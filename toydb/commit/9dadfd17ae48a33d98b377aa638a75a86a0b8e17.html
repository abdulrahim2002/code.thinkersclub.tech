<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Split out storage engine module. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/9dadfd17ae48a33d98b377aa638a75a86a0b8e17.html">9dadfd17ae48a33d98b377aa638a75a86a0b8e17</a>
<b>parent</b> <a href="../commit/786452e3dc51a186b1dc7f756fd3dc3b6018eb8c.html">786452e3dc51a186b1dc7f756fd3dc3b6018eb8c</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sat,  2 Sep 2023 21:04:33 +0200

Split out storage engine module.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">30</td><td><span class="i">+++++++++++++++</span><span class="d">---------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++++</span><span class="d">-------</span></td></tr>
<tr><td class="A">A</td><td><a href="#h2">src/storage/engine/bitcask.rs</a></td><td> | </td><td class="num">627</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="R">R</td><td><a href="#h3">src/storage/kv/golden/bitcask/compact-after -&gt; src/storage/engine/golden/bitcask/compact-after</a></td><td> | </td><td class="num">0</td><td><span class="i"></span><span class="d"></span></td></tr>
<tr><td class="R">R</td><td><a href="#h4">src/storage/kv/golden/bitcask/compact-before -&gt; src/storage/engine/golden/bitcask/compact-before</a></td><td> | </td><td class="num">0</td><td><span class="i"></span><span class="d"></span></td></tr>
<tr><td class="R">R</td><td><a href="#h5">src/storage/kv/golden/bitcask/log -&gt; src/storage/engine/golden/bitcask/log</a></td><td> | </td><td class="num">0</td><td><span class="i"></span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h6">src/storage/engine/memory.rs</a></td><td> | </td><td class="num">79</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h7">src/storage/engine/mod.rs</a></td><td> | </td><td class="num">294</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="D">D</td><td><a href="#h8">src/storage/kv/bitcask.rs</a></td><td> | </td><td class="num">627</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h9">src/storage/kv/memory.rs</a></td><td> | </td><td class="num">79</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/storage/kv/mod.rs</a></td><td> | </td><td class="num">296</td><td><span class="i">+</span><span class="d">------------------------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">src/storage/kv/mvcc.rs</a></td><td> | </td><td class="num">92</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">src/storage/mod.rs</a></td><td> | </td><td class="num">1</td><td><span class="i">+</span><span class="d"></span></td></tr>
</table></pre><pre>13 files changed, 1072 insertions(+), 1067 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -9,22 +9,22 @@ use std::borrow::Cow;
</a> use std::clone::Clone;
 use std::collections::HashSet;
 
<a href="#h0-0-3" id="h0-0-3" class="d">-/// A SQL engine based on an underlying MVCC key/value store
</a><a href="#h0-0-4" id="h0-0-4" class="d">-pub struct KV&lt;S: kv::Store&gt; {
</a><a href="#h0-0-5" id="h0-0-5" class="d">-    /// The underlying key/value store
</a><a href="#h0-0-6" id="h0-0-6" class="d">-    pub(super) kv: kv::MVCC&lt;S&gt;,
</a><a href="#h0-0-7" id="h0-0-7" class="i">+/// A SQL engine based on an underlying MVCC key/value store.
</a><a href="#h0-0-8" id="h0-0-8" class="i">+pub struct KV&lt;E: kv::Engine&gt; {
</a><a href="#h0-0-9" id="h0-0-9" class="i">+    /// The underlying key/value store.
</a><a href="#h0-0-10" id="h0-0-10" class="i">+    pub(super) kv: kv::MVCC&lt;E&gt;,
</a> }
 
 // FIXME Implement Clone manually due to https://github.com/rust-lang/rust/issues/26925
<a href="#h0-0-14" id="h0-0-14" class="d">-impl&lt;S: kv::Store&gt; Clone for KV&lt;S&gt; {
</a><a href="#h0-0-15" id="h0-0-15" class="i">+impl&lt;E: kv::Engine&gt; Clone for KV&lt;E&gt; {
</a>     fn clone(&amp;self) -&gt; Self {
         KV::new(self.kv.clone())
     }
 }
 
<a href="#h0-0-21" id="h0-0-21" class="d">-impl&lt;S: kv::Store&gt; KV&lt;S&gt; {
</a><a href="#h0-0-22" id="h0-0-22" class="i">+impl&lt;E: kv::Engine&gt; KV&lt;E&gt; {
</a>     /// Creates a new key/value-based SQL engine
<a href="#h0-0-24" id="h0-0-24" class="d">-    pub fn new(kv: kv::MVCC&lt;S&gt;) -&gt; Self {
</a><a href="#h0-0-25" id="h0-0-25" class="i">+    pub fn new(kv: kv::MVCC&lt;E&gt;) -&gt; Self {
</a>         Self { kv }
     }
 
<a href="#h0-1" id="h0-1" class="h">@@ -39,8 +39,8 @@ impl&lt;S: kv::Store&gt; KV&lt;S&gt; {
</a>     }
 }
 
<a href="#h0-1-3" id="h0-1-3" class="d">-impl&lt;S: kv::Store&gt; super::Engine for KV&lt;S&gt; {
</a><a href="#h0-1-4" id="h0-1-4" class="d">-    type Transaction = Transaction&lt;S&gt;;
</a><a href="#h0-1-5" id="h0-1-5" class="i">+impl&lt;E: kv::Engine&gt; super::Engine for KV&lt;E&gt; {
</a><a href="#h0-1-6" id="h0-1-6" class="i">+    type Transaction = Transaction&lt;E&gt;;
</a> 
     fn begin(&amp;self, mode: super::Mode) -&gt; Result&lt;Self::Transaction&gt; {
         Ok(Self::Transaction::new(self.kv.begin_with_mode(mode)?))
<a href="#h0-2" id="h0-2" class="h">@@ -62,13 +62,13 @@ fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a> }
 
 /// An SQL transaction based on an MVCC key/value transaction
<a href="#h0-2-3" id="h0-2-3" class="d">-pub struct Transaction&lt;S: kv::Store&gt; {
</a><a href="#h0-2-4" id="h0-2-4" class="d">-    txn: kv::mvcc::Transaction&lt;S&gt;,
</a><a href="#h0-2-5" id="h0-2-5" class="i">+pub struct Transaction&lt;E: kv::Engine&gt; {
</a><a href="#h0-2-6" id="h0-2-6" class="i">+    txn: kv::mvcc::Transaction&lt;E&gt;,
</a> }
 
<a href="#h0-2-9" id="h0-2-9" class="d">-impl&lt;S: kv::Store&gt; Transaction&lt;S&gt; {
</a><a href="#h0-2-10" id="h0-2-10" class="i">+impl&lt;E: kv::Engine&gt; Transaction&lt;E&gt; {
</a>     /// Creates a new SQL transaction from an MVCC transaction
<a href="#h0-2-12" id="h0-2-12" class="d">-    fn new(txn: kv::mvcc::Transaction&lt;S&gt;) -&gt; Self {
</a><a href="#h0-2-13" id="h0-2-13" class="i">+    fn new(txn: kv::mvcc::Transaction&lt;E&gt;) -&gt; Self {
</a>         Self { txn }
     }
 
<a href="#h0-3" id="h0-3" class="h">@@ -99,7 +99,7 @@ impl&lt;S: kv::Store&gt; Transaction&lt;S&gt; {
</a>     }
 }
 
<a href="#h0-3-3" id="h0-3-3" class="d">-impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a><a href="#h0-3-4" id="h0-3-4" class="i">+impl&lt;E: kv::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>     fn id(&amp;self) -&gt; u64 {
         self.txn.id()
     }
<a href="#h0-4" id="h0-4" class="h">@@ -270,7 +270,7 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>     }
 }
 
<a href="#h0-4-3" id="h0-4-3" class="d">-impl&lt;S: kv::Store&gt; Catalog for Transaction&lt;S&gt; {
</a><a href="#h0-4-4" id="h0-4-4" class="i">+impl&lt;E: kv::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>     fn create_table(&amp;mut self, table: Table) -&gt; Result&lt;()&gt; {
         if self.read_table(&amp;table.name)?.is_some() {
             return Err(Error::Value(format!(&quot;Table {} already exists&quot;, table.name)));
<b>diff --git a/<a id="h1" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -74,7 +74,7 @@ impl Raft {
</a>     }
 
     /// Creates an underlying state machine for a Raft engine.
<a href="#h1-0-3" id="h1-0-3" class="d">-    pub fn new_state&lt;S: kv::Store&gt;(kv: kv::MVCC&lt;S&gt;) -&gt; Result&lt;State&lt;S&gt;&gt; {
</a><a href="#h1-0-4" id="h1-0-4" class="i">+    pub fn new_state&lt;E: kv::Engine&gt;(kv: kv::MVCC&lt;E&gt;) -&gt; Result&lt;State&lt;E&gt;&gt; {
</a>         State::new(kv)
     }
 
<a href="#h1-1" id="h1-1" class="h">@@ -260,17 +260,17 @@ impl Catalog for Transaction {
</a> }
 
 /// The Raft state machine for the Raft-based SQL engine, using a KV SQL engine
<a href="#h1-1-3" id="h1-1-3" class="d">-pub struct State&lt;S: kv::Store&gt; {
</a><a href="#h1-1-4" id="h1-1-4" class="i">+pub struct State&lt;E: kv::Engine&gt; {
</a>     /// The underlying KV SQL engine
<a href="#h1-1-6" id="h1-1-6" class="d">-    engine: super::KV&lt;S&gt;,
</a><a href="#h1-1-7" id="h1-1-7" class="i">+    engine: super::KV&lt;E&gt;,
</a>     /// The last applied index
     applied_index: u64,
 }
 
<a href="#h1-1-12" id="h1-1-12" class="d">-impl&lt;S: kv::Store&gt; State&lt;S&gt; {
</a><a href="#h1-1-13" id="h1-1-13" class="i">+impl&lt;E: kv::Engine&gt; State&lt;E&gt; {
</a>     /// Creates a new Raft state maching using the given MVCC key/value store
<a href="#h1-1-15" id="h1-1-15" class="d">-    pub fn new(store: kv::MVCC&lt;S&gt;) -&gt; Result&lt;Self&gt; {
</a><a href="#h1-1-16" id="h1-1-16" class="d">-        let engine = super::KV::new(store);
</a><a href="#h1-1-17" id="h1-1-17" class="i">+    pub fn new(engine: kv::MVCC&lt;E&gt;) -&gt; Result&lt;Self&gt; {
</a><a href="#h1-1-18" id="h1-1-18" class="i">+        let engine = super::KV::new(engine);
</a>         let applied_index = engine
             .get_metadata(b&quot;applied_index&quot;)?
             .map(|b| Raft::deserialize(&amp;b))
<a href="#h1-2" id="h1-2" class="h">@@ -305,7 +305,7 @@ impl&lt;S: kv::Store&gt; State&lt;S&gt; {
</a>     }
 }
 
<a href="#h1-2-3" id="h1-2-3" class="d">-impl&lt;S: kv::Store&gt; raft::State for State&lt;S&gt; {
</a><a href="#h1-2-4" id="h1-2-4" class="i">+impl&lt;E: kv::Engine&gt; raft::State for State&lt;E&gt; {
</a>     fn applied_index(&amp;self) -&gt; u64 {
         self.applied_index
     }
<b>diff --git a/<a id="h2" href="../file/src/storage/engine/bitcask.rs.html">src/storage/engine/bitcask.rs</a> b/<a href="../file/src/storage/engine/bitcask.rs.html">src/storage/engine/bitcask.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -0,0 +1,627 @@
</a><a href="#h2-0-0" id="h2-0-0" class="i">+use super::Engine;
</a><a href="#h2-0-1" id="h2-0-1" class="i">+use crate::error::Result;
</a><a href="#h2-0-2" id="h2-0-2" class="i">+
</a><a href="#h2-0-3" id="h2-0-3" class="i">+use fs4::FileExt;
</a><a href="#h2-0-4" id="h2-0-4" class="i">+use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, Write};
</a><a href="#h2-0-5" id="h2-0-5" class="i">+use std::path::PathBuf;
</a><a href="#h2-0-6" id="h2-0-6" class="i">+
</a><a href="#h2-0-7" id="h2-0-7" class="i">+/// A very simple variant of BitCask, itself a very simple log-structured
</a><a href="#h2-0-8" id="h2-0-8" class="i">+/// key-value engine used e.g. by the Riak database. It is not compatible with
</a><a href="#h2-0-9" id="h2-0-9" class="i">+/// BitCask databases generated by other implementations. See:
</a><a href="#h2-0-10" id="h2-0-10" class="i">+/// https://riak.com/assets/bitcask-intro.pdf
</a><a href="#h2-0-11" id="h2-0-11" class="i">+///
</a><a href="#h2-0-12" id="h2-0-12" class="i">+/// BitCask writes key-value pairs to an append-only log file, and keeps a
</a><a href="#h2-0-13" id="h2-0-13" class="i">+/// mapping of keys to file positions in memory. All live keys must fit in
</a><a href="#h2-0-14" id="h2-0-14" class="i">+/// memory. Deletes write a tombstone value to the log file. To remove old
</a><a href="#h2-0-15" id="h2-0-15" class="i">+/// garbage, logs can be compacted by writing new logs containing only live
</a><a href="#h2-0-16" id="h2-0-16" class="i">+/// data, skipping replaced values and tombstones.
</a><a href="#h2-0-17" id="h2-0-17" class="i">+///
</a><a href="#h2-0-18" id="h2-0-18" class="i">+/// This implementation makes several significant simplifications over
</a><a href="#h2-0-19" id="h2-0-19" class="i">+/// standard BitCask:
</a><a href="#h2-0-20" id="h2-0-20" class="i">+///
</a><a href="#h2-0-21" id="h2-0-21" class="i">+/// - Instead of writing multiple fixed-size log files, it uses a single
</a><a href="#h2-0-22" id="h2-0-22" class="i">+///   append-only log file of arbitrary size. This increases the compaction
</a><a href="#h2-0-23" id="h2-0-23" class="i">+///   volume, since the entire log file must be rewritten on every compaction,
</a><a href="#h2-0-24" id="h2-0-24" class="i">+///   and can exceed the filesystem&#39;s file size limit, but ToyDB databases are
</a><a href="#h2-0-25" id="h2-0-25" class="i">+///   expected to be small.
</a><a href="#h2-0-26" id="h2-0-26" class="i">+///
</a><a href="#h2-0-27" id="h2-0-27" class="i">+/// - Compactions lock the database for reads and writes. This is ok since ToyDB
</a><a href="#h2-0-28" id="h2-0-28" class="i">+///   only compacts during node startup and files are expected to be small.
</a><a href="#h2-0-29" id="h2-0-29" class="i">+///
</a><a href="#h2-0-30" id="h2-0-30" class="i">+/// - Hint files are not used, the log itself is scanned when opened to
</a><a href="#h2-0-31" id="h2-0-31" class="i">+///   build the keydir. Hint files only omit values, and ToyDB values are
</a><a href="#h2-0-32" id="h2-0-32" class="i">+///   expected to be small, so the hint files would be nearly as large as
</a><a href="#h2-0-33" id="h2-0-33" class="i">+///   the compacted log files themselves.
</a><a href="#h2-0-34" id="h2-0-34" class="i">+///
</a><a href="#h2-0-35" id="h2-0-35" class="i">+/// - Log entries don&#39;t contain timestamps or checksums.
</a><a href="#h2-0-36" id="h2-0-36" class="i">+///
</a><a href="#h2-0-37" id="h2-0-37" class="i">+/// The structure of a log entry is:
</a><a href="#h2-0-38" id="h2-0-38" class="i">+///
</a><a href="#h2-0-39" id="h2-0-39" class="i">+/// - Key length as big-endian u32
</a><a href="#h2-0-40" id="h2-0-40" class="i">+/// - Value length as big-endian i32, or -1 for tombstones
</a><a href="#h2-0-41" id="h2-0-41" class="i">+/// - Key as raw bytes (max 2 GB)
</a><a href="#h2-0-42" id="h2-0-42" class="i">+/// - Value as raw bytes (max 2 GB)
</a><a href="#h2-0-43" id="h2-0-43" class="i">+pub struct BitCask {
</a><a href="#h2-0-44" id="h2-0-44" class="i">+    /// The active append-only log file.
</a><a href="#h2-0-45" id="h2-0-45" class="i">+    log: Log,
</a><a href="#h2-0-46" id="h2-0-46" class="i">+    /// Maps keys to a value position and length in the log file.
</a><a href="#h2-0-47" id="h2-0-47" class="i">+    keydir: KeyDir,
</a><a href="#h2-0-48" id="h2-0-48" class="i">+}
</a><a href="#h2-0-49" id="h2-0-49" class="i">+
</a><a href="#h2-0-50" id="h2-0-50" class="i">+/// Maps keys to a value position and length in the log file.
</a><a href="#h2-0-51" id="h2-0-51" class="i">+type KeyDir = std::collections::BTreeMap&lt;Vec&lt;u8&gt;, (u64, u32)&gt;;
</a><a href="#h2-0-52" id="h2-0-52" class="i">+
</a><a href="#h2-0-53" id="h2-0-53" class="i">+impl BitCask {
</a><a href="#h2-0-54" id="h2-0-54" class="i">+    /// Opens or creates a BitCask database in the given file.
</a><a href="#h2-0-55" id="h2-0-55" class="i">+    pub fn new(path: PathBuf) -&gt; Result&lt;Self&gt; {
</a><a href="#h2-0-56" id="h2-0-56" class="i">+        let mut log = Log::new(path)?;
</a><a href="#h2-0-57" id="h2-0-57" class="i">+        let keydir = log.build_keydir()?;
</a><a href="#h2-0-58" id="h2-0-58" class="i">+        Ok(Self { log, keydir })
</a><a href="#h2-0-59" id="h2-0-59" class="i">+    }
</a><a href="#h2-0-60" id="h2-0-60" class="i">+
</a><a href="#h2-0-61" id="h2-0-61" class="i">+    /// Opens a BitCask database, and automatically compacts it if the amount
</a><a href="#h2-0-62" id="h2-0-62" class="i">+    /// of garbage exceeds the given ratio when opened.
</a><a href="#h2-0-63" id="h2-0-63" class="i">+    pub fn new_compact(path: PathBuf, garbage_ratio_threshold: f64) -&gt; Result&lt;Self&gt; {
</a><a href="#h2-0-64" id="h2-0-64" class="i">+        let mut s = Self::new(path)?;
</a><a href="#h2-0-65" id="h2-0-65" class="i">+
</a><a href="#h2-0-66" id="h2-0-66" class="i">+        let (live_bytes, total_bytes) = s.compute_sizes()?;
</a><a href="#h2-0-67" id="h2-0-67" class="i">+        let garbage_bytes = total_bytes - live_bytes;
</a><a href="#h2-0-68" id="h2-0-68" class="i">+        let garbage_ratio = garbage_bytes as f64 / total_bytes as f64;
</a><a href="#h2-0-69" id="h2-0-69" class="i">+        if garbage_bytes &gt; 0 &amp;&amp; garbage_ratio &gt;= garbage_ratio_threshold {
</a><a href="#h2-0-70" id="h2-0-70" class="i">+            log::info!(
</a><a href="#h2-0-71" id="h2-0-71" class="i">+                &quot;Compacting {} to remove {:.1}MB garbage ({:.0}% of {:.1}MB)&quot;,
</a><a href="#h2-0-72" id="h2-0-72" class="i">+                s.log.path.display(),
</a><a href="#h2-0-73" id="h2-0-73" class="i">+                garbage_bytes / 1024 / 1024,
</a><a href="#h2-0-74" id="h2-0-74" class="i">+                garbage_ratio * 100.0,
</a><a href="#h2-0-75" id="h2-0-75" class="i">+                total_bytes / 1024 / 1024
</a><a href="#h2-0-76" id="h2-0-76" class="i">+            );
</a><a href="#h2-0-77" id="h2-0-77" class="i">+            s.compact()?;
</a><a href="#h2-0-78" id="h2-0-78" class="i">+            log::info!(
</a><a href="#h2-0-79" id="h2-0-79" class="i">+                &quot;Compacted {} to size {:.1}MB&quot;,
</a><a href="#h2-0-80" id="h2-0-80" class="i">+                s.log.path.display(),
</a><a href="#h2-0-81" id="h2-0-81" class="i">+                live_bytes / 1024 / 1024
</a><a href="#h2-0-82" id="h2-0-82" class="i">+            );
</a><a href="#h2-0-83" id="h2-0-83" class="i">+        }
</a><a href="#h2-0-84" id="h2-0-84" class="i">+
</a><a href="#h2-0-85" id="h2-0-85" class="i">+        Ok(s)
</a><a href="#h2-0-86" id="h2-0-86" class="i">+    }
</a><a href="#h2-0-87" id="h2-0-87" class="i">+}
</a><a href="#h2-0-88" id="h2-0-88" class="i">+
</a><a href="#h2-0-89" id="h2-0-89" class="i">+impl std::fmt::Display for BitCask {
</a><a href="#h2-0-90" id="h2-0-90" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h2-0-91" id="h2-0-91" class="i">+        write!(f, &quot;bitcask&quot;)
</a><a href="#h2-0-92" id="h2-0-92" class="i">+    }
</a><a href="#h2-0-93" id="h2-0-93" class="i">+}
</a><a href="#h2-0-94" id="h2-0-94" class="i">+
</a><a href="#h2-0-95" id="h2-0-95" class="i">+impl Engine for BitCask {
</a><a href="#h2-0-96" id="h2-0-96" class="i">+    type ScanIterator&lt;&#39;a&gt; = ScanIterator&lt;&#39;a&gt;;
</a><a href="#h2-0-97" id="h2-0-97" class="i">+
</a><a href="#h2-0-98" id="h2-0-98" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-99" id="h2-0-99" class="i">+        self.log.write_entry(key, None)?;
</a><a href="#h2-0-100" id="h2-0-100" class="i">+        self.keydir.remove(key);
</a><a href="#h2-0-101" id="h2-0-101" class="i">+        Ok(())
</a><a href="#h2-0-102" id="h2-0-102" class="i">+    }
</a><a href="#h2-0-103" id="h2-0-103" class="i">+
</a><a href="#h2-0-104" id="h2-0-104" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-105" id="h2-0-105" class="i">+        Ok(self.log.file.sync_all()?)
</a><a href="#h2-0-106" id="h2-0-106" class="i">+    }
</a><a href="#h2-0-107" id="h2-0-107" class="i">+
</a><a href="#h2-0-108" id="h2-0-108" class="i">+    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h2-0-109" id="h2-0-109" class="i">+        if let Some((value_pos, value_len)) = self.keydir.get(key) {
</a><a href="#h2-0-110" id="h2-0-110" class="i">+            Ok(Some(self.log.read_value(*value_pos, *value_len)?))
</a><a href="#h2-0-111" id="h2-0-111" class="i">+        } else {
</a><a href="#h2-0-112" id="h2-0-112" class="i">+            Ok(None)
</a><a href="#h2-0-113" id="h2-0-113" class="i">+        }
</a><a href="#h2-0-114" id="h2-0-114" class="i">+    }
</a><a href="#h2-0-115" id="h2-0-115" class="i">+
</a><a href="#h2-0-116" id="h2-0-116" class="i">+    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h2-0-117" id="h2-0-117" class="i">+        ScanIterator { inner: self.keydir.range(range), log: &amp;mut self.log }
</a><a href="#h2-0-118" id="h2-0-118" class="i">+    }
</a><a href="#h2-0-119" id="h2-0-119" class="i">+
</a><a href="#h2-0-120" id="h2-0-120" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-121" id="h2-0-121" class="i">+        let (pos, len) = self.log.write_entry(key, Some(&amp;*value))?;
</a><a href="#h2-0-122" id="h2-0-122" class="i">+        let value_len = value.len() as u32;
</a><a href="#h2-0-123" id="h2-0-123" class="i">+        self.keydir.insert(key.to_vec(), (pos + len as u64 - value_len as u64, value_len));
</a><a href="#h2-0-124" id="h2-0-124" class="i">+        Ok(())
</a><a href="#h2-0-125" id="h2-0-125" class="i">+    }
</a><a href="#h2-0-126" id="h2-0-126" class="i">+}
</a><a href="#h2-0-127" id="h2-0-127" class="i">+
</a><a href="#h2-0-128" id="h2-0-128" class="i">+pub struct ScanIterator&lt;&#39;a&gt; {
</a><a href="#h2-0-129" id="h2-0-129" class="i">+    inner: std::collections::btree_map::Range&lt;&#39;a, Vec&lt;u8&gt;, (u64, u32)&gt;,
</a><a href="#h2-0-130" id="h2-0-130" class="i">+    log: &amp;&#39;a mut Log,
</a><a href="#h2-0-131" id="h2-0-131" class="i">+}
</a><a href="#h2-0-132" id="h2-0-132" class="i">+
</a><a href="#h2-0-133" id="h2-0-133" class="i">+impl&lt;&#39;a&gt; ScanIterator&lt;&#39;a&gt; {
</a><a href="#h2-0-134" id="h2-0-134" class="i">+    fn map(&amp;mut self, item: (&amp;Vec&lt;u8&gt;, &amp;(u64, u32))) -&gt; &lt;Self as Iterator&gt;::Item {
</a><a href="#h2-0-135" id="h2-0-135" class="i">+        let (key, (value_pos, value_len)) = item;
</a><a href="#h2-0-136" id="h2-0-136" class="i">+        Ok((key.clone(), self.log.read_value(*value_pos, *value_len)?))
</a><a href="#h2-0-137" id="h2-0-137" class="i">+    }
</a><a href="#h2-0-138" id="h2-0-138" class="i">+}
</a><a href="#h2-0-139" id="h2-0-139" class="i">+
</a><a href="#h2-0-140" id="h2-0-140" class="i">+impl&lt;&#39;a&gt; Iterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h2-0-141" id="h2-0-141" class="i">+    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a><a href="#h2-0-142" id="h2-0-142" class="i">+
</a><a href="#h2-0-143" id="h2-0-143" class="i">+    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h2-0-144" id="h2-0-144" class="i">+        self.inner.next().map(|item| self.map(item))
</a><a href="#h2-0-145" id="h2-0-145" class="i">+    }
</a><a href="#h2-0-146" id="h2-0-146" class="i">+}
</a><a href="#h2-0-147" id="h2-0-147" class="i">+
</a><a href="#h2-0-148" id="h2-0-148" class="i">+impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h2-0-149" id="h2-0-149" class="i">+    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h2-0-150" id="h2-0-150" class="i">+        self.inner.next_back().map(|item| self.map(item))
</a><a href="#h2-0-151" id="h2-0-151" class="i">+    }
</a><a href="#h2-0-152" id="h2-0-152" class="i">+}
</a><a href="#h2-0-153" id="h2-0-153" class="i">+
</a><a href="#h2-0-154" id="h2-0-154" class="i">+impl BitCask {
</a><a href="#h2-0-155" id="h2-0-155" class="i">+    /// Compacts the current log file by writing out a new log file containing
</a><a href="#h2-0-156" id="h2-0-156" class="i">+    /// only live keys and replacing the current file with it.
</a><a href="#h2-0-157" id="h2-0-157" class="i">+    pub fn compact(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-158" id="h2-0-158" class="i">+        let mut tmp_path = self.log.path.clone();
</a><a href="#h2-0-159" id="h2-0-159" class="i">+        tmp_path.set_extension(&quot;new&quot;);
</a><a href="#h2-0-160" id="h2-0-160" class="i">+        let (mut new_log, new_keydir) = self.write_log(tmp_path)?;
</a><a href="#h2-0-161" id="h2-0-161" class="i">+
</a><a href="#h2-0-162" id="h2-0-162" class="i">+        std::fs::rename(&amp;new_log.path, &amp;self.log.path)?;
</a><a href="#h2-0-163" id="h2-0-163" class="i">+        new_log.path = self.log.path.clone();
</a><a href="#h2-0-164" id="h2-0-164" class="i">+
</a><a href="#h2-0-165" id="h2-0-165" class="i">+        self.log = new_log;
</a><a href="#h2-0-166" id="h2-0-166" class="i">+        self.keydir = new_keydir;
</a><a href="#h2-0-167" id="h2-0-167" class="i">+        Ok(())
</a><a href="#h2-0-168" id="h2-0-168" class="i">+    }
</a><a href="#h2-0-169" id="h2-0-169" class="i">+
</a><a href="#h2-0-170" id="h2-0-170" class="i">+    /// Computes the live and total sizes of the log file, by iterating over the
</a><a href="#h2-0-171" id="h2-0-171" class="i">+    /// keydir and fetching the file&#39;s size from the filesystem metadata. The
</a><a href="#h2-0-172" id="h2-0-172" class="i">+    /// garbage size (i.e. old, replaced entries and tombstones) is the
</a><a href="#h2-0-173" id="h2-0-173" class="i">+    /// difference between these values.
</a><a href="#h2-0-174" id="h2-0-174" class="i">+    ///
</a><a href="#h2-0-175" id="h2-0-175" class="i">+    /// We could keep track of these values during mutations, but it&#39;s not
</a><a href="#h2-0-176" id="h2-0-176" class="i">+    /// currently needed -- we only use this to determine whether to compact the
</a><a href="#h2-0-177" id="h2-0-177" class="i">+    /// database when it&#39;s initially opened, so we&#39;d need to run basically the
</a><a href="#h2-0-178" id="h2-0-178" class="i">+    /// same computations anyway.
</a><a href="#h2-0-179" id="h2-0-179" class="i">+    pub fn compute_sizes(&amp;mut self) -&gt; Result&lt;(u64, u64)&gt; {
</a><a href="#h2-0-180" id="h2-0-180" class="i">+        let total_size = self.log.file.metadata()?.len();
</a><a href="#h2-0-181" id="h2-0-181" class="i">+        let live_size = self.keydir.iter().fold(0, |size, (key, (_, value_len))| {
</a><a href="#h2-0-182" id="h2-0-182" class="i">+            size + 4 + 4 + key.len() as u64 + *value_len as u64
</a><a href="#h2-0-183" id="h2-0-183" class="i">+        });
</a><a href="#h2-0-184" id="h2-0-184" class="i">+        Ok((live_size, total_size))
</a><a href="#h2-0-185" id="h2-0-185" class="i">+    }
</a><a href="#h2-0-186" id="h2-0-186" class="i">+
</a><a href="#h2-0-187" id="h2-0-187" class="i">+    /// Writes out a new log file with the live entries of the current log file
</a><a href="#h2-0-188" id="h2-0-188" class="i">+    /// and returns it along with its keydir. Entries are written in key order.
</a><a href="#h2-0-189" id="h2-0-189" class="i">+    fn write_log(&amp;mut self, path: PathBuf) -&gt; Result&lt;(Log, KeyDir)&gt; {
</a><a href="#h2-0-190" id="h2-0-190" class="i">+        let mut new_keydir = KeyDir::new();
</a><a href="#h2-0-191" id="h2-0-191" class="i">+        let mut new_log = Log::new(path)?;
</a><a href="#h2-0-192" id="h2-0-192" class="i">+        new_log.file.set_len(0)?; // truncate file if it exists
</a><a href="#h2-0-193" id="h2-0-193" class="i">+        for (key, (value_pos, value_len)) in self.keydir.iter() {
</a><a href="#h2-0-194" id="h2-0-194" class="i">+            let value = self.log.read_value(*value_pos, *value_len)?;
</a><a href="#h2-0-195" id="h2-0-195" class="i">+            let (pos, len) = new_log.write_entry(key, Some(&amp;value))?;
</a><a href="#h2-0-196" id="h2-0-196" class="i">+            new_keydir.insert(key.clone(), (pos + len as u64 - *value_len as u64, *value_len));
</a><a href="#h2-0-197" id="h2-0-197" class="i">+        }
</a><a href="#h2-0-198" id="h2-0-198" class="i">+        Ok((new_log, new_keydir))
</a><a href="#h2-0-199" id="h2-0-199" class="i">+    }
</a><a href="#h2-0-200" id="h2-0-200" class="i">+}
</a><a href="#h2-0-201" id="h2-0-201" class="i">+
</a><a href="#h2-0-202" id="h2-0-202" class="i">+/// Attempt to flush the file when the database is closed.
</a><a href="#h2-0-203" id="h2-0-203" class="i">+impl Drop for BitCask {
</a><a href="#h2-0-204" id="h2-0-204" class="i">+    fn drop(&amp;mut self) {
</a><a href="#h2-0-205" id="h2-0-205" class="i">+        if let Err(error) = self.flush() {
</a><a href="#h2-0-206" id="h2-0-206" class="i">+            log::error!(&quot;failed to flush file: {}&quot;, error)
</a><a href="#h2-0-207" id="h2-0-207" class="i">+        }
</a><a href="#h2-0-208" id="h2-0-208" class="i">+    }
</a><a href="#h2-0-209" id="h2-0-209" class="i">+}
</a><a href="#h2-0-210" id="h2-0-210" class="i">+
</a><a href="#h2-0-211" id="h2-0-211" class="i">+/// A BitCask append-only log file, containing a sequence of key/value
</a><a href="#h2-0-212" id="h2-0-212" class="i">+/// entries encoded as follows;
</a><a href="#h2-0-213" id="h2-0-213" class="i">+///
</a><a href="#h2-0-214" id="h2-0-214" class="i">+/// - Key length as big-endian u64 (8 bytes)
</a><a href="#h2-0-215" id="h2-0-215" class="i">+/// - Value length as big-endian i64, or -1 for tombstones (8 bytes)
</a><a href="#h2-0-216" id="h2-0-216" class="i">+/// - Key as raw bytes
</a><a href="#h2-0-217" id="h2-0-217" class="i">+/// - Value as raw bytes
</a><a href="#h2-0-218" id="h2-0-218" class="i">+struct Log {
</a><a href="#h2-0-219" id="h2-0-219" class="i">+    /// Path to the log file.
</a><a href="#h2-0-220" id="h2-0-220" class="i">+    path: PathBuf,
</a><a href="#h2-0-221" id="h2-0-221" class="i">+    /// The opened file containing the log.
</a><a href="#h2-0-222" id="h2-0-222" class="i">+    file: std::fs::File,
</a><a href="#h2-0-223" id="h2-0-223" class="i">+}
</a><a href="#h2-0-224" id="h2-0-224" class="i">+
</a><a href="#h2-0-225" id="h2-0-225" class="i">+impl Log {
</a><a href="#h2-0-226" id="h2-0-226" class="i">+    /// Opens a log file, or creates one if it does not exist. Takes out an
</a><a href="#h2-0-227" id="h2-0-227" class="i">+    /// exclusive lock on the file until it is closed, or errors if the lock is
</a><a href="#h2-0-228" id="h2-0-228" class="i">+    /// already held.
</a><a href="#h2-0-229" id="h2-0-229" class="i">+    fn new(path: PathBuf) -&gt; Result&lt;Self&gt; {
</a><a href="#h2-0-230" id="h2-0-230" class="i">+        if let Some(dir) = path.parent() {
</a><a href="#h2-0-231" id="h2-0-231" class="i">+            std::fs::create_dir_all(dir)?
</a><a href="#h2-0-232" id="h2-0-232" class="i">+        }
</a><a href="#h2-0-233" id="h2-0-233" class="i">+        let file = std::fs::OpenOptions::new().read(true).write(true).create(true).open(&amp;path)?;
</a><a href="#h2-0-234" id="h2-0-234" class="i">+        file.try_lock_exclusive()?;
</a><a href="#h2-0-235" id="h2-0-235" class="i">+        Ok(Self { path, file })
</a><a href="#h2-0-236" id="h2-0-236" class="i">+    }
</a><a href="#h2-0-237" id="h2-0-237" class="i">+
</a><a href="#h2-0-238" id="h2-0-238" class="i">+    /// Builds a keydir by scanning the log file. If an incomplete entry is
</a><a href="#h2-0-239" id="h2-0-239" class="i">+    /// encountered, it is assumed to be caused by an incomplete write operation
</a><a href="#h2-0-240" id="h2-0-240" class="i">+    /// and the remainder of the file is truncated.
</a><a href="#h2-0-241" id="h2-0-241" class="i">+    fn build_keydir(&amp;mut self) -&gt; Result&lt;KeyDir&gt; {
</a><a href="#h2-0-242" id="h2-0-242" class="i">+        let mut len_buf = [0u8; 4];
</a><a href="#h2-0-243" id="h2-0-243" class="i">+        let mut keydir = KeyDir::new();
</a><a href="#h2-0-244" id="h2-0-244" class="i">+        let file_len = self.file.metadata()?.len();
</a><a href="#h2-0-245" id="h2-0-245" class="i">+        let mut r = BufReader::new(&amp;mut self.file);
</a><a href="#h2-0-246" id="h2-0-246" class="i">+        let mut pos = r.seek(SeekFrom::Start(0))?;
</a><a href="#h2-0-247" id="h2-0-247" class="i">+
</a><a href="#h2-0-248" id="h2-0-248" class="i">+        while pos &lt; file_len {
</a><a href="#h2-0-249" id="h2-0-249" class="i">+            // Read the next entry from the file, returning the key, value
</a><a href="#h2-0-250" id="h2-0-250" class="i">+            // position, and value length or None for tombstones.
</a><a href="#h2-0-251" id="h2-0-251" class="i">+            let result = || -&gt; std::result::Result&lt;(Vec&lt;u8&gt;, u64, Option&lt;u32&gt;), std::io::Error&gt; {
</a><a href="#h2-0-252" id="h2-0-252" class="i">+                r.read_exact(&amp;mut len_buf)?;
</a><a href="#h2-0-253" id="h2-0-253" class="i">+                let key_len = u32::from_be_bytes(len_buf);
</a><a href="#h2-0-254" id="h2-0-254" class="i">+                r.read_exact(&amp;mut len_buf)?;
</a><a href="#h2-0-255" id="h2-0-255" class="i">+                let value_len_or_tombstone = match i32::from_be_bytes(len_buf) {
</a><a href="#h2-0-256" id="h2-0-256" class="i">+                    l if l &gt;= 0 =&gt; Some(l as u32),
</a><a href="#h2-0-257" id="h2-0-257" class="i">+                    _ =&gt; None, // -1 for tombstones
</a><a href="#h2-0-258" id="h2-0-258" class="i">+                };
</a><a href="#h2-0-259" id="h2-0-259" class="i">+                let value_pos = pos + 4 + 4 + key_len as u64;
</a><a href="#h2-0-260" id="h2-0-260" class="i">+
</a><a href="#h2-0-261" id="h2-0-261" class="i">+                let mut key = vec![0; key_len as usize];
</a><a href="#h2-0-262" id="h2-0-262" class="i">+                r.read_exact(&amp;mut key)?;
</a><a href="#h2-0-263" id="h2-0-263" class="i">+
</a><a href="#h2-0-264" id="h2-0-264" class="i">+                if let Some(value_len) = value_len_or_tombstone {
</a><a href="#h2-0-265" id="h2-0-265" class="i">+                    if value_pos + value_len as u64 &gt; file_len {
</a><a href="#h2-0-266" id="h2-0-266" class="i">+                        return Err(std::io::Error::new(
</a><a href="#h2-0-267" id="h2-0-267" class="i">+                            std::io::ErrorKind::UnexpectedEof,
</a><a href="#h2-0-268" id="h2-0-268" class="i">+                            &quot;value extends beyond end of file&quot;,
</a><a href="#h2-0-269" id="h2-0-269" class="i">+                        ));
</a><a href="#h2-0-270" id="h2-0-270" class="i">+                    }
</a><a href="#h2-0-271" id="h2-0-271" class="i">+                    r.seek_relative(value_len as i64)?; // avoids discarding buffer
</a><a href="#h2-0-272" id="h2-0-272" class="i">+                }
</a><a href="#h2-0-273" id="h2-0-273" class="i">+
</a><a href="#h2-0-274" id="h2-0-274" class="i">+                Ok((key, value_pos, value_len_or_tombstone))
</a><a href="#h2-0-275" id="h2-0-275" class="i">+            }();
</a><a href="#h2-0-276" id="h2-0-276" class="i">+
</a><a href="#h2-0-277" id="h2-0-277" class="i">+            match result {
</a><a href="#h2-0-278" id="h2-0-278" class="i">+                // Populate the keydir with the entry, or remove it on tombstones.
</a><a href="#h2-0-279" id="h2-0-279" class="i">+                Ok((key, value_pos, Some(value_len))) =&gt; {
</a><a href="#h2-0-280" id="h2-0-280" class="i">+                    keydir.insert(key, (value_pos, value_len));
</a><a href="#h2-0-281" id="h2-0-281" class="i">+                    pos = value_pos + value_len as u64;
</a><a href="#h2-0-282" id="h2-0-282" class="i">+                }
</a><a href="#h2-0-283" id="h2-0-283" class="i">+                Ok((key, value_pos, None)) =&gt; {
</a><a href="#h2-0-284" id="h2-0-284" class="i">+                    keydir.remove(&amp;key);
</a><a href="#h2-0-285" id="h2-0-285" class="i">+                    pos = value_pos;
</a><a href="#h2-0-286" id="h2-0-286" class="i">+                }
</a><a href="#h2-0-287" id="h2-0-287" class="i">+                // If an incomplete entry was found at the end of the file, assume an
</a><a href="#h2-0-288" id="h2-0-288" class="i">+                // incomplete write and truncate the file.
</a><a href="#h2-0-289" id="h2-0-289" class="i">+                Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof =&gt; {
</a><a href="#h2-0-290" id="h2-0-290" class="i">+                    log::error!(&quot;Found incomplete entry at offset {}, truncating file&quot;, pos);
</a><a href="#h2-0-291" id="h2-0-291" class="i">+                    self.file.set_len(pos)?;
</a><a href="#h2-0-292" id="h2-0-292" class="i">+                    break;
</a><a href="#h2-0-293" id="h2-0-293" class="i">+                }
</a><a href="#h2-0-294" id="h2-0-294" class="i">+                Err(err) =&gt; return Err(err.into()),
</a><a href="#h2-0-295" id="h2-0-295" class="i">+            }
</a><a href="#h2-0-296" id="h2-0-296" class="i">+        }
</a><a href="#h2-0-297" id="h2-0-297" class="i">+
</a><a href="#h2-0-298" id="h2-0-298" class="i">+        Ok(keydir)
</a><a href="#h2-0-299" id="h2-0-299" class="i">+    }
</a><a href="#h2-0-300" id="h2-0-300" class="i">+
</a><a href="#h2-0-301" id="h2-0-301" class="i">+    /// Reads a value from the log file.
</a><a href="#h2-0-302" id="h2-0-302" class="i">+    fn read_value(&amp;mut self, value_pos: u64, value_len: u32) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-0-303" id="h2-0-303" class="i">+        let mut value = vec![0; value_len as usize];
</a><a href="#h2-0-304" id="h2-0-304" class="i">+        self.file.seek(SeekFrom::Start(value_pos))?;
</a><a href="#h2-0-305" id="h2-0-305" class="i">+        self.file.read_exact(&amp;mut value)?;
</a><a href="#h2-0-306" id="h2-0-306" class="i">+        Ok(value)
</a><a href="#h2-0-307" id="h2-0-307" class="i">+    }
</a><a href="#h2-0-308" id="h2-0-308" class="i">+
</a><a href="#h2-0-309" id="h2-0-309" class="i">+    /// Appends a key/value entry to the log file, using a None value for
</a><a href="#h2-0-310" id="h2-0-310" class="i">+    /// tombstones. It returns the position and length of the entry.
</a><a href="#h2-0-311" id="h2-0-311" class="i">+    fn write_entry(&amp;mut self, key: &amp;[u8], value: Option&lt;&amp;[u8]&gt;) -&gt; Result&lt;(u64, u32)&gt; {
</a><a href="#h2-0-312" id="h2-0-312" class="i">+        let key_len = key.len() as u32;
</a><a href="#h2-0-313" id="h2-0-313" class="i">+        let value_len = value.map_or(0, |v| v.len() as u32);
</a><a href="#h2-0-314" id="h2-0-314" class="i">+        let value_len_or_tombstone = value.map_or(-1, |v| v.len() as i32);
</a><a href="#h2-0-315" id="h2-0-315" class="i">+        let len = 4 + 4 + key_len + value_len;
</a><a href="#h2-0-316" id="h2-0-316" class="i">+
</a><a href="#h2-0-317" id="h2-0-317" class="i">+        let pos = self.file.seek(SeekFrom::End(0))?;
</a><a href="#h2-0-318" id="h2-0-318" class="i">+        let mut w = BufWriter::with_capacity(len as usize, &amp;mut self.file);
</a><a href="#h2-0-319" id="h2-0-319" class="i">+        w.write_all(&amp;key_len.to_be_bytes())?;
</a><a href="#h2-0-320" id="h2-0-320" class="i">+        w.write_all(&amp;value_len_or_tombstone.to_be_bytes())?;
</a><a href="#h2-0-321" id="h2-0-321" class="i">+        w.write_all(key)?;
</a><a href="#h2-0-322" id="h2-0-322" class="i">+        if let Some(value) = value {
</a><a href="#h2-0-323" id="h2-0-323" class="i">+            w.write_all(value)?;
</a><a href="#h2-0-324" id="h2-0-324" class="i">+        }
</a><a href="#h2-0-325" id="h2-0-325" class="i">+        w.flush()?;
</a><a href="#h2-0-326" id="h2-0-326" class="i">+
</a><a href="#h2-0-327" id="h2-0-327" class="i">+        Ok((pos, len))
</a><a href="#h2-0-328" id="h2-0-328" class="i">+    }
</a><a href="#h2-0-329" id="h2-0-329" class="i">+
</a><a href="#h2-0-330" id="h2-0-330" class="i">+    #[cfg(test)]
</a><a href="#h2-0-331" id="h2-0-331" class="i">+    /// Prints the entire log file to the given writer in human-readable form.
</a><a href="#h2-0-332" id="h2-0-332" class="i">+    fn print&lt;W: Write&gt;(&amp;mut self, w: &amp;mut W) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-333" id="h2-0-333" class="i">+        let mut len_buf = [0u8; 4];
</a><a href="#h2-0-334" id="h2-0-334" class="i">+        let file_len = self.file.metadata()?.len();
</a><a href="#h2-0-335" id="h2-0-335" class="i">+        let mut r = BufReader::new(&amp;mut self.file);
</a><a href="#h2-0-336" id="h2-0-336" class="i">+        let mut pos = r.seek(SeekFrom::Start(0))?;
</a><a href="#h2-0-337" id="h2-0-337" class="i">+        let mut idx = 0;
</a><a href="#h2-0-338" id="h2-0-338" class="i">+
</a><a href="#h2-0-339" id="h2-0-339" class="i">+        while pos &lt; file_len {
</a><a href="#h2-0-340" id="h2-0-340" class="i">+            writeln!(w, &quot;entry = {}, offset {}&quot;, idx, pos)?;
</a><a href="#h2-0-341" id="h2-0-341" class="i">+
</a><a href="#h2-0-342" id="h2-0-342" class="i">+            r.read_exact(&amp;mut len_buf)?;
</a><a href="#h2-0-343" id="h2-0-343" class="i">+            let key_len = u32::from_be_bytes(len_buf);
</a><a href="#h2-0-344" id="h2-0-344" class="i">+            writeln!(w, &quot;klen  = {} {:x?}&quot;, key_len, len_buf)?;
</a><a href="#h2-0-345" id="h2-0-345" class="i">+
</a><a href="#h2-0-346" id="h2-0-346" class="i">+            r.read_exact(&amp;mut len_buf)?;
</a><a href="#h2-0-347" id="h2-0-347" class="i">+            let value_len_or_tombstone = i32::from_be_bytes(len_buf); // NB: -1 for tombstones
</a><a href="#h2-0-348" id="h2-0-348" class="i">+            let value_len = value_len_or_tombstone.max(0) as u32;
</a><a href="#h2-0-349" id="h2-0-349" class="i">+            writeln!(w, &quot;vlen  = {} {:x?}&quot;, value_len_or_tombstone, len_buf)?;
</a><a href="#h2-0-350" id="h2-0-350" class="i">+
</a><a href="#h2-0-351" id="h2-0-351" class="i">+            let mut key = vec![0; key_len as usize];
</a><a href="#h2-0-352" id="h2-0-352" class="i">+            r.read_exact(&amp;mut key)?;
</a><a href="#h2-0-353" id="h2-0-353" class="i">+            write!(w, &quot;key   = &quot;)?;
</a><a href="#h2-0-354" id="h2-0-354" class="i">+            if let Ok(str) = std::str::from_utf8(&amp;key) {
</a><a href="#h2-0-355" id="h2-0-355" class="i">+                write!(w, r#&quot;&quot;{}&quot; &quot;#, str)?;
</a><a href="#h2-0-356" id="h2-0-356" class="i">+            }
</a><a href="#h2-0-357" id="h2-0-357" class="i">+            writeln!(w, &quot;{:x?}&quot;, key)?;
</a><a href="#h2-0-358" id="h2-0-358" class="i">+
</a><a href="#h2-0-359" id="h2-0-359" class="i">+            let mut value = vec![0; value_len as usize];
</a><a href="#h2-0-360" id="h2-0-360" class="i">+            r.read_exact(&amp;mut value)?;
</a><a href="#h2-0-361" id="h2-0-361" class="i">+            write!(w, &quot;value = &quot;)?;
</a><a href="#h2-0-362" id="h2-0-362" class="i">+            if value_len_or_tombstone &lt; 0 {
</a><a href="#h2-0-363" id="h2-0-363" class="i">+                write!(w, &quot;tombstone &quot;)?;
</a><a href="#h2-0-364" id="h2-0-364" class="i">+            } else if let Ok(str) = std::str::from_utf8(&amp;value) {
</a><a href="#h2-0-365" id="h2-0-365" class="i">+                if str.chars().all(|c| !c.is_control()) {
</a><a href="#h2-0-366" id="h2-0-366" class="i">+                    write!(w, r#&quot;&quot;{}&quot; &quot;#, str)?;
</a><a href="#h2-0-367" id="h2-0-367" class="i">+                }
</a><a href="#h2-0-368" id="h2-0-368" class="i">+            }
</a><a href="#h2-0-369" id="h2-0-369" class="i">+            write!(w, &quot;{:x?}\n\n&quot;, value)?;
</a><a href="#h2-0-370" id="h2-0-370" class="i">+
</a><a href="#h2-0-371" id="h2-0-371" class="i">+            pos += 4 + 4 + key_len as u64 + value_len as u64;
</a><a href="#h2-0-372" id="h2-0-372" class="i">+            idx += 1;
</a><a href="#h2-0-373" id="h2-0-373" class="i">+        }
</a><a href="#h2-0-374" id="h2-0-374" class="i">+        Ok(())
</a><a href="#h2-0-375" id="h2-0-375" class="i">+    }
</a><a href="#h2-0-376" id="h2-0-376" class="i">+}
</a><a href="#h2-0-377" id="h2-0-377" class="i">+
</a><a href="#h2-0-378" id="h2-0-378" class="i">+#[cfg(test)]
</a><a href="#h2-0-379" id="h2-0-379" class="i">+mod tests {
</a><a href="#h2-0-380" id="h2-0-380" class="i">+    use super::*;
</a><a href="#h2-0-381" id="h2-0-381" class="i">+
</a><a href="#h2-0-382" id="h2-0-382" class="i">+    const GOLDEN_DIR: &amp;str = &quot;src/storage/engine/golden/bitcask&quot;;
</a><a href="#h2-0-383" id="h2-0-383" class="i">+
</a><a href="#h2-0-384" id="h2-0-384" class="i">+    super::super::tests::test_engine!({
</a><a href="#h2-0-385" id="h2-0-385" class="i">+        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h2-0-386" id="h2-0-386" class="i">+        BitCask::new(path)?
</a><a href="#h2-0-387" id="h2-0-387" class="i">+    });
</a><a href="#h2-0-388" id="h2-0-388" class="i">+
</a><a href="#h2-0-389" id="h2-0-389" class="i">+    /// Creates a new BitCask engine for testing.
</a><a href="#h2-0-390" id="h2-0-390" class="i">+    fn setup() -&gt; Result&lt;BitCask&gt; {
</a><a href="#h2-0-391" id="h2-0-391" class="i">+        BitCask::new(tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;))
</a><a href="#h2-0-392" id="h2-0-392" class="i">+    }
</a><a href="#h2-0-393" id="h2-0-393" class="i">+
</a><a href="#h2-0-394" id="h2-0-394" class="i">+    /// Writes various values primarily for testing log file handling.
</a><a href="#h2-0-395" id="h2-0-395" class="i">+    ///
</a><a href="#h2-0-396" id="h2-0-396" class="i">+    /// - &#39;&#39;: empty key and value
</a><a href="#h2-0-397" id="h2-0-397" class="i">+    /// - a: write
</a><a href="#h2-0-398" id="h2-0-398" class="i">+    /// - b: write, write
</a><a href="#h2-0-399" id="h2-0-399" class="i">+    /// - c: write, delete, write
</a><a href="#h2-0-400" id="h2-0-400" class="i">+    /// - d: delete, write
</a><a href="#h2-0-401" id="h2-0-401" class="i">+    /// - e: write, delete
</a><a href="#h2-0-402" id="h2-0-402" class="i">+    /// - f: delete
</a><a href="#h2-0-403" id="h2-0-403" class="i">+    fn setup_log(s: &amp;mut BitCask) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-404" id="h2-0-404" class="i">+        s.set(b&quot;b&quot;, vec![0x01])?;
</a><a href="#h2-0-405" id="h2-0-405" class="i">+        s.set(b&quot;b&quot;, vec![0x02])?;
</a><a href="#h2-0-406" id="h2-0-406" class="i">+
</a><a href="#h2-0-407" id="h2-0-407" class="i">+        s.set(b&quot;e&quot;, vec![0x05])?;
</a><a href="#h2-0-408" id="h2-0-408" class="i">+        s.delete(b&quot;e&quot;)?;
</a><a href="#h2-0-409" id="h2-0-409" class="i">+
</a><a href="#h2-0-410" id="h2-0-410" class="i">+        s.set(b&quot;c&quot;, vec![0x00])?;
</a><a href="#h2-0-411" id="h2-0-411" class="i">+        s.delete(b&quot;c&quot;)?;
</a><a href="#h2-0-412" id="h2-0-412" class="i">+        s.set(b&quot;c&quot;, vec![0x03])?;
</a><a href="#h2-0-413" id="h2-0-413" class="i">+
</a><a href="#h2-0-414" id="h2-0-414" class="i">+        s.set(b&quot;&quot;, vec![])?;
</a><a href="#h2-0-415" id="h2-0-415" class="i">+
</a><a href="#h2-0-416" id="h2-0-416" class="i">+        s.set(b&quot;a&quot;, vec![0x01])?;
</a><a href="#h2-0-417" id="h2-0-417" class="i">+
</a><a href="#h2-0-418" id="h2-0-418" class="i">+        s.delete(b&quot;f&quot;)?;
</a><a href="#h2-0-419" id="h2-0-419" class="i">+
</a><a href="#h2-0-420" id="h2-0-420" class="i">+        s.delete(b&quot;d&quot;)?;
</a><a href="#h2-0-421" id="h2-0-421" class="i">+        s.set(b&quot;d&quot;, vec![0x04])?;
</a><a href="#h2-0-422" id="h2-0-422" class="i">+
</a><a href="#h2-0-423" id="h2-0-423" class="i">+        // Make sure the scan yields the expected results.
</a><a href="#h2-0-424" id="h2-0-424" class="i">+        assert_eq!(
</a><a href="#h2-0-425" id="h2-0-425" class="i">+            vec![
</a><a href="#h2-0-426" id="h2-0-426" class="i">+                (b&quot;&quot;.to_vec(), vec![]),
</a><a href="#h2-0-427" id="h2-0-427" class="i">+                (b&quot;a&quot;.to_vec(), vec![0x01]),
</a><a href="#h2-0-428" id="h2-0-428" class="i">+                (b&quot;b&quot;.to_vec(), vec![0x02]),
</a><a href="#h2-0-429" id="h2-0-429" class="i">+                (b&quot;c&quot;.to_vec(), vec![0x03]),
</a><a href="#h2-0-430" id="h2-0-430" class="i">+                (b&quot;d&quot;.to_vec(), vec![0x04]),
</a><a href="#h2-0-431" id="h2-0-431" class="i">+            ],
</a><a href="#h2-0-432" id="h2-0-432" class="i">+            s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h2-0-433" id="h2-0-433" class="i">+        );
</a><a href="#h2-0-434" id="h2-0-434" class="i">+
</a><a href="#h2-0-435" id="h2-0-435" class="i">+        Ok(())
</a><a href="#h2-0-436" id="h2-0-436" class="i">+    }
</a><a href="#h2-0-437" id="h2-0-437" class="i">+
</a><a href="#h2-0-438" id="h2-0-438" class="i">+    #[test]
</a><a href="#h2-0-439" id="h2-0-439" class="i">+    /// Tests that logs are written correctly using a golden file.
</a><a href="#h2-0-440" id="h2-0-440" class="i">+    fn log() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-441" id="h2-0-441" class="i">+        let mut s = setup()?;
</a><a href="#h2-0-442" id="h2-0-442" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h2-0-443" id="h2-0-443" class="i">+
</a><a href="#h2-0-444" id="h2-0-444" class="i">+        let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
</a><a href="#h2-0-445" id="h2-0-445" class="i">+        s.log.print(&amp;mut mint.new_goldenfile(&quot;log&quot;)?)?;
</a><a href="#h2-0-446" id="h2-0-446" class="i">+        Ok(())
</a><a href="#h2-0-447" id="h2-0-447" class="i">+    }
</a><a href="#h2-0-448" id="h2-0-448" class="i">+
</a><a href="#h2-0-449" id="h2-0-449" class="i">+    #[test]
</a><a href="#h2-0-450" id="h2-0-450" class="i">+    /// Tests that writing and then reading a file yields the same results.
</a><a href="#h2-0-451" id="h2-0-451" class="i">+    fn reopen() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-452" id="h2-0-452" class="i">+        // NB: Don&#39;t use setup(), because the tempdir will be removed when
</a><a href="#h2-0-453" id="h2-0-453" class="i">+        // the path falls out of scope.
</a><a href="#h2-0-454" id="h2-0-454" class="i">+        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h2-0-455" id="h2-0-455" class="i">+        let mut s = BitCask::new(path.clone())?;
</a><a href="#h2-0-456" id="h2-0-456" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h2-0-457" id="h2-0-457" class="i">+
</a><a href="#h2-0-458" id="h2-0-458" class="i">+        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h2-0-459" id="h2-0-459" class="i">+        drop(s);
</a><a href="#h2-0-460" id="h2-0-460" class="i">+        let mut s = BitCask::new(path)?;
</a><a href="#h2-0-461" id="h2-0-461" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h2-0-462" id="h2-0-462" class="i">+
</a><a href="#h2-0-463" id="h2-0-463" class="i">+        Ok(())
</a><a href="#h2-0-464" id="h2-0-464" class="i">+    }
</a><a href="#h2-0-465" id="h2-0-465" class="i">+
</a><a href="#h2-0-466" id="h2-0-466" class="i">+    #[test]
</a><a href="#h2-0-467" id="h2-0-467" class="i">+    /// Tests log compaction, by writing golden files of the before/after state,
</a><a href="#h2-0-468" id="h2-0-468" class="i">+    /// and checking that the database contains the same results, even after
</a><a href="#h2-0-469" id="h2-0-469" class="i">+    /// reopening the file.
</a><a href="#h2-0-470" id="h2-0-470" class="i">+    fn compact() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-471" id="h2-0-471" class="i">+        // NB: Don&#39;t use setup(), because the tempdir will be removed when
</a><a href="#h2-0-472" id="h2-0-472" class="i">+        // the path falls out of scope.
</a><a href="#h2-0-473" id="h2-0-473" class="i">+        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h2-0-474" id="h2-0-474" class="i">+        let mut s = BitCask::new(path.clone())?;
</a><a href="#h2-0-475" id="h2-0-475" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h2-0-476" id="h2-0-476" class="i">+
</a><a href="#h2-0-477" id="h2-0-477" class="i">+        // Dump the initial log file.
</a><a href="#h2-0-478" id="h2-0-478" class="i">+        let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
</a><a href="#h2-0-479" id="h2-0-479" class="i">+        s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-before&quot;)?)?;
</a><a href="#h2-0-480" id="h2-0-480" class="i">+        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h2-0-481" id="h2-0-481" class="i">+
</a><a href="#h2-0-482" id="h2-0-482" class="i">+        // Compact the log file and assert the new log file contents.
</a><a href="#h2-0-483" id="h2-0-483" class="i">+        s.compact()?;
</a><a href="#h2-0-484" id="h2-0-484" class="i">+        assert_eq!(path, s.log.path);
</a><a href="#h2-0-485" id="h2-0-485" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h2-0-486" id="h2-0-486" class="i">+        s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-after&quot;)?)?;
</a><a href="#h2-0-487" id="h2-0-487" class="i">+
</a><a href="#h2-0-488" id="h2-0-488" class="i">+        // Reopen the log file and assert that the contents are the same.
</a><a href="#h2-0-489" id="h2-0-489" class="i">+        drop(s);
</a><a href="#h2-0-490" id="h2-0-490" class="i">+        let mut s = BitCask::new(path)?;
</a><a href="#h2-0-491" id="h2-0-491" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h2-0-492" id="h2-0-492" class="i">+
</a><a href="#h2-0-493" id="h2-0-493" class="i">+        Ok(())
</a><a href="#h2-0-494" id="h2-0-494" class="i">+    }
</a><a href="#h2-0-495" id="h2-0-495" class="i">+
</a><a href="#h2-0-496" id="h2-0-496" class="i">+    #[test]
</a><a href="#h2-0-497" id="h2-0-497" class="i">+    /// Tests that new_compact() will automatically compact the file when appropriate.
</a><a href="#h2-0-498" id="h2-0-498" class="i">+    fn new_compact() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-499" id="h2-0-499" class="i">+        // Create an initial log file with a few entries.
</a><a href="#h2-0-500" id="h2-0-500" class="i">+        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h2-0-501" id="h2-0-501" class="i">+        let path = dir.path().join(&quot;orig&quot;);
</a><a href="#h2-0-502" id="h2-0-502" class="i">+        let compactpath = dir.path().join(&quot;compact&quot;);
</a><a href="#h2-0-503" id="h2-0-503" class="i">+
</a><a href="#h2-0-504" id="h2-0-504" class="i">+        let mut s = BitCask::new_compact(path.clone(), 0.2)?;
</a><a href="#h2-0-505" id="h2-0-505" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h2-0-506" id="h2-0-506" class="i">+        let (live_bytes, total_bytes) = s.compute_sizes()?;
</a><a href="#h2-0-507" id="h2-0-507" class="i">+        let garbage_ratio = (total_bytes - live_bytes) as f64 / total_bytes as f64;
</a><a href="#h2-0-508" id="h2-0-508" class="i">+        drop(s);
</a><a href="#h2-0-509" id="h2-0-509" class="i">+
</a><a href="#h2-0-510" id="h2-0-510" class="i">+        // Test a few threshold value and assert whether it should trigger compaction.
</a><a href="#h2-0-511" id="h2-0-511" class="i">+        let cases = vec![
</a><a href="#h2-0-512" id="h2-0-512" class="i">+            (-1.0, true),
</a><a href="#h2-0-513" id="h2-0-513" class="i">+            (0.0, true),
</a><a href="#h2-0-514" id="h2-0-514" class="i">+            (garbage_ratio - 0.001, true),
</a><a href="#h2-0-515" id="h2-0-515" class="i">+            (garbage_ratio, true),
</a><a href="#h2-0-516" id="h2-0-516" class="i">+            (garbage_ratio + 0.001, false),
</a><a href="#h2-0-517" id="h2-0-517" class="i">+            (1.0, false),
</a><a href="#h2-0-518" id="h2-0-518" class="i">+            (2.0, false),
</a><a href="#h2-0-519" id="h2-0-519" class="i">+        ];
</a><a href="#h2-0-520" id="h2-0-520" class="i">+        for (threshold, expect_compact) in cases.into_iter() {
</a><a href="#h2-0-521" id="h2-0-521" class="i">+            std::fs::copy(&amp;path, &amp;compactpath)?;
</a><a href="#h2-0-522" id="h2-0-522" class="i">+            let mut s = BitCask::new_compact(compactpath.clone(), threshold)?;
</a><a href="#h2-0-523" id="h2-0-523" class="i">+            let (new_live, new_total) = s.compute_sizes()?;
</a><a href="#h2-0-524" id="h2-0-524" class="i">+            assert_eq!(new_live, live_bytes);
</a><a href="#h2-0-525" id="h2-0-525" class="i">+            if expect_compact {
</a><a href="#h2-0-526" id="h2-0-526" class="i">+                assert_eq!(new_total, live_bytes);
</a><a href="#h2-0-527" id="h2-0-527" class="i">+            } else {
</a><a href="#h2-0-528" id="h2-0-528" class="i">+                assert_eq!(new_total, total_bytes);
</a><a href="#h2-0-529" id="h2-0-529" class="i">+            }
</a><a href="#h2-0-530" id="h2-0-530" class="i">+        }
</a><a href="#h2-0-531" id="h2-0-531" class="i">+
</a><a href="#h2-0-532" id="h2-0-532" class="i">+        Ok(())
</a><a href="#h2-0-533" id="h2-0-533" class="i">+    }
</a><a href="#h2-0-534" id="h2-0-534" class="i">+
</a><a href="#h2-0-535" id="h2-0-535" class="i">+    #[test]
</a><a href="#h2-0-536" id="h2-0-536" class="i">+    /// Tests that exclusive locks are taken out on log files, released when the
</a><a href="#h2-0-537" id="h2-0-537" class="i">+    /// database is closed, and that an error is returned if a lock is already
</a><a href="#h2-0-538" id="h2-0-538" class="i">+    /// held.
</a><a href="#h2-0-539" id="h2-0-539" class="i">+    fn log_lock() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-540" id="h2-0-540" class="i">+        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h2-0-541" id="h2-0-541" class="i">+        let s = BitCask::new(path.clone())?;
</a><a href="#h2-0-542" id="h2-0-542" class="i">+
</a><a href="#h2-0-543" id="h2-0-543" class="i">+        assert!(BitCask::new(path.clone()).is_err());
</a><a href="#h2-0-544" id="h2-0-544" class="i">+        drop(s);
</a><a href="#h2-0-545" id="h2-0-545" class="i">+        assert!(BitCask::new(path.clone()).is_ok());
</a><a href="#h2-0-546" id="h2-0-546" class="i">+
</a><a href="#h2-0-547" id="h2-0-547" class="i">+        Ok(())
</a><a href="#h2-0-548" id="h2-0-548" class="i">+    }
</a><a href="#h2-0-549" id="h2-0-549" class="i">+
</a><a href="#h2-0-550" id="h2-0-550" class="i">+    #[test]
</a><a href="#h2-0-551" id="h2-0-551" class="i">+    /// Tests that an incomplete write at the end of the log file can be
</a><a href="#h2-0-552" id="h2-0-552" class="i">+    /// recovered by discarding the last entry.
</a><a href="#h2-0-553" id="h2-0-553" class="i">+    fn recovery() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-554" id="h2-0-554" class="i">+        // Create an initial log file with a few entries.
</a><a href="#h2-0-555" id="h2-0-555" class="i">+        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h2-0-556" id="h2-0-556" class="i">+        let path = dir.path().join(&quot;complete&quot;);
</a><a href="#h2-0-557" id="h2-0-557" class="i">+        let truncpath = dir.path().join(&quot;truncated&quot;);
</a><a href="#h2-0-558" id="h2-0-558" class="i">+
</a><a href="#h2-0-559" id="h2-0-559" class="i">+        let mut log = Log::new(path.clone())?;
</a><a href="#h2-0-560" id="h2-0-560" class="i">+        let mut ends = vec![];
</a><a href="#h2-0-561" id="h2-0-561" class="i">+
</a><a href="#h2-0-562" id="h2-0-562" class="i">+        let (pos, len) = log.write_entry(&quot;deleted&quot;.as_bytes(), Some(&amp;[1, 2, 3]))?;
</a><a href="#h2-0-563" id="h2-0-563" class="i">+        ends.push(pos + len as u64);
</a><a href="#h2-0-564" id="h2-0-564" class="i">+
</a><a href="#h2-0-565" id="h2-0-565" class="i">+        let (pos, len) = log.write_entry(&quot;deleted&quot;.as_bytes(), None)?;
</a><a href="#h2-0-566" id="h2-0-566" class="i">+        ends.push(pos + len as u64);
</a><a href="#h2-0-567" id="h2-0-567" class="i">+
</a><a href="#h2-0-568" id="h2-0-568" class="i">+        let (pos, len) = log.write_entry(&amp;[], Some(&amp;[]))?;
</a><a href="#h2-0-569" id="h2-0-569" class="i">+        ends.push(pos + len as u64);
</a><a href="#h2-0-570" id="h2-0-570" class="i">+
</a><a href="#h2-0-571" id="h2-0-571" class="i">+        let (pos, len) = log.write_entry(&quot;key&quot;.as_bytes(), Some(&amp;[1, 2, 3, 4, 5]))?;
</a><a href="#h2-0-572" id="h2-0-572" class="i">+        ends.push(pos + len as u64);
</a><a href="#h2-0-573" id="h2-0-573" class="i">+
</a><a href="#h2-0-574" id="h2-0-574" class="i">+        drop(log);
</a><a href="#h2-0-575" id="h2-0-575" class="i">+
</a><a href="#h2-0-576" id="h2-0-576" class="i">+        // Copy the file, and truncate it at each byte, then try to open it
</a><a href="#h2-0-577" id="h2-0-577" class="i">+        // and assert that we always retain a prefix of entries.
</a><a href="#h2-0-578" id="h2-0-578" class="i">+        let size = std::fs::metadata(&amp;path)?.len();
</a><a href="#h2-0-579" id="h2-0-579" class="i">+        for pos in 0..=size {
</a><a href="#h2-0-580" id="h2-0-580" class="i">+            std::fs::copy(&amp;path, &amp;truncpath)?;
</a><a href="#h2-0-581" id="h2-0-581" class="i">+            let f = std::fs::OpenOptions::new().write(true).open(&amp;truncpath)?;
</a><a href="#h2-0-582" id="h2-0-582" class="i">+            f.set_len(pos)?;
</a><a href="#h2-0-583" id="h2-0-583" class="i">+            drop(f);
</a><a href="#h2-0-584" id="h2-0-584" class="i">+
</a><a href="#h2-0-585" id="h2-0-585" class="i">+            let mut expect = vec![];
</a><a href="#h2-0-586" id="h2-0-586" class="i">+            if pos &gt;= ends[0] {
</a><a href="#h2-0-587" id="h2-0-587" class="i">+                expect.push((b&quot;deleted&quot;.to_vec(), vec![1, 2, 3]))
</a><a href="#h2-0-588" id="h2-0-588" class="i">+            }
</a><a href="#h2-0-589" id="h2-0-589" class="i">+            if pos &gt;= ends[1] {
</a><a href="#h2-0-590" id="h2-0-590" class="i">+                expect.pop(); // &quot;deleted&quot; key removed
</a><a href="#h2-0-591" id="h2-0-591" class="i">+            }
</a><a href="#h2-0-592" id="h2-0-592" class="i">+            if pos &gt;= ends[2] {
</a><a href="#h2-0-593" id="h2-0-593" class="i">+                expect.push((b&quot;&quot;.to_vec(), vec![]))
</a><a href="#h2-0-594" id="h2-0-594" class="i">+            }
</a><a href="#h2-0-595" id="h2-0-595" class="i">+            if pos &gt;= ends[3] {
</a><a href="#h2-0-596" id="h2-0-596" class="i">+                expect.push((b&quot;key&quot;.to_vec(), vec![1, 2, 3, 4, 5]))
</a><a href="#h2-0-597" id="h2-0-597" class="i">+            }
</a><a href="#h2-0-598" id="h2-0-598" class="i">+
</a><a href="#h2-0-599" id="h2-0-599" class="i">+            let mut s = BitCask::new(truncpath.clone())?;
</a><a href="#h2-0-600" id="h2-0-600" class="i">+            assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h2-0-601" id="h2-0-601" class="i">+        }
</a><a href="#h2-0-602" id="h2-0-602" class="i">+
</a><a href="#h2-0-603" id="h2-0-603" class="i">+        Ok(())
</a><a href="#h2-0-604" id="h2-0-604" class="i">+    }
</a><a href="#h2-0-605" id="h2-0-605" class="i">+
</a><a href="#h2-0-606" id="h2-0-606" class="i">+    #[test]
</a><a href="#h2-0-607" id="h2-0-607" class="i">+    /// Tests compute_sizes(), both for a log file with known garbage, and
</a><a href="#h2-0-608" id="h2-0-608" class="i">+    /// after compacting it when the live size must equal the file size.
</a><a href="#h2-0-609" id="h2-0-609" class="i">+    fn compute_sizes() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-610" id="h2-0-610" class="i">+        let mut s = setup()?;
</a><a href="#h2-0-611" id="h2-0-611" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h2-0-612" id="h2-0-612" class="i">+
</a><a href="#h2-0-613" id="h2-0-613" class="i">+        // Before compaction, the log contains garbage, so the live size must be
</a><a href="#h2-0-614" id="h2-0-614" class="i">+        // less than the log size.
</a><a href="#h2-0-615" id="h2-0-615" class="i">+        let (live_size, total_size) = s.compute_sizes()?;
</a><a href="#h2-0-616" id="h2-0-616" class="i">+        assert_eq!(total_size, s.log.file.metadata()?.len());
</a><a href="#h2-0-617" id="h2-0-617" class="i">+        assert!(live_size &lt; total_size);
</a><a href="#h2-0-618" id="h2-0-618" class="i">+
</a><a href="#h2-0-619" id="h2-0-619" class="i">+        // After compaction, the live size should not have changed. Furthermore,
</a><a href="#h2-0-620" id="h2-0-620" class="i">+        // the log now only contains live data, so the live size must equal the
</a><a href="#h2-0-621" id="h2-0-621" class="i">+        // log file size.
</a><a href="#h2-0-622" id="h2-0-622" class="i">+        s.compact()?;
</a><a href="#h2-0-623" id="h2-0-623" class="i">+        assert_eq!((live_size, live_size), s.compute_sizes()?);
</a><a href="#h2-0-624" id="h2-0-624" class="i">+        Ok(())
</a><a href="#h2-0-625" id="h2-0-625" class="i">+    }
</a><a href="#h2-0-626" id="h2-0-626" class="i">+}
</a><b>diff --git a/<a id="h3" href="../file/src/storage/kv/golden/bitcask/compact-after.html">src/storage/kv/golden/bitcask/compact-after</a> b/<a href="../file/src/storage/engine/golden/bitcask/compact-after.html">src/storage/engine/golden/bitcask/compact-after</a></b>
<b>diff --git a/<a id="h4" href="../file/src/storage/kv/golden/bitcask/compact-before.html">src/storage/kv/golden/bitcask/compact-before</a> b/<a href="../file/src/storage/engine/golden/bitcask/compact-before.html">src/storage/engine/golden/bitcask/compact-before</a></b>
<b>diff --git a/<a id="h5" href="../file/src/storage/kv/golden/bitcask/log.html">src/storage/kv/golden/bitcask/log</a> b/<a href="../file/src/storage/engine/golden/bitcask/log.html">src/storage/engine/golden/bitcask/log</a></b>
<b>diff --git a/<a id="h6" href="../file/src/storage/engine/memory.rs.html">src/storage/engine/memory.rs</a> b/<a href="../file/src/storage/engine/memory.rs.html">src/storage/engine/memory.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -0,0 +1,79 @@
</a><a href="#h6-0-0" id="h6-0-0" class="i">+use super::Engine;
</a><a href="#h6-0-1" id="h6-0-1" class="i">+use crate::error::Result;
</a><a href="#h6-0-2" id="h6-0-2" class="i">+
</a><a href="#h6-0-3" id="h6-0-3" class="i">+/// An in-memory key/value storage engine using the Rust standard library B-tree
</a><a href="#h6-0-4" id="h6-0-4" class="i">+/// implementation. Data is not persisted.
</a><a href="#h6-0-5" id="h6-0-5" class="i">+pub struct Memory {
</a><a href="#h6-0-6" id="h6-0-6" class="i">+    data: std::collections::BTreeMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h6-0-7" id="h6-0-7" class="i">+}
</a><a href="#h6-0-8" id="h6-0-8" class="i">+
</a><a href="#h6-0-9" id="h6-0-9" class="i">+impl Memory {
</a><a href="#h6-0-10" id="h6-0-10" class="i">+    /// Creates a new Memory key-value storage engine.
</a><a href="#h6-0-11" id="h6-0-11" class="i">+    pub fn new() -&gt; Self {
</a><a href="#h6-0-12" id="h6-0-12" class="i">+        Self { data: std::collections::BTreeMap::new() }
</a><a href="#h6-0-13" id="h6-0-13" class="i">+    }
</a><a href="#h6-0-14" id="h6-0-14" class="i">+}
</a><a href="#h6-0-15" id="h6-0-15" class="i">+
</a><a href="#h6-0-16" id="h6-0-16" class="i">+impl std::fmt::Display for Memory {
</a><a href="#h6-0-17" id="h6-0-17" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h6-0-18" id="h6-0-18" class="i">+        write!(f, &quot;memory&quot;)
</a><a href="#h6-0-19" id="h6-0-19" class="i">+    }
</a><a href="#h6-0-20" id="h6-0-20" class="i">+}
</a><a href="#h6-0-21" id="h6-0-21" class="i">+
</a><a href="#h6-0-22" id="h6-0-22" class="i">+impl Engine for Memory {
</a><a href="#h6-0-23" id="h6-0-23" class="i">+    type ScanIterator&lt;&#39;a&gt; = ScanIterator&lt;&#39;a&gt;;
</a><a href="#h6-0-24" id="h6-0-24" class="i">+
</a><a href="#h6-0-25" id="h6-0-25" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h6-0-26" id="h6-0-26" class="i">+        Ok(())
</a><a href="#h6-0-27" id="h6-0-27" class="i">+    }
</a><a href="#h6-0-28" id="h6-0-28" class="i">+
</a><a href="#h6-0-29" id="h6-0-29" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h6-0-30" id="h6-0-30" class="i">+        self.data.remove(key);
</a><a href="#h6-0-31" id="h6-0-31" class="i">+        Ok(())
</a><a href="#h6-0-32" id="h6-0-32" class="i">+    }
</a><a href="#h6-0-33" id="h6-0-33" class="i">+
</a><a href="#h6-0-34" id="h6-0-34" class="i">+    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h6-0-35" id="h6-0-35" class="i">+        Ok(self.data.get(key).cloned())
</a><a href="#h6-0-36" id="h6-0-36" class="i">+    }
</a><a href="#h6-0-37" id="h6-0-37" class="i">+
</a><a href="#h6-0-38" id="h6-0-38" class="i">+    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h6-0-39" id="h6-0-39" class="i">+        ScanIterator { inner: self.data.range(range) }
</a><a href="#h6-0-40" id="h6-0-40" class="i">+    }
</a><a href="#h6-0-41" id="h6-0-41" class="i">+
</a><a href="#h6-0-42" id="h6-0-42" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h6-0-43" id="h6-0-43" class="i">+        self.data.insert(key.to_vec(), value);
</a><a href="#h6-0-44" id="h6-0-44" class="i">+        Ok(())
</a><a href="#h6-0-45" id="h6-0-45" class="i">+    }
</a><a href="#h6-0-46" id="h6-0-46" class="i">+}
</a><a href="#h6-0-47" id="h6-0-47" class="i">+
</a><a href="#h6-0-48" id="h6-0-48" class="i">+pub struct ScanIterator&lt;&#39;a&gt; {
</a><a href="#h6-0-49" id="h6-0-49" class="i">+    inner: std::collections::btree_map::Range&lt;&#39;a, Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h6-0-50" id="h6-0-50" class="i">+}
</a><a href="#h6-0-51" id="h6-0-51" class="i">+
</a><a href="#h6-0-52" id="h6-0-52" class="i">+impl&lt;&#39;a&gt; ScanIterator&lt;&#39;a&gt; {
</a><a href="#h6-0-53" id="h6-0-53" class="i">+    fn map(item: (&amp;Vec&lt;u8&gt;, &amp;Vec&lt;u8&gt;)) -&gt; &lt;Self as Iterator&gt;::Item {
</a><a href="#h6-0-54" id="h6-0-54" class="i">+        let (key, value) = item;
</a><a href="#h6-0-55" id="h6-0-55" class="i">+        Ok((key.clone(), value.clone()))
</a><a href="#h6-0-56" id="h6-0-56" class="i">+    }
</a><a href="#h6-0-57" id="h6-0-57" class="i">+}
</a><a href="#h6-0-58" id="h6-0-58" class="i">+
</a><a href="#h6-0-59" id="h6-0-59" class="i">+impl&lt;&#39;a&gt; Iterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h6-0-60" id="h6-0-60" class="i">+    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a><a href="#h6-0-61" id="h6-0-61" class="i">+
</a><a href="#h6-0-62" id="h6-0-62" class="i">+    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h6-0-63" id="h6-0-63" class="i">+        self.inner.next().map(Self::map)
</a><a href="#h6-0-64" id="h6-0-64" class="i">+    }
</a><a href="#h6-0-65" id="h6-0-65" class="i">+}
</a><a href="#h6-0-66" id="h6-0-66" class="i">+
</a><a href="#h6-0-67" id="h6-0-67" class="i">+impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h6-0-68" id="h6-0-68" class="i">+    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h6-0-69" id="h6-0-69" class="i">+        self.inner.next_back().map(Self::map)
</a><a href="#h6-0-70" id="h6-0-70" class="i">+    }
</a><a href="#h6-0-71" id="h6-0-71" class="i">+}
</a><a href="#h6-0-72" id="h6-0-72" class="i">+
</a><a href="#h6-0-73" id="h6-0-73" class="i">+#[cfg(test)]
</a><a href="#h6-0-74" id="h6-0-74" class="i">+mod tests {
</a><a href="#h6-0-75" id="h6-0-75" class="i">+    use super::*;
</a><a href="#h6-0-76" id="h6-0-76" class="i">+
</a><a href="#h6-0-77" id="h6-0-77" class="i">+    super::super::tests::test_engine!(Memory::new());
</a><a href="#h6-0-78" id="h6-0-78" class="i">+}
</a><b>diff --git a/<a id="h7" href="../file/src/storage/engine/mod.rs.html">src/storage/engine/mod.rs</a> b/<a href="../file/src/storage/engine/mod.rs.html">src/storage/engine/mod.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -0,0 +1,294 @@
</a><a href="#h7-0-0" id="h7-0-0" class="i">+mod bitcask;
</a><a href="#h7-0-1" id="h7-0-1" class="i">+mod memory;
</a><a href="#h7-0-2" id="h7-0-2" class="i">+
</a><a href="#h7-0-3" id="h7-0-3" class="i">+pub use bitcask::BitCask;
</a><a href="#h7-0-4" id="h7-0-4" class="i">+pub use memory::Memory;
</a><a href="#h7-0-5" id="h7-0-5" class="i">+
</a><a href="#h7-0-6" id="h7-0-6" class="i">+use crate::error::Result;
</a><a href="#h7-0-7" id="h7-0-7" class="i">+
</a><a href="#h7-0-8" id="h7-0-8" class="i">+/// A key/value storage engine, where both keys and values are arbitrary byte
</a><a href="#h7-0-9" id="h7-0-9" class="i">+/// strings between 0 B and 2 GB, stored in lexicographical key order. Writes
</a><a href="#h7-0-10" id="h7-0-10" class="i">+/// are only guaranteed durable after calling flush().
</a><a href="#h7-0-11" id="h7-0-11" class="i">+///
</a><a href="#h7-0-12" id="h7-0-12" class="i">+/// Only supports single-threaded use since all methods (including reads) take a
</a><a href="#h7-0-13" id="h7-0-13" class="i">+/// mutable reference -- serialized access can&#39;t be avoided anyway, since both
</a><a href="#h7-0-14" id="h7-0-14" class="i">+/// Raft execution and file access is serial.
</a><a href="#h7-0-15" id="h7-0-15" class="i">+pub trait Engine: std::fmt::Display + Send + Sync {
</a><a href="#h7-0-16" id="h7-0-16" class="i">+    /// The iterator returned by scan(). Traits can&#39;t return &quot;impl Trait&quot;, and
</a><a href="#h7-0-17" id="h7-0-17" class="i">+    /// we don&#39;t want to use trait objects, so the type must be specified.
</a><a href="#h7-0-18" id="h7-0-18" class="i">+    type ScanIterator&lt;&#39;a&gt;: DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; + &#39;a
</a><a href="#h7-0-19" id="h7-0-19" class="i">+    where
</a><a href="#h7-0-20" id="h7-0-20" class="i">+        Self: &#39;a;
</a><a href="#h7-0-21" id="h7-0-21" class="i">+
</a><a href="#h7-0-22" id="h7-0-22" class="i">+    /// Deletes a key, or does nothing if it does not exist.
</a><a href="#h7-0-23" id="h7-0-23" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt;;
</a><a href="#h7-0-24" id="h7-0-24" class="i">+
</a><a href="#h7-0-25" id="h7-0-25" class="i">+    /// Flushes any buffered data to the underlying storage medium.
</a><a href="#h7-0-26" id="h7-0-26" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</a><a href="#h7-0-27" id="h7-0-27" class="i">+
</a><a href="#h7-0-28" id="h7-0-28" class="i">+    /// Gets a value for a key, if it exists.
</a><a href="#h7-0-29" id="h7-0-29" class="i">+    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
</a><a href="#h7-0-30" id="h7-0-30" class="i">+
</a><a href="#h7-0-31" id="h7-0-31" class="i">+    /// Iterates over an ordered range of key/value pairs.
</a><a href="#h7-0-32" id="h7-0-32" class="i">+    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Self::ScanIterator&lt;&#39;_&gt;;
</a><a href="#h7-0-33" id="h7-0-33" class="i">+
</a><a href="#h7-0-34" id="h7-0-34" class="i">+    /// Sets a value for a key, replacing the existing value if any.
</a><a href="#h7-0-35" id="h7-0-35" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;
</a><a href="#h7-0-36" id="h7-0-36" class="i">+}
</a><a href="#h7-0-37" id="h7-0-37" class="i">+
</a><a href="#h7-0-38" id="h7-0-38" class="i">+#[cfg(test)]
</a><a href="#h7-0-39" id="h7-0-39" class="i">+mod tests {
</a><a href="#h7-0-40" id="h7-0-40" class="i">+    /// Generates common tests for any Engine implementation.
</a><a href="#h7-0-41" id="h7-0-41" class="i">+    macro_rules! test_engine {
</a><a href="#h7-0-42" id="h7-0-42" class="i">+        ($setup:expr) =&gt; {
</a><a href="#h7-0-43" id="h7-0-43" class="i">+            /// Tests Engine point operations, i.e. set, get, and delete.
</a><a href="#h7-0-44" id="h7-0-44" class="i">+            #[test]
</a><a href="#h7-0-45" id="h7-0-45" class="i">+            fn point_ops() -&gt; Result&lt;()&gt; {
</a><a href="#h7-0-46" id="h7-0-46" class="i">+                let mut s = $setup;
</a><a href="#h7-0-47" id="h7-0-47" class="i">+
</a><a href="#h7-0-48" id="h7-0-48" class="i">+                // Getting a missing key should return None.
</a><a href="#h7-0-49" id="h7-0-49" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h7-0-50" id="h7-0-50" class="i">+
</a><a href="#h7-0-51" id="h7-0-51" class="i">+                // Setting and getting a key should return its value.
</a><a href="#h7-0-52" id="h7-0-52" class="i">+                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h7-0-53" id="h7-0-53" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![1]));
</a><a href="#h7-0-54" id="h7-0-54" class="i">+
</a><a href="#h7-0-55" id="h7-0-55" class="i">+                // Setting a different key should not affect the first.
</a><a href="#h7-0-56" id="h7-0-56" class="i">+                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h7-0-57" id="h7-0-57" class="i">+                assert_eq!(s.get(b&quot;b&quot;)?, Some(vec![2]));
</a><a href="#h7-0-58" id="h7-0-58" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![1]));
</a><a href="#h7-0-59" id="h7-0-59" class="i">+
</a><a href="#h7-0-60" id="h7-0-60" class="i">+                // Getting a different missing key should return None. The
</a><a href="#h7-0-61" id="h7-0-61" class="i">+                // comparison is case-insensitive for strings.
</a><a href="#h7-0-62" id="h7-0-62" class="i">+                assert_eq!(s.get(b&quot;c&quot;)?, None);
</a><a href="#h7-0-63" id="h7-0-63" class="i">+                assert_eq!(s.get(b&quot;A&quot;)?, None);
</a><a href="#h7-0-64" id="h7-0-64" class="i">+
</a><a href="#h7-0-65" id="h7-0-65" class="i">+                // Setting an existing key should replace its value.
</a><a href="#h7-0-66" id="h7-0-66" class="i">+                s.set(b&quot;a&quot;, vec![0])?;
</a><a href="#h7-0-67" id="h7-0-67" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![0]));
</a><a href="#h7-0-68" id="h7-0-68" class="i">+
</a><a href="#h7-0-69" id="h7-0-69" class="i">+                // Deleting a key should remove it, but not affect others.
</a><a href="#h7-0-70" id="h7-0-70" class="i">+                s.delete(b&quot;a&quot;)?;
</a><a href="#h7-0-71" id="h7-0-71" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h7-0-72" id="h7-0-72" class="i">+                assert_eq!(s.get(b&quot;b&quot;)?, Some(vec![2]));
</a><a href="#h7-0-73" id="h7-0-73" class="i">+
</a><a href="#h7-0-74" id="h7-0-74" class="i">+                // Deletes are idempotent.
</a><a href="#h7-0-75" id="h7-0-75" class="i">+                s.delete(b&quot;a&quot;)?;
</a><a href="#h7-0-76" id="h7-0-76" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h7-0-77" id="h7-0-77" class="i">+
</a><a href="#h7-0-78" id="h7-0-78" class="i">+                Ok(())
</a><a href="#h7-0-79" id="h7-0-79" class="i">+            }
</a><a href="#h7-0-80" id="h7-0-80" class="i">+
</a><a href="#h7-0-81" id="h7-0-81" class="i">+            #[test]
</a><a href="#h7-0-82" id="h7-0-82" class="i">+            /// Tests Engine point operations on empty keys and values. These
</a><a href="#h7-0-83" id="h7-0-83" class="i">+            /// are as valid as any other key/value.
</a><a href="#h7-0-84" id="h7-0-84" class="i">+            fn point_ops_empty() -&gt; Result&lt;()&gt; {
</a><a href="#h7-0-85" id="h7-0-85" class="i">+                let mut s = $setup;
</a><a href="#h7-0-86" id="h7-0-86" class="i">+                assert_eq!(s.get(b&quot;&quot;)?, None);
</a><a href="#h7-0-87" id="h7-0-87" class="i">+                s.set(b&quot;&quot;, vec![])?;
</a><a href="#h7-0-88" id="h7-0-88" class="i">+                assert_eq!(s.get(b&quot;&quot;)?, Some(vec![]));
</a><a href="#h7-0-89" id="h7-0-89" class="i">+                s.delete(b&quot;&quot;)?;
</a><a href="#h7-0-90" id="h7-0-90" class="i">+                assert_eq!(s.get(b&quot;&quot;)?, None);
</a><a href="#h7-0-91" id="h7-0-91" class="i">+                Ok(())
</a><a href="#h7-0-92" id="h7-0-92" class="i">+            }
</a><a href="#h7-0-93" id="h7-0-93" class="i">+
</a><a href="#h7-0-94" id="h7-0-94" class="i">+            #[test]
</a><a href="#h7-0-95" id="h7-0-95" class="i">+            /// Tests Engine point operations on keys and values of increasing
</a><a href="#h7-0-96" id="h7-0-96" class="i">+            /// sizes, up to 16 MB.
</a><a href="#h7-0-97" id="h7-0-97" class="i">+            fn point_ops_sizes() -&gt; Result&lt;()&gt; {
</a><a href="#h7-0-98" id="h7-0-98" class="i">+                let mut s = $setup;
</a><a href="#h7-0-99" id="h7-0-99" class="i">+
</a><a href="#h7-0-100" id="h7-0-100" class="i">+                // Generate keys/values for increasing powers of two.
</a><a href="#h7-0-101" id="h7-0-101" class="i">+                for size in (1..=24).map(|i| 1 &lt;&lt; i) {
</a><a href="#h7-0-102" id="h7-0-102" class="i">+                    let bytes = &quot;x&quot;.repeat(size);
</a><a href="#h7-0-103" id="h7-0-103" class="i">+                    let key = bytes.as_bytes();
</a><a href="#h7-0-104" id="h7-0-104" class="i">+                    let value = bytes.clone().into_bytes();
</a><a href="#h7-0-105" id="h7-0-105" class="i">+
</a><a href="#h7-0-106" id="h7-0-106" class="i">+                    assert_eq!(s.get(key)?, None);
</a><a href="#h7-0-107" id="h7-0-107" class="i">+                    s.set(key, value.clone())?;
</a><a href="#h7-0-108" id="h7-0-108" class="i">+                    assert_eq!(s.get(key)?, Some(value));
</a><a href="#h7-0-109" id="h7-0-109" class="i">+                    s.delete(key)?;
</a><a href="#h7-0-110" id="h7-0-110" class="i">+                    assert_eq!(s.get(key)?, None);
</a><a href="#h7-0-111" id="h7-0-111" class="i">+                }
</a><a href="#h7-0-112" id="h7-0-112" class="i">+
</a><a href="#h7-0-113" id="h7-0-113" class="i">+                Ok(())
</a><a href="#h7-0-114" id="h7-0-114" class="i">+            }
</a><a href="#h7-0-115" id="h7-0-115" class="i">+
</a><a href="#h7-0-116" id="h7-0-116" class="i">+            #[test]
</a><a href="#h7-0-117" id="h7-0-117" class="i">+            /// Tests various Engine scans.
</a><a href="#h7-0-118" id="h7-0-118" class="i">+            fn scan() -&gt; Result&lt;()&gt; {
</a><a href="#h7-0-119" id="h7-0-119" class="i">+                let mut s = $setup;
</a><a href="#h7-0-120" id="h7-0-120" class="i">+                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h7-0-121" id="h7-0-121" class="i">+                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h7-0-122" id="h7-0-122" class="i">+                s.set(b&quot;ba&quot;, vec![2, 1])?;
</a><a href="#h7-0-123" id="h7-0-123" class="i">+                s.set(b&quot;bb&quot;, vec![2, 2])?;
</a><a href="#h7-0-124" id="h7-0-124" class="i">+                s.set(b&quot;c&quot;, vec![3])?;
</a><a href="#h7-0-125" id="h7-0-125" class="i">+                s.set(b&quot;C&quot;, vec![3])?;
</a><a href="#h7-0-126" id="h7-0-126" class="i">+
</a><a href="#h7-0-127" id="h7-0-127" class="i">+                #[track_caller]
</a><a href="#h7-0-128" id="h7-0-128" class="i">+                fn assert_scan&lt;I&gt;(iter: I, expect: Vec&lt;(&amp;[u8], Vec&lt;u8&gt;)&gt;) -&gt; Result&lt;()&gt;
</a><a href="#h7-0-129" id="h7-0-129" class="i">+                where
</a><a href="#h7-0-130" id="h7-0-130" class="i">+                    I: Iterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt;,
</a><a href="#h7-0-131" id="h7-0-131" class="i">+                {
</a><a href="#h7-0-132" id="h7-0-132" class="i">+                    assert_eq!(
</a><a href="#h7-0-133" id="h7-0-133" class="i">+                        iter.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h7-0-134" id="h7-0-134" class="i">+                        expect.into_iter().map(|(k, v)| (k.to_vec(), v)).collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h7-0-135" id="h7-0-135" class="i">+                    );
</a><a href="#h7-0-136" id="h7-0-136" class="i">+                    Ok(())
</a><a href="#h7-0-137" id="h7-0-137" class="i">+                }
</a><a href="#h7-0-138" id="h7-0-138" class="i">+
</a><a href="#h7-0-139" id="h7-0-139" class="i">+                // Forward/reverse scans.
</a><a href="#h7-0-140" id="h7-0-140" class="i">+                assert_scan(
</a><a href="#h7-0-141" id="h7-0-141" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()),
</a><a href="#h7-0-142" id="h7-0-142" class="i">+                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;bb&quot;, vec![2, 2])],
</a><a href="#h7-0-143" id="h7-0-143" class="i">+                )?;
</a><a href="#h7-0-144" id="h7-0-144" class="i">+                assert_scan(
</a><a href="#h7-0-145" id="h7-0-145" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).rev(),
</a><a href="#h7-0-146" id="h7-0-146" class="i">+                    vec![(b&quot;bb&quot;, vec![2, 2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;b&quot;, vec![2])],
</a><a href="#h7-0-147" id="h7-0-147" class="i">+                )?;
</a><a href="#h7-0-148" id="h7-0-148" class="i">+
</a><a href="#h7-0-149" id="h7-0-149" class="i">+                // Inclusive/exclusive ranges.
</a><a href="#h7-0-150" id="h7-0-150" class="i">+                assert_scan(
</a><a href="#h7-0-151" id="h7-0-151" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()),
</a><a href="#h7-0-152" id="h7-0-152" class="i">+                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1])],
</a><a href="#h7-0-153" id="h7-0-153" class="i">+                )?;
</a><a href="#h7-0-154" id="h7-0-154" class="i">+                assert_scan(
</a><a href="#h7-0-155" id="h7-0-155" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()),
</a><a href="#h7-0-156" id="h7-0-156" class="i">+                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;bb&quot;, vec![2, 2])],
</a><a href="#h7-0-157" id="h7-0-157" class="i">+                )?;
</a><a href="#h7-0-158" id="h7-0-158" class="i">+
</a><a href="#h7-0-159" id="h7-0-159" class="i">+                // Open ranges.
</a><a href="#h7-0-160" id="h7-0-160" class="i">+                assert_scan(s.scan(b&quot;bb&quot;.to_vec()..), vec![(b&quot;bb&quot;, vec![2, 2]), (b&quot;c&quot;, vec![3])])?;
</a><a href="#h7-0-161" id="h7-0-161" class="i">+                assert_scan(
</a><a href="#h7-0-162" id="h7-0-162" class="i">+                    s.scan(..=b&quot;b&quot;.to_vec()),
</a><a href="#h7-0-163" id="h7-0-163" class="i">+                    vec![(b&quot;C&quot;, vec![3]), (b&quot;a&quot;, vec![1]), (b&quot;b&quot;, vec![2])],
</a><a href="#h7-0-164" id="h7-0-164" class="i">+                )?;
</a><a href="#h7-0-165" id="h7-0-165" class="i">+
</a><a href="#h7-0-166" id="h7-0-166" class="i">+                // Full range.
</a><a href="#h7-0-167" id="h7-0-167" class="i">+                assert_scan(
</a><a href="#h7-0-168" id="h7-0-168" class="i">+                    s.scan(..),
</a><a href="#h7-0-169" id="h7-0-169" class="i">+                    vec![
</a><a href="#h7-0-170" id="h7-0-170" class="i">+                        (b&quot;C&quot;, vec![3]),
</a><a href="#h7-0-171" id="h7-0-171" class="i">+                        (b&quot;a&quot;, vec![1]),
</a><a href="#h7-0-172" id="h7-0-172" class="i">+                        (b&quot;b&quot;, vec![2]),
</a><a href="#h7-0-173" id="h7-0-173" class="i">+                        (b&quot;ba&quot;, vec![2, 1]),
</a><a href="#h7-0-174" id="h7-0-174" class="i">+                        (b&quot;bb&quot;, vec![2, 2]),
</a><a href="#h7-0-175" id="h7-0-175" class="i">+                        (b&quot;c&quot;, vec![3]),
</a><a href="#h7-0-176" id="h7-0-176" class="i">+                    ],
</a><a href="#h7-0-177" id="h7-0-177" class="i">+                )?;
</a><a href="#h7-0-178" id="h7-0-178" class="i">+                Ok(())
</a><a href="#h7-0-179" id="h7-0-179" class="i">+            }
</a><a href="#h7-0-180" id="h7-0-180" class="i">+
</a><a href="#h7-0-181" id="h7-0-181" class="i">+            #[test]
</a><a href="#h7-0-182" id="h7-0-182" class="i">+            /// Runs random operations both on a Engine and a known-good
</a><a href="#h7-0-183" id="h7-0-183" class="i">+            /// BTreeMap, comparing the results of each operation as well as the
</a><a href="#h7-0-184" id="h7-0-184" class="i">+            /// final state.
</a><a href="#h7-0-185" id="h7-0-185" class="i">+            fn random_ops() -&gt; Result&lt;()&gt; {
</a><a href="#h7-0-186" id="h7-0-186" class="i">+                const NUM_OPS: u64 = 1000;
</a><a href="#h7-0-187" id="h7-0-187" class="i">+
</a><a href="#h7-0-188" id="h7-0-188" class="i">+                use rand::{seq::SliceRandom, Rng, RngCore};
</a><a href="#h7-0-189" id="h7-0-189" class="i">+                let seed: u64 = rand::thread_rng().gen();
</a><a href="#h7-0-190" id="h7-0-190" class="i">+                let mut rng: rand::rngs::StdRng = rand::SeedableRng::seed_from_u64(seed);
</a><a href="#h7-0-191" id="h7-0-191" class="i">+                println!(&quot;seed = {}&quot;, seed);
</a><a href="#h7-0-192" id="h7-0-192" class="i">+
</a><a href="#h7-0-193" id="h7-0-193" class="i">+                #[derive(Debug)]
</a><a href="#h7-0-194" id="h7-0-194" class="i">+                enum Op {
</a><a href="#h7-0-195" id="h7-0-195" class="i">+                    Set,
</a><a href="#h7-0-196" id="h7-0-196" class="i">+                    Delete,
</a><a href="#h7-0-197" id="h7-0-197" class="i">+                    Get,
</a><a href="#h7-0-198" id="h7-0-198" class="i">+                    Scan,
</a><a href="#h7-0-199" id="h7-0-199" class="i">+                }
</a><a href="#h7-0-200" id="h7-0-200" class="i">+
</a><a href="#h7-0-201" id="h7-0-201" class="i">+                impl rand::distributions::Distribution&lt;Op&gt; for rand::distributions::Standard {
</a><a href="#h7-0-202" id="h7-0-202" class="i">+                    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; Op {
</a><a href="#h7-0-203" id="h7-0-203" class="i">+                        match rng.gen_range(0..=3) {
</a><a href="#h7-0-204" id="h7-0-204" class="i">+                            0 =&gt; Op::Set,
</a><a href="#h7-0-205" id="h7-0-205" class="i">+                            1 =&gt; Op::Delete,
</a><a href="#h7-0-206" id="h7-0-206" class="i">+                            2 =&gt; Op::Get,
</a><a href="#h7-0-207" id="h7-0-207" class="i">+                            3 =&gt; Op::Scan,
</a><a href="#h7-0-208" id="h7-0-208" class="i">+                            _ =&gt; panic!(&quot;unexpected value&quot;),
</a><a href="#h7-0-209" id="h7-0-209" class="i">+                        }
</a><a href="#h7-0-210" id="h7-0-210" class="i">+                    }
</a><a href="#h7-0-211" id="h7-0-211" class="i">+                }
</a><a href="#h7-0-212" id="h7-0-212" class="i">+
</a><a href="#h7-0-213" id="h7-0-213" class="i">+                let mut s = $setup;
</a><a href="#h7-0-214" id="h7-0-214" class="i">+                let mut keys: Vec&lt;Vec&lt;u8&gt;&gt; = Vec::new();
</a><a href="#h7-0-215" id="h7-0-215" class="i">+                let mut m = std::collections::BTreeMap::new();
</a><a href="#h7-0-216" id="h7-0-216" class="i">+
</a><a href="#h7-0-217" id="h7-0-217" class="i">+                // Pick an already-used key with 80% probability, or generate a
</a><a href="#h7-0-218" id="h7-0-218" class="i">+                // new key.
</a><a href="#h7-0-219" id="h7-0-219" class="i">+                let mut random_key = |mut rng: &amp;mut rand::rngs::StdRng| -&gt; Vec&lt;u8&gt; {
</a><a href="#h7-0-220" id="h7-0-220" class="i">+                    if rng.gen::&lt;f64&gt;() &lt; 0.8 &amp;&amp; !keys.is_empty() {
</a><a href="#h7-0-221" id="h7-0-221" class="i">+                        keys.choose(&amp;mut rng).unwrap().clone()
</a><a href="#h7-0-222" id="h7-0-222" class="i">+                    } else {
</a><a href="#h7-0-223" id="h7-0-223" class="i">+                        let mut key = vec![0; rng.gen_range(0..=16)];
</a><a href="#h7-0-224" id="h7-0-224" class="i">+                        rng.fill_bytes(&amp;mut key);
</a><a href="#h7-0-225" id="h7-0-225" class="i">+                        keys.push(key.clone());
</a><a href="#h7-0-226" id="h7-0-226" class="i">+                        key
</a><a href="#h7-0-227" id="h7-0-227" class="i">+                    }
</a><a href="#h7-0-228" id="h7-0-228" class="i">+                };
</a><a href="#h7-0-229" id="h7-0-229" class="i">+
</a><a href="#h7-0-230" id="h7-0-230" class="i">+                let random_value = |rng: &amp;mut rand::rngs::StdRng| -&gt; Vec&lt;u8&gt; {
</a><a href="#h7-0-231" id="h7-0-231" class="i">+                    let mut value = vec![0; rng.gen_range(0..=16)];
</a><a href="#h7-0-232" id="h7-0-232" class="i">+                    rng.fill_bytes(&amp;mut value);
</a><a href="#h7-0-233" id="h7-0-233" class="i">+                    value
</a><a href="#h7-0-234" id="h7-0-234" class="i">+                };
</a><a href="#h7-0-235" id="h7-0-235" class="i">+
</a><a href="#h7-0-236" id="h7-0-236" class="i">+                // Run random operations.
</a><a href="#h7-0-237" id="h7-0-237" class="i">+                for _ in 0..NUM_OPS {
</a><a href="#h7-0-238" id="h7-0-238" class="i">+                    match rng.gen::&lt;Op&gt;() {
</a><a href="#h7-0-239" id="h7-0-239" class="i">+                        Op::Set =&gt; {
</a><a href="#h7-0-240" id="h7-0-240" class="i">+                            let key = random_key(&amp;mut rng);
</a><a href="#h7-0-241" id="h7-0-241" class="i">+                            let value = random_value(&amp;mut rng);
</a><a href="#h7-0-242" id="h7-0-242" class="i">+                            println!(&quot;set {:?} = {:?}&quot;, key, value);
</a><a href="#h7-0-243" id="h7-0-243" class="i">+                            s.set(&amp;key, value.clone())?;
</a><a href="#h7-0-244" id="h7-0-244" class="i">+                            m.insert(key, value);
</a><a href="#h7-0-245" id="h7-0-245" class="i">+                        }
</a><a href="#h7-0-246" id="h7-0-246" class="i">+                        Op::Delete =&gt; {
</a><a href="#h7-0-247" id="h7-0-247" class="i">+                            let key = random_key(&amp;mut rng);
</a><a href="#h7-0-248" id="h7-0-248" class="i">+                            println!(&quot;delete {:?}&quot;, key);
</a><a href="#h7-0-249" id="h7-0-249" class="i">+                            s.delete(&amp;key)?;
</a><a href="#h7-0-250" id="h7-0-250" class="i">+                            m.remove(&amp;key);
</a><a href="#h7-0-251" id="h7-0-251" class="i">+                        }
</a><a href="#h7-0-252" id="h7-0-252" class="i">+                        Op::Get =&gt; {
</a><a href="#h7-0-253" id="h7-0-253" class="i">+                            let key = random_key(&amp;mut rng);
</a><a href="#h7-0-254" id="h7-0-254" class="i">+                            let value = s.get(&amp;key)?;
</a><a href="#h7-0-255" id="h7-0-255" class="i">+                            let expect = m.get(&amp;key).cloned();
</a><a href="#h7-0-256" id="h7-0-256" class="i">+                            println!(&quot;get {:?} =&gt; {:?}&quot;, key, value);
</a><a href="#h7-0-257" id="h7-0-257" class="i">+                            assert_eq!(value, expect);
</a><a href="#h7-0-258" id="h7-0-258" class="i">+                        }
</a><a href="#h7-0-259" id="h7-0-259" class="i">+                        Op::Scan =&gt; {
</a><a href="#h7-0-260" id="h7-0-260" class="i">+                            let mut from = random_key(&amp;mut rng);
</a><a href="#h7-0-261" id="h7-0-261" class="i">+                            let mut to = random_key(&amp;mut rng);
</a><a href="#h7-0-262" id="h7-0-262" class="i">+                            if (to &lt; from) {
</a><a href="#h7-0-263" id="h7-0-263" class="i">+                                (from, to) = (to, from)
</a><a href="#h7-0-264" id="h7-0-264" class="i">+                            }
</a><a href="#h7-0-265" id="h7-0-265" class="i">+                            println!(&quot;scan {:?} .. {:?}&quot;, from, to);
</a><a href="#h7-0-266" id="h7-0-266" class="i">+                            let result =
</a><a href="#h7-0-267" id="h7-0-267" class="i">+                                s.scan(from.clone()..to.clone()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h7-0-268" id="h7-0-268" class="i">+                            let expect = m
</a><a href="#h7-0-269" id="h7-0-269" class="i">+                                .range(from..to)
</a><a href="#h7-0-270" id="h7-0-270" class="i">+                                .map(|(k, v)| (k.clone(), v.clone()))
</a><a href="#h7-0-271" id="h7-0-271" class="i">+                                .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h7-0-272" id="h7-0-272" class="i">+                            assert_eq!(result, expect);
</a><a href="#h7-0-273" id="h7-0-273" class="i">+                        }
</a><a href="#h7-0-274" id="h7-0-274" class="i">+                    }
</a><a href="#h7-0-275" id="h7-0-275" class="i">+                }
</a><a href="#h7-0-276" id="h7-0-276" class="i">+
</a><a href="#h7-0-277" id="h7-0-277" class="i">+                // Compare the final states.
</a><a href="#h7-0-278" id="h7-0-278" class="i">+                println!(&quot;comparing final state&quot;);
</a><a href="#h7-0-279" id="h7-0-279" class="i">+
</a><a href="#h7-0-280" id="h7-0-280" class="i">+                let state = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h7-0-281" id="h7-0-281" class="i">+                let expect = m
</a><a href="#h7-0-282" id="h7-0-282" class="i">+                    .range::&lt;Vec&lt;u8&gt;, _&gt;(..)
</a><a href="#h7-0-283" id="h7-0-283" class="i">+                    .map(|(k, v)| (k.clone(), v.clone()))
</a><a href="#h7-0-284" id="h7-0-284" class="i">+                    .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h7-0-285" id="h7-0-285" class="i">+                assert_eq!(state, expect);
</a><a href="#h7-0-286" id="h7-0-286" class="i">+
</a><a href="#h7-0-287" id="h7-0-287" class="i">+                Ok(())
</a><a href="#h7-0-288" id="h7-0-288" class="i">+            }
</a><a href="#h7-0-289" id="h7-0-289" class="i">+        };
</a><a href="#h7-0-290" id="h7-0-290" class="i">+    }
</a><a href="#h7-0-291" id="h7-0-291" class="i">+
</a><a href="#h7-0-292" id="h7-0-292" class="i">+    pub(super) use test_engine; // export for use in submodules
</a><a href="#h7-0-293" id="h7-0-293" class="i">+}
</a><b>diff --git a/<a id="h8" href="../file/src/storage/kv/bitcask.rs.html">src/storage/kv/bitcask.rs</a> b/<a href="../file/src/storage/kv/bitcask.rs.html">src/storage/kv/bitcask.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -1,627 +0,0 @@
</a><a href="#h8-0-0" id="h8-0-0" class="d">-use super::Store;
</a><a href="#h8-0-1" id="h8-0-1" class="d">-use crate::error::Result;
</a><a href="#h8-0-2" id="h8-0-2" class="d">-
</a><a href="#h8-0-3" id="h8-0-3" class="d">-use fs4::FileExt;
</a><a href="#h8-0-4" id="h8-0-4" class="d">-use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, Write};
</a><a href="#h8-0-5" id="h8-0-5" class="d">-use std::path::PathBuf;
</a><a href="#h8-0-6" id="h8-0-6" class="d">-
</a><a href="#h8-0-7" id="h8-0-7" class="d">-/// A very simple variant of BitCask, itself a very simple log-structured
</a><a href="#h8-0-8" id="h8-0-8" class="d">-/// key-value store used e.g. by the Riak database. It is not compatible with
</a><a href="#h8-0-9" id="h8-0-9" class="d">-/// BitCask databases generated by other implementations. See:
</a><a href="#h8-0-10" id="h8-0-10" class="d">-/// https://riak.com/assets/bitcask-intro.pdf
</a><a href="#h8-0-11" id="h8-0-11" class="d">-///
</a><a href="#h8-0-12" id="h8-0-12" class="d">-/// BitCask writes key-value pairs to an append-only log file, and keeps a
</a><a href="#h8-0-13" id="h8-0-13" class="d">-/// mapping of keys to file positions in memory. All live keys must fit in
</a><a href="#h8-0-14" id="h8-0-14" class="d">-/// memory. Deletes write a tombstone value to the log file. To remove old
</a><a href="#h8-0-15" id="h8-0-15" class="d">-/// garbage, logs can be compacted by writing new logs containing only live
</a><a href="#h8-0-16" id="h8-0-16" class="d">-/// data, skipping replaced values and tombstones.
</a><a href="#h8-0-17" id="h8-0-17" class="d">-///
</a><a href="#h8-0-18" id="h8-0-18" class="d">-/// This implementation makes several significant simplifications over
</a><a href="#h8-0-19" id="h8-0-19" class="d">-/// standard BitCask:
</a><a href="#h8-0-20" id="h8-0-20" class="d">-///
</a><a href="#h8-0-21" id="h8-0-21" class="d">-/// - Instead of writing multiple fixed-size log files, it uses a single
</a><a href="#h8-0-22" id="h8-0-22" class="d">-///   append-only log file of arbitrary size. This increases the compaction
</a><a href="#h8-0-23" id="h8-0-23" class="d">-///   volume, since the entire log file must be rewritten on every compaction,
</a><a href="#h8-0-24" id="h8-0-24" class="d">-///   and can exceed the filesystem&#39;s file size limit, but ToyDB databases are
</a><a href="#h8-0-25" id="h8-0-25" class="d">-///   expected to be small.
</a><a href="#h8-0-26" id="h8-0-26" class="d">-///
</a><a href="#h8-0-27" id="h8-0-27" class="d">-/// - Compactions lock the database for reads and writes. This is ok since ToyDB
</a><a href="#h8-0-28" id="h8-0-28" class="d">-///   only compacts during node startup and files are expected to be small.
</a><a href="#h8-0-29" id="h8-0-29" class="d">-///
</a><a href="#h8-0-30" id="h8-0-30" class="d">-/// - Hint files are not used, the log itself is scanned when opened to
</a><a href="#h8-0-31" id="h8-0-31" class="d">-///   build the keydir. Hint files only omit values, and ToyDB values are
</a><a href="#h8-0-32" id="h8-0-32" class="d">-///   expected to be small, so the hint files would be nearly as large as
</a><a href="#h8-0-33" id="h8-0-33" class="d">-///   the compacted log files themselves.
</a><a href="#h8-0-34" id="h8-0-34" class="d">-///
</a><a href="#h8-0-35" id="h8-0-35" class="d">-/// - Log entries don&#39;t contain timestamps or checksums.
</a><a href="#h8-0-36" id="h8-0-36" class="d">-///
</a><a href="#h8-0-37" id="h8-0-37" class="d">-/// The structure of a log entry is:
</a><a href="#h8-0-38" id="h8-0-38" class="d">-///
</a><a href="#h8-0-39" id="h8-0-39" class="d">-/// - Key length as big-endian u32
</a><a href="#h8-0-40" id="h8-0-40" class="d">-/// - Value length as big-endian i32, or -1 for tombstones
</a><a href="#h8-0-41" id="h8-0-41" class="d">-/// - Key as raw bytes (max 2 GB)
</a><a href="#h8-0-42" id="h8-0-42" class="d">-/// - Value as raw bytes (max 2 GB)
</a><a href="#h8-0-43" id="h8-0-43" class="d">-pub struct BitCask {
</a><a href="#h8-0-44" id="h8-0-44" class="d">-    /// The active append-only log file.
</a><a href="#h8-0-45" id="h8-0-45" class="d">-    log: Log,
</a><a href="#h8-0-46" id="h8-0-46" class="d">-    /// Maps keys to a value position and length in the log file.
</a><a href="#h8-0-47" id="h8-0-47" class="d">-    keydir: KeyDir,
</a><a href="#h8-0-48" id="h8-0-48" class="d">-}
</a><a href="#h8-0-49" id="h8-0-49" class="d">-
</a><a href="#h8-0-50" id="h8-0-50" class="d">-/// Maps keys to a value position and length in the log file.
</a><a href="#h8-0-51" id="h8-0-51" class="d">-type KeyDir = std::collections::BTreeMap&lt;Vec&lt;u8&gt;, (u64, u32)&gt;;
</a><a href="#h8-0-52" id="h8-0-52" class="d">-
</a><a href="#h8-0-53" id="h8-0-53" class="d">-impl BitCask {
</a><a href="#h8-0-54" id="h8-0-54" class="d">-    /// Opens or creates a BitCask database in the given file.
</a><a href="#h8-0-55" id="h8-0-55" class="d">-    pub fn new(path: PathBuf) -&gt; Result&lt;Self&gt; {
</a><a href="#h8-0-56" id="h8-0-56" class="d">-        let mut log = Log::new(path)?;
</a><a href="#h8-0-57" id="h8-0-57" class="d">-        let keydir = log.build_keydir()?;
</a><a href="#h8-0-58" id="h8-0-58" class="d">-        Ok(Self { log, keydir })
</a><a href="#h8-0-59" id="h8-0-59" class="d">-    }
</a><a href="#h8-0-60" id="h8-0-60" class="d">-
</a><a href="#h8-0-61" id="h8-0-61" class="d">-    /// Opens a BitCask database, and automatically compacts it if the amount
</a><a href="#h8-0-62" id="h8-0-62" class="d">-    /// of garbage exceeds the given ratio when opened.
</a><a href="#h8-0-63" id="h8-0-63" class="d">-    pub fn new_compact(path: PathBuf, garbage_ratio_threshold: f64) -&gt; Result&lt;Self&gt; {
</a><a href="#h8-0-64" id="h8-0-64" class="d">-        let mut s = Self::new(path)?;
</a><a href="#h8-0-65" id="h8-0-65" class="d">-
</a><a href="#h8-0-66" id="h8-0-66" class="d">-        let (live_bytes, total_bytes) = s.compute_sizes()?;
</a><a href="#h8-0-67" id="h8-0-67" class="d">-        let garbage_bytes = total_bytes - live_bytes;
</a><a href="#h8-0-68" id="h8-0-68" class="d">-        let garbage_ratio = garbage_bytes as f64 / total_bytes as f64;
</a><a href="#h8-0-69" id="h8-0-69" class="d">-        if garbage_bytes &gt; 0 &amp;&amp; garbage_ratio &gt;= garbage_ratio_threshold {
</a><a href="#h8-0-70" id="h8-0-70" class="d">-            log::info!(
</a><a href="#h8-0-71" id="h8-0-71" class="d">-                &quot;Compacting {} to remove {:.1}MB garbage ({:.0}% of {:.1}MB)&quot;,
</a><a href="#h8-0-72" id="h8-0-72" class="d">-                s.log.path.display(),
</a><a href="#h8-0-73" id="h8-0-73" class="d">-                garbage_bytes / 1024 / 1024,
</a><a href="#h8-0-74" id="h8-0-74" class="d">-                garbage_ratio * 100.0,
</a><a href="#h8-0-75" id="h8-0-75" class="d">-                total_bytes / 1024 / 1024
</a><a href="#h8-0-76" id="h8-0-76" class="d">-            );
</a><a href="#h8-0-77" id="h8-0-77" class="d">-            s.compact()?;
</a><a href="#h8-0-78" id="h8-0-78" class="d">-            log::info!(
</a><a href="#h8-0-79" id="h8-0-79" class="d">-                &quot;Compacted {} to size {:.1}MB&quot;,
</a><a href="#h8-0-80" id="h8-0-80" class="d">-                s.log.path.display(),
</a><a href="#h8-0-81" id="h8-0-81" class="d">-                live_bytes / 1024 / 1024
</a><a href="#h8-0-82" id="h8-0-82" class="d">-            );
</a><a href="#h8-0-83" id="h8-0-83" class="d">-        }
</a><a href="#h8-0-84" id="h8-0-84" class="d">-
</a><a href="#h8-0-85" id="h8-0-85" class="d">-        Ok(s)
</a><a href="#h8-0-86" id="h8-0-86" class="d">-    }
</a><a href="#h8-0-87" id="h8-0-87" class="d">-}
</a><a href="#h8-0-88" id="h8-0-88" class="d">-
</a><a href="#h8-0-89" id="h8-0-89" class="d">-impl std::fmt::Display for BitCask {
</a><a href="#h8-0-90" id="h8-0-90" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h8-0-91" id="h8-0-91" class="d">-        write!(f, &quot;bitcask&quot;)
</a><a href="#h8-0-92" id="h8-0-92" class="d">-    }
</a><a href="#h8-0-93" id="h8-0-93" class="d">-}
</a><a href="#h8-0-94" id="h8-0-94" class="d">-
</a><a href="#h8-0-95" id="h8-0-95" class="d">-impl Store for BitCask {
</a><a href="#h8-0-96" id="h8-0-96" class="d">-    type ScanIterator&lt;&#39;a&gt; = ScanIterator&lt;&#39;a&gt;;
</a><a href="#h8-0-97" id="h8-0-97" class="d">-
</a><a href="#h8-0-98" id="h8-0-98" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-99" id="h8-0-99" class="d">-        self.log.write_entry(key, None)?;
</a><a href="#h8-0-100" id="h8-0-100" class="d">-        self.keydir.remove(key);
</a><a href="#h8-0-101" id="h8-0-101" class="d">-        Ok(())
</a><a href="#h8-0-102" id="h8-0-102" class="d">-    }
</a><a href="#h8-0-103" id="h8-0-103" class="d">-
</a><a href="#h8-0-104" id="h8-0-104" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-105" id="h8-0-105" class="d">-        Ok(self.log.file.sync_all()?)
</a><a href="#h8-0-106" id="h8-0-106" class="d">-    }
</a><a href="#h8-0-107" id="h8-0-107" class="d">-
</a><a href="#h8-0-108" id="h8-0-108" class="d">-    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h8-0-109" id="h8-0-109" class="d">-        if let Some((value_pos, value_len)) = self.keydir.get(key) {
</a><a href="#h8-0-110" id="h8-0-110" class="d">-            Ok(Some(self.log.read_value(*value_pos, *value_len)?))
</a><a href="#h8-0-111" id="h8-0-111" class="d">-        } else {
</a><a href="#h8-0-112" id="h8-0-112" class="d">-            Ok(None)
</a><a href="#h8-0-113" id="h8-0-113" class="d">-        }
</a><a href="#h8-0-114" id="h8-0-114" class="d">-    }
</a><a href="#h8-0-115" id="h8-0-115" class="d">-
</a><a href="#h8-0-116" id="h8-0-116" class="d">-    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h8-0-117" id="h8-0-117" class="d">-        ScanIterator { inner: self.keydir.range(range), log: &amp;mut self.log }
</a><a href="#h8-0-118" id="h8-0-118" class="d">-    }
</a><a href="#h8-0-119" id="h8-0-119" class="d">-
</a><a href="#h8-0-120" id="h8-0-120" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-121" id="h8-0-121" class="d">-        let (pos, len) = self.log.write_entry(key, Some(&amp;*value))?;
</a><a href="#h8-0-122" id="h8-0-122" class="d">-        let value_len = value.len() as u32;
</a><a href="#h8-0-123" id="h8-0-123" class="d">-        self.keydir.insert(key.to_vec(), (pos + len as u64 - value_len as u64, value_len));
</a><a href="#h8-0-124" id="h8-0-124" class="d">-        Ok(())
</a><a href="#h8-0-125" id="h8-0-125" class="d">-    }
</a><a href="#h8-0-126" id="h8-0-126" class="d">-}
</a><a href="#h8-0-127" id="h8-0-127" class="d">-
</a><a href="#h8-0-128" id="h8-0-128" class="d">-pub struct ScanIterator&lt;&#39;a&gt; {
</a><a href="#h8-0-129" id="h8-0-129" class="d">-    inner: std::collections::btree_map::Range&lt;&#39;a, Vec&lt;u8&gt;, (u64, u32)&gt;,
</a><a href="#h8-0-130" id="h8-0-130" class="d">-    log: &amp;&#39;a mut Log,
</a><a href="#h8-0-131" id="h8-0-131" class="d">-}
</a><a href="#h8-0-132" id="h8-0-132" class="d">-
</a><a href="#h8-0-133" id="h8-0-133" class="d">-impl&lt;&#39;a&gt; ScanIterator&lt;&#39;a&gt; {
</a><a href="#h8-0-134" id="h8-0-134" class="d">-    fn map(&amp;mut self, item: (&amp;Vec&lt;u8&gt;, &amp;(u64, u32))) -&gt; &lt;Self as Iterator&gt;::Item {
</a><a href="#h8-0-135" id="h8-0-135" class="d">-        let (key, (value_pos, value_len)) = item;
</a><a href="#h8-0-136" id="h8-0-136" class="d">-        Ok((key.clone(), self.log.read_value(*value_pos, *value_len)?))
</a><a href="#h8-0-137" id="h8-0-137" class="d">-    }
</a><a href="#h8-0-138" id="h8-0-138" class="d">-}
</a><a href="#h8-0-139" id="h8-0-139" class="d">-
</a><a href="#h8-0-140" id="h8-0-140" class="d">-impl&lt;&#39;a&gt; Iterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h8-0-141" id="h8-0-141" class="d">-    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a><a href="#h8-0-142" id="h8-0-142" class="d">-
</a><a href="#h8-0-143" id="h8-0-143" class="d">-    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h8-0-144" id="h8-0-144" class="d">-        self.inner.next().map(|item| self.map(item))
</a><a href="#h8-0-145" id="h8-0-145" class="d">-    }
</a><a href="#h8-0-146" id="h8-0-146" class="d">-}
</a><a href="#h8-0-147" id="h8-0-147" class="d">-
</a><a href="#h8-0-148" id="h8-0-148" class="d">-impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h8-0-149" id="h8-0-149" class="d">-    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h8-0-150" id="h8-0-150" class="d">-        self.inner.next_back().map(|item| self.map(item))
</a><a href="#h8-0-151" id="h8-0-151" class="d">-    }
</a><a href="#h8-0-152" id="h8-0-152" class="d">-}
</a><a href="#h8-0-153" id="h8-0-153" class="d">-
</a><a href="#h8-0-154" id="h8-0-154" class="d">-impl BitCask {
</a><a href="#h8-0-155" id="h8-0-155" class="d">-    /// Compacts the current log file by writing out a new log file containing
</a><a href="#h8-0-156" id="h8-0-156" class="d">-    /// only live keys and replacing the current file with it.
</a><a href="#h8-0-157" id="h8-0-157" class="d">-    pub fn compact(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-158" id="h8-0-158" class="d">-        let mut tmp_path = self.log.path.clone();
</a><a href="#h8-0-159" id="h8-0-159" class="d">-        tmp_path.set_extension(&quot;new&quot;);
</a><a href="#h8-0-160" id="h8-0-160" class="d">-        let (mut new_log, new_keydir) = self.write_log(tmp_path)?;
</a><a href="#h8-0-161" id="h8-0-161" class="d">-
</a><a href="#h8-0-162" id="h8-0-162" class="d">-        std::fs::rename(&amp;new_log.path, &amp;self.log.path)?;
</a><a href="#h8-0-163" id="h8-0-163" class="d">-        new_log.path = self.log.path.clone();
</a><a href="#h8-0-164" id="h8-0-164" class="d">-
</a><a href="#h8-0-165" id="h8-0-165" class="d">-        self.log = new_log;
</a><a href="#h8-0-166" id="h8-0-166" class="d">-        self.keydir = new_keydir;
</a><a href="#h8-0-167" id="h8-0-167" class="d">-        Ok(())
</a><a href="#h8-0-168" id="h8-0-168" class="d">-    }
</a><a href="#h8-0-169" id="h8-0-169" class="d">-
</a><a href="#h8-0-170" id="h8-0-170" class="d">-    /// Computes the live and total sizes of the log file, by iterating over the
</a><a href="#h8-0-171" id="h8-0-171" class="d">-    /// keydir and fetching the file&#39;s size from the filesystem metadata. The
</a><a href="#h8-0-172" id="h8-0-172" class="d">-    /// garbage size (i.e. old, replaced entries and tombstones) is the
</a><a href="#h8-0-173" id="h8-0-173" class="d">-    /// difference between these values.
</a><a href="#h8-0-174" id="h8-0-174" class="d">-    ///
</a><a href="#h8-0-175" id="h8-0-175" class="d">-    /// We could keep track of these values during mutations, but it&#39;s not
</a><a href="#h8-0-176" id="h8-0-176" class="d">-    /// currently needed -- we only use this to determine whether to compact the
</a><a href="#h8-0-177" id="h8-0-177" class="d">-    /// database when it&#39;s initially opened, so we&#39;d need to run basically the
</a><a href="#h8-0-178" id="h8-0-178" class="d">-    /// same computations anyway.
</a><a href="#h8-0-179" id="h8-0-179" class="d">-    pub fn compute_sizes(&amp;mut self) -&gt; Result&lt;(u64, u64)&gt; {
</a><a href="#h8-0-180" id="h8-0-180" class="d">-        let total_size = self.log.file.metadata()?.len();
</a><a href="#h8-0-181" id="h8-0-181" class="d">-        let live_size = self.keydir.iter().fold(0, |size, (key, (_, value_len))| {
</a><a href="#h8-0-182" id="h8-0-182" class="d">-            size + 4 + 4 + key.len() as u64 + *value_len as u64
</a><a href="#h8-0-183" id="h8-0-183" class="d">-        });
</a><a href="#h8-0-184" id="h8-0-184" class="d">-        Ok((live_size, total_size))
</a><a href="#h8-0-185" id="h8-0-185" class="d">-    }
</a><a href="#h8-0-186" id="h8-0-186" class="d">-
</a><a href="#h8-0-187" id="h8-0-187" class="d">-    /// Writes out a new log file with the live entries of the current log file
</a><a href="#h8-0-188" id="h8-0-188" class="d">-    /// and returns it along with its keydir. Entries are written in key order.
</a><a href="#h8-0-189" id="h8-0-189" class="d">-    fn write_log(&amp;mut self, path: PathBuf) -&gt; Result&lt;(Log, KeyDir)&gt; {
</a><a href="#h8-0-190" id="h8-0-190" class="d">-        let mut new_keydir = KeyDir::new();
</a><a href="#h8-0-191" id="h8-0-191" class="d">-        let mut new_log = Log::new(path)?;
</a><a href="#h8-0-192" id="h8-0-192" class="d">-        new_log.file.set_len(0)?; // truncate file if it exists
</a><a href="#h8-0-193" id="h8-0-193" class="d">-        for (key, (value_pos, value_len)) in self.keydir.iter() {
</a><a href="#h8-0-194" id="h8-0-194" class="d">-            let value = self.log.read_value(*value_pos, *value_len)?;
</a><a href="#h8-0-195" id="h8-0-195" class="d">-            let (pos, len) = new_log.write_entry(key, Some(&amp;value))?;
</a><a href="#h8-0-196" id="h8-0-196" class="d">-            new_keydir.insert(key.clone(), (pos + len as u64 - *value_len as u64, *value_len));
</a><a href="#h8-0-197" id="h8-0-197" class="d">-        }
</a><a href="#h8-0-198" id="h8-0-198" class="d">-        Ok((new_log, new_keydir))
</a><a href="#h8-0-199" id="h8-0-199" class="d">-    }
</a><a href="#h8-0-200" id="h8-0-200" class="d">-}
</a><a href="#h8-0-201" id="h8-0-201" class="d">-
</a><a href="#h8-0-202" id="h8-0-202" class="d">-/// Attempt to flush the file when the database is closed.
</a><a href="#h8-0-203" id="h8-0-203" class="d">-impl Drop for BitCask {
</a><a href="#h8-0-204" id="h8-0-204" class="d">-    fn drop(&amp;mut self) {
</a><a href="#h8-0-205" id="h8-0-205" class="d">-        if let Err(error) = self.flush() {
</a><a href="#h8-0-206" id="h8-0-206" class="d">-            log::error!(&quot;failed to flush file: {}&quot;, error)
</a><a href="#h8-0-207" id="h8-0-207" class="d">-        }
</a><a href="#h8-0-208" id="h8-0-208" class="d">-    }
</a><a href="#h8-0-209" id="h8-0-209" class="d">-}
</a><a href="#h8-0-210" id="h8-0-210" class="d">-
</a><a href="#h8-0-211" id="h8-0-211" class="d">-/// A BitCask append-only log file, containing a sequence of key/value
</a><a href="#h8-0-212" id="h8-0-212" class="d">-/// entries encoded as follows;
</a><a href="#h8-0-213" id="h8-0-213" class="d">-///
</a><a href="#h8-0-214" id="h8-0-214" class="d">-/// - Key length as big-endian u64 (8 bytes)
</a><a href="#h8-0-215" id="h8-0-215" class="d">-/// - Value length as big-endian i64, or -1 for tombstones (8 bytes)
</a><a href="#h8-0-216" id="h8-0-216" class="d">-/// - Key as raw bytes
</a><a href="#h8-0-217" id="h8-0-217" class="d">-/// - Value as raw bytes
</a><a href="#h8-0-218" id="h8-0-218" class="d">-struct Log {
</a><a href="#h8-0-219" id="h8-0-219" class="d">-    /// Path to the log file.
</a><a href="#h8-0-220" id="h8-0-220" class="d">-    path: PathBuf,
</a><a href="#h8-0-221" id="h8-0-221" class="d">-    /// The opened file containing the log.
</a><a href="#h8-0-222" id="h8-0-222" class="d">-    file: std::fs::File,
</a><a href="#h8-0-223" id="h8-0-223" class="d">-}
</a><a href="#h8-0-224" id="h8-0-224" class="d">-
</a><a href="#h8-0-225" id="h8-0-225" class="d">-impl Log {
</a><a href="#h8-0-226" id="h8-0-226" class="d">-    /// Opens a log file, or creates one if it does not exist. Takes out an
</a><a href="#h8-0-227" id="h8-0-227" class="d">-    /// exclusive lock on the file until it is closed, or errors if the lock is
</a><a href="#h8-0-228" id="h8-0-228" class="d">-    /// already held.
</a><a href="#h8-0-229" id="h8-0-229" class="d">-    fn new(path: PathBuf) -&gt; Result&lt;Self&gt; {
</a><a href="#h8-0-230" id="h8-0-230" class="d">-        if let Some(dir) = path.parent() {
</a><a href="#h8-0-231" id="h8-0-231" class="d">-            std::fs::create_dir_all(dir)?
</a><a href="#h8-0-232" id="h8-0-232" class="d">-        }
</a><a href="#h8-0-233" id="h8-0-233" class="d">-        let file = std::fs::OpenOptions::new().read(true).write(true).create(true).open(&amp;path)?;
</a><a href="#h8-0-234" id="h8-0-234" class="d">-        file.try_lock_exclusive()?;
</a><a href="#h8-0-235" id="h8-0-235" class="d">-        Ok(Self { path, file })
</a><a href="#h8-0-236" id="h8-0-236" class="d">-    }
</a><a href="#h8-0-237" id="h8-0-237" class="d">-
</a><a href="#h8-0-238" id="h8-0-238" class="d">-    /// Builds a keydir by scanning the log file. If an incomplete entry is
</a><a href="#h8-0-239" id="h8-0-239" class="d">-    /// encountered, it is assumed to be caused by an incomplete write operation
</a><a href="#h8-0-240" id="h8-0-240" class="d">-    /// and the remainder of the file is truncated.
</a><a href="#h8-0-241" id="h8-0-241" class="d">-    fn build_keydir(&amp;mut self) -&gt; Result&lt;KeyDir&gt; {
</a><a href="#h8-0-242" id="h8-0-242" class="d">-        let mut len_buf = [0u8; 4];
</a><a href="#h8-0-243" id="h8-0-243" class="d">-        let mut keydir = KeyDir::new();
</a><a href="#h8-0-244" id="h8-0-244" class="d">-        let file_len = self.file.metadata()?.len();
</a><a href="#h8-0-245" id="h8-0-245" class="d">-        let mut r = BufReader::new(&amp;mut self.file);
</a><a href="#h8-0-246" id="h8-0-246" class="d">-        let mut pos = r.seek(SeekFrom::Start(0))?;
</a><a href="#h8-0-247" id="h8-0-247" class="d">-
</a><a href="#h8-0-248" id="h8-0-248" class="d">-        while pos &lt; file_len {
</a><a href="#h8-0-249" id="h8-0-249" class="d">-            // Read the next entry from the file, returning the key, value
</a><a href="#h8-0-250" id="h8-0-250" class="d">-            // position, and value length or None for tombstones.
</a><a href="#h8-0-251" id="h8-0-251" class="d">-            let result = || -&gt; std::result::Result&lt;(Vec&lt;u8&gt;, u64, Option&lt;u32&gt;), std::io::Error&gt; {
</a><a href="#h8-0-252" id="h8-0-252" class="d">-                r.read_exact(&amp;mut len_buf)?;
</a><a href="#h8-0-253" id="h8-0-253" class="d">-                let key_len = u32::from_be_bytes(len_buf);
</a><a href="#h8-0-254" id="h8-0-254" class="d">-                r.read_exact(&amp;mut len_buf)?;
</a><a href="#h8-0-255" id="h8-0-255" class="d">-                let value_len_or_tombstone = match i32::from_be_bytes(len_buf) {
</a><a href="#h8-0-256" id="h8-0-256" class="d">-                    l if l &gt;= 0 =&gt; Some(l as u32),
</a><a href="#h8-0-257" id="h8-0-257" class="d">-                    _ =&gt; None, // -1 for tombstones
</a><a href="#h8-0-258" id="h8-0-258" class="d">-                };
</a><a href="#h8-0-259" id="h8-0-259" class="d">-                let value_pos = pos + 4 + 4 + key_len as u64;
</a><a href="#h8-0-260" id="h8-0-260" class="d">-
</a><a href="#h8-0-261" id="h8-0-261" class="d">-                let mut key = vec![0; key_len as usize];
</a><a href="#h8-0-262" id="h8-0-262" class="d">-                r.read_exact(&amp;mut key)?;
</a><a href="#h8-0-263" id="h8-0-263" class="d">-
</a><a href="#h8-0-264" id="h8-0-264" class="d">-                if let Some(value_len) = value_len_or_tombstone {
</a><a href="#h8-0-265" id="h8-0-265" class="d">-                    if value_pos + value_len as u64 &gt; file_len {
</a><a href="#h8-0-266" id="h8-0-266" class="d">-                        return Err(std::io::Error::new(
</a><a href="#h8-0-267" id="h8-0-267" class="d">-                            std::io::ErrorKind::UnexpectedEof,
</a><a href="#h8-0-268" id="h8-0-268" class="d">-                            &quot;value extends beyond end of file&quot;,
</a><a href="#h8-0-269" id="h8-0-269" class="d">-                        ));
</a><a href="#h8-0-270" id="h8-0-270" class="d">-                    }
</a><a href="#h8-0-271" id="h8-0-271" class="d">-                    r.seek_relative(value_len as i64)?; // avoids discarding buffer
</a><a href="#h8-0-272" id="h8-0-272" class="d">-                }
</a><a href="#h8-0-273" id="h8-0-273" class="d">-
</a><a href="#h8-0-274" id="h8-0-274" class="d">-                Ok((key, value_pos, value_len_or_tombstone))
</a><a href="#h8-0-275" id="h8-0-275" class="d">-            }();
</a><a href="#h8-0-276" id="h8-0-276" class="d">-
</a><a href="#h8-0-277" id="h8-0-277" class="d">-            match result {
</a><a href="#h8-0-278" id="h8-0-278" class="d">-                // Populate the keydir with the entry, or remove it on tombstones.
</a><a href="#h8-0-279" id="h8-0-279" class="d">-                Ok((key, value_pos, Some(value_len))) =&gt; {
</a><a href="#h8-0-280" id="h8-0-280" class="d">-                    keydir.insert(key, (value_pos, value_len));
</a><a href="#h8-0-281" id="h8-0-281" class="d">-                    pos = value_pos + value_len as u64;
</a><a href="#h8-0-282" id="h8-0-282" class="d">-                }
</a><a href="#h8-0-283" id="h8-0-283" class="d">-                Ok((key, value_pos, None)) =&gt; {
</a><a href="#h8-0-284" id="h8-0-284" class="d">-                    keydir.remove(&amp;key);
</a><a href="#h8-0-285" id="h8-0-285" class="d">-                    pos = value_pos;
</a><a href="#h8-0-286" id="h8-0-286" class="d">-                }
</a><a href="#h8-0-287" id="h8-0-287" class="d">-                // If an incomplete entry was found at the end of the file, assume an
</a><a href="#h8-0-288" id="h8-0-288" class="d">-                // incomplete write and truncate the file.
</a><a href="#h8-0-289" id="h8-0-289" class="d">-                Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof =&gt; {
</a><a href="#h8-0-290" id="h8-0-290" class="d">-                    log::error!(&quot;Found incomplete entry at offset {}, truncating file&quot;, pos);
</a><a href="#h8-0-291" id="h8-0-291" class="d">-                    self.file.set_len(pos)?;
</a><a href="#h8-0-292" id="h8-0-292" class="d">-                    break;
</a><a href="#h8-0-293" id="h8-0-293" class="d">-                }
</a><a href="#h8-0-294" id="h8-0-294" class="d">-                Err(err) =&gt; return Err(err.into()),
</a><a href="#h8-0-295" id="h8-0-295" class="d">-            }
</a><a href="#h8-0-296" id="h8-0-296" class="d">-        }
</a><a href="#h8-0-297" id="h8-0-297" class="d">-
</a><a href="#h8-0-298" id="h8-0-298" class="d">-        Ok(keydir)
</a><a href="#h8-0-299" id="h8-0-299" class="d">-    }
</a><a href="#h8-0-300" id="h8-0-300" class="d">-
</a><a href="#h8-0-301" id="h8-0-301" class="d">-    /// Reads a value from the log file.
</a><a href="#h8-0-302" id="h8-0-302" class="d">-    fn read_value(&amp;mut self, value_pos: u64, value_len: u32) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h8-0-303" id="h8-0-303" class="d">-        let mut value = vec![0; value_len as usize];
</a><a href="#h8-0-304" id="h8-0-304" class="d">-        self.file.seek(SeekFrom::Start(value_pos))?;
</a><a href="#h8-0-305" id="h8-0-305" class="d">-        self.file.read_exact(&amp;mut value)?;
</a><a href="#h8-0-306" id="h8-0-306" class="d">-        Ok(value)
</a><a href="#h8-0-307" id="h8-0-307" class="d">-    }
</a><a href="#h8-0-308" id="h8-0-308" class="d">-
</a><a href="#h8-0-309" id="h8-0-309" class="d">-    /// Appends a key/value entry to the log file, using a None value for
</a><a href="#h8-0-310" id="h8-0-310" class="d">-    /// tombstones. It returns the position and length of the entry.
</a><a href="#h8-0-311" id="h8-0-311" class="d">-    fn write_entry(&amp;mut self, key: &amp;[u8], value: Option&lt;&amp;[u8]&gt;) -&gt; Result&lt;(u64, u32)&gt; {
</a><a href="#h8-0-312" id="h8-0-312" class="d">-        let key_len = key.len() as u32;
</a><a href="#h8-0-313" id="h8-0-313" class="d">-        let value_len = value.map_or(0, |v| v.len() as u32);
</a><a href="#h8-0-314" id="h8-0-314" class="d">-        let value_len_or_tombstone = value.map_or(-1, |v| v.len() as i32);
</a><a href="#h8-0-315" id="h8-0-315" class="d">-        let len = 4 + 4 + key_len + value_len;
</a><a href="#h8-0-316" id="h8-0-316" class="d">-
</a><a href="#h8-0-317" id="h8-0-317" class="d">-        let pos = self.file.seek(SeekFrom::End(0))?;
</a><a href="#h8-0-318" id="h8-0-318" class="d">-        let mut w = BufWriter::with_capacity(len as usize, &amp;mut self.file);
</a><a href="#h8-0-319" id="h8-0-319" class="d">-        w.write_all(&amp;key_len.to_be_bytes())?;
</a><a href="#h8-0-320" id="h8-0-320" class="d">-        w.write_all(&amp;value_len_or_tombstone.to_be_bytes())?;
</a><a href="#h8-0-321" id="h8-0-321" class="d">-        w.write_all(key)?;
</a><a href="#h8-0-322" id="h8-0-322" class="d">-        if let Some(value) = value {
</a><a href="#h8-0-323" id="h8-0-323" class="d">-            w.write_all(value)?;
</a><a href="#h8-0-324" id="h8-0-324" class="d">-        }
</a><a href="#h8-0-325" id="h8-0-325" class="d">-        w.flush()?;
</a><a href="#h8-0-326" id="h8-0-326" class="d">-
</a><a href="#h8-0-327" id="h8-0-327" class="d">-        Ok((pos, len))
</a><a href="#h8-0-328" id="h8-0-328" class="d">-    }
</a><a href="#h8-0-329" id="h8-0-329" class="d">-
</a><a href="#h8-0-330" id="h8-0-330" class="d">-    #[cfg(test)]
</a><a href="#h8-0-331" id="h8-0-331" class="d">-    /// Prints the entire log file to the given writer in human-readable form.
</a><a href="#h8-0-332" id="h8-0-332" class="d">-    fn print&lt;W: Write&gt;(&amp;mut self, w: &amp;mut W) -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-333" id="h8-0-333" class="d">-        let mut len_buf = [0u8; 4];
</a><a href="#h8-0-334" id="h8-0-334" class="d">-        let file_len = self.file.metadata()?.len();
</a><a href="#h8-0-335" id="h8-0-335" class="d">-        let mut r = BufReader::new(&amp;mut self.file);
</a><a href="#h8-0-336" id="h8-0-336" class="d">-        let mut pos = r.seek(SeekFrom::Start(0))?;
</a><a href="#h8-0-337" id="h8-0-337" class="d">-        let mut idx = 0;
</a><a href="#h8-0-338" id="h8-0-338" class="d">-
</a><a href="#h8-0-339" id="h8-0-339" class="d">-        while pos &lt; file_len {
</a><a href="#h8-0-340" id="h8-0-340" class="d">-            writeln!(w, &quot;entry = {}, offset {}&quot;, idx, pos)?;
</a><a href="#h8-0-341" id="h8-0-341" class="d">-
</a><a href="#h8-0-342" id="h8-0-342" class="d">-            r.read_exact(&amp;mut len_buf)?;
</a><a href="#h8-0-343" id="h8-0-343" class="d">-            let key_len = u32::from_be_bytes(len_buf);
</a><a href="#h8-0-344" id="h8-0-344" class="d">-            writeln!(w, &quot;klen  = {} {:x?}&quot;, key_len, len_buf)?;
</a><a href="#h8-0-345" id="h8-0-345" class="d">-
</a><a href="#h8-0-346" id="h8-0-346" class="d">-            r.read_exact(&amp;mut len_buf)?;
</a><a href="#h8-0-347" id="h8-0-347" class="d">-            let value_len_or_tombstone = i32::from_be_bytes(len_buf); // NB: -1 for tombstones
</a><a href="#h8-0-348" id="h8-0-348" class="d">-            let value_len = value_len_or_tombstone.max(0) as u32;
</a><a href="#h8-0-349" id="h8-0-349" class="d">-            writeln!(w, &quot;vlen  = {} {:x?}&quot;, value_len_or_tombstone, len_buf)?;
</a><a href="#h8-0-350" id="h8-0-350" class="d">-
</a><a href="#h8-0-351" id="h8-0-351" class="d">-            let mut key = vec![0; key_len as usize];
</a><a href="#h8-0-352" id="h8-0-352" class="d">-            r.read_exact(&amp;mut key)?;
</a><a href="#h8-0-353" id="h8-0-353" class="d">-            write!(w, &quot;key   = &quot;)?;
</a><a href="#h8-0-354" id="h8-0-354" class="d">-            if let Ok(str) = std::str::from_utf8(&amp;key) {
</a><a href="#h8-0-355" id="h8-0-355" class="d">-                write!(w, r#&quot;&quot;{}&quot; &quot;#, str)?;
</a><a href="#h8-0-356" id="h8-0-356" class="d">-            }
</a><a href="#h8-0-357" id="h8-0-357" class="d">-            writeln!(w, &quot;{:x?}&quot;, key)?;
</a><a href="#h8-0-358" id="h8-0-358" class="d">-
</a><a href="#h8-0-359" id="h8-0-359" class="d">-            let mut value = vec![0; value_len as usize];
</a><a href="#h8-0-360" id="h8-0-360" class="d">-            r.read_exact(&amp;mut value)?;
</a><a href="#h8-0-361" id="h8-0-361" class="d">-            write!(w, &quot;value = &quot;)?;
</a><a href="#h8-0-362" id="h8-0-362" class="d">-            if value_len_or_tombstone &lt; 0 {
</a><a href="#h8-0-363" id="h8-0-363" class="d">-                write!(w, &quot;tombstone &quot;)?;
</a><a href="#h8-0-364" id="h8-0-364" class="d">-            } else if let Ok(str) = std::str::from_utf8(&amp;value) {
</a><a href="#h8-0-365" id="h8-0-365" class="d">-                if str.chars().all(|c| !c.is_control()) {
</a><a href="#h8-0-366" id="h8-0-366" class="d">-                    write!(w, r#&quot;&quot;{}&quot; &quot;#, str)?;
</a><a href="#h8-0-367" id="h8-0-367" class="d">-                }
</a><a href="#h8-0-368" id="h8-0-368" class="d">-            }
</a><a href="#h8-0-369" id="h8-0-369" class="d">-            write!(w, &quot;{:x?}\n\n&quot;, value)?;
</a><a href="#h8-0-370" id="h8-0-370" class="d">-
</a><a href="#h8-0-371" id="h8-0-371" class="d">-            pos += 4 + 4 + key_len as u64 + value_len as u64;
</a><a href="#h8-0-372" id="h8-0-372" class="d">-            idx += 1;
</a><a href="#h8-0-373" id="h8-0-373" class="d">-        }
</a><a href="#h8-0-374" id="h8-0-374" class="d">-        Ok(())
</a><a href="#h8-0-375" id="h8-0-375" class="d">-    }
</a><a href="#h8-0-376" id="h8-0-376" class="d">-}
</a><a href="#h8-0-377" id="h8-0-377" class="d">-
</a><a href="#h8-0-378" id="h8-0-378" class="d">-#[cfg(test)]
</a><a href="#h8-0-379" id="h8-0-379" class="d">-mod tests {
</a><a href="#h8-0-380" id="h8-0-380" class="d">-    use super::*;
</a><a href="#h8-0-381" id="h8-0-381" class="d">-
</a><a href="#h8-0-382" id="h8-0-382" class="d">-    const GOLDEN_DIR: &amp;str = &quot;src/storage/kv/golden/bitcask&quot;;
</a><a href="#h8-0-383" id="h8-0-383" class="d">-
</a><a href="#h8-0-384" id="h8-0-384" class="d">-    super::super::tests::test_store!({
</a><a href="#h8-0-385" id="h8-0-385" class="d">-        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h8-0-386" id="h8-0-386" class="d">-        BitCask::new(path)?
</a><a href="#h8-0-387" id="h8-0-387" class="d">-    });
</a><a href="#h8-0-388" id="h8-0-388" class="d">-
</a><a href="#h8-0-389" id="h8-0-389" class="d">-    /// Creates a new BitCask store for testing.
</a><a href="#h8-0-390" id="h8-0-390" class="d">-    fn setup() -&gt; Result&lt;BitCask&gt; {
</a><a href="#h8-0-391" id="h8-0-391" class="d">-        BitCask::new(tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;))
</a><a href="#h8-0-392" id="h8-0-392" class="d">-    }
</a><a href="#h8-0-393" id="h8-0-393" class="d">-
</a><a href="#h8-0-394" id="h8-0-394" class="d">-    /// Writes various values primarily for testing log file handling.
</a><a href="#h8-0-395" id="h8-0-395" class="d">-    ///
</a><a href="#h8-0-396" id="h8-0-396" class="d">-    /// - &#39;&#39;: empty key and value
</a><a href="#h8-0-397" id="h8-0-397" class="d">-    /// - a: write
</a><a href="#h8-0-398" id="h8-0-398" class="d">-    /// - b: write, write
</a><a href="#h8-0-399" id="h8-0-399" class="d">-    /// - c: write, delete, write
</a><a href="#h8-0-400" id="h8-0-400" class="d">-    /// - d: delete, write
</a><a href="#h8-0-401" id="h8-0-401" class="d">-    /// - e: write, delete
</a><a href="#h8-0-402" id="h8-0-402" class="d">-    /// - f: delete
</a><a href="#h8-0-403" id="h8-0-403" class="d">-    fn setup_log(s: &amp;mut BitCask) -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-404" id="h8-0-404" class="d">-        s.set(b&quot;b&quot;, vec![0x01])?;
</a><a href="#h8-0-405" id="h8-0-405" class="d">-        s.set(b&quot;b&quot;, vec![0x02])?;
</a><a href="#h8-0-406" id="h8-0-406" class="d">-
</a><a href="#h8-0-407" id="h8-0-407" class="d">-        s.set(b&quot;e&quot;, vec![0x05])?;
</a><a href="#h8-0-408" id="h8-0-408" class="d">-        s.delete(b&quot;e&quot;)?;
</a><a href="#h8-0-409" id="h8-0-409" class="d">-
</a><a href="#h8-0-410" id="h8-0-410" class="d">-        s.set(b&quot;c&quot;, vec![0x00])?;
</a><a href="#h8-0-411" id="h8-0-411" class="d">-        s.delete(b&quot;c&quot;)?;
</a><a href="#h8-0-412" id="h8-0-412" class="d">-        s.set(b&quot;c&quot;, vec![0x03])?;
</a><a href="#h8-0-413" id="h8-0-413" class="d">-
</a><a href="#h8-0-414" id="h8-0-414" class="d">-        s.set(b&quot;&quot;, vec![])?;
</a><a href="#h8-0-415" id="h8-0-415" class="d">-
</a><a href="#h8-0-416" id="h8-0-416" class="d">-        s.set(b&quot;a&quot;, vec![0x01])?;
</a><a href="#h8-0-417" id="h8-0-417" class="d">-
</a><a href="#h8-0-418" id="h8-0-418" class="d">-        s.delete(b&quot;f&quot;)?;
</a><a href="#h8-0-419" id="h8-0-419" class="d">-
</a><a href="#h8-0-420" id="h8-0-420" class="d">-        s.delete(b&quot;d&quot;)?;
</a><a href="#h8-0-421" id="h8-0-421" class="d">-        s.set(b&quot;d&quot;, vec![0x04])?;
</a><a href="#h8-0-422" id="h8-0-422" class="d">-
</a><a href="#h8-0-423" id="h8-0-423" class="d">-        // Make sure the scan yields the expected results.
</a><a href="#h8-0-424" id="h8-0-424" class="d">-        assert_eq!(
</a><a href="#h8-0-425" id="h8-0-425" class="d">-            vec![
</a><a href="#h8-0-426" id="h8-0-426" class="d">-                (b&quot;&quot;.to_vec(), vec![]),
</a><a href="#h8-0-427" id="h8-0-427" class="d">-                (b&quot;a&quot;.to_vec(), vec![0x01]),
</a><a href="#h8-0-428" id="h8-0-428" class="d">-                (b&quot;b&quot;.to_vec(), vec![0x02]),
</a><a href="#h8-0-429" id="h8-0-429" class="d">-                (b&quot;c&quot;.to_vec(), vec![0x03]),
</a><a href="#h8-0-430" id="h8-0-430" class="d">-                (b&quot;d&quot;.to_vec(), vec![0x04]),
</a><a href="#h8-0-431" id="h8-0-431" class="d">-            ],
</a><a href="#h8-0-432" id="h8-0-432" class="d">-            s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h8-0-433" id="h8-0-433" class="d">-        );
</a><a href="#h8-0-434" id="h8-0-434" class="d">-
</a><a href="#h8-0-435" id="h8-0-435" class="d">-        Ok(())
</a><a href="#h8-0-436" id="h8-0-436" class="d">-    }
</a><a href="#h8-0-437" id="h8-0-437" class="d">-
</a><a href="#h8-0-438" id="h8-0-438" class="d">-    #[test]
</a><a href="#h8-0-439" id="h8-0-439" class="d">-    /// Tests that logs are written correctly using a golden file.
</a><a href="#h8-0-440" id="h8-0-440" class="d">-    fn log() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-441" id="h8-0-441" class="d">-        let mut s = setup()?;
</a><a href="#h8-0-442" id="h8-0-442" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h8-0-443" id="h8-0-443" class="d">-
</a><a href="#h8-0-444" id="h8-0-444" class="d">-        let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
</a><a href="#h8-0-445" id="h8-0-445" class="d">-        s.log.print(&amp;mut mint.new_goldenfile(&quot;log&quot;)?)?;
</a><a href="#h8-0-446" id="h8-0-446" class="d">-        Ok(())
</a><a href="#h8-0-447" id="h8-0-447" class="d">-    }
</a><a href="#h8-0-448" id="h8-0-448" class="d">-
</a><a href="#h8-0-449" id="h8-0-449" class="d">-    #[test]
</a><a href="#h8-0-450" id="h8-0-450" class="d">-    /// Tests that writing and then reading a file yields the same results.
</a><a href="#h8-0-451" id="h8-0-451" class="d">-    fn reopen() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-452" id="h8-0-452" class="d">-        // NB: Don&#39;t use setup(), because the tempdir will be removed when
</a><a href="#h8-0-453" id="h8-0-453" class="d">-        // the path falls out of scope.
</a><a href="#h8-0-454" id="h8-0-454" class="d">-        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h8-0-455" id="h8-0-455" class="d">-        let mut s = BitCask::new(path.clone())?;
</a><a href="#h8-0-456" id="h8-0-456" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h8-0-457" id="h8-0-457" class="d">-
</a><a href="#h8-0-458" id="h8-0-458" class="d">-        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h8-0-459" id="h8-0-459" class="d">-        drop(s);
</a><a href="#h8-0-460" id="h8-0-460" class="d">-        let mut s = BitCask::new(path)?;
</a><a href="#h8-0-461" id="h8-0-461" class="d">-        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h8-0-462" id="h8-0-462" class="d">-
</a><a href="#h8-0-463" id="h8-0-463" class="d">-        Ok(())
</a><a href="#h8-0-464" id="h8-0-464" class="d">-    }
</a><a href="#h8-0-465" id="h8-0-465" class="d">-
</a><a href="#h8-0-466" id="h8-0-466" class="d">-    #[test]
</a><a href="#h8-0-467" id="h8-0-467" class="d">-    /// Tests log compaction, by writing golden files of the before/after state,
</a><a href="#h8-0-468" id="h8-0-468" class="d">-    /// and checking that the database contains the same results, even after
</a><a href="#h8-0-469" id="h8-0-469" class="d">-    /// reopening the file.
</a><a href="#h8-0-470" id="h8-0-470" class="d">-    fn compact() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-471" id="h8-0-471" class="d">-        // NB: Don&#39;t use setup(), because the tempdir will be removed when
</a><a href="#h8-0-472" id="h8-0-472" class="d">-        // the path falls out of scope.
</a><a href="#h8-0-473" id="h8-0-473" class="d">-        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h8-0-474" id="h8-0-474" class="d">-        let mut s = BitCask::new(path.clone())?;
</a><a href="#h8-0-475" id="h8-0-475" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h8-0-476" id="h8-0-476" class="d">-
</a><a href="#h8-0-477" id="h8-0-477" class="d">-        // Dump the initial log file.
</a><a href="#h8-0-478" id="h8-0-478" class="d">-        let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
</a><a href="#h8-0-479" id="h8-0-479" class="d">-        s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-before&quot;)?)?;
</a><a href="#h8-0-480" id="h8-0-480" class="d">-        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h8-0-481" id="h8-0-481" class="d">-
</a><a href="#h8-0-482" id="h8-0-482" class="d">-        // Compact the log file and assert the new log file contents.
</a><a href="#h8-0-483" id="h8-0-483" class="d">-        s.compact()?;
</a><a href="#h8-0-484" id="h8-0-484" class="d">-        assert_eq!(path, s.log.path);
</a><a href="#h8-0-485" id="h8-0-485" class="d">-        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h8-0-486" id="h8-0-486" class="d">-        s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-after&quot;)?)?;
</a><a href="#h8-0-487" id="h8-0-487" class="d">-
</a><a href="#h8-0-488" id="h8-0-488" class="d">-        // Reopen the log file and assert that the contents are the same.
</a><a href="#h8-0-489" id="h8-0-489" class="d">-        drop(s);
</a><a href="#h8-0-490" id="h8-0-490" class="d">-        let mut s = BitCask::new(path)?;
</a><a href="#h8-0-491" id="h8-0-491" class="d">-        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h8-0-492" id="h8-0-492" class="d">-
</a><a href="#h8-0-493" id="h8-0-493" class="d">-        Ok(())
</a><a href="#h8-0-494" id="h8-0-494" class="d">-    }
</a><a href="#h8-0-495" id="h8-0-495" class="d">-
</a><a href="#h8-0-496" id="h8-0-496" class="d">-    #[test]
</a><a href="#h8-0-497" id="h8-0-497" class="d">-    /// Tests that new_compact() will automatically compact the file when appropriate.
</a><a href="#h8-0-498" id="h8-0-498" class="d">-    fn new_compact() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-499" id="h8-0-499" class="d">-        // Create an initial log file with a few entries.
</a><a href="#h8-0-500" id="h8-0-500" class="d">-        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h8-0-501" id="h8-0-501" class="d">-        let path = dir.path().join(&quot;orig&quot;);
</a><a href="#h8-0-502" id="h8-0-502" class="d">-        let compactpath = dir.path().join(&quot;compact&quot;);
</a><a href="#h8-0-503" id="h8-0-503" class="d">-
</a><a href="#h8-0-504" id="h8-0-504" class="d">-        let mut s = BitCask::new_compact(path.clone(), 0.2)?;
</a><a href="#h8-0-505" id="h8-0-505" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h8-0-506" id="h8-0-506" class="d">-        let (live_bytes, total_bytes) = s.compute_sizes()?;
</a><a href="#h8-0-507" id="h8-0-507" class="d">-        let garbage_ratio = (total_bytes - live_bytes) as f64 / total_bytes as f64;
</a><a href="#h8-0-508" id="h8-0-508" class="d">-        drop(s);
</a><a href="#h8-0-509" id="h8-0-509" class="d">-
</a><a href="#h8-0-510" id="h8-0-510" class="d">-        // Test a few threshold value and assert whether it should trigger compaction.
</a><a href="#h8-0-511" id="h8-0-511" class="d">-        let cases = vec![
</a><a href="#h8-0-512" id="h8-0-512" class="d">-            (-1.0, true),
</a><a href="#h8-0-513" id="h8-0-513" class="d">-            (0.0, true),
</a><a href="#h8-0-514" id="h8-0-514" class="d">-            (garbage_ratio - 0.001, true),
</a><a href="#h8-0-515" id="h8-0-515" class="d">-            (garbage_ratio, true),
</a><a href="#h8-0-516" id="h8-0-516" class="d">-            (garbage_ratio + 0.001, false),
</a><a href="#h8-0-517" id="h8-0-517" class="d">-            (1.0, false),
</a><a href="#h8-0-518" id="h8-0-518" class="d">-            (2.0, false),
</a><a href="#h8-0-519" id="h8-0-519" class="d">-        ];
</a><a href="#h8-0-520" id="h8-0-520" class="d">-        for (threshold, expect_compact) in cases.into_iter() {
</a><a href="#h8-0-521" id="h8-0-521" class="d">-            std::fs::copy(&amp;path, &amp;compactpath)?;
</a><a href="#h8-0-522" id="h8-0-522" class="d">-            let mut s = BitCask::new_compact(compactpath.clone(), threshold)?;
</a><a href="#h8-0-523" id="h8-0-523" class="d">-            let (new_live, new_total) = s.compute_sizes()?;
</a><a href="#h8-0-524" id="h8-0-524" class="d">-            assert_eq!(new_live, live_bytes);
</a><a href="#h8-0-525" id="h8-0-525" class="d">-            if expect_compact {
</a><a href="#h8-0-526" id="h8-0-526" class="d">-                assert_eq!(new_total, live_bytes);
</a><a href="#h8-0-527" id="h8-0-527" class="d">-            } else {
</a><a href="#h8-0-528" id="h8-0-528" class="d">-                assert_eq!(new_total, total_bytes);
</a><a href="#h8-0-529" id="h8-0-529" class="d">-            }
</a><a href="#h8-0-530" id="h8-0-530" class="d">-        }
</a><a href="#h8-0-531" id="h8-0-531" class="d">-
</a><a href="#h8-0-532" id="h8-0-532" class="d">-        Ok(())
</a><a href="#h8-0-533" id="h8-0-533" class="d">-    }
</a><a href="#h8-0-534" id="h8-0-534" class="d">-
</a><a href="#h8-0-535" id="h8-0-535" class="d">-    #[test]
</a><a href="#h8-0-536" id="h8-0-536" class="d">-    /// Tests that exclusive locks are taken out on log files, released when the
</a><a href="#h8-0-537" id="h8-0-537" class="d">-    /// database is closed, and that an error is returned if a lock is already
</a><a href="#h8-0-538" id="h8-0-538" class="d">-    /// held.
</a><a href="#h8-0-539" id="h8-0-539" class="d">-    fn log_lock() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-540" id="h8-0-540" class="d">-        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h8-0-541" id="h8-0-541" class="d">-        let s = BitCask::new(path.clone())?;
</a><a href="#h8-0-542" id="h8-0-542" class="d">-
</a><a href="#h8-0-543" id="h8-0-543" class="d">-        assert!(BitCask::new(path.clone()).is_err());
</a><a href="#h8-0-544" id="h8-0-544" class="d">-        drop(s);
</a><a href="#h8-0-545" id="h8-0-545" class="d">-        assert!(BitCask::new(path.clone()).is_ok());
</a><a href="#h8-0-546" id="h8-0-546" class="d">-
</a><a href="#h8-0-547" id="h8-0-547" class="d">-        Ok(())
</a><a href="#h8-0-548" id="h8-0-548" class="d">-    }
</a><a href="#h8-0-549" id="h8-0-549" class="d">-
</a><a href="#h8-0-550" id="h8-0-550" class="d">-    #[test]
</a><a href="#h8-0-551" id="h8-0-551" class="d">-    /// Tests that an incomplete write at the end of the log file can be
</a><a href="#h8-0-552" id="h8-0-552" class="d">-    /// recovered by discarding the last entry.
</a><a href="#h8-0-553" id="h8-0-553" class="d">-    fn recovery() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-554" id="h8-0-554" class="d">-        // Create an initial log file with a few entries.
</a><a href="#h8-0-555" id="h8-0-555" class="d">-        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h8-0-556" id="h8-0-556" class="d">-        let path = dir.path().join(&quot;complete&quot;);
</a><a href="#h8-0-557" id="h8-0-557" class="d">-        let truncpath = dir.path().join(&quot;truncated&quot;);
</a><a href="#h8-0-558" id="h8-0-558" class="d">-
</a><a href="#h8-0-559" id="h8-0-559" class="d">-        let mut log = Log::new(path.clone())?;
</a><a href="#h8-0-560" id="h8-0-560" class="d">-        let mut ends = vec![];
</a><a href="#h8-0-561" id="h8-0-561" class="d">-
</a><a href="#h8-0-562" id="h8-0-562" class="d">-        let (pos, len) = log.write_entry(&quot;deleted&quot;.as_bytes(), Some(&amp;[1, 2, 3]))?;
</a><a href="#h8-0-563" id="h8-0-563" class="d">-        ends.push(pos + len as u64);
</a><a href="#h8-0-564" id="h8-0-564" class="d">-
</a><a href="#h8-0-565" id="h8-0-565" class="d">-        let (pos, len) = log.write_entry(&quot;deleted&quot;.as_bytes(), None)?;
</a><a href="#h8-0-566" id="h8-0-566" class="d">-        ends.push(pos + len as u64);
</a><a href="#h8-0-567" id="h8-0-567" class="d">-
</a><a href="#h8-0-568" id="h8-0-568" class="d">-        let (pos, len) = log.write_entry(&amp;[], Some(&amp;[]))?;
</a><a href="#h8-0-569" id="h8-0-569" class="d">-        ends.push(pos + len as u64);
</a><a href="#h8-0-570" id="h8-0-570" class="d">-
</a><a href="#h8-0-571" id="h8-0-571" class="d">-        let (pos, len) = log.write_entry(&quot;key&quot;.as_bytes(), Some(&amp;[1, 2, 3, 4, 5]))?;
</a><a href="#h8-0-572" id="h8-0-572" class="d">-        ends.push(pos + len as u64);
</a><a href="#h8-0-573" id="h8-0-573" class="d">-
</a><a href="#h8-0-574" id="h8-0-574" class="d">-        drop(log);
</a><a href="#h8-0-575" id="h8-0-575" class="d">-
</a><a href="#h8-0-576" id="h8-0-576" class="d">-        // Copy the file, and truncate it at each byte, then try to open it
</a><a href="#h8-0-577" id="h8-0-577" class="d">-        // and assert that we always retain a prefix of entries.
</a><a href="#h8-0-578" id="h8-0-578" class="d">-        let size = std::fs::metadata(&amp;path)?.len();
</a><a href="#h8-0-579" id="h8-0-579" class="d">-        for pos in 0..=size {
</a><a href="#h8-0-580" id="h8-0-580" class="d">-            std::fs::copy(&amp;path, &amp;truncpath)?;
</a><a href="#h8-0-581" id="h8-0-581" class="d">-            let f = std::fs::OpenOptions::new().write(true).open(&amp;truncpath)?;
</a><a href="#h8-0-582" id="h8-0-582" class="d">-            f.set_len(pos)?;
</a><a href="#h8-0-583" id="h8-0-583" class="d">-            drop(f);
</a><a href="#h8-0-584" id="h8-0-584" class="d">-
</a><a href="#h8-0-585" id="h8-0-585" class="d">-            let mut expect = vec![];
</a><a href="#h8-0-586" id="h8-0-586" class="d">-            if pos &gt;= ends[0] {
</a><a href="#h8-0-587" id="h8-0-587" class="d">-                expect.push((b&quot;deleted&quot;.to_vec(), vec![1, 2, 3]))
</a><a href="#h8-0-588" id="h8-0-588" class="d">-            }
</a><a href="#h8-0-589" id="h8-0-589" class="d">-            if pos &gt;= ends[1] {
</a><a href="#h8-0-590" id="h8-0-590" class="d">-                expect.pop(); // &quot;deleted&quot; key removed
</a><a href="#h8-0-591" id="h8-0-591" class="d">-            }
</a><a href="#h8-0-592" id="h8-0-592" class="d">-            if pos &gt;= ends[2] {
</a><a href="#h8-0-593" id="h8-0-593" class="d">-                expect.push((b&quot;&quot;.to_vec(), vec![]))
</a><a href="#h8-0-594" id="h8-0-594" class="d">-            }
</a><a href="#h8-0-595" id="h8-0-595" class="d">-            if pos &gt;= ends[3] {
</a><a href="#h8-0-596" id="h8-0-596" class="d">-                expect.push((b&quot;key&quot;.to_vec(), vec![1, 2, 3, 4, 5]))
</a><a href="#h8-0-597" id="h8-0-597" class="d">-            }
</a><a href="#h8-0-598" id="h8-0-598" class="d">-
</a><a href="#h8-0-599" id="h8-0-599" class="d">-            let mut s = BitCask::new(truncpath.clone())?;
</a><a href="#h8-0-600" id="h8-0-600" class="d">-            assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h8-0-601" id="h8-0-601" class="d">-        }
</a><a href="#h8-0-602" id="h8-0-602" class="d">-
</a><a href="#h8-0-603" id="h8-0-603" class="d">-        Ok(())
</a><a href="#h8-0-604" id="h8-0-604" class="d">-    }
</a><a href="#h8-0-605" id="h8-0-605" class="d">-
</a><a href="#h8-0-606" id="h8-0-606" class="d">-    #[test]
</a><a href="#h8-0-607" id="h8-0-607" class="d">-    /// Tests compute_sizes(), both for a log file with known garbage, and
</a><a href="#h8-0-608" id="h8-0-608" class="d">-    /// after compacting it when the live size must equal the file size.
</a><a href="#h8-0-609" id="h8-0-609" class="d">-    fn compute_sizes() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-610" id="h8-0-610" class="d">-        let mut s = setup()?;
</a><a href="#h8-0-611" id="h8-0-611" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h8-0-612" id="h8-0-612" class="d">-
</a><a href="#h8-0-613" id="h8-0-613" class="d">-        // Before compaction, the log contains garbage, so the live size must be
</a><a href="#h8-0-614" id="h8-0-614" class="d">-        // less than the log size.
</a><a href="#h8-0-615" id="h8-0-615" class="d">-        let (live_size, total_size) = s.compute_sizes()?;
</a><a href="#h8-0-616" id="h8-0-616" class="d">-        assert_eq!(total_size, s.log.file.metadata()?.len());
</a><a href="#h8-0-617" id="h8-0-617" class="d">-        assert!(live_size &lt; total_size);
</a><a href="#h8-0-618" id="h8-0-618" class="d">-
</a><a href="#h8-0-619" id="h8-0-619" class="d">-        // After compaction, the live size should not have changed. Furthermore,
</a><a href="#h8-0-620" id="h8-0-620" class="d">-        // the log now only contains live data, so the live size must equal the
</a><a href="#h8-0-621" id="h8-0-621" class="d">-        // log file size.
</a><a href="#h8-0-622" id="h8-0-622" class="d">-        s.compact()?;
</a><a href="#h8-0-623" id="h8-0-623" class="d">-        assert_eq!((live_size, live_size), s.compute_sizes()?);
</a><a href="#h8-0-624" id="h8-0-624" class="d">-        Ok(())
</a><a href="#h8-0-625" id="h8-0-625" class="d">-    }
</a><a href="#h8-0-626" id="h8-0-626" class="d">-}
</a><b>diff --git a/<a id="h9" href="../file/src/storage/kv/memory.rs.html">src/storage/kv/memory.rs</a> b/<a href="../file/src/storage/kv/memory.rs.html">src/storage/kv/memory.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,79 +0,0 @@
</a><a href="#h9-0-0" id="h9-0-0" class="d">-use super::Store;
</a><a href="#h9-0-1" id="h9-0-1" class="d">-use crate::error::Result;
</a><a href="#h9-0-2" id="h9-0-2" class="d">-
</a><a href="#h9-0-3" id="h9-0-3" class="d">-/// An in-memory key/value store using the Rust standard library B-tree
</a><a href="#h9-0-4" id="h9-0-4" class="d">-/// implementation. Data is not persisted.
</a><a href="#h9-0-5" id="h9-0-5" class="d">-pub struct Memory {
</a><a href="#h9-0-6" id="h9-0-6" class="d">-    data: std::collections::BTreeMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h9-0-7" id="h9-0-7" class="d">-}
</a><a href="#h9-0-8" id="h9-0-8" class="d">-
</a><a href="#h9-0-9" id="h9-0-9" class="d">-impl Memory {
</a><a href="#h9-0-10" id="h9-0-10" class="d">-    /// Creates a new Memory key-value storage engine.
</a><a href="#h9-0-11" id="h9-0-11" class="d">-    pub fn new() -&gt; Self {
</a><a href="#h9-0-12" id="h9-0-12" class="d">-        Self { data: std::collections::BTreeMap::new() }
</a><a href="#h9-0-13" id="h9-0-13" class="d">-    }
</a><a href="#h9-0-14" id="h9-0-14" class="d">-}
</a><a href="#h9-0-15" id="h9-0-15" class="d">-
</a><a href="#h9-0-16" id="h9-0-16" class="d">-impl std::fmt::Display for Memory {
</a><a href="#h9-0-17" id="h9-0-17" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h9-0-18" id="h9-0-18" class="d">-        write!(f, &quot;memory&quot;)
</a><a href="#h9-0-19" id="h9-0-19" class="d">-    }
</a><a href="#h9-0-20" id="h9-0-20" class="d">-}
</a><a href="#h9-0-21" id="h9-0-21" class="d">-
</a><a href="#h9-0-22" id="h9-0-22" class="d">-impl Store for Memory {
</a><a href="#h9-0-23" id="h9-0-23" class="d">-    type ScanIterator&lt;&#39;a&gt; = ScanIterator&lt;&#39;a&gt;;
</a><a href="#h9-0-24" id="h9-0-24" class="d">-
</a><a href="#h9-0-25" id="h9-0-25" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-26" id="h9-0-26" class="d">-        Ok(())
</a><a href="#h9-0-27" id="h9-0-27" class="d">-    }
</a><a href="#h9-0-28" id="h9-0-28" class="d">-
</a><a href="#h9-0-29" id="h9-0-29" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-30" id="h9-0-30" class="d">-        self.data.remove(key);
</a><a href="#h9-0-31" id="h9-0-31" class="d">-        Ok(())
</a><a href="#h9-0-32" id="h9-0-32" class="d">-    }
</a><a href="#h9-0-33" id="h9-0-33" class="d">-
</a><a href="#h9-0-34" id="h9-0-34" class="d">-    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h9-0-35" id="h9-0-35" class="d">-        Ok(self.data.get(key).cloned())
</a><a href="#h9-0-36" id="h9-0-36" class="d">-    }
</a><a href="#h9-0-37" id="h9-0-37" class="d">-
</a><a href="#h9-0-38" id="h9-0-38" class="d">-    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h9-0-39" id="h9-0-39" class="d">-        ScanIterator { inner: self.data.range(range) }
</a><a href="#h9-0-40" id="h9-0-40" class="d">-    }
</a><a href="#h9-0-41" id="h9-0-41" class="d">-
</a><a href="#h9-0-42" id="h9-0-42" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-43" id="h9-0-43" class="d">-        self.data.insert(key.to_vec(), value);
</a><a href="#h9-0-44" id="h9-0-44" class="d">-        Ok(())
</a><a href="#h9-0-45" id="h9-0-45" class="d">-    }
</a><a href="#h9-0-46" id="h9-0-46" class="d">-}
</a><a href="#h9-0-47" id="h9-0-47" class="d">-
</a><a href="#h9-0-48" id="h9-0-48" class="d">-pub struct ScanIterator&lt;&#39;a&gt; {
</a><a href="#h9-0-49" id="h9-0-49" class="d">-    inner: std::collections::btree_map::Range&lt;&#39;a, Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h9-0-50" id="h9-0-50" class="d">-}
</a><a href="#h9-0-51" id="h9-0-51" class="d">-
</a><a href="#h9-0-52" id="h9-0-52" class="d">-impl&lt;&#39;a&gt; ScanIterator&lt;&#39;a&gt; {
</a><a href="#h9-0-53" id="h9-0-53" class="d">-    fn map(item: (&amp;Vec&lt;u8&gt;, &amp;Vec&lt;u8&gt;)) -&gt; &lt;Self as Iterator&gt;::Item {
</a><a href="#h9-0-54" id="h9-0-54" class="d">-        let (key, value) = item;
</a><a href="#h9-0-55" id="h9-0-55" class="d">-        Ok((key.clone(), value.clone()))
</a><a href="#h9-0-56" id="h9-0-56" class="d">-    }
</a><a href="#h9-0-57" id="h9-0-57" class="d">-}
</a><a href="#h9-0-58" id="h9-0-58" class="d">-
</a><a href="#h9-0-59" id="h9-0-59" class="d">-impl&lt;&#39;a&gt; Iterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h9-0-60" id="h9-0-60" class="d">-    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a><a href="#h9-0-61" id="h9-0-61" class="d">-
</a><a href="#h9-0-62" id="h9-0-62" class="d">-    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h9-0-63" id="h9-0-63" class="d">-        self.inner.next().map(Self::map)
</a><a href="#h9-0-64" id="h9-0-64" class="d">-    }
</a><a href="#h9-0-65" id="h9-0-65" class="d">-}
</a><a href="#h9-0-66" id="h9-0-66" class="d">-
</a><a href="#h9-0-67" id="h9-0-67" class="d">-impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h9-0-68" id="h9-0-68" class="d">-    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h9-0-69" id="h9-0-69" class="d">-        self.inner.next_back().map(Self::map)
</a><a href="#h9-0-70" id="h9-0-70" class="d">-    }
</a><a href="#h9-0-71" id="h9-0-71" class="d">-}
</a><a href="#h9-0-72" id="h9-0-72" class="d">-
</a><a href="#h9-0-73" id="h9-0-73" class="d">-#[cfg(test)]
</a><a href="#h9-0-74" id="h9-0-74" class="d">-mod tests {
</a><a href="#h9-0-75" id="h9-0-75" class="d">-    use super::*;
</a><a href="#h9-0-76" id="h9-0-76" class="d">-
</a><a href="#h9-0-77" id="h9-0-77" class="d">-    super::super::tests::test_store!(Memory::new());
</a><a href="#h9-0-78" id="h9-0-78" class="d">-}
</a><b>diff --git a/<a id="h10" href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a> b/<a href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -1,297 +1,7 @@
</a><a href="#h10-0-0" id="h10-0-0" class="d">-mod bitcask;
</a> pub mod encoding;
<a href="#h10-0-2" id="h10-0-2" class="d">-mod memory;
</a> pub mod mvcc;
 
<a href="#h10-0-5" id="h10-0-5" class="d">-pub use bitcask::BitCask;
</a><a href="#h10-0-6" id="h10-0-6" class="d">-pub use memory::Memory;
</a><a href="#h10-0-7" id="h10-0-7" class="i">+pub use super::engine::BitCask;
</a><a href="#h10-0-8" id="h10-0-8" class="i">+pub use super::engine::Engine;
</a><a href="#h10-0-9" id="h10-0-9" class="i">+pub use super::engine::Memory;
</a> pub use mvcc::MVCC;
<a href="#h10-0-11" id="h10-0-11" class="d">-
</a><a href="#h10-0-12" id="h10-0-12" class="d">-use crate::error::Result;
</a><a href="#h10-0-13" id="h10-0-13" class="d">-
</a><a href="#h10-0-14" id="h10-0-14" class="d">-/// A key/value storage engine, where both keys and values are arbitrary byte
</a><a href="#h10-0-15" id="h10-0-15" class="d">-/// strings between 0 B and 2 GB, stored in lexicographical key order. Writes
</a><a href="#h10-0-16" id="h10-0-16" class="d">-/// are only guaranteed durable after calling flush().
</a><a href="#h10-0-17" id="h10-0-17" class="d">-///
</a><a href="#h10-0-18" id="h10-0-18" class="d">-/// Only supports single-threaded use since all methods (including reads) take a
</a><a href="#h10-0-19" id="h10-0-19" class="d">-/// mutable reference -- serialized access can&#39;t be avoided anyway, since both
</a><a href="#h10-0-20" id="h10-0-20" class="d">-/// Raft execution and file access is serial.
</a><a href="#h10-0-21" id="h10-0-21" class="d">-pub trait Store: std::fmt::Display + Send + Sync {
</a><a href="#h10-0-22" id="h10-0-22" class="d">-    /// The iterator returned by scan(). Traits can&#39;t return &quot;impl Trait&quot;, and
</a><a href="#h10-0-23" id="h10-0-23" class="d">-    /// we don&#39;t want to use trait objects, so the type must be specified.
</a><a href="#h10-0-24" id="h10-0-24" class="d">-    type ScanIterator&lt;&#39;a&gt;: DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; + &#39;a
</a><a href="#h10-0-25" id="h10-0-25" class="d">-    where
</a><a href="#h10-0-26" id="h10-0-26" class="d">-        Self: &#39;a;
</a><a href="#h10-0-27" id="h10-0-27" class="d">-
</a><a href="#h10-0-28" id="h10-0-28" class="d">-    /// Deletes a key, or does nothing if it does not exist.
</a><a href="#h10-0-29" id="h10-0-29" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt;;
</a><a href="#h10-0-30" id="h10-0-30" class="d">-
</a><a href="#h10-0-31" id="h10-0-31" class="d">-    /// Flushes any buffered data to the underlying storage medium.
</a><a href="#h10-0-32" id="h10-0-32" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</a><a href="#h10-0-33" id="h10-0-33" class="d">-
</a><a href="#h10-0-34" id="h10-0-34" class="d">-    /// Gets a value for a key, if it exists.
</a><a href="#h10-0-35" id="h10-0-35" class="d">-    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
</a><a href="#h10-0-36" id="h10-0-36" class="d">-
</a><a href="#h10-0-37" id="h10-0-37" class="d">-    /// Iterates over an ordered range of key/value pairs.
</a><a href="#h10-0-38" id="h10-0-38" class="d">-    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Self::ScanIterator&lt;&#39;_&gt;;
</a><a href="#h10-0-39" id="h10-0-39" class="d">-
</a><a href="#h10-0-40" id="h10-0-40" class="d">-    /// Sets a value for a key, replacing the existing value if any.
</a><a href="#h10-0-41" id="h10-0-41" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;
</a><a href="#h10-0-42" id="h10-0-42" class="d">-}
</a><a href="#h10-0-43" id="h10-0-43" class="d">-
</a><a href="#h10-0-44" id="h10-0-44" class="d">-#[cfg(test)]
</a><a href="#h10-0-45" id="h10-0-45" class="d">-mod tests {
</a><a href="#h10-0-46" id="h10-0-46" class="d">-    /// Generates common tests for any Store implementation.
</a><a href="#h10-0-47" id="h10-0-47" class="d">-    macro_rules! test_store {
</a><a href="#h10-0-48" id="h10-0-48" class="d">-        ($setup:expr) =&gt; {
</a><a href="#h10-0-49" id="h10-0-49" class="d">-            /// Tests Store point operations, i.e. set, get, and delete.
</a><a href="#h10-0-50" id="h10-0-50" class="d">-            #[test]
</a><a href="#h10-0-51" id="h10-0-51" class="d">-            fn point_ops() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-52" id="h10-0-52" class="d">-                let mut s = $setup;
</a><a href="#h10-0-53" id="h10-0-53" class="d">-
</a><a href="#h10-0-54" id="h10-0-54" class="d">-                // Getting a missing key should return None.
</a><a href="#h10-0-55" id="h10-0-55" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h10-0-56" id="h10-0-56" class="d">-
</a><a href="#h10-0-57" id="h10-0-57" class="d">-                // Setting and getting a key should return its value.
</a><a href="#h10-0-58" id="h10-0-58" class="d">-                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h10-0-59" id="h10-0-59" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![1]));
</a><a href="#h10-0-60" id="h10-0-60" class="d">-
</a><a href="#h10-0-61" id="h10-0-61" class="d">-                // Setting a different key should not affect the first.
</a><a href="#h10-0-62" id="h10-0-62" class="d">-                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h10-0-63" id="h10-0-63" class="d">-                assert_eq!(s.get(b&quot;b&quot;)?, Some(vec![2]));
</a><a href="#h10-0-64" id="h10-0-64" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![1]));
</a><a href="#h10-0-65" id="h10-0-65" class="d">-
</a><a href="#h10-0-66" id="h10-0-66" class="d">-                // Getting a different missing key should return None. The
</a><a href="#h10-0-67" id="h10-0-67" class="d">-                // comparison is case-insensitive for strings.
</a><a href="#h10-0-68" id="h10-0-68" class="d">-                assert_eq!(s.get(b&quot;c&quot;)?, None);
</a><a href="#h10-0-69" id="h10-0-69" class="d">-                assert_eq!(s.get(b&quot;A&quot;)?, None);
</a><a href="#h10-0-70" id="h10-0-70" class="d">-
</a><a href="#h10-0-71" id="h10-0-71" class="d">-                // Setting an existing key should replace its value.
</a><a href="#h10-0-72" id="h10-0-72" class="d">-                s.set(b&quot;a&quot;, vec![0])?;
</a><a href="#h10-0-73" id="h10-0-73" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![0]));
</a><a href="#h10-0-74" id="h10-0-74" class="d">-
</a><a href="#h10-0-75" id="h10-0-75" class="d">-                // Deleting a key should remove it, but not affect others.
</a><a href="#h10-0-76" id="h10-0-76" class="d">-                s.delete(b&quot;a&quot;)?;
</a><a href="#h10-0-77" id="h10-0-77" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h10-0-78" id="h10-0-78" class="d">-                assert_eq!(s.get(b&quot;b&quot;)?, Some(vec![2]));
</a><a href="#h10-0-79" id="h10-0-79" class="d">-
</a><a href="#h10-0-80" id="h10-0-80" class="d">-                // Deletes are idempotent.
</a><a href="#h10-0-81" id="h10-0-81" class="d">-                s.delete(b&quot;a&quot;)?;
</a><a href="#h10-0-82" id="h10-0-82" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h10-0-83" id="h10-0-83" class="d">-
</a><a href="#h10-0-84" id="h10-0-84" class="d">-                Ok(())
</a><a href="#h10-0-85" id="h10-0-85" class="d">-            }
</a><a href="#h10-0-86" id="h10-0-86" class="d">-
</a><a href="#h10-0-87" id="h10-0-87" class="d">-            #[test]
</a><a href="#h10-0-88" id="h10-0-88" class="d">-            /// Tests Store point operations on empty keys and values. These
</a><a href="#h10-0-89" id="h10-0-89" class="d">-            /// are as valid as any other key/value.
</a><a href="#h10-0-90" id="h10-0-90" class="d">-            fn point_ops_empty() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-91" id="h10-0-91" class="d">-                let mut s = $setup;
</a><a href="#h10-0-92" id="h10-0-92" class="d">-                assert_eq!(s.get(b&quot;&quot;)?, None);
</a><a href="#h10-0-93" id="h10-0-93" class="d">-                s.set(b&quot;&quot;, vec![])?;
</a><a href="#h10-0-94" id="h10-0-94" class="d">-                assert_eq!(s.get(b&quot;&quot;)?, Some(vec![]));
</a><a href="#h10-0-95" id="h10-0-95" class="d">-                s.delete(b&quot;&quot;)?;
</a><a href="#h10-0-96" id="h10-0-96" class="d">-                assert_eq!(s.get(b&quot;&quot;)?, None);
</a><a href="#h10-0-97" id="h10-0-97" class="d">-                Ok(())
</a><a href="#h10-0-98" id="h10-0-98" class="d">-            }
</a><a href="#h10-0-99" id="h10-0-99" class="d">-
</a><a href="#h10-0-100" id="h10-0-100" class="d">-            #[test]
</a><a href="#h10-0-101" id="h10-0-101" class="d">-            /// Tests Store point operations on keys and values of increasing
</a><a href="#h10-0-102" id="h10-0-102" class="d">-            /// sizes, up to 16 MB.
</a><a href="#h10-0-103" id="h10-0-103" class="d">-            fn point_ops_sizes() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-104" id="h10-0-104" class="d">-                let mut s = $setup;
</a><a href="#h10-0-105" id="h10-0-105" class="d">-
</a><a href="#h10-0-106" id="h10-0-106" class="d">-                // Generate keys/values for increasing powers of two.
</a><a href="#h10-0-107" id="h10-0-107" class="d">-                for size in (1..=24).map(|i| 1 &lt;&lt; i) {
</a><a href="#h10-0-108" id="h10-0-108" class="d">-                    let bytes = &quot;x&quot;.repeat(size);
</a><a href="#h10-0-109" id="h10-0-109" class="d">-                    let key = bytes.as_bytes();
</a><a href="#h10-0-110" id="h10-0-110" class="d">-                    let value = bytes.clone().into_bytes();
</a><a href="#h10-0-111" id="h10-0-111" class="d">-
</a><a href="#h10-0-112" id="h10-0-112" class="d">-                    assert_eq!(s.get(key)?, None);
</a><a href="#h10-0-113" id="h10-0-113" class="d">-                    s.set(key, value.clone())?;
</a><a href="#h10-0-114" id="h10-0-114" class="d">-                    assert_eq!(s.get(key)?, Some(value));
</a><a href="#h10-0-115" id="h10-0-115" class="d">-                    s.delete(key)?;
</a><a href="#h10-0-116" id="h10-0-116" class="d">-                    assert_eq!(s.get(key)?, None);
</a><a href="#h10-0-117" id="h10-0-117" class="d">-                }
</a><a href="#h10-0-118" id="h10-0-118" class="d">-
</a><a href="#h10-0-119" id="h10-0-119" class="d">-                Ok(())
</a><a href="#h10-0-120" id="h10-0-120" class="d">-            }
</a><a href="#h10-0-121" id="h10-0-121" class="d">-
</a><a href="#h10-0-122" id="h10-0-122" class="d">-            #[test]
</a><a href="#h10-0-123" id="h10-0-123" class="d">-            /// Tests various Store scans.
</a><a href="#h10-0-124" id="h10-0-124" class="d">-            fn scan() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-125" id="h10-0-125" class="d">-                let mut s = $setup;
</a><a href="#h10-0-126" id="h10-0-126" class="d">-                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h10-0-127" id="h10-0-127" class="d">-                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h10-0-128" id="h10-0-128" class="d">-                s.set(b&quot;ba&quot;, vec![2, 1])?;
</a><a href="#h10-0-129" id="h10-0-129" class="d">-                s.set(b&quot;bb&quot;, vec![2, 2])?;
</a><a href="#h10-0-130" id="h10-0-130" class="d">-                s.set(b&quot;c&quot;, vec![3])?;
</a><a href="#h10-0-131" id="h10-0-131" class="d">-                s.set(b&quot;C&quot;, vec![3])?;
</a><a href="#h10-0-132" id="h10-0-132" class="d">-
</a><a href="#h10-0-133" id="h10-0-133" class="d">-                #[track_caller]
</a><a href="#h10-0-134" id="h10-0-134" class="d">-                fn assert_scan&lt;I&gt;(iter: I, expect: Vec&lt;(&amp;[u8], Vec&lt;u8&gt;)&gt;) -&gt; Result&lt;()&gt;
</a><a href="#h10-0-135" id="h10-0-135" class="d">-                where
</a><a href="#h10-0-136" id="h10-0-136" class="d">-                    I: Iterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt;,
</a><a href="#h10-0-137" id="h10-0-137" class="d">-                {
</a><a href="#h10-0-138" id="h10-0-138" class="d">-                    assert_eq!(
</a><a href="#h10-0-139" id="h10-0-139" class="d">-                        iter.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h10-0-140" id="h10-0-140" class="d">-                        expect.into_iter().map(|(k, v)| (k.to_vec(), v)).collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h10-0-141" id="h10-0-141" class="d">-                    );
</a><a href="#h10-0-142" id="h10-0-142" class="d">-                    Ok(())
</a><a href="#h10-0-143" id="h10-0-143" class="d">-                }
</a><a href="#h10-0-144" id="h10-0-144" class="d">-
</a><a href="#h10-0-145" id="h10-0-145" class="d">-                // Forward/reverse scans.
</a><a href="#h10-0-146" id="h10-0-146" class="d">-                assert_scan(
</a><a href="#h10-0-147" id="h10-0-147" class="d">-                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()),
</a><a href="#h10-0-148" id="h10-0-148" class="d">-                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;bb&quot;, vec![2, 2])],
</a><a href="#h10-0-149" id="h10-0-149" class="d">-                )?;
</a><a href="#h10-0-150" id="h10-0-150" class="d">-                assert_scan(
</a><a href="#h10-0-151" id="h10-0-151" class="d">-                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).rev(),
</a><a href="#h10-0-152" id="h10-0-152" class="d">-                    vec![(b&quot;bb&quot;, vec![2, 2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;b&quot;, vec![2])],
</a><a href="#h10-0-153" id="h10-0-153" class="d">-                )?;
</a><a href="#h10-0-154" id="h10-0-154" class="d">-
</a><a href="#h10-0-155" id="h10-0-155" class="d">-                // Inclusive/exclusive ranges.
</a><a href="#h10-0-156" id="h10-0-156" class="d">-                assert_scan(
</a><a href="#h10-0-157" id="h10-0-157" class="d">-                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()),
</a><a href="#h10-0-158" id="h10-0-158" class="d">-                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1])],
</a><a href="#h10-0-159" id="h10-0-159" class="d">-                )?;
</a><a href="#h10-0-160" id="h10-0-160" class="d">-                assert_scan(
</a><a href="#h10-0-161" id="h10-0-161" class="d">-                    s.scan(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()),
</a><a href="#h10-0-162" id="h10-0-162" class="d">-                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;bb&quot;, vec![2, 2])],
</a><a href="#h10-0-163" id="h10-0-163" class="d">-                )?;
</a><a href="#h10-0-164" id="h10-0-164" class="d">-
</a><a href="#h10-0-165" id="h10-0-165" class="d">-                // Open ranges.
</a><a href="#h10-0-166" id="h10-0-166" class="d">-                assert_scan(s.scan(b&quot;bb&quot;.to_vec()..), vec![(b&quot;bb&quot;, vec![2, 2]), (b&quot;c&quot;, vec![3])])?;
</a><a href="#h10-0-167" id="h10-0-167" class="d">-                assert_scan(
</a><a href="#h10-0-168" id="h10-0-168" class="d">-                    s.scan(..=b&quot;b&quot;.to_vec()),
</a><a href="#h10-0-169" id="h10-0-169" class="d">-                    vec![(b&quot;C&quot;, vec![3]), (b&quot;a&quot;, vec![1]), (b&quot;b&quot;, vec![2])],
</a><a href="#h10-0-170" id="h10-0-170" class="d">-                )?;
</a><a href="#h10-0-171" id="h10-0-171" class="d">-
</a><a href="#h10-0-172" id="h10-0-172" class="d">-                // Full range.
</a><a href="#h10-0-173" id="h10-0-173" class="d">-                assert_scan(
</a><a href="#h10-0-174" id="h10-0-174" class="d">-                    s.scan(..),
</a><a href="#h10-0-175" id="h10-0-175" class="d">-                    vec![
</a><a href="#h10-0-176" id="h10-0-176" class="d">-                        (b&quot;C&quot;, vec![3]),
</a><a href="#h10-0-177" id="h10-0-177" class="d">-                        (b&quot;a&quot;, vec![1]),
</a><a href="#h10-0-178" id="h10-0-178" class="d">-                        (b&quot;b&quot;, vec![2]),
</a><a href="#h10-0-179" id="h10-0-179" class="d">-                        (b&quot;ba&quot;, vec![2, 1]),
</a><a href="#h10-0-180" id="h10-0-180" class="d">-                        (b&quot;bb&quot;, vec![2, 2]),
</a><a href="#h10-0-181" id="h10-0-181" class="d">-                        (b&quot;c&quot;, vec![3]),
</a><a href="#h10-0-182" id="h10-0-182" class="d">-                    ],
</a><a href="#h10-0-183" id="h10-0-183" class="d">-                )?;
</a><a href="#h10-0-184" id="h10-0-184" class="d">-                Ok(())
</a><a href="#h10-0-185" id="h10-0-185" class="d">-            }
</a><a href="#h10-0-186" id="h10-0-186" class="d">-
</a><a href="#h10-0-187" id="h10-0-187" class="d">-            #[test]
</a><a href="#h10-0-188" id="h10-0-188" class="d">-            /// Runs random operations both on a Store and a known-good
</a><a href="#h10-0-189" id="h10-0-189" class="d">-            /// BTreeMap, comparing the results of each operation as well as the
</a><a href="#h10-0-190" id="h10-0-190" class="d">-            /// final state.
</a><a href="#h10-0-191" id="h10-0-191" class="d">-            fn random_ops() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-192" id="h10-0-192" class="d">-                const NUM_OPS: u64 = 1000;
</a><a href="#h10-0-193" id="h10-0-193" class="d">-
</a><a href="#h10-0-194" id="h10-0-194" class="d">-                use rand::{seq::SliceRandom, Rng, RngCore};
</a><a href="#h10-0-195" id="h10-0-195" class="d">-                let seed: u64 = rand::thread_rng().gen();
</a><a href="#h10-0-196" id="h10-0-196" class="d">-                let mut rng: rand::rngs::StdRng = rand::SeedableRng::seed_from_u64(seed);
</a><a href="#h10-0-197" id="h10-0-197" class="d">-                println!(&quot;seed = {}&quot;, seed);
</a><a href="#h10-0-198" id="h10-0-198" class="d">-
</a><a href="#h10-0-199" id="h10-0-199" class="d">-                #[derive(Debug)]
</a><a href="#h10-0-200" id="h10-0-200" class="d">-                enum Op {
</a><a href="#h10-0-201" id="h10-0-201" class="d">-                    Set,
</a><a href="#h10-0-202" id="h10-0-202" class="d">-                    Delete,
</a><a href="#h10-0-203" id="h10-0-203" class="d">-                    Get,
</a><a href="#h10-0-204" id="h10-0-204" class="d">-                    Scan,
</a><a href="#h10-0-205" id="h10-0-205" class="d">-                }
</a><a href="#h10-0-206" id="h10-0-206" class="d">-
</a><a href="#h10-0-207" id="h10-0-207" class="d">-                impl rand::distributions::Distribution&lt;Op&gt; for rand::distributions::Standard {
</a><a href="#h10-0-208" id="h10-0-208" class="d">-                    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; Op {
</a><a href="#h10-0-209" id="h10-0-209" class="d">-                        match rng.gen_range(0..=3) {
</a><a href="#h10-0-210" id="h10-0-210" class="d">-                            0 =&gt; Op::Set,
</a><a href="#h10-0-211" id="h10-0-211" class="d">-                            1 =&gt; Op::Delete,
</a><a href="#h10-0-212" id="h10-0-212" class="d">-                            2 =&gt; Op::Get,
</a><a href="#h10-0-213" id="h10-0-213" class="d">-                            3 =&gt; Op::Scan,
</a><a href="#h10-0-214" id="h10-0-214" class="d">-                            _ =&gt; panic!(&quot;unexpected value&quot;),
</a><a href="#h10-0-215" id="h10-0-215" class="d">-                        }
</a><a href="#h10-0-216" id="h10-0-216" class="d">-                    }
</a><a href="#h10-0-217" id="h10-0-217" class="d">-                }
</a><a href="#h10-0-218" id="h10-0-218" class="d">-
</a><a href="#h10-0-219" id="h10-0-219" class="d">-                let mut s = $setup;
</a><a href="#h10-0-220" id="h10-0-220" class="d">-                let mut keys: Vec&lt;Vec&lt;u8&gt;&gt; = Vec::new();
</a><a href="#h10-0-221" id="h10-0-221" class="d">-                let mut m = std::collections::BTreeMap::new();
</a><a href="#h10-0-222" id="h10-0-222" class="d">-
</a><a href="#h10-0-223" id="h10-0-223" class="d">-                // Pick an already-used key with 80% probability, or generate a
</a><a href="#h10-0-224" id="h10-0-224" class="d">-                // new key.
</a><a href="#h10-0-225" id="h10-0-225" class="d">-                let mut random_key = |mut rng: &amp;mut rand::rngs::StdRng| -&gt; Vec&lt;u8&gt; {
</a><a href="#h10-0-226" id="h10-0-226" class="d">-                    if rng.gen::&lt;f64&gt;() &lt; 0.8 &amp;&amp; !keys.is_empty() {
</a><a href="#h10-0-227" id="h10-0-227" class="d">-                        keys.choose(&amp;mut rng).unwrap().clone()
</a><a href="#h10-0-228" id="h10-0-228" class="d">-                    } else {
</a><a href="#h10-0-229" id="h10-0-229" class="d">-                        let mut key = vec![0; rng.gen_range(0..=16)];
</a><a href="#h10-0-230" id="h10-0-230" class="d">-                        rng.fill_bytes(&amp;mut key);
</a><a href="#h10-0-231" id="h10-0-231" class="d">-                        keys.push(key.clone());
</a><a href="#h10-0-232" id="h10-0-232" class="d">-                        key
</a><a href="#h10-0-233" id="h10-0-233" class="d">-                    }
</a><a href="#h10-0-234" id="h10-0-234" class="d">-                };
</a><a href="#h10-0-235" id="h10-0-235" class="d">-
</a><a href="#h10-0-236" id="h10-0-236" class="d">-                let random_value = |rng: &amp;mut rand::rngs::StdRng| -&gt; Vec&lt;u8&gt; {
</a><a href="#h10-0-237" id="h10-0-237" class="d">-                    let mut value = vec![0; rng.gen_range(0..=16)];
</a><a href="#h10-0-238" id="h10-0-238" class="d">-                    rng.fill_bytes(&amp;mut value);
</a><a href="#h10-0-239" id="h10-0-239" class="d">-                    value
</a><a href="#h10-0-240" id="h10-0-240" class="d">-                };
</a><a href="#h10-0-241" id="h10-0-241" class="d">-
</a><a href="#h10-0-242" id="h10-0-242" class="d">-                // Run random operations.
</a><a href="#h10-0-243" id="h10-0-243" class="d">-                for _ in 0..NUM_OPS {
</a><a href="#h10-0-244" id="h10-0-244" class="d">-                    match rng.gen::&lt;Op&gt;() {
</a><a href="#h10-0-245" id="h10-0-245" class="d">-                        Op::Set =&gt; {
</a><a href="#h10-0-246" id="h10-0-246" class="d">-                            let key = random_key(&amp;mut rng);
</a><a href="#h10-0-247" id="h10-0-247" class="d">-                            let value = random_value(&amp;mut rng);
</a><a href="#h10-0-248" id="h10-0-248" class="d">-                            println!(&quot;set {:?} = {:?}&quot;, key, value);
</a><a href="#h10-0-249" id="h10-0-249" class="d">-                            s.set(&amp;key, value.clone())?;
</a><a href="#h10-0-250" id="h10-0-250" class="d">-                            m.insert(key, value);
</a><a href="#h10-0-251" id="h10-0-251" class="d">-                        }
</a><a href="#h10-0-252" id="h10-0-252" class="d">-                        Op::Delete =&gt; {
</a><a href="#h10-0-253" id="h10-0-253" class="d">-                            let key = random_key(&amp;mut rng);
</a><a href="#h10-0-254" id="h10-0-254" class="d">-                            println!(&quot;delete {:?}&quot;, key);
</a><a href="#h10-0-255" id="h10-0-255" class="d">-                            s.delete(&amp;key)?;
</a><a href="#h10-0-256" id="h10-0-256" class="d">-                            m.remove(&amp;key);
</a><a href="#h10-0-257" id="h10-0-257" class="d">-                        }
</a><a href="#h10-0-258" id="h10-0-258" class="d">-                        Op::Get =&gt; {
</a><a href="#h10-0-259" id="h10-0-259" class="d">-                            let key = random_key(&amp;mut rng);
</a><a href="#h10-0-260" id="h10-0-260" class="d">-                            let value = s.get(&amp;key)?;
</a><a href="#h10-0-261" id="h10-0-261" class="d">-                            let expect = m.get(&amp;key).cloned();
</a><a href="#h10-0-262" id="h10-0-262" class="d">-                            println!(&quot;get {:?} =&gt; {:?}&quot;, key, value);
</a><a href="#h10-0-263" id="h10-0-263" class="d">-                            assert_eq!(value, expect);
</a><a href="#h10-0-264" id="h10-0-264" class="d">-                        }
</a><a href="#h10-0-265" id="h10-0-265" class="d">-                        Op::Scan =&gt; {
</a><a href="#h10-0-266" id="h10-0-266" class="d">-                            let mut from = random_key(&amp;mut rng);
</a><a href="#h10-0-267" id="h10-0-267" class="d">-                            let mut to = random_key(&amp;mut rng);
</a><a href="#h10-0-268" id="h10-0-268" class="d">-                            if (to &lt; from) {
</a><a href="#h10-0-269" id="h10-0-269" class="d">-                                (from, to) = (to, from)
</a><a href="#h10-0-270" id="h10-0-270" class="d">-                            }
</a><a href="#h10-0-271" id="h10-0-271" class="d">-                            println!(&quot;scan {:?} .. {:?}&quot;, from, to);
</a><a href="#h10-0-272" id="h10-0-272" class="d">-                            let result =
</a><a href="#h10-0-273" id="h10-0-273" class="d">-                                s.scan(from.clone()..to.clone()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h10-0-274" id="h10-0-274" class="d">-                            let expect = m
</a><a href="#h10-0-275" id="h10-0-275" class="d">-                                .range(from..to)
</a><a href="#h10-0-276" id="h10-0-276" class="d">-                                .map(|(k, v)| (k.clone(), v.clone()))
</a><a href="#h10-0-277" id="h10-0-277" class="d">-                                .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h10-0-278" id="h10-0-278" class="d">-                            assert_eq!(result, expect);
</a><a href="#h10-0-279" id="h10-0-279" class="d">-                        }
</a><a href="#h10-0-280" id="h10-0-280" class="d">-                    }
</a><a href="#h10-0-281" id="h10-0-281" class="d">-                }
</a><a href="#h10-0-282" id="h10-0-282" class="d">-
</a><a href="#h10-0-283" id="h10-0-283" class="d">-                // Compare the final states.
</a><a href="#h10-0-284" id="h10-0-284" class="d">-                println!(&quot;comparing final state&quot;);
</a><a href="#h10-0-285" id="h10-0-285" class="d">-
</a><a href="#h10-0-286" id="h10-0-286" class="d">-                let state = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h10-0-287" id="h10-0-287" class="d">-                let expect = m
</a><a href="#h10-0-288" id="h10-0-288" class="d">-                    .range::&lt;Vec&lt;u8&gt;, _&gt;(..)
</a><a href="#h10-0-289" id="h10-0-289" class="d">-                    .map(|(k, v)| (k.clone(), v.clone()))
</a><a href="#h10-0-290" id="h10-0-290" class="d">-                    .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h10-0-291" id="h10-0-291" class="d">-                assert_eq!(state, expect);
</a><a href="#h10-0-292" id="h10-0-292" class="d">-
</a><a href="#h10-0-293" id="h10-0-293" class="d">-                Ok(())
</a><a href="#h10-0-294" id="h10-0-294" class="d">-            }
</a><a href="#h10-0-295" id="h10-0-295" class="d">-        };
</a><a href="#h10-0-296" id="h10-0-296" class="d">-    }
</a><a href="#h10-0-297" id="h10-0-297" class="d">-
</a><a href="#h10-0-298" id="h10-0-298" class="d">-    pub(super) use test_store; // export for use in submodules
</a><a href="#h10-0-299" id="h10-0-299" class="d">-}
</a><b>diff --git a/<a id="h11" href="../file/src/storage/kv/mvcc.rs.html">src/storage/kv/mvcc.rs</a> b/<a href="../file/src/storage/kv/mvcc.rs.html">src/storage/kv/mvcc.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h11-0-0" id="h11-0-0" class="d">-use super::{encoding, Store};
</a><a href="#h11-0-1" id="h11-0-1" class="i">+use super::{encoding, Engine};
</a> use crate::error::{Error, Result};
 
 use serde::{Deserialize, Serialize};
<a href="#h11-1" id="h11-1" class="h">@@ -16,49 +16,49 @@ pub struct Status {
</a>     pub storage: String,
 }
 
<a href="#h11-1-3" id="h11-1-3" class="d">-/// An MVCC-based transactional key-value store.
</a><a href="#h11-1-4" id="h11-1-4" class="d">-pub struct MVCC&lt;S: Store&gt; {
</a><a href="#h11-1-5" id="h11-1-5" class="d">-    /// The underlying KV store. It is protected by a mutex so it can be shared between txns.
</a><a href="#h11-1-6" id="h11-1-6" class="d">-    store: Arc&lt;Mutex&lt;S&gt;&gt;,
</a><a href="#h11-1-7" id="h11-1-7" class="i">+/// An MVCC-based transactional key-value engine.
</a><a href="#h11-1-8" id="h11-1-8" class="i">+pub struct MVCC&lt;E: Engine&gt; {
</a><a href="#h11-1-9" id="h11-1-9" class="i">+    /// The underlying KV engine. It is protected by a mutex so it can be shared between txns.
</a><a href="#h11-1-10" id="h11-1-10" class="i">+    engine: Arc&lt;Mutex&lt;E&gt;&gt;,
</a> }
 
<a href="#h11-1-13" id="h11-1-13" class="d">-impl&lt;S: Store&gt; Clone for MVCC&lt;S&gt; {
</a><a href="#h11-1-14" id="h11-1-14" class="i">+impl&lt;E: Engine&gt; Clone for MVCC&lt;E&gt; {
</a>     fn clone(&amp;self) -&gt; Self {
<a href="#h11-1-16" id="h11-1-16" class="d">-        MVCC { store: self.store.clone() }
</a><a href="#h11-1-17" id="h11-1-17" class="i">+        MVCC { engine: self.engine.clone() }
</a>     }
 }
 
<a href="#h11-1-21" id="h11-1-21" class="d">-impl&lt;S: Store&gt; MVCC&lt;S&gt; {
</a><a href="#h11-1-22" id="h11-1-22" class="d">-    /// Creates a new MVCC key-value store with the given key-value store for storage.
</a><a href="#h11-1-23" id="h11-1-23" class="d">-    pub fn new(store: S) -&gt; Self {
</a><a href="#h11-1-24" id="h11-1-24" class="d">-        Self { store: Arc::new(Mutex::new(store)) }
</a><a href="#h11-1-25" id="h11-1-25" class="i">+impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a><a href="#h11-1-26" id="h11-1-26" class="i">+    /// Creates a new MVCC engine with the given storage engine.
</a><a href="#h11-1-27" id="h11-1-27" class="i">+    pub fn new(engine: E) -&gt; Self {
</a><a href="#h11-1-28" id="h11-1-28" class="i">+        Self { engine: Arc::new(Mutex::new(engine)) }
</a>     }
 
     /// Begins a new transaction in read-write mode.
     #[allow(dead_code)]
<a href="#h11-1-33" id="h11-1-33" class="d">-    pub fn begin(&amp;self) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a><a href="#h11-1-34" id="h11-1-34" class="d">-        Transaction::begin(self.store.clone(), Mode::ReadWrite)
</a><a href="#h11-1-35" id="h11-1-35" class="i">+    pub fn begin(&amp;self) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a><a href="#h11-1-36" id="h11-1-36" class="i">+        Transaction::begin(self.engine.clone(), Mode::ReadWrite)
</a>     }
 
     /// Begins a new transaction in the given mode.
<a href="#h11-1-40" id="h11-1-40" class="d">-    pub fn begin_with_mode(&amp;self, mode: Mode) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a><a href="#h11-1-41" id="h11-1-41" class="d">-        Transaction::begin(self.store.clone(), mode)
</a><a href="#h11-1-42" id="h11-1-42" class="i">+    pub fn begin_with_mode(&amp;self, mode: Mode) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a><a href="#h11-1-43" id="h11-1-43" class="i">+        Transaction::begin(self.engine.clone(), mode)
</a>     }
 
     /// Resumes a transaction with the given ID.
<a href="#h11-1-47" id="h11-1-47" class="d">-    pub fn resume(&amp;self, id: u64) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a><a href="#h11-1-48" id="h11-1-48" class="d">-        Transaction::resume(self.store.clone(), id)
</a><a href="#h11-1-49" id="h11-1-49" class="i">+    pub fn resume(&amp;self, id: u64) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a><a href="#h11-1-50" id="h11-1-50" class="i">+        Transaction::resume(self.engine.clone(), id)
</a>     }
 
     /// Fetches an unversioned metadata value
     pub fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
<a href="#h11-1-55" id="h11-1-55" class="d">-        let mut session = self.store.lock()?;
</a><a href="#h11-1-56" id="h11-1-56" class="i">+        let mut session = self.engine.lock()?;
</a>         session.get(&amp;Key::Metadata(key.into()).encode())
     }
 
     /// Sets an unversioned metadata value
     pub fn set_metadata(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
<a href="#h11-1-62" id="h11-1-62" class="d">-        let mut session = self.store.lock()?;
</a><a href="#h11-1-63" id="h11-1-63" class="i">+        let mut session = self.engine.lock()?;
</a>         session.set(&amp;Key::Metadata(key.into()).encode(), value)
     }
 
<a href="#h11-2" id="h11-2" class="h">@@ -68,14 +68,14 @@ impl&lt;S: Store&gt; MVCC&lt;S&gt; {
</a>     // https://github.com/rust-lang/reference/issues/452
     #[allow(clippy::needless_return)]
     pub fn status(&amp;self) -&gt; Result&lt;Status&gt; {
<a href="#h11-2-3" id="h11-2-3" class="d">-        let mut store = self.store.lock()?;
</a><a href="#h11-2-4" id="h11-2-4" class="i">+        let mut engine = self.engine.lock()?;
</a>         return Ok(Status {
<a href="#h11-2-6" id="h11-2-6" class="d">-            storage: store.to_string(),
</a><a href="#h11-2-7" id="h11-2-7" class="d">-            txns: match store.get(&amp;Key::TxnNext.encode())? {
</a><a href="#h11-2-8" id="h11-2-8" class="i">+            storage: engine.to_string(),
</a><a href="#h11-2-9" id="h11-2-9" class="i">+            txns: match engine.get(&amp;Key::TxnNext.encode())? {
</a>                 Some(ref v) =&gt; deserialize(v)?,
                 None =&gt; 1,
             } - 1,
<a href="#h11-2-13" id="h11-2-13" class="d">-            txns_active: store
</a><a href="#h11-2-14" id="h11-2-14" class="i">+            txns_active: engine
</a>                 .scan(Key::TxnActive(0).encode()..Key::TxnActive(std::u64::MAX).encode())
                 .try_fold(0, |count, r| r.map(|_| count + 1))?,
         });
<a href="#h11-3" id="h11-3" class="h">@@ -93,9 +93,9 @@ fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a> }
 
 /// An MVCC transaction.
<a href="#h11-3-3" id="h11-3-3" class="d">-pub struct Transaction&lt;S: Store&gt; {
</a><a href="#h11-3-4" id="h11-3-4" class="d">-    /// The underlying store for the transaction. Shared between transactions using a mutex.
</a><a href="#h11-3-5" id="h11-3-5" class="d">-    store: Arc&lt;Mutex&lt;S&gt;&gt;,
</a><a href="#h11-3-6" id="h11-3-6" class="i">+pub struct Transaction&lt;E: Engine&gt; {
</a><a href="#h11-3-7" id="h11-3-7" class="i">+    /// The underlying engine for the transaction. Shared between transactions using a mutex.
</a><a href="#h11-3-8" id="h11-3-8" class="i">+    engine: Arc&lt;Mutex&lt;E&gt;&gt;,
</a>     /// The unique transaction ID.
     id: u64,
     /// The transaction mode.
<a href="#h11-4" id="h11-4" class="h">@@ -104,10 +104,10 @@ pub struct Transaction&lt;S: Store&gt; {
</a>     snapshot: Snapshot,
 }
 
<a href="#h11-4-3" id="h11-4-3" class="d">-impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a><a href="#h11-4-4" id="h11-4-4" class="i">+impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// Begins a new transaction in the given mode.
<a href="#h11-4-6" id="h11-4-6" class="d">-    fn begin(store: Arc&lt;Mutex&lt;S&gt;&gt;, mode: Mode) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-4-7" id="h11-4-7" class="d">-        let mut session = store.lock()?;
</a><a href="#h11-4-8" id="h11-4-8" class="i">+    fn begin(engine: Arc&lt;Mutex&lt;E&gt;&gt;, mode: Mode) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-4-9" id="h11-4-9" class="i">+        let mut session = engine.lock()?;
</a> 
         let id = match session.get(&amp;Key::TxnNext.encode())? {
             Some(ref v) =&gt; deserialize(v)?,
<a href="#h11-5" id="h11-5" class="h">@@ -121,26 +121,26 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>         // for any future snapshot transactions looking at this one.
         let mut snapshot = Snapshot::take(&amp;mut session, id)?;
         if let Mode::Snapshot { version } = &amp;mode {
<a href="#h11-5-3" id="h11-5-3" class="d">-            snapshot = Snapshot::restore(&amp;mut session, *version)?
</a><a href="#h11-5-4" id="h11-5-4" class="i">+            snapshot = Snapshot::reengine(&amp;mut session, *version)?
</a>         }
         drop(session);
 
<a href="#h11-5-8" id="h11-5-8" class="d">-        Ok(Self { store, id, mode, snapshot })
</a><a href="#h11-5-9" id="h11-5-9" class="i">+        Ok(Self { engine, id, mode, snapshot })
</a>     }
 
     /// Resumes an active transaction with the given ID. Errors if the transaction is not active.
<a href="#h11-5-13" id="h11-5-13" class="d">-    fn resume(store: Arc&lt;Mutex&lt;S&gt;&gt;, id: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-5-14" id="h11-5-14" class="d">-        let mut session = store.lock()?;
</a><a href="#h11-5-15" id="h11-5-15" class="i">+    fn resume(engine: Arc&lt;Mutex&lt;E&gt;&gt;, id: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-5-16" id="h11-5-16" class="i">+        let mut session = engine.lock()?;
</a>         let mode = match session.get(&amp;Key::TxnActive(id).encode())? {
             Some(v) =&gt; deserialize(&amp;v)?,
             None =&gt; return Err(Error::Value(format!(&quot;No active transaction {}&quot;, id))),
         };
         let snapshot = match &amp;mode {
<a href="#h11-5-22" id="h11-5-22" class="d">-            Mode::Snapshot { version } =&gt; Snapshot::restore(&amp;mut session, *version)?,
</a><a href="#h11-5-23" id="h11-5-23" class="d">-            _ =&gt; Snapshot::restore(&amp;mut session, id)?,
</a><a href="#h11-5-24" id="h11-5-24" class="i">+            Mode::Snapshot { version } =&gt; Snapshot::reengine(&amp;mut session, *version)?,
</a><a href="#h11-5-25" id="h11-5-25" class="i">+            _ =&gt; Snapshot::reengine(&amp;mut session, id)?,
</a>         };
         std::mem::drop(session);
<a href="#h11-5-28" id="h11-5-28" class="d">-        Ok(Self { store, id, mode, snapshot })
</a><a href="#h11-5-29" id="h11-5-29" class="i">+        Ok(Self { engine, id, mode, snapshot })
</a>     }
 
     /// Returns the transaction ID.
<a href="#h11-6" id="h11-6" class="h">@@ -155,14 +155,14 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a> 
     /// Commits the transaction, by removing the txn from the active set.
     pub fn commit(self) -&gt; Result&lt;()&gt; {
<a href="#h11-6-3" id="h11-6-3" class="d">-        let mut session = self.store.lock()?;
</a><a href="#h11-6-4" id="h11-6-4" class="i">+        let mut session = self.engine.lock()?;
</a>         session.delete(&amp;Key::TxnActive(self.id).encode())?;
         session.flush()
     }
 
     /// Rolls back the transaction, by removing all updated entries.
     pub fn rollback(self) -&gt; Result&lt;()&gt; {
<a href="#h11-6-11" id="h11-6-11" class="d">-        let mut session = self.store.lock()?;
</a><a href="#h11-6-12" id="h11-6-12" class="i">+        let mut session = self.engine.lock()?;
</a>         if self.mode.mutable() {
             let mut rollback = Vec::new();
             let mut scan = session.scan(
<a href="#h11-7" id="h11-7" class="h">@@ -191,7 +191,7 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a> 
     /// Fetches a key.
     pub fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
<a href="#h11-7-3" id="h11-7-3" class="d">-        let mut session = self.store.lock()?;
</a><a href="#h11-7-4" id="h11-7-4" class="i">+        let mut session = self.engine.lock()?;
</a>         let mut scan = session
             .scan(Key::Record(key.into(), 0).encode()..=Key::Record(key.into(), self.id).encode())
             .rev();
<a href="#h11-8" id="h11-8" class="h">@@ -220,8 +220,8 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>             Bound::Included(k) =&gt; Bound::Included(Key::Record(k.into(), std::u64::MAX).encode()),
             Bound::Unbounded =&gt; Bound::Unbounded,
         };
<a href="#h11-8-3" id="h11-8-3" class="d">-        // TODO: For now, collect results from the store to not have to deal with lifetimes.
</a><a href="#h11-8-4" id="h11-8-4" class="d">-        let scan = Box::new(self.store.lock()?.scan((start, end)).collect::&lt;Vec&lt;_&gt;&gt;().into_iter());
</a><a href="#h11-8-5" id="h11-8-5" class="i">+        // TODO: For now, collect results from the engine to not have to deal with lifetimes.
</a><a href="#h11-8-6" id="h11-8-6" class="i">+        let scan = Box::new(self.engine.lock()?.scan((start, end)).collect::&lt;Vec&lt;_&gt;&gt;().into_iter());
</a>         Ok(Box::new(Scan::new(scan, self.snapshot.clone())))
     }
 
<a href="#h11-9" id="h11-9" class="h">@@ -259,7 +259,7 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>         if !self.mode.mutable() {
             return Err(Error::ReadOnly);
         }
<a href="#h11-9-3" id="h11-9-3" class="d">-        let mut session = self.store.lock()?;
</a><a href="#h11-9-4" id="h11-9-4" class="i">+        let mut session = self.engine.lock()?;
</a> 
         // Check if the key is dirty, i.e. if it has any uncommitted changes, by scanning for any
         // versions that aren&#39;t visible to us.
<a href="#h11-10" id="h11-10" class="h">@@ -338,7 +338,7 @@ struct Snapshot {
</a> 
 impl Snapshot {
     /// Takes a new snapshot, persisting it as `Key::TxnSnapshot(version)`.
<a href="#h11-10-3" id="h11-10-3" class="d">-    fn take&lt;S: Store&gt;(session: &amp;mut MutexGuard&lt;S&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-10-4" id="h11-10-4" class="i">+    fn take&lt;E: Engine&gt;(session: &amp;mut MutexGuard&lt;E&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a>         let mut snapshot = Self { version, invisible: HashSet::new() };
         let mut scan = session.scan(Key::TxnActive(0).encode()..Key::TxnActive(version).encode());
         while let Some((key, _)) = scan.next().transpose()? {
<a href="#h11-11" id="h11-11" class="h">@@ -352,8 +352,8 @@ impl Snapshot {
</a>         Ok(snapshot)
     }
 
<a href="#h11-11-3" id="h11-11-3" class="d">-    /// Restores an existing snapshot from `Key::TxnSnapshot(version)`, or errors if not found.
</a><a href="#h11-11-4" id="h11-11-4" class="d">-    fn restore&lt;S: Store&gt;(session: &amp;mut MutexGuard&lt;S&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-11-5" id="h11-11-5" class="i">+    /// Reengines an existing snapshot from `Key::TxnSnapshot(version)`, or errors if not found.
</a><a href="#h11-11-6" id="h11-11-6" class="i">+    fn reengine&lt;E: Engine&gt;(session: &amp;mut MutexGuard&lt;E&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a>         match session.get(&amp;Key::TxnSnapshot(version).encode())? {
             Some(ref v) =&gt; Ok(Self { version, invisible: deserialize(v)? }),
             None =&gt; Err(Error::Value(format!(&quot;Snapshot not found for version {}&quot;, version))),
<a href="#h11-12" id="h11-12" class="h">@@ -427,7 +427,7 @@ pub type ScanIterator&lt;&#39;a&gt; =
</a> 
 /// A key range scan.
 pub struct Scan&lt;&#39;a&gt; {
<a href="#h11-12-3" id="h11-12-3" class="d">-    /// The augmented KV store iterator, with key (decoded) and value. Note that we don&#39;t retain
</a><a href="#h11-12-4" id="h11-12-4" class="i">+    /// The augmented KV engine iterator, with key (decoded) and value. Note that we don&#39;t retain
</a>     /// the decoded version, so there will be multiple keys (for each version). We want the last.
     scan: Peekable&lt;ScanIterator&lt;&#39;a&gt;&gt;,
     /// Keeps track of next_back() seen key, whose previous versions should be ignored.
<b>diff --git a/<a id="h12" href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a> b/<a href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -1,2 +1,3 @@
</a><a href="#h12-0-0" id="h12-0-0" class="i">+pub mod engine;
</a> pub mod kv;
 pub mod log;
</pre>
</div>
</body>
</html>
