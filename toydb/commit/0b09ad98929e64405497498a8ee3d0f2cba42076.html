<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Add MVCC module documentation. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/0b09ad98929e64405497498a8ee3d0f2cba42076.html">0b09ad98929e64405497498a8ee3d0f2cba42076</a>
<b>parent</b> <a href="../commit/cccc547b5016c60bd1d1a92815196c7bd14a0b40.html">cccc547b5016c60bd1d1a92815196c7bd14a0b40</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Fri,  8 Sep 2023 20:17:49 +0200

Add MVCC module documentation.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/storage/mvcc.rs</a></td><td> | </td><td class="num">170</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">---</span></td></tr>
</table></pre><pre>1 file changed, 165 insertions(+), 5 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -1,3 +1,144 @@
</a><a href="#h0-0-0" id="h0-0-0" class="i">+//! This module implements MVCC (Multi-Version Concurrency Control), a widely
</a><a href="#h0-0-1" id="h0-0-1" class="i">+//! used method for ACID transactions and concurrency control. It allows
</a><a href="#h0-0-2" id="h0-0-2" class="i">+//! multiple concurrent transactions to access and modify the same dataset,
</a><a href="#h0-0-3" id="h0-0-3" class="i">+//! isolates them from each other, detects and handles conflicts, and commits
</a><a href="#h0-0-4" id="h0-0-4" class="i">+//! their writes atomically as a single unit. It uses an underlying storage
</a><a href="#h0-0-5" id="h0-0-5" class="i">+//! engine to store raw keys and values.
</a><a href="#h0-0-6" id="h0-0-6" class="i">+//!
</a><a href="#h0-0-7" id="h0-0-7" class="i">+//! VERSIONS
</a><a href="#h0-0-8" id="h0-0-8" class="i">+//! ========
</a><a href="#h0-0-9" id="h0-0-9" class="i">+//!
</a><a href="#h0-0-10" id="h0-0-10" class="i">+//! MVCC handles concurrency control by managing multiple historical versions of
</a><a href="#h0-0-11" id="h0-0-11" class="i">+//! keys, identified by a timestamp. Every write adds a new version at a higher
</a><a href="#h0-0-12" id="h0-0-12" class="i">+//! timestamp, with deletes having a special tombstone value. For example, the
</a><a href="#h0-0-13" id="h0-0-13" class="i">+//! keys a,b,c,d may have the following values at various logical timestamps (x
</a><a href="#h0-0-14" id="h0-0-14" class="i">+//! is tombstone):
</a><a href="#h0-0-15" id="h0-0-15" class="i">+//!
</a><a href="#h0-0-16" id="h0-0-16" class="i">+//! Time
</a><a href="#h0-0-17" id="h0-0-17" class="i">+//! 5
</a><a href="#h0-0-18" id="h0-0-18" class="i">+//! 4  a4          
</a><a href="#h0-0-19" id="h0-0-19" class="i">+//! 3      b3      x
</a><a href="#h0-0-20" id="h0-0-20" class="i">+//! 2            
</a><a href="#h0-0-21" id="h0-0-21" class="i">+//! 1  a1      c1  d1
</a><a href="#h0-0-22" id="h0-0-22" class="i">+//!    a   b   c   d   Keys
</a><a href="#h0-0-23" id="h0-0-23" class="i">+//!
</a><a href="#h0-0-24" id="h0-0-24" class="i">+//! A transaction t2 that started at T=2 will see the values a=a1, c=c1, d=d1. A
</a><a href="#h0-0-25" id="h0-0-25" class="i">+//! different transaction t5 running at T=5 will see a=a4, b=b3, c=c1.
</a><a href="#h0-0-26" id="h0-0-26" class="i">+//!
</a><a href="#h0-0-27" id="h0-0-27" class="i">+//! ToyDB uses logical timestamps with a sequence number stored in
</a><a href="#h0-0-28" id="h0-0-28" class="i">+//! Key::NextVersion. Each new read-write transaction takes its timestamp from
</a><a href="#h0-0-29" id="h0-0-29" class="i">+//! the current value of Key::NextVersion and then increments the value for the
</a><a href="#h0-0-30" id="h0-0-30" class="i">+//! next transaction.
</a><a href="#h0-0-31" id="h0-0-31" class="i">+//!
</a><a href="#h0-0-32" id="h0-0-32" class="i">+//! ISOLATION
</a><a href="#h0-0-33" id="h0-0-33" class="i">+//! =========
</a><a href="#h0-0-34" id="h0-0-34" class="i">+//!
</a><a href="#h0-0-35" id="h0-0-35" class="i">+//! MVCC provides an isolation level called snapshot isolation. Briefly,
</a><a href="#h0-0-36" id="h0-0-36" class="i">+//! transactions see a consistent snapshot of the database state as of their
</a><a href="#h0-0-37" id="h0-0-37" class="i">+//! start time. Writes made by concurrent or subsequent transactions are never
</a><a href="#h0-0-38" id="h0-0-38" class="i">+//! visible to it. If two concurrent transactions write to the same key they
</a><a href="#h0-0-39" id="h0-0-39" class="i">+//! will conflict and one of them must retry. A transaction&#39;s writes become
</a><a href="#h0-0-40" id="h0-0-40" class="i">+//! atomically visible to subsequent transactions only when they commit, and are
</a><a href="#h0-0-41" id="h0-0-41" class="i">+//! rolled back on failure. Read-only transactions never conflict with other
</a><a href="#h0-0-42" id="h0-0-42" class="i">+//! transactions.
</a><a href="#h0-0-43" id="h0-0-43" class="i">+//!
</a><a href="#h0-0-44" id="h0-0-44" class="i">+//! Transactions write new versions at their timestamp, storing them as
</a><a href="#h0-0-45" id="h0-0-45" class="i">+//! Key::Version(key, version) =&gt; value. If a transaction writes to a key and
</a><a href="#h0-0-46" id="h0-0-46" class="i">+//! finds a newer version, it returns an error and the client must retry.
</a><a href="#h0-0-47" id="h0-0-47" class="i">+//!
</a><a href="#h0-0-48" id="h0-0-48" class="i">+//! Active (uncommitted) read-write transactions record their version in the
</a><a href="#h0-0-49" id="h0-0-49" class="i">+//! active set, stored as Key::Active(version). When new transactions begin, they
</a><a href="#h0-0-50" id="h0-0-50" class="i">+//! take a snapshot of this active set, and any key versions that belong to a
</a><a href="#h0-0-51" id="h0-0-51" class="i">+//! transaction in the active set are considered invisible (to anyone except that
</a><a href="#h0-0-52" id="h0-0-52" class="i">+//! transaction itself). Writes to keys that already have a past version in the
</a><a href="#h0-0-53" id="h0-0-53" class="i">+//! active set will also return an error.
</a><a href="#h0-0-54" id="h0-0-54" class="i">+//!
</a><a href="#h0-0-55" id="h0-0-55" class="i">+//! To commit, a transaction simply deletes its record in the active set. This
</a><a href="#h0-0-56" id="h0-0-56" class="i">+//! will immediately (and, crucially, atomically) make all of its writes visible
</a><a href="#h0-0-57" id="h0-0-57" class="i">+//! to subsequent transactions, but not ongoing ones. If the transaction is
</a><a href="#h0-0-58" id="h0-0-58" class="i">+//! cancelled and rolled back, it maintains a record of all keys it wrote as
</a><a href="#h0-0-59" id="h0-0-59" class="i">+//! Key::TxnWrite(version, key), so that it can find the corresponding versions
</a><a href="#h0-0-60" id="h0-0-60" class="i">+//! and delete them before removing itself from the active set.
</a><a href="#h0-0-61" id="h0-0-61" class="i">+//!
</a><a href="#h0-0-62" id="h0-0-62" class="i">+//! Consider the following example, where we have two ongoing transactions at
</a><a href="#h0-0-63" id="h0-0-63" class="i">+//! time T=2 and T=5, with some writes that are not yet committed marked in
</a><a href="#h0-0-64" id="h0-0-64" class="i">+//! parentheses.
</a><a href="#h0-0-65" id="h0-0-65" class="i">+//!
</a><a href="#h0-0-66" id="h0-0-66" class="i">+//! Active set: [2, 5]
</a><a href="#h0-0-67" id="h0-0-67" class="i">+//!
</a><a href="#h0-0-68" id="h0-0-68" class="i">+//! Time
</a><a href="#h0-0-69" id="h0-0-69" class="i">+//! 5 (a5)
</a><a href="#h0-0-70" id="h0-0-70" class="i">+//! 4  a4          
</a><a href="#h0-0-71" id="h0-0-71" class="i">+//! 3      b3      x
</a><a href="#h0-0-72" id="h0-0-72" class="i">+//! 2         (x)     (e2)
</a><a href="#h0-0-73" id="h0-0-73" class="i">+//! 1  a1      c1  d1
</a><a href="#h0-0-74" id="h0-0-74" class="i">+//!    a   b   c   d   e   Keys
</a><a href="#h0-0-75" id="h0-0-75" class="i">+//!
</a><a href="#h0-0-76" id="h0-0-76" class="i">+//! Here, t2 will see a=a1, d=d1, e=e2 (it sees its own writes). t5 will see
</a><a href="#h0-0-77" id="h0-0-77" class="i">+//! a=a5, b=b3, c=c1. t2 does not see any newer versions, and t5 does not see
</a><a href="#h0-0-78" id="h0-0-78" class="i">+//! the tombstone at c@2 nor the value e=e2, because version=2 is in its active
</a><a href="#h0-0-79" id="h0-0-79" class="i">+//! set.
</a><a href="#h0-0-80" id="h0-0-80" class="i">+//!
</a><a href="#h0-0-81" id="h0-0-81" class="i">+//! If t2 tries to write b=b2, it receives an error and must retry, because a
</a><a href="#h0-0-82" id="h0-0-82" class="i">+//! newer version exists. Similarly, if t5 tries to write e=e5, it receives an
</a><a href="#h0-0-83" id="h0-0-83" class="i">+//! error and must retry, because the version e=e2 is in its active set.
</a><a href="#h0-0-84" id="h0-0-84" class="i">+//!
</a><a href="#h0-0-85" id="h0-0-85" class="i">+//! To commit, t2 can remove itself from the active set. A new transaction t6
</a><a href="#h0-0-86" id="h0-0-86" class="i">+//! starting after the commit will then see c as deleted and e=e2. t5 will still
</a><a href="#h0-0-87" id="h0-0-87" class="i">+//! not see any of t2&#39;s writes, because it&#39;s still in its local snapshot of the
</a><a href="#h0-0-88" id="h0-0-88" class="i">+//! active set at the time it began.
</a><a href="#h0-0-89" id="h0-0-89" class="i">+//!
</a><a href="#h0-0-90" id="h0-0-90" class="i">+//! READ-ONLY AND TIME TRAVEL QUERIES
</a><a href="#h0-0-91" id="h0-0-91" class="i">+//! =================================
</a><a href="#h0-0-92" id="h0-0-92" class="i">+//!
</a><a href="#h0-0-93" id="h0-0-93" class="i">+//! Since MVCC stores historical versions, it can trivially support time travel
</a><a href="#h0-0-94" id="h0-0-94" class="i">+//! queries where a transaction reads at a past timestamp and has a consistent
</a><a href="#h0-0-95" id="h0-0-95" class="i">+//! view of the database at that time.
</a><a href="#h0-0-96" id="h0-0-96" class="i">+//!
</a><a href="#h0-0-97" id="h0-0-97" class="i">+//! This is done by a transaction simply using a past version, as if it had
</a><a href="#h0-0-98" id="h0-0-98" class="i">+//! started far in the past, ignoring newer versions like any other transaction.
</a><a href="#h0-0-99" id="h0-0-99" class="i">+//! This transaction cannot write, as it does not have a unique timestamp (the
</a><a href="#h0-0-100" id="h0-0-100" class="i">+//! original read-write transaction originally owned this timestamp).
</a><a href="#h0-0-101" id="h0-0-101" class="i">+//!
</a><a href="#h0-0-102" id="h0-0-102" class="i">+//! The only wrinkle is that the time-travel query must also know what the active
</a><a href="#h0-0-103" id="h0-0-103" class="i">+//! set was at that version. Otherwise, it may see past transactions that committed
</a><a href="#h0-0-104" id="h0-0-104" class="i">+//! after that time, which were not visible to the original transaction that wrote
</a><a href="#h0-0-105" id="h0-0-105" class="i">+//! at that version. Similarly, if a time-travel query reads at a version that is
</a><a href="#h0-0-106" id="h0-0-106" class="i">+//! still active, it should not see its in-progress writes, and after it commits
</a><a href="#h0-0-107" id="h0-0-107" class="i">+//! a different time-travel query should not see those writes either, to maintain
</a><a href="#h0-0-108" id="h0-0-108" class="i">+//! version consistency.
</a><a href="#h0-0-109" id="h0-0-109" class="i">+//!
</a><a href="#h0-0-110" id="h0-0-110" class="i">+//! To achieve this, every read-write transaction stores its active set snapshot
</a><a href="#h0-0-111" id="h0-0-111" class="i">+//! in the storage engine as well, as Key::TxnActiveSnapshot, such that later
</a><a href="#h0-0-112" id="h0-0-112" class="i">+//! time-travel queries can restore its original snapshot. Furthermore, a
</a><a href="#h0-0-113" id="h0-0-113" class="i">+//! time-travel query can only see versions below the snapshot version, otherwise
</a><a href="#h0-0-114" id="h0-0-114" class="i">+//! it could see spurious in-progress or since-committed versions.
</a><a href="#h0-0-115" id="h0-0-115" class="i">+//!
</a><a href="#h0-0-116" id="h0-0-116" class="i">+//! In the following example, a time-travel query at version=3 would see a=a1,
</a><a href="#h0-0-117" id="h0-0-117" class="i">+//! c=c1, d=d1.
</a><a href="#h0-0-118" id="h0-0-118" class="i">+//!
</a><a href="#h0-0-119" id="h0-0-119" class="i">+//! Time
</a><a href="#h0-0-120" id="h0-0-120" class="i">+//! 5
</a><a href="#h0-0-121" id="h0-0-121" class="i">+//! 4  a4          
</a><a href="#h0-0-122" id="h0-0-122" class="i">+//! 3      b3      x
</a><a href="#h0-0-123" id="h0-0-123" class="i">+//! 2            
</a><a href="#h0-0-124" id="h0-0-124" class="i">+//! 1  a1      c1  d1
</a><a href="#h0-0-125" id="h0-0-125" class="i">+//!    a   b   c   d   Keys
</a><a href="#h0-0-126" id="h0-0-126" class="i">+//!
</a><a href="#h0-0-127" id="h0-0-127" class="i">+//! Read-only queries work similarly to time-travel queries, with one exception:
</a><a href="#h0-0-128" id="h0-0-128" class="i">+//! they read at the next (current) version, i.e. Key::NextVersion, and use the
</a><a href="#h0-0-129" id="h0-0-129" class="i">+//! current active set, storing the snapshot in memory only. Read-only queries
</a><a href="#h0-0-130" id="h0-0-130" class="i">+//! do not increment the version sequence number in Key::NextVersion.
</a><a href="#h0-0-131" id="h0-0-131" class="i">+//!
</a><a href="#h0-0-132" id="h0-0-132" class="i">+//! GARBAGE COLLECTION
</a><a href="#h0-0-133" id="h0-0-133" class="i">+//! ==================
</a><a href="#h0-0-134" id="h0-0-134" class="i">+//!
</a><a href="#h0-0-135" id="h0-0-135" class="i">+//! Normally, old versions would be garbage collected regularly, when they are
</a><a href="#h0-0-136" id="h0-0-136" class="i">+//! no longer needed by active transactions or time-travel queries. However,
</a><a href="#h0-0-137" id="h0-0-137" class="i">+//! ToyDB does not implement garbage collection, instead keeping all history
</a><a href="#h0-0-138" id="h0-0-138" class="i">+//! forever, both out of laziness and also because it allows unlimited time
</a><a href="#h0-0-139" id="h0-0-139" class="i">+//! travel queries (it&#39;s a feature, not a bug!).
</a><a href="#h0-0-140" id="h0-0-140" class="i">+
</a> use super::{keycode, Engine};
 use crate::error::{Error, Result};
 
<a href="#h0-1" id="h0-1" class="h">@@ -40,7 +181,8 @@ enum Key&lt;&#39;a&gt; {
</a>     ),
     /// Unversioned non-transactional key/value pairs. These exist separately
     /// from versioned keys, i.e. the unversioned key &quot;foo&quot; is entirely
<a href="#h0-1-3" id="h0-1-3" class="d">-    /// independent of the versioned key &quot;foo@7&quot;.
</a><a href="#h0-1-4" id="h0-1-4" class="i">+    /// independent of the versioned key &quot;foo@7&quot;. These are mostly used
</a><a href="#h0-1-5" id="h0-1-5" class="i">+    /// for metadata.
</a>     Unversioned(
         #[serde(with = &quot;serde_bytes&quot;)]
         #[serde(borrow)]
<a href="#h0-2" id="h0-2" class="h">@@ -80,9 +222,16 @@ impl&lt;&#39;a&gt; KeyPrefix&lt;&#39;a&gt; {
</a>     }
 }
 
<a href="#h0-2-3" id="h0-2-3" class="d">-/// An MVCC-based transactional key-value engine.
</a><a href="#h0-2-4" id="h0-2-4" class="i">+/// An MVCC-based transactional key-value engine. It wraps an underlying storage
</a><a href="#h0-2-5" id="h0-2-5" class="i">+/// engine that&#39;s used for raw key/value storage.
</a><a href="#h0-2-6" id="h0-2-6" class="i">+///
</a><a href="#h0-2-7" id="h0-2-7" class="i">+/// While it supports any number of concurrent transactions, individual read or
</a><a href="#h0-2-8" id="h0-2-8" class="i">+/// write operations are executed sequentially, serialized via a mutex. There
</a><a href="#h0-2-9" id="h0-2-9" class="i">+/// are two reasons for this: the storage engine itself is not thread-safe,
</a><a href="#h0-2-10" id="h0-2-10" class="i">+/// requiring serialized access, and the Raft state machine that manages the
</a><a href="#h0-2-11" id="h0-2-11" class="i">+/// MVCC engine applies commands one at a time from the Raft log, which will
</a><a href="#h0-2-12" id="h0-2-12" class="i">+/// serialize them anyway.
</a> pub struct MVCC&lt;E: Engine&gt; {
<a href="#h0-2-14" id="h0-2-14" class="d">-    /// The underlying KV engine. It is protected by a mutex so it can be shared between txns.
</a>     engine: Arc&lt;Mutex&lt;E&gt;&gt;,
 }
 
<a href="#h0-3" id="h0-3" class="h">@@ -155,7 +304,7 @@ pub struct Status {
</a> 
 /// An MVCC transaction.
 pub struct Transaction&lt;E: Engine&gt; {
<a href="#h0-3-3" id="h0-3-3" class="d">-    /// The underlying engine for the transaction. Shared between transactions using a mutex.
</a><a href="#h0-3-4" id="h0-3-4" class="i">+    /// The underlying engine, shared by all transactions.
</a>     engine: Arc&lt;Mutex&lt;E&gt;&gt;,
     /// The transaction state.
     st: TransactionState,
<a href="#h0-4" id="h0-4" class="h">@@ -165,7 +314,7 @@ pub struct Transaction&lt;E: Engine&gt; {
</a> /// is separate from Transaction to allow it to be passed around independently
 /// of the engine. There are two main motivations for this:
 ///
<a href="#h0-4-3" id="h0-4-3" class="d">-/// - It can be exported via Transaction.state(), (de)serialied, and later used
</a><a href="#h0-4-4" id="h0-4-4" class="i">+/// - It can be exported via Transaction.state(), (de)serialized, and later used
</a> ///   to instantiate a new functionally equivalent Transaction via
 ///   Transaction::resume(). This allows passing the transaction between the
 ///   storage engine and SQL engine (potentially running on a different node)
<a href="#h0-5" id="h0-5" class="h">@@ -190,6 +339,17 @@ pub struct TransactionState {
</a> 
 impl TransactionState {
     /// Checks whether the given version is visible to this transaction.
<a href="#h0-5-3" id="h0-5-3" class="i">+    ///
</a><a href="#h0-5-4" id="h0-5-4" class="i">+    /// Future versions, and versions belonging to active transactions as of
</a><a href="#h0-5-5" id="h0-5-5" class="i">+    /// the start of this transaction, are never isible.
</a><a href="#h0-5-6" id="h0-5-6" class="i">+    ///
</a><a href="#h0-5-7" id="h0-5-7" class="i">+    /// Read-write transactions see their own writes at their version.
</a><a href="#h0-5-8" id="h0-5-8" class="i">+    ///
</a><a href="#h0-5-9" id="h0-5-9" class="i">+    /// Read-only queries only see versions below the transaction&#39;s version,
</a><a href="#h0-5-10" id="h0-5-10" class="i">+    /// excluding the version itself. This is to ensure time-travel queries see
</a><a href="#h0-5-11" id="h0-5-11" class="i">+    /// a consistent version both before and after any active transaction at
</a><a href="#h0-5-12" id="h0-5-12" class="i">+    /// that version commits its writes. See the module documentation for
</a><a href="#h0-5-13" id="h0-5-13" class="i">+    /// details.
</a>     fn is_visible(&amp;self, version: Version) -&gt; bool {
         if self.active.get(&amp;version).is_some() {
             false
</pre>
</div>
</body>
</html>
