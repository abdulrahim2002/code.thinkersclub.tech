<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>storage: move `Debug` engine to `engine::test::Emit` - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/e1e228b77bd4b4849db378ed4b7eff0ee984967b.html">e1e228b77bd4b4849db378ed4b7eff0ee984967b</a>
<b>parent</b> <a href="../commit/a637d77804f05e40e8312232f0734b14e669add1.html">a637d77804f05e40e8312232f0734b14e669add1</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Mon, 10 Jun 2024 23:52:10 +0200

storage: move `Debug` engine to `engine::test::Emit`

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/log.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">+++++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/storage/debug.rs</a></td><td> | </td><td class="num">83</td><td><span class="i">+++</span><span class="d">----------------------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/storage/engine.rs</a></td><td> | </td><td class="num">76</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/storage/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i"></span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/storage/mvcc.rs</a></td><td> | </td><td class="num">53</td><td><span class="i">+++++++++++++++++++++++++++++++</span><span class="d">----------------------</span></td></tr>
</table></pre><pre>5 files changed, 119 insertions(+), 110 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -343,6 +343,7 @@ mod tests {
</a>     use super::*;
     use crossbeam::channel::Receiver;
     use std::{error::Error, result::Result};
<a href="#h0-0-3" id="h0-0-3" class="i">+    use storage::engine::test as testengine;
</a>     use test_each_file::test_each_path;
 
     // Run goldenscript tests in src/raft/testscripts/log.
<a href="#h0-1" id="h0-1" class="h">@@ -355,7 +356,7 @@ mod tests {
</a>     /// Runs Raft log goldenscript tests. For available commands, see run().
     struct TestRunner {
         log: Log,
<a href="#h0-1-3" id="h0-1-3" class="d">-        op_rx: Receiver&lt;storage::debug::Operation&gt;,
</a><a href="#h0-1-4" id="h0-1-4" class="i">+        op_rx: Receiver&lt;testengine::Operation&gt;,
</a>     }
 
     impl goldenscript::Runner for TestRunner {
<a href="#h0-2" id="h0-2" class="h">@@ -535,8 +536,8 @@ mod tests {
</a> 
     impl TestRunner {
         fn new() -&gt; Self {
<a href="#h0-2-3" id="h0-2-3" class="d">-            let engine = storage::Debug::new(storage::Memory::new());
</a><a href="#h0-2-4" id="h0-2-4" class="d">-            let op_rx = engine.op_rx();
</a><a href="#h0-2-5" id="h0-2-5" class="i">+            let (op_tx, op_rx) = crossbeam::channel::unbounded();
</a><a href="#h0-2-6" id="h0-2-6" class="i">+            let engine = testengine::Emit::new(storage::Memory::new(), op_tx);
</a>             let log = Log::new(Box::new(engine)).expect(&quot;log init failed&quot;);
             Self { log, op_rx }
         }
<a href="#h0-3" id="h0-3" class="h">@@ -566,11 +567,13 @@ mod tests {
</a>                 return;
             }
             while let Ok(op) = self.op_rx.try_recv() {
<a href="#h0-3-3" id="h0-3-3" class="d">-                use storage::debug::Operation;
</a><a href="#h0-3-4" id="h0-3-4" class="i">+                use testengine::Operation;
</a>                 let s = match op {
<a href="#h0-3-6" id="h0-3-6" class="d">-                    Operation::Delete(k) =&gt; format!(&quot;delete {}&quot;, Self::format_key(&amp;k)),
</a><a href="#h0-3-7" id="h0-3-7" class="i">+                    Operation::Delete { key } =&gt; format!(&quot;delete {}&quot;, Self::format_key(&amp;key)),
</a>                     Operation::Flush =&gt; &quot;flush&quot;.to_string(),
<a href="#h0-3-9" id="h0-3-9" class="d">-                    Operation::Set(k, v) =&gt; format!(&quot;set {}&quot;, Self::format_key_value(&amp;k, &amp;v)),
</a><a href="#h0-3-10" id="h0-3-10" class="i">+                    Operation::Set { key, value } =&gt; {
</a><a href="#h0-3-11" id="h0-3-11" class="i">+                        format!(&quot;set {}&quot;, Self::format_key_value(&amp;key, &amp;value))
</a><a href="#h0-3-12" id="h0-3-12" class="i">+                    }
</a>                 };
                 output.push_str(&amp;format!(&quot;engine: {s}\n&quot;));
             }
<b>diff --git a/<a id="h1" href="../file/src/storage/debug.rs.html">src/storage/debug.rs</a> b/<a href="../file/src/storage/debug.rs.html">src/storage/debug.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,13 +1,11 @@
</a> //! Storage debug helpers, primarily formatting of raw engine data.
 
<a href="#h1-0-2" id="h1-0-2" class="d">-use std::collections::HashSet;
</a><a href="#h1-0-3" id="h1-0-3" class="d">-
</a><a href="#h1-0-4" id="h1-0-4" class="d">-use crossbeam::channel::{Receiver, Sender};
</a><a href="#h1-0-5" id="h1-0-5" class="i">+// TODO: consider moving these elsewhere.
</a> 
<a href="#h1-0-7" id="h1-0-7" class="d">-use super::engine::{self, ScanIterator, Status};
</a> use super::mvcc::{self, TransactionState};
 use crate::encoding::{bincode, Key as _};
<a href="#h1-0-10" id="h1-0-10" class="d">-use crate::error::Result;
</a><a href="#h1-0-11" id="h1-0-11" class="i">+
</a><a href="#h1-0-12" id="h1-0-12" class="i">+use std::collections::HashSet;
</a> 
 /// Formats a raw byte string, either as a UTF-8 string (if valid and
 /// printable), otherwise hex-encoded.
<a href="#h1-1" id="h1-1" class="h">@@ -92,78 +90,3 @@ pub fn format_key_value(key: &amp;[u8], value: &amp;Option&lt;Vec&lt;u8&gt;&gt;) -&gt; (String, Option&lt;
</a> 
     (fkey, fvalue)
 }
<a href="#h1-1-3" id="h1-1-3" class="d">-
</a><a href="#h1-1-4" id="h1-1-4" class="d">-/// A debug storage engine, which wraps another engine and emits events.
</a><a href="#h1-1-5" id="h1-1-5" class="d">-pub struct Engine&lt;E: engine::Engine&gt; {
</a><a href="#h1-1-6" id="h1-1-6" class="d">-    /// The wrapped engine.
</a><a href="#h1-1-7" id="h1-1-7" class="d">-    inner: E,
</a><a href="#h1-1-8" id="h1-1-8" class="d">-    /// Sends engine operations.
</a><a href="#h1-1-9" id="h1-1-9" class="d">-    op_tx: Sender&lt;Operation&gt;,
</a><a href="#h1-1-10" id="h1-1-10" class="d">-    /// Receives engine operations.
</a><a href="#h1-1-11" id="h1-1-11" class="d">-    op_rx: Receiver&lt;Operation&gt;,
</a><a href="#h1-1-12" id="h1-1-12" class="d">-}
</a><a href="#h1-1-13" id="h1-1-13" class="d">-
</a><a href="#h1-1-14" id="h1-1-14" class="d">-impl&lt;E: engine::Engine&gt; std::fmt::Display for Engine&lt;E&gt; {
</a><a href="#h1-1-15" id="h1-1-15" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h1-1-16" id="h1-1-16" class="d">-        write!(f, &quot;debug:{}&quot;, self.inner)
</a><a href="#h1-1-17" id="h1-1-17" class="d">-    }
</a><a href="#h1-1-18" id="h1-1-18" class="d">-}
</a><a href="#h1-1-19" id="h1-1-19" class="d">-
</a><a href="#h1-1-20" id="h1-1-20" class="d">-impl&lt;E: engine::Engine&gt; Engine&lt;E&gt; {
</a><a href="#h1-1-21" id="h1-1-21" class="d">-    pub fn new(inner: E) -&gt; Self {
</a><a href="#h1-1-22" id="h1-1-22" class="d">-        let (op_tx, op_rx) = crossbeam::channel::unbounded();
</a><a href="#h1-1-23" id="h1-1-23" class="d">-        Self { inner, op_tx, op_rx }
</a><a href="#h1-1-24" id="h1-1-24" class="d">-    }
</a><a href="#h1-1-25" id="h1-1-25" class="d">-
</a><a href="#h1-1-26" id="h1-1-26" class="d">-    pub fn op_rx(&amp;self) -&gt; Receiver&lt;Operation&gt; {
</a><a href="#h1-1-27" id="h1-1-27" class="d">-        self.op_rx.clone()
</a><a href="#h1-1-28" id="h1-1-28" class="d">-    }
</a><a href="#h1-1-29" id="h1-1-29" class="d">-}
</a><a href="#h1-1-30" id="h1-1-30" class="d">-
</a><a href="#h1-1-31" id="h1-1-31" class="d">-impl&lt;E: engine::Engine&gt; engine::Engine for Engine&lt;E&gt; {
</a><a href="#h1-1-32" id="h1-1-32" class="d">-    type ScanIterator&lt;&#39;a&gt; = E::ScanIterator&lt;&#39;a&gt; where E: &#39;a;
</a><a href="#h1-1-33" id="h1-1-33" class="d">-
</a><a href="#h1-1-34" id="h1-1-34" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h1-1-35" id="h1-1-35" class="d">-        self.inner.flush()?;
</a><a href="#h1-1-36" id="h1-1-36" class="d">-        self.op_tx.send(Operation::Flush)?;
</a><a href="#h1-1-37" id="h1-1-37" class="d">-        Ok(())
</a><a href="#h1-1-38" id="h1-1-38" class="d">-    }
</a><a href="#h1-1-39" id="h1-1-39" class="d">-
</a><a href="#h1-1-40" id="h1-1-40" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h1-1-41" id="h1-1-41" class="d">-        self.inner.delete(key)?;
</a><a href="#h1-1-42" id="h1-1-42" class="d">-        self.op_tx.send(Operation::Delete(key.to_vec()))?;
</a><a href="#h1-1-43" id="h1-1-43" class="d">-        Ok(())
</a><a href="#h1-1-44" id="h1-1-44" class="d">-    }
</a><a href="#h1-1-45" id="h1-1-45" class="d">-
</a><a href="#h1-1-46" id="h1-1-46" class="d">-    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h1-1-47" id="h1-1-47" class="d">-        self.inner.get(key)
</a><a href="#h1-1-48" id="h1-1-48" class="d">-    }
</a><a href="#h1-1-49" id="h1-1-49" class="d">-
</a><a href="#h1-1-50" id="h1-1-50" class="d">-    fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h1-1-51" id="h1-1-51" class="d">-        self.inner.scan(range)
</a><a href="#h1-1-52" id="h1-1-52" class="d">-    }
</a><a href="#h1-1-53" id="h1-1-53" class="d">-
</a><a href="#h1-1-54" id="h1-1-54" class="d">-    fn scan_dyn(
</a><a href="#h1-1-55" id="h1-1-55" class="d">-        &amp;mut self,
</a><a href="#h1-1-56" id="h1-1-56" class="d">-        range: (std::ops::Bound&lt;Vec&lt;u8&gt;&gt;, std::ops::Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h1-1-57" id="h1-1-57" class="d">-    ) -&gt; Box&lt;dyn ScanIterator + &#39;_&gt; {
</a><a href="#h1-1-58" id="h1-1-58" class="d">-        Box::new(self.scan(range))
</a><a href="#h1-1-59" id="h1-1-59" class="d">-    }
</a><a href="#h1-1-60" id="h1-1-60" class="d">-
</a><a href="#h1-1-61" id="h1-1-61" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h1-1-62" id="h1-1-62" class="d">-        self.inner.set(key, value.clone())?;
</a><a href="#h1-1-63" id="h1-1-63" class="d">-        self.op_tx.send(Operation::Set(key.to_vec(), value))?;
</a><a href="#h1-1-64" id="h1-1-64" class="d">-        Ok(())
</a><a href="#h1-1-65" id="h1-1-65" class="d">-    }
</a><a href="#h1-1-66" id="h1-1-66" class="d">-
</a><a href="#h1-1-67" id="h1-1-67" class="d">-    fn status(&amp;mut self) -&gt; Result&lt;Status&gt; {
</a><a href="#h1-1-68" id="h1-1-68" class="d">-        self.inner.status()
</a><a href="#h1-1-69" id="h1-1-69" class="d">-    }
</a><a href="#h1-1-70" id="h1-1-70" class="d">-}
</a><a href="#h1-1-71" id="h1-1-71" class="d">-
</a><a href="#h1-1-72" id="h1-1-72" class="d">-/// An engine operation, emitted by the debug engine.
</a><a href="#h1-1-73" id="h1-1-73" class="d">-pub enum Operation {
</a><a href="#h1-1-74" id="h1-1-74" class="d">-    Delete(Vec&lt;u8&gt;),
</a><a href="#h1-1-75" id="h1-1-75" class="d">-    Flush,
</a><a href="#h1-1-76" id="h1-1-76" class="d">-    Set(Vec&lt;u8&gt;, Vec&lt;u8&gt;),
</a><a href="#h1-1-77" id="h1-1-77" class="d">-}
</a><b>diff --git a/<a id="h2" href="../file/src/storage/engine.rs.html">src/storage/engine.rs</a> b/<a href="../file/src/storage/engine.rs.html">src/storage/engine.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -81,6 +81,82 @@ pub struct Status {
</a> }
 
 #[cfg(test)]
<a href="#h2-0-3" id="h2-0-3" class="i">+/// Test helper engines.
</a><a href="#h2-0-4" id="h2-0-4" class="i">+pub mod test {
</a><a href="#h2-0-5" id="h2-0-5" class="i">+    use super::*;
</a><a href="#h2-0-6" id="h2-0-6" class="i">+    use crossbeam::channel::Sender;
</a><a href="#h2-0-7" id="h2-0-7" class="i">+
</a><a href="#h2-0-8" id="h2-0-8" class="i">+    /// Wraps another engine and emits write events to the given channel.
</a><a href="#h2-0-9" id="h2-0-9" class="i">+    pub struct Emit&lt;E: Engine&gt; {
</a><a href="#h2-0-10" id="h2-0-10" class="i">+        /// The wrapped engine.
</a><a href="#h2-0-11" id="h2-0-11" class="i">+        inner: E,
</a><a href="#h2-0-12" id="h2-0-12" class="i">+        /// Sends operation events.
</a><a href="#h2-0-13" id="h2-0-13" class="i">+        tx: Sender&lt;Operation&gt;,
</a><a href="#h2-0-14" id="h2-0-14" class="i">+    }
</a><a href="#h2-0-15" id="h2-0-15" class="i">+
</a><a href="#h2-0-16" id="h2-0-16" class="i">+    /// An engine operation emitted by the Emit engine.
</a><a href="#h2-0-17" id="h2-0-17" class="i">+    pub enum Operation {
</a><a href="#h2-0-18" id="h2-0-18" class="i">+        Delete { key: Vec&lt;u8&gt; },
</a><a href="#h2-0-19" id="h2-0-19" class="i">+        Flush,
</a><a href="#h2-0-20" id="h2-0-20" class="i">+        Set { key: Vec&lt;u8&gt;, value: Vec&lt;u8&gt; },
</a><a href="#h2-0-21" id="h2-0-21" class="i">+    }
</a><a href="#h2-0-22" id="h2-0-22" class="i">+
</a><a href="#h2-0-23" id="h2-0-23" class="i">+    impl&lt;E: Engine&gt; std::fmt::Display for Emit&lt;E&gt; {
</a><a href="#h2-0-24" id="h2-0-24" class="i">+        fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h2-0-25" id="h2-0-25" class="i">+            // Just dispatch to the inner engine.
</a><a href="#h2-0-26" id="h2-0-26" class="i">+            self.inner.fmt(f)
</a><a href="#h2-0-27" id="h2-0-27" class="i">+        }
</a><a href="#h2-0-28" id="h2-0-28" class="i">+    }
</a><a href="#h2-0-29" id="h2-0-29" class="i">+
</a><a href="#h2-0-30" id="h2-0-30" class="i">+    impl&lt;E: Engine&gt; Emit&lt;E&gt; {
</a><a href="#h2-0-31" id="h2-0-31" class="i">+        pub fn new(inner: E, tx: Sender&lt;Operation&gt;) -&gt; Self {
</a><a href="#h2-0-32" id="h2-0-32" class="i">+            Self { inner, tx }
</a><a href="#h2-0-33" id="h2-0-33" class="i">+        }
</a><a href="#h2-0-34" id="h2-0-34" class="i">+    }
</a><a href="#h2-0-35" id="h2-0-35" class="i">+
</a><a href="#h2-0-36" id="h2-0-36" class="i">+    impl&lt;E: Engine&gt; Engine for Emit&lt;E&gt; {
</a><a href="#h2-0-37" id="h2-0-37" class="i">+        type ScanIterator&lt;&#39;a&gt; = E::ScanIterator&lt;&#39;a&gt; where E: &#39;a;
</a><a href="#h2-0-38" id="h2-0-38" class="i">+
</a><a href="#h2-0-39" id="h2-0-39" class="i">+        fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-40" id="h2-0-40" class="i">+            self.inner.flush()?;
</a><a href="#h2-0-41" id="h2-0-41" class="i">+            self.tx.send(Operation::Flush)?;
</a><a href="#h2-0-42" id="h2-0-42" class="i">+            Ok(())
</a><a href="#h2-0-43" id="h2-0-43" class="i">+        }
</a><a href="#h2-0-44" id="h2-0-44" class="i">+
</a><a href="#h2-0-45" id="h2-0-45" class="i">+        fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-46" id="h2-0-46" class="i">+            self.inner.delete(key)?;
</a><a href="#h2-0-47" id="h2-0-47" class="i">+            self.tx.send(Operation::Delete { key: key.to_vec() })?;
</a><a href="#h2-0-48" id="h2-0-48" class="i">+            Ok(())
</a><a href="#h2-0-49" id="h2-0-49" class="i">+        }
</a><a href="#h2-0-50" id="h2-0-50" class="i">+
</a><a href="#h2-0-51" id="h2-0-51" class="i">+        fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h2-0-52" id="h2-0-52" class="i">+            self.inner.get(key)
</a><a href="#h2-0-53" id="h2-0-53" class="i">+        }
</a><a href="#h2-0-54" id="h2-0-54" class="i">+
</a><a href="#h2-0-55" id="h2-0-55" class="i">+        fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h2-0-56" id="h2-0-56" class="i">+            self.inner.scan(range)
</a><a href="#h2-0-57" id="h2-0-57" class="i">+        }
</a><a href="#h2-0-58" id="h2-0-58" class="i">+
</a><a href="#h2-0-59" id="h2-0-59" class="i">+        fn scan_dyn(
</a><a href="#h2-0-60" id="h2-0-60" class="i">+            &amp;mut self,
</a><a href="#h2-0-61" id="h2-0-61" class="i">+            range: (std::ops::Bound&lt;Vec&lt;u8&gt;&gt;, std::ops::Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h2-0-62" id="h2-0-62" class="i">+        ) -&gt; Box&lt;dyn ScanIterator + &#39;_&gt; {
</a><a href="#h2-0-63" id="h2-0-63" class="i">+            Box::new(self.scan(range))
</a><a href="#h2-0-64" id="h2-0-64" class="i">+        }
</a><a href="#h2-0-65" id="h2-0-65" class="i">+
</a><a href="#h2-0-66" id="h2-0-66" class="i">+        fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-67" id="h2-0-67" class="i">+            self.inner.set(key, value.clone())?;
</a><a href="#h2-0-68" id="h2-0-68" class="i">+            self.tx.send(Operation::Set { key: key.to_vec(), value })?;
</a><a href="#h2-0-69" id="h2-0-69" class="i">+            Ok(())
</a><a href="#h2-0-70" id="h2-0-70" class="i">+        }
</a><a href="#h2-0-71" id="h2-0-71" class="i">+
</a><a href="#h2-0-72" id="h2-0-72" class="i">+        fn status(&amp;mut self) -&gt; Result&lt;Status&gt; {
</a><a href="#h2-0-73" id="h2-0-73" class="i">+            self.inner.status()
</a><a href="#h2-0-74" id="h2-0-74" class="i">+        }
</a><a href="#h2-0-75" id="h2-0-75" class="i">+    }
</a><a href="#h2-0-76" id="h2-0-76" class="i">+}
</a><a href="#h2-0-77" id="h2-0-77" class="i">+
</a><a href="#h2-0-78" id="h2-0-78" class="i">+#[cfg(test)]
</a> pub(crate) mod tests {
     /// Generates common tests for any Engine implementation.
     macro_rules! test_engine {
<b>diff --git a/<a id="h3" href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a> b/<a href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -5,7 +5,5 @@ mod memory;
</a> pub mod mvcc;
 
 pub use bitcask::BitCask;
<a href="#h3-0-3" id="h3-0-3" class="d">-#[cfg(test)]
</a><a href="#h3-0-4" id="h3-0-4" class="d">-pub use debug::Engine as Debug;
</a> pub use engine::{Engine, ScanIterator, Status};
 pub use memory::Memory;
<b>diff --git a/<a id="h4" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -784,8 +784,10 @@ impl&lt;&#39;a, E: Engine&gt; DoubleEndedIterator for VersionIterator&lt;&#39;a, E&gt; {
</a> #[cfg(test)]
 pub mod tests {
     use super::super::debug;
<a href="#h4-0-3" id="h4-0-3" class="d">-    use super::super::{Debug, Memory};
</a><a href="#h4-0-4" id="h4-0-4" class="i">+    use super::super::engine::test::{self as testengine, Emit};
</a><a href="#h4-0-5" id="h4-0-5" class="i">+    use super::super::Memory;
</a>     use super::*;
<a href="#h4-0-7" id="h4-0-7" class="i">+    use crossbeam::channel::Receiver;
</a>     use std::collections::HashMap;
     use std::io::Write as _;
 
<a href="#h4-1" id="h4-1" class="h">@@ -794,7 +796,8 @@ pub mod tests {
</a>     /// An MVCC wrapper that records transaction schedules to golden masters.
     /// TODO: migrate this to goldenscript.
     struct Schedule {
<a href="#h4-1-3" id="h4-1-3" class="d">-        mvcc: MVCC&lt;Debug&lt;Memory&gt;&gt;,
</a><a href="#h4-1-4" id="h4-1-4" class="i">+        mvcc: MVCC&lt;Emit&lt;Memory&gt;&gt;,
</a><a href="#h4-1-5" id="h4-1-5" class="i">+        op_rx: Receiver&lt;testengine::Operation&gt;,
</a>         mint: goldenfile::Mint,
         file: Arc&lt;Mutex&lt;std::fs::File&gt;&gt;,
         next_id: u8,
<a href="#h4-2" id="h4-2" class="h">@@ -803,10 +806,11 @@ pub mod tests {
</a>     impl Schedule {
         /// Creates a new schedule using the given golden master filename.
         fn new(name: &amp;str) -&gt; Result&lt;Self&gt; {
<a href="#h4-2-3" id="h4-2-3" class="d">-            let mvcc = MVCC::new(Debug::new(Memory::new()));
</a><a href="#h4-2-4" id="h4-2-4" class="i">+            let (op_tx, op_rx) = crossbeam::channel::unbounded();
</a><a href="#h4-2-5" id="h4-2-5" class="i">+            let mvcc = MVCC::new(Emit::new(Memory::new(), op_tx));
</a>             let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
             let file = Arc::new(Mutex::new(mint.new_goldenfile(name)?));
<a href="#h4-2-8" id="h4-2-8" class="d">-            Ok(Self { mvcc, mint, file, next_id: 1 })
</a><a href="#h4-2-9" id="h4-2-9" class="i">+            Ok(Self { mvcc, op_rx, mint, file, next_id: 1 })
</a>         }
 
         /// Sets up an initial, versioned dataset from the given data as a
<a href="#h4-3" id="h4-3" class="h">@@ -836,7 +840,7 @@ pub mod tests {
</a>                 txn.commit()?;
             }
             // Flush the write log, but dump the engine contents.
<a href="#h4-3-3" id="h4-3-3" class="d">-            while self.mvcc.engine.lock()?.op_rx().try_recv().is_ok() {}
</a><a href="#h4-3-4" id="h4-3-4" class="i">+            while self.op_rx.try_recv().is_ok() {}
</a>             self.print_engine()?;
             writeln!(&amp;mut self.file.lock()?)?;
             Ok(())
<a href="#h4-4" id="h4-4" class="h">@@ -862,12 +866,17 @@ pub mod tests {
</a>         fn new_txn(
             &amp;mut self,
             name: &amp;str,
<a href="#h4-4-3" id="h4-4-3" class="d">-            result: Result&lt;Transaction&lt;Debug&lt;Memory&gt;&gt;&gt;,
</a><a href="#h4-4-4" id="h4-4-4" class="i">+            result: Result&lt;Transaction&lt;Emit&lt;Memory&gt;&gt;&gt;,
</a>         ) -&gt; Result&lt;ScheduleTransaction&gt; {
             let id = self.next_id;
             self.next_id += 1;
             self.print_begin(id, name, &amp;result)?;
<a href="#h4-4-9" id="h4-4-9" class="d">-            result.map(|txn| ScheduleTransaction { id, txn, file: self.file.clone() })
</a><a href="#h4-4-10" id="h4-4-10" class="i">+            result.map(|txn| ScheduleTransaction {
</a><a href="#h4-4-11" id="h4-4-11" class="i">+                id,
</a><a href="#h4-4-12" id="h4-4-12" class="i">+                txn,
</a><a href="#h4-4-13" id="h4-4-13" class="i">+                file: self.file.clone(),
</a><a href="#h4-4-14" id="h4-4-14" class="i">+                op_rx: self.op_rx.clone(),
</a><a href="#h4-4-15" id="h4-4-15" class="i">+            })
</a>         }
 
         /// Prints a transaction begin to the golden file.
<a href="#h4-5" id="h4-5" class="h">@@ -875,7 +884,7 @@ pub mod tests {
</a>             &amp;mut self,
             id: u8,
             name: &amp;str,
<a href="#h4-5-3" id="h4-5-3" class="d">-            result: &amp;Result&lt;Transaction&lt;Debug&lt;Memory&gt;&gt;&gt;,
</a><a href="#h4-5-4" id="h4-5-4" class="i">+            result: &amp;Result&lt;Transaction&lt;Emit&lt;Memory&gt;&gt;&gt;,
</a>         ) -&gt; Result&lt;()&gt; {
             let mut f = self.file.lock()?;
             write!(f, &quot;T{}: {} → &quot;, id, name)?;
<a href="#h4-6" id="h4-6" class="h">@@ -883,24 +892,23 @@ pub mod tests {
</a>                 Ok(txn) =&gt; writeln!(f, &quot;{}&quot;, debug::format_txn(txn.state()))?,
                 Err(err) =&gt; writeln!(f, &quot;Error::{:?}&quot;, err)?,
             };
<a href="#h4-6-3" id="h4-6-3" class="d">-            Self::print_log(&amp;mut f, &amp;mut self.mvcc.engine.lock()?)?;
</a><a href="#h4-6-4" id="h4-6-4" class="i">+            Self::print_log(&amp;mut f, &amp;self.op_rx)?;
</a>             writeln!(f)?;
             Ok(())
         }
<a href="#h4-6-8" id="h4-6-8" class="d">-
</a>         /// Prints the engine write log since the last call to the golden file.
         fn print_log(
             f: &amp;mut MutexGuard&lt;&#39;_, std::fs::File&gt;,
<a href="#h4-6-12" id="h4-6-12" class="d">-            engine: &amp;mut MutexGuard&lt;&#39;_, Debug&lt;Memory&gt;&gt;,
</a><a href="#h4-6-13" id="h4-6-13" class="i">+            op_rx: &amp;Receiver&lt;testengine::Operation&gt;,
</a>         ) -&gt; Result&lt;()&gt; {
<a href="#h4-6-15" id="h4-6-15" class="d">-            while let Ok(op) = engine.op_rx().try_recv() {
</a><a href="#h4-6-16" id="h4-6-16" class="i">+            while let Ok(op) = op_rx.try_recv() {
</a>                 match op {
<a href="#h4-6-18" id="h4-6-18" class="d">-                    debug::Operation::Delete(key) =&gt; {
</a><a href="#h4-6-19" id="h4-6-19" class="i">+                    testengine::Operation::Delete { key } =&gt; {
</a>                         let (fkey, _) = debug::format_key_value(&amp;key, &amp;None);
                         writeln!(f, &quot;    del {fkey}&quot;)
                     }
<a href="#h4-6-23" id="h4-6-23" class="d">-                    debug::Operation::Flush =&gt; writeln!(f, &quot;    flush&quot;),
</a><a href="#h4-6-24" id="h4-6-24" class="d">-                    debug::Operation::Set(key, value) =&gt; {
</a><a href="#h4-6-25" id="h4-6-25" class="i">+                    testengine::Operation::Flush =&gt; writeln!(f, &quot;    flush&quot;),
</a><a href="#h4-6-26" id="h4-6-26" class="i">+                    testengine::Operation::Set { key, value } =&gt; {
</a>                         let (fkey, fvalue) = debug::format_key_value(&amp;key, &amp;Some(value));
                         writeln!(f, &quot;    set {} = {}&quot;, fkey, fvalue.unwrap())
                     }
<a href="#h4-7" id="h4-7" class="h">@@ -951,7 +959,7 @@ pub mod tests {
</a>                 Ok(_) =&gt; writeln!(f)?,
                 Err(err) =&gt; writeln!(f, &quot; → Error::{:?}&quot;, err)?,
             }
<a href="#h4-7-3" id="h4-7-3" class="d">-            Schedule::print_log(&amp;mut f, &amp;mut self.mvcc.engine.lock()?)?;
</a><a href="#h4-7-4" id="h4-7-4" class="i">+            Schedule::print_log(&amp;mut f, &amp;self.op_rx)?;
</a>             writeln!(f)?;
             result
         }
<a href="#h4-8" id="h4-8" class="h">@@ -967,8 +975,9 @@ pub mod tests {
</a> 
     struct ScheduleTransaction {
         id: u8,
<a href="#h4-8-3" id="h4-8-3" class="d">-        txn: Transaction&lt;Debug&lt;Memory&gt;&gt;,
</a><a href="#h4-8-4" id="h4-8-4" class="i">+        txn: Transaction&lt;Emit&lt;Memory&gt;&gt;,
</a>         file: Arc&lt;Mutex&lt;std::fs::File&gt;&gt;,
<a href="#h4-8-6" id="h4-8-6" class="i">+        op_rx: Receiver&lt;testengine::Operation&gt;,
</a>     }
 
     impl Clone for ScheduleTransaction {
<a href="#h4-9" id="h4-9" class="h">@@ -977,7 +986,7 @@ pub mod tests {
</a>         /// since a commit/rollback will invalidate the cloned transactions.
         fn clone(&amp;self) -&gt; Self {
             let txn = Transaction { engine: self.txn.engine.clone(), st: self.txn.st.clone() };
<a href="#h4-9-3" id="h4-9-3" class="d">-            Self { id: self.id, txn, file: self.file.clone() }
</a><a href="#h4-9-4" id="h4-9-4" class="i">+            Self { id: self.id, op_rx: self.op_rx.clone(), txn, file: self.file.clone() }
</a>         }
     }
 
<a href="#h4-10" id="h4-10" class="h">@@ -1029,7 +1038,7 @@ pub mod tests {
</a>             Ok(value)
         }
 
<a href="#h4-10-3" id="h4-10-3" class="d">-        fn scan&lt;R: RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;self, range: R) -&gt; Result&lt;Scan&lt;Debug&lt;Memory&gt;&gt;&gt; {
</a><a href="#h4-10-4" id="h4-10-4" class="i">+        fn scan&lt;R: RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;self, range: R) -&gt; Result&lt;Scan&lt;Emit&lt;Memory&gt;&gt;&gt; {
</a>             let name = format!(
                 &quot;scan {}..{}&quot;,
                 match range.start_bound() {
<a href="#h4-11" id="h4-11" class="h">@@ -1048,7 +1057,7 @@ pub mod tests {
</a>             Ok(scan)
         }
 
<a href="#h4-11-3" id="h4-11-3" class="d">-        fn scan_prefix(&amp;self, prefix: &amp;[u8]) -&gt; Result&lt;Scan&lt;Debug&lt;Memory&gt;&gt;&gt; {
</a><a href="#h4-11-4" id="h4-11-4" class="i">+        fn scan_prefix(&amp;self, prefix: &amp;[u8]) -&gt; Result&lt;Scan&lt;Emit&lt;Memory&gt;&gt;&gt; {
</a>             let mut scan = self.txn.scan_prefix(prefix)?;
             self.print_scan(&amp;format!(&quot;scan prefix {}&quot;, debug::format_raw(prefix)), scan.to_vec()?)?;
             Ok(scan)
<a href="#h4-12" id="h4-12" class="h">@@ -1062,7 +1071,7 @@ pub mod tests {
</a>                 Ok(_) =&gt; writeln!(f)?,
                 Err(err) =&gt; writeln!(f, &quot; → Error::{:?}&quot;, err)?,
             }
<a href="#h4-12-3" id="h4-12-3" class="d">-            Schedule::print_log(&amp;mut f, &amp;mut self.txn.engine.lock()?)?;
</a><a href="#h4-12-4" id="h4-12-4" class="i">+            Schedule::print_log(&amp;mut f, &amp;self.op_rx)?;
</a>             writeln!(f)?;
             Ok(())
         }
<a href="#h4-13" id="h4-13" class="h">@@ -1092,7 +1101,7 @@ pub mod tests {
</a> 
     // Asserts scan invariants.
     #[track_caller]
<a href="#h4-13-3" id="h4-13-3" class="d">-    fn assert_scan_invariants(scan: &amp;mut Scan&lt;Debug&lt;Memory&gt;&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h4-13-4" id="h4-13-4" class="i">+    fn assert_scan_invariants(scan: &amp;mut Scan&lt;Emit&lt;Memory&gt;&gt;) -&gt; Result&lt;()&gt; {
</a>         // Iterator and vec should yield same results.
         let result = scan.to_vec()?;
         assert_eq!(scan.iter().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?, result);
</pre>
</div>
</body>
</html>
