<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: clean up `Local` engine - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/d599d2a833e56688433f6fccf2db4fbceaec977c.html">d599d2a833e56688433f6fccf2db4fbceaec977c</a>
<b>parent</b> <a href="../commit/249fd65d06e38b91ae0f6f5315633fdefe15f065.html">249fd65d06e38b91ae0f6f5315633fdefe15f065</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue, 18 Jun 2024 21:24:12 +0200

sql: clean up `Local` engine

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">docs/sql.md</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/engine/local.rs</a></td><td> | </td><td class="num">383</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">--------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/types/schema.rs</a></td><td> | </td><td class="num">105</td><td><span class="i">+++++++++++++++++++++++++++++++</span><span class="d">------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/types/value.rs</a></td><td> | </td><td class="num">9</td><td><span class="i">+++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">tests/e2e/client.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">tests/sql/mutation/delete_where_float</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">tests/sql/mutation/delete_where_integer</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">tests/sql/mutation/delete_where_string</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">tests/sql/mutation/update_where_float</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">tests/sql/mutation/update_where_integer</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">tests/sql/mutation/update_where_string</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">tests/sql/query/where_float</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h13">tests/sql/query/where_integer</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h14">tests/sql/query/where_string</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h15">tests/sql/schema.rs</a></td><td> | </td><td class="num">4</td><td><span class="i"></span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h16">tests/sql/schema/delete_ref_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h17">tests/sql/schema/delete_ref_self_all</a></td><td> | </td><td class="num">9</td><td><span class="i">+</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h18">tests/sql/schema/delete_ref_self_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h19">tests/sql/schema/drop_table_ref_target</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h20">tests/sql/schema/insert_pk_boolean_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h21">tests/sql/schema/insert_pk_float_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h22">tests/sql/schema/insert_pk_float_infinity</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h23">tests/sql/schema/insert_pk_float_nan</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h24">tests/sql/schema/insert_pk_integer_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h25">tests/sql/schema/insert_pk_string_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h26">tests/sql/schema/insert_ref_boolean_missing</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h27">tests/sql/schema/insert_ref_float_missing</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h28">tests/sql/schema/insert_ref_integer_missing</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h29">tests/sql/schema/insert_ref_self_missing</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h30">tests/sql/schema/insert_ref_string_case</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h31">tests/sql/schema/insert_ref_string_missing</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="D">D</td><td><a href="#h32">tests/sql/schema/insert_string_1024</a></td><td> | </td><td class="num">12</td><td><span class="i"></span><span class="d">------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h33">tests/sql/schema/insert_string_1024_unicode</a></td><td> | </td><td class="num">12</td><td><span class="i"></span><span class="d">------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h34">tests/sql/schema/insert_string_1025</a></td><td> | </td><td class="num">11</td><td><span class="i"></span><span class="d">-----------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h35">tests/sql/schema/insert_string_1025_unicode</a></td><td> | </td><td class="num">11</td><td><span class="i"></span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h36">tests/sql/schema/insert_unique_boolean_duplicate</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h37">tests/sql/schema/insert_unique_float_duplicate</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h38">tests/sql/schema/insert_unique_integer_duplicate</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h39">tests/sql/schema/insert_unique_string_duplicate</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h40">tests/sql/schema/update_pk_float_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h41">tests/sql/schema/update_pk_float_conflict_all</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h42">tests/sql/schema/update_pk_integer_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h43">tests/sql/schema/update_pk_integer_conflict_all</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h44">tests/sql/schema/update_pk_string_conflict</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h45">tests/sql/schema/update_pk_string_conflict_all</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h46">tests/sql/schema/update_ref_pk</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h47">tests/sql/schema/update_ref_self_pk</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h48">tests/sql/schema/update_ref_source_missing</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h49">tests/sql/schema/update_unique_boolean_duplicate</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
</table></pre><pre>50 files changed, 320 insertions(+), 322 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/docs/sql.md.html">docs/sql.md</a> b/<a href="../file/docs/sql.md.html">docs/sql.md</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -7,7 +7,7 @@ The following data types are supported:
</a> * `BOOLEAN` (`BOOL`): logical truth values, i.e. true and false.
 * `FLOAT` (`DOUBLE`): 64-bit signed floating point numbers, using [IEEE 754 `binary64`](https://en.wikipedia.org/wiki/binary64) encoding. Supports magnitudes of 10⁻³⁰⁷ to 10³⁰⁸ with 53-bit precision (~15 significant figures), as well as the special values infinity and NaN.
 * `INTEGER` (`INT`): 64-bit signed integer numbers with a range of ±2⁶³-1.
<a href="#h0-0-3" id="h0-0-3" class="d">-* `STRING` (`CHAR`, `TEXT`, `VARCHAR`): UTF-8 encoded strings up to 1024 bytes.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+* `STRING` (`CHAR`, `TEXT`, `VARCHAR`): UTF-8 encoded strings.
</a> 
 In addition, the special `NULL` value is used for an unknown value, following the rules of [three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic).
 
<b>diff --git a/<a id="h1" href="../file/src/sql/engine/local.rs.html">src/sql/engine/local.rs</a> b/<a href="../file/src/sql/engine/local.rs.html">src/sql/engine/local.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,44 +1,45 @@
</a><a href="#h1-0-0" id="h1-0-0" class="d">-use super::super::types::schema::Table;
</a><a href="#h1-0-1" id="h1-0-1" class="d">-use super::super::types::{Expression, Row, Rows, Value};
</a><a href="#h1-0-2" id="h1-0-2" class="d">-use super::{Catalog, Transaction as _};
</a><a href="#h1-0-3" id="h1-0-3" class="i">+use super::Catalog;
</a> use crate::encoding::{self, Key as _, Value as _};
 use crate::error::Result;
<a href="#h1-0-6" id="h1-0-6" class="d">-use crate::storage;
</a><a href="#h1-0-7" id="h1-0-7" class="i">+use crate::sql::types::schema::Table;
</a><a href="#h1-0-8" id="h1-0-8" class="i">+use crate::sql::types::{Expression, Row, Rows, Value};
</a><a href="#h1-0-9" id="h1-0-9" class="i">+use crate::storage::{self, mvcc};
</a> use crate::{errdata, errinput};
 
 use serde::{Deserialize, Serialize};
 use std::borrow::Cow;
<a href="#h1-0-14" id="h1-0-14" class="d">-use std::clone::Clone;
</a> use std::collections::{HashMap, HashSet};
 
<a href="#h1-0-17" id="h1-0-17" class="d">-/// A SQL engine using a local storage engine.
</a><a href="#h1-0-18" id="h1-0-18" class="i">+/// A SQL engine using local storage. This provides the main SQL storage logic,
</a><a href="#h1-0-19" id="h1-0-19" class="i">+/// including with the Raft SQL engine which dispatches to this engine for
</a><a href="#h1-0-20" id="h1-0-20" class="i">+/// node-local SQL storage.
</a> pub struct Local&lt;E: storage::Engine&gt; {
<a href="#h1-0-22" id="h1-0-22" class="d">-    /// The underlying key/value store.
</a><a href="#h1-0-23" id="h1-0-23" class="d">-    pub(super) kv: storage::mvcc::MVCC&lt;E&gt;,
</a><a href="#h1-0-24" id="h1-0-24" class="i">+    /// The local MVCC storage engine.
</a><a href="#h1-0-25" id="h1-0-25" class="i">+    pub(super) mvcc: mvcc::MVCC&lt;E&gt;,
</a> }
 
 impl&lt;E: storage::Engine&gt; Local&lt;E&gt; {
<a href="#h1-0-29" id="h1-0-29" class="d">-    /// Creates a new key/value-based SQL engine
</a><a href="#h1-0-30" id="h1-0-30" class="i">+    /// Creates a new local SQL engine using the given storage engine.
</a>     pub fn new(engine: E) -&gt; Self {
<a href="#h1-0-32" id="h1-0-32" class="d">-        Self { kv: storage::mvcc::MVCC::new(engine) }
</a><a href="#h1-0-33" id="h1-0-33" class="i">+        Self { mvcc: mvcc::MVCC::new(engine) }
</a>     }
 
<a href="#h1-0-36" id="h1-0-36" class="d">-    /// Resumes a transaction from the given state
</a><a href="#h1-0-37" id="h1-0-37" class="d">-    pub fn resume(
</a><a href="#h1-0-38" id="h1-0-38" class="d">-        &amp;self,
</a><a href="#h1-0-39" id="h1-0-39" class="d">-        state: storage::mvcc::TransactionState,
</a><a href="#h1-0-40" id="h1-0-40" class="d">-    ) -&gt; Result&lt;&lt;Self as super::Engine&gt;::Transaction&gt; {
</a><a href="#h1-0-41" id="h1-0-41" class="d">-        Ok(&lt;Self as super::Engine&gt;::Transaction::new(self.kv.resume(state)?))
</a><a href="#h1-0-42" id="h1-0-42" class="i">+    /// Resumes a transaction from the given state. This is usually encapsulated
</a><a href="#h1-0-43" id="h1-0-43" class="i">+    /// in `mvcc::Transaction`, but the Raft-based engine can&#39;t retain the MVCC
</a><a href="#h1-0-44" id="h1-0-44" class="i">+    /// transaction between each request since it may be executed across
</a><a href="#h1-0-45" id="h1-0-45" class="i">+    /// multiple leader nodes, so it instead keeps the state in the session.
</a><a href="#h1-0-46" id="h1-0-46" class="i">+    pub fn resume(&amp;self, state: mvcc::TransactionState) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a><a href="#h1-0-47" id="h1-0-47" class="i">+        Ok(Transaction::new(self.mvcc.resume(state)?))
</a>     }
 
<a href="#h1-0-50" id="h1-0-50" class="d">-    /// Fetches an unversioned key.
</a><a href="#h1-0-51" id="h1-0-51" class="i">+    /// Fetches an unversioned key, or None if it doesn&#39;t exist.
</a>     pub fn get_unversioned(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
<a href="#h1-0-53" id="h1-0-53" class="d">-        self.kv.get_unversioned(key)
</a><a href="#h1-0-54" id="h1-0-54" class="i">+        self.mvcc.get_unversioned(key)
</a>     }
 
     /// Sets an unversioned key.
     pub fn set_unversioned(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
<a href="#h1-0-59" id="h1-0-59" class="d">-        self.kv.set_unversioned(key, value)
</a><a href="#h1-0-60" id="h1-0-60" class="i">+        self.mvcc.set_unversioned(key, value)
</a>     }
 }
 
<a href="#h1-1" id="h1-1" class="h">@@ -46,77 +47,94 @@ impl&lt;&#39;a, E: storage::Engine + &#39;a&gt; super::Engine&lt;&#39;a&gt; for Local&lt;E&gt; {
</a>     type Transaction = Transaction&lt;E&gt;;
 
     fn begin(&amp;self) -&gt; Result&lt;Self::Transaction&gt; {
<a href="#h1-1-3" id="h1-1-3" class="d">-        Ok(Self::Transaction::new(self.kv.begin()?))
</a><a href="#h1-1-4" id="h1-1-4" class="i">+        Ok(Self::Transaction::new(self.mvcc.begin()?))
</a>     }
 
     fn begin_read_only(&amp;self) -&gt; Result&lt;Self::Transaction&gt; {
<a href="#h1-1-8" id="h1-1-8" class="d">-        Ok(Self::Transaction::new(self.kv.begin_read_only()?))
</a><a href="#h1-1-9" id="h1-1-9" class="i">+        Ok(Self::Transaction::new(self.mvcc.begin_read_only()?))
</a>     }
 
<a href="#h1-1-12" id="h1-1-12" class="d">-    fn begin_as_of(&amp;self, version: u64) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h1-1-13" id="h1-1-13" class="d">-        Ok(Self::Transaction::new(self.kv.begin_as_of(version)?))
</a><a href="#h1-1-14" id="h1-1-14" class="i">+    fn begin_as_of(&amp;self, version: mvcc::Version) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h1-1-15" id="h1-1-15" class="i">+        Ok(Self::Transaction::new(self.mvcc.begin_as_of(version)?))
</a>     }
 }
 
<a href="#h1-1-19" id="h1-1-19" class="d">-/// An SQL transaction based on an MVCC key/value transaction
</a><a href="#h1-1-20" id="h1-1-20" class="i">+/// A SQL transaction, wrapping an MVCC transaction.
</a> pub struct Transaction&lt;E: storage::Engine&gt; {
<a href="#h1-1-22" id="h1-1-22" class="d">-    txn: storage::mvcc::Transaction&lt;E&gt;,
</a><a href="#h1-1-23" id="h1-1-23" class="i">+    txn: mvcc::Transaction&lt;E&gt;,
</a> }
 
 impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
<a href="#h1-1-27" id="h1-1-27" class="d">-    /// Creates a new SQL transaction from an MVCC transaction
</a><a href="#h1-1-28" id="h1-1-28" class="d">-    fn new(txn: storage::mvcc::Transaction&lt;E&gt;) -&gt; Self {
</a><a href="#h1-1-29" id="h1-1-29" class="i">+    /// Creates a new SQL transaction using the given MVCC transaction.
</a><a href="#h1-1-30" id="h1-1-30" class="i">+    fn new(txn: mvcc::Transaction&lt;E&gt;) -&gt; Self {
</a>         Self { txn }
     }
 
<a href="#h1-1-34" id="h1-1-34" class="d">-    /// Returns the transaction&#39;s serialized state.
</a><a href="#h1-1-35" id="h1-1-35" class="d">-    pub(super) fn state(&amp;self) -&gt; &amp;storage::mvcc::TransactionState {
</a><a href="#h1-1-36" id="h1-1-36" class="i">+    /// Returns the transaction&#39;s internal state.
</a><a href="#h1-1-37" id="h1-1-37" class="i">+    pub(super) fn state(&amp;self) -&gt; &amp;mvcc::TransactionState {
</a>         self.txn.state()
     }
 
<a href="#h1-1-41" id="h1-1-41" class="d">-    /// Loads an index entry
</a><a href="#h1-1-42" id="h1-1-42" class="d">-    fn index_load(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
</a><a href="#h1-1-43" id="h1-1-43" class="i">+    /// Fetches the matching primary keys for the given secondary index value,
</a><a href="#h1-1-44" id="h1-1-44" class="i">+    /// or an empty set if there is none.
</a><a href="#h1-1-45" id="h1-1-45" class="i">+    fn get_index(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
</a><a href="#h1-1-46" id="h1-1-46" class="i">+        debug_assert!(self.has_index(table, column)?, &quot;no index on {table}.{column}&quot;);
</a>         Ok(self
             .txn
             .get(&amp;Key::Index(table.into(), column.into(), value.into()).encode())?
<a href="#h1-1-50" id="h1-1-50" class="d">-            .map(|v| HashSet::&lt;Value&gt;::decode(&amp;v))
</a><a href="#h1-1-51" id="h1-1-51" class="i">+            .map(|v| HashSet::decode(&amp;v))
</a>             .transpose()?
             .unwrap_or_default())
     }
 
<a href="#h1-1-56" id="h1-1-56" class="d">-    /// Saves an index entry.
</a><a href="#h1-1-57" id="h1-1-57" class="d">-    fn index_save(
</a><a href="#h1-1-58" id="h1-1-58" class="i">+    /// Fetches a single row by primary key, or None if it doesn&#39;t exist.
</a><a href="#h1-1-59" id="h1-1-59" class="i">+    fn get_row(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
</a><a href="#h1-1-60" id="h1-1-60" class="i">+        self.txn
</a><a href="#h1-1-61" id="h1-1-61" class="i">+            .get(&amp;Key::Row(table.into(), id.into()).encode())?
</a><a href="#h1-1-62" id="h1-1-62" class="i">+            .map(|v| Row::decode(&amp;v))
</a><a href="#h1-1-63" id="h1-1-63" class="i">+            .transpose()
</a><a href="#h1-1-64" id="h1-1-64" class="i">+    }
</a><a href="#h1-1-65" id="h1-1-65" class="i">+
</a><a href="#h1-1-66" id="h1-1-66" class="i">+    /// Returns true if the given secondary index exists.
</a><a href="#h1-1-67" id="h1-1-67" class="i">+    fn has_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;bool&gt; {
</a><a href="#h1-1-68" id="h1-1-68" class="i">+        Ok(self.must_get_table(table)?.get_column(column)?.index)
</a><a href="#h1-1-69" id="h1-1-69" class="i">+    }
</a><a href="#h1-1-70" id="h1-1-70" class="i">+
</a><a href="#h1-1-71" id="h1-1-71" class="i">+    /// Stores a secondary index entry for the given column value, replacing the
</a><a href="#h1-1-72" id="h1-1-72" class="i">+    /// existing entry.
</a><a href="#h1-1-73" id="h1-1-73" class="i">+    fn set_index(
</a>         &amp;self,
         table: &amp;str,
         column: &amp;str,
         value: &amp;Value,
<a href="#h1-1-78" id="h1-1-78" class="d">-        index: HashSet&lt;Value&gt;,
</a><a href="#h1-1-79" id="h1-1-79" class="i">+        ids: HashSet&lt;Value&gt;,
</a>     ) -&gt; Result&lt;()&gt; {
<a href="#h1-1-81" id="h1-1-81" class="i">+        debug_assert!(self.has_index(table, column)?, &quot;no index on {table}.{column}&quot;);
</a>         let key = Key::Index(table.into(), column.into(), value.into()).encode();
<a href="#h1-1-83" id="h1-1-83" class="d">-        if index.is_empty() {
</a><a href="#h1-1-84" id="h1-1-84" class="i">+        if ids.is_empty() {
</a>             self.txn.delete(&amp;key)
         } else {
<a href="#h1-1-87" id="h1-1-87" class="d">-            self.txn.set(&amp;key, index.encode())
</a><a href="#h1-1-88" id="h1-1-88" class="i">+            self.txn.set(&amp;key, ids.encode())
</a>         }
     }
 
<a href="#h1-1-92" id="h1-1-92" class="d">-    /// Returns all foreign key references to a table, as table -&gt; columns.
</a><a href="#h1-1-93" id="h1-1-93" class="i">+    /// Returns all tables referencing a table, as (table, column index) pairs.
</a>     /// This includes references from the table itself.
<a href="#h1-1-95" id="h1-1-95" class="d">-    fn references(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;(String, Vec&lt;String&gt;)&gt;&gt; {
</a><a href="#h1-1-96" id="h1-1-96" class="i">+    fn table_references(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;(Table, Vec&lt;usize&gt;)&gt;&gt; {
</a>         Ok(self
             .list_tables()?
             .into_iter()
             .map(|t| {
<a href="#h1-1-101" id="h1-1-101" class="d">-                (
</a><a href="#h1-1-102" id="h1-1-102" class="d">-                    t.name,
</a><a href="#h1-1-103" id="h1-1-103" class="d">-                    t.columns
</a><a href="#h1-1-104" id="h1-1-104" class="d">-                        .iter()
</a><a href="#h1-1-105" id="h1-1-105" class="d">-                        .filter(|c| c.references.as_deref() == Some(table))
</a><a href="#h1-1-106" id="h1-1-106" class="d">-                        .map(|c| c.name.clone())
</a><a href="#h1-1-107" id="h1-1-107" class="d">-                        .collect::&lt;Vec&lt;_&gt;&gt;(),
</a><a href="#h1-1-108" id="h1-1-108" class="d">-                )
</a><a href="#h1-1-109" id="h1-1-109" class="i">+                let references: Vec&lt;usize&gt; = t
</a><a href="#h1-1-110" id="h1-1-110" class="i">+                    .columns
</a><a href="#h1-1-111" id="h1-1-111" class="i">+                    .iter()
</a><a href="#h1-1-112" id="h1-1-112" class="i">+                    .enumerate()
</a><a href="#h1-1-113" id="h1-1-113" class="i">+                    .filter(|(_, c)| c.references.as_deref() == Some(table))
</a><a href="#h1-1-114" id="h1-1-114" class="i">+                    .map(|(i, _)| i)
</a><a href="#h1-1-115" id="h1-1-115" class="i">+                    .collect();
</a><a href="#h1-1-116" id="h1-1-116" class="i">+                (t, references)
</a>             })
<a href="#h1-1-118" id="h1-1-118" class="d">-            .filter(|(_, cs)| !cs.is_empty())
</a><a href="#h1-1-119" id="h1-1-119" class="i">+            .filter(|(_, references)| !references.is_empty())
</a>             .collect())
     }
 }
<a href="#h1-2" id="h1-2" class="h">@@ -138,96 +156,102 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         self.txn.rollback()
     }
 
<a href="#h1-2-3" id="h1-2-3" class="d">-    fn insert(&amp;self, table: &amp;str, rows: Vec&lt;Row&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h1-2-4" id="h1-2-4" class="d">-        let table = self.must_get_table(table)?;
</a><a href="#h1-2-5" id="h1-2-5" class="d">-        for row in rows {
</a><a href="#h1-2-6" id="h1-2-6" class="d">-            table.validate_row(&amp;row, self)?;
</a><a href="#h1-2-7" id="h1-2-7" class="d">-            let id = table.get_row_key(&amp;row)?;
</a><a href="#h1-2-8" id="h1-2-8" class="d">-            if !self.get(&amp;table.name, &amp;[id.clone()])?.is_empty() {
</a><a href="#h1-2-9" id="h1-2-9" class="d">-                return errinput!(&quot;primary key {id} already exists for table {}&quot;, table.name);
</a><a href="#h1-2-10" id="h1-2-10" class="d">-            }
</a><a href="#h1-2-11" id="h1-2-11" class="d">-            self.txn.set(&amp;Key::Row((&amp;table.name).into(), id.into()).encode(), row.encode())?;
</a><a href="#h1-2-12" id="h1-2-12" class="d">-
</a><a href="#h1-2-13" id="h1-2-13" class="d">-            // Update indexes
</a><a href="#h1-2-14" id="h1-2-14" class="d">-            for (i, column) in table.columns.iter().enumerate().filter(|(_, c)| c.index) {
</a><a href="#h1-2-15" id="h1-2-15" class="d">-                let mut index = self.index_load(&amp;table.name, &amp;column.name, &amp;row[i])?;
</a><a href="#h1-2-16" id="h1-2-16" class="d">-                index.insert(id.clone());
</a><a href="#h1-2-17" id="h1-2-17" class="d">-                self.index_save(&amp;table.name, &amp;column.name, &amp;row[i], index)?;
</a><a href="#h1-2-18" id="h1-2-18" class="d">-            }
</a><a href="#h1-2-19" id="h1-2-19" class="d">-        }
</a><a href="#h1-2-20" id="h1-2-20" class="d">-        Ok(())
</a><a href="#h1-2-21" id="h1-2-21" class="d">-    }
</a><a href="#h1-2-22" id="h1-2-22" class="d">-
</a>     fn delete(&amp;self, table: &amp;str, ids: &amp;[Value]) -&gt; Result&lt;()&gt; {
<a href="#h1-2-24" id="h1-2-24" class="d">-        // Check for foreign key referenes.
</a><a href="#h1-2-25" id="h1-2-25" class="d">-
</a><a href="#h1-2-26" id="h1-2-26" class="d">-        // TODO: try to be more clever than simply iterating over each ID.
</a><a href="#h1-2-27" id="h1-2-27" class="d">-        for id in ids {
</a><a href="#h1-2-28" id="h1-2-28" class="d">-            let table = self.must_get_table(table)?;
</a><a href="#h1-2-29" id="h1-2-29" class="d">-            for (t, cs) in self.references(&amp;table.name)? {
</a><a href="#h1-2-30" id="h1-2-30" class="d">-                let t = self.must_get_table(&amp;t)?;
</a><a href="#h1-2-31" id="h1-2-31" class="d">-                let cs = cs
</a><a href="#h1-2-32" id="h1-2-32" class="d">-                    .into_iter()
</a><a href="#h1-2-33" id="h1-2-33" class="d">-                    .map(|c| Ok((t.get_column_index(&amp;c)?, c)))
</a><a href="#h1-2-34" id="h1-2-34" class="d">-                    .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h1-2-35" id="h1-2-35" class="d">-                let mut scan = self.scan(&amp;t.name, None)?;
</a><a href="#h1-2-36" id="h1-2-36" class="d">-                while let Some(row) = scan.next().transpose()? {
</a><a href="#h1-2-37" id="h1-2-37" class="d">-                    for (i, c) in &amp;cs {
</a><a href="#h1-2-38" id="h1-2-38" class="d">-                        if &amp;row[*i] == id
</a><a href="#h1-2-39" id="h1-2-39" class="d">-                            &amp;&amp; (table.name != t.name || id != table.get_row_key(&amp;row)?)
</a><a href="#h1-2-40" id="h1-2-40" class="d">-                        {
</a><a href="#h1-2-41" id="h1-2-41" class="d">-                            return errinput!(
</a><a href="#h1-2-42" id="h1-2-42" class="d">-                                &quot;primary key {id} referenced by table {} column {c}&quot;,
</a><a href="#h1-2-43" id="h1-2-43" class="d">-                                t.name
</a><a href="#h1-2-44" id="h1-2-44" class="d">-                            );
</a><a href="#h1-2-45" id="h1-2-45" class="d">-                        }
</a><a href="#h1-2-46" id="h1-2-46" class="i">+        let table = self.must_get_table(table)?;
</a><a href="#h1-2-47" id="h1-2-47" class="i">+        let indexes: Vec&lt;_&gt; = table.columns.iter().enumerate().filter(|(_, c)| c.index).collect();
</a><a href="#h1-2-48" id="h1-2-48" class="i">+
</a><a href="#h1-2-49" id="h1-2-49" class="i">+        // Check for foreign key references to the deleted rows.
</a><a href="#h1-2-50" id="h1-2-50" class="i">+        for (source, refs) in self.table_references(&amp;table.name)? {
</a><a href="#h1-2-51" id="h1-2-51" class="i">+            let self_reference = source.name == table.name;
</a><a href="#h1-2-52" id="h1-2-52" class="i">+            for i in refs {
</a><a href="#h1-2-53" id="h1-2-53" class="i">+                let column = &amp;source.columns[i];
</a><a href="#h1-2-54" id="h1-2-54" class="i">+                let mut source_ids = if i == source.primary_key {
</a><a href="#h1-2-55" id="h1-2-55" class="i">+                    // If the reference is from a primary key column, do a lookup.
</a><a href="#h1-2-56" id="h1-2-56" class="i">+                    self.get(&amp;source.name, ids)?
</a><a href="#h1-2-57" id="h1-2-57" class="i">+                        .into_iter()
</a><a href="#h1-2-58" id="h1-2-58" class="i">+                        .map(|row| row.into_iter().nth(i).expect(&quot;short row&quot;))
</a><a href="#h1-2-59" id="h1-2-59" class="i">+                        .collect()
</a><a href="#h1-2-60" id="h1-2-60" class="i">+                } else {
</a><a href="#h1-2-61" id="h1-2-61" class="i">+                    // Otherwise (commonly), do a secondary index lookup.
</a><a href="#h1-2-62" id="h1-2-62" class="i">+                    // All foreign keys have a secondary index.
</a><a href="#h1-2-63" id="h1-2-63" class="i">+                    self.lookup_index(&amp;source.name, &amp;column.name, ids)?
</a><a href="#h1-2-64" id="h1-2-64" class="i">+                };
</a><a href="#h1-2-65" id="h1-2-65" class="i">+                // We can ignore any references between the deleted rows,
</a><a href="#h1-2-66" id="h1-2-66" class="i">+                // including a row referring to itself.
</a><a href="#h1-2-67" id="h1-2-67" class="i">+                if self_reference {
</a><a href="#h1-2-68" id="h1-2-68" class="i">+                    for id in ids {
</a><a href="#h1-2-69" id="h1-2-69" class="i">+                        source_ids.remove(id);
</a>                     }
                 }
<a href="#h1-2-72" id="h1-2-72" class="i">+                if let Some(source_id) = source_ids.into_iter().next() {
</a><a href="#h1-2-73" id="h1-2-73" class="i">+                    return errinput!(
</a><a href="#h1-2-74" id="h1-2-74" class="i">+                        &quot;row referenced by {}.{} for {}.{}={source_id}&quot;,
</a><a href="#h1-2-75" id="h1-2-75" class="i">+                        source.name,
</a><a href="#h1-2-76" id="h1-2-76" class="i">+                        column.name,
</a><a href="#h1-2-77" id="h1-2-77" class="i">+                        source.name,
</a><a href="#h1-2-78" id="h1-2-78" class="i">+                        source.columns[source.primary_key].name
</a><a href="#h1-2-79" id="h1-2-79" class="i">+                    );
</a><a href="#h1-2-80" id="h1-2-80" class="i">+                }
</a>             }
<a href="#h1-2-82" id="h1-2-82" class="i">+        }
</a> 
<a href="#h1-2-84" id="h1-2-84" class="d">-            let indexes: Vec&lt;_&gt; =
</a><a href="#h1-2-85" id="h1-2-85" class="d">-                table.columns.iter().enumerate().filter(|(_, c)| c.index).collect();
</a><a href="#h1-2-86" id="h1-2-86" class="i">+        for id in ids {
</a><a href="#h1-2-87" id="h1-2-87" class="i">+            // Remove the primary key from any index entries. There must be
</a><a href="#h1-2-88" id="h1-2-88" class="i">+            // an index entry for each row.
</a><a href="#h1-2-89" id="h1-2-89" class="i">+            //
</a><a href="#h1-2-90" id="h1-2-90" class="i">+            // TODO: NULL entries shouldn&#39;t be indexed, we can skip
</a><a href="#h1-2-91" id="h1-2-91" class="i">+            // those. But they&#39;re currently indexed.
</a>             if !indexes.is_empty() {
<a href="#h1-2-93" id="h1-2-93" class="d">-                for row in self.get(&amp;table.name, &amp;[id.clone()])? {
</a><a href="#h1-2-94" id="h1-2-94" class="d">-                    for (i, column) in &amp;indexes {
</a><a href="#h1-2-95" id="h1-2-95" class="d">-                        let mut index = self.index_load(&amp;table.name, &amp;column.name, &amp;row[*i])?;
</a><a href="#h1-2-96" id="h1-2-96" class="i">+                if let Some(row) = self.get_row(&amp;table.name, id)? {
</a><a href="#h1-2-97" id="h1-2-97" class="i">+                    for (i, column) in indexes.iter().copied() {
</a><a href="#h1-2-98" id="h1-2-98" class="i">+                        let mut index = self.get_index(&amp;table.name, &amp;column.name, &amp;row[i])?;
</a>                         index.remove(id);
<a href="#h1-2-100" id="h1-2-100" class="d">-                        self.index_save(&amp;table.name, &amp;column.name, &amp;row[*i], index)?;
</a><a href="#h1-2-101" id="h1-2-101" class="i">+                        self.set_index(&amp;table.name, &amp;column.name, &amp;row[i], index)?;
</a>                     }
                 }
             }
<a href="#h1-2-105" id="h1-2-105" class="d">-            self.txn.delete(&amp;Key::Row(table.name.into(), id.into()).encode())?;
</a><a href="#h1-2-106" id="h1-2-106" class="i">+
</a><a href="#h1-2-107" id="h1-2-107" class="i">+            // Delete the row.
</a><a href="#h1-2-108" id="h1-2-108" class="i">+            self.txn.delete(&amp;Key::Row((&amp;table.name).into(), id.into()).encode())?;
</a>         }
         Ok(())
     }
 
     fn get(&amp;self, table: &amp;str, ids: &amp;[Value]) -&gt; Result&lt;Vec&lt;Row&gt;&gt; {
<a href="#h1-2-114" id="h1-2-114" class="d">-        ids.iter()
</a><a href="#h1-2-115" id="h1-2-115" class="d">-            .filter_map(|id| {
</a><a href="#h1-2-116" id="h1-2-116" class="d">-                self.txn
</a><a href="#h1-2-117" id="h1-2-117" class="d">-                    .get(&amp;Key::Row(table.into(), id.into()).encode())
</a><a href="#h1-2-118" id="h1-2-118" class="d">-                    .transpose()
</a><a href="#h1-2-119" id="h1-2-119" class="d">-                    .map(|r| r.and_then(|v| Row::decode(&amp;v)))
</a><a href="#h1-2-120" id="h1-2-120" class="d">-            })
</a><a href="#h1-2-121" id="h1-2-121" class="d">-            .collect()
</a><a href="#h1-2-122" id="h1-2-122" class="i">+        ids.iter().filter_map(|id| self.get_row(table, id).transpose()).collect()
</a>     }
 
<a href="#h1-2-125" id="h1-2-125" class="d">-    fn lookup_index(&amp;self, table: &amp;str, column: &amp;str, value: &amp;[Value]) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
</a><a href="#h1-2-126" id="h1-2-126" class="d">-        if !self.must_get_table(table)?.get_column(column)?.index {
</a><a href="#h1-2-127" id="h1-2-127" class="d">-            return errinput!(&quot;no index on {table}.{column}&quot;);
</a><a href="#h1-2-128" id="h1-2-128" class="i">+    fn insert(&amp;self, table: &amp;str, rows: Vec&lt;Row&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h1-2-129" id="h1-2-129" class="i">+        let table = self.must_get_table(table)?;
</a><a href="#h1-2-130" id="h1-2-130" class="i">+        for row in rows {
</a><a href="#h1-2-131" id="h1-2-131" class="i">+            // Insert the row.
</a><a href="#h1-2-132" id="h1-2-132" class="i">+            table.validate_row(&amp;row, false, self)?;
</a><a href="#h1-2-133" id="h1-2-133" class="i">+            let id = &amp;row[table.primary_key];
</a><a href="#h1-2-134" id="h1-2-134" class="i">+            self.txn.set(&amp;Key::Row((&amp;table.name).into(), id.into()).encode(), row.encode())?;
</a><a href="#h1-2-135" id="h1-2-135" class="i">+
</a><a href="#h1-2-136" id="h1-2-136" class="i">+            // Update any secondary indexes.
</a><a href="#h1-2-137" id="h1-2-137" class="i">+            for (i, column) in table.columns.iter().enumerate().filter(|(_, c)| c.index) {
</a><a href="#h1-2-138" id="h1-2-138" class="i">+                let mut index = self.get_index(&amp;table.name, &amp;column.name, &amp;row[i])?;
</a><a href="#h1-2-139" id="h1-2-139" class="i">+                index.insert(id.clone());
</a><a href="#h1-2-140" id="h1-2-140" class="i">+                self.set_index(&amp;table.name, &amp;column.name, &amp;row[i], index)?;
</a><a href="#h1-2-141" id="h1-2-141" class="i">+            }
</a>         }
<a href="#h1-2-143" id="h1-2-143" class="i">+        Ok(())
</a><a href="#h1-2-144" id="h1-2-144" class="i">+    }
</a><a href="#h1-2-145" id="h1-2-145" class="i">+
</a><a href="#h1-2-146" id="h1-2-146" class="i">+    fn lookup_index(&amp;self, table: &amp;str, column: &amp;str, values: &amp;[Value]) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
</a><a href="#h1-2-147" id="h1-2-147" class="i">+        debug_assert!(self.has_index(table, column)?, &quot;index lookup without index&quot;);
</a>         let mut pks = HashSet::new();
<a href="#h1-2-149" id="h1-2-149" class="d">-        for v in value {
</a><a href="#h1-2-150" id="h1-2-150" class="d">-            pks.extend(self.index_load(table, column, v)?)
</a><a href="#h1-2-151" id="h1-2-151" class="i">+        for v in values {
</a><a href="#h1-2-152" id="h1-2-152" class="i">+            pks.extend(self.get_index(table, column, v)?)
</a>         }
         Ok(pks)
     }
 
     fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Rows&gt; {
<a href="#h1-2-158" id="h1-2-158" class="d">-        let table = self.must_get_table(table)?;
</a>         Ok(Box::new(
             self.txn
<a href="#h1-2-161" id="h1-2-161" class="d">-                .scan_prefix(&amp;KeyPrefix::Row((&amp;table.name).into()).encode())
</a><a href="#h1-2-162" id="h1-2-162" class="i">+                .scan_prefix(&amp;KeyPrefix::Row(table.into()).encode())
</a>                 .iter()
                 .map(|r| r.and_then(|(_, v)| Row::decode(&amp;v)))
                 .filter_map(move |r| match r {
<a href="#h1-3" id="h1-3" class="h">@@ -235,38 +259,34 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>                         Some(filter) =&gt; match filter.evaluate(Some(&amp;row)) {
                             Ok(Value::Boolean(b)) if b =&gt; Some(Ok(row)),
                             Ok(Value::Boolean(_)) | Ok(Value::Null) =&gt; None,
<a href="#h1-3-3" id="h1-3-3" class="d">-                            Ok(v) =&gt; Some(errdata!(&quot;filter returned {v}, expected boolean&quot;)),
</a><a href="#h1-3-4" id="h1-3-4" class="i">+                            Ok(v) =&gt; Some(errinput!(&quot;filter returned {v}, expected boolean&quot;)),
</a>                             Err(err) =&gt; Some(Err(err)),
                         },
                         None =&gt; Some(Ok(row)),
                     },
                     err =&gt; Some(err),
                 })
<a href="#h1-3-11" id="h1-3-11" class="i">+                // TODO: don&#39;t collect.
</a>                 .collect::&lt;Vec&lt;_&gt;&gt;()
                 .into_iter(),
         ))
     }
 
     fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;super::IndexScan&gt; {
<a href="#h1-3-18" id="h1-3-18" class="d">-        let table = self.must_get_table(table)?;
</a><a href="#h1-3-19" id="h1-3-19" class="d">-        let column = table.get_column(column)?;
</a><a href="#h1-3-20" id="h1-3-20" class="d">-        if !column.index {
</a><a href="#h1-3-21" id="h1-3-21" class="d">-            return errinput!(&quot;no index for {}.{}&quot;, table.name, column.name);
</a><a href="#h1-3-22" id="h1-3-22" class="d">-        }
</a><a href="#h1-3-23" id="h1-3-23" class="i">+        debug_assert!(self.has_index(table, column)?, &quot;index scan without index&quot;);
</a>         Ok(Box::new(
             self.txn
<a href="#h1-3-26" id="h1-3-26" class="d">-                .scan_prefix(
</a><a href="#h1-3-27" id="h1-3-27" class="d">-                    &amp;KeyPrefix::Index((&amp;table.name).into(), (&amp;column.name).into()).encode(),
</a><a href="#h1-3-28" id="h1-3-28" class="d">-                )
</a><a href="#h1-3-29" id="h1-3-29" class="i">+                .scan_prefix(&amp;KeyPrefix::Index(table.into(), column.into()).encode())
</a>                 .iter()
<a href="#h1-3-31" id="h1-3-31" class="d">-                .map(|r| -&gt; Result&lt;(Value, HashSet&lt;Value&gt;)&gt; {
</a><a href="#h1-3-32" id="h1-3-32" class="d">-                    let (k, v) = r?;
</a><a href="#h1-3-33" id="h1-3-33" class="d">-                    let value = match Key::decode(&amp;k)? {
</a><a href="#h1-3-34" id="h1-3-34" class="d">-                        Key::Index(_, _, pk) =&gt; pk.into_owned(),
</a><a href="#h1-3-35" id="h1-3-35" class="d">-                        _ =&gt; return errdata!(&quot;invalid index key&quot;),
</a><a href="#h1-3-36" id="h1-3-36" class="d">-                    };
</a><a href="#h1-3-37" id="h1-3-37" class="d">-                    Ok((value, HashSet::&lt;Value&gt;::decode(&amp;v)?))
</a><a href="#h1-3-38" id="h1-3-38" class="i">+                .map(|r| {
</a><a href="#h1-3-39" id="h1-3-39" class="i">+                    r.and_then(|(k, v)| {
</a><a href="#h1-3-40" id="h1-3-40" class="i">+                        let Key::Index(_, _, value) = Key::decode(&amp;k)? else {
</a><a href="#h1-3-41" id="h1-3-41" class="i">+                            return errdata!(&quot;invalid index key&quot;);
</a><a href="#h1-3-42" id="h1-3-42" class="i">+                        };
</a><a href="#h1-3-43" id="h1-3-43" class="i">+                        Ok((value.into_owned(), HashSet::decode(&amp;v)?))
</a><a href="#h1-3-44" id="h1-3-44" class="i">+                    })
</a>                 })
<a href="#h1-3-46" id="h1-3-46" class="i">+                // TODO: don&#39;t collect.
</a>                 .collect::&lt;Vec&lt;_&gt;&gt;()
                 .into_iter(),
         ))
<a href="#h1-4" id="h1-4" class="h">@@ -274,36 +294,46 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a> 
     fn update(&amp;self, table: &amp;str, rows: HashMap&lt;Value, Row&gt;) -&gt; Result&lt;()&gt; {
         let table = self.must_get_table(table)?;
<a href="#h1-4-3" id="h1-4-3" class="d">-        // TODO: be more clever than just iterating here.
</a><a href="#h1-4-4" id="h1-4-4" class="i">+
</a>         for (id, row) in rows {
<a href="#h1-4-6" id="h1-4-6" class="d">-            // If the primary key changes we do a delete and create, otherwise we replace the row
</a><a href="#h1-4-7" id="h1-4-7" class="d">-            if id != *table.get_row_key(&amp;row)? {
</a><a href="#h1-4-8" id="h1-4-8" class="d">-                self.delete(&amp;table.name, &amp;[id.clone()])?;
</a><a href="#h1-4-9" id="h1-4-9" class="i">+            // If the primary key changes, we simply do a delete and insert.
</a><a href="#h1-4-10" id="h1-4-10" class="i">+            // This simplifies constraint validation.
</a><a href="#h1-4-11" id="h1-4-11" class="i">+            if id != row[table.primary_key] {
</a><a href="#h1-4-12" id="h1-4-12" class="i">+                self.delete(&amp;table.name, &amp;[id])?;
</a>                 self.insert(&amp;table.name, vec![row])?;
                 return Ok(());
             }
 
<a href="#h1-4-17" id="h1-4-17" class="d">-            // Update indexes, knowing that the primary key has not changed
</a><a href="#h1-4-18" id="h1-4-18" class="i">+            // Validate the row, but don&#39;t write it yet since we may need to
</a><a href="#h1-4-19" id="h1-4-19" class="i">+            // read the existing value to update secondary indexes.
</a><a href="#h1-4-20" id="h1-4-20" class="i">+            table.validate_row(&amp;row, true, self)?;
</a><a href="#h1-4-21" id="h1-4-21" class="i">+
</a><a href="#h1-4-22" id="h1-4-22" class="i">+            // Update indexes, knowing that the primary key has not changed.
</a>             let indexes: Vec&lt;_&gt; =
                 table.columns.iter().enumerate().filter(|(_, c)| c.index).collect();
             if !indexes.is_empty() {
                 let old = self.get(&amp;table.name, &amp;[id.clone()])?.remove(0);
                 for (i, column) in indexes {
<a href="#h1-4-28" id="h1-4-28" class="i">+                    // If the value didn&#39;t change, we don&#39;t have to do anything.
</a>                     if old[i] == row[i] {
                         continue;
                     }
<a href="#h1-4-32" id="h1-4-32" class="d">-                    let mut index = self.index_load(&amp;table.name, &amp;column.name, &amp;old[i])?;
</a><a href="#h1-4-33" id="h1-4-33" class="i">+
</a><a href="#h1-4-34" id="h1-4-34" class="i">+                    // Remove the old value from the index entry.
</a><a href="#h1-4-35" id="h1-4-35" class="i">+                    let mut index = self.get_index(&amp;table.name, &amp;column.name, &amp;old[i])?;
</a>                     index.remove(&amp;id);
<a href="#h1-4-37" id="h1-4-37" class="d">-                    self.index_save(&amp;table.name, &amp;column.name, &amp;old[i], index)?;
</a><a href="#h1-4-38" id="h1-4-38" class="i">+                    self.set_index(&amp;table.name, &amp;column.name, &amp;old[i], index)?;
</a> 
<a href="#h1-4-40" id="h1-4-40" class="d">-                    let mut index = self.index_load(&amp;table.name, &amp;column.name, &amp;row[i])?;
</a><a href="#h1-4-41" id="h1-4-41" class="i">+                    // Insert the new value into the index entry.
</a><a href="#h1-4-42" id="h1-4-42" class="i">+                    // TODO: consider whether Null values should be indexed.
</a><a href="#h1-4-43" id="h1-4-43" class="i">+                    let mut index = self.get_index(&amp;table.name, &amp;column.name, &amp;row[i])?;
</a>                     index.insert(id.clone());
<a href="#h1-4-45" id="h1-4-45" class="d">-                    self.index_save(&amp;table.name, &amp;column.name, &amp;row[i], index)?;
</a><a href="#h1-4-46" id="h1-4-46" class="i">+                    self.set_index(&amp;table.name, &amp;column.name, &amp;row[i], index)?;
</a>                 }
             }
 
<a href="#h1-4-50" id="h1-4-50" class="d">-            table.validate_row(&amp;row, self)?;
</a><a href="#h1-4-51" id="h1-4-51" class="d">-            self.txn.set(&amp;Key::Row((&amp;table.name).into(), id.into()).encode(), row.encode())?;
</a><a href="#h1-4-52" id="h1-4-52" class="i">+            // Update the row.
</a><a href="#h1-4-53" id="h1-4-53" class="i">+            self.txn.set(&amp;Key::Row((&amp;table.name).into(), (&amp;id).into()).encode(), row.encode())?;
</a>         }
         Ok(())
     }
<a href="#h1-5" id="h1-5" class="h">@@ -319,22 +349,56 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>     }
 
     fn drop_table(&amp;self, table: &amp;str, if_exists: bool) -&gt; Result&lt;bool&gt; {
<a href="#h1-5-3" id="h1-5-3" class="d">-        let table = if !if_exists {
</a><a href="#h1-5-4" id="h1-5-4" class="d">-            self.must_get_table(table)?
</a><a href="#h1-5-5" id="h1-5-5" class="d">-        } else if let Some(table) = self.get_table(table)? {
</a><a href="#h1-5-6" id="h1-5-6" class="d">-            table
</a><a href="#h1-5-7" id="h1-5-7" class="d">-        } else {
</a><a href="#h1-5-8" id="h1-5-8" class="d">-            return Ok(false);
</a><a href="#h1-5-9" id="h1-5-9" class="i">+        let table = match self.get_table(table)? {
</a><a href="#h1-5-10" id="h1-5-10" class="i">+            Some(table) =&gt; table,
</a><a href="#h1-5-11" id="h1-5-11" class="i">+            None if if_exists =&gt; return Ok(false),
</a><a href="#h1-5-12" id="h1-5-12" class="i">+            None =&gt; return errinput!(&quot;table {table} does not exist&quot;),
</a>         };
<a href="#h1-5-14" id="h1-5-14" class="d">-        if let Some((t, cs)) = self.references(&amp;table.name)?.iter().find(|(t, _)| *t != table.name)
</a><a href="#h1-5-15" id="h1-5-15" class="i">+
</a><a href="#h1-5-16" id="h1-5-16" class="i">+        // Check for foreign key references.
</a><a href="#h1-5-17" id="h1-5-17" class="i">+        if let Some((source, refs)) =
</a><a href="#h1-5-18" id="h1-5-18" class="i">+            self.table_references(&amp;table.name)?.iter().find(|(t, _)| t.name != table.name)
</a>         {
<a href="#h1-5-20" id="h1-5-20" class="d">-            return errinput!(&quot;table {} is referenced by table {} column {}&quot;, table.name, t, cs[0]);
</a><a href="#h1-5-21" id="h1-5-21" class="i">+            return errinput!(
</a><a href="#h1-5-22" id="h1-5-22" class="i">+                &quot;table {} is referenced from {}.{}&quot;,
</a><a href="#h1-5-23" id="h1-5-23" class="i">+                table.name,
</a><a href="#h1-5-24" id="h1-5-24" class="i">+                source.name,
</a><a href="#h1-5-25" id="h1-5-25" class="i">+                source.columns[refs[0]].name
</a><a href="#h1-5-26" id="h1-5-26" class="i">+            );
</a><a href="#h1-5-27" id="h1-5-27" class="i">+        }
</a><a href="#h1-5-28" id="h1-5-28" class="i">+
</a><a href="#h1-5-29" id="h1-5-29" class="i">+        // Delete the table schema entry.
</a><a href="#h1-5-30" id="h1-5-30" class="i">+        self.txn.delete(&amp;Key::Table((&amp;table.name).into()).encode())?;
</a><a href="#h1-5-31" id="h1-5-31" class="i">+
</a><a href="#h1-5-32" id="h1-5-32" class="i">+        // Delete the table rows. storage::Engine doesn&#39;t support writing while
</a><a href="#h1-5-33" id="h1-5-33" class="i">+        // scanning, so we buffer all keys in a vector. We could also do this in
</a><a href="#h1-5-34" id="h1-5-34" class="i">+        // batches, although we&#39;d want to do the batching above Raft to avoid
</a><a href="#h1-5-35" id="h1-5-35" class="i">+        // blocking Raft processing for the duration of the drop.
</a><a href="#h1-5-36" id="h1-5-36" class="i">+        let keys: Vec&lt;Vec&lt;u8&gt;&gt; = self
</a><a href="#h1-5-37" id="h1-5-37" class="i">+            .txn
</a><a href="#h1-5-38" id="h1-5-38" class="i">+            .scan_prefix(&amp;KeyPrefix::Row((&amp;table.name).into()).encode())
</a><a href="#h1-5-39" id="h1-5-39" class="i">+            .iter()
</a><a href="#h1-5-40" id="h1-5-40" class="i">+            .map(|r| r.map(|(key, _)| key))
</a><a href="#h1-5-41" id="h1-5-41" class="i">+            .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h1-5-42" id="h1-5-42" class="i">+        for key in keys {
</a><a href="#h1-5-43" id="h1-5-43" class="i">+            self.txn.delete(&amp;key)?;
</a>         }
<a href="#h1-5-45" id="h1-5-45" class="d">-        let mut scan = self.scan(&amp;table.name, None)?;
</a><a href="#h1-5-46" id="h1-5-46" class="d">-        while let Some(row) = scan.next().transpose()? {
</a><a href="#h1-5-47" id="h1-5-47" class="d">-            self.delete(&amp;table.name, &amp;[table.get_row_key(&amp;row)?.clone()])?
</a><a href="#h1-5-48" id="h1-5-48" class="i">+
</a><a href="#h1-5-49" id="h1-5-49" class="i">+        // Delete any secondary indexes.
</a><a href="#h1-5-50" id="h1-5-50" class="i">+        for column in table.columns.iter().filter(|c| c.index) {
</a><a href="#h1-5-51" id="h1-5-51" class="i">+            let keys: Vec&lt;_&gt; = self
</a><a href="#h1-5-52" id="h1-5-52" class="i">+                .txn
</a><a href="#h1-5-53" id="h1-5-53" class="i">+                .scan_prefix(
</a><a href="#h1-5-54" id="h1-5-54" class="i">+                    &amp;KeyPrefix::Index((&amp;table.name).into(), (&amp;column.name).into()).encode(),
</a><a href="#h1-5-55" id="h1-5-55" class="i">+                )
</a><a href="#h1-5-56" id="h1-5-56" class="i">+                .iter()
</a><a href="#h1-5-57" id="h1-5-57" class="i">+                .map(|r| r.map(|(key, _)| key))
</a><a href="#h1-5-58" id="h1-5-58" class="i">+                .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h1-5-59" id="h1-5-59" class="i">+            for key in keys {
</a><a href="#h1-5-60" id="h1-5-60" class="i">+                self.txn.delete(&amp;key)?;
</a><a href="#h1-5-61" id="h1-5-61" class="i">+            }
</a>         }
<a href="#h1-5-63" id="h1-5-63" class="d">-        self.txn.delete(&amp;Key::Table(table.name.into()).encode())?;
</a><a href="#h1-5-64" id="h1-5-64" class="i">+
</a>         Ok(true)
     }
 
<a href="#h1-6" id="h1-6" class="h">@@ -351,11 +415,16 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>     }
 }
 
<a href="#h1-6-3" id="h1-6-3" class="d">-/// SQL keys, using the KeyCode order-preserving encoding. Uses table and column
</a><a href="#h1-6-4" id="h1-6-4" class="d">-/// names directly as identifiers, to avoid additional indirection. It is not
</a><a href="#h1-6-5" id="h1-6-5" class="d">-/// possible to change names, so this is ok. Cow strings allow encoding borrowed
</a><a href="#h1-6-6" id="h1-6-6" class="d">-/// values and decoding into owned values.
</a><a href="#h1-6-7" id="h1-6-7" class="d">-#[derive(Debug, Deserialize, Serialize)]
</a><a href="#h1-6-8" id="h1-6-8" class="i">+/// SQL engine keys, using the KeyCode order-preserving encoding. For
</a><a href="#h1-6-9" id="h1-6-9" class="i">+/// simplicity, table and column names are used directly as identifiers in
</a><a href="#h1-6-10" id="h1-6-10" class="i">+/// keys, instead of e.g. numberic IDs. It is not possible to change
</a><a href="#h1-6-11" id="h1-6-11" class="i">+/// table/column names, so this is fine.
</a><a href="#h1-6-12" id="h1-6-12" class="i">+///
</a><a href="#h1-6-13" id="h1-6-13" class="i">+/// Uses Cow to allow encoding borrowed values but decoding owned values.
</a><a href="#h1-6-14" id="h1-6-14" class="i">+///
</a><a href="#h1-6-15" id="h1-6-15" class="i">+/// TODO: add helper methods here to encode borrowed keys. This should also
</a><a href="#h1-6-16" id="h1-6-16" class="i">+/// encode into a reused byte buffer, see keycode::serialize() comment.
</a><a href="#h1-6-17" id="h1-6-17" class="i">+#[derive(Deserialize, Serialize)]
</a> enum Key&lt;&#39;a&gt; {
     /// A table schema by table name.
     Table(Cow&lt;&#39;a, str&gt;),
<a href="#h1-7" id="h1-7" class="h">@@ -369,7 +438,7 @@ impl&lt;&#39;a&gt; encoding::Key&lt;&#39;a&gt; for Key&lt;&#39;a&gt; {}
</a> 
 /// Key prefixes, allowing prefix scans of specific parts of the keyspace. These
 /// must match the keys -- in particular, the enum variant indexes must match.
<a href="#h1-7-3" id="h1-7-3" class="d">-#[derive(Debug, Deserialize, Serialize)]
</a><a href="#h1-7-4" id="h1-7-4" class="i">+#[derive(Deserialize, Serialize)]
</a> enum KeyPrefix&lt;&#39;a&gt; {
     /// All table schemas.
     Table,
<b>diff --git a/<a id="h2" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -316,7 +316,7 @@ impl&lt;E: storage::Engine&gt; raft::State for State&lt;E&gt; {
</a>                 };
                 txn.state().encode()
             }
<a href="#h2-0-3" id="h2-0-3" class="d">-            Read::Status =&gt; self.local.kv.status()?.encode(),
</a><a href="#h2-0-4" id="h2-0-4" class="i">+            Read::Status =&gt; self.local.mvcc.status()?.encode(),
</a> 
             Read::Get { txn, table, ids } =&gt; self.local.resume(txn)?.get(&amp;table, &amp;ids)?.encode(),
             Read::LookupIndex { txn, table, column, values } =&gt; {
<b>diff --git a/<a id="h3" href="../file/src/sql/types/schema.rs.html">src/sql/types/schema.rs</a> b/<a href="../file/src/sql/types/schema.rs.html">src/sql/types/schema.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,13 +1,13 @@
</a> use super::value::{DataType, Value};
 use crate::encoding;
<a href="#h3-0-2" id="h3-0-2" class="i">+use crate::errinput;
</a> use crate::error::Result;
 use crate::sql::engine::{Catalog, Transaction};
<a href="#h3-0-5" id="h3-0-5" class="d">-use crate::{errdata, errinput};
</a> 
 use serde::{Deserialize, Serialize};
 use std::borrow::Cow;
 
<a href="#h3-0-10" id="h3-0-10" class="d">-/// A table schema, which specifies the structure and constraints of its data.
</a><a href="#h3-0-11" id="h3-0-11" class="i">+/// A table schema, which specifies the data structure and constraints.
</a> ///
 /// Tables can&#39;t change after they are created. There is no ALTER TABLE nor
 /// CREATE/DROP INDEX -- only CREATE TABLE and DROP TABLE.
<a href="#h3-1" id="h3-1" class="h">@@ -85,7 +85,7 @@ impl std::fmt::Display for Table {
</a> impl Table {
     /// Fetches a column by name.
     ///
<a href="#h3-1-3" id="h3-1-3" class="d">-    /// TODO: consider getting rid of all these helpers.
</a><a href="#h3-1-4" id="h3-1-4" class="i">+    /// TODO: consider getting rid of this helper.
</a>     pub fn get_column(&amp;self, name: &amp;str) -&gt; Result&lt;&amp;Column&gt; {
         self.columns
             .iter()
<a href="#h3-2" id="h3-2" class="h">@@ -93,19 +93,6 @@ impl Table {
</a>             .ok_or(errinput!(&quot;column {name} not found in table {}&quot;, self.name))
     }
 
<a href="#h3-2-3" id="h3-2-3" class="d">-    /// Fetches a column index by name
</a><a href="#h3-2-4" id="h3-2-4" class="d">-    pub fn get_column_index(&amp;self, name: &amp;str) -&gt; Result&lt;usize&gt; {
</a><a href="#h3-2-5" id="h3-2-5" class="d">-        self.columns
</a><a href="#h3-2-6" id="h3-2-6" class="d">-            .iter()
</a><a href="#h3-2-7" id="h3-2-7" class="d">-            .position(|c| c.name == name)
</a><a href="#h3-2-8" id="h3-2-8" class="d">-            .ok_or(errinput!(&quot;column {name} not found in table {}&quot;, self.name))
</a><a href="#h3-2-9" id="h3-2-9" class="d">-    }
</a><a href="#h3-2-10" id="h3-2-10" class="d">-
</a><a href="#h3-2-11" id="h3-2-11" class="d">-    /// Returns the primary key value of a row.
</a><a href="#h3-2-12" id="h3-2-12" class="d">-    pub fn get_row_key&lt;&#39;a&gt;(&amp;self, row: &amp;&#39;a [Value]) -&gt; Result&lt;&amp;&#39;a Value&gt; {
</a><a href="#h3-2-13" id="h3-2-13" class="d">-        row.get(self.primary_key).ok_or(errdata!(&quot;no primary key in row {row:?}&quot;))
</a><a href="#h3-2-14" id="h3-2-14" class="d">-    }
</a><a href="#h3-2-15" id="h3-2-15" class="d">-
</a>     /// Validates the table schema.
     pub fn validate(&amp;self, catalog: &amp;impl Catalog) -&gt; Result&lt;()&gt; {
         if self.name.is_empty() {
<a href="#h3-3" id="h3-3" class="h">@@ -183,67 +170,57 @@ impl Table {
</a>         Ok(())
     }
 
<a href="#h3-3-3" id="h3-3-3" class="d">-    /// Validates a row.
</a><a href="#h3-3-4" id="h3-3-4" class="i">+    /// Validates a row, including uniqueness constraints and references.
</a>     ///
<a href="#h3-3-6" id="h3-3-6" class="d">-    /// TODO: clean this up together with the Local engine. Who should be
</a><a href="#h3-3-7" id="h3-3-7" class="d">-    /// responsible for non-local validation (i.e. primary/unique conflicts and
</a><a href="#h3-3-8" id="h3-3-8" class="d">-    /// reference integrity)?
</a><a href="#h3-3-9" id="h3-3-9" class="d">-    pub fn validate_row(&amp;self, row: &amp;[Value], txn: &amp;impl Transaction) -&gt; Result&lt;()&gt; {
</a><a href="#h3-3-10" id="h3-3-10" class="i">+    /// If update is true, the row replaces an existing entry with the same
</a><a href="#h3-3-11" id="h3-3-11" class="i">+    /// primary key. Otherwise, it is an insert. Primary key changes are
</a><a href="#h3-3-12" id="h3-3-12" class="i">+    /// implemented as a delete+insert.
</a><a href="#h3-3-13" id="h3-3-13" class="i">+    pub fn validate_row(&amp;self, row: &amp;[Value], update: bool, txn: &amp;impl Transaction) -&gt; Result&lt;()&gt; {
</a>         if row.len() != self.columns.len() {
             return errinput!(&quot;invalid row size for table {}&quot;, self.name);
         }
<a href="#h3-3-17" id="h3-3-17" class="d">-        let pk = self.get_row_key(row)?;
</a><a href="#h3-3-18" id="h3-3-18" class="d">-        for (i, (column, value)) in self.columns.iter().zip(row.iter()).enumerate() {
</a><a href="#h3-3-19" id="h3-3-19" class="i">+
</a><a href="#h3-3-20" id="h3-3-20" class="i">+        // Validate primary key.
</a><a href="#h3-3-21" id="h3-3-21" class="i">+        let id = &amp;row[self.primary_key];
</a><a href="#h3-3-22" id="h3-3-22" class="i">+        let idslice = &amp;row[self.primary_key..=self.primary_key];
</a><a href="#h3-3-23" id="h3-3-23" class="i">+        if !update &amp;&amp; !txn.get(&amp;self.name, idslice)?.is_empty() {
</a><a href="#h3-3-24" id="h3-3-24" class="i">+            return errinput!(&quot;primary key {id} already exists&quot;);
</a><a href="#h3-3-25" id="h3-3-25" class="i">+        }
</a><a href="#h3-3-26" id="h3-3-26" class="i">+
</a><a href="#h3-3-27" id="h3-3-27" class="i">+        for (i, (column, value)) in self.columns.iter().zip(row).enumerate() {
</a><a href="#h3-3-28" id="h3-3-28" class="i">+            let (cname, ctype) = (&amp;column.name, &amp;column.datatype);
</a><a href="#h3-3-29" id="h3-3-29" class="i">+            let valueslice = &amp;row[i..=i];
</a><a href="#h3-3-30" id="h3-3-30" class="i">+
</a>             // Validate datatype.
<a href="#h3-3-32" id="h3-3-32" class="d">-            match value.datatype() {
</a><a href="#h3-3-33" id="h3-3-33" class="d">-                None if column.nullable =&gt; {}
</a><a href="#h3-3-34" id="h3-3-34" class="d">-                None =&gt; return errinput!(&quot;NULL value not allowed for column {}&quot;, column.name),
</a><a href="#h3-3-35" id="h3-3-35" class="d">-                Some(ref datatype) if datatype != &amp;column.datatype =&gt; {
</a><a href="#h3-3-36" id="h3-3-36" class="d">-                    return errinput!(
</a><a href="#h3-3-37" id="h3-3-37" class="d">-                        &quot;invalid datatype {} for {} column {}&quot;,
</a><a href="#h3-3-38" id="h3-3-38" class="d">-                        datatype,
</a><a href="#h3-3-39" id="h3-3-39" class="d">-                        column.datatype,
</a><a href="#h3-3-40" id="h3-3-40" class="d">-                        column.name
</a><a href="#h3-3-41" id="h3-3-41" class="d">-                    )
</a><a href="#h3-3-42" id="h3-3-42" class="i">+            if let Some(ref vtype) = value.datatype() {
</a><a href="#h3-3-43" id="h3-3-43" class="i">+                if vtype != ctype {
</a><a href="#h3-3-44" id="h3-3-44" class="i">+                    return errinput!(&quot;invalid datatype {vtype} for {ctype} column {cname}&quot;);
</a>                 }
<a href="#h3-3-46" id="h3-3-46" class="d">-                _ =&gt; {}
</a><a href="#h3-3-47" id="h3-3-47" class="i">+            }
</a><a href="#h3-3-48" id="h3-3-48" class="i">+            if value == &amp;Value::Null &amp;&amp; !column.nullable {
</a><a href="#h3-3-49" id="h3-3-49" class="i">+                return errinput!(&quot;NULL value not allowed for column {cname}&quot;);
</a>             }
 
<a href="#h3-3-52" id="h3-3-52" class="d">-            // Validate value
</a><a href="#h3-3-53" id="h3-3-53" class="d">-            match value {
</a><a href="#h3-3-54" id="h3-3-54" class="d">-                Value::String(s) if s.len() &gt; 1024 =&gt; {
</a><a href="#h3-3-55" id="h3-3-55" class="d">-                    errinput!(&quot;strings cannot be more than 1024 bytes&quot;)
</a><a href="#h3-3-56" id="h3-3-56" class="d">-                }
</a><a href="#h3-3-57" id="h3-3-57" class="d">-                _ =&gt; Ok(()),
</a><a href="#h3-3-58" id="h3-3-58" class="d">-            }?;
</a><a href="#h3-3-59" id="h3-3-59" class="d">-
</a><a href="#h3-3-60" id="h3-3-60" class="d">-            // Validate outgoing references
</a><a href="#h3-3-61" id="h3-3-61" class="i">+            // Validate outgoing references.
</a>             if let Some(target) = &amp;column.references {
                 match value {
<a href="#h3-3-64" id="h3-3-64" class="d">-                    Value::Null =&gt; Ok(()),
</a><a href="#h3-3-65" id="h3-3-65" class="d">-                    Value::Float(f) if f.is_nan() =&gt; Ok(()),
</a><a href="#h3-3-66" id="h3-3-66" class="d">-                    v if target == &amp;self.name &amp;&amp; v == pk =&gt; Ok(()),
</a><a href="#h3-3-67" id="h3-3-67" class="d">-                    v if txn.get(target, &amp;[v.clone()])?.is_empty() =&gt; {
</a><a href="#h3-3-68" id="h3-3-68" class="d">-                        errinput!(&quot;referenced primary key {v} in table {target} does not exist&quot;,)
</a><a href="#h3-3-69" id="h3-3-69" class="i">+                    v if v.is_unknown() =&gt; {}
</a><a href="#h3-3-70" id="h3-3-70" class="i">+                    v if target == &amp;self.name &amp;&amp; v == id =&gt; {}
</a><a href="#h3-3-71" id="h3-3-71" class="i">+                    v if txn.get(target, valueslice)?.is_empty() =&gt; {
</a><a href="#h3-3-72" id="h3-3-72" class="i">+                        return errinput!(&quot;reference {v} not in table {target}&quot;);
</a>                     }
<a href="#h3-3-74" id="h3-3-74" class="d">-                    _ =&gt; Ok(()),
</a><a href="#h3-3-75" id="h3-3-75" class="d">-                }?;
</a><a href="#h3-3-76" id="h3-3-76" class="i">+                    _ =&gt; {}
</a><a href="#h3-3-77" id="h3-3-77" class="i">+                }
</a>             }
 
<a href="#h3-3-80" id="h3-3-80" class="d">-            // Validate uniqueness constraints.
</a><a href="#h3-3-81" id="h3-3-81" class="d">-            // TODO: this needs an index lookup.
</a><a href="#h3-3-82" id="h3-3-82" class="d">-            if column.unique &amp;&amp; i != self.primary_key &amp;&amp; value != &amp;Value::Null {
</a><a href="#h3-3-83" id="h3-3-83" class="d">-                let index = self.get_column_index(&amp;column.name)?;
</a><a href="#h3-3-84" id="h3-3-84" class="d">-                let mut scan = txn.scan(&amp;self.name, None)?;
</a><a href="#h3-3-85" id="h3-3-85" class="d">-                while let Some(row) = scan.next().transpose()? {
</a><a href="#h3-3-86" id="h3-3-86" class="d">-                    if row.get(index).unwrap_or(&amp;Value::Null) == value
</a><a href="#h3-3-87" id="h3-3-87" class="d">-                        &amp;&amp; self.get_row_key(&amp;row)? != pk
</a><a href="#h3-3-88" id="h3-3-88" class="d">-                    {
</a><a href="#h3-3-89" id="h3-3-89" class="d">-                        return errinput!(
</a><a href="#h3-3-90" id="h3-3-90" class="d">-                            &quot;unique value {value} already exists for column {}&quot;,
</a><a href="#h3-3-91" id="h3-3-91" class="d">-                            column.name
</a><a href="#h3-3-92" id="h3-3-92" class="d">-                        );
</a><a href="#h3-3-93" id="h3-3-93" class="d">-                    }
</a><a href="#h3-3-94" id="h3-3-94" class="i">+            // Validate uniqueness constraints. Unique columns are indexed.
</a><a href="#h3-3-95" id="h3-3-95" class="i">+            if column.unique &amp;&amp; i != self.primary_key &amp;&amp; !value.is_unknown() {
</a><a href="#h3-3-96" id="h3-3-96" class="i">+                let mut index = txn.lookup_index(&amp;self.name, &amp;column.name, valueslice)?;
</a><a href="#h3-3-97" id="h3-3-97" class="i">+                if update {
</a><a href="#h3-3-98" id="h3-3-98" class="i">+                    index.remove(id); // ignore existing version of this row
</a><a href="#h3-3-99" id="h3-3-99" class="i">+                }
</a><a href="#h3-3-100" id="h3-3-100" class="i">+                if !index.is_empty() {
</a><a href="#h3-3-101" id="h3-3-101" class="i">+                    return errinput!(&quot;value {value} already in unique column {cname}&quot;);
</a>                 }
             }
         }
<b>diff --git a/<a id="h4" href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a> b/<a href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -111,6 +111,15 @@ impl Value {
</a>             Self::String(_) =&gt; Some(DataType::String),
         }
     }
<a href="#h4-0-3" id="h4-0-3" class="i">+
</a><a href="#h4-0-4" id="h4-0-4" class="i">+    /// Returns true if the value is unknown (NULL or NaN).
</a><a href="#h4-0-5" id="h4-0-5" class="i">+    pub fn is_unknown(&amp;self) -&gt; bool {
</a><a href="#h4-0-6" id="h4-0-6" class="i">+        match self {
</a><a href="#h4-0-7" id="h4-0-7" class="i">+            Self::Null =&gt; true,
</a><a href="#h4-0-8" id="h4-0-8" class="i">+            Self::Float(f) if f.is_nan() =&gt; true,
</a><a href="#h4-0-9" id="h4-0-9" class="i">+            _ =&gt; false,
</a><a href="#h4-0-10" id="h4-0-10" class="i">+        }
</a><a href="#h4-0-11" id="h4-0-11" class="i">+    }
</a> }
 
 impl std::fmt::Display for Value {
<b>diff --git a/<a id="h5" href="../file/tests/e2e/client.rs.html">tests/e2e/client.rs</a> b/<a href="../file/tests/e2e/client.rs.html">tests/e2e/client.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -186,7 +186,7 @@ fn execute() -&gt; Result&lt;()&gt; {
</a>     // INSERT
     assert_eq!(
         c.execute(&quot;INSERT INTO genres VALUES (1, &#39;Western&#39;)&quot;),
<a href="#h5-0-3" id="h5-0-3" class="d">-        Err(Error::InvalidInput(&quot;primary key 1 already exists for table genres&quot;.into())),
</a><a href="#h5-0-4" id="h5-0-4" class="i">+        Err(Error::InvalidInput(&quot;primary key 1 already exists&quot;.into())),
</a>     );
     assert_eq!(
         c.execute(&quot;INSERT INTO genres VALUES (9, &#39;Western&#39;)&quot;),
<a href="#h5-1" id="h5-1" class="h">@@ -208,7 +208,7 @@ fn execute() -&gt; Result&lt;()&gt; {
</a>     );
     assert_eq!(
         c.execute(&quot;UPDATE genres SET id = 1 WHERE id = 9&quot;),
<a href="#h5-1-3" id="h5-1-3" class="d">-        Err(Error::InvalidInput(&quot;primary key 1 already exists for table genres&quot;.into()))
</a><a href="#h5-1-4" id="h5-1-4" class="i">+        Err(Error::InvalidInput(&quot;primary key 1 already exists&quot;.into()))
</a>     );
 
     // DELETE
<a href="#h5-2" id="h5-2" class="h">@@ -300,7 +300,7 @@ fn execute_txn() -&gt; Result&lt;()&gt; {
</a>     c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Horror&#39;)&quot;)?;
     assert_eq!(
         c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;),
<a href="#h5-2-3" id="h5-2-3" class="d">-        Err(Error::InvalidInput(&quot;primary key 5 already exists for table genres&quot;.into()))
</a><a href="#h5-2-4" id="h5-2-4" class="i">+        Err(Error::InvalidInput(&quot;primary key 5 already exists&quot;.into()))
</a>     );
     assert_eq!(c.txn(), Some((4, false)));
     c.execute(&quot;INSERT INTO genres VALUES (6, &#39;Western&#39;)&quot;)?;
<b>diff --git a/<a id="h6" href="../file/tests/sql/mutation/delete_where_float.html">tests/sql/mutation/delete_where_float</a> b/<a href="../file/tests/sql/mutation/delete_where_float.html">tests/sql/mutation/delete_where_float</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,5 +1,5 @@
</a> Query: DELETE FROM test WHERE 3.14
<a href="#h6-0-1" id="h6-0-1" class="d">-Error: InvalidData(&quot;filter returned 3.14, expected boolean&quot;)
</a><a href="#h6-0-2" id="h6-0-2" class="i">+Error: InvalidInput(&quot;filter returned 3.14, expected boolean&quot;)
</a> 
 Storage:
 CREATE TABLE other (
<b>diff --git a/<a id="h7" href="../file/tests/sql/mutation/delete_where_integer.html">tests/sql/mutation/delete_where_integer</a> b/<a href="../file/tests/sql/mutation/delete_where_integer.html">tests/sql/mutation/delete_where_integer</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -1,5 +1,5 @@
</a> Query: DELETE FROM test WHERE 1
<a href="#h7-0-1" id="h7-0-1" class="d">-Error: InvalidData(&quot;filter returned 1, expected boolean&quot;)
</a><a href="#h7-0-2" id="h7-0-2" class="i">+Error: InvalidInput(&quot;filter returned 1, expected boolean&quot;)
</a> 
 Storage:
 CREATE TABLE other (
<b>diff --git a/<a id="h8" href="../file/tests/sql/mutation/delete_where_string.html">tests/sql/mutation/delete_where_string</a> b/<a href="../file/tests/sql/mutation/delete_where_string.html">tests/sql/mutation/delete_where_string</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -1,5 +1,5 @@
</a> Query: DELETE FROM test WHERE &#39;a&#39;
<a href="#h8-0-1" id="h8-0-1" class="d">-Error: InvalidData(&quot;filter returned a, expected boolean&quot;)
</a><a href="#h8-0-2" id="h8-0-2" class="i">+Error: InvalidInput(&quot;filter returned a, expected boolean&quot;)
</a> 
 Storage:
 CREATE TABLE other (
<b>diff --git a/<a id="h9" href="../file/tests/sql/mutation/update_where_float.html">tests/sql/mutation/update_where_float</a> b/<a href="../file/tests/sql/mutation/update_where_float.html">tests/sql/mutation/update_where_float</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE test SET name = &#39;x&#39; WHERE 3.14
<a href="#h9-0-1" id="h9-0-1" class="d">-Error: InvalidData(&quot;filter returned 3.14, expected boolean&quot;)
</a><a href="#h9-0-2" id="h9-0-2" class="i">+Error: InvalidInput(&quot;filter returned 3.14, expected boolean&quot;)
</a> 
 Storage:
 CREATE TABLE other (
<b>diff --git a/<a id="h10" href="../file/tests/sql/mutation/update_where_integer.html">tests/sql/mutation/update_where_integer</a> b/<a href="../file/tests/sql/mutation/update_where_integer.html">tests/sql/mutation/update_where_integer</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE test SET name = &#39;x&#39; WHERE 1
<a href="#h10-0-1" id="h10-0-1" class="d">-Error: InvalidData(&quot;filter returned 1, expected boolean&quot;)
</a><a href="#h10-0-2" id="h10-0-2" class="i">+Error: InvalidInput(&quot;filter returned 1, expected boolean&quot;)
</a> 
 Storage:
 CREATE TABLE other (
<b>diff --git a/<a id="h11" href="../file/tests/sql/mutation/update_where_string.html">tests/sql/mutation/update_where_string</a> b/<a href="../file/tests/sql/mutation/update_where_string.html">tests/sql/mutation/update_where_string</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE test SET name = &#39;x&#39; WHERE &#39;a&#39;
<a href="#h11-0-1" id="h11-0-1" class="d">-Error: InvalidData(&quot;filter returned a, expected boolean&quot;)
</a><a href="#h11-0-2" id="h11-0-2" class="i">+Error: InvalidInput(&quot;filter returned a, expected boolean&quot;)
</a> 
 Storage:
 CREATE TABLE other (
<b>diff --git a/<a id="h12" href="../file/tests/sql/query/where_float.html">tests/sql/query/where_float</a> b/<a href="../file/tests/sql/query/where_float.html">tests/sql/query/where_float</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -3,7 +3,7 @@ Query: SELECT * FROM movies WHERE 3.14
</a> Explain:
 Scan: movies (3.14)
 
<a href="#h12-0-3" id="h12-0-3" class="d">-Error: invalid data: filter returned 3.14, expected boolean
</a><a href="#h12-0-4" id="h12-0-4" class="i">+Error: invalid input: filter returned 3.14, expected boolean
</a> 
 AST: Select {
     select: [],
<b>diff --git a/<a id="h13" href="../file/tests/sql/query/where_integer.html">tests/sql/query/where_integer</a> b/<a href="../file/tests/sql/query/where_integer.html">tests/sql/query/where_integer</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -3,7 +3,7 @@ Query: SELECT * FROM movies WHERE 7
</a> Explain:
 Scan: movies (7)
 
<a href="#h13-0-3" id="h13-0-3" class="d">-Error: invalid data: filter returned 7, expected boolean
</a><a href="#h13-0-4" id="h13-0-4" class="i">+Error: invalid input: filter returned 7, expected boolean
</a> 
 AST: Select {
     select: [],
<b>diff --git a/<a id="h14" href="../file/tests/sql/query/where_string.html">tests/sql/query/where_string</a> b/<a href="../file/tests/sql/query/where_string.html">tests/sql/query/where_string</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -3,7 +3,7 @@ Query: SELECT * FROM movies WHERE &#39;abc&#39;
</a> Explain:
 Scan: movies (abc)
 
<a href="#h14-0-3" id="h14-0-3" class="d">-Error: invalid data: filter returned abc, expected boolean
</a><a href="#h14-0-4" id="h14-0-4" class="i">+Error: invalid input: filter returned abc, expected boolean
</a> 
 AST: Select {
     select: [],
<b>diff --git a/<a id="h15" href="../file/tests/sql/schema.rs.html">tests/sql/schema.rs</a> b/<a href="../file/tests/sql/schema.rs.html">tests/sql/schema.rs</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -207,10 +207,6 @@ test_schema! { with [
</a>     insert_string: r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;abc&#39;)&quot;#,
     insert_string_empty: r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;&#39;)&quot;#,
     insert_string_unicode: r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39; Hi! 👋&#39;)&quot;#,
<a href="#h15-0-3" id="h15-0-3" class="d">-    insert_string_1024: &amp;format!(r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;{}&#39;)&quot;#, &quot;a&quot;.repeat(1024)),
</a><a href="#h15-0-4" id="h15-0-4" class="d">-    insert_string_1025: &amp;format!(r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;{}&#39;)&quot;#, &quot;a&quot;.repeat(1025)),
</a><a href="#h15-0-5" id="h15-0-5" class="d">-    insert_string_1024_unicode: &amp;format!(r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;{}&#39;)&quot;#, &quot;𐍈&quot;.repeat(256)),
</a><a href="#h15-0-6" id="h15-0-6" class="d">-    insert_string_1025_unicode: &amp;format!(r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;{}x&#39;)&quot;#, &quot;𐍈&quot;.repeat(256)),
</a>     insert_string_null: r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, NULL)&quot;#,
     insert_string_boolean: r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, FALSE)&quot;#,
     insert_string_float: r#&quot;INSERT INTO types (id, &quot;string&quot;) VALUES (0, 3.14)&quot;#,
<b>diff --git a/<a id="h16" href="../file/tests/sql/schema/delete_ref_conflict.html">tests/sql/schema/delete_ref_conflict</a> b/<a href="../file/tests/sql/schema/delete_ref_conflict.html">tests/sql/schema/delete_ref_conflict</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -1,5 +1,5 @@
</a> Query: DELETE FROM target WHERE id = 1
<a href="#h16-0-1" id="h16-0-1" class="d">-Error: InvalidInput(&quot;primary key 1 referenced by table source column target_id&quot;)
</a><a href="#h16-0-2" id="h16-0-2" class="i">+Error: InvalidInput(&quot;row referenced by source.target_id for source.id=1&quot;)
</a> 
 Storage:
 CREATE TABLE source (
<b>diff --git a/<a id="h17" href="../file/tests/sql/schema/delete_ref_self_all.html">tests/sql/schema/delete_ref_self_all</a> b/<a href="../file/tests/sql/schema/delete_ref_self_all.html">tests/sql/schema/delete_ref_self_all</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -1,5 +1,5 @@
</a> Query: DELETE FROM self
<a href="#h17-0-1" id="h17-0-1" class="d">-Error: InvalidInput(&quot;primary key 1 referenced by table self column self_id&quot;)
</a><a href="#h17-0-2" id="h17-0-2" class="i">+Result: Delete { count: 4 }
</a> 
 Storage:
 CREATE TABLE self (
<a href="#h17-1" id="h17-1" class="h">@@ -7,12 +7,5 @@ CREATE TABLE self (
</a>   self_id INTEGER DEFAULT NULL INDEX REFERENCES self,
   value STRING DEFAULT NULL
 )
<a href="#h17-1-3" id="h17-1-3" class="d">-[Integer(1), Integer(1), String(&quot;a&quot;)]
</a><a href="#h17-1-4" id="h17-1-4" class="d">-[Integer(2), Integer(1), String(&quot;b&quot;)]
</a><a href="#h17-1-5" id="h17-1-5" class="d">-[Integer(3), Integer(3), String(&quot;c&quot;)]
</a><a href="#h17-1-6" id="h17-1-6" class="d">-[Integer(4), Null, String(&quot;d&quot;)]
</a> 
 Index self.self_id
<a href="#h17-1-9" id="h17-1-9" class="d">-Null =&gt; [Integer(4)]
</a><a href="#h17-1-10" id="h17-1-10" class="d">-Integer(1) =&gt; [Integer(1), Integer(2)]
</a><a href="#h17-1-11" id="h17-1-11" class="d">-Integer(3) =&gt; [Integer(3)]
</a><b>diff --git a/<a id="h18" href="../file/tests/sql/schema/delete_ref_self_conflict.html">tests/sql/schema/delete_ref_self_conflict</a> b/<a href="../file/tests/sql/schema/delete_ref_self_conflict.html">tests/sql/schema/delete_ref_self_conflict</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -1,5 +1,5 @@
</a> Query: DELETE FROM self WHERE id = 1
<a href="#h18-0-1" id="h18-0-1" class="d">-Error: InvalidInput(&quot;primary key 1 referenced by table self column self_id&quot;)
</a><a href="#h18-0-2" id="h18-0-2" class="i">+Error: InvalidInput(&quot;row referenced by self.self_id for self.id=2&quot;)
</a> 
 Storage:
 CREATE TABLE self (
<b>diff --git a/<a id="h19" href="../file/tests/sql/schema/drop_table_ref_target.html">tests/sql/schema/drop_table_ref_target</a> b/<a href="../file/tests/sql/schema/drop_table_ref_target.html">tests/sql/schema/drop_table_ref_target</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -1,5 +1,5 @@
</a> Query: DROP TABLE target
<a href="#h19-0-1" id="h19-0-1" class="d">-Error: InvalidInput(&quot;table target is referenced by table source column target_id&quot;)
</a><a href="#h19-0-2" id="h19-0-2" class="i">+Error: InvalidInput(&quot;table target is referenced from source.target_id&quot;)
</a> 
 Storage:
 CREATE TABLE self (
<b>diff --git a/<a id="h20" href="../file/tests/sql/schema/insert_pk_boolean_conflict.html">tests/sql/schema/insert_pk_boolean_conflict</a> b/<a href="../file/tests/sql/schema/insert_pk_boolean_conflict.html">tests/sql/schema/insert_pk_boolean_conflict</a></b>
<a href="#h20-0" id="h20-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;boolean&quot; VALUES (FALSE)
<a href="#h20-0-1" id="h20-0-1" class="d">-Error: InvalidInput(&quot;primary key FALSE already exists for table boolean&quot;)
</a><a href="#h20-0-2" id="h20-0-2" class="i">+Error: InvalidInput(&quot;primary key FALSE already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;boolean&quot; (
<b>diff --git a/<a id="h21" href="../file/tests/sql/schema/insert_pk_float_conflict.html">tests/sql/schema/insert_pk_float_conflict</a> b/<a href="../file/tests/sql/schema/insert_pk_float_conflict.html">tests/sql/schema/insert_pk_float_conflict</a></b>
<a href="#h21-0" id="h21-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;float&quot; VALUES (3.14)
<a href="#h21-0-1" id="h21-0-1" class="d">-Error: InvalidInput(&quot;primary key 3.14 already exists for table float&quot;)
</a><a href="#h21-0-2" id="h21-0-2" class="i">+Error: InvalidInput(&quot;primary key 3.14 already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;float&quot; (
<b>diff --git a/<a id="h22" href="../file/tests/sql/schema/insert_pk_float_infinity.html">tests/sql/schema/insert_pk_float_infinity</a> b/<a href="../file/tests/sql/schema/insert_pk_float_infinity.html">tests/sql/schema/insert_pk_float_infinity</a></b>
<a href="#h22-0" id="h22-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;float&quot; VALUES (INFINITY)
<a href="#h22-0-1" id="h22-0-1" class="d">-Error: InvalidInput(&quot;primary key inf already exists for table float&quot;)
</a><a href="#h22-0-2" id="h22-0-2" class="i">+Error: InvalidInput(&quot;primary key inf already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;float&quot; (
<b>diff --git a/<a id="h23" href="../file/tests/sql/schema/insert_pk_float_nan.html">tests/sql/schema/insert_pk_float_nan</a> b/<a href="../file/tests/sql/schema/insert_pk_float_nan.html">tests/sql/schema/insert_pk_float_nan</a></b>
<a href="#h23-0" id="h23-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;float&quot; VALUES (NAN)
<a href="#h23-0-1" id="h23-0-1" class="d">-Error: InvalidInput(&quot;primary key NaN already exists for table float&quot;)
</a><a href="#h23-0-2" id="h23-0-2" class="i">+Error: InvalidInput(&quot;primary key NaN already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;float&quot; (
<b>diff --git a/<a id="h24" href="../file/tests/sql/schema/insert_pk_integer_conflict.html">tests/sql/schema/insert_pk_integer_conflict</a> b/<a href="../file/tests/sql/schema/insert_pk_integer_conflict.html">tests/sql/schema/insert_pk_integer_conflict</a></b>
<a href="#h24-0" id="h24-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;integer&quot; VALUES (1)
<a href="#h24-0-1" id="h24-0-1" class="d">-Error: InvalidInput(&quot;primary key 1 already exists for table integer&quot;)
</a><a href="#h24-0-2" id="h24-0-2" class="i">+Error: InvalidInput(&quot;primary key 1 already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;integer&quot; (
<b>diff --git a/<a id="h25" href="../file/tests/sql/schema/insert_pk_string_conflict.html">tests/sql/schema/insert_pk_string_conflict</a> b/<a href="../file/tests/sql/schema/insert_pk_string_conflict.html">tests/sql/schema/insert_pk_string_conflict</a></b>
<a href="#h25-0" id="h25-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;string&quot; VALUES (&#39;foo&#39;)
<a href="#h25-0-1" id="h25-0-1" class="d">-Error: InvalidInput(&quot;primary key foo already exists for table string&quot;)
</a><a href="#h25-0-2" id="h25-0-2" class="i">+Error: InvalidInput(&quot;primary key foo already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;string&quot; (
<b>diff --git a/<a id="h26" href="../file/tests/sql/schema/insert_ref_boolean_missing.html">tests/sql/schema/insert_ref_boolean_missing</a> b/<a href="../file/tests/sql/schema/insert_ref_boolean_missing.html">tests/sql/schema/insert_ref_boolean_missing</a></b>
<a href="#h26-0" id="h26-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO source VALUES (1, FALSE)
<a href="#h26-0-1" id="h26-0-1" class="d">-Error: InvalidInput(&quot;referenced primary key FALSE in table target does not exist&quot;)
</a><a href="#h26-0-2" id="h26-0-2" class="i">+Error: InvalidInput(&quot;reference FALSE not in table target&quot;)
</a> 
 Storage:
 CREATE TABLE source (
<b>diff --git a/<a id="h27" href="../file/tests/sql/schema/insert_ref_float_missing.html">tests/sql/schema/insert_ref_float_missing</a> b/<a href="../file/tests/sql/schema/insert_ref_float_missing.html">tests/sql/schema/insert_ref_float_missing</a></b>
<a href="#h27-0" id="h27-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO source VALUES (1, 1.618)
<a href="#h27-0-1" id="h27-0-1" class="d">-Error: InvalidInput(&quot;referenced primary key 1.618 in table target does not exist&quot;)
</a><a href="#h27-0-2" id="h27-0-2" class="i">+Error: InvalidInput(&quot;reference 1.618 not in table target&quot;)
</a> 
 Storage:
 CREATE TABLE source (
<b>diff --git a/<a id="h28" href="../file/tests/sql/schema/insert_ref_integer_missing.html">tests/sql/schema/insert_ref_integer_missing</a> b/<a href="../file/tests/sql/schema/insert_ref_integer_missing.html">tests/sql/schema/insert_ref_integer_missing</a></b>
<a href="#h28-0" id="h28-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO source VALUES (1, 7)
<a href="#h28-0-1" id="h28-0-1" class="d">-Error: InvalidInput(&quot;referenced primary key 7 in table target does not exist&quot;)
</a><a href="#h28-0-2" id="h28-0-2" class="i">+Error: InvalidInput(&quot;reference 7 not in table target&quot;)
</a> 
 Storage:
 CREATE TABLE source (
<b>diff --git a/<a id="h29" href="../file/tests/sql/schema/insert_ref_self_missing.html">tests/sql/schema/insert_ref_self_missing</a> b/<a href="../file/tests/sql/schema/insert_ref_self_missing.html">tests/sql/schema/insert_ref_self_missing</a></b>
<a href="#h29-0" id="h29-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO self VALUES (5, 9, &#39;e&#39;)
<a href="#h29-0-1" id="h29-0-1" class="d">-Error: InvalidInput(&quot;referenced primary key 9 in table self does not exist&quot;)
</a><a href="#h29-0-2" id="h29-0-2" class="i">+Error: InvalidInput(&quot;reference 9 not in table self&quot;)
</a> 
 Storage:
 CREATE TABLE self (
<b>diff --git a/<a id="h30" href="../file/tests/sql/schema/insert_ref_string_case.html">tests/sql/schema/insert_ref_string_case</a> b/<a href="../file/tests/sql/schema/insert_ref_string_case.html">tests/sql/schema/insert_ref_string_case</a></b>
<a href="#h30-0" id="h30-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO source VALUES (1, &#39;Foo&#39;)
<a href="#h30-0-1" id="h30-0-1" class="d">-Error: InvalidInput(&quot;referenced primary key Foo in table target does not exist&quot;)
</a><a href="#h30-0-2" id="h30-0-2" class="i">+Error: InvalidInput(&quot;reference Foo not in table target&quot;)
</a> 
 Storage:
 CREATE TABLE source (
<b>diff --git a/<a id="h31" href="../file/tests/sql/schema/insert_ref_string_missing.html">tests/sql/schema/insert_ref_string_missing</a> b/<a href="../file/tests/sql/schema/insert_ref_string_missing.html">tests/sql/schema/insert_ref_string_missing</a></b>
<a href="#h31-0" id="h31-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO source VALUES (1, &#39;baz&#39;)
<a href="#h31-0-1" id="h31-0-1" class="d">-Error: InvalidInput(&quot;referenced primary key baz in table target does not exist&quot;)
</a><a href="#h31-0-2" id="h31-0-2" class="i">+Error: InvalidInput(&quot;reference baz not in table target&quot;)
</a> 
 Storage:
 CREATE TABLE source (
<b>diff --git a/<a id="h32" href="../file/tests/sql/schema/insert_string_1024.html">tests/sql/schema/insert_string_1024</a> b/<a href="../file/tests/sql/schema/insert_string_1024.html">tests/sql/schema/insert_string_1024</a></b>
<a href="#h32-0" id="h32-0" class="h">@@ -1,12 +0,0 @@
</a><a href="#h32-0-0" id="h32-0-0" class="d">-Query: INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39;)
</a><a href="#h32-0-1" id="h32-0-1" class="d">-Result: Create { count: 1 }
</a><a href="#h32-0-2" id="h32-0-2" class="d">-
</a><a href="#h32-0-3" id="h32-0-3" class="d">-Storage:
</a><a href="#h32-0-4" id="h32-0-4" class="d">-CREATE TABLE types (
</a><a href="#h32-0-5" id="h32-0-5" class="d">-  id INTEGER PRIMARY KEY,
</a><a href="#h32-0-6" id="h32-0-6" class="d">-  &quot;boolean&quot; BOOLEAN DEFAULT NULL,
</a><a href="#h32-0-7" id="h32-0-7" class="d">-  &quot;float&quot; FLOAT DEFAULT NULL,
</a><a href="#h32-0-8" id="h32-0-8" class="d">-  &quot;integer&quot; INTEGER DEFAULT NULL,
</a><a href="#h32-0-9" id="h32-0-9" class="d">-  &quot;string&quot; STRING DEFAULT NULL
</a><a href="#h32-0-10" id="h32-0-10" class="d">-)
</a><a href="#h32-0-11" id="h32-0-11" class="d">-[Integer(0), Null, Null, Null, String(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;)]
</a><b>diff --git a/<a id="h33" href="../file/tests/sql/schema/insert_string_1024_unicode.html">tests/sql/schema/insert_string_1024_unicode</a> b/<a href="../file/tests/sql/schema/insert_string_1024_unicode.html">tests/sql/schema/insert_string_1024_unicode</a></b>
<a href="#h33-0" id="h33-0" class="h">@@ -1,12 +0,0 @@
</a><a href="#h33-0-0" id="h33-0-0" class="d">-Query: INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈&#39;)
</a><a href="#h33-0-1" id="h33-0-1" class="d">-Result: Create { count: 1 }
</a><a href="#h33-0-2" id="h33-0-2" class="d">-
</a><a href="#h33-0-3" id="h33-0-3" class="d">-Storage:
</a><a href="#h33-0-4" id="h33-0-4" class="d">-CREATE TABLE types (
</a><a href="#h33-0-5" id="h33-0-5" class="d">-  id INTEGER PRIMARY KEY,
</a><a href="#h33-0-6" id="h33-0-6" class="d">-  &quot;boolean&quot; BOOLEAN DEFAULT NULL,
</a><a href="#h33-0-7" id="h33-0-7" class="d">-  &quot;float&quot; FLOAT DEFAULT NULL,
</a><a href="#h33-0-8" id="h33-0-8" class="d">-  &quot;integer&quot; INTEGER DEFAULT NULL,
</a><a href="#h33-0-9" id="h33-0-9" class="d">-  &quot;string&quot; STRING DEFAULT NULL
</a><a href="#h33-0-10" id="h33-0-10" class="d">-)
</a><a href="#h33-0-11" id="h33-0-11" class="d">-[Integer(0), Null, Null, Null, String(&quot;𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈&quot;)]
</a><b>diff --git a/<a id="h34" href="../file/tests/sql/schema/insert_string_1025.html">tests/sql/schema/insert_string_1025</a> b/<a href="../file/tests/sql/schema/insert_string_1025.html">tests/sql/schema/insert_string_1025</a></b>
<a href="#h34-0" id="h34-0" class="h">@@ -1,11 +0,0 @@
</a><a href="#h34-0-0" id="h34-0-0" class="d">-Query: INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39;)
</a><a href="#h34-0-1" id="h34-0-1" class="d">-Error: InvalidInput(&quot;strings cannot be more than 1024 bytes&quot;)
</a><a href="#h34-0-2" id="h34-0-2" class="d">-
</a><a href="#h34-0-3" id="h34-0-3" class="d">-Storage:
</a><a href="#h34-0-4" id="h34-0-4" class="d">-CREATE TABLE types (
</a><a href="#h34-0-5" id="h34-0-5" class="d">-  id INTEGER PRIMARY KEY,
</a><a href="#h34-0-6" id="h34-0-6" class="d">-  &quot;boolean&quot; BOOLEAN DEFAULT NULL,
</a><a href="#h34-0-7" id="h34-0-7" class="d">-  &quot;float&quot; FLOAT DEFAULT NULL,
</a><a href="#h34-0-8" id="h34-0-8" class="d">-  &quot;integer&quot; INTEGER DEFAULT NULL,
</a><a href="#h34-0-9" id="h34-0-9" class="d">-  &quot;string&quot; STRING DEFAULT NULL
</a><a href="#h34-0-10" id="h34-0-10" class="d">-)
</a><b>diff --git a/<a id="h35" href="../file/tests/sql/schema/insert_string_1025_unicode.html">tests/sql/schema/insert_string_1025_unicode</a> b/<a href="../file/tests/sql/schema/insert_string_1025_unicode.html">tests/sql/schema/insert_string_1025_unicode</a></b>
<a href="#h35-0" id="h35-0" class="h">@@ -1,11 +0,0 @@
</a><a href="#h35-0-0" id="h35-0-0" class="d">-Query: INSERT INTO types (id, &quot;string&quot;) VALUES (0, &#39;𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈𐍈x&#39;)
</a><a href="#h35-0-1" id="h35-0-1" class="d">-Error: InvalidInput(&quot;strings cannot be more than 1024 bytes&quot;)
</a><a href="#h35-0-2" id="h35-0-2" class="d">-
</a><a href="#h35-0-3" id="h35-0-3" class="d">-Storage:
</a><a href="#h35-0-4" id="h35-0-4" class="d">-CREATE TABLE types (
</a><a href="#h35-0-5" id="h35-0-5" class="d">-  id INTEGER PRIMARY KEY,
</a><a href="#h35-0-6" id="h35-0-6" class="d">-  &quot;boolean&quot; BOOLEAN DEFAULT NULL,
</a><a href="#h35-0-7" id="h35-0-7" class="d">-  &quot;float&quot; FLOAT DEFAULT NULL,
</a><a href="#h35-0-8" id="h35-0-8" class="d">-  &quot;integer&quot; INTEGER DEFAULT NULL,
</a><a href="#h35-0-9" id="h35-0-9" class="d">-  &quot;string&quot; STRING DEFAULT NULL
</a><a href="#h35-0-10" id="h35-0-10" class="d">-)
</a><b>diff --git a/<a id="h36" href="../file/tests/sql/schema/insert_unique_boolean_duplicate.html">tests/sql/schema/insert_unique_boolean_duplicate</a> b/<a href="../file/tests/sql/schema/insert_unique_boolean_duplicate.html">tests/sql/schema/insert_unique_boolean_duplicate</a></b>
<a href="#h36-0" id="h36-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;unique&quot; (id, &quot;boolean&quot;) VALUES (2, TRUE)
<a href="#h36-0-1" id="h36-0-1" class="d">-Error: InvalidInput(&quot;unique value TRUE already exists for column boolean&quot;)
</a><a href="#h36-0-2" id="h36-0-2" class="i">+Error: InvalidInput(&quot;value TRUE already in unique column boolean&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;unique&quot; (
<b>diff --git a/<a id="h37" href="../file/tests/sql/schema/insert_unique_float_duplicate.html">tests/sql/schema/insert_unique_float_duplicate</a> b/<a href="../file/tests/sql/schema/insert_unique_float_duplicate.html">tests/sql/schema/insert_unique_float_duplicate</a></b>
<a href="#h37-0" id="h37-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;unique&quot; (id, &quot;float&quot;) VALUES (2, 3.14)
<a href="#h37-0-1" id="h37-0-1" class="d">-Error: InvalidInput(&quot;unique value 3.14 already exists for column float&quot;)
</a><a href="#h37-0-2" id="h37-0-2" class="i">+Error: InvalidInput(&quot;value 3.14 already in unique column float&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;unique&quot; (
<b>diff --git a/<a id="h38" href="../file/tests/sql/schema/insert_unique_integer_duplicate.html">tests/sql/schema/insert_unique_integer_duplicate</a> b/<a href="../file/tests/sql/schema/insert_unique_integer_duplicate.html">tests/sql/schema/insert_unique_integer_duplicate</a></b>
<a href="#h38-0" id="h38-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;unique&quot; (id, &quot;integer&quot;) VALUES (2, 7)
<a href="#h38-0-1" id="h38-0-1" class="d">-Error: InvalidInput(&quot;unique value 7 already exists for column integer&quot;)
</a><a href="#h38-0-2" id="h38-0-2" class="i">+Error: InvalidInput(&quot;value 7 already in unique column integer&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;unique&quot; (
<b>diff --git a/<a id="h39" href="../file/tests/sql/schema/insert_unique_string_duplicate.html">tests/sql/schema/insert_unique_string_duplicate</a> b/<a href="../file/tests/sql/schema/insert_unique_string_duplicate.html">tests/sql/schema/insert_unique_string_duplicate</a></b>
<a href="#h39-0" id="h39-0" class="h">@@ -1,5 +1,5 @@
</a> Query: INSERT INTO &quot;unique&quot; (id, &quot;string&quot;) VALUES (2, &#39;foo&#39;)
<a href="#h39-0-1" id="h39-0-1" class="d">-Error: InvalidInput(&quot;unique value foo already exists for column string&quot;)
</a><a href="#h39-0-2" id="h39-0-2" class="i">+Error: InvalidInput(&quot;value foo already in unique column string&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;unique&quot; (
<b>diff --git a/<a id="h40" href="../file/tests/sql/schema/update_pk_float_conflict.html">tests/sql/schema/update_pk_float_conflict</a> b/<a href="../file/tests/sql/schema/update_pk_float_conflict.html">tests/sql/schema/update_pk_float_conflict</a></b>
<a href="#h40-0" id="h40-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE &quot;float&quot; SET pk = 2.718 WHERE pk = 3.14
<a href="#h40-0-1" id="h40-0-1" class="d">-Error: InvalidInput(&quot;primary key 2.718 already exists for table float&quot;)
</a><a href="#h40-0-2" id="h40-0-2" class="i">+Error: InvalidInput(&quot;primary key 2.718 already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;float&quot; (
<b>diff --git a/<a id="h41" href="../file/tests/sql/schema/update_pk_float_conflict_all.html">tests/sql/schema/update_pk_float_conflict_all</a> b/<a href="../file/tests/sql/schema/update_pk_float_conflict_all.html">tests/sql/schema/update_pk_float_conflict_all</a></b>
<a href="#h41-0" id="h41-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE &quot;float&quot; SET pk = 3.14
<a href="#h41-0-1" id="h41-0-1" class="d">-Error: InvalidInput(&quot;primary key 3.14 already exists for table float&quot;)
</a><a href="#h41-0-2" id="h41-0-2" class="i">+Error: InvalidInput(&quot;primary key 3.14 already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;float&quot; (
<b>diff --git a/<a id="h42" href="../file/tests/sql/schema/update_pk_integer_conflict.html">tests/sql/schema/update_pk_integer_conflict</a> b/<a href="../file/tests/sql/schema/update_pk_integer_conflict.html">tests/sql/schema/update_pk_integer_conflict</a></b>
<a href="#h42-0" id="h42-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE &quot;integer&quot; SET pk = 1 WHERE pk = 2
<a href="#h42-0-1" id="h42-0-1" class="d">-Error: InvalidInput(&quot;primary key 1 already exists for table integer&quot;)
</a><a href="#h42-0-2" id="h42-0-2" class="i">+Error: InvalidInput(&quot;primary key 1 already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;integer&quot; (
<b>diff --git a/<a id="h43" href="../file/tests/sql/schema/update_pk_integer_conflict_all.html">tests/sql/schema/update_pk_integer_conflict_all</a> b/<a href="../file/tests/sql/schema/update_pk_integer_conflict_all.html">tests/sql/schema/update_pk_integer_conflict_all</a></b>
<a href="#h43-0" id="h43-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE &quot;integer&quot; SET pk = 1
<a href="#h43-0-1" id="h43-0-1" class="d">-Error: InvalidInput(&quot;primary key 1 already exists for table integer&quot;)
</a><a href="#h43-0-2" id="h43-0-2" class="i">+Error: InvalidInput(&quot;primary key 1 already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;integer&quot; (
<b>diff --git a/<a id="h44" href="../file/tests/sql/schema/update_pk_string_conflict.html">tests/sql/schema/update_pk_string_conflict</a> b/<a href="../file/tests/sql/schema/update_pk_string_conflict.html">tests/sql/schema/update_pk_string_conflict</a></b>
<a href="#h44-0" id="h44-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE &quot;string&quot; SET pk = &#39;bar&#39; WHERE pk = &#39;foo&#39;
<a href="#h44-0-1" id="h44-0-1" class="d">-Error: InvalidInput(&quot;primary key bar already exists for table string&quot;)
</a><a href="#h44-0-2" id="h44-0-2" class="i">+Error: InvalidInput(&quot;primary key bar already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;string&quot; (
<b>diff --git a/<a id="h45" href="../file/tests/sql/schema/update_pk_string_conflict_all.html">tests/sql/schema/update_pk_string_conflict_all</a> b/<a href="../file/tests/sql/schema/update_pk_string_conflict_all.html">tests/sql/schema/update_pk_string_conflict_all</a></b>
<a href="#h45-0" id="h45-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE &quot;string&quot; SET pk = &#39;foo&#39;
<a href="#h45-0-1" id="h45-0-1" class="d">-Error: InvalidInput(&quot;primary key foo already exists for table string&quot;)
</a><a href="#h45-0-2" id="h45-0-2" class="i">+Error: InvalidInput(&quot;primary key foo already exists&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;string&quot; (
<b>diff --git a/<a id="h46" href="../file/tests/sql/schema/update_ref_pk.html">tests/sql/schema/update_ref_pk</a> b/<a href="../file/tests/sql/schema/update_ref_pk.html">tests/sql/schema/update_ref_pk</a></b>
<a href="#h46-0" id="h46-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE target SET id = 9 WHERE id = 1
<a href="#h46-0-1" id="h46-0-1" class="d">-Error: InvalidInput(&quot;primary key 1 referenced by table source column target_id&quot;)
</a><a href="#h46-0-2" id="h46-0-2" class="i">+Error: InvalidInput(&quot;row referenced by source.target_id for source.id=1&quot;)
</a> 
 Storage:
 CREATE TABLE source (
<b>diff --git a/<a id="h47" href="../file/tests/sql/schema/update_ref_self_pk.html">tests/sql/schema/update_ref_self_pk</a> b/<a href="../file/tests/sql/schema/update_ref_self_pk.html">tests/sql/schema/update_ref_self_pk</a></b>
<a href="#h47-0" id="h47-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE self SET id = 9 WHERE id = 1
<a href="#h47-0-1" id="h47-0-1" class="d">-Error: InvalidInput(&quot;primary key 1 referenced by table self column self_id&quot;)
</a><a href="#h47-0-2" id="h47-0-2" class="i">+Error: InvalidInput(&quot;row referenced by self.self_id for self.id=2&quot;)
</a> 
 Storage:
 CREATE TABLE self (
<b>diff --git a/<a id="h48" href="../file/tests/sql/schema/update_ref_source_missing.html">tests/sql/schema/update_ref_source_missing</a> b/<a href="../file/tests/sql/schema/update_ref_source_missing.html">tests/sql/schema/update_ref_source_missing</a></b>
<a href="#h48-0" id="h48-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE source SET target_id = 9 WHERE id = 4
<a href="#h48-0-1" id="h48-0-1" class="d">-Error: InvalidInput(&quot;referenced primary key 9 in table target does not exist&quot;)
</a><a href="#h48-0-2" id="h48-0-2" class="i">+Error: InvalidInput(&quot;reference 9 not in table target&quot;)
</a> 
 Storage:
 CREATE TABLE source (
<b>diff --git a/<a id="h49" href="../file/tests/sql/schema/update_unique_boolean_duplicate.html">tests/sql/schema/update_unique_boolean_duplicate</a> b/<a href="../file/tests/sql/schema/update_unique_boolean_duplicate.html">tests/sql/schema/update_unique_boolean_duplicate</a></b>
<a href="#h49-0" id="h49-0" class="h">@@ -1,5 +1,5 @@
</a> Query: UPDATE &quot;unique&quot; SET &quot;boolean&quot; = TRUE WHERE id = 0
<a href="#h49-0-1" id="h49-0-1" class="d">-Error: InvalidInput(&quot;unique value TRUE already exists for column boolean&quot;)
</a><a href="#h49-0-2" id="h49-0-2" class="i">+Error: InvalidInput(&quot;value TRUE already in unique column boolean&quot;)
</a> 
 Storage:
 CREATE TABLE &quot;unique&quot; (
</pre>
</div>
</body>
</html>
