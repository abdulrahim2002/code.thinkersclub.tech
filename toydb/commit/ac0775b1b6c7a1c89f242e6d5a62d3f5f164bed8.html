<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Use TransactionState to bundle a Transaction&#39;s internal state. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/ac0775b1b6c7a1c89f242e6d5a62d3f5f164bed8.html">ac0775b1b6c7a1c89f242e6d5a62d3f5f164bed8</a>
<b>parent</b> <a href="../commit/29481598538c9fbc4143bcb062b335ec7e4a3cf1.html">29481598538c9fbc4143bcb062b335ec7e4a3cf1</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Fri,  8 Sep 2023 10:00:50 +0200

Use TransactionState to bundle a Transaction&#39;s internal state.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/storage/mvcc.rs</a></td><td> | </td><td class="num">133</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
</table></pre><pre>2 files changed, 66 insertions(+), 69 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -85,7 +85,7 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>     }
 
     /// Returns the transaction&#39;s serialized state.
<a href="#h0-0-3" id="h0-0-3" class="d">-    pub(super) fn state(&amp;self) -&gt; storage::mvcc::TransactionState {
</a><a href="#h0-0-4" id="h0-0-4" class="i">+    pub(super) fn state(&amp;self) -&gt; &amp;storage::mvcc::TransactionState {
</a>         self.txn.state()
     }
 
<b>diff --git a/<a id="h1" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -160,29 +160,48 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a> pub struct Transaction&lt;E: Engine&gt; {
     /// The underlying engine for the transaction. Shared between transactions using a mutex.
     engine: Arc&lt;Mutex&lt;E&gt;&gt;,
<a href="#h1-0-3" id="h1-0-3" class="i">+    /// The transaction state.
</a><a href="#h1-0-4" id="h1-0-4" class="i">+    st: TransactionState,
</a><a href="#h1-0-5" id="h1-0-5" class="i">+}
</a><a href="#h1-0-6" id="h1-0-6" class="i">+
</a><a href="#h1-0-7" id="h1-0-7" class="i">+/// A Transaction&#39;s state, which determines its write version and isolation. It
</a><a href="#h1-0-8" id="h1-0-8" class="i">+/// is separate from Transaction to allow it to be passed around independently
</a><a href="#h1-0-9" id="h1-0-9" class="i">+/// of the engine. There are two main motivations for this:
</a><a href="#h1-0-10" id="h1-0-10" class="i">+///
</a><a href="#h1-0-11" id="h1-0-11" class="i">+/// - It can be exported via Transaction.state(), (de)serialied, and later used
</a><a href="#h1-0-12" id="h1-0-12" class="i">+///   to instantiate a new functionally equivalent Transaction via
</a><a href="#h1-0-13" id="h1-0-13" class="i">+///   Transaction::resume(). This allows passing the transaction between the
</a><a href="#h1-0-14" id="h1-0-14" class="i">+///   storage engine and SQL engine (potentially running on a different node)
</a><a href="#h1-0-15" id="h1-0-15" class="i">+///   across the Raft state machine boundary.
</a><a href="#h1-0-16" id="h1-0-16" class="i">+///
</a><a href="#h1-0-17" id="h1-0-17" class="i">+/// - It can be borrowed independently of Engine, allowing references to it
</a><a href="#h1-0-18" id="h1-0-18" class="i">+///   in VisibleIterator, which would otherwise result in self-references.
</a><a href="#h1-0-19" id="h1-0-19" class="i">+#[derive(Clone, Serialize, Deserialize)]
</a><a href="#h1-0-20" id="h1-0-20" class="i">+pub struct TransactionState {
</a>     /// The version this transaction is running at. Only one read-write
     /// transaction can run at a given version, since this identifies its
     /// writes.
<a href="#h1-0-24" id="h1-0-24" class="d">-    version: Version,
</a><a href="#h1-0-25" id="h1-0-25" class="i">+    pub version: Version,
</a>     /// If true, the transaction is read only.
<a href="#h1-0-27" id="h1-0-27" class="d">-    read_only: bool,
</a><a href="#h1-0-28" id="h1-0-28" class="i">+    pub read_only: bool,
</a>     /// The set of concurrent active (uncommitted) transactions, as of the start
     /// of this transaction. Their writes should be invisible to this
     /// transaction even if they&#39;re writing at a lower version, since they&#39;re
     /// not committed yet.
<a href="#h1-0-33" id="h1-0-33" class="d">-    active: HashSet&lt;Version&gt;,
</a><a href="#h1-0-34" id="h1-0-34" class="i">+    pub active: HashSet&lt;Version&gt;,
</a> }
 
<a href="#h1-0-37" id="h1-0-37" class="d">-/// A serializable representation of a Transaction&#39;s state. It can be exported
</a><a href="#h1-0-38" id="h1-0-38" class="d">-/// from a Transaction and later used to instantiate a new Transaction that&#39;s
</a><a href="#h1-0-39" id="h1-0-39" class="d">-/// functionally equivalent via Transaction::resume(). In particular, this
</a><a href="#h1-0-40" id="h1-0-40" class="d">-/// allows passing the transaction between the SQL engine and storage engine
</a><a href="#h1-0-41" id="h1-0-41" class="d">-/// across the Raft state machine boundary.
</a><a href="#h1-0-42" id="h1-0-42" class="d">-#[derive(Clone, Serialize, Deserialize)]
</a><a href="#h1-0-43" id="h1-0-43" class="d">-pub struct TransactionState {
</a><a href="#h1-0-44" id="h1-0-44" class="d">-    pub version: u64,
</a><a href="#h1-0-45" id="h1-0-45" class="d">-    pub read_only: bool,
</a><a href="#h1-0-46" id="h1-0-46" class="d">-    pub active: HashSet&lt;u64&gt;,
</a><a href="#h1-0-47" id="h1-0-47" class="i">+impl TransactionState {
</a><a href="#h1-0-48" id="h1-0-48" class="i">+    /// Checks whether the given version is visible to this transaction.
</a><a href="#h1-0-49" id="h1-0-49" class="i">+    fn is_visible(&amp;self, version: Version) -&gt; bool {
</a><a href="#h1-0-50" id="h1-0-50" class="i">+        if self.active.get(&amp;version).is_some() {
</a><a href="#h1-0-51" id="h1-0-51" class="i">+            false
</a><a href="#h1-0-52" id="h1-0-52" class="i">+        } else if self.read_only {
</a><a href="#h1-0-53" id="h1-0-53" class="i">+            version &lt; self.version
</a><a href="#h1-0-54" id="h1-0-54" class="i">+        } else {
</a><a href="#h1-0-55" id="h1-0-55" class="i">+            version &lt;= self.version
</a><a href="#h1-0-56" id="h1-0-56" class="i">+        }
</a><a href="#h1-0-57" id="h1-0-57" class="i">+    }
</a> }
 
 impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
<a href="#h1-1" id="h1-1" class="h">@@ -208,7 +227,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         session.set(&amp;Key::TxnActive(version).encode()?, vec![])?;
         drop(session);
 
<a href="#h1-1-3" id="h1-1-3" class="d">-        Ok(Self { engine, version, read_only: false, active })
</a><a href="#h1-1-4" id="h1-1-4" class="i">+        Ok(Self { engine, st: TransactionState { version, read_only: false, active } })
</a>     }
 
     /// Begins a new read-only transaction. If version is given it will see the
<a href="#h1-2" id="h1-2" class="h">@@ -242,7 +261,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a> 
         drop(session);
 
<a href="#h1-2-3" id="h1-2-3" class="d">-        Ok(Self { engine, version, read_only: true, active })
</a><a href="#h1-2-4" id="h1-2-4" class="i">+        Ok(Self { engine, st: TransactionState { version, read_only: true, active } })
</a>     }
 
     /// Resumes a transaction from the given state.
<a href="#h1-3" id="h1-3" class="h">@@ -252,7 +271,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         if !s.read_only &amp;&amp; engine.lock()?.get(&amp;Key::TxnActive(s.version).encode()?)?.is_none() {
             return Err(Error::Internal(format!(&quot;No active transaction at version {}&quot;, s.version)));
         }
<a href="#h1-3-3" id="h1-3-3" class="d">-        Ok(Self { engine, version: s.version, read_only: s.read_only, active: s.active })
</a><a href="#h1-3-4" id="h1-3-4" class="i">+        Ok(Self { engine, st: s })
</a>     }
 
     /// Fetches the set of currently active transactions.
<a href="#h1-4" id="h1-4" class="h">@@ -270,47 +289,43 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a> 
     /// Returns the version the transaction is running at.
     pub fn version(&amp;self) -&gt; Version {
<a href="#h1-4-3" id="h1-4-3" class="d">-        self.version
</a><a href="#h1-4-4" id="h1-4-4" class="i">+        self.st.version
</a>     }
 
     /// Returns whether the transaction is read-only.
     pub fn read_only(&amp;self) -&gt; bool {
<a href="#h1-4-9" id="h1-4-9" class="d">-        self.read_only
</a><a href="#h1-4-10" id="h1-4-10" class="i">+        self.st.read_only
</a>     }
 
     /// Returns the transaction&#39;s state. This can be used to instantiate a
     /// functionally equivalent transaction via resume().
<a href="#h1-4-15" id="h1-4-15" class="d">-    pub fn state(&amp;self) -&gt; TransactionState {
</a><a href="#h1-4-16" id="h1-4-16" class="d">-        TransactionState {
</a><a href="#h1-4-17" id="h1-4-17" class="d">-            version: self.version,
</a><a href="#h1-4-18" id="h1-4-18" class="d">-            read_only: self.read_only,
</a><a href="#h1-4-19" id="h1-4-19" class="d">-            active: self.active.clone(),
</a><a href="#h1-4-20" id="h1-4-20" class="d">-        }
</a><a href="#h1-4-21" id="h1-4-21" class="i">+    pub fn state(&amp;self) -&gt; &amp;TransactionState {
</a><a href="#h1-4-22" id="h1-4-22" class="i">+        &amp;self.st
</a>     }
 
     /// Commits the transaction, by removing it from the active set. This will
     /// immediately make its writes visible to subsequent transactions.
     pub fn commit(self) -&gt; Result&lt;()&gt; {
<a href="#h1-4-28" id="h1-4-28" class="d">-        if self.read_only {
</a><a href="#h1-4-29" id="h1-4-29" class="i">+        if self.st.read_only {
</a>             return Ok(());
         }
<a href="#h1-4-32" id="h1-4-32" class="d">-        self.engine.lock()?.delete(&amp;Key::TxnActive(self.version).encode()?)
</a><a href="#h1-4-33" id="h1-4-33" class="i">+        self.engine.lock()?.delete(&amp;Key::TxnActive(self.st.version).encode()?)
</a>     }
 
     /// Rolls back the transaction, by undoing all written versions and removing
     /// it from the active set. The active set snapshot is left behind, since
     /// this is needed for time travel queries at this version.
     pub fn rollback(self) -&gt; Result&lt;()&gt; {
<a href="#h1-4-40" id="h1-4-40" class="d">-        if self.read_only {
</a><a href="#h1-4-41" id="h1-4-41" class="i">+        if self.st.read_only {
</a>             return Ok(());
         }
         let mut session = self.engine.lock()?;
         let mut rollback = Vec::new();
<a href="#h1-4-46" id="h1-4-46" class="d">-        let mut scan = session.scan_prefix(&amp;KeyPrefix::TxnWrite(self.version).encode()?);
</a><a href="#h1-4-47" id="h1-4-47" class="i">+        let mut scan = session.scan_prefix(&amp;KeyPrefix::TxnWrite(self.st.version).encode()?);
</a>         while let Some((key, _)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::TxnWrite(_, key) =&gt; {
<a href="#h1-4-51" id="h1-4-51" class="d">-                    rollback.push(Key::Version(key, self.version).encode()?); // the written version
</a><a href="#h1-4-52" id="h1-4-52" class="i">+                    rollback.push(Key::Version(key, self.st.version).encode()?) // the version
</a>                 }
                 key =&gt; return Err(Error::Internal(format!(&quot;Expected TxnWrite, got {:?}&quot;, key))),
             };
<a href="#h1-5" id="h1-5" class="h">@@ -320,7 +335,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         for key in rollback.into_iter() {
             session.delete(&amp;key)?;
         }
<a href="#h1-5-3" id="h1-5-3" class="d">-        session.delete(&amp;Key::TxnActive(self.version).encode()?) // remove from active set
</a><a href="#h1-5-4" id="h1-5-4" class="i">+        session.delete(&amp;Key::TxnActive(self.st.version).encode()?) // remove from active set
</a>     }
 
     /// Deletes a key.
<a href="#h1-6" id="h1-6" class="h">@@ -338,7 +353,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// uncommitted version), a serialization error is returned.  Replacing our
     /// own uncommitted write is fine.
     fn write_version(&amp;self, key: &amp;[u8], value: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;()&gt; {
<a href="#h1-6-3" id="h1-6-3" class="d">-        if self.read_only {
</a><a href="#h1-6-4" id="h1-6-4" class="i">+        if self.st.read_only {
</a>             return Err(Error::ReadOnly);
         }
         let mut session = self.engine.lock()?;
<a href="#h1-7" id="h1-7" class="h">@@ -347,14 +362,16 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         // (either a newer version, or an uncommitted version in our past). We
         // can only conflict with the latest key, since all transactions enforce
         // the same invariant.
<a href="#h1-7-3" id="h1-7-3" class="d">-        let from =
</a><a href="#h1-7-4" id="h1-7-4" class="d">-            Key::Version(key.into(), self.active.iter().min().copied().unwrap_or(self.version + 1))
</a><a href="#h1-7-5" id="h1-7-5" class="d">-                .encode()?;
</a><a href="#h1-7-6" id="h1-7-6" class="i">+        let from = Key::Version(
</a><a href="#h1-7-7" id="h1-7-7" class="i">+            key.into(),
</a><a href="#h1-7-8" id="h1-7-8" class="i">+            self.st.active.iter().min().copied().unwrap_or(self.st.version + 1),
</a><a href="#h1-7-9" id="h1-7-9" class="i">+        )
</a><a href="#h1-7-10" id="h1-7-10" class="i">+        .encode()?;
</a>         let to = Key::Version(key.into(), u64::MAX).encode()?;
         if let Some((k, _)) = session.scan(from..=to).last().transpose()? {
             match Key::decode(&amp;k)? {
                 Key::Version(_, version) =&gt; {
<a href="#h1-7-15" id="h1-7-15" class="d">-                    if !self.is_visible(version) {
</a><a href="#h1-7-16" id="h1-7-16" class="i">+                    if !self.st.is_visible(version) {
</a>                         return Err(Error::Serialization);
                     }
                 }
<a href="#h1-8" id="h1-8" class="h">@@ -366,19 +383,9 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         //
         // NB: TxnWrite contains the provided user key, not the encoded engine
         // key, since we can construct the engine key using the version.
<a href="#h1-8-3" id="h1-8-3" class="d">-        session.set(&amp;Key::TxnWrite(self.version, key.into()).encode()?, vec![])?;
</a><a href="#h1-8-4" id="h1-8-4" class="d">-        session.set(&amp;Key::Version(key.into(), self.version).encode()?, bincode::serialize(&amp;value)?)
</a><a href="#h1-8-5" id="h1-8-5" class="d">-    }
</a><a href="#h1-8-6" id="h1-8-6" class="d">-
</a><a href="#h1-8-7" id="h1-8-7" class="d">-    /// Checks whether the given version is visible to this transaction.
</a><a href="#h1-8-8" id="h1-8-8" class="d">-    fn is_visible(&amp;self, version: Version) -&gt; bool {
</a><a href="#h1-8-9" id="h1-8-9" class="d">-        if self.active.get(&amp;version).is_some() {
</a><a href="#h1-8-10" id="h1-8-10" class="d">-            false
</a><a href="#h1-8-11" id="h1-8-11" class="d">-        } else if self.read_only {
</a><a href="#h1-8-12" id="h1-8-12" class="d">-            version &lt; self.version
</a><a href="#h1-8-13" id="h1-8-13" class="d">-        } else {
</a><a href="#h1-8-14" id="h1-8-14" class="d">-            version &lt;= self.version
</a><a href="#h1-8-15" id="h1-8-15" class="d">-        }
</a><a href="#h1-8-16" id="h1-8-16" class="i">+        session.set(&amp;Key::TxnWrite(self.st.version, key.into()).encode()?, vec![])?;
</a><a href="#h1-8-17" id="h1-8-17" class="i">+        session
</a><a href="#h1-8-18" id="h1-8-18" class="i">+            .set(&amp;Key::Version(key.into(), self.st.version).encode()?, bincode::serialize(&amp;value)?)
</a>     }
 
     /// Fetches a key&#39;s value, or None if it does not exist.
<a href="#h1-9" id="h1-9" class="h">@@ -387,13 +394,13 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         let mut scan = session
             .scan(
                 Key::Version(key.into(), 0).encode()?
<a href="#h1-9-3" id="h1-9-3" class="d">-                    ..=Key::Version(key.into(), self.version).encode()?,
</a><a href="#h1-9-4" id="h1-9-4" class="i">+                    ..=Key::Version(key.into(), self.st.version).encode()?,
</a>             )
             .rev();
         while let Some((k, v)) = scan.next().transpose()? {
             match Key::decode(&amp;k)? {
                 Key::Version(_, version) =&gt; {
<a href="#h1-9-10" id="h1-9-10" class="d">-                    if self.is_visible(version) {
</a><a href="#h1-9-11" id="h1-9-11" class="i">+                    if self.st.is_visible(version) {
</a>                         return Ok(bincode::deserialize(&amp;v)?);
                     }
                 }
<a href="#h1-10" id="h1-10" class="h">@@ -441,7 +448,7 @@ pub struct Scan&lt;&#39;a, E: Engine + &#39;a&gt; {
</a>     /// Access to the locked engine.
     engine: MutexGuard&lt;&#39;a, E&gt;,
     /// The transaction state.
<a href="#h1-10-3" id="h1-10-3" class="d">-    txn: TransactionState,
</a><a href="#h1-10-4" id="h1-10-4" class="i">+    txn: &amp;&#39;a TransactionState,
</a>     /// The scan type and parameter.
     param: ScanType,
 }
<a href="#h1-11" id="h1-11" class="h">@@ -455,7 +462,7 @@ impl&lt;&#39;a, E: Engine + &#39;a&gt; Scan&lt;&#39;a, E&gt; {
</a>     /// Runs a normal range scan.
     fn from_range(
         engine: MutexGuard&lt;&#39;a, E&gt;,
<a href="#h1-11-3" id="h1-11-3" class="d">-        txn: TransactionState,
</a><a href="#h1-11-4" id="h1-11-4" class="i">+        txn: &amp;&#39;a TransactionState,
</a>         start: Bound&lt;Vec&lt;u8&gt;&gt;,
         end: Bound&lt;Vec&lt;u8&gt;&gt;,
     ) -&gt; Self {
<a href="#h1-12" id="h1-12" class="h">@@ -463,7 +470,7 @@ impl&lt;&#39;a, E: Engine + &#39;a&gt; Scan&lt;&#39;a, E&gt; {
</a>     }
 
     /// Runs a prefix scan.
<a href="#h1-12-3" id="h1-12-3" class="d">-    fn from_prefix(engine: MutexGuard&lt;&#39;a, E&gt;, txn: TransactionState, prefix: Vec&lt;u8&gt;) -&gt; Self {
</a><a href="#h1-12-4" id="h1-12-4" class="i">+    fn from_prefix(engine: MutexGuard&lt;&#39;a, E&gt;, txn: &amp;&#39;a TransactionState, prefix: Vec&lt;u8&gt;) -&gt; Self {
</a>         Self { engine, txn, param: ScanType::Prefix(prefix) }
     }
 
<a href="#h1-13" id="h1-13" class="h">@@ -473,7 +480,7 @@ impl&lt;&#39;a, E: Engine + &#39;a&gt; Scan&lt;&#39;a, E&gt; {
</a>             ScanType::Range(range) =&gt; self.engine.scan(range.clone()),
             ScanType::Prefix(prefix) =&gt; self.engine.scan_prefix(prefix),
         };
<a href="#h1-13-3" id="h1-13-3" class="d">-        ScanIterator::new(&amp;self.txn, inner)
</a><a href="#h1-13-4" id="h1-13-4" class="i">+        ScanIterator::new(self.txn, inner)
</a>     }
 
     /// Collects the result to a vector.
<a href="#h1-14" id="h1-14" class="h">@@ -559,6 +566,7 @@ struct VersionIterator&lt;&#39;a, E: Engine + &#39;a&gt; {
</a>     inner: E::ScanIterator&lt;&#39;a&gt;,
 }
 
<a href="#h1-14-3" id="h1-14-3" class="i">+#[allow(clippy::type_complexity)]
</a> impl&lt;&#39;a, E: Engine + &#39;a&gt; VersionIterator&lt;&#39;a, E&gt; {
     /// Creates a new MVCC version iterator for the given engine iterator.
     fn new(txn: &amp;&#39;a TransactionState, inner: E::ScanIterator&lt;&#39;a&gt;) -&gt; Self {
<a href="#h1-15" id="h1-15" class="h">@@ -572,24 +580,13 @@ impl&lt;&#39;a, E: Engine + &#39;a&gt; VersionIterator&lt;&#39;a, E&gt; {
</a>             Key::Version(key, version) =&gt; (key.into_owned(), version),
             key =&gt; return Err(Error::Internal(format!(&quot;Expected Key::Version got {:?}&quot;, key))),
         };
<a href="#h1-15-3" id="h1-15-3" class="d">-        if self.is_visible(version) {
</a><a href="#h1-15-4" id="h1-15-4" class="i">+        if self.txn.is_visible(version) {
</a>             Ok(Some((key, version)))
         } else {
             Ok(None)
         }
     }
 
<a href="#h1-15-11" id="h1-15-11" class="d">-    /// Checks whether the given version is visible to this scan&#39;s transaction.
</a><a href="#h1-15-12" id="h1-15-12" class="d">-    fn is_visible(&amp;self, version: Version) -&gt; bool {
</a><a href="#h1-15-13" id="h1-15-13" class="d">-        if self.txn.active.get(&amp;version).is_some() {
</a><a href="#h1-15-14" id="h1-15-14" class="d">-            false
</a><a href="#h1-15-15" id="h1-15-15" class="d">-        } else if self.txn.read_only {
</a><a href="#h1-15-16" id="h1-15-16" class="d">-            version &lt; self.txn.version
</a><a href="#h1-15-17" id="h1-15-17" class="d">-        } else {
</a><a href="#h1-15-18" id="h1-15-18" class="d">-            version &lt;= self.txn.version
</a><a href="#h1-15-19" id="h1-15-19" class="d">-        }
</a><a href="#h1-15-20" id="h1-15-20" class="d">-    }
</a><a href="#h1-15-21" id="h1-15-21" class="d">-
</a>     // Fallible next(), emitting the next item, or None if exhausted.
     fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Version, Vec&lt;u8&gt;)&gt;&gt; {
         while let Some((key, value)) = self.inner.next().transpose()? {
<a href="#h1-16" id="h1-16" class="h">@@ -761,7 +758,7 @@ pub mod tests {
</a> 
         // We now resume t3, who should see it&#39;s own changes but none
         // of the others&#39;
<a href="#h1-16-3" id="h1-16-3" class="d">-        let state = t3.state();
</a><a href="#h1-16-4" id="h1-16-4" class="i">+        let state = t3.state().clone();
</a>         std::mem::drop(t3);
         let tr = mvcc.resume(state.clone())?;
         assert_eq!(3, tr.version());
<a href="#h1-17" id="h1-17" class="h">@@ -798,7 +795,7 @@ pub mod tests {
</a>         assert_eq!(2, ts.version());
         assert_eq!(Some(b&quot;t1&quot;.to_vec()), ts.get(b&quot;a&quot;)?);
 
<a href="#h1-17-3" id="h1-17-3" class="d">-        let state = ts.state();
</a><a href="#h1-17-4" id="h1-17-4" class="i">+        let state = ts.state().clone();
</a>         std::mem::drop(ts);
         let ts = mvcc.resume(state)?;
         assert_eq!(2, ts.version());
</pre>
</div>
</body>
</html>
