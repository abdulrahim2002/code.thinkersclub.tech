<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: only allow HAVING with aggregate function or GROUP BY - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/87234b2b325879c3af70f0e981568b69e910d805.html">87234b2b325879c3af70f0e981568b69e910d805</a>
<b>parent</b> <a href="../commit/b4a6830f3eb25e0fd9b3278106c1222a8d4cba96.html">b4a6830f3eb25e0fd9b3278106c1222a8d4cba96</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Mon, 15 Jul 2024 13:57:59 +0200

sql: only allow HAVING with aggregate function or GROUP BY

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/planner/plan.rs</a></td><td> | </td><td class="num">29</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">7</td><td><span class="i">+++++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/testscripts/queries/clauses</a></td><td> | </td><td class="num">47</td><td><span class="i">+++++++++++++++++++++++++++</span><span class="d">--------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/testscripts/queries/having</a></td><td> | </td><td class="num">30</td><td><span class="i">++++++++++++++</span><span class="d">----------------</span></td></tr>
</table></pre><pre>4 files changed, 75 insertions(+), 38 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a> b/<a href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -136,6 +136,35 @@ pub enum Node {
</a> }
 
 impl Node {
<a href="#h0-0-3" id="h0-0-3" class="i">+    /// Recursively walks the expression tree depth-first, calling the given
</a><a href="#h0-0-4" id="h0-0-4" class="i">+    /// closure until it returns false. Returns true otherwise.
</a><a href="#h0-0-5" id="h0-0-5" class="i">+    pub fn walk(&amp;self, visitor: &amp;mut impl FnMut(&amp;Self) -&gt; bool) -&gt; bool {
</a><a href="#h0-0-6" id="h0-0-6" class="i">+        use Node::*;
</a><a href="#h0-0-7" id="h0-0-7" class="i">+        if !visitor(self) {
</a><a href="#h0-0-8" id="h0-0-8" class="i">+            return false;
</a><a href="#h0-0-9" id="h0-0-9" class="i">+        }
</a><a href="#h0-0-10" id="h0-0-10" class="i">+        match self {
</a><a href="#h0-0-11" id="h0-0-11" class="i">+            HashJoin { left, right, .. } | NestedLoopJoin { left, right, .. } =&gt; {
</a><a href="#h0-0-12" id="h0-0-12" class="i">+                left.walk(visitor) &amp;&amp; right.walk(visitor)
</a><a href="#h0-0-13" id="h0-0-13" class="i">+            }
</a><a href="#h0-0-14" id="h0-0-14" class="i">+
</a><a href="#h0-0-15" id="h0-0-15" class="i">+            Aggregate { source, .. }
</a><a href="#h0-0-16" id="h0-0-16" class="i">+            | Filter { source, .. }
</a><a href="#h0-0-17" id="h0-0-17" class="i">+            | Limit { source, .. }
</a><a href="#h0-0-18" id="h0-0-18" class="i">+            | Offset { source, .. }
</a><a href="#h0-0-19" id="h0-0-19" class="i">+            | Order { source, .. }
</a><a href="#h0-0-20" id="h0-0-20" class="i">+            | Projection { source, .. } =&gt; source.walk(visitor),
</a><a href="#h0-0-21" id="h0-0-21" class="i">+
</a><a href="#h0-0-22" id="h0-0-22" class="i">+            IndexLookup { .. } | KeyLookup { .. } | Nothing | Scan { .. } | Values { .. } =&gt; true,
</a><a href="#h0-0-23" id="h0-0-23" class="i">+        }
</a><a href="#h0-0-24" id="h0-0-24" class="i">+    }
</a><a href="#h0-0-25" id="h0-0-25" class="i">+
</a><a href="#h0-0-26" id="h0-0-26" class="i">+    /// Recursively walks the node tree depth-first, calling the given closure
</a><a href="#h0-0-27" id="h0-0-27" class="i">+    /// until it returns true. Returns false otherwise. The inverse of walk().
</a><a href="#h0-0-28" id="h0-0-28" class="i">+    pub fn contains(&amp;self, visitor: &amp;impl Fn(&amp;Self) -&gt; bool) -&gt; bool {
</a><a href="#h0-0-29" id="h0-0-29" class="i">+        !self.walk(&amp;mut |node| !visitor(node))
</a><a href="#h0-0-30" id="h0-0-30" class="i">+    }
</a><a href="#h0-0-31" id="h0-0-31" class="i">+
</a>     /// Recursively transforms query nodes depth-first by applying the given
     /// closures before and after descending.
     pub fn transform&lt;B, A&gt;(mut self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
<b>diff --git a/<a id="h1" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -205,8 +205,11 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         };
 
         // Build HAVING clause.
<a href="#h1-0-3" id="h1-0-3" class="d">-        if let Some(expr) = having {
</a><a href="#h1-0-4" id="h1-0-4" class="d">-            let predicate = Self::build_expression(expr, &amp;scope)?;
</a><a href="#h1-0-5" id="h1-0-5" class="i">+        if let Some(having) = having {
</a><a href="#h1-0-6" id="h1-0-6" class="i">+            if !node.contains(&amp;|n| matches!(n, Node::Aggregate { .. })) {
</a><a href="#h1-0-7" id="h1-0-7" class="i">+                return errinput!(&quot;HAVING requires GROUP BY or aggregate function&quot;);
</a><a href="#h1-0-8" id="h1-0-8" class="i">+            }
</a><a href="#h1-0-9" id="h1-0-9" class="i">+            let predicate = Self::build_expression(having, &amp;scope)?;
</a>             node = Node::Filter { source: Box::new(node), predicate };
         };
 
<b>diff --git a/<a id="h2" href="../file/src/sql/testscripts/queries/clauses.html">src/sql/testscripts/queries/clauses</a> b/<a href="../file/src/sql/testscripts/queries/clauses.html">src/sql/testscripts/queries/clauses</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -14,53 +14,60 @@
</a> ok
 
 # This is the only valid order of all clauses:
<a href="#h2-0-3" id="h2-0-3" class="d">-&gt; SELECT * FROM test WHERE TRUE HAVING TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a><a href="#h2-0-4" id="h2-0-4" class="i">+&gt; SELECT COUNT(*) FROM test WHERE TRUE GROUP BY TRUE HAVING TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a> ---
<a href="#h2-0-6" id="h2-0-6" class="d">-2, FALSE, 2.718, 1, üëç
</a><a href="#h2-0-7" id="h2-0-7" class="i">+ok
</a> 
 # All clauses except SELECT are optional.
<a href="#h2-0-10" id="h2-0-10" class="d">-&gt; SELECT 1 WHERE TRUE HAVING TRUE ORDER BY 1 LIMIT 1 OFFSET 1
</a><a href="#h2-0-11" id="h2-0-11" class="i">+&gt; SELECT COUNT(*) WHERE TRUE GROUP BY TRUE HAVING TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a> ---
 ok
 
<a href="#h2-0-15" id="h2-0-15" class="d">-&gt; SELECT * FROM test HAVING TRUE ORDER BY id LIMIT 1 OFFSET 1
</a><a href="#h2-0-16" id="h2-0-16" class="i">+&gt; SELECT COUNT(*) FROM test GROUP BY TRUE HAVING TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a> ---
<a href="#h2-0-18" id="h2-0-18" class="d">-2, FALSE, 2.718, 1, üëç
</a><a href="#h2-0-19" id="h2-0-19" class="i">+ok
</a><a href="#h2-0-20" id="h2-0-20" class="i">+
</a><a href="#h2-0-21" id="h2-0-21" class="i">+&gt; SELECT COUNT(*) FROM test WHERE TRUE HAVING TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a><a href="#h2-0-22" id="h2-0-22" class="i">+---
</a><a href="#h2-0-23" id="h2-0-23" class="i">+ok
</a> 
<a href="#h2-0-25" id="h2-0-25" class="d">-&gt; SELECT * FROM test WHERE TRUE ORDER BY id LIMIT 1 OFFSET 1
</a><a href="#h2-0-26" id="h2-0-26" class="i">+&gt; SELECT COUNT(*) FROM test WHERE TRUE GROUP BY TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a> ---
<a href="#h2-0-28" id="h2-0-28" class="d">-2, FALSE, 2.718, 1, üëç
</a><a href="#h2-0-29" id="h2-0-29" class="i">+ok
</a> 
<a href="#h2-0-31" id="h2-0-31" class="d">-&gt; SELECT * FROM test WHERE TRUE HAVING TRUE LIMIT 1 OFFSET 1
</a><a href="#h2-0-32" id="h2-0-32" class="i">+&gt; SELECT COUNT(*) FROM test WHERE TRUE GROUP BY TRUE HAVING TRUE LIMIT 1 OFFSET 1
</a> ---
<a href="#h2-0-34" id="h2-0-34" class="d">-2, FALSE, 2.718, 1, üëç
</a><a href="#h2-0-35" id="h2-0-35" class="i">+ok
</a> 
<a href="#h2-0-37" id="h2-0-37" class="d">-&gt; SELECT * FROM test WHERE TRUE HAVING TRUE ORDER BY TRUE OFFSET 1
</a><a href="#h2-0-38" id="h2-0-38" class="i">+&gt; SELECT COUNT(*) FROM test WHERE TRUE GROUP BY TRUE HAVING TRUE ORDER BY TRUE OFFSET 1
</a> ---
<a href="#h2-0-40" id="h2-0-40" class="d">-2, FALSE, 2.718, 1, üëç
</a><a href="#h2-0-41" id="h2-0-41" class="d">-3, NULL, NULL, NULL, NULL
</a><a href="#h2-0-42" id="h2-0-42" class="i">+ok
</a> 
<a href="#h2-0-44" id="h2-0-44" class="d">-&gt; SELECT * FROM test WHERE TRUE HAVING TRUE ORDER BY TRUE LIMIT 1
</a><a href="#h2-0-45" id="h2-0-45" class="i">+&gt; SELECT COUNT(*) FROM test WHERE TRUE GROUP BY TRUE HAVING TRUE ORDER BY TRUE LIMIT 1
</a> ---
<a href="#h2-0-47" id="h2-0-47" class="d">-1, TRUE, 3.14, 7, foo
</a><a href="#h2-0-48" id="h2-0-48" class="i">+3
</a> 
 # The clause order is required. Moving any clause to the next position errors.
<a href="#h2-0-51" id="h2-0-51" class="d">-!&gt; FROM test SELECT * WHERE TRUE HAVING TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a><a href="#h2-0-52" id="h2-0-52" class="i">+!&gt; FROM test SELECT COUNT(*) WHERE TRUE GROUP BY TRUE HAVING TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a> ---
 Error: invalid input: unexpected token FROM
 
<a href="#h2-0-56" id="h2-0-56" class="d">-!&gt; SELECT * FROM test HAVING TRUE WHERE TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a><a href="#h2-0-57" id="h2-0-57" class="i">+!&gt; SELECT COUNT(*) FROM test GROUP BY TRUE WHERE TRUE HAVING TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a> ---
 Error: invalid input: unexpected token WHERE
 
<a href="#h2-0-61" id="h2-0-61" class="d">-!&gt; SELECT * FROM test WHERE TRUE ORDER BY TRUE HAVING TRUE LIMIT 1 OFFSET 1
</a><a href="#h2-0-62" id="h2-0-62" class="i">+!&gt; SELECT COUNT(*) FROM test WHERE TRUE HAVING TRUE GROUP BY TRUE ORDER BY TRUE LIMIT 1 OFFSET 1
</a><a href="#h2-0-63" id="h2-0-63" class="i">+---
</a><a href="#h2-0-64" id="h2-0-64" class="i">+Error: invalid input: unexpected token GROUP
</a><a href="#h2-0-65" id="h2-0-65" class="i">+
</a><a href="#h2-0-66" id="h2-0-66" class="i">+!&gt; SELECT COUNT(*) FROM test WHERE TRUE ORDER BY TRUE GROUP BY TRUE HAVING TRUE LIMIT 1 OFFSET 1
</a> ---
<a href="#h2-0-68" id="h2-0-68" class="d">-Error: invalid input: unexpected token HAVING
</a><a href="#h2-0-69" id="h2-0-69" class="i">+Error: invalid input: unexpected token GROUP
</a> 
<a href="#h2-0-71" id="h2-0-71" class="d">-!&gt; SELECT * FROM test WHERE TRUE HAVING TRUE LIMIT 1 ORDER BY TRUE OFFSET 1
</a><a href="#h2-0-72" id="h2-0-72" class="i">+!&gt; SELECT COUNT(*) FROM test WHERE TRUE GROUP BY TRUE HAVING TRUE LIMIT 1 ORDER BY TRUE OFFSET 1
</a> ---
 Error: invalid input: unexpected token ORDER
 
<a href="#h2-0-76" id="h2-0-76" class="d">-!&gt; SELECT * FROM test WHERE TRUE HAVING TRUE ORDER BY TRUE OFFSET 1 LIMIT 1 
</a><a href="#h2-0-77" id="h2-0-77" class="i">+!&gt; SELECT COUNT(*) FROM test WHERE TRUE GROUP BY TRUE HAVING TRUE ORDER BY TRUE OFFSET 1 LIMIT 1 
</a> ---
 Error: invalid input: unexpected token LIMIT
<b>diff --git a/<a id="h3" href="../file/src/sql/testscripts/queries/having.html">src/sql/testscripts/queries/having</a> b/<a href="../file/src/sql/testscripts/queries/having.html">src/sql/testscripts/queries/having</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -18,25 +18,23 @@
</a> ---
 ok
 
<a href="#h3-0-3" id="h3-0-3" class="d">-# Having without a GROUP BY clause is valid, and behaves as if every column is
</a><a href="#h3-0-4" id="h3-0-4" class="d">-# grouped by.
</a><a href="#h3-0-5" id="h3-0-5" class="d">-[plan]&gt; SELECT * FROM test HAVING id &gt; 3
</a><a href="#h3-0-6" id="h3-0-6" class="i">+# Having requires an aggregate function or GROUP BY clause.
</a><a href="#h3-0-7" id="h3-0-7" class="i">+!&gt; SELECT * FROM test HAVING id &gt; 3
</a> ---
<a href="#h3-0-9" id="h3-0-9" class="d">-Scan: test (id &gt; 3)
</a><a href="#h3-0-10" id="h3-0-10" class="d">-4, b, TRUE, 42, inf, üëã
</a><a href="#h3-0-11" id="h3-0-11" class="d">-5, a, FALSE, 7, NaN, 
</a><a href="#h3-0-12" id="h3-0-12" class="d">-6, b, FALSE, -1, 0, abc
</a><a href="#h3-0-13" id="h3-0-13" class="i">+Error: invalid input: HAVING requires GROUP BY or aggregate function
</a> 
<a href="#h3-0-15" id="h3-0-15" class="d">-# Having works with a column not in the result.
</a><a href="#h3-0-16" id="h3-0-16" class="d">-# TODO: should it?
</a><a href="#h3-0-17" id="h3-0-17" class="d">-[plan]&gt; SELECT id FROM test HAVING &quot;int&quot; &gt; 3
</a><a href="#h3-0-18" id="h3-0-18" class="i">+&gt; SELECT COUNT(*) FROM test HAVING COUNT(*) &gt; 0
</a> ---
<a href="#h3-0-20" id="h3-0-20" class="d">-Projection: #0
</a><a href="#h3-0-21" id="h3-0-21" class="d">-‚îî‚îÄ Filter: int &gt; 3
</a><a href="#h3-0-22" id="h3-0-22" class="d">-   ‚îî‚îÄ Projection: id, int
</a><a href="#h3-0-23" id="h3-0-23" class="d">-      ‚îî‚îÄ Scan: test
</a><a href="#h3-0-24" id="h3-0-24" class="d">-4
</a><a href="#h3-0-25" id="h3-0-25" class="d">-5
</a><a href="#h3-0-26" id="h3-0-26" class="i">+7
</a><a href="#h3-0-27" id="h3-0-27" class="i">+
</a><a href="#h3-0-28" id="h3-0-28" class="i">+&gt; SELECT TRUE FROM test GROUP BY id HAVING id &gt; 0
</a><a href="#h3-0-29" id="h3-0-29" class="i">+---
</a><a href="#h3-0-30" id="h3-0-30" class="i">+TRUE
</a><a href="#h3-0-31" id="h3-0-31" class="i">+TRUE
</a><a href="#h3-0-32" id="h3-0-32" class="i">+TRUE
</a><a href="#h3-0-33" id="h3-0-33" class="i">+TRUE
</a><a href="#h3-0-34" id="h3-0-34" class="i">+TRUE
</a><a href="#h3-0-35" id="h3-0-35" class="i">+TRUE
</a> 
 # Having works with an aggregate function, even if it&#39;s not in SELECT.
 [plan]&gt; SELECT &quot;group&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) &gt; 10
</pre>
</div>
</body>
</html>
