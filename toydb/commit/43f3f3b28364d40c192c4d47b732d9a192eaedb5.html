<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>encoding: remove some TODOs that aren&#39;t relevant - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/43f3f3b28364d40c192c4d47b732d9a192eaedb5.html">43f3f3b28364d40c192c4d47b732d9a192eaedb5</a>
<b>parent</b> <a href="../commit/29675287dd909922d38b31fae6436127a1ae35a2.html">29675287dd909922d38b31fae6436127a1ae35a2</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Wed, 26 Jun 2024 16:26:06 +0200

encoding: remove some TODOs that aren&#39;t relevant

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/encoding/bincode.rs</a></td><td> | </td><td class="num">11</td><td><span class="i">++++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/encoding/keycode.rs</a></td><td> | </td><td class="num">35</td><td><span class="i">++++++++++++++++</span><span class="d">-------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/encoding/mod.rs</a></td><td> | </td><td class="num">7</td><td><span class="i">+++++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/engine/local.rs</a></td><td> | </td><td class="num">3</td><td><span class="i"></span><span class="d">---</span></td></tr>
</table></pre><pre>4 files changed, 27 insertions(+), 29 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/encoding/bincode.rs.html">src/encoding/bincode.rs</a> b/<a href="../file/src/encoding/bincode.rs.html">src/encoding/bincode.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -11,6 +11,7 @@
</a> use crate::error::{Error, Result};
 
 use bincode::Options as _;
<a href="#h0-0-3" id="h0-0-3" class="i">+use serde::{de::DeserializeOwned, Deserialize, Serialize};
</a> 
 /// Returns the default Bincode options, initialized on first use.
 fn bincode() -&gt; &amp;&#39;static bincode::DefaultOptions {
<a href="#h0-1" id="h0-1" class="h">@@ -19,18 +20,18 @@ fn bincode() -&gt; &amp;&#39;static bincode::DefaultOptions {
</a> }
 
 /// Deserializes a value using Bincode.
<a href="#h0-1-3" id="h0-1-3" class="d">-pub fn deserialize&lt;&#39;de, T: serde::Deserialize&lt;&#39;de&gt;&gt;(bytes: &amp;&#39;de [u8]) -&gt; Result&lt;T&gt; {
</a><a href="#h0-1-4" id="h0-1-4" class="i">+pub fn deserialize&lt;&#39;de, T: Deserialize&lt;&#39;de&gt;&gt;(bytes: &amp;&#39;de [u8]) -&gt; Result&lt;T&gt; {
</a>     Ok(bincode().deserialize(bytes)?)
 }
 
 /// Deserializes a value from a reader using Bincode.
<a href="#h0-1-9" id="h0-1-9" class="d">-pub fn deserialize_from&lt;R: std::io::Read, T: serde::de::DeserializeOwned&gt;(reader: R) -&gt; Result&lt;T&gt; {
</a><a href="#h0-1-10" id="h0-1-10" class="i">+pub fn deserialize_from&lt;R: std::io::Read, T: DeserializeOwned&gt;(reader: R) -&gt; Result&lt;T&gt; {
</a>     Ok(bincode().deserialize_from(reader)?)
 }
 
 /// Deserializes a value from a reader using Bincode, or returns None if the
 /// reader is closed.
<a href="#h0-1-16" id="h0-1-16" class="d">-pub fn maybe_deserialize_from&lt;R: std::io::Read, T: serde::de::DeserializeOwned&gt;(
</a><a href="#h0-1-17" id="h0-1-17" class="i">+pub fn maybe_deserialize_from&lt;R: std::io::Read, T: DeserializeOwned&gt;(
</a>     reader: R,
 ) -&gt; Result&lt;Option&lt;T&gt;&gt; {
     match bincode().deserialize_from(reader) {
<a href="#h0-2" id="h0-2" class="h">@@ -47,13 +48,13 @@ pub fn maybe_deserialize_from&lt;R: std::io::Read, T: serde::de::DeserializeOwned&gt;(
</a> }
 
 /// Serializes a value using Bincode.
<a href="#h0-2-3" id="h0-2-3" class="d">-pub fn serialize&lt;T: serde::Serialize&gt;(value: &amp;T) -&gt; Vec&lt;u8&gt; {
</a><a href="#h0-2-4" id="h0-2-4" class="i">+pub fn serialize&lt;T: Serialize&gt;(value: &amp;T) -&gt; Vec&lt;u8&gt; {
</a>     // Panic on serialization failures, as this is typically an issue with the
     // provided data structure.
     bincode().serialize(value).expect(&quot;bincode serialization failed&quot;)
 }
 
 /// Serializes a value to a writer using Bincode.
<a href="#h0-2-11" id="h0-2-11" class="d">-pub fn serialize_into&lt;W: std::io::Write, T: serde::Serialize&gt;(writer: W, value: &amp;T) -&gt; Result&lt;()&gt; {
</a><a href="#h0-2-12" id="h0-2-12" class="i">+pub fn serialize_into&lt;W: std::io::Write, T: Serialize&gt;(writer: W, value: &amp;T) -&gt; Result&lt;()&gt; {
</a>     Ok(bincode().serialize_into(writer, value)?)
 }
<b>diff --git a/<a id="h1" href="../file/src/encoding/keycode.rs.html">src/encoding/keycode.rs</a> b/<a href="../file/src/encoding/keycode.rs.html">src/encoding/keycode.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -44,21 +44,18 @@
</a> //! serde_bytes::ByteBuf or use the #[serde(with=&quot;serde_bytes&quot;)] attribute. See
 //! https://github.com/serde-rs/bytes
 
<a href="#h1-0-3" id="h1-0-3" class="d">-use de::IntoDeserializer;
</a><a href="#h1-0-4" id="h1-0-4" class="d">-use serde::{de, ser};
</a><a href="#h1-0-5" id="h1-0-5" class="d">-
</a> use crate::errdata;
 use crate::error::{Error, Result};
 
<a href="#h1-0-9" id="h1-0-9" class="i">+use serde::{de, de::IntoDeserializer as _, ser};
</a><a href="#h1-0-10" id="h1-0-10" class="i">+
</a> /// Serializes a key to a binary KeyCode representation.
 ///
<a href="#h1-0-13" id="h1-0-13" class="d">-/// This will allocate a new byte vector for every call. Often, keys are used
</a><a href="#h1-0-14" id="h1-0-14" class="d">-/// immediately and then discarded, so we could reuse a byte buffer between
</a><a href="#h1-0-15" id="h1-0-15" class="d">-/// calls to avoid the allocations. We don&#39;t, for simplicity.
</a><a href="#h1-0-16" id="h1-0-16" class="d">-///
</a><a href="#h1-0-17" id="h1-0-17" class="d">-/// TODO: given lifetime enforcement, it would be trivial to hand out references
</a><a href="#h1-0-18" id="h1-0-18" class="d">-/// to the reused byte buffer. Consider adding this.
</a><a href="#h1-0-19" id="h1-0-19" class="d">-pub fn serialize&lt;T: serde::Serialize&gt;(key: &amp;T) -&gt; Vec&lt;u8&gt; {
</a><a href="#h1-0-20" id="h1-0-20" class="i">+/// In the common case, the encoded key is borrowed for a storage engine call
</a><a href="#h1-0-21" id="h1-0-21" class="i">+/// and then thrown away. We could avoid a bunch of allocations by taking a
</a><a href="#h1-0-22" id="h1-0-22" class="i">+/// reusable byte vector to encode into and return a reference to it, but we
</a><a href="#h1-0-23" id="h1-0-23" class="i">+/// keep it simple.
</a><a href="#h1-0-24" id="h1-0-24" class="i">+pub fn serialize&lt;T: ser::Serialize&gt;(key: &amp;T) -&gt; Vec&lt;u8&gt; {
</a>     let mut serializer = Serializer { output: Vec::new() };
     // Panic on serialization failures, as this is typically an issue with the
     // provided data structure.
<a href="#h1-1" id="h1-1" class="h">@@ -67,7 +64,7 @@ pub fn serialize&lt;T: serde::Serialize&gt;(key: &amp;T) -&gt; Vec&lt;u8&gt; {
</a> }
 
 /// Deserializes a key from a binary KeyCode representation.
<a href="#h1-1-3" id="h1-1-3" class="d">-pub fn deserialize&lt;&#39;a, T: serde::Deserialize&lt;&#39;a&gt;&gt;(input: &amp;&#39;a [u8]) -&gt; Result&lt;T&gt; {
</a><a href="#h1-1-4" id="h1-1-4" class="i">+pub fn deserialize&lt;&#39;a, T: de::Deserialize&lt;&#39;a&gt;&gt;(input: &amp;&#39;a [u8]) -&gt; Result&lt;T&gt; {
</a>     let mut deserializer = Deserializer::from_bytes(input);
     let t = T::deserialize(&amp;mut deserializer)?;
     if !deserializer.input.is_empty() {
<a href="#h1-2" id="h1-2" class="h">@@ -84,7 +81,7 @@ struct Serializer {
</a>     output: Vec&lt;u8&gt;,
 }
 
<a href="#h1-2-3" id="h1-2-3" class="d">-impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a><a href="#h1-2-4" id="h1-2-4" class="i">+impl&lt;&#39;a&gt; ser::Serializer for &amp;&#39;a mut Serializer {
</a>     type Ok = ();
     type Error = Error;
 
<a href="#h1-3" id="h1-3" class="h">@@ -192,7 +189,7 @@ impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a>         unimplemented!()
     }
 
<a href="#h1-3-3" id="h1-3-3" class="d">-    fn serialize_some&lt;T: serde::Serialize + ?Sized&gt;(self, _: &amp;T) -&gt; Result&lt;()&gt; {
</a><a href="#h1-3-4" id="h1-3-4" class="i">+    fn serialize_some&lt;T: ser::Serialize + ?Sized&gt;(self, _: &amp;T) -&gt; Result&lt;()&gt; {
</a>         unimplemented!()
     }
 
<a href="#h1-4" id="h1-4" class="h">@@ -210,7 +207,7 @@ impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a>         Ok(())
     }
 
<a href="#h1-4-3" id="h1-4-3" class="d">-    fn serialize_newtype_struct&lt;T: serde::Serialize + ?Sized&gt;(
</a><a href="#h1-4-4" id="h1-4-4" class="i">+    fn serialize_newtype_struct&lt;T: ser::Serialize + ?Sized&gt;(
</a>         self,
         _: &amp;&#39;static str,
         _: &amp;T,
<a href="#h1-5" id="h1-5" class="h">@@ -219,7 +216,7 @@ impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a>     }
 
     /// Newtype variants are serialized using the variant index and inner type.
<a href="#h1-5-3" id="h1-5-3" class="d">-    fn serialize_newtype_variant&lt;T: serde::Serialize + ?Sized&gt;(
</a><a href="#h1-5-4" id="h1-5-4" class="i">+    fn serialize_newtype_variant&lt;T: ser::Serialize + ?Sized&gt;(
</a>         self,
         name: &amp;&#39;static str,
         index: u32,
<a href="#h1-6" id="h1-6" class="h">@@ -285,7 +282,7 @@ impl&lt;&#39;a&gt; ser::SerializeSeq for &amp;&#39;a mut Serializer {
</a>     type Ok = ();
     type Error = Error;
 
<a href="#h1-6-3" id="h1-6-3" class="d">-    fn serialize_element&lt;T: serde::Serialize + ?Sized&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt; {
</a><a href="#h1-6-4" id="h1-6-4" class="i">+    fn serialize_element&lt;T: ser::Serialize + ?Sized&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt; {
</a>         value.serialize(&amp;mut **self)
     }
 
<a href="#h1-7" id="h1-7" class="h">@@ -299,7 +296,7 @@ impl&lt;&#39;a&gt; ser::SerializeTuple for &amp;&#39;a mut Serializer {
</a>     type Ok = ();
     type Error = Error;
 
<a href="#h1-7-3" id="h1-7-3" class="d">-    fn serialize_element&lt;T: serde::Serialize + ?Sized&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt; {
</a><a href="#h1-7-4" id="h1-7-4" class="i">+    fn serialize_element&lt;T: ser::Serialize + ?Sized&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt; {
</a>         value.serialize(&amp;mut **self)
     }
 
<a href="#h1-8" id="h1-8" class="h">@@ -313,7 +310,7 @@ impl&lt;&#39;a&gt; ser::SerializeTupleVariant for &amp;&#39;a mut Serializer {
</a>     type Ok = ();
     type Error = Error;
 
<a href="#h1-8-3" id="h1-8-3" class="d">-    fn serialize_field&lt;T: serde::Serialize + ?Sized&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt; {
</a><a href="#h1-8-4" id="h1-8-4" class="i">+    fn serialize_field&lt;T: ser::Serialize + ?Sized&gt;(&amp;mut self, value: &amp;T) -&gt; Result&lt;()&gt; {
</a>         value.serialize(&amp;mut **self)
     }
 
<a href="#h1-9" id="h1-9" class="h">@@ -370,7 +367,7 @@ impl&lt;&#39;de&gt; Deserializer&lt;&#39;de&gt; {
</a> }
 
 /// For details on serialization formats, see Serializer.
<a href="#h1-9-3" id="h1-9-3" class="d">-impl&lt;&#39;de, &#39;a&gt; serde::Deserializer&lt;&#39;de&gt; for &amp;&#39;a mut Deserializer&lt;&#39;de&gt; {
</a><a href="#h1-9-4" id="h1-9-4" class="i">+impl&lt;&#39;de, &#39;a&gt; de::Deserializer&lt;&#39;de&gt; for &amp;&#39;a mut Deserializer&lt;&#39;de&gt; {
</a>     type Error = Error;
 
     fn deserialize_any&lt;V: de::Visitor&lt;&#39;de&gt;&gt;(self, _: V) -&gt; Result&lt;V::Value&gt; {
<b>diff --git a/<a id="h2" href="../file/src/encoding/mod.rs.html">src/encoding/mod.rs</a> b/<a href="../file/src/encoding/mod.rs.html">src/encoding/mod.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -11,8 +11,6 @@ use serde::{de::DeserializeOwned, Deserialize, Serialize};
</a> 
 /// Adds automatic Keycode encode/decode methods to key enums. These are
 /// primarily meant for keys stored in key/value storage engines.
<a href="#h2-0-3" id="h2-0-3" class="d">-///
</a><a href="#h2-0-4" id="h2-0-4" class="d">-/// TODO: consider making this DeserializeOwned instead.
</a> pub trait Key&lt;&#39;de&gt;: Serialize + Deserialize&lt;&#39;de&gt; {
     /// Decodes a key from a byte slice using Keycode.
     fn decode(bytes: &amp;&#39;de [u8]) -&gt; Result&lt;Self&gt; {
<a href="#h2-1" id="h2-1" class="h">@@ -20,6 +18,11 @@ pub trait Key&lt;&#39;de&gt;: Serialize + Deserialize&lt;&#39;de&gt; {
</a>     }
 
     /// Encodes a key to a byte vector using Keycode.
<a href="#h2-1-3" id="h2-1-3" class="i">+    ///
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    /// In the common case, the encoded key is borrowed for a storage engine
</a><a href="#h2-1-5" id="h2-1-5" class="i">+    /// call and then thrown away. We could avoid a bunch of allocations by
</a><a href="#h2-1-6" id="h2-1-6" class="i">+    /// taking a reusable byte vector to encode into and return a reference to
</a><a href="#h2-1-7" id="h2-1-7" class="i">+    /// it, but we keep it simple.
</a>     fn encode(&amp;self) -&gt; Vec&lt;u8&gt; {
         keycode::serialize(self)
     }
<b>diff --git a/<a id="h3" href="../file/src/sql/engine/local.rs.html">src/sql/engine/local.rs</a> b/<a href="../file/src/sql/engine/local.rs.html">src/sql/engine/local.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -410,9 +410,6 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a> /// table/column names, so this is fine.
 ///
 /// Uses Cow to allow encoding borrowed values but decoding owned values.
<a href="#h3-0-3" id="h3-0-3" class="d">-///
</a><a href="#h3-0-4" id="h3-0-4" class="d">-/// TODO: add helper methods here to encode borrowed keys. This should also
</a><a href="#h3-0-5" id="h3-0-5" class="d">-/// encode into a reused byte buffer, see keycode::serialize() comment.
</a> #[derive(Deserialize, Serialize)]
 enum Key&lt;&#39;a&gt; {
     /// A table schema by table name.
</pre>
</div>
</body>
</html>
