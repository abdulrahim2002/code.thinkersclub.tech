<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Use runtime assertions for Raft message validation - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/0b3e5cda59c9d6ff840daea408bbca3bbbb175a8.html">0b3e5cda59c9d6ff840daea408bbca3bbbb175a8</a>
<b>parent</b> <a href="../commit/48c5655ebd8d13fe40208d842dd0ea2e89d48a26.html">48c5655ebd8d13fe40208d842dd0ea2e89d48a26</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 19 Nov 2023 18:33:33 +0100

Use runtime assertions for Raft message validation

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">+++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/raft/node/follower.rs</a></td><td> | </td><td class="num">10</td><td><span class="i">++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/node/leader.rs</a></td><td> | </td><td class="num">20</td><td><span class="i">+++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/node/mod.rs</a></td><td> | </td><td class="num">49</td><td><span class="i">+++++++++++++++++++++++++</span><span class="d">------------------------</span></td></tr>
</table></pre><pre>4 files changed, 43 insertions(+), 48 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -2,7 +2,7 @@ use super::super::{Address, Event, Message};
</a> use super::{rand_election_timeout, Follower, Leader, Node, NodeID, RoleNode, Term, Ticks};
 use crate::error::{Error, Result};
 
<a href="#h0-0-3" id="h0-0-3" class="d">-use ::log::{debug, error, info, warn};
</a><a href="#h0-0-4" id="h0-0-4" class="i">+use ::log::{debug, info, warn};
</a> use std::collections::HashSet;
 
 /// A candidate is campaigning to become a leader.
<a href="#h0-1" id="h0-1" class="h">@@ -68,14 +68,11 @@ impl RoleNode&lt;Candidate&gt; {
</a>     /// Processes a message.
     pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
         // Assert invariants.
<a href="#h0-1-3" id="h0-1-3" class="d">-        debug_assert_eq!(self.term, self.log.get_term()?.0, &quot;Term does not match log&quot;);
</a><a href="#h0-1-4" id="h0-1-4" class="i">+        self.assert_invariants()?;
</a><a href="#h0-1-5" id="h0-1-5" class="i">+        self.assert_step(&amp;msg);
</a>         debug_assert_eq!(Some(self.id), self.log.get_term()?.1, &quot;Log vote does not match self&quot;);
 
<a href="#h0-1-8" id="h0-1-8" class="d">-        // Drop invalid messages and messages from past terms.
</a><a href="#h0-1-9" id="h0-1-9" class="d">-        if let Err(err) = self.validate(&amp;msg) {
</a><a href="#h0-1-10" id="h0-1-10" class="d">-            error!(&quot;Invalid message: {} ({:?})&quot;, err, msg);
</a><a href="#h0-1-11" id="h0-1-11" class="d">-            return Ok(self.into());
</a><a href="#h0-1-12" id="h0-1-12" class="d">-        }
</a><a href="#h0-1-13" id="h0-1-13" class="i">+        // Drop messages from past terms.
</a>         if msg.term &lt; self.term &amp;&amp; msg.term &gt; 0 {
             debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
             return Ok(self.into());
<a href="#h0-2" id="h0-2" class="h">@@ -124,6 +121,7 @@ impl RoleNode&lt;Candidate&gt; {
</a> 
     /// Processes a logical clock tick.
     pub fn tick(mut self) -&gt; Result&lt;Node&gt; {
<a href="#h0-2-3" id="h0-2-3" class="i">+        self.assert_invariants()?;
</a>         self.role.election_duration += 1;
         if self.role.election_duration &gt;= self.role.election_timeout {
             self.campaign()?;
<b>diff --git a/<a id="h1" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -75,17 +75,14 @@ impl RoleNode&lt;Follower&gt; {
</a>     /// Processes a message.
     pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
         // Assert invariants.
<a href="#h1-0-3" id="h1-0-3" class="d">-        debug_assert_eq!(self.term, self.log.get_term()?.0, &quot;Term does not match log&quot;);
</a><a href="#h1-0-4" id="h1-0-4" class="i">+        self.assert_invariants()?;
</a><a href="#h1-0-5" id="h1-0-5" class="i">+        self.assert_step(&amp;msg);
</a>         debug_assert_eq!(self.role.voted_for, self.log.get_term()?.1, &quot;Vote does not match log&quot;);
         if self.role.leader.is_none() {
             assert!(self.role.forwarded.is_empty(), &quot;Leaderless follower has forwarded requests&quot;);
         }
 
<a href="#h1-0-11" id="h1-0-11" class="d">-        // Drop invalid messages and messages from past terms.
</a><a href="#h1-0-12" id="h1-0-12" class="d">-        if let Err(err) = self.validate(&amp;msg) {
</a><a href="#h1-0-13" id="h1-0-13" class="d">-            error!(&quot;Invalid message: {} ({:?})&quot;, err, msg);
</a><a href="#h1-0-14" id="h1-0-14" class="d">-            return Ok(self.into());
</a><a href="#h1-0-15" id="h1-0-15" class="d">-        }
</a><a href="#h1-0-16" id="h1-0-16" class="i">+        // Drop messages from past terms.
</a>         if msg.term &lt; self.term &amp;&amp; msg.term &gt; 0 {
             debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
             return Ok(self.into());
<a href="#h1-1" id="h1-1" class="h">@@ -216,6 +213,7 @@ impl RoleNode&lt;Follower&gt; {
</a> 
     /// Processes a logical clock tick.
     pub fn tick(mut self) -&gt; Result&lt;Node&gt; {
<a href="#h1-1-3" id="h1-1-3" class="i">+        self.assert_invariants()?;
</a>         self.role.leader_seen += 1;
         if self.role.leader_seen &gt;= self.role.election_timeout {
             return Ok(self.become_candidate()?.into());
<b>diff --git a/<a id="h2" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,8 +1,8 @@
</a> use super::super::{Address, Event, Index, Instruction, Message, Request, Response, Status};
 use super::{Follower, Node, NodeID, RoleNode, Term, Ticks, HEARTBEAT_INTERVAL};
<a href="#h2-0-2" id="h2-0-2" class="d">-use crate::error::{Error, Result};
</a><a href="#h2-0-3" id="h2-0-3" class="i">+use crate::error::Result;
</a> 
<a href="#h2-0-5" id="h2-0-5" class="d">-use ::log::{debug, error, info};
</a><a href="#h2-0-6" id="h2-0-6" class="i">+use ::log::{debug, info};
</a> use std::collections::{HashMap, HashSet};
 
 /// Peer replication progress.
<a href="#h2-1" id="h2-1" class="h">@@ -49,14 +49,11 @@ impl RoleNode&lt;Leader&gt; {
</a>     /// Processes a message.
     pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
         // Assert invariants.
<a href="#h2-1-3" id="h2-1-3" class="d">-        debug_assert_eq!(self.term, self.log.get_term()?.0, &quot;Term does not match log&quot;);
</a><a href="#h2-1-4" id="h2-1-4" class="i">+        self.assert_invariants()?;
</a><a href="#h2-1-5" id="h2-1-5" class="i">+        self.assert_step(&amp;msg);
</a>         debug_assert_eq!(Some(self.id), self.log.get_term()?.1, &quot;Log vote does not match self&quot;);
 
<a href="#h2-1-8" id="h2-1-8" class="d">-        // Drop invalid messages and messages from past terms.
</a><a href="#h2-1-9" id="h2-1-9" class="d">-        if let Err(err) = self.validate(&amp;msg) {
</a><a href="#h2-1-10" id="h2-1-10" class="d">-            error!(&quot;Invalid message: {} ({:?})&quot;, err, msg);
</a><a href="#h2-1-11" id="h2-1-11" class="d">-            return Ok(self.into());
</a><a href="#h2-1-12" id="h2-1-12" class="d">-        }
</a><a href="#h2-1-13" id="h2-1-13" class="i">+        // Drop messages from past terms.
</a>         if msg.term &lt; self.term &amp;&amp; msg.term &gt; 0 {
             debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
             return Ok(self.into());
<a href="#h2-2" id="h2-2" class="h">@@ -185,6 +182,7 @@ impl RoleNode&lt;Leader&gt; {
</a> 
     /// Processes a logical clock tick.
     pub fn tick(mut self) -&gt; Result&lt;Node&gt; {
<a href="#h2-2-3" id="h2-2-3" class="i">+        self.assert_invariants()?;
</a>         self.role.since_heartbeat += 1;
         if self.role.since_heartbeat &gt;= HEARTBEAT_INTERVAL {
             self.heartbeat()?;
<a href="#h2-3" id="h2-3" class="h">@@ -248,7 +246,7 @@ impl RoleNode&lt;Leader&gt; {
</a>         match self.log.get(commit_index)? {
             Some(entry) if entry.term == self.term =&gt; {}
             Some(_) =&gt; return Ok(prev_commit_index),
<a href="#h2-3-3" id="h2-3-3" class="d">-            None =&gt; return Err(Error::Internal(format!(&quot;Commit index {} missing&quot;, commit_index))),
</a><a href="#h2-3-4" id="h2-3-4" class="i">+            None =&gt; panic!(&quot;Commit index {} missing&quot;, commit_index),
</a>         };
 
         // Commit and apply the new entries.
<a href="#h2-4" id="h2-4" class="h">@@ -268,10 +266,10 @@ impl RoleNode&lt;Leader&gt; {
</a>         let (base_index, base_term) = match self.role.progress.get(&amp;peer) {
             Some(Progress { next, .. }) if *next &gt; 1 =&gt; match self.log.get(next - 1)? {
                 Some(entry) =&gt; (entry.index, entry.term),
<a href="#h2-4-3" id="h2-4-3" class="d">-                None =&gt; return Err(Error::Internal(format!(&quot;Missing base entry {}&quot;, next - 1))),
</a><a href="#h2-4-4" id="h2-4-4" class="i">+                None =&gt; panic!(&quot;Missing base entry {}&quot;, next - 1),
</a>             },
             Some(_) =&gt; (0, 0),
<a href="#h2-4-7" id="h2-4-7" class="d">-            None =&gt; return Err(Error::Internal(format!(&quot;Unknown peer {}&quot;, peer))),
</a><a href="#h2-4-8" id="h2-4-8" class="i">+            None =&gt; panic!(&quot;Unknown peer {}&quot;, peer),
</a>         };
 
         let entries = self.log.scan((base_index + 1)..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
<b>diff --git a/<a id="h3" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -3,7 +3,7 @@ mod follower;
</a> mod leader;
 
 use super::{Address, Driver, Event, Index, Instruction, Log, Message, State};
<a href="#h3-0-3" id="h3-0-3" class="d">-use crate::error::{Error, Result};
</a><a href="#h3-0-4" id="h3-0-4" class="i">+use crate::error::Result;
</a> use candidate::Candidate;
 use follower::Follower;
 use leader::Leader;
<a href="#h3-1" id="h3-1" class="h">@@ -175,45 +175,46 @@ impl&lt;R&gt; RoleNode&lt;R&gt; {
</a>         Ok(self.node_tx.send(msg)?)
     }
 
<a href="#h3-1-3" id="h3-1-3" class="d">-    /// Validates a message, when stepping it.
</a><a href="#h3-1-4" id="h3-1-4" class="d">-    fn validate(&amp;self, msg: &amp;Message) -&gt; Result&lt;()&gt; {
</a><a href="#h3-1-5" id="h3-1-5" class="i">+    /// Asserts invariants during state transitions (steps and ticks).
</a><a href="#h3-1-6" id="h3-1-6" class="i">+    fn assert_invariants(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h3-1-7" id="h3-1-7" class="i">+        debug_assert_eq!(self.term, self.log.get_term()?.0, &quot;Term does not match log&quot;);
</a><a href="#h3-1-8" id="h3-1-8" class="i">+        Ok(())
</a><a href="#h3-1-9" id="h3-1-9" class="i">+    }
</a><a href="#h3-1-10" id="h3-1-10" class="i">+
</a><a href="#h3-1-11" id="h3-1-11" class="i">+    /// Asserts message invariants when stepping.
</a><a href="#h3-1-12" id="h3-1-12" class="i">+    ///
</a><a href="#h3-1-13" id="h3-1-13" class="i">+    /// In a real production database, these should be errors instead, since
</a><a href="#h3-1-14" id="h3-1-14" class="i">+    /// external input from the network can&#39;t be trusted to uphold invariants.
</a><a href="#h3-1-15" id="h3-1-15" class="i">+    fn assert_step(&amp;self, msg: &amp;Message) {
</a>         // Messages must be addressed to the local node, or a broadcast.
         match msg.to {
             Address::Broadcast =&gt; {}
<a href="#h3-1-19" id="h3-1-19" class="d">-            Address::Client =&gt; return Err(Error::Internal(&quot;Received message for client&quot;.into())),
</a><a href="#h3-1-20" id="h3-1-20" class="d">-            Address::Node(id) if id == self.id =&gt; {}
</a><a href="#h3-1-21" id="h3-1-21" class="d">-            Address::Node(_) =&gt; {
</a><a href="#h3-1-22" id="h3-1-22" class="d">-                return Err(Error::Internal(&quot;Received message for other node&quot;.into()))
</a><a href="#h3-1-23" id="h3-1-23" class="d">-            }
</a><a href="#h3-1-24" id="h3-1-24" class="i">+            Address::Client =&gt; panic!(&quot;Message to client&quot;),
</a><a href="#h3-1-25" id="h3-1-25" class="i">+            Address::Node(id) =&gt; assert_eq!(id, self.id, &quot;Message to other node&quot;),
</a>         }
 
         match msg.from {
             // The broadcast address can&#39;t send anything.
<a href="#h3-1-30" id="h3-1-30" class="d">-            Address::Broadcast =&gt; {
</a><a href="#h3-1-31" id="h3-1-31" class="d">-                return Err(Error::Internal(&quot;Message from broadcast address&quot;.into()))
</a><a href="#h3-1-32" id="h3-1-32" class="d">-            }
</a><a href="#h3-1-33" id="h3-1-33" class="i">+            Address::Broadcast =&gt; panic!(&quot;Message from broadcast address&quot;),
</a>             // Clients can only send ClientRequest without a term.
             Address::Client =&gt; {
<a href="#h3-1-36" id="h3-1-36" class="d">-                if msg.term &gt; 0 {
</a><a href="#h3-1-37" id="h3-1-37" class="d">-                    return Err(Error::Internal(&quot;Client message with term&quot;.into()));
</a><a href="#h3-1-38" id="h3-1-38" class="d">-                }
</a><a href="#h3-1-39" id="h3-1-39" class="d">-                if !matches!(msg.event, Event::ClientRequest { .. }) {
</a><a href="#h3-1-40" id="h3-1-40" class="d">-                    return Err(Error::Internal(&quot;Non-request message from client&quot;.into()));
</a><a href="#h3-1-41" id="h3-1-41" class="d">-                }
</a><a href="#h3-1-42" id="h3-1-42" class="i">+                assert_eq!(msg.term, 0, &quot;Client message with term&quot;);
</a><a href="#h3-1-43" id="h3-1-43" class="i">+                assert!(
</a><a href="#h3-1-44" id="h3-1-44" class="i">+                    matches!(msg.event, Event::ClientRequest { .. }),
</a><a href="#h3-1-45" id="h3-1-45" class="i">+                    &quot;Non-request message from client&quot;
</a><a href="#h3-1-46" id="h3-1-46" class="i">+                );
</a>             }
             // Nodes must be known, and must include their term.
             Address::Node(id) =&gt; {
<a href="#h3-1-50" id="h3-1-50" class="d">-                if id != self.id &amp;&amp; !self.peers.contains(&amp;id) {
</a><a href="#h3-1-51" id="h3-1-51" class="d">-                    return Err(Error::Internal(format!(&quot;Message from unknown node {}&quot;, id)));
</a><a href="#h3-1-52" id="h3-1-52" class="d">-                }
</a><a href="#h3-1-53" id="h3-1-53" class="i">+                assert!(id == self.id || self.peers.contains(&amp;id), &quot;Unknown sender {}&quot;, id);
</a>                 // TODO: For now, accept ClientResponse without term, since the
                 // state driver does not have access to it.
<a href="#h3-1-56" id="h3-1-56" class="d">-                if msg.term == 0 &amp;&amp; !matches!(msg.event, Event::ClientResponse { .. }) {
</a><a href="#h3-1-57" id="h3-1-57" class="d">-                    return Err(Error::Internal(&quot;Message without term&quot;.into()));
</a><a href="#h3-1-58" id="h3-1-58" class="d">-                }
</a><a href="#h3-1-59" id="h3-1-59" class="i">+                assert!(
</a><a href="#h3-1-60" id="h3-1-60" class="i">+                    msg.term &gt; 0 || matches!(msg.event, Event::ClientResponse { .. }),
</a><a href="#h3-1-61" id="h3-1-61" class="i">+                    &quot;Message without term&quot;
</a><a href="#h3-1-62" id="h3-1-62" class="i">+                );
</a>             }
         }
<a href="#h3-1-65" id="h3-1-65" class="d">-        Ok(())
</a>     }
 }
 
</pre>
</div>
</body>
</html>
