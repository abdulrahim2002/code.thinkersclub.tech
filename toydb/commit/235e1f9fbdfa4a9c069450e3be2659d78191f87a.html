<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: improve handling of * in `SELECT` - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/235e1f9fbdfa4a9c069450e3be2659d78191f87a.html">235e1f9fbdfa4a9c069450e3be2659d78191f87a</a>
<b>parent</b> <a href="../commit/2582e3a908f70ff24f5ff6df2fd989e292d588cb.html">2582e3a908f70ff24f5ff6df2fd989e292d588cb</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Wed, 17 Jul 2024 18:34:33 +0200

sql: improve handling of * in `SELECT`

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">++++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/parser/parser.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">+++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">47</td><td><span class="i">++++++++++++++++++++++++++++++++++</span><span class="d">-------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/testscripts/queries/aggregate</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/testscripts/queries/select</a></td><td> | </td><td class="num">40</td><td><span class="i">++++++++++++++++++++++++++++++++</span><span class="d">--------</span></td></tr>
</table></pre><pre>5 files changed, 80 insertions(+), 35 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -98,6 +98,8 @@ pub enum Order {
</a> /// Expressions. Can be nested.
 #[derive(Clone, Debug, Eq, Hash, PartialEq)]
 pub enum Expression {
<a href="#h0-0-3" id="h0-0-3" class="i">+    /// All columns, i.e. *.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+    All,
</a>     /// A column reference, optionally qualified with a table name.
     Column(Option&lt;String&gt;, String),
     /// A literal value.
<a href="#h0-1" id="h0-1" class="h">@@ -217,7 +219,7 @@ impl Expression {
</a> 
             Self::Function(_, exprs) =&gt; exprs.iter().any(|expr| expr.walk(visitor)),
 
<a href="#h0-1-3" id="h0-1-3" class="d">-            Self::Literal(_) | Self::Column(_, _) =&gt; true,
</a><a href="#h0-1-4" id="h0-1-4" class="i">+            Self::All | Self::Column(_, _) | Self::Literal(_) =&gt; true,
</a>         }
     }
 
<a href="#h0-2" id="h0-2" class="h">@@ -264,7 +266,7 @@ impl Expression {
</a> 
             Self::Function(_, exprs) =&gt; exprs.iter().for_each(|expr| expr.collect(visitor, c)),
 
<a href="#h0-2-3" id="h0-2-3" class="d">-            Self::Literal(_) | Self::Column(_, _) =&gt; {}
</a><a href="#h0-2-4" id="h0-2-4" class="i">+            Self::All | Self::Column(_, _) | Self::Literal(_) =&gt; {}
</a>         }
     }
 }
<b>diff --git a/<a id="h1" href="../file/src/sql/parser/parser.rs.html">src/sql/parser/parser.rs</a> b/<a href="../file/src/sql/parser/parser.rs.html">src/sql/parser/parser.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -344,14 +344,14 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>         if !self.next_is(Keyword::Select.into()) {
             return Ok(Vec::new());
         }
<a href="#h1-0-3" id="h1-0-3" class="d">-        if self.next_is(Token::Asterisk) {
</a><a href="#h1-0-4" id="h1-0-4" class="d">-            return Ok(Vec::new());
</a><a href="#h1-0-5" id="h1-0-5" class="d">-        }
</a>         let mut select = Vec::new();
         loop {
             let expr = self.parse_expression()?;
             let mut label = None;
             if self.next_is(Keyword::As.into()) || matches!(self.peek()?, Some(Token::Ident(_))) {
<a href="#h1-0-11" id="h1-0-11" class="i">+                if expr == ast::Expression::All {
</a><a href="#h1-0-12" id="h1-0-12" class="i">+                    return errinput!(&quot;can&#39;t alias *&quot;);
</a><a href="#h1-0-13" id="h1-0-13" class="i">+                }
</a>                 label = Some(self.next_ident()?);
             }
             select.push((expr, label));
<a href="#h1-1" id="h1-1" class="h">@@ -515,6 +515,9 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     /// * A parenthesized expression.
     fn parse_expression_atom(&amp;mut self) -&gt; Result&lt;ast::Expression&gt; {
         Ok(match self.next()? {
<a href="#h1-1-3" id="h1-1-3" class="i">+            // All columns.
</a><a href="#h1-1-4" id="h1-1-4" class="i">+            Token::Asterisk =&gt; ast::Expression::All,
</a><a href="#h1-1-5" id="h1-1-5" class="i">+
</a>             // Literal value.
             Token::Number(n) if n.chars().all(|c| c.is_ascii_digit()) =&gt; {
                 ast::Literal::Integer(n.parse()?).into()
<a href="#h1-2" id="h1-2" class="h">@@ -534,12 +537,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>                     if !args.is_empty() {
                         self.expect(Token::Comma)?;
                     }
<a href="#h1-2-3" id="h1-2-3" class="d">-                    if name == &quot;count&quot; &amp;&amp; self.next_is(Token::Asterisk) {
</a><a href="#h1-2-4" id="h1-2-4" class="d">-                        // TODO: ugly hack to handle COUNT(*).
</a><a href="#h1-2-5" id="h1-2-5" class="d">-                        args.push(ast::Expression::Literal(ast::Literal::Boolean(true)));
</a><a href="#h1-2-6" id="h1-2-6" class="d">-                    } else {
</a><a href="#h1-2-7" id="h1-2-7" class="d">-                        args.push(self.parse_expression()?);
</a><a href="#h1-2-8" id="h1-2-8" class="d">-                    }
</a><a href="#h1-2-9" id="h1-2-9" class="i">+                    args.push(self.parse_expression()?);
</a>                 }
                 ast::Expression::Function(name, args)
             }
<b>diff --git a/<a id="h2" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -163,14 +163,33 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         // Build FROM clause.
         let mut node = if !from.is_empty() {
             self.build_from_clause(&amp;mut scope, from)?
<a href="#h2-0-3" id="h2-0-3" class="d">-        } else if select.is_empty() {
</a><a href="#h2-0-4" id="h2-0-4" class="d">-            return errinput!(&quot;SELECT * requires a FROM clause&quot;);
</a>         } else {
             // For a constant SELECT, emit a single empty row to project with.
             // This allows using aggregate functions and WHERE as normal.
             Node::Values { rows: vec![vec![]] }
         };
 
<a href="#h2-0-11" id="h2-0-11" class="i">+        // Expand out SELECT * to all FROM columns if there are multiple SELECT
</a><a href="#h2-0-12" id="h2-0-12" class="i">+        // expressions or a GROUP BY clause (to ensure all columns are in GROUP
</a><a href="#h2-0-13" id="h2-0-13" class="i">+        // BY). For simplicity, expressions only supports scalar values, so we
</a><a href="#h2-0-14" id="h2-0-14" class="i">+        // special-case the * tuple here.
</a><a href="#h2-0-15" id="h2-0-15" class="i">+        if select.contains(&amp;(ast::Expression::All, None)) {
</a><a href="#h2-0-16" id="h2-0-16" class="i">+            if node.size() == 0 {
</a><a href="#h2-0-17" id="h2-0-17" class="i">+                return errinput!(&quot;SELECT * requires a FROM clause&quot;);
</a><a href="#h2-0-18" id="h2-0-18" class="i">+            }
</a><a href="#h2-0-19" id="h2-0-19" class="i">+            if select.len() &gt; 1 || !group_by.is_empty() {
</a><a href="#h2-0-20" id="h2-0-20" class="i">+                select = select
</a><a href="#h2-0-21" id="h2-0-21" class="i">+                    .into_iter()
</a><a href="#h2-0-22" id="h2-0-22" class="i">+                    .flat_map(|(expr, alias)| match expr {
</a><a href="#h2-0-23" id="h2-0-23" class="i">+                        ast::Expression::All =&gt; itertools::Either::Left(
</a><a href="#h2-0-24" id="h2-0-24" class="i">+                            (0..node.size()).map(|i| (node.column_label(i).into(), None)),
</a><a href="#h2-0-25" id="h2-0-25" class="i">+                        ),
</a><a href="#h2-0-26" id="h2-0-26" class="i">+                        expr =&gt; itertools::Either::Right(std::iter::once((expr, alias))),
</a><a href="#h2-0-27" id="h2-0-27" class="i">+                    })
</a><a href="#h2-0-28" id="h2-0-28" class="i">+                    .collect();
</a><a href="#h2-0-29" id="h2-0-29" class="i">+            }
</a><a href="#h2-0-30" id="h2-0-30" class="i">+        }
</a><a href="#h2-0-31" id="h2-0-31" class="i">+
</a>         // Build WHERE clause.
         if let Some(expr) = r#where {
             let predicate = Self::build_expression(expr, &amp;scope)?;
<a href="#h2-1" id="h2-1" class="h">@@ -180,18 +199,11 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         // Build aggregate functions and GROUP BY clause.
         let aggregates = Self::collect_aggregates(&amp;select, &amp;having, &amp;order_by);
         if !group_by.is_empty() || !aggregates.is_empty() {
<a href="#h2-1-3" id="h2-1-3" class="d">-            // For SELECT * with aggregates, expand as explicit columns to
</a><a href="#h2-1-4" id="h2-1-4" class="d">-            // verify that they&#39;re all used in GROUP BY as well.
</a><a href="#h2-1-5" id="h2-1-5" class="d">-            if select.is_empty() {
</a><a href="#h2-1-6" id="h2-1-6" class="d">-                select = (0..node.size())
</a><a href="#h2-1-7" id="h2-1-7" class="d">-                    .map(|i| (ast::Expression::from(node.column_label(i)), None))
</a><a href="#h2-1-8" id="h2-1-8" class="d">-                    .collect();
</a><a href="#h2-1-9" id="h2-1-9" class="d">-            }
</a>             node = self.build_aggregate(&amp;mut scope, node, group_by, aggregates)?;
         }
 
<a href="#h2-1-13" id="h2-1-13" class="d">-        // Build SELECT clause.
</a><a href="#h2-1-14" id="h2-1-14" class="d">-        if !select.is_empty() {
</a><a href="#h2-1-15" id="h2-1-15" class="i">+        // Build SELECT clause. We can omit this for a trivial SELECT *.
</a><a href="#h2-1-16" id="h2-1-16" class="i">+        if select.as_slice() != [(ast::Expression::All, None)] {
</a>             // Prepare the post-projection scope.
             let mut child_scope = scope.project(&amp;select);
 
<a href="#h2-2" id="h2-2" class="h">@@ -210,7 +222,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a> 
             scope = child_scope;
             node = Node::Projection { source: Box::new(node), expressions, aliases };
<a href="#h2-2-3" id="h2-2-3" class="d">-        };
</a><a href="#h2-2-4" id="h2-2-4" class="i">+        }
</a> 
         // Build HAVING clause.
         if let Some(having) = having {
<a href="#h2-3" id="h2-3" class="h">@@ -379,7 +391,12 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         if args[0].contains(&amp;|expr| Self::is_aggregate_function(expr)) {
             return errinput!(&quot;aggregate functions can&#39;t be nested&quot;);
         }
<a href="#h2-3-3" id="h2-3-3" class="d">-        let expr = Self::build_expression(args.remove(0), scope)?;
</a><a href="#h2-3-4" id="h2-3-4" class="i">+        // Special-case COUNT(*) since expressions don&#39;t support tuples.
</a><a href="#h2-3-5" id="h2-3-5" class="i">+        let expr = if name.as_str() == &quot;count&quot; &amp;&amp; args[0] == ast::Expression::All {
</a><a href="#h2-3-6" id="h2-3-6" class="i">+            Expression::Constant(Value::Boolean(true))
</a><a href="#h2-3-7" id="h2-3-7" class="i">+        } else {
</a><a href="#h2-3-8" id="h2-3-8" class="i">+            Self::build_expression(args.remove(0), scope)?
</a><a href="#h2-3-9" id="h2-3-9" class="i">+        };
</a>         Ok(match name.as_str() {
             &quot;avg&quot; =&gt; Aggregate::Average(expr),
             &quot;count&quot; =&gt; Aggregate::Count(expr),
<a href="#h2-4" id="h2-4" class="h">@@ -482,6 +499,10 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         };
 
         Ok(match expr {
<a href="#h2-4-3" id="h2-4-3" class="i">+            // For simplicity, expression evaluation only supports scalar
</a><a href="#h2-4-4" id="h2-4-4" class="i">+            // values, not compound types like tuples. Support for * is
</a><a href="#h2-4-5" id="h2-4-5" class="i">+            // therefore special-cased in SELECT and COUNT(*).
</a><a href="#h2-4-6" id="h2-4-6" class="i">+            ast::Expression::All =&gt; return errinput!(&quot;unsupported use of *&quot;),
</a>             ast::Expression::Literal(l) =&gt; Constant(match l {
                 ast::Literal::Null =&gt; Value::Null,
                 ast::Literal::Boolean(b) =&gt; Value::Boolean(b),
<b>diff --git a/<a id="h3" href="../file/src/sql/testscripts/queries/aggregate.html">src/sql/testscripts/queries/aggregate</a> b/<a href="../file/src/sql/testscripts/queries/aggregate.html">src/sql/testscripts/queries/aggregate</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -222,10 +222,10 @@ Aggregate: count(1), min(1), max(1), sum(1), avg(1)
</a> 6, 1, 1, 6, 1
 
 # Constant aggregates can&#39;t be used with value rows.
<a href="#h3-0-3" id="h3-0-3" class="d">-[plan]!&gt; SELECT *, COUNT(1), MIN(1), MAX(1), SUM(1), AVG(1) FROM test
</a><a href="#h3-0-4" id="h3-0-4" class="d">-[plan]!&gt; SELECT id, COUNT(1), MIN(1), MAX(1), SUM(1), AVG(1) FROM test
</a><a href="#h3-0-5" id="h3-0-5" class="i">+!&gt; SELECT *, COUNT(1), MIN(1), MAX(1), SUM(1), AVG(1) FROM test
</a><a href="#h3-0-6" id="h3-0-6" class="i">+!&gt; SELECT id, COUNT(1), MIN(1), MAX(1), SUM(1), AVG(1) FROM test
</a> ---
<a href="#h3-0-8" id="h3-0-8" class="d">-Error: invalid input: unexpected token ,
</a><a href="#h3-0-9" id="h3-0-9" class="i">+Error: invalid input: column test.id must be used in an aggregate or GROUP BY expression
</a> Error: invalid input: column id must be used in an aggregate or GROUP BY expression
 
 # Repeated aggregates work.
<b>diff --git a/<a id="h4" href="../file/src/sql/testscripts/queries/select.html">src/sql/testscripts/queries/select</a> b/<a href="../file/src/sql/testscripts/queries/select.html">src/sql/testscripts/queries/select</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -57,6 +57,11 @@ TRUE
</a> FALSE
 NULL
 
<a href="#h4-0-3" id="h4-0-3" class="i">+# * can&#39;t be used with table names, for simplicity.
</a><a href="#h4-0-4" id="h4-0-4" class="i">+!&gt; SELECT test.* FROM test
</a><a href="#h4-0-5" id="h4-0-5" class="i">+---
</a><a href="#h4-0-6" id="h4-0-6" class="i">+Error: invalid input: expected identifier, got *
</a><a href="#h4-0-7" id="h4-0-7" class="i">+
</a> # A SELECT * without a table errors, as does a bare FROM.
 !&gt; SELECT *
 !&gt; SELECT * FROM
<a href="#h4-1" id="h4-1" class="h">@@ -64,15 +69,34 @@ NULL
</a> Error: invalid input: SELECT * requires a FROM clause
 Error: invalid input: unexpected end of input
 
<a href="#h4-1-3" id="h4-1-3" class="d">-# Mix columns, column expressions, and constant expressions.
</a><a href="#h4-1-4" id="h4-1-4" class="d">-[plan,header]&gt; SELECT id, 7-4, &quot;float&quot;^2 FROM test
</a><a href="#h4-1-5" id="h4-1-5" class="i">+# A * errors in expressions. For simplicity, expressions only support scalars.
</a><a href="#h4-1-6" id="h4-1-6" class="i">+!&gt; SELECT 1 + * FROM test
</a><a href="#h4-1-7" id="h4-1-7" class="i">+!&gt; SELECT sqrt(*) FROM test
</a><a href="#h4-1-8" id="h4-1-8" class="i">+!&gt; SELECT max(*) FROM test
</a><a href="#h4-1-9" id="h4-1-9" class="i">+---
</a><a href="#h4-1-10" id="h4-1-10" class="i">+Error: invalid input: unsupported use of *
</a><a href="#h4-1-11" id="h4-1-11" class="i">+Error: invalid input: unsupported use of *
</a><a href="#h4-1-12" id="h4-1-12" class="i">+Error: invalid input: unsupported use of *
</a><a href="#h4-1-13" id="h4-1-13" class="i">+
</a><a href="#h4-1-14" id="h4-1-14" class="i">+# A * can be used multiple times.
</a><a href="#h4-1-15" id="h4-1-15" class="i">+[plan,header]&gt; SELECT *, *, * FROM test
</a><a href="#h4-1-16" id="h4-1-16" class="i">+---
</a><a href="#h4-1-17" id="h4-1-17" class="i">+Projection: test.id, test.bool, test.float, test.int, test.string, test.id, test.bool, test.float, test.int, test.string, test.id, test.bool, test.float, test.int, test.string
</a><a href="#h4-1-18" id="h4-1-18" class="i">+‚îî‚îÄ Scan: test
</a><a href="#h4-1-19" id="h4-1-19" class="i">+test.id, test.bool, test.float, test.int, test.string, test.id, test.bool, test.float, test.int, test.string, test.id, test.bool, test.float, test.int, test.string
</a><a href="#h4-1-20" id="h4-1-20" class="i">+1, TRUE, 3.14, 7, foo, 1, TRUE, 3.14, 7, foo, 1, TRUE, 3.14, 7, foo
</a><a href="#h4-1-21" id="h4-1-21" class="i">+2, FALSE, 2.718, 1, üëç, 2, FALSE, 2.718, 1, üëç, 2, FALSE, 2.718, 1, üëç
</a><a href="#h4-1-22" id="h4-1-22" class="i">+3, NULL, NULL, NULL, NULL, 3, NULL, NULL, NULL, NULL, 3, NULL, NULL, NULL, NULL
</a><a href="#h4-1-23" id="h4-1-23" class="i">+
</a><a href="#h4-1-24" id="h4-1-24" class="i">+# Mix *, columns, column expressions, and constant expressions.
</a><a href="#h4-1-25" id="h4-1-25" class="i">+[plan,header]&gt; SELECT id, 7-4, *, &quot;float&quot;^2 FROM test
</a> ---
<a href="#h4-1-27" id="h4-1-27" class="d">-Projection: test.id, 3, test.float ^ 2
</a><a href="#h4-1-28" id="h4-1-28" class="i">+Projection: test.id, 3, test.id, test.bool, test.float, test.int, test.string, test.float ^ 2
</a> ‚îî‚îÄ Scan: test
<a href="#h4-1-30" id="h4-1-30" class="d">-test.id, , 
</a><a href="#h4-1-31" id="h4-1-31" class="d">-1, 3, 9.8596
</a><a href="#h4-1-32" id="h4-1-32" class="d">-2, 3, 7.387524
</a><a href="#h4-1-33" id="h4-1-33" class="d">-3, 3, NULL
</a><a href="#h4-1-34" id="h4-1-34" class="i">+test.id, , test.id, test.bool, test.float, test.int, test.string, 
</a><a href="#h4-1-35" id="h4-1-35" class="i">+1, 3, 1, TRUE, 3.14, 7, foo, 9.8596
</a><a href="#h4-1-36" id="h4-1-36" class="i">+2, 3, 2, FALSE, 2.718, 1, üëç, 7.387524
</a><a href="#h4-1-37" id="h4-1-37" class="i">+3, 3, 3, NULL, NULL, NULL, NULL, NULL
</a> 
 # Column names may be qualified or unqualified.
 [header]&gt; SELECT id, test.&quot;bool&quot; FROM test
<a href="#h4-2" id="h4-2" class="h">@@ -165,7 +189,7 @@ Error: invalid input: unexpected token .
</a> !&gt; SELECT * AS all FROM test
 ---
 Error: invalid input: unexpected end of input
<a href="#h4-2-3" id="h4-2-3" class="d">-Error: invalid input: unexpected token AS
</a><a href="#h4-2-4" id="h4-2-4" class="i">+Error: invalid input: can&#39;t alias *
</a> 
 # Ambiguous columns error.
 !&gt; SELECT id FROM test, other
</pre>
</div>
</body>
</html>
