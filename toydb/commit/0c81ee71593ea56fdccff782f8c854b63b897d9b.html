<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>storage: use MVCC key options instead of keyspaces - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/0c81ee71593ea56fdccff782f8c854b63b897d9b.html">0c81ee71593ea56fdccff782f8c854b63b897d9b</a>
<b>parent</b> <a href="../commit/9d777ff712e2299283e8bc9472563586686f17ad.html">9d777ff712e2299283e8bc9472563586686f17ad</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Fri, 15 May 2020 22:11:49 +0200

storage: use MVCC key options instead of keyspaces

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">83</td><td><span class="i">++++++++++++++++++++++++++++++++</span><span class="d">-----------------------------------------------</span></td></tr>
</table></pre><pre>1 file changed, 33 insertions(+), 50 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -77,7 +77,7 @@ impl&lt;S: kv::Store&gt; Transaction&lt;S&gt; {
</a>         column: &amp;str,
         value: &amp;Value,
     ) -&gt; Result&lt;HashSet&lt;Value&gt;, Error&gt; {
<a href="#h0-0-3" id="h0-0-3" class="d">-        let key = Key::Index(table, column, value).encode();
</a><a href="#h0-0-4" id="h0-0-4" class="i">+        let key = Key::Index(table, column, Some(value)).encode();
</a>         if let Some(value) = self.txn.get(&amp;key)? {
             let item: (Value, HashSet&lt;Value&gt;) = deserialize(&amp;value)?;
             Ok(item.1)
<a href="#h0-1" id="h0-1" class="h">@@ -96,7 +96,7 @@ impl&lt;S: kv::Store&gt; Transaction&lt;S&gt; {
</a>         value: &amp;Value,
         index: HashSet&lt;Value&gt;,
     ) -&gt; Result&lt;(), Error&gt; {
<a href="#h0-1-3" id="h0-1-3" class="d">-        let key = Key::Index(table, column, value).encode();
</a><a href="#h0-1-4" id="h0-1-4" class="i">+        let key = Key::Index(table, column, Some(value)).encode();
</a>         if index.is_empty() {
             self.txn.delete(&amp;key)
         } else {
<a href="#h0-2" id="h0-2" class="h">@@ -132,7 +132,7 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>                 id, table.name
             )));
         }
<a href="#h0-2-3" id="h0-2-3" class="d">-        self.txn.set(&amp;Key::Row(&amp;table.name, &amp;id).encode(), serialize(&amp;row)?)?;
</a><a href="#h0-2-4" id="h0-2-4" class="i">+        self.txn.set(&amp;Key::Row(&amp;table.name, Some(&amp;id)).encode(), serialize(&amp;row)?)?;
</a> 
         // Update indexes
         for (i, column) in table.columns.iter().enumerate().filter(|(_, c)| c.index) {
<a href="#h0-3" id="h0-3" class="h">@@ -157,11 +157,11 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>                 }
             }
         }
<a href="#h0-3-3" id="h0-3-3" class="d">-        self.txn.delete(&amp;Key::Row(&amp;table.name, id).encode())
</a><a href="#h0-3-4" id="h0-3-4" class="i">+        self.txn.delete(&amp;Key::Row(&amp;table.name, Some(id)).encode())
</a>     }
 
     fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;, Error&gt; {
<a href="#h0-3-8" id="h0-3-8" class="d">-        self.txn.get(&amp;Key::Row(table, id).encode())?.map(|v| deserialize(&amp;v)).transpose()
</a><a href="#h0-3-9" id="h0-3-9" class="i">+        self.txn.get(&amp;Key::Row(table, Some(id)).encode())?.map(|v| deserialize(&amp;v)).transpose()
</a>     }
 
     fn read_index(
<a href="#h0-4" id="h0-4" class="h">@@ -180,7 +180,7 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>         let table = self.must_read_table(&amp;table)?;
         let scan = self
             .txn
<a href="#h0-4-3" id="h0-4-3" class="d">-            .scan_prefix(&amp;KeyPrefix::Row(&amp;table.name).encode())?
</a><a href="#h0-4-4" id="h0-4-4" class="i">+            .scan_prefix(&amp;Key::Row(&amp;table.name, None).encode())?
</a>             .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)))
             .filter_map(|r| match r {
                 Ok(row) =&gt; match &amp;filter {
<a href="#h0-5" id="h0-5" class="h">@@ -211,7 +211,7 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a> 
         let scan = self
             .txn
<a href="#h0-5-3" id="h0-5-3" class="d">-            .scan_prefix(&amp;KeyPrefix::Index(&amp;table.name, &amp;column.name).encode())?
</a><a href="#h0-5-4" id="h0-5-4" class="i">+            .scan_prefix(&amp;Key::Index(&amp;table.name, &amp;column.name, None).encode())?
</a>             .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)));
 
         // FIXME We buffer results here, to avoid dealing with trait lifetimes right now
<a href="#h0-6" id="h0-6" class="h">@@ -246,7 +246,7 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>         }
 
         table.validate_row(&amp;row, self)?;
<a href="#h0-6-3" id="h0-6-3" class="d">-        self.txn.set(&amp;Key::Row(&amp;table.name, &amp;id).encode(), serialize(&amp;row)?)
</a><a href="#h0-6-4" id="h0-6-4" class="i">+        self.txn.set(&amp;Key::Row(&amp;table.name, Some(&amp;id)).encode(), serialize(&amp;row)?)
</a>     }
 }
 
<a href="#h0-7" id="h0-7" class="h">@@ -256,7 +256,7 @@ impl&lt;S: kv::Store&gt; Catalog for Transaction&lt;S&gt; {
</a>             return Err(Error::Value(format!(&quot;Table {} already exists&quot;, table.name)));
         }
         table.validate(self)?;
<a href="#h0-7-3" id="h0-7-3" class="d">-        self.txn.set(&amp;Key::Table(&amp;table.name).encode(), serialize(table)?)
</a><a href="#h0-7-4" id="h0-7-4" class="i">+        self.txn.set(&amp;Key::Table(Some(&amp;table.name)).encode(), serialize(table)?)
</a>     }
 
     fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;(), Error&gt; {
<a href="#h0-8" id="h0-8" class="h">@@ -266,17 +266,17 @@ impl&lt;S: kv::Store&gt; Catalog for Transaction&lt;S&gt; {
</a>         while let Some(row) = scan.next().transpose()? {
             self.delete(&amp;table.name, &amp;table.get_row_key(&amp;row)?)?
         }
<a href="#h0-8-3" id="h0-8-3" class="d">-        self.txn.delete(&amp;Key::Table(&amp;table.name).encode())
</a><a href="#h0-8-4" id="h0-8-4" class="i">+        self.txn.delete(&amp;Key::Table(Some(&amp;table.name)).encode())
</a>     }
 
     fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;, Error&gt; {
<a href="#h0-8-8" id="h0-8-8" class="d">-        self.txn.get(&amp;Key::Table(table).encode())?.map(|v| deserialize(&amp;v)).transpose()
</a><a href="#h0-8-9" id="h0-8-9" class="i">+        self.txn.get(&amp;Key::Table(Some(table)).encode())?.map(|v| deserialize(&amp;v)).transpose()
</a>     }
 
     fn scan_tables(&amp;self) -&gt; Result&lt;Tables, Error&gt; {
         Ok(Box::new(
             self.txn
<a href="#h0-8-15" id="h0-8-15" class="d">-                .scan_prefix(&amp;KeyPrefix::Table.encode())?
</a><a href="#h0-8-16" id="h0-8-16" class="i">+                .scan_prefix(&amp;Key::Table(None).encode())?
</a>                 .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)))
                 .collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
                 .into_iter(),
<a href="#h0-9" id="h0-9" class="h">@@ -284,54 +284,37 @@ impl&lt;S: kv::Store&gt; Catalog for Transaction&lt;S&gt; {
</a>     }
 }
 
<a href="#h0-9-3" id="h0-9-3" class="d">-/// Encodes MVCC keyspace prefixes
</a><a href="#h0-9-4" id="h0-9-4" class="d">-enum KeyPrefix&lt;&#39;a&gt; {
</a><a href="#h0-9-5" id="h0-9-5" class="d">-    /// Tables
</a><a href="#h0-9-6" id="h0-9-6" class="d">-    Table,
</a><a href="#h0-9-7" id="h0-9-7" class="d">-    /// Index entries for a table and column
</a><a href="#h0-9-8" id="h0-9-8" class="d">-    Index(&amp;&#39;a str, &amp;&#39;a str),
</a><a href="#h0-9-9" id="h0-9-9" class="d">-    /// Rows for a table
</a><a href="#h0-9-10" id="h0-9-10" class="d">-    Row(&amp;&#39;a str),
</a><a href="#h0-9-11" id="h0-9-11" class="d">-}
</a><a href="#h0-9-12" id="h0-9-12" class="d">-
</a><a href="#h0-9-13" id="h0-9-13" class="d">-impl&lt;&#39;a&gt; KeyPrefix&lt;&#39;a&gt; {
</a><a href="#h0-9-14" id="h0-9-14" class="d">-    fn encode(&amp;self) -&gt; Vec&lt;u8&gt; {
</a><a href="#h0-9-15" id="h0-9-15" class="d">-        match self {
</a><a href="#h0-9-16" id="h0-9-16" class="d">-            KeyPrefix::Table =&gt; vec![0x01],
</a><a href="#h0-9-17" id="h0-9-17" class="d">-            KeyPrefix::Index(table, column) =&gt; [
</a><a href="#h0-9-18" id="h0-9-18" class="d">-                vec![0x03],
</a><a href="#h0-9-19" id="h0-9-19" class="d">-                table.as_bytes().to_vec(),
</a><a href="#h0-9-20" id="h0-9-20" class="d">-                vec![0x00],
</a><a href="#h0-9-21" id="h0-9-21" class="d">-                column.as_bytes().to_vec(),
</a><a href="#h0-9-22" id="h0-9-22" class="d">-                vec![0x00],
</a><a href="#h0-9-23" id="h0-9-23" class="d">-            ]
</a><a href="#h0-9-24" id="h0-9-24" class="d">-            .concat(),
</a><a href="#h0-9-25" id="h0-9-25" class="d">-            KeyPrefix::Row(table) =&gt; [vec![0x05], table.as_bytes().to_vec(), vec![0x00]].concat(),
</a><a href="#h0-9-26" id="h0-9-26" class="d">-        }
</a><a href="#h0-9-27" id="h0-9-27" class="d">-    }
</a><a href="#h0-9-28" id="h0-9-28" class="d">-}
</a><a href="#h0-9-29" id="h0-9-29" class="d">-
</a><a href="#h0-9-30" id="h0-9-30" class="d">-/// Encodes tables and rows as MVCC key/value keys
</a><a href="#h0-9-31" id="h0-9-31" class="i">+/// Encodes MVCC keys. Options can be None to get a keyspace prefix.
</a> enum Key&lt;&#39;a&gt; {
     /// A table schema key for the given table name
<a href="#h0-9-34" id="h0-9-34" class="d">-    Table(&amp;&#39;a str),
</a><a href="#h0-9-35" id="h0-9-35" class="i">+    Table(Option&lt;&amp;&#39;a str&gt;),
</a>     /// A key for an index entry
<a href="#h0-9-37" id="h0-9-37" class="d">-    Index(&amp;&#39;a str, &amp;&#39;a str, &amp;&#39;a Value),
</a><a href="#h0-9-38" id="h0-9-38" class="i">+    Index(&amp;&#39;a str, &amp;&#39;a str, Option&lt;&amp;&#39;a Value&gt;),
</a>     /// A key for a row identified by table name and row primary key
<a href="#h0-9-40" id="h0-9-40" class="d">-    Row(&amp;&#39;a str, &amp;&#39;a Value),
</a><a href="#h0-9-41" id="h0-9-41" class="i">+    Row(&amp;&#39;a str, Option&lt;&amp;&#39;a Value&gt;),
</a> }
 
 impl&lt;&#39;a&gt; Key&lt;&#39;a&gt; {
     /// Encodes the key as a byte vector
     fn encode(self) -&gt; Vec&lt;u8&gt; {
         match self {
<a href="#h0-9-48" id="h0-9-48" class="d">-            Self::Table(name) =&gt; [KeyPrefix::Table.encode(), name.as_bytes().to_vec()].concat(),
</a><a href="#h0-9-49" id="h0-9-49" class="d">-            Self::Index(table, column, value) =&gt; {
</a><a href="#h0-9-50" id="h0-9-50" class="d">-                [KeyPrefix::Index(table, column).encode(), Self::encode_value(value)].concat()
</a><a href="#h0-9-51" id="h0-9-51" class="d">-            }
</a><a href="#h0-9-52" id="h0-9-52" class="d">-            Self::Row(table, pk) =&gt; {
</a><a href="#h0-9-53" id="h0-9-53" class="d">-                [KeyPrefix::Row(table).encode(), Self::encode_value(pk)].concat()
</a><a href="#h0-9-54" id="h0-9-54" class="d">-            }
</a><a href="#h0-9-55" id="h0-9-55" class="i">+            Self::Table(name) =&gt; [vec![0x01], name.unwrap_or(&quot;&quot;).as_bytes().to_vec()].concat(),
</a><a href="#h0-9-56" id="h0-9-56" class="i">+            Self::Index(table, column, value) =&gt; [
</a><a href="#h0-9-57" id="h0-9-57" class="i">+                vec![0x02],
</a><a href="#h0-9-58" id="h0-9-58" class="i">+                table.as_bytes().to_vec(),
</a><a href="#h0-9-59" id="h0-9-59" class="i">+                vec![0x00],
</a><a href="#h0-9-60" id="h0-9-60" class="i">+                column.as_bytes().to_vec(),
</a><a href="#h0-9-61" id="h0-9-61" class="i">+                vec![0x00],
</a><a href="#h0-9-62" id="h0-9-62" class="i">+                value.map_or_else(Vec::new, Self::encode_value),
</a><a href="#h0-9-63" id="h0-9-63" class="i">+            ]
</a><a href="#h0-9-64" id="h0-9-64" class="i">+            .concat(),
</a><a href="#h0-9-65" id="h0-9-65" class="i">+            Self::Row(table, pk) =&gt; [
</a><a href="#h0-9-66" id="h0-9-66" class="i">+                vec![0x03],
</a><a href="#h0-9-67" id="h0-9-67" class="i">+                table.as_bytes().to_vec(),
</a><a href="#h0-9-68" id="h0-9-68" class="i">+                vec![0x00],
</a><a href="#h0-9-69" id="h0-9-69" class="i">+                pk.map_or_else(Vec::new, Self::encode_value),
</a><a href="#h0-9-70" id="h0-9-70" class="i">+            ]
</a><a href="#h0-9-71" id="h0-9-71" class="i">+            .concat(),
</a>         }
     }
 
</pre>
</div>
</body>
</html>
