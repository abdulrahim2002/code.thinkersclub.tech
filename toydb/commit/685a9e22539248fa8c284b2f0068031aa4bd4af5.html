<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>raft: use log to store current term - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/685a9e22539248fa8c284b2f0068031aa4bd4af5.html">685a9e22539248fa8c284b2f0068031aa4bd4af5</a>
<b>parent</b> <a href="../commit/72b2d9e87828d0ea1a25c99fd42c15b50dff8776.html">72b2d9e87828d0ea1a25c99fd42c15b50dff8776</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun,  9 Jun 2024 00:22:40 +0200

raft: use log to store current term

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/log.rs</a></td><td> | </td><td class="num">13</td><td><span class="i">++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/raft/node.rs</a></td><td> | </td><td class="num">106</td><td><span class="i">++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------------</span></td></tr>
</table></pre><pre>2 files changed, 50 insertions(+), 69 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -145,13 +145,8 @@ impl Log {
</a>         (self.last_index, self.last_term)
     }
 
<a href="#h0-0-3" id="h0-0-3" class="d">-    /// Returns the current term (0 if none).
</a><a href="#h0-0-4" id="h0-0-4" class="d">-    pub fn get_term(&amp;self) -&gt; Term {
</a><a href="#h0-0-5" id="h0-0-5" class="d">-        self.term
</a><a href="#h0-0-6" id="h0-0-6" class="d">-    }
</a><a href="#h0-0-7" id="h0-0-7" class="d">-
</a><a href="#h0-0-8" id="h0-0-8" class="d">-    /// Returns the current term and vote.
</a><a href="#h0-0-9" id="h0-0-9" class="d">-    pub fn get_term_vote(&amp;self) -&gt; (Term, Option&lt;NodeID&gt;) {
</a><a href="#h0-0-10" id="h0-0-10" class="i">+    /// Returns the current term (0 if none) and vote.
</a><a href="#h0-0-11" id="h0-0-11" class="i">+    pub fn get_term(&amp;self) -&gt; (Term, Option&lt;NodeID&gt;) {
</a>         (self.term, self.vote)
     }
 
<a href="#h0-1" id="h0-1" class="h">@@ -402,7 +397,7 @@ mod tests {
</a>                 // get_term
                 &quot;get_term&quot; =&gt; {
                     command.consume_args().reject_rest()?;
<a href="#h0-1-3" id="h0-1-3" class="d">-                    let (term, vote) = self.log.get_term_vote();
</a><a href="#h0-1-4" id="h0-1-4" class="i">+                    let (term, vote) = self.log.get_term();
</a>                     output.push_str(&amp;format!(
                         &quot;term={term} vote={}\n&quot;,
                         vote.map(|v| v.to_string()).unwrap_or(&quot;None&quot;.to_string())
<a href="#h0-2" id="h0-2" class="h">@@ -489,7 +484,7 @@ mod tests {
</a>                     let mut args = command.consume_args();
                     let engine = args.lookup_parse(&quot;engine&quot;)?.unwrap_or(false);
                     args.reject_rest()?;
<a href="#h0-2-3" id="h0-2-3" class="d">-                    let (term, vote) = self.log.get_term_vote();
</a><a href="#h0-2-4" id="h0-2-4" class="i">+                    let (term, vote) = self.log.get_term();
</a>                     let (last_index, last_term) = self.log.get_last_index();
                     let (commit_index, commit_term) = self.log.get_commit_index();
                     output.push_str(&amp;format!(
<b>diff --git a/<a id="h1" href="../file/src/raft/node.rs.html">src/raft/node.rs</a> b/<a href="../file/src/raft/node.rs.html">src/raft/node.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -82,9 +82,9 @@ impl Node {
</a>     /// Returns the node term.
     pub fn term(&amp;self) -&gt; Term {
         match self {
<a href="#h1-0-3" id="h1-0-3" class="d">-            Node::Candidate(n) =&gt; n.term,
</a><a href="#h1-0-4" id="h1-0-4" class="d">-            Node::Follower(n) =&gt; n.term,
</a><a href="#h1-0-5" id="h1-0-5" class="d">-            Node::Leader(n) =&gt; n.term,
</a><a href="#h1-0-6" id="h1-0-6" class="i">+            Node::Candidate(n) =&gt; n.term(),
</a><a href="#h1-0-7" id="h1-0-7" class="i">+            Node::Follower(n) =&gt; n.term(),
</a><a href="#h1-0-8" id="h1-0-8" class="i">+            Node::Leader(n) =&gt; n.term(),
</a>         }
     }
 
<a href="#h1-1" id="h1-1" class="h">@@ -136,7 +136,6 @@ pub trait Role {}
</a> pub struct RawNode&lt;R: Role = Follower&gt; {
     id: NodeID,
     peers: HashSet&lt;NodeID&gt;,
<a href="#h1-1-3" id="h1-1-3" class="d">-    term: Term,
</a>     log: Log,
     state: Box&lt;dyn State&gt;,
     node_tx: crossbeam::channel::Sender&lt;Envelope&gt;,
<a href="#h1-2" id="h1-2" class="h">@@ -150,7 +149,6 @@ impl&lt;R: Role&gt; RawNode&lt;R&gt; {
</a>         RawNode {
             id: self.id,
             peers: self.peers,
<a href="#h1-2-3" id="h1-2-3" class="d">-            term: self.term,
</a>             log: self.log,
             state: self.state,
             node_tx: self.node_tx,
<a href="#h1-3" id="h1-3" class="h">@@ -159,6 +157,11 @@ impl&lt;R: Role&gt; RawNode&lt;R&gt; {
</a>         }
     }
 
<a href="#h1-3-3" id="h1-3-3" class="i">+    /// Returns the node&#39;s current term. Convenience wrapper for Log.get_term().
</a><a href="#h1-3-4" id="h1-3-4" class="i">+    fn term(&amp;self) -&gt; Term {
</a><a href="#h1-3-5" id="h1-3-5" class="i">+        self.log.get_term().0
</a><a href="#h1-3-6" id="h1-3-6" class="i">+    }
</a><a href="#h1-3-7" id="h1-3-7" class="i">+
</a>     /// Applies any pending, committed entries to the state machine. The command
     /// responses are discarded, use maybe_apply_with() instead to access them.
     fn maybe_apply(&amp;mut self) -&gt; Result&lt;()&gt; {
<a href="#h1-4" id="h1-4" class="h">@@ -207,7 +210,7 @@ impl&lt;R: Role&gt; RawNode&lt;R&gt; {
</a> 
     /// Sends a message.
     fn send(&amp;self, to: NodeID, message: Message) -&gt; Result&lt;()&gt; {
<a href="#h1-4-3" id="h1-4-3" class="d">-        let msg = Envelope { from: self.id, to, term: self.term, message };
</a><a href="#h1-4-4" id="h1-4-4" class="i">+        let msg = Envelope { from: self.id, to, term: self.term(), message };
</a>         debug!(&quot;Sending {msg:?}&quot;);
         Ok(self.node_tx.send(msg)?)
     }
<a href="#h1-5" id="h1-5" class="h">@@ -226,12 +229,6 @@ impl&lt;R: Role&gt; RawNode&lt;R&gt; {
</a>         rand::thread_rng().gen_range(self.opts.election_timeout_range.clone())
     }
 
<a href="#h1-5-3" id="h1-5-3" class="d">-    /// Asserts common node invariants.
</a><a href="#h1-5-4" id="h1-5-4" class="d">-    fn assert_node(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h1-5-5" id="h1-5-5" class="d">-        debug_assert_eq!(self.term, self.log.get_term(), &quot;Term does not match log&quot;);
</a><a href="#h1-5-6" id="h1-5-6" class="d">-        Ok(())
</a><a href="#h1-5-7" id="h1-5-7" class="d">-    }
</a><a href="#h1-5-8" id="h1-5-8" class="d">-
</a>     /// Asserts message invariants when stepping.
     fn assert_step(&amp;self, msg: &amp;Envelope) {
         // Messages must be addressed to the local node.
<a href="#h1-6" id="h1-6" class="h">@@ -268,11 +265,9 @@ impl Role for Candidate {}
</a> impl RawNode&lt;Candidate&gt; {
     /// Asserts internal invariants.
     fn assert(&amp;mut self) -&gt; Result&lt;()&gt; {
<a href="#h1-6-3" id="h1-6-3" class="d">-        self.assert_node()?;
</a><a href="#h1-6-4" id="h1-6-4" class="d">-
</a><a href="#h1-6-5" id="h1-6-5" class="d">-        assert_ne!(self.term, 0, &quot;Candidates can&#39;t have term 0&quot;);
</a><a href="#h1-6-6" id="h1-6-6" class="d">-        assert!(self.role.votes.contains(&amp;self.id), &quot;Candidate did not vote for self&quot;);
</a><a href="#h1-6-7" id="h1-6-7" class="d">-        debug_assert_eq!(Some(self.id), self.log.get_term_vote().1, &quot;Log vote does not match self&quot;);
</a><a href="#h1-6-8" id="h1-6-8" class="i">+        assert_ne!(self.term(), 0, &quot;candidates can&#39;t have term 0&quot;);
</a><a href="#h1-6-9" id="h1-6-9" class="i">+        assert!(self.role.votes.contains(&amp;self.id), &quot;candidate did not vote for self&quot;);
</a><a href="#h1-6-10" id="h1-6-10" class="i">+        debug_assert_eq!(Some(self.id), self.log.get_term().1, &quot;log vote does not match self&quot;);
</a> 
         assert!(
             self.role.election_duration &lt; self.role.election_timeout,
<a href="#h1-7" id="h1-7" class="h">@@ -286,20 +281,19 @@ impl RawNode&lt;Candidate&gt; {
</a>     /// follow the winner, or we discovered a new term in which case we step
     /// into it as a leaderless follower.
     fn into_follower(mut self, term: Term, leader: Option&lt;NodeID&gt;) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
<a href="#h1-7-3" id="h1-7-3" class="d">-        assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
</a><a href="#h1-7-4" id="h1-7-4" class="i">+        assert!(term &gt;= self.term(), &quot;term regression {} → {}&quot;, self.term(), term);
</a> 
         let election_timeout = self.gen_election_timeout();
         if let Some(leader) = leader {
             // We lost the election, follow the winner.
<a href="#h1-7-9" id="h1-7-9" class="d">-            assert_eq!(term, self.term, &quot;Can&#39;t follow leader in different term&quot;);
</a><a href="#h1-7-10" id="h1-7-10" class="i">+            assert_eq!(term, self.term(), &quot;can&#39;t follow leader in different term&quot;);
</a>             info!(&quot;Lost election, following leader {} in term {}&quot;, leader, term);
             Ok(self.into_role(Follower::new(Some(leader), election_timeout)))
         } else {
             // We found a new term, but we don&#39;t necessarily know who the leader
             // is yet. We&#39;ll find out when we step a message from it.
<a href="#h1-7-16" id="h1-7-16" class="d">-            assert_ne!(term, self.term, &quot;Can&#39;t become leaderless follower in current term&quot;);
</a><a href="#h1-7-17" id="h1-7-17" class="i">+            assert_ne!(term, self.term(), &quot;can&#39;t be leaderless follower in current term&quot;);
</a>             info!(&quot;Discovered new term {}&quot;, term);
<a href="#h1-7-19" id="h1-7-19" class="d">-            self.term = term;
</a>             self.log.set_term(term, None)?;
             Ok(self.into_role(Follower::new(None, election_timeout)))
         }
<a href="#h1-8" id="h1-8" class="h">@@ -307,7 +301,7 @@ impl RawNode&lt;Candidate&gt; {
</a> 
     /// Transitions the candidate to a leader. We won the election.
     fn into_leader(self) -&gt; Result&lt;RawNode&lt;Leader&gt;&gt; {
<a href="#h1-8-3" id="h1-8-3" class="d">-        info!(&quot;Won election for term {}, becoming leader&quot;, self.term);
</a><a href="#h1-8-4" id="h1-8-4" class="i">+        info!(&quot;Won election for term {}, becoming leader&quot;, self.term());
</a>         let peers = self.peers.clone();
         let (last_index, _) = self.log.get_last_index();
         let mut node = self.into_role(Leader::new(peers, last_index));
<a href="#h1-9" id="h1-9" class="h">@@ -330,7 +324,7 @@ impl RawNode&lt;Candidate&gt; {
</a>         self.assert_step(&amp;msg);
 
         // Drop messages from past terms.
<a href="#h1-9-3" id="h1-9-3" class="d">-        if msg.term &lt; self.term {
</a><a href="#h1-9-4" id="h1-9-4" class="i">+        if msg.term &lt; self.term() {
</a>             debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
             return Ok(self.into());
         }
<a href="#h1-10" id="h1-10" class="h">@@ -338,7 +332,7 @@ impl RawNode&lt;Candidate&gt; {
</a>         // If we receive a message for a future term, become a leaderless
         // follower in it and step the message. If the message is a Heartbeat or
         // Append from the leader, stepping it will follow the leader.
<a href="#h1-10-3" id="h1-10-3" class="d">-        if msg.term &gt; self.term {
</a><a href="#h1-10-4" id="h1-10-4" class="i">+        if msg.term &gt; self.term() {
</a>             return self.into_follower(msg.term, None)?.step(msg);
         }
 
<a href="#h1-11" id="h1-11" class="h">@@ -394,11 +388,10 @@ impl RawNode&lt;Candidate&gt; {
</a>     /// Campaign for leadership by increasing the term, voting for ourself, and
     /// soliciting votes from all peers.
     fn campaign(&amp;mut self) -&gt; Result&lt;()&gt; {
<a href="#h1-11-3" id="h1-11-3" class="d">-        let term = self.term + 1;
</a><a href="#h1-11-4" id="h1-11-4" class="d">-        info!(&quot;Starting new election for term {}&quot;, term);
</a><a href="#h1-11-5" id="h1-11-5" class="i">+        let term = self.term() + 1;
</a><a href="#h1-11-6" id="h1-11-6" class="i">+        info!(&quot;Starting new election for term {term}&quot;);
</a>         self.role = Candidate::new(self.gen_election_timeout());
         self.role.votes.insert(self.id); // vote for ourself
<a href="#h1-11-9" id="h1-11-9" class="d">-        self.term = term;
</a>         self.log.set_term(term, Some(self.id))?;
 
         let (last_index, last_term) = self.log.get_last_index();
<a href="#h1-12" id="h1-12" class="h">@@ -439,21 +432,18 @@ impl RawNode&lt;Follower&gt; {
</a>         node_tx: crossbeam::channel::Sender&lt;Envelope&gt;,
         opts: Options,
     ) -&gt; Result&lt;Self&gt; {
<a href="#h1-12-3" id="h1-12-3" class="d">-        let term = log.get_term();
</a>         let role = Follower::new(None, 0);
<a href="#h1-12-5" id="h1-12-5" class="d">-        let mut node = Self { id, peers, term, log, state, node_tx, opts, role };
</a><a href="#h1-12-6" id="h1-12-6" class="i">+        let mut node = Self { id, peers, log, state, node_tx, opts, role };
</a>         node.role.election_timeout = node.gen_election_timeout();
         Ok(node)
     }
 
     /// Asserts internal invariants.
     fn assert(&amp;mut self) -&gt; Result&lt;()&gt; {
<a href="#h1-12-13" id="h1-12-13" class="d">-        self.assert_node()?;
</a><a href="#h1-12-14" id="h1-12-14" class="d">-
</a>         if let Some(leader) = self.role.leader {
             assert_ne!(leader, self.id, &quot;Can&#39;t follow self&quot;);
             assert!(self.peers.contains(&amp;leader), &quot;Leader not in peers&quot;);
<a href="#h1-12-18" id="h1-12-18" class="d">-            assert_ne!(self.term, 0, &quot;Followers with leaders can&#39;t have term 0&quot;);
</a><a href="#h1-12-19" id="h1-12-19" class="i">+            assert_ne!(self.term(), 0, &quot;Followers with leaders can&#39;t have term 0&quot;);
</a>         } else {
             assert!(self.role.forwarded.is_empty(), &quot;Leaderless follower has forwarded requests&quot;);
         }
<a href="#h1-13" id="h1-13" class="h">@@ -485,7 +475,7 @@ impl RawNode&lt;Follower&gt; {
</a>     /// in a new term (e.g. if someone holds a new election) or following a
     /// leader in the current term once someone wins the election.
     fn into_follower(mut self, leader: Option&lt;NodeID&gt;, term: Term) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
<a href="#h1-13-3" id="h1-13-3" class="d">-        assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
</a><a href="#h1-13-4" id="h1-13-4" class="i">+        assert!(term &gt;= self.term(), &quot;term regression {} → {}&quot;, self.term(), term);
</a> 
         // Abort any forwarded requests. These must be retried with new leader.
         self.abort_forwarded()?;
<a href="#h1-14" id="h1-14" class="h">@@ -493,15 +483,14 @@ impl RawNode&lt;Follower&gt; {
</a>         if let Some(leader) = leader {
             // We found a leader in the current term.
             assert_eq!(self.role.leader, None, &quot;Already have leader in term&quot;);
<a href="#h1-14-3" id="h1-14-3" class="d">-            assert_eq!(term, self.term, &quot;Can&#39;t follow leader in different term&quot;);
</a><a href="#h1-14-4" id="h1-14-4" class="d">-            info!(&quot;Following leader {} in term {}&quot;, leader, term);
</a><a href="#h1-14-5" id="h1-14-5" class="i">+            assert_eq!(term, self.term(), &quot;Can&#39;t follow leader in different term&quot;);
</a><a href="#h1-14-6" id="h1-14-6" class="i">+            info!(&quot;Following leader {leader} in term {term}&quot;);
</a>             self.role = Follower::new(Some(leader), self.role.election_timeout);
         } else {
             // We found a new term, but we don&#39;t necessarily know who the leader
             // is yet. We&#39;ll find out when we step a message from it.
<a href="#h1-14-11" id="h1-14-11" class="d">-            assert_ne!(term, self.term, &quot;Can&#39;t become leaderless follower in current term&quot;);
</a><a href="#h1-14-12" id="h1-14-12" class="d">-            info!(&quot;Discovered new term {}&quot;, term);
</a><a href="#h1-14-13" id="h1-14-13" class="d">-            self.term = term;
</a><a href="#h1-14-14" id="h1-14-14" class="i">+            assert_ne!(term, self.term(), &quot;can&#39;t be leaderless follower in current term&quot;);
</a><a href="#h1-14-15" id="h1-14-15" class="i">+            info!(&quot;Discovered new term {term}&quot;);
</a>             self.log.set_term(term, None)?;
             self.role = Follower::new(None, self.gen_election_timeout());
         }
<a href="#h1-15" id="h1-15" class="h">@@ -514,7 +503,7 @@ impl RawNode&lt;Follower&gt; {
</a>         self.assert_step(&amp;msg);
 
         // Drop messages from past terms.
<a href="#h1-15-3" id="h1-15-3" class="d">-        if msg.term &lt; self.term {
</a><a href="#h1-15-4" id="h1-15-4" class="i">+        if msg.term &lt; self.term() {
</a>             debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
             return Ok(self.into());
         }
<a href="#h1-16" id="h1-16" class="h">@@ -522,7 +511,7 @@ impl RawNode&lt;Follower&gt; {
</a>         // If we receive a message for a future term, become a leaderless
         // follower in it and step the message. If the message is a Heartbeat or
         // Append from the leader, stepping it will follow the leader.
<a href="#h1-16-3" id="h1-16-3" class="d">-        if msg.term &gt; self.term {
</a><a href="#h1-16-4" id="h1-16-4" class="i">+        if msg.term &gt; self.term() {
</a>             return self.into_follower(None, msg.term)?.step(msg);
         }
 
<a href="#h1-17" id="h1-17" class="h">@@ -588,7 +577,7 @@ impl RawNode&lt;Follower&gt; {
</a>             // A candidate in this term is requesting our vote.
             Message::Campaign { last_index, last_term } =&gt; {
                 // Don&#39;t vote if we already voted for someone else in this term.
<a href="#h1-17-3" id="h1-17-3" class="d">-                if let (_, Some(vote)) = self.log.get_term_vote() {
</a><a href="#h1-17-4" id="h1-17-4" class="i">+                if let (_, Some(vote)) = self.log.get_term() {
</a>                     if msg.from != vote {
                         self.send(msg.from, Message::CampaignResponse { vote: false })?;
                         return Ok(self.into());
<a href="#h1-18" id="h1-18" class="h">@@ -603,8 +592,8 @@ impl RawNode&lt;Follower&gt; {
</a>                 }
 
                 // Grant the vote.
<a href="#h1-18-3" id="h1-18-3" class="d">-                info!(&quot;Voting for {} in term {} election&quot;, msg.from, self.term);
</a><a href="#h1-18-4" id="h1-18-4" class="d">-                self.log.set_term(self.term, Some(msg.from))?;
</a><a href="#h1-18-5" id="h1-18-5" class="i">+                info!(&quot;Voting for {} in term {} election&quot;, msg.from, msg.term);
</a><a href="#h1-18-6" id="h1-18-6" class="i">+                self.log.set_term(msg.term, Some(msg.from))?;
</a>                 self.send(msg.from, Message::CampaignResponse { vote: true })?;
             }
 
<a href="#h1-19" id="h1-19" class="h">@@ -787,11 +776,8 @@ impl Role for Leader {}
</a> impl RawNode&lt;Leader&gt; {
     /// Asserts internal invariants.
     fn assert(&amp;mut self) -&gt; Result&lt;()&gt; {
<a href="#h1-19-3" id="h1-19-3" class="d">-        self.assert_node()?;
</a><a href="#h1-19-4" id="h1-19-4" class="d">-
</a><a href="#h1-19-5" id="h1-19-5" class="d">-        assert_ne!(self.term, 0, &quot;Leaders can&#39;t have term 0&quot;);
</a><a href="#h1-19-6" id="h1-19-6" class="d">-        debug_assert_eq!(Some(self.id), self.log.get_term_vote().1, &quot;Log vote does not match self&quot;);
</a><a href="#h1-19-7" id="h1-19-7" class="d">-
</a><a href="#h1-19-8" id="h1-19-8" class="i">+        assert_ne!(self.term(), 0, &quot;leaders can&#39;t have term 0&quot;);
</a><a href="#h1-19-9" id="h1-19-9" class="i">+        debug_assert_eq!(Some(self.id), self.log.get_term().1, &quot;vote does not match self&quot;);
</a>         Ok(())
     }
 
<a href="#h1-20" id="h1-20" class="h">@@ -799,10 +785,10 @@ impl RawNode&lt;Leader&gt; {
</a>     /// discover a new term, so we become a leaderless follower. Subsequently
     /// stepping the received message may discover the leader, if there is one.
     fn into_follower(mut self, term: Term) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
<a href="#h1-20-3" id="h1-20-3" class="d">-        assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
</a><a href="#h1-20-4" id="h1-20-4" class="d">-        assert!(term &gt; self.term, &quot;Can only become follower in later term&quot;);
</a><a href="#h1-20-5" id="h1-20-5" class="i">+        assert!(term &gt;= self.term(), &quot;term regression {} → {}&quot;, self.term(), term);
</a><a href="#h1-20-6" id="h1-20-6" class="i">+        assert!(term &gt; self.term(), &quot;can only become follower in later term&quot;);
</a> 
<a href="#h1-20-8" id="h1-20-8" class="d">-        info!(&quot;Discovered new term {}&quot;, term);
</a><a href="#h1-20-9" id="h1-20-9" class="i">+        info!(&quot;Discovered new term {term}&quot;);
</a> 
         // Cancel in-flight requests.
         for write in std::mem::take(&amp;mut self.role.writes).into_values().sorted_by_key(|w| w.id) {
<a href="#h1-21" id="h1-21" class="h">@@ -818,7 +804,6 @@ impl RawNode&lt;Leader&gt; {
</a>             )?;
         }
 
<a href="#h1-21-3" id="h1-21-3" class="d">-        self.term = term;
</a>         self.log.set_term(term, None)?;
         let election_timeout = self.gen_election_timeout();
         Ok(self.into_role(Follower::new(None, election_timeout)))
<a href="#h1-22" id="h1-22" class="h">@@ -830,7 +815,7 @@ impl RawNode&lt;Leader&gt; {
</a>         self.assert_step(&amp;msg);
 
         // Drop messages from past terms.
<a href="#h1-22-3" id="h1-22-3" class="d">-        if msg.term &lt; self.term {
</a><a href="#h1-22-4" id="h1-22-4" class="i">+        if msg.term &lt; self.term() {
</a>             debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
             return Ok(self.into());
         }
<a href="#h1-23" id="h1-23" class="h">@@ -838,7 +823,7 @@ impl RawNode&lt;Leader&gt; {
</a>         // If we receive a message for a future term, become a leaderless
         // follower in it and step the message. If the message is a Heartbeat or
         // Append from the leader, stepping it will follow the leader.
<a href="#h1-23-3" id="h1-23-3" class="d">-        if msg.term &gt; self.term {
</a><a href="#h1-23-4" id="h1-23-4" class="i">+        if msg.term &gt; self.term() {
</a>             return self.into_follower(msg.term)?.step(msg);
         }
 
<a href="#h1-24" id="h1-24" class="h">@@ -953,7 +938,7 @@ impl RawNode&lt;Leader&gt; {
</a>             Message::ClientRequest { id, request: Request::Status } =&gt; {
                 let status = Status {
                     leader: self.id,
<a href="#h1-24-3" id="h1-24-3" class="d">-                    term: self.term,
</a><a href="#h1-24-4" id="h1-24-4" class="i">+                    term: self.term(),
</a>                     match_index: self
                         .role
                         .progress
<a href="#h1-25" id="h1-25" class="h">@@ -1005,7 +990,7 @@ impl RawNode&lt;Leader&gt; {
</a>         let (commit_index, _) = self.log.get_commit_index();
         let read_seq = self.role.read_seq;
 
<a href="#h1-25-3" id="h1-25-3" class="d">-        assert_eq!(last_term, self.term, &quot;leader has stale last_term&quot;);
</a><a href="#h1-25-4" id="h1-25-4" class="i">+        assert_eq!(last_term, self.term(), &quot;leader has stale last_term&quot;);
</a> 
         self.broadcast(Message::Heartbeat { last_index, commit_index, read_seq })?;
         // NB: We don&#39;t reset self.since_heartbeat here, because we want to send
<a href="#h1-26" id="h1-26" class="h">@@ -1059,7 +1044,7 @@ impl RawNode&lt;Leader&gt; {
</a>         // We can only safely commit an entry from our own term (see figure 8 in
         // Raft paper).
         commit_index = match self.log.get(quorum_index)? {
<a href="#h1-26-3" id="h1-26-3" class="d">-            Some(entry) if entry.term == self.term =&gt; quorum_index,
</a><a href="#h1-26-4" id="h1-26-4" class="i">+            Some(entry) if entry.term == self.term() =&gt; quorum_index,
</a>             Some(_) =&gt; return Ok(commit_index),
             None =&gt; panic!(&quot;missing commit index {quorum_index} missing&quot;),
         };
<a href="#h1-27" id="h1-27" class="h">@@ -1068,13 +1053,14 @@ impl RawNode&lt;Leader&gt; {
</a>         self.log.commit(commit_index)?;
 
         // Apply entries and respond to client writers.
<a href="#h1-27-3" id="h1-27-3" class="i">+        let term = self.term();
</a>         Self::maybe_apply_with(&amp;mut self.log, &amp;mut self.state, |index, result| -&gt; Result&lt;()&gt; {
             if let Some(write) = self.role.writes.remove(&amp;index) {
                 // TODO: use self.send() or something.
                 self.node_tx.send(Envelope {
                     from: self.id,
                     to: write.from,
<a href="#h1-27-10" id="h1-27-10" class="d">-                    term: self.term,
</a><a href="#h1-27-11" id="h1-27-11" class="i">+                    term,
</a>                     message: Message::ClientResponse {
                         id: write.id,
                         response: result.map(Response::Write),
<a href="#h1-28" id="h1-28" class="h">@@ -1086,7 +1072,7 @@ impl RawNode&lt;Leader&gt; {
</a> 
         // If the commit term changed, there may be pending reads waiting for us
         // to commit an entry from our own term. Execute them.
<a href="#h1-28-3" id="h1-28-3" class="d">-        if old_commit_term != self.term {
</a><a href="#h1-28-4" id="h1-28-4" class="i">+        if old_commit_term != self.term() {
</a>             self.maybe_read()?;
         }
 
<a href="#h1-29" id="h1-29" class="h">@@ -1106,7 +1092,7 @@ impl RawNode&lt;Leader&gt; {
</a>         // linearizability.
         let (commit_index, commit_term) = self.log.get_commit_index();
         let applied_index = self.state.get_applied_index();
<a href="#h1-29-3" id="h1-29-3" class="d">-        if commit_term &lt; self.term || applied_index &lt; commit_index {
</a><a href="#h1-29-4" id="h1-29-4" class="i">+        if commit_term &lt; self.term() || applied_index &lt; commit_index {
</a>             return Ok(());
         }
 
</pre>
</div>
</body>
</html>
