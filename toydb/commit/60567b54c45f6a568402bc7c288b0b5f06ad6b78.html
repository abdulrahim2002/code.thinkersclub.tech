<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rewrite Raft log store to use a regular storage engine. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/60567b54c45f6a568402bc7c288b0b5f06ad6b78.html">60567b54c45f6a568402bc7c288b0b5f06ad6b78</a>
<b>parent</b> <a href="../commit/0ace16edb664e4b150a228c890d7880ffd6ff5c7.html">0ace16edb664e4b150a228c890d7880ffd6ff5c7</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue, 14 Nov 2023 21:38:23 +0100

Rewrite Raft log store to use a regular storage engine.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">config/toydb.yaml</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/bin/toydb.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">+++++++++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/log.rs</a></td><td> | </td><td class="num">709</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">24</td><td><span class="i">++++++++++++</span><span class="d">------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/raft/node/follower.rs</a></td><td> | </td><td class="num">137</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">--------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/raft/node/leader.rs</a></td><td> | </td><td class="num">61</td><td><span class="i">+++++++++++++++++++++++++++++++</span><span class="d">------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/raft/node/mod.rs</a></td><td> | </td><td class="num">66</td><td><span class="i">+++++++++++++++++++++++</span><span class="d">-------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/server.rs</a></td><td> | </td><td class="num">5</td><td><span class="i">++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">tests/client/mod.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">tests/setup.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
</table></pre><pre>11 files changed, 515 insertions(+), 519 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/config/toydb.yaml.html">config/toydb.yaml</a> b/<a href="../file/config/toydb.yaml.html">config/toydb.yaml</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -20,9 +20,9 @@ compact_threshold: 0.2
</a> sync: true
 
 # Raft log storage engine
<a href="#h0-0-3" id="h0-0-3" class="d">-# - hybrid: (default) stores committed entries in an indexed append-only file, the rest in memory.
</a><a href="#h0-0-4" id="h0-0-4" class="d">-# - memory: stores all entries in memory.
</a><a href="#h0-0-5" id="h0-0-5" class="d">-storage_raft: hybrid
</a><a href="#h0-0-6" id="h0-0-6" class="i">+# - bitcask (default): an append-only log-structured store.
</a><a href="#h0-0-7" id="h0-0-7" class="i">+# - memory: an in-memory store using the Rust standard library&#39;s BTreeMap.
</a><a href="#h0-0-8" id="h0-0-8" class="i">+storage_raft: bitcask
</a> 
 # SQL key-value storage engine
 # - bitcask (default): an append-only log-structured store.
<b>diff --git a/<a id="h1" href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a> b/<a href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -35,9 +35,15 @@ async fn main() -&gt; Result&lt;()&gt; {
</a>     simplelog::SimpleLogger::init(loglevel, logconfig.build())?;
 
     let path = std::path::Path::new(&amp;cfg.data_dir);
<a href="#h1-0-3" id="h1-0-3" class="d">-    let raft_store: Box&lt;dyn storage::log::Store&gt; = match cfg.storage_raft.as_str() {
</a><a href="#h1-0-4" id="h1-0-4" class="d">-        &quot;hybrid&quot; | &quot;&quot; =&gt; Box::new(storage::log::Hybrid::new(path, cfg.sync)?),
</a><a href="#h1-0-5" id="h1-0-5" class="d">-        &quot;memory&quot; =&gt; Box::new(storage::log::Memory::new()),
</a><a href="#h1-0-6" id="h1-0-6" class="i">+    let raft_log = match cfg.storage_raft.as_str() {
</a><a href="#h1-0-7" id="h1-0-7" class="i">+        &quot;bitcask&quot; | &quot;&quot; =&gt; raft::Log::new(
</a><a href="#h1-0-8" id="h1-0-8" class="i">+            Box::new(storage::engine::BitCask::new_compact(
</a><a href="#h1-0-9" id="h1-0-9" class="i">+                path.join(&quot;log&quot;),
</a><a href="#h1-0-10" id="h1-0-10" class="i">+                cfg.compact_threshold,
</a><a href="#h1-0-11" id="h1-0-11" class="i">+            )?),
</a><a href="#h1-0-12" id="h1-0-12" class="i">+            cfg.sync,
</a><a href="#h1-0-13" id="h1-0-13" class="i">+        )?,
</a><a href="#h1-0-14" id="h1-0-14" class="i">+        &quot;memory&quot; =&gt; raft::Log::new(Box::new(storage::engine::Memory::new()), false)?,
</a>         name =&gt; return Err(Error::Config(format!(&quot;Unknown Raft storage engine {}&quot;, name))),
     };
     let raft_state: Box&lt;dyn raft::State&gt; = match cfg.storage_sql.as_str() {
<a href="#h1-1" id="h1-1" class="h">@@ -53,7 +59,7 @@ async fn main() -&gt; Result&lt;()&gt; {
</a>         name =&gt; return Err(Error::Config(format!(&quot;Unknown SQL storage engine {}&quot;, name))),
     };
 
<a href="#h1-1-3" id="h1-1-3" class="d">-    Server::new(&amp;cfg.id, cfg.peers, raft_store, raft_state)
</a><a href="#h1-1-4" id="h1-1-4" class="i">+    Server::new(&amp;cfg.id, cfg.peers, raft_log, raft_state)
</a>         .await?
         .listen(&amp;cfg.listen_sql, &amp;cfg.listen_raft)
         .await?
<a href="#h1-2" id="h1-2" class="h">@@ -86,7 +92,7 @@ impl Config {
</a>             .set_default(&quot;data_dir&quot;, &quot;data&quot;)?
             .set_default(&quot;compact_threshold&quot;, 0.2)?
             .set_default(&quot;sync&quot;, true)?
<a href="#h1-2-3" id="h1-2-3" class="d">-            .set_default(&quot;storage_raft&quot;, &quot;hybrid&quot;)?
</a><a href="#h1-2-4" id="h1-2-4" class="i">+            .set_default(&quot;storage_raft&quot;, &quot;bitcask&quot;)?
</a>             .set_default(&quot;storage_sql&quot;, &quot;bitcask&quot;)?
             .add_source(config::File::with_name(file))
             .add_source(config::Environment::with_prefix(&quot;TOYDB&quot;))
<b>diff --git a/<a id="h2" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,10 +1,8 @@
</a> use crate::error::{Error, Result};
<a href="#h2-0-1" id="h2-0-1" class="d">-use crate::storage::log::Range;
</a><a href="#h2-0-2" id="h2-0-2" class="d">-use crate::storage::{self, bincode, log};
</a><a href="#h2-0-3" id="h2-0-3" class="i">+use crate::storage::{self, bincode, keycode};
</a> 
 use ::log::debug;
 use serde::{Deserialize, Serialize};
<a href="#h2-0-7" id="h2-0-7" class="d">-use std::ops::RangeBounds;
</a> 
 /// A log index.
 pub type Index = u64;
<a href="#h2-1" id="h2-1" class="h">@@ -13,10 +11,10 @@ pub type Index = u64;
</a> /// TODO: Consider moving this to the module root.
 pub type Term = u64;
 
<a href="#h2-1-3" id="h2-1-3" class="d">-/// A replicated log entry
</a><a href="#h2-1-4" id="h2-1-4" class="i">+/// A log entry.
</a> #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub struct Entry {
<a href="#h2-1-7" id="h2-1-7" class="d">-    /// The index of the entry.
</a><a href="#h2-1-8" id="h2-1-8" class="i">+    /// The entry index.
</a>     pub index: Index,
     /// The term in which the entry was added.
     pub term: Term,
<a href="#h2-2" id="h2-2" class="h">@@ -24,27 +22,47 @@ pub struct Entry {
</a>     pub command: Option&lt;Vec&lt;u8&gt;&gt;,
 }
 
<a href="#h2-2-3" id="h2-2-3" class="d">-/// A metadata key
</a><a href="#h2-2-4" id="h2-2-4" class="d">-#[derive(Clone, Debug, PartialEq)]
</a><a href="#h2-2-5" id="h2-2-5" class="i">+/// A log key, encoded using KeyCode.
</a><a href="#h2-2-6" id="h2-2-6" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a> pub enum Key {
<a href="#h2-2-8" id="h2-2-8" class="i">+    /// A log entry, storing the term and command.
</a><a href="#h2-2-9" id="h2-2-9" class="i">+    Entry(Index),
</a><a href="#h2-2-10" id="h2-2-10" class="i">+    /// Stores the current term and vote (if any).
</a>     TermVote,
<a href="#h2-2-12" id="h2-2-12" class="i">+    /// Stores the current commit index (if any).
</a><a href="#h2-2-13" id="h2-2-13" class="i">+    CommitIndex,
</a> }
 
 impl Key {
<a href="#h2-2-17" id="h2-2-17" class="d">-    fn encode(&amp;self) -&gt; Vec&lt;u8&gt; {
</a><a href="#h2-2-18" id="h2-2-18" class="d">-        match self {
</a><a href="#h2-2-19" id="h2-2-19" class="d">-            Self::TermVote =&gt; vec![0x00],
</a><a href="#h2-2-20" id="h2-2-20" class="d">-        }
</a><a href="#h2-2-21" id="h2-2-21" class="i">+    fn decode(bytes: &amp;[u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h2-2-22" id="h2-2-22" class="i">+        keycode::deserialize(bytes)
</a><a href="#h2-2-23" id="h2-2-23" class="i">+    }
</a><a href="#h2-2-24" id="h2-2-24" class="i">+
</a><a href="#h2-2-25" id="h2-2-25" class="i">+    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-2-26" id="h2-2-26" class="i">+        keycode::serialize(self)
</a>     }
 }
 
<a href="#h2-2-30" id="h2-2-30" class="i">+/// Log key prefixes, used for prefix scans.
</a><a href="#h2-2-31" id="h2-2-31" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h2-2-32" id="h2-2-32" class="i">+enum KeyPrefix {
</a><a href="#h2-2-33" id="h2-2-33" class="i">+    Entry,
</a><a href="#h2-2-34" id="h2-2-34" class="i">+    TermVote,
</a><a href="#h2-2-35" id="h2-2-35" class="i">+    CommitIndex,
</a><a href="#h2-2-36" id="h2-2-36" class="i">+}
</a><a href="#h2-2-37" id="h2-2-37" class="i">+
</a><a href="#h2-2-38" id="h2-2-38" class="i">+impl KeyPrefix {
</a><a href="#h2-2-39" id="h2-2-39" class="i">+    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-2-40" id="h2-2-40" class="i">+        keycode::serialize(self)
</a><a href="#h2-2-41" id="h2-2-41" class="i">+    }
</a><a href="#h2-2-42" id="h2-2-42" class="i">+}
</a> /// A log scan
 pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Entry&gt;&gt; + &#39;a&gt;;
 
<a href="#h2-2-46" id="h2-2-46" class="d">-/// The replicated Raft log
</a><a href="#h2-2-47" id="h2-2-47" class="i">+/// A Raft log.
</a> pub struct Log {
<a href="#h2-2-49" id="h2-2-49" class="d">-    /// The underlying log store.
</a><a href="#h2-2-50" id="h2-2-50" class="d">-    pub(super) store: Box&lt;dyn log::Store&gt;,
</a><a href="#h2-2-51" id="h2-2-51" class="i">+    /// The underlying storage engine.
</a><a href="#h2-2-52" id="h2-2-52" class="i">+    engine: Box&lt;dyn Engine&gt;,
</a>     /// The index of the last stored entry.
     last_index: Index,
     /// The term of the last stored entry.
<a href="#h2-3" id="h2-3" class="h">@@ -53,30 +71,47 @@ pub struct Log {
</a>     commit_index: Index,
     /// The term of the last committed entry.
     commit_term: Term,
<a href="#h2-3-3" id="h2-3-3" class="i">+    /// Whether to sync writes to disk.
</a><a href="#h2-3-4" id="h2-3-4" class="i">+    sync: bool,
</a> }
 
 impl Log {
<a href="#h2-3-8" id="h2-3-8" class="d">-    /// Creates a new log, using a log::Store for storage.
</a><a href="#h2-3-9" id="h2-3-9" class="d">-    pub fn new(store: Box&lt;dyn log::Store&gt;) -&gt; Result&lt;Self&gt; {
</a><a href="#h2-3-10" id="h2-3-10" class="d">-        let (commit_index, commit_term) = match store.committed() {
</a><a href="#h2-3-11" id="h2-3-11" class="d">-            0 =&gt; (0, 0),
</a><a href="#h2-3-12" id="h2-3-12" class="d">-            index =&gt; store
</a><a href="#h2-3-13" id="h2-3-13" class="d">-                .get(index)?
</a><a href="#h2-3-14" id="h2-3-14" class="d">-                .map(|v| bincode::deserialize::&lt;Entry&gt;(&amp;v))
</a><a href="#h2-3-15" id="h2-3-15" class="d">-                .transpose()?
</a><a href="#h2-3-16" id="h2-3-16" class="d">-                .map(|e| (e.index, e.term))
</a><a href="#h2-3-17" id="h2-3-17" class="d">-                .ok_or_else(|| Error::Internal(&quot;Committed entry not found&quot;.into()))?,
</a><a href="#h2-3-18" id="h2-3-18" class="d">-        };
</a><a href="#h2-3-19" id="h2-3-19" class="d">-        let (last_index, last_term) = match store.len() {
</a><a href="#h2-3-20" id="h2-3-20" class="d">-            0 =&gt; (0, 0),
</a><a href="#h2-3-21" id="h2-3-21" class="d">-            index =&gt; store
</a><a href="#h2-3-22" id="h2-3-22" class="d">-                .get(index)?
</a><a href="#h2-3-23" id="h2-3-23" class="d">-                .map(|v| bincode::deserialize::&lt;Entry&gt;(&amp;v))
</a><a href="#h2-3-24" id="h2-3-24" class="d">-                .transpose()?
</a><a href="#h2-3-25" id="h2-3-25" class="d">-                .map(|e| (e.index, e.term))
</a><a href="#h2-3-26" id="h2-3-26" class="d">-                .ok_or_else(|| Error::Internal(&quot;Last entry not found&quot;.into()))?,
</a><a href="#h2-3-27" id="h2-3-27" class="d">-        };
</a><a href="#h2-3-28" id="h2-3-28" class="d">-        Ok(Self { store, last_index, last_term, commit_index, commit_term })
</a><a href="#h2-3-29" id="h2-3-29" class="i">+    /// Creates a new log, using the given storage engine.
</a><a href="#h2-3-30" id="h2-3-30" class="i">+    pub fn new(mut engine: Box&lt;dyn Engine&gt;, sync: bool) -&gt; Result&lt;Self&gt; {
</a><a href="#h2-3-31" id="h2-3-31" class="i">+        let (last_index, last_term) = engine
</a><a href="#h2-3-32" id="h2-3-32" class="i">+            .scan_prefix(&amp;KeyPrefix::Entry.encode()?)
</a><a href="#h2-3-33" id="h2-3-33" class="i">+            .last()
</a><a href="#h2-3-34" id="h2-3-34" class="i">+            .transpose()?
</a><a href="#h2-3-35" id="h2-3-35" class="i">+            .map(|(k, v)| Self::decode_entry(&amp;k, &amp;v))
</a><a href="#h2-3-36" id="h2-3-36" class="i">+            .transpose()?
</a><a href="#h2-3-37" id="h2-3-37" class="i">+            .map(|e| (e.index, e.term))
</a><a href="#h2-3-38" id="h2-3-38" class="i">+            .unwrap_or((0, 0));
</a><a href="#h2-3-39" id="h2-3-39" class="i">+        let (commit_index, commit_term) = engine
</a><a href="#h2-3-40" id="h2-3-40" class="i">+            .get(&amp;Key::CommitIndex.encode()?)?
</a><a href="#h2-3-41" id="h2-3-41" class="i">+            .map(|v| bincode::deserialize(&amp;v))
</a><a href="#h2-3-42" id="h2-3-42" class="i">+            .transpose()?
</a><a href="#h2-3-43" id="h2-3-43" class="i">+            .unwrap_or((0, 0));
</a><a href="#h2-3-44" id="h2-3-44" class="i">+        Ok(Self { engine, last_index, last_term, commit_index, commit_term, sync })
</a><a href="#h2-3-45" id="h2-3-45" class="i">+    }
</a><a href="#h2-3-46" id="h2-3-46" class="i">+
</a><a href="#h2-3-47" id="h2-3-47" class="i">+    /// Decodes an entry from a log key/value pair.
</a><a href="#h2-3-48" id="h2-3-48" class="i">+    fn decode_entry(key: &amp;[u8], value: &amp;[u8]) -&gt; Result&lt;Entry&gt; {
</a><a href="#h2-3-49" id="h2-3-49" class="i">+        if let Key::Entry(index) = Key::decode(key)? {
</a><a href="#h2-3-50" id="h2-3-50" class="i">+            Self::decode_entry_value(index, value)
</a><a href="#h2-3-51" id="h2-3-51" class="i">+        } else {
</a><a href="#h2-3-52" id="h2-3-52" class="i">+            Err(Error::Internal(format!(&quot;Invalid key {:x?}&quot;, key)))
</a><a href="#h2-3-53" id="h2-3-53" class="i">+        }
</a><a href="#h2-3-54" id="h2-3-54" class="i">+    }
</a><a href="#h2-3-55" id="h2-3-55" class="i">+
</a><a href="#h2-3-56" id="h2-3-56" class="i">+    /// Decodes an entry from a value at a given index.
</a><a href="#h2-3-57" id="h2-3-57" class="i">+    fn decode_entry_value(index: Index, value: &amp;[u8]) -&gt; Result&lt;Entry&gt; {
</a><a href="#h2-3-58" id="h2-3-58" class="i">+        let (term, command) = bincode::deserialize(value)?;
</a><a href="#h2-3-59" id="h2-3-59" class="i">+        Ok(Entry { index, term, command })
</a><a href="#h2-3-60" id="h2-3-60" class="i">+    }
</a><a href="#h2-3-61" id="h2-3-61" class="i">+
</a><a href="#h2-3-62" id="h2-3-62" class="i">+    /// Returns log engine name and status.
</a><a href="#h2-3-63" id="h2-3-63" class="i">+    pub fn status(&amp;mut self) -&gt; Result&lt;storage::engine::Status&gt; {
</a><a href="#h2-3-64" id="h2-3-64" class="i">+        self.engine.status()
</a>     }
 
     /// Returns the commit index and term.
<a href="#h2-4" id="h2-4" class="h">@@ -90,10 +125,10 @@ impl Log {
</a>     }
 
     /// Returns the last known term (0 if none), and cast vote (if any).
<a href="#h2-4-3" id="h2-4-3" class="d">-    pub fn get_term(&amp;self) -&gt; Result&lt;(Term, Option&lt;String&gt;)&gt; {
</a><a href="#h2-4-4" id="h2-4-4" class="i">+    pub fn get_term(&amp;mut self) -&gt; Result&lt;(Term, Option&lt;String&gt;)&gt; {
</a>         let (term, voted_for) = self
<a href="#h2-4-6" id="h2-4-6" class="d">-            .store
</a><a href="#h2-4-7" id="h2-4-7" class="d">-            .get_metadata(&amp;Key::TermVote.encode())?
</a><a href="#h2-4-8" id="h2-4-8" class="i">+            .engine
</a><a href="#h2-4-9" id="h2-4-9" class="i">+            .get(&amp;Key::TermVote.encode()?)?
</a>             .map(|v| bincode::deserialize(&amp;v))
             .transpose()?
             .unwrap_or((0, None));
<a href="#h2-5" id="h2-5" class="h">@@ -103,37 +138,59 @@ impl Log {
</a> 
     /// Sets the most recent term, and cast vote (if any).
     pub fn set_term(&amp;mut self, term: Term, voted_for: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt; {
<a href="#h2-5-3" id="h2-5-3" class="d">-        self.store.set_metadata(&amp;Key::TermVote.encode(), bincode::serialize(&amp;(term, voted_for))?)
</a><a href="#h2-5-4" id="h2-5-4" class="i">+        self.engine.set(&amp;Key::TermVote.encode()?, bincode::serialize(&amp;(term, voted_for))?)?;
</a><a href="#h2-5-5" id="h2-5-5" class="i">+        self.maybe_flush()
</a>     }
 
<a href="#h2-5-8" id="h2-5-8" class="d">-    /// Appends a command to the log, returning the log index.
</a><a href="#h2-5-9" id="h2-5-9" class="i">+    /// Flushes the log to stable storage, if enabled.
</a><a href="#h2-5-10" id="h2-5-10" class="i">+    fn maybe_flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h2-5-11" id="h2-5-11" class="i">+        if self.sync {
</a><a href="#h2-5-12" id="h2-5-12" class="i">+            self.engine.flush()?;
</a><a href="#h2-5-13" id="h2-5-13" class="i">+        }
</a><a href="#h2-5-14" id="h2-5-14" class="i">+        Ok(())
</a><a href="#h2-5-15" id="h2-5-15" class="i">+    }
</a><a href="#h2-5-16" id="h2-5-16" class="i">+
</a><a href="#h2-5-17" id="h2-5-17" class="i">+    /// Appends a command to the log, returning its index. None implies a noop
</a><a href="#h2-5-18" id="h2-5-18" class="i">+    /// command, typically after Raft leader changes.
</a>     pub fn append(&amp;mut self, term: Term, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;Index&gt; {
<a href="#h2-5-20" id="h2-5-20" class="d">-        let entry = Entry { index: self.last_index + 1, term, command };
</a><a href="#h2-5-21" id="h2-5-21" class="d">-        debug!(&quot;Appending log entry {}: {:?}&quot;, entry.index, entry);
</a><a href="#h2-5-22" id="h2-5-22" class="d">-        self.store.append(bincode::serialize(&amp;entry)?)?;
</a><a href="#h2-5-23" id="h2-5-23" class="d">-        self.last_index = entry.index;
</a><a href="#h2-5-24" id="h2-5-24" class="d">-        self.last_term = entry.term;
</a><a href="#h2-5-25" id="h2-5-25" class="d">-        Ok(entry.index)
</a><a href="#h2-5-26" id="h2-5-26" class="i">+        let index = self.last_index + 1;
</a><a href="#h2-5-27" id="h2-5-27" class="i">+        self.engine.set(&amp;Key::Entry(index).encode()?, bincode::serialize(&amp;(term, command))?)?;
</a><a href="#h2-5-28" id="h2-5-28" class="i">+        self.maybe_flush()?;
</a><a href="#h2-5-29" id="h2-5-29" class="i">+        self.last_index = index;
</a><a href="#h2-5-30" id="h2-5-30" class="i">+        self.last_term = term;
</a><a href="#h2-5-31" id="h2-5-31" class="i">+        Ok(index)
</a>     }
 
<a href="#h2-5-34" id="h2-5-34" class="d">-    /// Commits entries up to and including an index.
</a><a href="#h2-5-35" id="h2-5-35" class="i">+    /// Commits entries up to and including the given index. The index must
</a><a href="#h2-5-36" id="h2-5-36" class="i">+    /// exist, and must be at or after the current commit index.
</a>     pub fn commit(&amp;mut self, index: Index) -&gt; Result&lt;u64&gt; {
<a href="#h2-5-38" id="h2-5-38" class="d">-        let entry = self
</a><a href="#h2-5-39" id="h2-5-39" class="d">-            .get(index)?
</a><a href="#h2-5-40" id="h2-5-40" class="d">-            .ok_or_else(|| Error::Internal(format!(&quot;Entry {} not found&quot;, index)))?;
</a><a href="#h2-5-41" id="h2-5-41" class="d">-        self.store.commit(index)?;
</a><a href="#h2-5-42" id="h2-5-42" class="i">+        if index &lt; self.commit_index {
</a><a href="#h2-5-43" id="h2-5-43" class="i">+            return Err(Error::Internal(format!(
</a><a href="#h2-5-44" id="h2-5-44" class="i">+                &quot;Commit index regression {} -&gt; {}&quot;,
</a><a href="#h2-5-45" id="h2-5-45" class="i">+                self.commit_index, index
</a><a href="#h2-5-46" id="h2-5-46" class="i">+            )));
</a><a href="#h2-5-47" id="h2-5-47" class="i">+        }
</a><a href="#h2-5-48" id="h2-5-48" class="i">+        let Some(entry) = self.get(index)? else {
</a><a href="#h2-5-49" id="h2-5-49" class="i">+            return Err(Error::Internal(format!(&quot;Can&#39;t commit non-existant index {}&quot;, index)));
</a><a href="#h2-5-50" id="h2-5-50" class="i">+        };
</a><a href="#h2-5-51" id="h2-5-51" class="i">+        self.engine
</a><a href="#h2-5-52" id="h2-5-52" class="i">+            .set(&amp;Key::CommitIndex.encode()?, bincode::serialize(&amp;(entry.index, entry.term))?)?;
</a><a href="#h2-5-53" id="h2-5-53" class="i">+        self.maybe_flush()?;
</a>         self.commit_index = entry.index;
         self.commit_term = entry.term;
         Ok(index)
     }
 
<a href="#h2-5-59" id="h2-5-59" class="d">-    /// Fetches an entry at an index
</a><a href="#h2-5-60" id="h2-5-60" class="d">-    pub fn get(&amp;self, index: Index) -&gt; Result&lt;Option&lt;Entry&gt;&gt; {
</a><a href="#h2-5-61" id="h2-5-61" class="d">-        self.store.get(index)?.map(|v| bincode::deserialize(&amp;v)).transpose()
</a><a href="#h2-5-62" id="h2-5-62" class="i">+    /// Fetches an entry at an index, or None if it does not exist.
</a><a href="#h2-5-63" id="h2-5-63" class="i">+    pub fn get(&amp;mut self, index: Index) -&gt; Result&lt;Option&lt;Entry&gt;&gt; {
</a><a href="#h2-5-64" id="h2-5-64" class="i">+        self.engine
</a><a href="#h2-5-65" id="h2-5-65" class="i">+            .get(&amp;Key::Entry(index).encode()?)?
</a><a href="#h2-5-66" id="h2-5-66" class="i">+            .map(|v| Self::decode_entry_value(index, &amp;v))
</a><a href="#h2-5-67" id="h2-5-67" class="i">+            .transpose()
</a>     }
 
<a href="#h2-5-70" id="h2-5-70" class="d">-    /// Checks if the log contains an entry
</a><a href="#h2-5-71" id="h2-5-71" class="d">-    pub fn has(&amp;self, index: Index, term: Term) -&gt; Result&lt;bool&gt; {
</a><a href="#h2-5-72" id="h2-5-72" class="i">+    /// Checks if the log contains an entry with the given term.
</a><a href="#h2-5-73" id="h2-5-73" class="i">+    pub fn has(&amp;mut self, index: Index, term: Term) -&gt; Result&lt;bool&gt; {
</a>         match self.get(index)? {
             Some(entry) =&gt; Ok(entry.term == term),
             None if index == 0 &amp;&amp; term == 0 =&gt; Ok(true),
<a href="#h2-6" id="h2-6" class="h">@@ -141,54 +198,69 @@ impl Log {
</a>         }
     }
 
<a href="#h2-6-3" id="h2-6-3" class="d">-    /// Iterates over log entries
</a><a href="#h2-6-4" id="h2-6-4" class="d">-    pub fn scan(&amp;self, range: impl RangeBounds&lt;Index&gt;) -&gt; Scan {
</a><a href="#h2-6-5" id="h2-6-5" class="d">-        Box::new(
</a><a href="#h2-6-6" id="h2-6-6" class="d">-            self.store.scan(Range::from(range)).map(|r| r.and_then(|v| bincode::deserialize(&amp;v))),
</a><a href="#h2-6-7" id="h2-6-7" class="d">-        )
</a><a href="#h2-6-8" id="h2-6-8" class="i">+    /// Iterates over log entries in the given index range.
</a><a href="#h2-6-9" id="h2-6-9" class="i">+    pub fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Index&gt;) -&gt; Result&lt;Scan&gt; {
</a><a href="#h2-6-10" id="h2-6-10" class="i">+        let from = match range.start_bound() {
</a><a href="#h2-6-11" id="h2-6-11" class="i">+            std::ops::Bound::Excluded(i) =&gt; std::ops::Bound::Excluded(Key::Entry(*i).encode()?),
</a><a href="#h2-6-12" id="h2-6-12" class="i">+            std::ops::Bound::Included(i) =&gt; std::ops::Bound::Included(Key::Entry(*i).encode()?),
</a><a href="#h2-6-13" id="h2-6-13" class="i">+            std::ops::Bound::Unbounded =&gt; std::ops::Bound::Included(Key::Entry(0).encode()?),
</a><a href="#h2-6-14" id="h2-6-14" class="i">+        };
</a><a href="#h2-6-15" id="h2-6-15" class="i">+        let to = match range.end_bound() {
</a><a href="#h2-6-16" id="h2-6-16" class="i">+            std::ops::Bound::Excluded(i) =&gt; std::ops::Bound::Excluded(Key::Entry(*i).encode()?),
</a><a href="#h2-6-17" id="h2-6-17" class="i">+            std::ops::Bound::Included(i) =&gt; std::ops::Bound::Included(Key::Entry(*i).encode()?),
</a><a href="#h2-6-18" id="h2-6-18" class="i">+            std::ops::Bound::Unbounded =&gt; {
</a><a href="#h2-6-19" id="h2-6-19" class="i">+                std::ops::Bound::Included(Key::Entry(Index::MAX).encode()?)
</a><a href="#h2-6-20" id="h2-6-20" class="i">+            }
</a><a href="#h2-6-21" id="h2-6-21" class="i">+        };
</a><a href="#h2-6-22" id="h2-6-22" class="i">+        Ok(Box::new(
</a><a href="#h2-6-23" id="h2-6-23" class="i">+            self.engine.scan(from, to).map(|r| r.and_then(|(k, v)| Self::decode_entry(&amp;k, &amp;v))),
</a><a href="#h2-6-24" id="h2-6-24" class="i">+        ))
</a>     }
 
<a href="#h2-6-27" id="h2-6-27" class="d">-    /// Splices a set of entries onto an offset. The entries must be contiguous, and the first entry
</a><a href="#h2-6-28" id="h2-6-28" class="d">-    /// must be at most last_index+1. If an entry does not exist, append it. If an existing entry
</a><a href="#h2-6-29" id="h2-6-29" class="d">-    /// has a term mismatch, replace it and all following entries.
</a><a href="#h2-6-30" id="h2-6-30" class="i">+    /// Splices a set of entries into the log. The entries must be contiguous,
</a><a href="#h2-6-31" id="h2-6-31" class="i">+    /// and the first entry must be at most last_index+1. If an entry does not
</a><a href="#h2-6-32" id="h2-6-32" class="i">+    /// exist, append it. If an existing entry has a term mismatch, replace it
</a><a href="#h2-6-33" id="h2-6-33" class="i">+    /// and all following entries.
</a>     pub fn splice(&amp;mut self, entries: Vec&lt;Entry&gt;) -&gt; Result&lt;u64&gt; {
<a href="#h2-6-35" id="h2-6-35" class="d">-        for i in 0..entries.len() {
</a><a href="#h2-6-36" id="h2-6-36" class="d">-            if i == 0 &amp;&amp; entries.get(i).unwrap().index &gt; self.last_index + 1 {
</a><a href="#h2-6-37" id="h2-6-37" class="d">-                return Err(Error::Internal(&quot;Spliced entries cannot begin past last index&quot;.into()));
</a><a href="#h2-6-38" id="h2-6-38" class="d">-            }
</a><a href="#h2-6-39" id="h2-6-39" class="d">-            if entries.get(i).unwrap().index != entries.get(0).unwrap().index + i as u64 {
</a><a href="#h2-6-40" id="h2-6-40" class="d">-                return Err(Error::Internal(&quot;Spliced entries must be contiguous&quot;.into()));
</a><a href="#h2-6-41" id="h2-6-41" class="d">-            }
</a><a href="#h2-6-42" id="h2-6-42" class="i">+        if entries.is_empty() {
</a><a href="#h2-6-43" id="h2-6-43" class="i">+            return Ok(self.last_index);
</a>         }
<a href="#h2-6-45" id="h2-6-45" class="d">-        for entry in entries {
</a><a href="#h2-6-46" id="h2-6-46" class="d">-            if let Some(ref current) = self.get(entry.index)? {
</a><a href="#h2-6-47" id="h2-6-47" class="d">-                if current.term == entry.term {
</a><a href="#h2-6-48" id="h2-6-48" class="d">-                    continue;
</a><a href="#h2-6-49" id="h2-6-49" class="d">-                }
</a><a href="#h2-6-50" id="h2-6-50" class="d">-                self.truncate(entry.index - 1)?;
</a><a href="#h2-6-51" id="h2-6-51" class="i">+        if entries[0].index == 0 || entries[0].index &gt; self.last_index + 1 {
</a><a href="#h2-6-52" id="h2-6-52" class="i">+            return Err(Error::Internal(&quot;Spliced entries must begin before last index&quot;.into()));
</a><a href="#h2-6-53" id="h2-6-53" class="i">+        }
</a><a href="#h2-6-54" id="h2-6-54" class="i">+        if entries[0].index &lt;= self.commit_index {
</a><a href="#h2-6-55" id="h2-6-55" class="i">+            return Err(Error::Internal(&quot;Spliced entries must begin after commit index&quot;.into()));
</a><a href="#h2-6-56" id="h2-6-56" class="i">+        }
</a><a href="#h2-6-57" id="h2-6-57" class="i">+        if !entries.windows(2).all(|w| w[0].index + 1 == w[1].index) {
</a><a href="#h2-6-58" id="h2-6-58" class="i">+            return Err(Error::Internal(&quot;Spliced entries must be contiguous&quot;.into()));
</a><a href="#h2-6-59" id="h2-6-59" class="i">+        }
</a><a href="#h2-6-60" id="h2-6-60" class="i">+        let (last_index, last_term) = entries.last().map(|e| (e.index, e.term)).unwrap();
</a><a href="#h2-6-61" id="h2-6-61" class="i">+
</a><a href="#h2-6-62" id="h2-6-62" class="i">+        // Skip entries that are already in the log (identified by index and term).
</a><a href="#h2-6-63" id="h2-6-63" class="i">+        let mut entries = entries.as_slice();
</a><a href="#h2-6-64" id="h2-6-64" class="i">+        let mut scan = self.scan(entries[0].index..=entries.last().unwrap().index)?;
</a><a href="#h2-6-65" id="h2-6-65" class="i">+        while let Some(e) = scan.next().transpose()? {
</a><a href="#h2-6-66" id="h2-6-66" class="i">+            if e.term != entries[0].term {
</a><a href="#h2-6-67" id="h2-6-67" class="i">+                break;
</a>             }
<a href="#h2-6-69" id="h2-6-69" class="d">-            self.append(entry.term, entry.command)?;
</a><a href="#h2-6-70" id="h2-6-70" class="i">+            entries = &amp;entries[1..];
</a>         }
<a href="#h2-6-72" id="h2-6-72" class="d">-        Ok(self.last_index)
</a><a href="#h2-6-73" id="h2-6-73" class="d">-    }
</a><a href="#h2-6-74" id="h2-6-74" class="i">+        drop(scan);
</a> 
<a href="#h2-6-76" id="h2-6-76" class="d">-    /// Truncates the log such that its last item is at most index.
</a><a href="#h2-6-77" id="h2-6-77" class="d">-    /// Refuses to remove entries that have been applied or committed.
</a><a href="#h2-6-78" id="h2-6-78" class="d">-    pub fn truncate(&amp;mut self, index: Index) -&gt; Result&lt;u64&gt; {
</a><a href="#h2-6-79" id="h2-6-79" class="d">-        debug!(&quot;Truncating log from entry {}&quot;, index);
</a><a href="#h2-6-80" id="h2-6-80" class="d">-        let (index, term) = match self.store.truncate(index)? {
</a><a href="#h2-6-81" id="h2-6-81" class="d">-            0 =&gt; (0, 0),
</a><a href="#h2-6-82" id="h2-6-82" class="d">-            i =&gt; self
</a><a href="#h2-6-83" id="h2-6-83" class="d">-                .store
</a><a href="#h2-6-84" id="h2-6-84" class="d">-                .get(i)?
</a><a href="#h2-6-85" id="h2-6-85" class="d">-                .map(|v| bincode::deserialize::&lt;Entry&gt;(&amp;v))
</a><a href="#h2-6-86" id="h2-6-86" class="d">-                .transpose()?
</a><a href="#h2-6-87" id="h2-6-87" class="d">-                .map(|e| (e.index, e.term))
</a><a href="#h2-6-88" id="h2-6-88" class="d">-                .ok_or_else(|| Error::Internal(format!(&quot;Entry {} not found&quot;, index)))?,
</a><a href="#h2-6-89" id="h2-6-89" class="d">-        };
</a><a href="#h2-6-90" id="h2-6-90" class="d">-        self.last_index = index;
</a><a href="#h2-6-91" id="h2-6-91" class="d">-        self.last_term = term;
</a><a href="#h2-6-92" id="h2-6-92" class="d">-        Ok(index)
</a><a href="#h2-6-93" id="h2-6-93" class="i">+        // Write any entries not already in the log.
</a><a href="#h2-6-94" id="h2-6-94" class="i">+        for e in entries {
</a><a href="#h2-6-95" id="h2-6-95" class="i">+            self.engine
</a><a href="#h2-6-96" id="h2-6-96" class="i">+                .set(&amp;Key::Entry(e.index).encode()?, bincode::serialize(&amp;(&amp;e.term, &amp;e.command))?)?;
</a><a href="#h2-6-97" id="h2-6-97" class="i">+        }
</a><a href="#h2-6-98" id="h2-6-98" class="i">+
</a><a href="#h2-6-99" id="h2-6-99" class="i">+        // Remove the remaining tail of the old log, if any, and update the index.
</a><a href="#h2-6-100" id="h2-6-100" class="i">+        for index in (last_index + 1)..=self.last_index {
</a><a href="#h2-6-101" id="h2-6-101" class="i">+            self.engine.delete(&amp;Key::Entry(index).encode()?)?;
</a><a href="#h2-6-102" id="h2-6-102" class="i">+        }
</a><a href="#h2-6-103" id="h2-6-103" class="i">+        self.maybe_flush()?;
</a><a href="#h2-6-104" id="h2-6-104" class="i">+        self.last_index = last_index;
</a><a href="#h2-6-105" id="h2-6-105" class="i">+        self.last_term = last_term;
</a><a href="#h2-6-106" id="h2-6-106" class="i">+        Ok(self.last_index)
</a>     }
 }
 
<a href="#h2-7" id="h2-7" class="h">@@ -264,117 +336,88 @@ impl&lt;E: storage::engine::Engine&gt; Engine for E {
</a> #[cfg(test)]
 mod tests {
     use super::*;
<a href="#h2-7-3" id="h2-7-3" class="i">+    use crate::storage::engine::Memory;
</a>     use pretty_assertions::assert_eq;
 
<a href="#h2-7-6" id="h2-7-6" class="d">-    fn setup() -&gt; Result&lt;(Log, Box&lt;log::Test&gt;)&gt; {
</a><a href="#h2-7-7" id="h2-7-7" class="d">-        let store = Box::new(log::Test::new());
</a><a href="#h2-7-8" id="h2-7-8" class="d">-        let log = Log::new(store.clone())?;
</a><a href="#h2-7-9" id="h2-7-9" class="d">-        Ok((log, store))
</a><a href="#h2-7-10" id="h2-7-10" class="i">+    fn setup() -&gt; Log {
</a><a href="#h2-7-11" id="h2-7-11" class="i">+        Log::new(Box::new(Memory::new()), false).expect(&quot;empty engine should never fail to open&quot;)
</a>     }
 
     #[test]
     fn new() -&gt; Result&lt;()&gt; {
<a href="#h2-7-16" id="h2-7-16" class="d">-        let (l, _) = setup()?;
</a><a href="#h2-7-17" id="h2-7-17" class="d">-        assert_eq!(0, l.last_index);
</a><a href="#h2-7-18" id="h2-7-18" class="d">-        assert_eq!(0, l.last_term);
</a><a href="#h2-7-19" id="h2-7-19" class="d">-        assert_eq!(0, l.commit_index);
</a><a href="#h2-7-20" id="h2-7-20" class="d">-        assert_eq!(0, l.commit_term);
</a><a href="#h2-7-21" id="h2-7-21" class="i">+        let mut l = setup();
</a><a href="#h2-7-22" id="h2-7-22" class="i">+        assert_eq!((0, 0), l.get_commit_index());
</a><a href="#h2-7-23" id="h2-7-23" class="i">+        assert_eq!((0, 0), l.get_last_index());
</a>         assert_eq!(None, l.get(1)?);
         Ok(())
     }
 
     #[test]
     fn append() -&gt; Result&lt;()&gt; {
<a href="#h2-7-30" id="h2-7-30" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-7-31" id="h2-7-31" class="d">-        assert_eq!(Ok(None), l.get(1));
</a><a href="#h2-7-32" id="h2-7-32" class="i">+        let mut l = setup();
</a><a href="#h2-7-33" id="h2-7-33" class="i">+        assert_eq!(l.get(1), Ok(None));
</a> 
<a href="#h2-7-35" id="h2-7-35" class="d">-        assert_eq!(1, l.append(3, Some(vec![0x01]))?);
</a><a href="#h2-7-36" id="h2-7-36" class="d">-        assert_eq!(Some(Entry { index: 1, term: 3, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h2-7-37" id="h2-7-37" class="d">-        assert_eq!(None, l.get(2)?);
</a><a href="#h2-7-38" id="h2-7-38" class="i">+        assert_eq!(l.append(3, Some(vec![0x01]))?, 1,);
</a><a href="#h2-7-39" id="h2-7-39" class="i">+        assert_eq!(l.get(1)?, Some(Entry { index: 1, term: 3, command: Some(vec![0x01]) }));
</a><a href="#h2-7-40" id="h2-7-40" class="i">+        assert_eq!(l.get(2)?, None);
</a> 
<a href="#h2-7-42" id="h2-7-42" class="d">-        assert_eq!(1, l.last_index);
</a><a href="#h2-7-43" id="h2-7-43" class="d">-        assert_eq!(3, l.last_term);
</a><a href="#h2-7-44" id="h2-7-44" class="d">-        assert_eq!(0, l.commit_index);
</a><a href="#h2-7-45" id="h2-7-45" class="d">-        assert_eq!(0, l.commit_term);
</a><a href="#h2-7-46" id="h2-7-46" class="d">-        Ok(())
</a><a href="#h2-7-47" id="h2-7-47" class="d">-    }
</a><a href="#h2-7-48" id="h2-7-48" class="i">+        assert_eq!(l.get_last_index(), (1, 3));
</a><a href="#h2-7-49" id="h2-7-49" class="i">+        assert_eq!(l.get_commit_index(), (0, 0));
</a> 
<a href="#h2-7-51" id="h2-7-51" class="d">-    #[test]
</a><a href="#h2-7-52" id="h2-7-52" class="d">-    fn append_none() -&gt; Result&lt;()&gt; {
</a><a href="#h2-7-53" id="h2-7-53" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-7-54" id="h2-7-54" class="d">-        assert_eq!(1, l.append(3, None)?);
</a><a href="#h2-7-55" id="h2-7-55" class="d">-        assert_eq!(Some(Entry { index: 1, term: 3, command: None }), l.get(1)?);
</a><a href="#h2-7-56" id="h2-7-56" class="i">+        assert_eq!(l.append(3, None)?, 2);
</a><a href="#h2-7-57" id="h2-7-57" class="i">+        assert_eq!(l.get(2)?, Some(Entry { index: 2, term: 3, command: None }));
</a><a href="#h2-7-58" id="h2-7-58" class="i">+        assert_eq!(l.get_last_index(), (2, 3));
</a><a href="#h2-7-59" id="h2-7-59" class="i">+        assert_eq!(l.get_commit_index(), (0, 0));
</a>         Ok(())
     }
 
     #[test]
<a href="#h2-7-64" id="h2-7-64" class="d">-    fn append_persistence() -&gt; Result&lt;()&gt; {
</a><a href="#h2-7-65" id="h2-7-65" class="d">-        let (mut l, store) = setup()?;
</a><a href="#h2-7-66" id="h2-7-66" class="i">+    fn commit() -&gt; Result&lt;()&gt; {
</a><a href="#h2-7-67" id="h2-7-67" class="i">+        let mut l = setup();
</a>         l.append(1, Some(vec![0x01]))?;
         l.append(2, None)?;
         l.append(2, Some(vec![0x03]))?;
 
<a href="#h2-7-72" id="h2-7-72" class="d">-        let l = Log::new(store)?;
</a><a href="#h2-7-73" id="h2-7-73" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h2-7-74" id="h2-7-74" class="d">-        assert_eq!(Some(Entry { index: 2, term: 2, command: None }), l.get(2)?);
</a><a href="#h2-7-75" id="h2-7-75" class="d">-        assert_eq!(Some(Entry { index: 3, term: 2, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h2-7-76" id="h2-7-76" class="d">-        Ok(())
</a><a href="#h2-7-77" id="h2-7-77" class="d">-    }
</a><a href="#h2-7-78" id="h2-7-78" class="i">+        // Committing a missing entry should error.
</a><a href="#h2-7-79" id="h2-7-79" class="i">+        assert_eq!(
</a><a href="#h2-7-80" id="h2-7-80" class="i">+            l.commit(0),
</a><a href="#h2-7-81" id="h2-7-81" class="i">+            Err(Error::Internal(&quot;Can&#39;t commit non-existant index 0&quot;.to_string()))
</a><a href="#h2-7-82" id="h2-7-82" class="i">+        );
</a><a href="#h2-7-83" id="h2-7-83" class="i">+        assert_eq!(
</a><a href="#h2-7-84" id="h2-7-84" class="i">+            l.commit(4),
</a><a href="#h2-7-85" id="h2-7-85" class="i">+            Err(Error::Internal(&quot;Can&#39;t commit non-existant index 4&quot;.to_string()))
</a><a href="#h2-7-86" id="h2-7-86" class="i">+        );
</a> 
<a href="#h2-7-88" id="h2-7-88" class="d">-    #[test]
</a><a href="#h2-7-89" id="h2-7-89" class="d">-    fn commit() -&gt; Result&lt;()&gt; {
</a><a href="#h2-7-90" id="h2-7-90" class="d">-        let (mut l, store) = setup()?;
</a><a href="#h2-7-91" id="h2-7-91" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-7-92" id="h2-7-92" class="d">-        l.append(2, None)?;
</a><a href="#h2-7-93" id="h2-7-93" class="d">-        l.append(2, Some(vec![0x03]))?;
</a><a href="#h2-7-94" id="h2-7-94" class="d">-        assert_eq!(3, l.commit(3)?);
</a><a href="#h2-7-95" id="h2-7-95" class="d">-        assert_eq!(3, l.commit_index);
</a><a href="#h2-7-96" id="h2-7-96" class="d">-        assert_eq!(2, l.commit_term);
</a><a href="#h2-7-97" id="h2-7-97" class="d">-
</a><a href="#h2-7-98" id="h2-7-98" class="d">-        // The last committed entry must be persisted, to sync with state machine
</a><a href="#h2-7-99" id="h2-7-99" class="d">-        let l = Log::new(store)?;
</a><a href="#h2-7-100" id="h2-7-100" class="d">-        assert_eq!(3, l.commit_index);
</a><a href="#h2-7-101" id="h2-7-101" class="d">-        assert_eq!(2, l.commit_term);
</a><a href="#h2-7-102" id="h2-7-102" class="d">-        Ok(())
</a><a href="#h2-7-103" id="h2-7-103" class="d">-    }
</a><a href="#h2-7-104" id="h2-7-104" class="i">+        // Committing an existing index works, and is idempotent.
</a><a href="#h2-7-105" id="h2-7-105" class="i">+        l.commit(2)?;
</a><a href="#h2-7-106" id="h2-7-106" class="i">+        assert_eq!(l.get_commit_index(), (2, 2));
</a><a href="#h2-7-107" id="h2-7-107" class="i">+        l.commit(2)?;
</a><a href="#h2-7-108" id="h2-7-108" class="i">+        assert_eq!(l.get_commit_index(), (2, 2));
</a> 
<a href="#h2-7-110" id="h2-7-110" class="d">-    #[test]
</a><a href="#h2-7-111" id="h2-7-111" class="d">-    fn commit_beyond() -&gt; Result&lt;()&gt; {
</a><a href="#h2-7-112" id="h2-7-112" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-7-113" id="h2-7-113" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-7-114" id="h2-7-114" class="d">-        l.append(2, None)?;
</a><a href="#h2-7-115" id="h2-7-115" class="d">-        l.append(2, Some(vec![0x03]))?;
</a><a href="#h2-7-116" id="h2-7-116" class="d">-        assert_eq!(Err(Error::Internal(&quot;Entry 4 not found&quot;.into())), l.commit(4));
</a><a href="#h2-7-117" id="h2-7-117" class="i">+        // Regressing the commit index should error.
</a><a href="#h2-7-118" id="h2-7-118" class="i">+        assert_eq!(l.commit(1), Err(Error::Internal(&quot;Commit index regression 2 -&gt; 1&quot;.to_string())));
</a> 
<a href="#h2-7-120" id="h2-7-120" class="d">-        Ok(())
</a><a href="#h2-7-121" id="h2-7-121" class="d">-    }
</a><a href="#h2-7-122" id="h2-7-122" class="i">+        // Committing a later index works.
</a><a href="#h2-7-123" id="h2-7-123" class="i">+        l.commit(3)?;
</a><a href="#h2-7-124" id="h2-7-124" class="i">+        assert_eq!(l.get_commit_index(), (3, 2));
</a> 
<a href="#h2-7-126" id="h2-7-126" class="d">-    #[test]
</a><a href="#h2-7-127" id="h2-7-127" class="d">-    fn commit_partial() -&gt; Result&lt;()&gt; {
</a><a href="#h2-7-128" id="h2-7-128" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-7-129" id="h2-7-129" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-7-130" id="h2-7-130" class="d">-        l.append(2, None)?;
</a><a href="#h2-7-131" id="h2-7-131" class="d">-        l.append(2, Some(vec![0x03]))?;
</a><a href="#h2-7-132" id="h2-7-132" class="d">-        assert_eq!(2, l.commit(2)?);
</a><a href="#h2-7-133" id="h2-7-133" class="d">-        assert_eq!(2, l.commit_index);
</a><a href="#h2-7-134" id="h2-7-134" class="d">-        assert_eq!(2, l.commit_term);
</a>         Ok(())
     }
 
     #[test]
     fn get() -&gt; Result&lt;()&gt; {
<a href="#h2-7-140" id="h2-7-140" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-7-141" id="h2-7-141" class="d">-        assert_eq!(None, l.get(1)?);
</a><a href="#h2-7-142" id="h2-7-142" class="i">+        let mut l = setup();
</a><a href="#h2-7-143" id="h2-7-143" class="i">+        assert_eq!(l.get(1)?, None);
</a> 
         l.append(3, Some(vec![0x01]))?;
<a href="#h2-7-146" id="h2-7-146" class="d">-        assert_eq!(Some(Entry { index: 1, term: 3, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h2-7-147" id="h2-7-147" class="d">-        assert_eq!(None, l.get(2)?);
</a><a href="#h2-7-148" id="h2-7-148" class="i">+        assert_eq!(l.get(1)?, Some(Entry { index: 1, term: 3, command: Some(vec![0x01]) }));
</a><a href="#h2-7-149" id="h2-7-149" class="i">+        assert_eq!(l.get(2)?, None);
</a>         Ok(())
     }
 
     #[test]
     fn has() -&gt; Result&lt;()&gt; {
<a href="#h2-7-155" id="h2-7-155" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-7-156" id="h2-7-156" class="i">+        let mut l = setup();
</a>         l.append(2, Some(vec![0x01]))?;
 
         assert!(l.has(1, 2)?);
<a href="#h2-8" id="h2-8" class="h">@@ -389,291 +432,231 @@ mod tests {
</a> 
     #[test]
     fn scan() -&gt; Result&lt;()&gt; {
<a href="#h2-8-3" id="h2-8-3" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-4" id="h2-8-4" class="i">+        let mut l = setup();
</a>         l.append(1, Some(vec![0x01]))?;
         l.append(1, Some(vec![0x02]))?;
         l.append(1, Some(vec![0x03]))?;
 
         assert_eq!(
<a href="#h2-8-10" id="h2-8-10" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
                 Entry { index: 2, term: 1, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 1, command: Some(vec![0x03]) },
             ],
<a href="#h2-8-16" id="h2-8-16" class="d">-            l.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(
<a href="#h2-8-19" id="h2-8-19" class="d">-            vec![
</a><a href="#h2-8-20" id="h2-8-20" class="d">-                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-21" id="h2-8-21" class="d">-                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-22" id="h2-8-22" class="d">-            ],
</a><a href="#h2-8-23" id="h2-8-23" class="d">-            l.scan(2..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-24" id="h2-8-24" class="i">+            l.scan(2..=2)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h2-8-25" id="h2-8-25" class="i">+            vec![Entry { index: 2, term: 1, command: Some(vec![0x02]) },],
</a>         );
<a href="#h2-8-27" id="h2-8-27" class="d">-        assert!(l.scan(4..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h2-8-28" id="h2-8-28" class="i">+        assert!(l.scan(4..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a>         Ok(())
     }
 
     #[test]
<a href="#h2-8-33" id="h2-8-33" class="d">-    fn load_save_term() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-34" id="h2-8-34" class="d">-        // Test loading empty term
</a><a href="#h2-8-35" id="h2-8-35" class="d">-        let (l, _) = setup()?;
</a><a href="#h2-8-36" id="h2-8-36" class="d">-        assert_eq!((0, None), l.get_term()?);
</a><a href="#h2-8-37" id="h2-8-37" class="i">+    fn set_get_term() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-38" id="h2-8-38" class="i">+        let mut l = setup();
</a><a href="#h2-8-39" id="h2-8-39" class="i">+        assert_eq!(l.get_term()?, (0, None));
</a> 
<a href="#h2-8-41" id="h2-8-41" class="d">-        // Test loading saved term
</a><a href="#h2-8-42" id="h2-8-42" class="d">-        let (mut l, store) = setup()?;
</a>         l.set_term(1, Some(&quot;a&quot;))?;
<a href="#h2-8-44" id="h2-8-44" class="d">-        let l = Log::new(store)?;
</a><a href="#h2-8-45" id="h2-8-45" class="d">-        assert_eq!((1, Some(&quot;a&quot;.into())), l.get_term()?);
</a><a href="#h2-8-46" id="h2-8-46" class="i">+        assert_eq!(l.get_term()?, (1, Some(&quot;a&quot;.into())));
</a> 
<a href="#h2-8-48" id="h2-8-48" class="d">-        // Test replacing saved term with none
</a><a href="#h2-8-49" id="h2-8-49" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-50" id="h2-8-50" class="d">-        l.set_term(1, Some(&quot;a&quot;))?;
</a><a href="#h2-8-51" id="h2-8-51" class="d">-        assert_eq!((1, Some(&quot;a&quot;.into())), l.get_term()?);
</a>         l.set_term(0, None)?;
<a href="#h2-8-53" id="h2-8-53" class="d">-        assert_eq!((0, None), l.get_term()?);
</a><a href="#h2-8-54" id="h2-8-54" class="i">+        assert_eq!(l.get_term()?, (0, None));
</a>         Ok(())
     }
 
     #[test]
     fn splice() -&gt; Result&lt;()&gt; {
<a href="#h2-8-60" id="h2-8-60" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-61" id="h2-8-61" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-62" id="h2-8-62" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-63" id="h2-8-63" class="d">-        l.append(3, Some(vec![0x03]))?;
</a><a href="#h2-8-64" id="h2-8-64" class="i">+        let mut l = setup();
</a> 
<a href="#h2-8-66" id="h2-8-66" class="i">+        // Splicing an empty vec should return the current last_index.
</a><a href="#h2-8-67" id="h2-8-67" class="i">+        assert_eq!(l.splice(vec![])?, 0);
</a><a href="#h2-8-68" id="h2-8-68" class="i">+
</a><a href="#h2-8-69" id="h2-8-69" class="i">+        // It should error if the first index is not 1.
</a><a href="#h2-8-70" id="h2-8-70" class="i">+        assert!(l.splice(vec![Entry { index: 0, term: 1, command: None }]).is_err());
</a><a href="#h2-8-71" id="h2-8-71" class="i">+        assert!(l.splice(vec![Entry { index: 2, term: 1, command: None }]).is_err());
</a><a href="#h2-8-72" id="h2-8-72" class="i">+
</a><a href="#h2-8-73" id="h2-8-73" class="i">+        // ...or the entries are not contiguous.
</a><a href="#h2-8-74" id="h2-8-74" class="i">+        assert!(l
</a><a href="#h2-8-75" id="h2-8-75" class="i">+            .splice(vec![
</a><a href="#h2-8-76" id="h2-8-76" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h2-8-77" id="h2-8-77" class="i">+                Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h2-8-78" id="h2-8-78" class="i">+            ])
</a><a href="#h2-8-79" id="h2-8-79" class="i">+            .is_err());
</a><a href="#h2-8-80" id="h2-8-80" class="i">+
</a><a href="#h2-8-81" id="h2-8-81" class="i">+        // Splicing into an empty log should be fine.
</a>         assert_eq!(
<a href="#h2-8-83" id="h2-8-83" class="d">-            4,
</a>             l.splice(vec![
<a href="#h2-8-85" id="h2-8-85" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-86" id="h2-8-86" class="d">-                Entry { index: 4, term: 4, command: Some(vec![0x04]) },
</a><a href="#h2-8-87" id="h2-8-87" class="d">-            ])?
</a><a href="#h2-8-88" id="h2-8-88" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h2-8-89" id="h2-8-89" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-90" id="h2-8-90" class="i">+            ])?,
</a><a href="#h2-8-91" id="h2-8-91" class="i">+            2
</a>         );
         assert_eq!(
<a href="#h2-8-94" id="h2-8-94" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-97" id="h2-8-97" class="d">-                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h2-8-98" id="h2-8-98" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-99" id="h2-8-99" class="d">-                Entry { index: 4, term: 4, command: Some(vec![0x04]) },
</a><a href="#h2-8-100" id="h2-8-100" class="d">-            ],
</a><a href="#h2-8-101" id="h2-8-101" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-102" id="h2-8-102" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-103" id="h2-8-103" class="i">+            ]
</a>         );
<a href="#h2-8-105" id="h2-8-105" class="d">-        assert_eq!(4, l.last_index);
</a><a href="#h2-8-106" id="h2-8-106" class="d">-        assert_eq!(4, l.last_term);
</a><a href="#h2-8-107" id="h2-8-107" class="d">-        Ok(())
</a><a href="#h2-8-108" id="h2-8-108" class="d">-    }
</a><a href="#h2-8-109" id="h2-8-109" class="d">-
</a><a href="#h2-8-110" id="h2-8-110" class="d">-    #[test]
</a><a href="#h2-8-111" id="h2-8-111" class="d">-    fn splice_all() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-112" id="h2-8-112" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-113" id="h2-8-113" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-114" id="h2-8-114" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-115" id="h2-8-115" class="d">-        l.append(3, Some(vec![0x03]))?;
</a> 
<a href="#h2-8-117" id="h2-8-117" class="i">+        // Splicing an empty vec should be fine, and return the last index
</a><a href="#h2-8-118" id="h2-8-118" class="i">+        // without affecting data.
</a><a href="#h2-8-119" id="h2-8-119" class="i">+        assert_eq!(l.splice(vec![])?, 2);
</a>         assert_eq!(
<a href="#h2-8-121" id="h2-8-121" class="d">-            2,
</a><a href="#h2-8-122" id="h2-8-122" class="d">-            l.splice(vec![
</a><a href="#h2-8-123" id="h2-8-123" class="d">-                Entry { index: 1, term: 4, command: Some(vec![0x0a]) },
</a><a href="#h2-8-124" id="h2-8-124" class="d">-                Entry { index: 2, term: 4, command: Some(vec![0x0b]) },
</a><a href="#h2-8-125" id="h2-8-125" class="d">-            ])?
</a><a href="#h2-8-126" id="h2-8-126" class="d">-        );
</a><a href="#h2-8-127" id="h2-8-127" class="d">-        assert_eq!(
</a><a href="#h2-8-128" id="h2-8-128" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
<a href="#h2-8-130" id="h2-8-130" class="d">-                Entry { index: 1, term: 4, command: Some(vec![0x0a]) },
</a><a href="#h2-8-131" id="h2-8-131" class="d">-                Entry { index: 2, term: 4, command: Some(vec![0x0b]) },
</a><a href="#h2-8-132" id="h2-8-132" class="d">-            ],
</a><a href="#h2-8-133" id="h2-8-133" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-134" id="h2-8-134" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h2-8-135" id="h2-8-135" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-136" id="h2-8-136" class="i">+            ]
</a>         );
<a href="#h2-8-138" id="h2-8-138" class="d">-        assert_eq!(2, l.last_index);
</a><a href="#h2-8-139" id="h2-8-139" class="d">-        assert_eq!(4, l.last_term);
</a><a href="#h2-8-140" id="h2-8-140" class="d">-        Ok(())
</a><a href="#h2-8-141" id="h2-8-141" class="d">-    }
</a> 
<a href="#h2-8-143" id="h2-8-143" class="d">-    #[test]
</a><a href="#h2-8-144" id="h2-8-144" class="d">-    fn splice_append() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-145" id="h2-8-145" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-146" id="h2-8-146" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-147" id="h2-8-147" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-148" id="h2-8-148" class="i">+        // Splicing with a gap after the last_index should error.
</a><a href="#h2-8-149" id="h2-8-149" class="i">+        assert!(l
</a><a href="#h2-8-150" id="h2-8-150" class="i">+            .splice(vec![
</a><a href="#h2-8-151" id="h2-8-151" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-152" id="h2-8-152" class="i">+                Entry { index: 5, term: 1, command: Some(vec![0x05]) },
</a><a href="#h2-8-153" id="h2-8-153" class="i">+            ])
</a><a href="#h2-8-154" id="h2-8-154" class="i">+            .is_err());
</a> 
<a href="#h2-8-156" id="h2-8-156" class="i">+        // Splicing after the last index should be fine.
</a>         assert_eq!(
<a href="#h2-8-158" id="h2-8-158" class="d">-            4,
</a>             l.splice(vec![
<a href="#h2-8-160" id="h2-8-160" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-161" id="h2-8-161" class="d">-                Entry { index: 4, term: 4, command: Some(vec![0x04]) },
</a><a href="#h2-8-162" id="h2-8-162" class="d">-            ])?
</a><a href="#h2-8-163" id="h2-8-163" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-164" id="h2-8-164" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-165" id="h2-8-165" class="i">+            ])?,
</a><a href="#h2-8-166" id="h2-8-166" class="i">+            4
</a>         );
         assert_eq!(
<a href="#h2-8-169" id="h2-8-169" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-172" id="h2-8-172" class="d">-                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h2-8-173" id="h2-8-173" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-174" id="h2-8-174" class="d">-                Entry { index: 4, term: 4, command: Some(vec![0x04]) },
</a><a href="#h2-8-175" id="h2-8-175" class="d">-            ],
</a><a href="#h2-8-176" id="h2-8-176" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-177" id="h2-8-177" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-178" id="h2-8-178" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-179" id="h2-8-179" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-180" id="h2-8-180" class="i">+            ]
</a>         );
<a href="#h2-8-182" id="h2-8-182" class="d">-        assert_eq!(4, l.last_index);
</a><a href="#h2-8-183" id="h2-8-183" class="d">-        assert_eq!(4, l.last_term);
</a><a href="#h2-8-184" id="h2-8-184" class="d">-        Ok(())
</a><a href="#h2-8-185" id="h2-8-185" class="d">-    }
</a><a href="#h2-8-186" id="h2-8-186" class="d">-
</a><a href="#h2-8-187" id="h2-8-187" class="d">-    #[test]
</a><a href="#h2-8-188" id="h2-8-188" class="d">-    fn splice_conflict_term() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-189" id="h2-8-189" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-190" id="h2-8-190" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-191" id="h2-8-191" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-192" id="h2-8-192" class="d">-        l.append(3, Some(vec![0x03]))?;
</a><a href="#h2-8-193" id="h2-8-193" class="d">-        l.append(4, Some(vec![0x04]))?;
</a> 
<a href="#h2-8-195" id="h2-8-195" class="i">+        // Splicing with overlap should be a noop.
</a>         assert_eq!(
<a href="#h2-8-197" id="h2-8-197" class="d">-            3,
</a>             l.splice(vec![
<a href="#h2-8-199" id="h2-8-199" class="d">-                Entry { index: 2, term: 3, command: Some(vec![0x0b]) },
</a><a href="#h2-8-200" id="h2-8-200" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x0c]) }
</a><a href="#h2-8-201" id="h2-8-201" class="d">-            ])?
</a><a href="#h2-8-202" id="h2-8-202" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-203" id="h2-8-203" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-204" id="h2-8-204" class="i">+            ])?,
</a><a href="#h2-8-205" id="h2-8-205" class="i">+            4
</a>         );
         assert_eq!(
<a href="#h2-8-208" id="h2-8-208" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-211" id="h2-8-211" class="d">-                Entry { index: 2, term: 3, command: Some(vec![0x0b]) },
</a><a href="#h2-8-212" id="h2-8-212" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x0c]) },
</a><a href="#h2-8-213" id="h2-8-213" class="d">-            ],
</a><a href="#h2-8-214" id="h2-8-214" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-215" id="h2-8-215" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-216" id="h2-8-216" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-217" id="h2-8-217" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-218" id="h2-8-218" class="i">+            ]
</a>         );
<a href="#h2-8-220" id="h2-8-220" class="d">-        assert_eq!(3, l.last_index);
</a><a href="#h2-8-221" id="h2-8-221" class="d">-        assert_eq!(3, l.last_term);
</a><a href="#h2-8-222" id="h2-8-222" class="d">-        Ok(())
</a><a href="#h2-8-223" id="h2-8-223" class="d">-    }
</a><a href="#h2-8-224" id="h2-8-224" class="d">-
</a><a href="#h2-8-225" id="h2-8-225" class="d">-    #[test]
</a><a href="#h2-8-226" id="h2-8-226" class="d">-    fn splice_error_noncontiguous() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-227" id="h2-8-227" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-228" id="h2-8-228" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-229" id="h2-8-229" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-230" id="h2-8-230" class="d">-        l.append(3, Some(vec![0x03]))?;
</a> 
         assert_eq!(
<a href="#h2-8-233" id="h2-8-233" class="d">-            Err(Error::Internal(&quot;Spliced entries must be contiguous&quot;.into())),
</a>             l.splice(vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-236" id="h2-8-236" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-237" id="h2-8-237" class="d">-            ])
</a><a href="#h2-8-238" id="h2-8-238" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-239" id="h2-8-239" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-240" id="h2-8-240" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-241" id="h2-8-241" class="i">+            ])?,
</a><a href="#h2-8-242" id="h2-8-242" class="i">+            4
</a>         );
         assert_eq!(
<a href="#h2-8-245" id="h2-8-245" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-248" id="h2-8-248" class="d">-                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h2-8-249" id="h2-8-249" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-250" id="h2-8-250" class="d">-            ],
</a><a href="#h2-8-251" id="h2-8-251" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-252" id="h2-8-252" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-253" id="h2-8-253" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-254" id="h2-8-254" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-255" id="h2-8-255" class="i">+            ]
</a>         );
<a href="#h2-8-257" id="h2-8-257" class="d">-        Ok(())
</a><a href="#h2-8-258" id="h2-8-258" class="d">-    }
</a><a href="#h2-8-259" id="h2-8-259" class="d">-
</a><a href="#h2-8-260" id="h2-8-260" class="d">-    #[test]
</a><a href="#h2-8-261" id="h2-8-261" class="d">-    fn splice_error_beyond_last() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-262" id="h2-8-262" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-263" id="h2-8-263" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-264" id="h2-8-264" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-265" id="h2-8-265" class="d">-        l.append(3, Some(vec![0x03]))?;
</a> 
<a href="#h2-8-267" id="h2-8-267" class="i">+        // Splicing in the middle should truncate the rest, even if the
</a><a href="#h2-8-268" id="h2-8-268" class="i">+        // entries match.
</a>         assert_eq!(
<a href="#h2-8-270" id="h2-8-270" class="d">-            Err(Error::Internal(&quot;Spliced entries cannot begin past last index&quot;.into())),
</a>             l.splice(vec![
<a href="#h2-8-272" id="h2-8-272" class="d">-                Entry { index: 5, term: 3, command: Some(vec![0x05]) },
</a><a href="#h2-8-273" id="h2-8-273" class="d">-                Entry { index: 6, term: 3, command: Some(vec![0x06]) },
</a><a href="#h2-8-274" id="h2-8-274" class="d">-            ])
</a><a href="#h2-8-275" id="h2-8-275" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-276" id="h2-8-276" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-277" id="h2-8-277" class="i">+            ])?,
</a><a href="#h2-8-278" id="h2-8-278" class="i">+            3
</a>         );
         assert_eq!(
<a href="#h2-8-281" id="h2-8-281" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-284" id="h2-8-284" class="d">-                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h2-8-285" id="h2-8-285" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-286" id="h2-8-286" class="d">-            ],
</a><a href="#h2-8-287" id="h2-8-287" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-288" id="h2-8-288" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-289" id="h2-8-289" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-290" id="h2-8-290" class="i">+            ]
</a>         );
<a href="#h2-8-292" id="h2-8-292" class="d">-        Ok(())
</a><a href="#h2-8-293" id="h2-8-293" class="d">-    }
</a><a href="#h2-8-294" id="h2-8-294" class="d">-
</a><a href="#h2-8-295" id="h2-8-295" class="d">-    #[test]
</a><a href="#h2-8-296" id="h2-8-296" class="d">-    fn splice_overlap_inside() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-297" id="h2-8-297" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-298" id="h2-8-298" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-299" id="h2-8-299" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-300" id="h2-8-300" class="d">-        l.append(3, Some(vec![0x03]))?;
</a> 
<a href="#h2-8-302" id="h2-8-302" class="d">-        assert_eq!(3, l.splice(vec![Entry { index: 2, term: 2, command: Some(vec![0x02]) },])?);
</a><a href="#h2-8-303" id="h2-8-303" class="i">+        // Splicing at the start should truncate the rest, even if the
</a><a href="#h2-8-304" id="h2-8-304" class="i">+        // entries match.
</a><a href="#h2-8-305" id="h2-8-305" class="i">+        assert_eq!(
</a><a href="#h2-8-306" id="h2-8-306" class="i">+            l.splice(vec![
</a><a href="#h2-8-307" id="h2-8-307" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h2-8-308" id="h2-8-308" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-309" id="h2-8-309" class="i">+            ])?,
</a><a href="#h2-8-310" id="h2-8-310" class="i">+            2
</a><a href="#h2-8-311" id="h2-8-311" class="i">+        );
</a>         assert_eq!(
<a href="#h2-8-313" id="h2-8-313" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-316" id="h2-8-316" class="d">-                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h2-8-317" id="h2-8-317" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-318" id="h2-8-318" class="d">-            ],
</a><a href="#h2-8-319" id="h2-8-319" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-320" id="h2-8-320" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-321" id="h2-8-321" class="i">+            ]
</a>         );
<a href="#h2-8-323" id="h2-8-323" class="d">-        Ok(())
</a><a href="#h2-8-324" id="h2-8-324" class="d">-    }
</a><a href="#h2-8-325" id="h2-8-325" class="d">-
</a><a href="#h2-8-326" id="h2-8-326" class="d">-    #[test]
</a><a href="#h2-8-327" id="h2-8-327" class="d">-    fn truncate() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-328" id="h2-8-328" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-329" id="h2-8-329" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-330" id="h2-8-330" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-331" id="h2-8-331" class="d">-        l.append(3, Some(vec![0x03]))?;
</a> 
<a href="#h2-8-333" id="h2-8-333" class="d">-        assert_eq!(2, l.truncate(2)?);
</a><a href="#h2-8-334" id="h2-8-334" class="i">+        // Splicing a different command does nothing.
</a><a href="#h2-8-335" id="h2-8-335" class="i">+        assert_eq!(l.splice(vec![Entry { index: 2, term: 1, command: Some(vec![0x00]) },])?, 2);
</a>         assert_eq!(
<a href="#h2-8-337" id="h2-8-337" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-340" id="h2-8-340" class="d">-                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h2-8-341" id="h2-8-341" class="d">-            ],
</a><a href="#h2-8-342" id="h2-8-342" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-343" id="h2-8-343" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-344" id="h2-8-344" class="i">+            ]
</a>         );
<a href="#h2-8-346" id="h2-8-346" class="d">-        Ok(())
</a><a href="#h2-8-347" id="h2-8-347" class="d">-    }
</a><a href="#h2-8-348" id="h2-8-348" class="d">-
</a><a href="#h2-8-349" id="h2-8-349" class="d">-    #[test]
</a><a href="#h2-8-350" id="h2-8-350" class="d">-    fn truncate_beyond() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-351" id="h2-8-351" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-352" id="h2-8-352" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-353" id="h2-8-353" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-354" id="h2-8-354" class="d">-        l.append(3, Some(vec![0x03]))?;
</a> 
<a href="#h2-8-356" id="h2-8-356" class="d">-        assert_eq!(3, l.truncate(4)?);
</a><a href="#h2-8-357" id="h2-8-357" class="i">+        // Splicing with overlap beyond the end works.
</a><a href="#h2-8-358" id="h2-8-358" class="i">+        assert_eq!(
</a><a href="#h2-8-359" id="h2-8-359" class="i">+            l.splice(vec![
</a><a href="#h2-8-360" id="h2-8-360" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-361" id="h2-8-361" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-362" id="h2-8-362" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-363" id="h2-8-363" class="i">+            ])?,
</a><a href="#h2-8-364" id="h2-8-364" class="i">+            4
</a><a href="#h2-8-365" id="h2-8-365" class="i">+        );
</a>         assert_eq!(
<a href="#h2-8-367" id="h2-8-367" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             vec![
                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
<a href="#h2-8-370" id="h2-8-370" class="d">-                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h2-8-371" id="h2-8-371" class="d">-                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h2-8-372" id="h2-8-372" class="d">-            ],
</a><a href="#h2-8-373" id="h2-8-373" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-8-374" id="h2-8-374" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-375" id="h2-8-375" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a><a href="#h2-8-376" id="h2-8-376" class="i">+                Entry { index: 4, term: 1, command: Some(vec![0x04]) },
</a><a href="#h2-8-377" id="h2-8-377" class="i">+            ]
</a>         );
<a href="#h2-8-379" id="h2-8-379" class="d">-        Ok(())
</a><a href="#h2-8-380" id="h2-8-380" class="d">-    }
</a><a href="#h2-8-381" id="h2-8-381" class="d">-
</a><a href="#h2-8-382" id="h2-8-382" class="d">-    #[test]
</a><a href="#h2-8-383" id="h2-8-383" class="d">-    fn truncate_committed() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-384" id="h2-8-384" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-385" id="h2-8-385" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-386" id="h2-8-386" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-387" id="h2-8-387" class="d">-        l.append(3, Some(vec![0x03]))?;
</a><a href="#h2-8-388" id="h2-8-388" class="d">-        l.commit(2)?;
</a> 
<a href="#h2-8-390" id="h2-8-390" class="i">+        // Splicing with a different term replaces.
</a>         assert_eq!(
<a href="#h2-8-392" id="h2-8-392" class="d">-            l.truncate(1),
</a><a href="#h2-8-393" id="h2-8-393" class="d">-            Err(Error::Internal(&quot;Cannot truncate below committed index 2&quot;.into()))
</a><a href="#h2-8-394" id="h2-8-394" class="i">+            l.splice(vec![
</a><a href="#h2-8-395" id="h2-8-395" class="i">+                Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h2-8-396" id="h2-8-396" class="i">+                Entry { index: 4, term: 2, command: Some(vec![0x04]) },
</a><a href="#h2-8-397" id="h2-8-397" class="i">+            ])?,
</a><a href="#h2-8-398" id="h2-8-398" class="i">+            4
</a><a href="#h2-8-399" id="h2-8-399" class="i">+        );
</a><a href="#h2-8-400" id="h2-8-400" class="i">+        assert_eq!(
</a><a href="#h2-8-401" id="h2-8-401" class="i">+            l.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h2-8-402" id="h2-8-402" class="i">+            vec![
</a><a href="#h2-8-403" id="h2-8-403" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h2-8-404" id="h2-8-404" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h2-8-405" id="h2-8-405" class="i">+                Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h2-8-406" id="h2-8-406" class="i">+                Entry { index: 4, term: 2, command: Some(vec![0x04]) },
</a><a href="#h2-8-407" id="h2-8-407" class="i">+            ]
</a>         );
<a href="#h2-8-409" id="h2-8-409" class="d">-        assert_eq!(l.truncate(2)?, 2);
</a><a href="#h2-8-410" id="h2-8-410" class="d">-        Ok(())
</a><a href="#h2-8-411" id="h2-8-411" class="d">-    }
</a><a href="#h2-8-412" id="h2-8-412" class="d">-
</a><a href="#h2-8-413" id="h2-8-413" class="d">-    #[test]
</a><a href="#h2-8-414" id="h2-8-414" class="d">-    fn truncate_zero() -&gt; Result&lt;()&gt; {
</a><a href="#h2-8-415" id="h2-8-415" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h2-8-416" id="h2-8-416" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h2-8-417" id="h2-8-417" class="d">-        l.append(2, Some(vec![0x02]))?;
</a><a href="#h2-8-418" id="h2-8-418" class="d">-        l.append(3, Some(vec![0x03]))?;
</a> 
<a href="#h2-8-420" id="h2-8-420" class="d">-        assert_eq!(0, l.truncate(0)?);
</a><a href="#h2-8-421" id="h2-8-421" class="d">-        assert!(l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a>         Ok(())
     }
 }
<b>diff --git a/<a id="h3" href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a> b/<a href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -5,7 +5,7 @@ mod node;
</a> mod server;
 mod state;
 
<a href="#h3-0-3" id="h3-0-3" class="d">-pub use self::log::{Entry, Log, Scan};
</a><a href="#h3-0-4" id="h3-0-4" class="i">+pub use self::log::{Engine, Entry, Log, Scan};
</a> pub use client::Client;
 pub use message::{Address, Event, Message, Request, Response};
 pub use node::{Node, Status};
<b>diff --git a/<a id="h4" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -127,7 +127,7 @@ mod tests {
</a>     use super::super::super::{Entry, Instruction, Log, Request};
     use super::super::tests::{assert_messages, assert_node};
     use super::*;
<a href="#h4-0-3" id="h4-0-3" class="d">-    use crate::storage::log;
</a><a href="#h4-0-4" id="h4-0-4" class="i">+    use crate::storage;
</a>     use std::collections::HashMap;
     use tokio::sync::mpsc;
 
<a href="#h4-1" id="h4-1" class="h">@@ -139,7 +139,7 @@ mod tests {
</a>     )&gt; {
         let (node_tx, mut node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
<a href="#h4-1-3" id="h4-1-3" class="d">-        let mut log = Log::new(Box::new(log::Test::new()))?;
</a><a href="#h4-1-4" id="h4-1-4" class="i">+        let mut log = Log::new(Box::new(storage::engine::Memory::new()), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<a href="#h4-2" id="h4-2" class="h">@@ -175,13 +175,13 @@ mod tests {
</a>     // and emits ConfirmLeader.
     fn step_heartbeat_current_term() -&gt; Result&lt;()&gt; {
         let (candidate, mut node_rx, mut state_rx) = setup()?;
<a href="#h4-2-3" id="h4-2-3" class="d">-        let node = candidate.step(Message {
</a><a href="#h4-2-4" id="h4-2-4" class="i">+        let mut node = candidate.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
         })?;
<a href="#h4-2-10" id="h4-2-10" class="d">-        assert_node(&amp;node).is_follower().term(3);
</a><a href="#h4-2-11" id="h4-2-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![
<a href="#h4-3" id="h4-3" class="h">@@ -211,13 +211,13 @@ mod tests {
</a>     // ConfirmLeader event
     fn step_heartbeat_future_term() -&gt; Result&lt;()&gt; {
         let (candidate, mut node_rx, mut state_rx) = setup()?;
<a href="#h4-3-3" id="h4-3-3" class="d">-        let node = candidate.step(Message {
</a><a href="#h4-3-4" id="h4-3-4" class="i">+        let mut node = candidate.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 4,
             event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
         })?;
<a href="#h4-3-10" id="h4-3-10" class="d">-        assert_node(&amp;node).is_follower().term(4);
</a><a href="#h4-3-11" id="h4-3-11" class="i">+        assert_node(&amp;mut node).is_follower().term(4);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![
<a href="#h4-4" id="h4-4" class="h">@@ -246,13 +246,13 @@ mod tests {
</a>     // Heartbeat for past term is ignored
     fn step_heartbeat_past_term() -&gt; Result&lt;()&gt; {
         let (candidate, mut node_rx, mut state_rx) = setup()?;
<a href="#h4-4-3" id="h4-4-3" class="d">-        let node = candidate.step(Message {
</a><a href="#h4-4-4" id="h4-4-4" class="i">+        let mut node = candidate.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 2,
             event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
         })?;
<a href="#h4-4-10" id="h4-4-10" class="d">-        assert_node(&amp;node).is_candidate().term(3);
</a><a href="#h4-4-11" id="h4-4-11" class="i">+        assert_node(&amp;mut node).is_candidate().term(3);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h4-5" id="h4-5" class="h">@@ -271,7 +271,7 @@ mod tests {
</a>             term: 3,
             event: Event::GrantVote,
         })?;
<a href="#h4-5-3" id="h4-5-3" class="d">-        assert_node(&amp;node).is_candidate().term(3);
</a><a href="#h4-5-4" id="h4-5-4" class="i">+        assert_node(&amp;mut node).is_candidate().term(3);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
 
<a href="#h4-6" id="h4-6" class="h">@@ -282,7 +282,7 @@ mod tests {
</a>             term: 3,
             event: Event::GrantVote,
         })?;
<a href="#h4-6-3" id="h4-6-3" class="d">-        assert_node(&amp;node).is_leader().term(3);
</a><a href="#h4-6-4" id="h4-6-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3);
</a> 
         assert_eq!(
             node_rx.try_recv()?,
<a href="#h4-7" id="h4-7" class="h">@@ -345,10 +345,10 @@ mod tests {
</a> 
         assert!(timeout &gt; 0);
         for _ in 0..timeout {
<a href="#h4-7-3" id="h4-7-3" class="d">-            assert_node(&amp;node).is_candidate().term(3);
</a><a href="#h4-7-4" id="h4-7-4" class="i">+            assert_node(&amp;mut node).is_candidate().term(3);
</a>             node = node.tick()?;
         }
<a href="#h4-7-7" id="h4-7-7" class="d">-        assert_node(&amp;node).is_candidate().term(4);
</a><a href="#h4-7-8" id="h4-7-8" class="i">+        assert_node(&amp;mut node).is_candidate().term(4);
</a> 
         assert_messages(
             &amp;mut node_rx,
<b>diff --git a/<a id="h5" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -87,7 +87,7 @@ impl RoleNode&lt;Follower&gt; {
</a>                     let (old_commit_index, _) = self.log.get_commit_index();
                     if has_committed &amp;&amp; commit_index &gt; old_commit_index {
                         self.log.commit(commit_index)?;
<a href="#h5-0-3" id="h5-0-3" class="d">-                        let mut scan = self.log.scan((old_commit_index + 1)..=commit_index);
</a><a href="#h5-0-4" id="h5-0-4" class="i">+                        let mut scan = self.log.scan((old_commit_index + 1)..=commit_index)?;
</a>                         while let Some(entry) = scan.next().transpose()? {
                             self.state_tx.send(Instruction::Apply { entry })?;
                         }
<a href="#h5-1" id="h5-1" class="h">@@ -173,7 +173,7 @@ pub mod tests {
</a>     use super::super::tests::{assert_messages, assert_node};
     use super::*;
     use crate::error::Error;
<a href="#h5-1-3" id="h5-1-3" class="d">-    use crate::storage::log;
</a><a href="#h5-1-4" id="h5-1-4" class="i">+    use crate::storage;
</a>     use std::collections::HashMap;
     use tokio::sync::mpsc;
 
<a href="#h5-2" id="h5-2" class="h">@@ -193,7 +193,7 @@ pub mod tests {
</a>     )&gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
<a href="#h5-2-3" id="h5-2-3" class="d">-        let mut log = Log::new(Box::new(log::Test::new()))?;
</a><a href="#h5-2-4" id="h5-2-4" class="i">+        let mut log = Log::new(Box::new(storage::engine::Memory::new()), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<a href="#h5-3" id="h5-3" class="h">@@ -218,13 +218,13 @@ pub mod tests {
</a>     // Heartbeat from current leader should commit and apply
     fn step_heartbeat() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-3-3" id="h5-3-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-3-4" id="h5-3-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h5-3-10" id="h5-3-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(3);
</a><a href="#h5-3-11" id="h5-3-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(3);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-4" id="h5-4" class="h">@@ -247,13 +247,13 @@ pub mod tests {
</a>     // Heartbeat from current leader with conflicting commit_term
     fn step_heartbeat_conflict_commit_term() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-4-3" id="h5-4-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-4-4" id="h5-4-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::Heartbeat { commit_index: 3, commit_term: 3 },
         })?;
<a href="#h5-4-10" id="h5-4-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a><a href="#h5-4-11" id="h5-4-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-5" id="h5-5" class="h">@@ -271,13 +271,13 @@ pub mod tests {
</a>     // Heartbeat from current leader with a missing commit_index
     fn step_heartbeat_missing_commit_entry() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-5-3" id="h5-5-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-5-4" id="h5-5-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
         })?;
<a href="#h5-5-10" id="h5-5-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a><a href="#h5-5-11" id="h5-5-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-6" id="h5-6" class="h">@@ -295,13 +295,13 @@ pub mod tests {
</a>     // Heartbeat from fake leader
     fn step_heartbeat_fake_leader() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-6-3" id="h5-6-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-6-4" id="h5-6-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;c&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
         })?;
<a href="#h5-6-10" id="h5-6-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a><a href="#h5-6-11" id="h5-6-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h5-7" id="h5-7" class="h">@@ -312,13 +312,13 @@ pub mod tests {
</a>     fn step_heartbeat_no_leader() -&gt; Result&lt;()&gt; {
         let (mut follower, mut node_rx, mut state_rx) = setup()?;
         follower.role = Follower::new(None, None);
<a href="#h5-7-3" id="h5-7-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-7-4" id="h5-7-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;c&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h5-7-10" id="h5-7-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;c&quot;)).voted_for(None).committed(3);
</a><a href="#h5-7-11" id="h5-7-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;c&quot;)).voted_for(None).committed(3);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-8" id="h5-8" class="h">@@ -341,13 +341,13 @@ pub mod tests {
</a>     // Heartbeat from current leader with old commit_index
     fn step_heartbeat_old_commit_index() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-8-3" id="h5-8-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-8-4" id="h5-8-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
         })?;
<a href="#h5-8-10" id="h5-8-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a><a href="#h5-8-11" id="h5-8-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-9" id="h5-9" class="h">@@ -365,13 +365,13 @@ pub mod tests {
</a>     // Heartbeat for future term with other leader changes leader
     fn step_heartbeat_future_term() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-9-3" id="h5-9-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-9-4" id="h5-9-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;c&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 4,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h5-9-10" id="h5-9-10" class="d">-        assert_node(&amp;node).is_follower().term(4).leader(Some(&quot;c&quot;)).voted_for(None);
</a><a href="#h5-9-11" id="h5-9-11" class="i">+        assert_node(&amp;mut node).is_follower().term(4).leader(Some(&quot;c&quot;)).voted_for(None);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-10" id="h5-10" class="h">@@ -394,13 +394,13 @@ pub mod tests {
</a>     // Heartbeat from past term
     fn step_heartbeat_past_term() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-10-3" id="h5-10-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-10-4" id="h5-10-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 2,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h5-10-10" id="h5-10-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a><a href="#h5-10-11" id="h5-10-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h5-11" id="h5-11" class="h">@@ -418,7 +418,7 @@ pub mod tests {
</a>             term: 3,
             event: Event::SolicitVote { last_index: 3, last_term: 2 },
         })?;
<a href="#h5-11-3" id="h5-11-3" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
</a><a href="#h5-11-4" id="h5-11-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-12" id="h5-12" class="h">@@ -437,7 +437,7 @@ pub mod tests {
</a>             term: 3,
             event: Event::SolicitVote { last_index: 3, last_term: 2 },
         })?;
<a href="#h5-12-3" id="h5-12-3" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
</a><a href="#h5-12-4" id="h5-12-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-13" id="h5-13" class="h">@@ -456,7 +456,7 @@ pub mod tests {
</a>             term: 3,
             event: Event::SolicitVote { last_index: 3, last_term: 2 },
         })?;
<a href="#h5-13-3" id="h5-13-3" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
</a><a href="#h5-13-4" id="h5-13-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h5-14" id="h5-14" class="h">@@ -466,13 +466,13 @@ pub mod tests {
</a>     // GrantVote messages are ignored
     fn step_grantvote_noop() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-14-3" id="h5-14-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-14-4" id="h5-14-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::GrantVote,
         })?;
<a href="#h5-14-10" id="h5-14-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;));
</a><a href="#h5-14-11" id="h5-14-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;));
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h5-15" id="h5-15" class="h">@@ -482,13 +482,13 @@ pub mod tests {
</a>     // SolicitVote is rejected if last_term is outdated.
     fn step_solicitvote_last_index_outdated() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-15-3" id="h5-15-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-15-4" id="h5-15-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;c&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::SolicitVote { last_index: 2, last_term: 2 },
         })?;
<a href="#h5-15-10" id="h5-15-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None);
</a><a href="#h5-15-11" id="h5-15-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h5-16" id="h5-16" class="h">@@ -498,13 +498,13 @@ pub mod tests {
</a>     // SolicitVote is rejected if last_term is outdated.
     fn step_solicitvote_last_term_outdated() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-16-3" id="h5-16-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-16-4" id="h5-16-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;c&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
             event: Event::SolicitVote { last_index: 3, last_term: 1 },
         })?;
<a href="#h5-16-10" id="h5-16-10" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None);
</a><a href="#h5-16-11" id="h5-16-11" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h5-17" id="h5-17" class="h">@@ -513,8 +513,27 @@ pub mod tests {
</a>     #[test]
     // ReplicateEntries accepts some entries at base 0 without changes
     fn step_replicateentries_base0() -&gt; Result&lt;()&gt; {
<a href="#h5-17-3" id="h5-17-3" class="d">-        let (follower, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h5-17-4" id="h5-17-4" class="d">-        let node = follower.step(Message {
</a><a href="#h5-17-5" id="h5-17-5" class="i">+        // TODO: Move this into a setup function.
</a><a href="#h5-17-6" id="h5-17-6" class="i">+        let (node_tx, mut node_rx) = mpsc::unbounded_channel();
</a><a href="#h5-17-7" id="h5-17-7" class="i">+        let (state_tx, mut state_rx) = mpsc::unbounded_channel();
</a><a href="#h5-17-8" id="h5-17-8" class="i">+        let mut log = Log::new(Box::new(storage::engine::Memory::new()), false)?;
</a><a href="#h5-17-9" id="h5-17-9" class="i">+        log.append(1, Some(vec![0x01]))?;
</a><a href="#h5-17-10" id="h5-17-10" class="i">+        log.append(1, Some(vec![0x02]))?;
</a><a href="#h5-17-11" id="h5-17-11" class="i">+        log.append(2, Some(vec![0x03]))?;
</a><a href="#h5-17-12" id="h5-17-12" class="i">+
</a><a href="#h5-17-13" id="h5-17-13" class="i">+        let follower = RoleNode {
</a><a href="#h5-17-14" id="h5-17-14" class="i">+            id: &quot;a&quot;.into(),
</a><a href="#h5-17-15" id="h5-17-15" class="i">+            peers: vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()],
</a><a href="#h5-17-16" id="h5-17-16" class="i">+            term: 0,
</a><a href="#h5-17-17" id="h5-17-17" class="i">+            log,
</a><a href="#h5-17-18" id="h5-17-18" class="i">+            node_tx,
</a><a href="#h5-17-19" id="h5-17-19" class="i">+            state_tx,
</a><a href="#h5-17-20" id="h5-17-20" class="i">+            proxied_reqs: HashMap::new(),
</a><a href="#h5-17-21" id="h5-17-21" class="i">+            queued_reqs: Vec::new(),
</a><a href="#h5-17-22" id="h5-17-22" class="i">+            role: Follower::new(Some(&quot;b&quot;), None),
</a><a href="#h5-17-23" id="h5-17-23" class="i">+        };
</a><a href="#h5-17-24" id="h5-17-24" class="i">+
</a><a href="#h5-17-25" id="h5-17-25" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
<a href="#h5-18" id="h5-18" class="h">@@ -527,10 +546,9 @@ pub mod tests {
</a>                 ],
             },
         })?;
<a href="#h5-18-3" id="h5-18-3" class="d">-        assert_node(&amp;node).is_follower().term(3).entries(vec![
</a><a href="#h5-18-4" id="h5-18-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).entries(vec![
</a>             Entry { index: 1, term: 1, command: Some(vec![0x01]) },
             Entry { index: 2, term: 1, command: Some(vec![0x02]) },
<a href="#h5-18-7" id="h5-18-7" class="d">-            Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a>         ]);
         assert_messages(
             &amp;mut node_rx,
<a href="#h5-19" id="h5-19" class="h">@@ -538,7 +556,7 @@ pub mod tests {
</a>                 from: Address::Local,
                 to: Address::Peer(&quot;b&quot;.into()),
                 term: 3,
<a href="#h5-19-3" id="h5-19-3" class="d">-                event: Event::AcceptEntries { last_index: 3 },
</a><a href="#h5-19-4" id="h5-19-4" class="i">+                event: Event::AcceptEntries { last_index: 2 },
</a>             }],
         );
         assert_messages(&amp;mut state_rx, vec![]);
<a href="#h5-20" id="h5-20" class="h">@@ -549,7 +567,7 @@ pub mod tests {
</a>     // ReplicateEntries appends entries but does not commit them
     fn step_replicateentries_append() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-20-3" id="h5-20-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-20-4" id="h5-20-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
<a href="#h5-21" id="h5-21" class="h">@@ -562,7 +580,7 @@ pub mod tests {
</a>                 ],
             },
         })?;
<a href="#h5-21-3" id="h5-21-3" class="d">-        assert_node(&amp;node).is_follower().term(3).entries(vec![
</a><a href="#h5-21-4" id="h5-21-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).entries(vec![
</a>             Entry { index: 1, term: 1, command: Some(vec![0x01]) },
             Entry { index: 2, term: 1, command: Some(vec![0x02]) },
             Entry { index: 3, term: 2, command: Some(vec![0x03]) },
<a href="#h5-22" id="h5-22" class="h">@@ -586,7 +604,7 @@ pub mod tests {
</a>     // ReplicateEntries accepts partially overlapping entries
     fn step_replicateentries_partial_overlap() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-22-3" id="h5-22-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-22-4" id="h5-22-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
<a href="#h5-23" id="h5-23" class="h">@@ -594,13 +612,12 @@ pub mod tests {
</a>                 base_index: 1,
                 base_term: 1,
                 entries: vec![
<a href="#h5-23-3" id="h5-23-3" class="d">-                    Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a>                     Entry { index: 3, term: 2, command: Some(vec![0x03]) },
                     Entry { index: 4, term: 3, command: Some(vec![0x04]) },
                 ],
             },
         })?;
<a href="#h5-23-9" id="h5-23-9" class="d">-        assert_node(&amp;node).is_follower().term(3).entries(vec![
</a><a href="#h5-23-10" id="h5-23-10" class="i">+        assert_node(&amp;mut node).is_follower().term(3).entries(vec![
</a>             Entry { index: 1, term: 1, command: Some(vec![0x01]) },
             Entry { index: 2, term: 1, command: Some(vec![0x02]) },
             Entry { index: 3, term: 2, command: Some(vec![0x03]) },
<a href="#h5-24" id="h5-24" class="h">@@ -623,7 +640,7 @@ pub mod tests {
</a>     // ReplicateEntries replaces conflicting entries
     fn step_replicateentries_replace() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-24-3" id="h5-24-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-24-4" id="h5-24-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
<a href="#h5-25" id="h5-25" class="h">@@ -636,7 +653,7 @@ pub mod tests {
</a>                 ],
             },
         })?;
<a href="#h5-25-3" id="h5-25-3" class="d">-        assert_node(&amp;node).is_follower().term(3).entries(vec![
</a><a href="#h5-25-4" id="h5-25-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).entries(vec![
</a>             Entry { index: 1, term: 1, command: Some(vec![0x01]) },
             Entry { index: 2, term: 1, command: Some(vec![0x02]) },
             Entry { index: 3, term: 3, command: Some(vec![0x04]) },
<a href="#h5-26" id="h5-26" class="h">@@ -659,7 +676,7 @@ pub mod tests {
</a>     // ReplicateEntries replaces partially conflicting entries
     fn step_replicateentries_replace_partial() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-26-3" id="h5-26-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-26-4" id="h5-26-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
<a href="#h5-27" id="h5-27" class="h">@@ -672,7 +689,7 @@ pub mod tests {
</a>                 ],
             },
         })?;
<a href="#h5-27-3" id="h5-27-3" class="d">-        assert_node(&amp;node).is_follower().term(3).entries(vec![
</a><a href="#h5-27-4" id="h5-27-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).entries(vec![
</a>             Entry { index: 1, term: 1, command: Some(vec![0x01]) },
             Entry { index: 2, term: 1, command: Some(vec![0x02]) },
             Entry { index: 3, term: 2, command: Some(vec![0x03]) },
<a href="#h5-28" id="h5-28" class="h">@@ -695,7 +712,7 @@ pub mod tests {
</a>     // ReplicateEntries rejects missing base index
     fn step_replicateentries_reject_missing_base_index() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-28-3" id="h5-28-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-28-4" id="h5-28-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
<a href="#h5-29" id="h5-29" class="h">@@ -705,7 +722,7 @@ pub mod tests {
</a>                 entries: vec![Entry { index: 6, term: 3, command: Some(vec![0x04]) }],
             },
         })?;
<a href="#h5-29-3" id="h5-29-3" class="d">-        assert_node(&amp;node).is_follower().term(3).entries(vec![
</a><a href="#h5-29-4" id="h5-29-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).entries(vec![
</a>             Entry { index: 1, term: 1, command: Some(vec![0x01]) },
             Entry { index: 2, term: 1, command: Some(vec![0x02]) },
             Entry { index: 3, term: 2, command: Some(vec![0x03]) },
<a href="#h5-30" id="h5-30" class="h">@@ -727,7 +744,7 @@ pub mod tests {
</a>     // ReplicateEntries rejects conflicting base term
     fn step_replicateentries_reject_missing_base_term() -&gt; Result&lt;()&gt; {
         let (follower, mut node_rx, mut state_rx) = setup()?;
<a href="#h5-30-3" id="h5-30-3" class="d">-        let node = follower.step(Message {
</a><a href="#h5-30-4" id="h5-30-4" class="i">+        let mut node = follower.step(Message {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
<a href="#h5-31" id="h5-31" class="h">@@ -737,7 +754,7 @@ pub mod tests {
</a>                 entries: vec![Entry { index: 2, term: 3, command: Some(vec![0x04]) }],
             },
         })?;
<a href="#h5-31-3" id="h5-31-3" class="d">-        assert_node(&amp;node).is_follower().term(3).entries(vec![
</a><a href="#h5-31-4" id="h5-31-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).entries(vec![
</a>             Entry { index: 1, term: 1, command: Some(vec![0x01]) },
             Entry { index: 2, term: 1, command: Some(vec![0x02]) },
             Entry { index: 3, term: 2, command: Some(vec![0x03]) },
<a href="#h5-32" id="h5-32" class="h">@@ -767,7 +784,7 @@ pub mod tests {
</a>             term: 0,
             event: Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
         })?;
<a href="#h5-32-3" id="h5-32-3" class="d">-        assert_node(&amp;node)
</a><a href="#h5-32-4" id="h5-32-4" class="i">+        assert_node(&amp;mut node)
</a>             .is_follower()
             .term(3)
             .leader(Some(&quot;b&quot;))
<a href="#h5-33" id="h5-33" class="h">@@ -796,7 +813,12 @@ pub mod tests {
</a>                 response: Ok(Response::State(vec![0xaf])),
             },
         })?;
<a href="#h5-33-3" id="h5-33-3" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).proxied(vec![]).queued(vec![]);
</a><a href="#h5-33-4" id="h5-33-4" class="i">+        assert_node(&amp;mut node)
</a><a href="#h5-33-5" id="h5-33-5" class="i">+            .is_follower()
</a><a href="#h5-33-6" id="h5-33-6" class="i">+            .term(3)
</a><a href="#h5-33-7" id="h5-33-7" class="i">+            .leader(Some(&quot;b&quot;))
</a><a href="#h5-33-8" id="h5-33-8" class="i">+            .proxied(vec![])
</a><a href="#h5-33-9" id="h5-33-9" class="i">+            .queued(vec![]);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h5-34" id="h5-34" class="h">@@ -826,7 +848,7 @@ pub mod tests {
</a>             term: 0,
             event: Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
         })?;
<a href="#h5-34-3" id="h5-34-3" class="d">-        assert_node(&amp;node).is_follower().term(3).leader(None).proxied(vec![]).queued(vec![(
</a><a href="#h5-34-4" id="h5-34-4" class="i">+        assert_node(&amp;mut node).is_follower().term(3).leader(None).proxied(vec![]).queued(vec![(
</a>             Address::Client,
             Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
         )]);
<a href="#h5-35" id="h5-35" class="h">@@ -840,7 +862,7 @@ pub mod tests {
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h5-35-3" id="h5-35-3" class="d">-        assert_node(&amp;node)
</a><a href="#h5-35-4" id="h5-35-4" class="i">+        assert_node(&amp;mut node)
</a>             .is_follower()
             .term(3)
             .leader(Some(&quot;c&quot;))
<a href="#h5-36" id="h5-36" class="h">@@ -887,7 +909,7 @@ pub mod tests {
</a>             term: 0,
             event: Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
         })?;
<a href="#h5-36-3" id="h5-36-3" class="d">-        assert_node(&amp;node)
</a><a href="#h5-36-4" id="h5-36-4" class="i">+        assert_node(&amp;mut node)
</a>             .is_follower()
             .term(3)
             .leader(Some(&quot;b&quot;))
<a href="#h5-37" id="h5-37" class="h">@@ -914,7 +936,12 @@ pub mod tests {
</a>             term: 4,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h5-37-3" id="h5-37-3" class="d">-        assert_node(&amp;node).is_follower().term(4).leader(Some(&quot;c&quot;)).proxied(vec![]).queued(vec![]);
</a><a href="#h5-37-4" id="h5-37-4" class="i">+        assert_node(&amp;mut node)
</a><a href="#h5-37-5" id="h5-37-5" class="i">+            .is_follower()
</a><a href="#h5-37-6" id="h5-37-6" class="i">+            .term(4)
</a><a href="#h5-37-7" id="h5-37-7" class="i">+            .leader(Some(&quot;c&quot;))
</a><a href="#h5-37-8" id="h5-37-8" class="i">+            .proxied(vec![])
</a><a href="#h5-37-9" id="h5-37-9" class="i">+            .queued(vec![]);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![
<a href="#h5-38" id="h5-38" class="h">@@ -950,7 +977,7 @@ pub mod tests {
</a>         // Make sure heartbeats reset election timeout
         assert!(timeout &gt; 0);
         for _ in 0..(3 * timeout) {
<a href="#h5-38-3" id="h5-38-3" class="d">-            assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;));
</a><a href="#h5-38-4" id="h5-38-4" class="i">+            assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;));
</a>             node = node.tick()?;
             node = node.step(Message {
                 from: Address::Peer(&quot;b&quot;.into()),
<a href="#h5-39" id="h5-39" class="h">@@ -970,10 +997,10 @@ pub mod tests {
</a>         }
 
         for _ in 0..timeout {
<a href="#h5-39-3" id="h5-39-3" class="d">-            assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;));
</a><a href="#h5-39-4" id="h5-39-4" class="i">+            assert_node(&amp;mut node).is_follower().term(3).leader(Some(&quot;b&quot;));
</a>             node = node.tick()?;
         }
<a href="#h5-39-7" id="h5-39-7" class="d">-        assert_node(&amp;node).is_candidate().term(4);
</a><a href="#h5-39-8" id="h5-39-8" class="i">+        assert_node(&amp;mut node).is_candidate().term(4);
</a> 
         assert_messages(
             &amp;mut node_rx,
<b>diff --git a/<a id="h6" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -45,8 +45,8 @@ impl RoleNode&lt;Leader&gt; {
</a>     /// Appends an entry to the log and replicates it to peers.
     pub fn append(&amp;mut self, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;u64&gt; {
         let index = self.log.append(self.term, command)?;
<a href="#h6-0-3" id="h6-0-3" class="d">-        for peer in self.peers.iter() {
</a><a href="#h6-0-4" id="h6-0-4" class="d">-            self.replicate(peer)?;
</a><a href="#h6-0-5" id="h6-0-5" class="i">+        for peer in self.peers.clone() {
</a><a href="#h6-0-6" id="h6-0-6" class="i">+            self.replicate(&amp;peer)?;
</a>         }
         Ok(index)
     }
<a href="#h6-1" id="h6-1" class="h">@@ -65,7 +65,7 @@ impl RoleNode&lt;Leader&gt; {
</a>             if let Some(entry) = self.log.get(quorum_index)? {
                 if entry.term == self.term {
                     self.log.commit(quorum_index)?;
<a href="#h6-1-3" id="h6-1-3" class="d">-                    let mut scan = self.log.scan((commit_index + 1)..=quorum_index);
</a><a href="#h6-1-4" id="h6-1-4" class="i">+                    let mut scan = self.log.scan((commit_index + 1)..=quorum_index)?;
</a>                     while let Some(entry) = scan.next().transpose()? {
                         self.state_tx.send(Instruction::Apply { entry })?;
                     }
<a href="#h6-2" id="h6-2" class="h">@@ -76,7 +76,7 @@ impl RoleNode&lt;Leader&gt; {
</a>     }
 
     /// Replicates the log to a peer.
<a href="#h6-2-3" id="h6-2-3" class="d">-    fn replicate(&amp;self, peer: &amp;str) -&gt; Result&lt;()&gt; {
</a><a href="#h6-2-4" id="h6-2-4" class="i">+    fn replicate(&amp;mut self, peer: &amp;str) -&gt; Result&lt;()&gt; {
</a>         let peer_next = self
             .role
             .peer_next_index
<a href="#h6-3" id="h6-3" class="h">@@ -89,7 +89,7 @@ impl RoleNode&lt;Leader&gt; {
</a>             None if base_index == 0 =&gt; 0,
             None =&gt; return Err(Error::Internal(format!(&quot;Missing base entry {}&quot;, base_index))),
         };
<a href="#h6-3-3" id="h6-3-3" class="d">-        let entries = self.log.scan(peer_next..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h6-3-4" id="h6-3-4" class="i">+        let entries = self.log.scan(peer_next..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a>         debug!(&quot;Replicating {} entries at base {} to {}&quot;, entries.len(), base_index, peer);
         self.send(
             Address::Peer(peer.to_string()),
<a href="#h6-4" id="h6-4" class="h">@@ -172,6 +172,7 @@ impl RoleNode&lt;Leader&gt; {
</a>             }
 
             Event::ClientRequest { id, request: Request::Status } =&gt; {
<a href="#h6-4-3" id="h6-4-3" class="i">+                let engine_status = self.log.status()?;
</a>                 let mut status = Box::new(Status {
                     server: self.id.clone(),
                     leader: self.id.clone(),
<a href="#h6-5" id="h6-5" class="h">@@ -179,8 +180,8 @@ impl RoleNode&lt;Leader&gt; {
</a>                     node_last_index: self.role.peer_last_index.clone(),
                     commit_index: self.log.get_commit_index().0,
                     apply_index: 0,
<a href="#h6-5-3" id="h6-5-3" class="d">-                    storage: self.log.store.to_string(),
</a><a href="#h6-5-4" id="h6-5-4" class="d">-                    storage_size: self.log.store.size(),
</a><a href="#h6-5-5" id="h6-5-5" class="i">+                    storage: engine_status.name.clone(),
</a><a href="#h6-5-6" id="h6-5-6" class="i">+                    storage_size: engine_status.size,
</a>                 });
                 status.node_last_index.insert(self.id.clone(), self.log.get_last_index().0);
                 self.state_tx.send(Instruction::Status { id, address: msg.from, status })?
<a href="#h6-6" id="h6-6" class="h">@@ -224,7 +225,7 @@ mod tests {
</a>     use super::super::super::{Entry, Log};
     use super::super::tests::{assert_messages, assert_node};
     use super::*;
<a href="#h6-6-3" id="h6-6-3" class="d">-    use crate::storage::log;
</a><a href="#h6-6-4" id="h6-6-4" class="i">+    use crate::storage;
</a>     use pretty_assertions::assert_eq;
     use tokio::sync::mpsc;
 
<a href="#h6-7" id="h6-7" class="h">@@ -237,7 +238,7 @@ mod tests {
</a>         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
         let peers = vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()];
<a href="#h6-7-3" id="h6-7-3" class="d">-        let mut log = Log::new(Box::new(log::Test::new()))?;
</a><a href="#h6-7-4" id="h6-7-4" class="i">+        let mut log = Log::new(Box::new(storage::engine::Memory::new()), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<a href="#h6-8" id="h6-8" class="h">@@ -272,7 +273,7 @@ mod tests {
</a>             term: 3,
             event: Event::ConfirmLeader { commit_index: 2, has_committed: true },
         })?;
<a href="#h6-8-3" id="h6-8-3" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h6-8-4" id="h6-8-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(
             &amp;mut state_rx,
<a href="#h6-9" id="h6-9" class="h">@@ -293,7 +294,7 @@ mod tests {
</a>             term: 3,
             event: Event::ConfirmLeader { commit_index: 2, has_committed: false },
         })?;
<a href="#h6-9-3" id="h6-9-3" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h6-9-4" id="h6-9-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h6-10" id="h6-10" class="h">@@ -322,7 +323,7 @@ mod tests {
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
         })?;
<a href="#h6-10-3" id="h6-10-3" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h6-10-4" id="h6-10-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h6-11" id="h6-11" class="h">@@ -340,7 +341,7 @@ mod tests {
</a>             term: 4,
             event: Event::Heartbeat { commit_index: 7, commit_term: 4 },
         })?;
<a href="#h6-11-3" id="h6-11-3" class="d">-        assert_node(&amp;node).is_follower().term(4).leader(Some(&quot;b&quot;)).committed(2);
</a><a href="#h6-11-4" id="h6-11-4" class="i">+        assert_node(&amp;mut node).is_follower().term(4).leader(Some(&quot;b&quot;)).committed(2);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h6-12" id="h6-12" class="h">@@ -366,7 +367,7 @@ mod tests {
</a>             term: 2,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h6-12-3" id="h6-12-3" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h6-12-4" id="h6-12-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
         Ok(())
<a href="#h6-13" id="h6-13" class="h">@@ -383,7 +384,7 @@ mod tests {
</a>             term: 3,
             event: Event::AcceptEntries { last_index: 4 },
         })?;
<a href="#h6-13-3" id="h6-13-3" class="d">-        assert_node(&amp;node).committed(2);
</a><a href="#h6-13-4" id="h6-13-4" class="i">+        assert_node(&amp;mut node).committed(2);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(&amp;mut state_rx, vec![]);
 
<a href="#h6-14" id="h6-14" class="h">@@ -393,7 +394,7 @@ mod tests {
</a>             term: 3,
             event: Event::AcceptEntries { last_index: 5 },
         })?;
<a href="#h6-14-3" id="h6-14-3" class="d">-        assert_node(&amp;node).committed(4);
</a><a href="#h6-14-4" id="h6-14-4" class="i">+        assert_node(&amp;mut node).committed(4);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(
             &amp;mut state_rx,
<a href="#h6-15" id="h6-15" class="h">@@ -413,7 +414,7 @@ mod tests {
</a>             term: 3,
             event: Event::AcceptEntries { last_index: 5 },
         })?;
<a href="#h6-15-3" id="h6-15-3" class="d">-        assert_node(&amp;node).committed(5);
</a><a href="#h6-15-4" id="h6-15-4" class="i">+        assert_node(&amp;mut node).committed(5);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(
             &amp;mut state_rx,
<a href="#h6-16" id="h6-16" class="h">@@ -422,7 +423,7 @@ mod tests {
</a>             }],
         );
 
<a href="#h6-16-3" id="h6-16-3" class="d">-        assert_node(&amp;node).is_leader().term(3);
</a><a href="#h6-16-4" id="h6-16-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3);
</a>         Ok(())
     }
 
<a href="#h6-17" id="h6-17" class="h">@@ -439,7 +440,7 @@ mod tests {
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 5 },
             })?;
<a href="#h6-17-3" id="h6-17-3" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h6-17-4" id="h6-17-4" class="i">+            assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a>             assert_messages(&amp;mut node_rx, vec![]);
             assert_messages(&amp;mut state_rx, vec![]);
         }
<a href="#h6-18" id="h6-18" class="h">@@ -460,7 +461,7 @@ mod tests {
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 3 },
             })?;
<a href="#h6-18-3" id="h6-18-3" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h6-18-4" id="h6-18-4" class="i">+            assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a>             assert_messages(&amp;mut node_rx, vec![]);
             assert_messages(&amp;mut state_rx, vec![]);
         }
<a href="#h6-19" id="h6-19" class="h">@@ -484,7 +485,7 @@ mod tests {
</a>             // The local leader will cast a vote to commit 5, thus when we have votes 2x7, 1x5, 2x0
             // we will commit index 5. However, we will correctly ignore the following votes for7.
             let c = if i == 0 { 2 } else { 5 };
<a href="#h6-19-3" id="h6-19-3" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(c).last(5);
</a><a href="#h6-19-4" id="h6-19-4" class="i">+            assert_node(&amp;mut node).is_leader().term(3).committed(c).last(5);
</a>             assert_messages(&amp;mut node_rx, vec![]);
             if i == 1 {
                 assert_messages(
<a href="#h6-20" id="h6-20" class="h">@@ -510,8 +511,8 @@ mod tests {
</a> 
     #[test]
     fn step_rejectentries() -&gt; Result&lt;()&gt; {
<a href="#h6-20-3" id="h6-20-3" class="d">-        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h6-20-4" id="h6-20-4" class="d">-        let entries = leader.log.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h6-20-5" id="h6-20-5" class="i">+        let (mut leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h6-20-6" id="h6-20-6" class="i">+        let entries = leader.log.scan(0..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a>         let mut node: Node = leader.into();
 
         for i in 0..(entries.len() + 3) {
<a href="#h6-21" id="h6-21" class="h">@@ -521,7 +522,7 @@ mod tests {
</a>                 term: 3,
                 event: Event::RejectEntries,
             })?;
<a href="#h6-21-3" id="h6-21-3" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h6-21-4" id="h6-21-4" class="i">+            assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a>             let index = if i &gt;= entries.len() { 0 } else { entries.len() - i - 1 };
             let replicate = entries.get(index..).unwrap().to_vec();
             assert_messages(
<a href="#h6-22" id="h6-22" class="h">@@ -558,7 +559,7 @@ mod tests {
</a>             term: 0,
             event: Event::ClientRequest { id: vec![0x01], request: Request::Query(vec![0xaf]) },
         })?;
<a href="#h6-22-3" id="h6-22-3" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2).last(5);
</a><a href="#h6-22-4" id="h6-22-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3).committed(2).last(5);
</a>         assert_messages(
             &amp;mut node_rx,
             vec![Message {
<a href="#h6-23" id="h6-23" class="h">@@ -598,7 +599,7 @@ mod tests {
</a>             term: 0,
             event: Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
         })?;
<a href="#h6-23-3" id="h6-23-3" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2).last(6).entry(Entry {
</a><a href="#h6-23-4" id="h6-23-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3).committed(2).last(6).entry(Entry {
</a>             index: 6,
             term: 3,
             command: Some(vec![0xaf]),
<a href="#h6-24" id="h6-24" class="h">@@ -640,7 +641,7 @@ mod tests {
</a>             term: 0,
             event: Event::ClientRequest { id: vec![0x01], request: Request::Status },
         })?;
<a href="#h6-24-3" id="h6-24-3" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2).last(5);
</a><a href="#h6-24-4" id="h6-24-4" class="i">+        assert_node(&amp;mut node).is_leader().term(3).committed(2).last(5);
</a>         assert_messages(&amp;mut node_rx, vec![]);
         assert_messages(
             &amp;mut state_rx,
<a href="#h6-25" id="h6-25" class="h">@@ -662,8 +663,8 @@ mod tests {
</a>                     .collect(),
                     commit_index: 2,
                     apply_index: 0,
<a href="#h6-25-3" id="h6-25-3" class="d">-                    storage: &quot;test&quot;.into(),
</a><a href="#h6-25-4" id="h6-25-4" class="d">-                    storage_size: 25,
</a><a href="#h6-25-5" id="h6-25-5" class="i">+                    storage: &quot;memory&quot;.into(),
</a><a href="#h6-25-6" id="h6-25-6" class="i">+                    storage_size: 71,
</a>                 }),
             }],
         );
<a href="#h6-26" id="h6-26" class="h">@@ -680,7 +681,7 @@ mod tests {
</a>                 assert_messages(&amp;mut node_rx, vec![]);
                 assert_messages(&amp;mut state_rx, vec![]);
                 node = node.tick()?;
<a href="#h6-26-3" id="h6-26-3" class="d">-                assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h6-26-4" id="h6-26-4" class="i">+                assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a>             }
 
             assert_eq!(
<b>diff --git a/<a id="h7" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -47,7 +47,7 @@ impl Node {
</a>     pub async fn new(
         id: &amp;str,
         peers: Vec&lt;String&gt;,
<a href="#h7-0-3" id="h7-0-3" class="d">-        log: Log,
</a><a href="#h7-0-4" id="h7-0-4" class="i">+        mut log: Log,
</a>         mut state: Box&lt;dyn State&gt;,
         node_tx: mpsc::UnboundedSender&lt;Message&gt;,
     ) -&gt; Result&lt;Self&gt; {
<a href="#h7-1" id="h7-1" class="h">@@ -64,7 +64,7 @@ impl Node {
</a>         let mut driver = Driver::new(state_rx, node_tx.clone());
         if commit_index &gt; applied_index {
             info!(&quot;Replaying log entries {} to {}&quot;, applied_index + 1, commit_index);
<a href="#h7-1-3" id="h7-1-3" class="d">-            driver.replay(&amp;mut *state, log.scan((applied_index + 1)..=commit_index))?;
</a><a href="#h7-1-4" id="h7-1-4" class="i">+            driver.replay(&amp;mut *state, log.scan((applied_index + 1)..=commit_index)?)?;
</a>         };
         tokio::spawn(driver.drive(state));
 
<a href="#h7-2" id="h7-2" class="h">@@ -242,7 +242,7 @@ mod tests {
</a>     use super::super::Entry;
     use super::follower::tests::{follower_leader, follower_voted_for};
     use super::*;
<a href="#h7-2-3" id="h7-2-3" class="d">-    use crate::storage::log;
</a><a href="#h7-2-4" id="h7-2-4" class="i">+    use crate::storage;
</a>     use pretty_assertions::assert_eq;
     use tokio::sync::mpsc;
 
<a href="#h7-3" id="h7-3" class="h">@@ -258,40 +258,40 @@ mod tests {
</a>     }
 
     pub struct NodeAsserter&lt;&#39;a&gt; {
<a href="#h7-3-3" id="h7-3-3" class="d">-        node: &amp;&#39;a Node,
</a><a href="#h7-3-4" id="h7-3-4" class="i">+        node: &amp;&#39;a mut Node,
</a>     }
 
     impl&lt;&#39;a&gt; NodeAsserter&lt;&#39;a&gt; {
<a href="#h7-3-8" id="h7-3-8" class="d">-        pub fn new(node: &amp;&#39;a Node) -&gt; Self {
</a><a href="#h7-3-9" id="h7-3-9" class="i">+        pub fn new(node: &amp;&#39;a mut Node) -&gt; Self {
</a>             Self { node }
         }
 
<a href="#h7-3-13" id="h7-3-13" class="d">-        fn log(&amp;self) -&gt; &amp;&#39;a Log {
</a><a href="#h7-3-14" id="h7-3-14" class="i">+        fn log(&amp;mut self) -&gt; &amp;&#39;_ mut Log {
</a>             match self.node {
<a href="#h7-3-16" id="h7-3-16" class="d">-                Node::Candidate(n) =&gt; &amp;n.log,
</a><a href="#h7-3-17" id="h7-3-17" class="d">-                Node::Follower(n) =&gt; &amp;n.log,
</a><a href="#h7-3-18" id="h7-3-18" class="d">-                Node::Leader(n) =&gt; &amp;n.log,
</a><a href="#h7-3-19" id="h7-3-19" class="i">+                Node::Candidate(n) =&gt; &amp;mut n.log,
</a><a href="#h7-3-20" id="h7-3-20" class="i">+                Node::Follower(n) =&gt; &amp;mut n.log,
</a><a href="#h7-3-21" id="h7-3-21" class="i">+                Node::Leader(n) =&gt; &amp;mut n.log,
</a>             }
         }
 
<a href="#h7-3-25" id="h7-3-25" class="d">-        pub fn committed(self, index: u64) -&gt; Self {
</a><a href="#h7-3-26" id="h7-3-26" class="i">+        pub fn committed(mut self, index: u64) -&gt; Self {
</a>             assert_eq!(index, self.log().get_commit_index().0, &quot;Unexpected committed index&quot;);
             self
         }
 
<a href="#h7-3-31" id="h7-3-31" class="d">-        pub fn last(self, index: u64) -&gt; Self {
</a><a href="#h7-3-32" id="h7-3-32" class="i">+        pub fn last(mut self, index: u64) -&gt; Self {
</a>             assert_eq!(index, self.log().get_last_index().0, &quot;Unexpected last index&quot;);
             self
         }
 
<a href="#h7-3-37" id="h7-3-37" class="d">-        pub fn entry(self, entry: Entry) -&gt; Self {
</a><a href="#h7-3-38" id="h7-3-38" class="i">+        pub fn entry(mut self, entry: Entry) -&gt; Self {
</a>             assert!(entry.index &lt;= self.log().get_last_index().0, &quot;Index beyond last entry&quot;);
             assert_eq!(entry, self.log().get(entry.index).unwrap().unwrap());
             self
         }
 
<a href="#h7-3-44" id="h7-3-44" class="d">-        pub fn entries(self, entries: Vec&lt;Entry&gt;) -&gt; Self {
</a><a href="#h7-3-45" id="h7-3-45" class="d">-            assert_eq!(entries, self.log().scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;().unwrap());
</a><a href="#h7-3-46" id="h7-3-46" class="i">+        pub fn entries(mut self, entries: Vec&lt;Entry&gt;) -&gt; Self {
</a><a href="#h7-3-47" id="h7-3-47" class="i">+            assert_eq!(entries, self.log().scan(0..).unwrap().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;().unwrap());
</a>             self
         }
 
<a href="#h7-4" id="h7-4" class="h">@@ -359,7 +359,7 @@ mod tests {
</a>             self
         }
 
<a href="#h7-4-3" id="h7-4-3" class="d">-        pub fn term(self, term: u64) -&gt; Self {
</a><a href="#h7-4-4" id="h7-4-4" class="i">+        pub fn term(mut self, term: u64) -&gt; Self {
</a>             assert_eq!(
                 term,
                 match self.node {
<a href="#h7-5" id="h7-5" class="h">@@ -383,7 +383,7 @@ mod tests {
</a>             self
         }
 
<a href="#h7-5-3" id="h7-5-3" class="d">-        pub fn voted_for(self, voted_for: Option&lt;&amp;str&gt;) -&gt; Self {
</a><a href="#h7-5-4" id="h7-5-4" class="i">+        pub fn voted_for(mut self, voted_for: Option&lt;&amp;str&gt;) -&gt; Self {
</a>             assert_eq!(
                 voted_for.map(str::to_owned),
                 match self.node {
<a href="#h7-6" id="h7-6" class="h">@@ -399,7 +399,7 @@ mod tests {
</a>         }
     }
 
<a href="#h7-6-3" id="h7-6-3" class="d">-    pub fn assert_node(node: &amp;Node) -&gt; NodeAsserter {
</a><a href="#h7-6-4" id="h7-6-4" class="i">+    pub fn assert_node(node: &amp;mut Node) -&gt; NodeAsserter {
</a>         NodeAsserter::new(node)
     }
 
<a href="#h7-7" id="h7-7" class="h">@@ -417,7 +417,7 @@ mod tests {
</a>             id: &quot;a&quot;.into(),
             peers,
             term: 1,
<a href="#h7-7-3" id="h7-7-3" class="d">-            log: Log::new(Box::new(log::Test::new()))?,
</a><a href="#h7-7-4" id="h7-7-4" class="i">+            log: Log::new(Box::new(storage::engine::Memory::new()), false)?,
</a>             node_tx,
             state_tx,
             proxied_reqs: HashMap::new(),
<a href="#h7-8" id="h7-8" class="h">@@ -432,7 +432,7 @@ mod tests {
</a>         let node = Node::new(
             &quot;a&quot;,
             vec![&quot;b&quot;.into(), &quot;c&quot;.into()],
<a href="#h7-8-3" id="h7-8-3" class="d">-            Log::new(Box::new(log::Test::new()))?,
</a><a href="#h7-8-4" id="h7-8-4" class="i">+            Log::new(Box::new(storage::engine::Memory::new()), false)?,
</a>             Box::new(TestState::new(0)),
             node_tx,
         )
<a href="#h7-9" id="h7-9" class="h">@@ -448,30 +448,10 @@ mod tests {
</a>         Ok(())
     }
 
<a href="#h7-9-3" id="h7-9-3" class="d">-    #[tokio::test]
</a><a href="#h7-9-4" id="h7-9-4" class="d">-    async fn new_loads_term() -&gt; Result&lt;()&gt; {
</a><a href="#h7-9-5" id="h7-9-5" class="d">-        let (node_tx, _) = mpsc::unbounded_channel();
</a><a href="#h7-9-6" id="h7-9-6" class="d">-        let store = Box::new(log::Test::new());
</a><a href="#h7-9-7" id="h7-9-7" class="d">-        Log::new(store.clone())?.set_term(3, Some(&quot;c&quot;))?;
</a><a href="#h7-9-8" id="h7-9-8" class="d">-        let node = Node::new(
</a><a href="#h7-9-9" id="h7-9-9" class="d">-            &quot;a&quot;,
</a><a href="#h7-9-10" id="h7-9-10" class="d">-            vec![&quot;b&quot;.into(), &quot;c&quot;.into()],
</a><a href="#h7-9-11" id="h7-9-11" class="d">-            Log::new(store)?,
</a><a href="#h7-9-12" id="h7-9-12" class="d">-            Box::new(TestState::new(0)),
</a><a href="#h7-9-13" id="h7-9-13" class="d">-            node_tx,
</a><a href="#h7-9-14" id="h7-9-14" class="d">-        )
</a><a href="#h7-9-15" id="h7-9-15" class="d">-        .await?;
</a><a href="#h7-9-16" id="h7-9-16" class="d">-        match node {
</a><a href="#h7-9-17" id="h7-9-17" class="d">-            Node::Follower(rolenode) =&gt; assert_eq!(rolenode.term, 3),
</a><a href="#h7-9-18" id="h7-9-18" class="d">-            _ =&gt; panic!(&quot;Expected node to start as follower&quot;),
</a><a href="#h7-9-19" id="h7-9-19" class="d">-        }
</a><a href="#h7-9-20" id="h7-9-20" class="d">-        Ok(())
</a><a href="#h7-9-21" id="h7-9-21" class="d">-    }
</a><a href="#h7-9-22" id="h7-9-22" class="d">-
</a>     #[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
     async fn new_state_apply_all() -&gt; Result&lt;()&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h7-9-26" id="h7-9-26" class="d">-        let mut log = Log::new(Box::new(log::Test::new()))?;
</a><a href="#h7-9-27" id="h7-9-27" class="i">+        let mut log = Log::new(Box::new(storage::engine::Memory::new()), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
<a href="#h7-10" id="h7-10" class="h">@@ -489,7 +469,7 @@ mod tests {
</a>     #[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
     async fn new_state_apply_partial() -&gt; Result&lt;()&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h7-10-3" id="h7-10-3" class="d">-        let mut log = Log::new(Box::new(log::Test::new()))?;
</a><a href="#h7-10-4" id="h7-10-4" class="i">+        let mut log = Log::new(Box::new(storage::engine::Memory::new()), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
<a href="#h7-11" id="h7-11" class="h">@@ -507,7 +487,7 @@ mod tests {
</a>     #[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
     async fn new_state_apply_missing() -&gt; Result&lt;()&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h7-11-3" id="h7-11-3" class="d">-        let mut log = Log::new(Box::new(log::Test::new()))?;
</a><a href="#h7-11-4" id="h7-11-4" class="i">+        let mut log = Log::new(Box::new(storage::engine::Memory::new()), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
<a href="#h7-12" id="h7-12" class="h">@@ -530,7 +510,7 @@ mod tests {
</a>         let node = Node::new(
             &quot;a&quot;,
             vec![],
<a href="#h7-12-3" id="h7-12-3" class="d">-            Log::new(Box::new(log::Test::new()))?,
</a><a href="#h7-12-4" id="h7-12-4" class="i">+            Log::new(Box::new(storage::engine::Memory::new()), false)?,
</a>             Box::new(TestState::new(0)),
             node_tx,
         )
<b>diff --git a/<a id="h8" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -5,7 +5,6 @@ use crate::sql::engine::Engine as _;
</a> use crate::sql::execution::ResultSet;
 use crate::sql::schema::{Catalog as _, Table};
 use crate::sql::types::Row;
<a href="#h8-0-3" id="h8-0-3" class="d">-use crate::storage::log;
</a> 
 use ::log::{debug, error, info};
 use futures::sink::SinkExt as _;
<a href="#h8-1" id="h8-1" class="h">@@ -29,11 +28,11 @@ impl Server {
</a>     pub async fn new(
         id: &amp;str,
         peers: HashMap&lt;String, String&gt;,
<a href="#h8-1-3" id="h8-1-3" class="d">-        raft_store: Box&lt;dyn log::Store&gt;,
</a><a href="#h8-1-4" id="h8-1-4" class="i">+        raft_log: raft::Log,
</a>         raft_state: Box&lt;dyn raft::State&gt;,
     ) -&gt; Result&lt;Self&gt; {
         Ok(Server {
<a href="#h8-1-8" id="h8-1-8" class="d">-            raft: raft::Server::new(id, peers, raft::Log::new(raft_store)?, raft_state).await?,
</a><a href="#h8-1-9" id="h8-1-9" class="i">+            raft: raft::Server::new(id, peers, raft_log, raft_state).await?,
</a>             raft_listener: None,
             sql_listener: None,
         })
<b>diff --git a/<a id="h9" href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a> b/<a href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -128,8 +128,8 @@ async fn status() -&gt; Result&lt;()&gt; {
</a>                 node_last_index: vec![(&quot;test&quot;.to_string(), 26)].into_iter().collect(),
                 commit_index: 26,
                 apply_index: 26,
<a href="#h9-0-3" id="h9-0-3" class="d">-                storage: &quot;hybrid&quot;.into(),
</a><a href="#h9-0-4" id="h9-0-4" class="d">-                storage_size: 1202,
</a><a href="#h9-0-5" id="h9-0-5" class="i">+                storage: &quot;bitcask&quot;.into(),
</a><a href="#h9-0-6" id="h9-0-6" class="i">+                storage_size: 1309,
</a>             },
             mvcc: mvcc::Status {
                 versions: 1,
<b>diff --git a/<a id="h10" href="../file/tests/setup.rs.html">tests/setup.rs</a> b/<a href="../file/tests/setup.rs.html">tests/setup.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -3,7 +3,7 @@
</a> use toydb::client::{Client, Pool};
 use toydb::error::Result;
 use toydb::server::Server;
<a href="#h10-0-3" id="h10-0-3" class="d">-use toydb::{sql, storage};
</a><a href="#h10-0-4" id="h10-0-4" class="i">+use toydb::{raft, sql, storage};
</a> 
 use futures_util::future::FutureExt as _;
 use pretty_assertions::assert_eq;
<a href="#h10-1" id="h10-1" class="h">@@ -78,7 +78,7 @@ pub async fn server(
</a>     let mut srv = Server::new(
         id,
         peers,
<a href="#h10-1-3" id="h10-1-3" class="d">-        Box::new(storage::log::Hybrid::new(dir.path(), false)?),
</a><a href="#h10-1-4" id="h10-1-4" class="i">+        raft::Log::new(Box::new(storage::engine::BitCask::new(dir.path().join(&quot;log&quot;))?), false)?,
</a>         Box::new(sql::engine::Raft::new_state(storage::engine::Memory::new())?),
     )
     .await?;
</pre>
</div>
</body>
</html>
