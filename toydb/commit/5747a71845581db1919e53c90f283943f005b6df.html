<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: clean up engine module - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/5747a71845581db1919e53c90f283943f005b6df.html">5747a71845581db1919e53c90f283943f005b6df</a>
<b>parent</b> <a href="../commit/d75876313db8f1d710e252624a98884b3c30c6c1.html">d75876313db8f1d710e252624a98884b3c30c6c1</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 21 Jul 2024 15:43:42 +0200

sql: clean up engine module

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/engine/engine.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">+++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/engine/local.rs</a></td><td> | </td><td class="num">103</td><td><span class="i">++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/engine/mod.rs</a></td><td> | </td><td class="num">5</td><td><span class="i">+++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">41</td><td><span class="i">+++++++++++++++++++</span><span class="d">----------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/engine/session.rs</a></td><td> | </td><td class="num">45</td><td><span class="i">++++++++++++++++++++++</span><span class="d">-----------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/execution/execute.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/mod.rs</a></td><td> | </td><td class="num">66</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/testscripts/writes/delete_reference</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/sql/testscripts/writes/update_reference</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
</table></pre><pre>9 files changed, 173 insertions(+), 122 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/engine/engine.rs.html">src/sql/engine/engine.rs</a> b/<a href="../file/src/sql/engine/engine.rs.html">src/sql/engine/engine.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -54,20 +54,19 @@ pub trait Transaction {
</a>     fn get(&amp;self, table: &amp;str, ids: &amp;[Value]) -&gt; Result&lt;Vec&lt;Row&gt;&gt;;
     /// Inserts new table rows.
     fn insert(&amp;self, table: &amp;str, rows: Vec&lt;Row&gt;) -&gt; Result&lt;()&gt;;
<a href="#h0-0-3" id="h0-0-3" class="d">-    /// Looks up a set of primary keys by index values. Uses a BTreeSet for test
</a><a href="#h0-0-4" id="h0-0-4" class="d">-    /// determinism.
</a><a href="#h0-0-5" id="h0-0-5" class="i">+    /// Looks up a set of primary keys by index values. BTreeSet for testing.
</a>     fn lookup_index(&amp;self, table: &amp;str, column: &amp;str, values: &amp;[Value]) -&gt; Result&lt;BTreeSet&lt;Value&gt;&gt;;
     /// Scans a table&#39;s rows, optionally applying the given filter.
     fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Rows&gt;;
<a href="#h0-0-9" id="h0-0-9" class="d">-    /// Updates table rows by primary key. Uses a BTreeMap for test determinism.
</a><a href="#h0-0-10" id="h0-0-10" class="i">+    /// Updates table rows by primary key. Uses BTreeMap for testing.
</a>     fn update(&amp;self, table: &amp;str, rows: BTreeMap&lt;Value, Row&gt;) -&gt; Result&lt;()&gt;;
 }
 
<a href="#h0-0-14" id="h0-0-14" class="d">-/// The catalog stores table schema information. It is required for
</a><a href="#h0-0-15" id="h0-0-15" class="d">-/// Engine::Transaction, and thus fully transactional. For simplicity, it only
</a><a href="#h0-0-16" id="h0-0-16" class="d">-/// supports very simple operations: creating and dropping tables. There are no
</a><a href="#h0-0-17" id="h0-0-17" class="d">-/// ALTER TABLE schema changes, nor CREATE INDEX -- everything has to be
</a><a href="#h0-0-18" id="h0-0-18" class="d">-/// specified when the table is initially created.
</a><a href="#h0-0-19" id="h0-0-19" class="i">+/// The catalog stores table schema information. It must be implemented for
</a><a href="#h0-0-20" id="h0-0-20" class="i">+/// Engine::Transaction, and is thus fully transactional. For simplicity, it
</a><a href="#h0-0-21" id="h0-0-21" class="i">+/// only supports creating and dropping tables. There are no ALTER TABLE schema
</a><a href="#h0-0-22" id="h0-0-22" class="i">+/// changes, nor CREATE INDEX -- everything has to be specified when the table
</a><a href="#h0-0-23" id="h0-0-23" class="i">+/// is initially created.
</a> ///
 /// This type is separate from Transaction, even though Engine::Transaction
 /// requires transactions to implement it. This allows better control of when
<b>diff --git a/<a id="h1" href="../file/src/sql/engine/local.rs.html">src/sql/engine/local.rs</a> b/<a href="../file/src/sql/engine/local.rs.html">src/sql/engine/local.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -5,16 +5,16 @@ use crate::error::Result;
</a> use crate::sql::types::{Expression, Row, Rows, Table, Value};
 use crate::storage::{self, mvcc};
 
<a href="#h1-0-3" id="h1-0-3" class="i">+use itertools::Itertools as _;
</a> use serde::{Deserialize, Serialize};
 use std::borrow::Cow;
 use std::collections::{BTreeMap, BTreeSet};
 
 /// A SQL engine using local storage. This provides the main SQL storage logic,
<a href="#h1-0-9" id="h1-0-9" class="d">-/// including with the Raft SQL engine which dispatches to this engine for
</a><a href="#h1-0-10" id="h1-0-10" class="d">-/// node-local SQL storage.
</a><a href="#h1-0-11" id="h1-0-11" class="i">+/// and the Raft SQL engine just dispatches to this for node-local SQL storage.
</a> pub struct Local&lt;E: storage::Engine + &#39;static&gt; {
     /// The local MVCC storage engine.
<a href="#h1-0-14" id="h1-0-14" class="d">-    pub(crate) mvcc: mvcc::MVCC&lt;E&gt;,
</a><a href="#h1-0-15" id="h1-0-15" class="i">+    pub mvcc: mvcc::MVCC&lt;E&gt;,
</a> }
 
 impl&lt;E: storage::Engine&gt; Local&lt;E&gt; {
<a href="#h1-1" id="h1-1" class="h">@@ -26,12 +26,12 @@ impl&lt;E: storage::Engine&gt; Local&lt;E&gt; {
</a>     /// Resumes a transaction from the given state. This is usually encapsulated
     /// in `mvcc::Transaction`, but the Raft-based engine can&#39;t retain the MVCC
     /// transaction between each request since it may be executed across
<a href="#h1-1-3" id="h1-1-3" class="d">-    /// multiple leader nodes, so it instead keeps the state in the session.
</a><a href="#h1-1-4" id="h1-1-4" class="i">+    /// different leader nodes, so it instead keeps the state in the session.
</a>     pub fn resume(&amp;self, state: mvcc::TransactionState) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
         Ok(Transaction::new(self.mvcc.resume(state)?))
     }
 
<a href="#h1-1-9" id="h1-1-9" class="d">-    /// Fetches an unversioned key, or None if it doesn&#39;t exist.
</a><a href="#h1-1-10" id="h1-1-10" class="i">+    /// Gets an unversioned key, or None if it doesn&#39;t exist.
</a>     pub fn get_unversioned(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
         self.mvcc.get_unversioned(key)
     }
<a href="#h1-2" id="h1-2" class="h">@@ -70,7 +70,7 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>     }
 
     /// Returns the transaction&#39;s internal state.
<a href="#h1-2-3" id="h1-2-3" class="d">-    pub(super) fn state(&amp;self) -&gt; &amp;mvcc::TransactionState {
</a><a href="#h1-2-4" id="h1-2-4" class="i">+    pub fn state(&amp;self) -&gt; &amp;mvcc::TransactionState {
</a>         self.txn.state()
     }
 
<a href="#h1-3" id="h1-3" class="h">@@ -163,7 +163,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a> 
     fn delete(&amp;self, table: &amp;str, ids: &amp;[Value]) -&gt; Result&lt;()&gt; {
         let table = self.must_get_table(table)?;
<a href="#h1-3-3" id="h1-3-3" class="d">-        let indexes: Vec&lt;_&gt; = table.columns.iter().enumerate().filter(|(_, c)| c.index).collect();
</a><a href="#h1-3-4" id="h1-3-4" class="i">+        let indexes = table.columns.iter().enumerate().filter(|(_, c)| c.index).collect_vec();
</a> 
         // Check for foreign key references to the deleted rows.
         for (source, refs) in self.table_references(&amp;table.name)? {
<a href="#h1-4" id="h1-4" class="h">@@ -188,25 +188,20 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>                         source_ids.remove(id);
                     }
                 }
<a href="#h1-4-3" id="h1-4-3" class="d">-                if let Some(source_id) = source_ids.into_iter().next() {
</a><a href="#h1-4-4" id="h1-4-4" class="d">-                    return errinput!(
</a><a href="#h1-4-5" id="h1-4-5" class="d">-                        &quot;primary key referenced by {}.{}={source_id}&quot;,
</a><a href="#h1-4-6" id="h1-4-6" class="d">-                        source.name,
</a><a href="#h1-4-7" id="h1-4-7" class="d">-                        source.columns[source.primary_key].name
</a><a href="#h1-4-8" id="h1-4-8" class="d">-                    );
</a><a href="#h1-4-9" id="h1-4-9" class="i">+                // Error if the delete would violate referential integrity.
</a><a href="#h1-4-10" id="h1-4-10" class="i">+                if let Some(source_id) = source_ids.first() {
</a><a href="#h1-4-11" id="h1-4-11" class="i">+                    let table = source.name;
</a><a href="#h1-4-12" id="h1-4-12" class="i">+                    let column = &amp;source.columns[source.primary_key].name;
</a><a href="#h1-4-13" id="h1-4-13" class="i">+                    return errinput!(&quot;row referenced by {table}.{column}={source_id}&quot;);
</a>                 }
             }
         }
 
<a href="#h1-4-18" id="h1-4-18" class="i">+        // Delete the rows.
</a>         for id in ids {
<a href="#h1-4-20" id="h1-4-20" class="d">-            // Normalize the ID.
</a><a href="#h1-4-21" id="h1-4-21" class="d">-            //
</a><a href="#h1-4-22" id="h1-4-22" class="d">-            // NB: We don&#39;t need to normalize in the above loop, because we&#39;re
</a><a href="#h1-4-23" id="h1-4-23" class="d">-            // calling methods that themselves perform normalization.
</a>             let id = id.normalize_ref();
 
<a href="#h1-4-26" id="h1-4-26" class="d">-            // Remove the primary key from any index entries. There must be an
</a><a href="#h1-4-27" id="h1-4-27" class="d">-            // index entry for each row.
</a><a href="#h1-4-28" id="h1-4-28" class="i">+            // Update any index entries.
</a>             if !indexes.is_empty() {
                 if let Some(row) = self.get_row(&amp;table.name, &amp;id)? {
                     for (i, column) in indexes.iter().copied() {
<a href="#h1-5" id="h1-5" class="h">@@ -217,7 +212,6 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>                 }
             }
 
<a href="#h1-5-3" id="h1-5-3" class="d">-            // Delete the row.
</a>             self.txn.delete(&amp;Key::Row((&amp;table.name).into(), id).encode())?;
         }
         Ok(())
<a href="#h1-6" id="h1-6" class="h">@@ -249,37 +243,37 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>     }
 
     fn lookup_index(&amp;self, table: &amp;str, column: &amp;str, values: &amp;[Value]) -&gt; Result&lt;BTreeSet&lt;Value&gt;&gt; {
<a href="#h1-6-3" id="h1-6-3" class="d">-        debug_assert!(self.has_index(table, column)?, &quot;index lookup without index&quot;);
</a><a href="#h1-6-4" id="h1-6-4" class="d">-        let mut pks = BTreeSet::new();
</a><a href="#h1-6-5" id="h1-6-5" class="d">-        for v in values {
</a><a href="#h1-6-6" id="h1-6-6" class="d">-            pks.extend(self.get_index(table, column, &amp;v.normalize_ref())?)
</a><a href="#h1-6-7" id="h1-6-7" class="d">-        }
</a><a href="#h1-6-8" id="h1-6-8" class="d">-        Ok(pks)
</a><a href="#h1-6-9" id="h1-6-9" class="i">+        debug_assert!(self.has_index(table, column)?, &quot;no index on {table}.{column}&quot;);
</a><a href="#h1-6-10" id="h1-6-10" class="i">+        values
</a><a href="#h1-6-11" id="h1-6-11" class="i">+            .iter()
</a><a href="#h1-6-12" id="h1-6-12" class="i">+            .map(|v| self.get_index(table, column, &amp;v.normalize_ref()))
</a><a href="#h1-6-13" id="h1-6-13" class="i">+            .flatten_ok()
</a><a href="#h1-6-14" id="h1-6-14" class="i">+            .collect()
</a>     }
 
     fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Rows&gt; {
<a href="#h1-6-18" id="h1-6-18" class="d">-        Ok(Box::new(
</a><a href="#h1-6-19" id="h1-6-19" class="d">-            self.txn
</a><a href="#h1-6-20" id="h1-6-20" class="d">-                .scan_prefix(&amp;KeyPrefix::Row(table.into()).encode())
</a><a href="#h1-6-21" id="h1-6-21" class="d">-                .map(|r| r.and_then(|(_, v)| Row::decode(&amp;v)))
</a><a href="#h1-6-22" id="h1-6-22" class="d">-                .filter_map(move |r| match r {
</a><a href="#h1-6-23" id="h1-6-23" class="d">-                    Ok(row) =&gt; match &amp;filter {
</a><a href="#h1-6-24" id="h1-6-24" class="d">-                        Some(filter) =&gt; match filter.evaluate(Some(&amp;row)) {
</a><a href="#h1-6-25" id="h1-6-25" class="d">-                            Ok(Value::Boolean(b)) if b =&gt; Some(Ok(row)),
</a><a href="#h1-6-26" id="h1-6-26" class="d">-                            Ok(Value::Boolean(_)) | Ok(Value::Null) =&gt; None,
</a><a href="#h1-6-27" id="h1-6-27" class="d">-                            Ok(v) =&gt; Some(errinput!(&quot;filter returned {v}, expected boolean&quot;)),
</a><a href="#h1-6-28" id="h1-6-28" class="d">-                            Err(err) =&gt; Some(Err(err)),
</a><a href="#h1-6-29" id="h1-6-29" class="d">-                        },
</a><a href="#h1-6-30" id="h1-6-30" class="d">-                        None =&gt; Some(Ok(row)),
</a><a href="#h1-6-31" id="h1-6-31" class="d">-                    },
</a><a href="#h1-6-32" id="h1-6-32" class="d">-                    err =&gt; Some(err),
</a><a href="#h1-6-33" id="h1-6-33" class="d">-                }),
</a><a href="#h1-6-34" id="h1-6-34" class="d">-        ))
</a><a href="#h1-6-35" id="h1-6-35" class="i">+        // TODO: this could be simpler if process_results() implemented Clone.
</a><a href="#h1-6-36" id="h1-6-36" class="i">+        let rows = self
</a><a href="#h1-6-37" id="h1-6-37" class="i">+            .txn
</a><a href="#h1-6-38" id="h1-6-38" class="i">+            .scan_prefix(&amp;KeyPrefix::Row(table.into()).encode())
</a><a href="#h1-6-39" id="h1-6-39" class="i">+            .map(|result| result.and_then(|(_, value)| Row::decode(&amp;value)));
</a><a href="#h1-6-40" id="h1-6-40" class="i">+        let Some(filter) = filter else {
</a><a href="#h1-6-41" id="h1-6-41" class="i">+            return Ok(Box::new(rows));
</a><a href="#h1-6-42" id="h1-6-42" class="i">+        };
</a><a href="#h1-6-43" id="h1-6-43" class="i">+        let rows = rows.filter_map(move |result| {
</a><a href="#h1-6-44" id="h1-6-44" class="i">+            result
</a><a href="#h1-6-45" id="h1-6-45" class="i">+                .and_then(|row| match filter.evaluate(Some(&amp;row))? {
</a><a href="#h1-6-46" id="h1-6-46" class="i">+                    Value::Boolean(true) =&gt; Ok(Some(row)),
</a><a href="#h1-6-47" id="h1-6-47" class="i">+                    Value::Boolean(false) | Value::Null =&gt; Ok(None),
</a><a href="#h1-6-48" id="h1-6-48" class="i">+                    value =&gt; errinput!(&quot;filter returned {value}, expected boolean&quot;),
</a><a href="#h1-6-49" id="h1-6-49" class="i">+                })
</a><a href="#h1-6-50" id="h1-6-50" class="i">+                .transpose()
</a><a href="#h1-6-51" id="h1-6-51" class="i">+        });
</a><a href="#h1-6-52" id="h1-6-52" class="i">+        Ok(Box::new(rows))
</a>     }
 
     fn update(&amp;self, table: &amp;str, rows: BTreeMap&lt;Value, Row&gt;) -&gt; Result&lt;()&gt; {
         let table = self.must_get_table(table)?;
<a href="#h1-6-57" id="h1-6-57" class="d">-
</a>         for (mut id, mut row) in rows {
             // Normalize the ID and row.
             id.normalize();
<a href="#h1-7" id="h1-7" class="h">@@ -298,8 +292,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>             table.validate_row(&amp;row, true, self)?;
 
             // Update indexes, knowing that the primary key has not changed.
<a href="#h1-7-3" id="h1-7-3" class="d">-            let indexes: Vec&lt;_&gt; =
</a><a href="#h1-7-4" id="h1-7-4" class="d">-                table.columns.iter().enumerate().filter(|(_, c)| c.index).collect();
</a><a href="#h1-7-5" id="h1-7-5" class="i">+            let indexes = table.columns.iter().enumerate().filter(|(_, c)| c.index).collect_vec();
</a>             if !indexes.is_empty() {
                 let old = self.get(&amp;table.name, &amp;[id.clone()])?.remove(0);
                 for (i, column) in indexes {
<a href="#h1-8" id="h1-8" class="h">@@ -362,29 +355,21 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>         // scanning, so we buffer all keys in a vector. We could also do this in
         // batches, although we&#39;d want to do the batching above Raft to avoid
         // blocking Raft processing for the duration of the drop.
<a href="#h1-8-3" id="h1-8-3" class="d">-        let keys: Vec&lt;Vec&lt;u8&gt;&gt; = self
</a><a href="#h1-8-4" id="h1-8-4" class="d">-            .txn
</a><a href="#h1-8-5" id="h1-8-5" class="d">-            .scan_prefix(&amp;KeyPrefix::Row((&amp;table.name).into()).encode())
</a><a href="#h1-8-6" id="h1-8-6" class="d">-            .map(|r| r.map(|(key, _)| key))
</a><a href="#h1-8-7" id="h1-8-7" class="d">-            .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h1-8-8" id="h1-8-8" class="i">+        let prefix = &amp;KeyPrefix::Row((&amp;table.name).into()).encode();
</a><a href="#h1-8-9" id="h1-8-9" class="i">+        let keys: Vec&lt;Vec&lt;u8&gt;&gt; =
</a><a href="#h1-8-10" id="h1-8-10" class="i">+            self.txn.scan_prefix(prefix).map_ok(|(key, _)| key).try_collect()?;
</a>         for key in keys {
             self.txn.delete(&amp;key)?;
         }
 
         // Delete any secondary indexes.
         for column in table.columns.iter().filter(|c| c.index) {
<a href="#h1-8-17" id="h1-8-17" class="d">-            let keys: Vec&lt;_&gt; = self
</a><a href="#h1-8-18" id="h1-8-18" class="d">-                .txn
</a><a href="#h1-8-19" id="h1-8-19" class="d">-                .scan_prefix(
</a><a href="#h1-8-20" id="h1-8-20" class="d">-                    &amp;KeyPrefix::Index((&amp;table.name).into(), (&amp;column.name).into()).encode(),
</a><a href="#h1-8-21" id="h1-8-21" class="d">-                )
</a><a href="#h1-8-22" id="h1-8-22" class="d">-                .map(|r| r.map(|(key, _)| key))
</a><a href="#h1-8-23" id="h1-8-23" class="d">-                .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h1-8-24" id="h1-8-24" class="i">+            let prefix = &amp;KeyPrefix::Index((&amp;table.name).into(), (&amp;column.name).into()).encode();
</a><a href="#h1-8-25" id="h1-8-25" class="i">+            let keys: Vec&lt;_&gt; = self.txn.scan_prefix(prefix).map_ok(|(key, _)| key).try_collect()?;
</a>             for key in keys {
                 self.txn.delete(&amp;key)?;
             }
         }
<a href="#h1-8-30" id="h1-8-30" class="d">-
</a>         Ok(true)
     }
 
<b>diff --git a/<a id="h2" href="../file/src/sql/engine/mod.rs.html">src/sql/engine/mod.rs</a> b/<a href="../file/src/sql/engine/mod.rs.html">src/sql/engine/mod.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,3 +1,8 @@
</a><a href="#h2-0-0" id="h2-0-0" class="i">+//! The SQL engine provides SQL data storage and access, as well as session and
</a><a href="#h2-0-1" id="h2-0-1" class="i">+//! transaction management. The `Local` engine provides node-local on-disk
</a><a href="#h2-0-2" id="h2-0-2" class="i">+//! storage, while the `Raft` engine submits commands through Raft consensus
</a><a href="#h2-0-3" id="h2-0-3" class="i">+//! before dispatching to the `Local` engine on each node.
</a><a href="#h2-0-4" id="h2-0-4" class="i">+
</a> mod engine;
 mod local;
 mod raft;
<b>diff --git a/<a id="h3" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -12,28 +12,24 @@ use std::borrow::Cow;
</a> use std::collections::{BTreeMap, BTreeSet};
 
 /// A Raft-based SQL engine. This dispatches to the `Local` engine for local
<a href="#h3-0-3" id="h3-0-3" class="d">-/// processing and storage on each node, but plumbs read/write commands through
</a><a href="#h3-0-4" id="h3-0-4" class="i">+/// storage and processing on each node, but plumbs read/write commands through
</a> /// Raft for distributed consensus.
 ///
 /// The `Raft` engine itself is simply a Raft client which sends `raft::Request`
 /// requests to the local Raft node for processing. These requests are received
 /// and processed by the Raft engine&#39;s `State` state machine running below Raft
 /// on each node, which forwards the commands to a `Local` SQL engine which
<a href="#h3-0-11" id="h3-0-11" class="d">-/// actually executes them using a `storage::Engine` for local storage. I.e.:
</a><a href="#h3-0-12" id="h3-0-12" class="i">+/// actually executes them using a `storage::Engine` for local storage.
</a> ///
<a href="#h3-0-14" id="h3-0-14" class="d">-/// 1. `sql::engine::Session`: plans and executes a SQL statement.
</a><a href="#h3-0-15" id="h3-0-15" class="d">-/// 2. `sql::engine::Raft`: sends row CRUD commands as `raft::Request`.
</a><a href="#h3-0-16" id="h3-0-16" class="d">-/// 3. `raft::Node`: performs Raft distributed consensus.
</a><a href="#h3-0-17" id="h3-0-17" class="d">-/// 4. `sql::engine::raft::State`: receives CRUD commands.
</a><a href="#h3-0-18" id="h3-0-18" class="d">-/// 5. `sql::engine::Local`: executes CRUD commands on each node.
</a><a href="#h3-0-19" id="h3-0-19" class="d">-/// 6. `storage::Engine`: reads/writes data on disk.
</a><a href="#h3-0-20" id="h3-0-20" class="i">+/// For more details on how SQL statements flow through the engine, see the
</a><a href="#h3-0-21" id="h3-0-21" class="i">+/// `sql` module documentation.
</a> pub struct Raft {
     /// Sends requests to the local Raft node, along with a response channel.
     tx: Sender&lt;(raft::Request, Sender&lt;Result&lt;raft::Response&gt;&gt;)&gt;,
 }
 
 impl Raft {
<a href="#h3-0-28" id="h3-0-28" class="d">-    /// The unversioned key used to store the applied index. Just use a string
</a><a href="#h3-0-29" id="h3-0-29" class="i">+    /// The unversioned key used to store the applied index. Just uses a string
</a>     /// for simplicity.
     pub const APPLIED_INDEX_KEY: &amp;&#39;static [u8] = b&quot;applied_index&quot;;
 
<a href="#h3-1" id="h3-1" class="h">@@ -57,18 +53,18 @@ impl Raft {
</a>     }
 
     /// Writes through Raft, deserializing the response into the return type.
<a href="#h3-1-3" id="h3-1-3" class="d">-    fn write&lt;V: DeserializeOwned&gt;(&amp;self, mutation: Write) -&gt; Result&lt;V&gt; {
</a><a href="#h3-1-4" id="h3-1-4" class="d">-        match self.execute(raft::Request::Write(mutation.encode()))? {
</a><a href="#h3-1-5" id="h3-1-5" class="d">-            raft::Response::Write(response) =&gt; Ok(bincode::deserialize(&amp;response)?),
</a><a href="#h3-1-6" id="h3-1-6" class="d">-            resp =&gt; errdata!(&quot;unexpected Raft write response {resp:?}&quot;),
</a><a href="#h3-1-7" id="h3-1-7" class="i">+    fn write&lt;V: DeserializeOwned&gt;(&amp;self, write: Write) -&gt; Result&lt;V&gt; {
</a><a href="#h3-1-8" id="h3-1-8" class="i">+        match self.execute(raft::Request::Write(write.encode()))? {
</a><a href="#h3-1-9" id="h3-1-9" class="i">+            raft::Response::Write(response) =&gt; bincode::deserialize(&amp;response),
</a><a href="#h3-1-10" id="h3-1-10" class="i">+            response =&gt; errdata!(&quot;unexpected Raft write response {response:?}&quot;),
</a>         }
     }
 
     /// Reads from Raft, deserializing the response into the return type.
<a href="#h3-1-15" id="h3-1-15" class="d">-    fn read&lt;V: DeserializeOwned&gt;(&amp;self, query: Read) -&gt; Result&lt;V&gt; {
</a><a href="#h3-1-16" id="h3-1-16" class="d">-        match self.execute(raft::Request::Read(query.encode()))? {
</a><a href="#h3-1-17" id="h3-1-17" class="d">-            raft::Response::Read(response) =&gt; Ok(bincode::deserialize(&amp;response)?),
</a><a href="#h3-1-18" id="h3-1-18" class="d">-            resp =&gt; errdata!(&quot;unexpected Raft read response {resp:?}&quot;),
</a><a href="#h3-1-19" id="h3-1-19" class="i">+    fn read&lt;V: DeserializeOwned&gt;(&amp;self, read: Read) -&gt; Result&lt;V&gt; {
</a><a href="#h3-1-20" id="h3-1-20" class="i">+        match self.execute(raft::Request::Read(read.encode()))? {
</a><a href="#h3-1-21" id="h3-1-21" class="i">+            raft::Response::Read(response) =&gt; bincode::deserialize(&amp;response),
</a><a href="#h3-1-22" id="h3-1-22" class="i">+            response =&gt; errdata!(&quot;unexpected Raft read response {response:?}&quot;),
</a>         }
     }
 
<a href="#h3-2" id="h3-2" class="h">@@ -76,7 +72,7 @@ impl Raft {
</a>     pub fn status(&amp;self) -&gt; Result&lt;Status&gt; {
         let raft = match self.execute(raft::Request::Status)? {
             raft::Response::Status(status) =&gt; status,
<a href="#h3-2-3" id="h3-2-3" class="d">-            resp =&gt; return errdata!(&quot;unexpected Raft status response {resp:?}&quot;),
</a><a href="#h3-2-4" id="h3-2-4" class="i">+            response =&gt; return errdata!(&quot;unexpected Raft status response {response:?}&quot;),
</a>         };
         let mvcc = self.read(Read::Status)?;
         Ok(Status { raft, mvcc })
<a href="#h3-3" id="h3-3" class="h">@@ -120,7 +116,7 @@ impl&lt;&#39;a&gt; Transaction&lt;&#39;a&gt; {
</a>         assert!(as_of.is_none() || read_only, &quot;can&#39;t use as_of without read_only&quot;);
         // Read-only transactions don&#39;t need to persist anything, they just need
         // to grab the current transaction state, so submit them as reads to
<a href="#h3-3-3" id="h3-3-3" class="d">-        // avoid a replication roundtrip (which would also require fsyncs).
</a><a href="#h3-3-4" id="h3-3-4" class="i">+        // avoid a replication roundtrip.
</a>         let state = if read_only || as_of.is_some() {
             engine.read(Read::BeginReadOnly { as_of })?
         } else {
<a href="#h3-4" id="h3-4" class="h">@@ -183,7 +179,7 @@ impl&lt;&#39;a&gt; super::Transaction for Transaction&lt;&#39;a&gt; {
</a>     }
 
     fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Rows&gt; {
<a href="#h3-4-3" id="h3-4-3" class="d">-        let scan: Vec&lt;_&gt; = self.engine.read(Read::Scan {
</a><a href="#h3-4-4" id="h3-4-4" class="i">+        let scan: Vec&lt;Row&gt; = self.engine.read(Read::Scan {
</a>             txn: (&amp;self.state).into(),
             table: table.into(),
             filter,
<a href="#h3-5" id="h3-5" class="h">@@ -226,7 +222,7 @@ impl&lt;&#39;a&gt; Catalog for Transaction&lt;&#39;a&gt; {
</a> /// instead simply delivering them as one large chunk. This means that e.g. a
 /// full table scan will pull the entire table into memory, serialize it, and
 /// send it across the network as one message. The simplest way to address this
<a href="#h3-5-3" id="h3-5-3" class="d">-/// would likely be to send batches of e.g. 1000 rows at a time.
</a><a href="#h3-5-4" id="h3-5-4" class="i">+/// would likely be to send row batches, but this is fine for our purposes.
</a> pub struct State&lt;E: storage::Engine + &#39;static&gt; {
     /// The local SQL engine.
     local: super::Local&lt;E&gt;,
<a href="#h3-6" id="h3-6" class="h">@@ -330,9 +326,10 @@ impl&lt;E: storage::Engine&gt; raft::State for State&lt;E&gt; {
</a>                 self.local
                     .resume(txn.into_owned())?
                     .scan(&amp;table, filter)?
<a href="#h3-6-3" id="h3-6-3" class="d">-                    .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h3-6-4" id="h3-6-4" class="i">+                    .collect::&lt;Result&lt;Vec&lt;Row&gt;&gt;&gt;()?
</a>                     .encode()
             }
<a href="#h3-6-7" id="h3-6-7" class="i">+
</a>             Read::GetTable { txn, table } =&gt; {
                 self.local.resume(txn.into_owned())?.get_table(&amp;table)?.encode()
             }
<b>diff --git a/<a id="h4" href="../file/src/sql/engine/session.rs.html">src/sql/engine/session.rs</a> b/<a href="../file/src/sql/engine/session.rs.html">src/sql/engine/session.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -8,6 +8,7 @@ use crate::sql::types::{Label, Row, Rows, Value};
</a> use crate::storage::mvcc;
 use crate::{errdata, errinput};
 
<a href="#h4-0-3" id="h4-0-3" class="i">+use itertools::Itertools as _;
</a> use log::error;
 use serde::{Deserialize, Serialize};
 
<a href="#h4-1" id="h4-1" class="h">@@ -28,28 +29,30 @@ impl&lt;&#39;a, E: Engine&lt;&#39;a&gt;&gt; Session&lt;&#39;a, E&gt; {
</a> 
     /// Executes a client statement.
     pub fn execute(&amp;mut self, statement: &amp;str) -&gt; Result&lt;StatementResult&gt; {
<a href="#h4-1-3" id="h4-1-3" class="d">-        match Parser::new(statement).parse()? {
</a><a href="#h4-1-4" id="h4-1-4" class="i">+        // Parse and execute the statement. Transaction control is done here,
</a><a href="#h4-1-5" id="h4-1-5" class="i">+        // other statements are executed by the SQL engine.
</a><a href="#h4-1-6" id="h4-1-6" class="i">+        Ok(match Parser::new(statement).parse()? {
</a>             ast::Statement::Begin { .. } if self.txn.is_some() =&gt; {
<a href="#h4-1-8" id="h4-1-8" class="d">-                errinput!(&quot;already in a transaction&quot;)
</a><a href="#h4-1-9" id="h4-1-9" class="i">+                return errinput!(&quot;already in a transaction&quot;)
</a>             }
             ast::Statement::Begin { read_only: false, as_of: Some(_) } =&gt; {
<a href="#h4-1-12" id="h4-1-12" class="d">-                errinput!(&quot;can&#39;t start read-write transaction in a given version&quot;)
</a><a href="#h4-1-13" id="h4-1-13" class="i">+                return errinput!(&quot;can&#39;t start read-write transaction in a given version&quot;)
</a>             }
             ast::Statement::Begin { read_only: false, as_of: None } =&gt; {
                 let txn = self.engine.begin()?;
                 let version = txn.version();
                 self.txn = Some(txn);
<a href="#h4-1-19" id="h4-1-19" class="d">-                Ok(StatementResult::Begin { version, read_only: false })
</a><a href="#h4-1-20" id="h4-1-20" class="i">+                StatementResult::Begin { version, read_only: false }
</a>             }
             ast::Statement::Begin { read_only: true, as_of: None } =&gt; {
                 let txn = self.engine.begin_read_only()?;
                 let version = txn.version();
                 self.txn = Some(txn);
<a href="#h4-1-26" id="h4-1-26" class="d">-                Ok(StatementResult::Begin { version, read_only: true })
</a><a href="#h4-1-27" id="h4-1-27" class="i">+                StatementResult::Begin { version, read_only: true }
</a>             }
             ast::Statement::Begin { read_only: true, as_of: Some(version) } =&gt; {
                 self.txn = Some(self.engine.begin_as_of(version)?);
<a href="#h4-1-31" id="h4-1-31" class="d">-                Ok(StatementResult::Begin { version, read_only: true })
</a><a href="#h4-1-32" id="h4-1-32" class="i">+                StatementResult::Begin { version, read_only: true }
</a>             }
             ast::Statement::Commit =&gt; {
                 let Some(txn) = self.txn.take() else {
<a href="#h4-2" id="h4-2" class="h">@@ -57,7 +60,7 @@ impl&lt;&#39;a, E: Engine&lt;&#39;a&gt;&gt; Session&lt;&#39;a, E&gt; {
</a>                 };
                 let version = txn.version();
                 txn.commit()?;
<a href="#h4-2-3" id="h4-2-3" class="d">-                Ok(StatementResult::Commit { version })
</a><a href="#h4-2-4" id="h4-2-4" class="i">+                StatementResult::Commit { version }
</a>             }
             ast::Statement::Rollback =&gt; {
                 let Some(txn) = self.txn.take() else {
<a href="#h4-3" id="h4-3" class="h">@@ -65,18 +68,18 @@ impl&lt;&#39;a, E: Engine&lt;&#39;a&gt;&gt; Session&lt;&#39;a, E&gt; {
</a>                 };
                 let version = txn.version();
                 txn.rollback()?;
<a href="#h4-3-3" id="h4-3-3" class="d">-                Ok(StatementResult::Rollback { version })
</a><a href="#h4-3-4" id="h4-3-4" class="i">+                StatementResult::Rollback { version }
</a>             }
             ast::Statement::Explain(statement) =&gt; self.with_txn(true, |txn| {
                 Ok(StatementResult::Explain(Plan::build(*statement, txn)?.optimize()?))
<a href="#h4-3-8" id="h4-3-8" class="d">-            }),
</a><a href="#h4-3-9" id="h4-3-9" class="i">+            })?,
</a>             statement =&gt; {
                 let read_only = matches!(statement, ast::Statement::Select { .. });
                 self.with_txn(read_only, |txn| {
                     Plan::build(statement, txn)?.optimize()?.execute(txn)?.try_into()
<a href="#h4-3-14" id="h4-3-14" class="d">-                })
</a><a href="#h4-3-15" id="h4-3-15" class="i">+                })?
</a>             }
<a href="#h4-3-17" id="h4-3-17" class="d">-        }
</a><a href="#h4-3-18" id="h4-3-18" class="i">+        })
</a>     }
 
     /// Runs a closure in the session&#39;s explicit transaction, if there is one,
<a href="#h4-4" id="h4-4" class="h">@@ -154,9 +157,9 @@ impl TryFrom&lt;ExecutionResult&gt; for StatementResult {
</a>             ExecutionResult::Delete { count } =&gt; Self::Delete { count },
             ExecutionResult::Insert { count } =&gt; Self::Insert { count },
             ExecutionResult::Update { count } =&gt; Self::Update { count },
<a href="#h4-4-3" id="h4-4-3" class="d">-            ExecutionResult::Select { rows, labels } =&gt; {
</a><a href="#h4-4-4" id="h4-4-4" class="i">+            ExecutionResult::Select { rows, columns } =&gt; {
</a>                 // We buffer the entire set of rows, for simplicity.
<a href="#h4-4-6" id="h4-4-6" class="d">-                Self::Select { columns: labels, rows: rows.collect::&lt;Result&lt;_&gt;&gt;()? }
</a><a href="#h4-4-7" id="h4-4-7" class="i">+                Self::Select { columns, rows: rows.try_collect()? }
</a>             }
         })
     }
<a href="#h4-5" id="h4-5" class="h">@@ -180,7 +183,7 @@ impl TryFrom&lt;StatementResult&gt; for Row {
</a> 
     fn try_from(result: StatementResult) -&gt; Result&lt;Self&gt; {
         let mut rows: Rows = result.try_into()?;
<a href="#h4-5-3" id="h4-5-3" class="d">-        rows.next().transpose()?.ok_or(errdata!(&quot;no rows returned&quot;))
</a><a href="#h4-5-4" id="h4-5-4" class="i">+        rows.next().transpose()?.ok_or_else(|| errdata!(&quot;no rows returned&quot;))
</a>     }
 }
 
<a href="#h4-6" id="h4-6" class="h">@@ -190,7 +193,7 @@ impl TryFrom&lt;StatementResult&gt; for Value {
</a> 
     fn try_from(result: StatementResult) -&gt; Result&lt;Self&gt; {
         let row: Row = result.try_into()?;
<a href="#h4-6-3" id="h4-6-3" class="d">-        row.into_iter().next().ok_or(errdata!(&quot;no columns returned&quot;))
</a><a href="#h4-6-4" id="h4-6-4" class="i">+        row.into_iter().next().ok_or_else(|| errdata!(&quot;no columns returned&quot;))
</a>     }
 }
 
<a href="#h4-7" id="h4-7" class="h">@@ -199,8 +202,7 @@ impl TryFrom&lt;StatementResult&gt; for bool {
</a>     type Error = Error;
 
     fn try_from(result: StatementResult) -&gt; Result&lt;Self&gt; {
<a href="#h4-7-3" id="h4-7-3" class="d">-        let value: Value = result.try_into()?;
</a><a href="#h4-7-4" id="h4-7-4" class="d">-        value.try_into()
</a><a href="#h4-7-5" id="h4-7-5" class="i">+        Value::try_from(result)?.try_into()
</a>     }
 }
 
<a href="#h4-8" id="h4-8" class="h">@@ -209,8 +211,7 @@ impl TryFrom&lt;StatementResult&gt; for f64 {
</a>     type Error = Error;
 
     fn try_from(result: StatementResult) -&gt; Result&lt;Self&gt; {
<a href="#h4-8-3" id="h4-8-3" class="d">-        let value: Value = result.try_into()?;
</a><a href="#h4-8-4" id="h4-8-4" class="d">-        value.try_into()
</a><a href="#h4-8-5" id="h4-8-5" class="i">+        Value::try_from(result)?.try_into()
</a>     }
 }
 
<a href="#h4-9" id="h4-9" class="h">@@ -219,8 +220,7 @@ impl TryFrom&lt;StatementResult&gt; for i64 {
</a>     type Error = Error;
 
     fn try_from(result: StatementResult) -&gt; Result&lt;Self&gt; {
<a href="#h4-9-3" id="h4-9-3" class="d">-        let value: Value = result.try_into()?;
</a><a href="#h4-9-4" id="h4-9-4" class="d">-        value.try_into()
</a><a href="#h4-9-5" id="h4-9-5" class="i">+        Value::try_from(result)?.try_into()
</a>     }
 }
 
<a href="#h4-10" id="h4-10" class="h">@@ -229,7 +229,6 @@ impl TryFrom&lt;StatementResult&gt; for String {
</a>     type Error = Error;
 
     fn try_from(result: StatementResult) -&gt; Result&lt;Self&gt; {
<a href="#h4-10-3" id="h4-10-3" class="d">-        let value: Value = result.try_into()?;
</a><a href="#h4-10-4" id="h4-10-4" class="d">-        value.try_into()
</a><a href="#h4-10-5" id="h4-10-5" class="i">+        Value::try_from(result)?.try_into()
</a>     }
 }
<b>diff --git a/<a id="h5" href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a> b/<a href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -42,9 +42,9 @@ pub fn execute_plan(
</a>         }
 
         Plan::Select(root) =&gt; {
<a href="#h5-0-3" id="h5-0-3" class="d">-            let labels = (0..root.columns()).map(|i| root.column_label(i)).collect();
</a><a href="#h5-0-4" id="h5-0-4" class="d">-            let iter = execute(root, txn)?;
</a><a href="#h5-0-5" id="h5-0-5" class="d">-            ExecutionResult::Select { rows: iter, labels }
</a><a href="#h5-0-6" id="h5-0-6" class="i">+            let columns = (0..root.columns()).map(|i| root.column_label(i)).collect();
</a><a href="#h5-0-7" id="h5-0-7" class="i">+            let rows = execute(root, txn)?;
</a><a href="#h5-0-8" id="h5-0-8" class="i">+            ExecutionResult::Select { rows, columns }
</a>         }
 
         Plan::Update { table, primary_key, source, expressions } =&gt; {
<a href="#h5-1" id="h5-1" class="h">@@ -130,5 +130,5 @@ pub enum ExecutionResult {
</a>     Delete { count: u64 },
     Insert { count: u64 },
     Update { count: u64 },
<a href="#h5-1-3" id="h5-1-3" class="d">-    Select { rows: Rows, labels: Vec&lt;Label&gt; },
</a><a href="#h5-1-4" id="h5-1-4" class="i">+    Select { rows: Rows, columns: Vec&lt;Label&gt; },
</a> }
<b>diff --git a/<a id="h6" href="../file/src/sql/mod.rs.html">src/sql/mod.rs</a> b/<a href="../file/src/sql/mod.rs.html">src/sql/mod.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,3 +1,69 @@
</a><a href="#h6-0-0" id="h6-0-0" class="i">+//! Implements a SQL execution engine. A SQL statement flows through the engine
</a><a href="#h6-0-1" id="h6-0-1" class="i">+//! as follows:
</a><a href="#h6-0-2" id="h6-0-2" class="i">+//!
</a><a href="#h6-0-3" id="h6-0-3" class="i">+//! 1. The `toySQL` client connects to the server, which creates a new
</a><a href="#h6-0-4" id="h6-0-4" class="i">+//!    `sql::engine::Session` in `Server::sql_session`.
</a><a href="#h6-0-5" id="h6-0-5" class="i">+//!
</a><a href="#h6-0-6" id="h6-0-6" class="i">+//! 2. `toySQL` submits a SQL `SELECT` string, which the server executes via
</a><a href="#h6-0-7" id="h6-0-7" class="i">+//!     `Session::execute`.
</a><a href="#h6-0-8" id="h6-0-8" class="i">+//!
</a><a href="#h6-0-9" id="h6-0-9" class="i">+//! 3. `Session::execute` calls `Parser::parse` to parse the SQL `SELECT` string
</a><a href="#h6-0-10" id="h6-0-10" class="i">+//!     into an `ast::Statement::Select` AST (Abstract Syntax Tree). The parser
</a><a href="#h6-0-11" id="h6-0-11" class="i">+//!     uses the `Lexer` for initial tokenization.
</a><a href="#h6-0-12" id="h6-0-12" class="i">+//!     
</a><a href="#h6-0-13" id="h6-0-13" class="i">+//! 4. `Session::execute` obtains a new read-only `sql::engine::Transaction` via
</a><a href="#h6-0-14" id="h6-0-14" class="i">+//!    `Session::with_txn`. We&#39;ll gloss over the details here.
</a><a href="#h6-0-15" id="h6-0-15" class="i">+//!
</a><a href="#h6-0-16" id="h6-0-16" class="i">+//! 5. `Session::execute` calls `Plan::build` to construct an execution plan
</a><a href="#h6-0-17" id="h6-0-17" class="i">+//!    from the AST via the `Planner`, using the `Transaction`&#39;s
</a><a href="#h6-0-18" id="h6-0-18" class="i">+//!    `sql::engine::Catalog` trait to look up table schema information.
</a><a href="#h6-0-19" id="h6-0-19" class="i">+//!
</a><a href="#h6-0-20" id="h6-0-20" class="i">+//! 6. `Session::execute` calls `Plan::optimize` to optimize the execution plan
</a><a href="#h6-0-21" id="h6-0-21" class="i">+//!    via the optimizers in `sql::planner::optimizer`. This e.g. performs
</a><a href="#h6-0-22" id="h6-0-22" class="i">+//!    filter pushdown to filter rows during storage scans, uses secondary
</a><a href="#h6-0-23" id="h6-0-23" class="i">+//!    indexes where appropriate, and chooses more efficient join types.
</a><a href="#h6-0-24" id="h6-0-24" class="i">+//!
</a><a href="#h6-0-25" id="h6-0-25" class="i">+//! 7. `Session::execute` calls `Plan::execute` to actually execute the plan,
</a><a href="#h6-0-26" id="h6-0-26" class="i">+//!    using the `Transaction` to access the `sql::engine::Engine`.  It uses the
</a><a href="#h6-0-27" id="h6-0-27" class="i">+//!    executors in `sql::execution` to recursively execute the
</a><a href="#h6-0-28" id="h6-0-28" class="i">+//!    `sql::planner::Node` nodes, which stream and process `sql::types::Row`
</a><a href="#h6-0-29" id="h6-0-29" class="i">+//!    vectors via `sql::types::Rows` iterators.
</a><a href="#h6-0-30" id="h6-0-30" class="i">+//!
</a><a href="#h6-0-31" id="h6-0-31" class="i">+//! 8. At the tip of the execution plan there&#39;s typically a `Node::Scan` which
</a><a href="#h6-0-32" id="h6-0-32" class="i">+//!    performs full table scans from storage. It is executed by
</a><a href="#h6-0-33" id="h6-0-33" class="i">+//!    `sql::execution::source::scan`, which calls `Transaction::scan`.
</a><a href="#h6-0-34" id="h6-0-34" class="i">+//!
</a><a href="#h6-0-35" id="h6-0-35" class="i">+//! 9. The upper `sql::engine::Raft` engine submits a `Read::Scan` request to
</a><a href="#h6-0-36" id="h6-0-36" class="i">+//!    Raft via `Raft::read` and `Raft::execute`. This is submitted through the
</a><a href="#h6-0-37" id="h6-0-37" class="i">+//!    crossbeam channel `Raft::tx`, which is routed to the local Raft node in
</a><a href="#h6-0-38" id="h6-0-38" class="i">+//!    `Server::raft_route` via `raft::Node::step`.
</a><a href="#h6-0-39" id="h6-0-39" class="i">+//!
</a><a href="#h6-0-40" id="h6-0-40" class="i">+//! 10. We&#39;ll skip Raft details, but see the `raft` module documentation. The
</a><a href="#h6-0-41" id="h6-0-41" class="i">+//!     `Read::Scan` request eventually makes its way to the SQL state machine
</a><a href="#h6-0-42" id="h6-0-42" class="i">+//!     `sql::engine::raft::State` that&#39;s managed by Raft. Since this is a read
</a><a href="#h6-0-43" id="h6-0-43" class="i">+//!     request, it is executed only on the leader node, calling `State::read`.
</a><a href="#h6-0-44" id="h6-0-44" class="i">+//!
</a><a href="#h6-0-45" id="h6-0-45" class="i">+//! 11. `State` wraps the `sql::engine::Local` SQL execution engine that runs
</a><a href="#h6-0-46" id="h6-0-46" class="i">+//!     on each node, using local storage. `State::read` calls
</a><a href="#h6-0-47" id="h6-0-47" class="i">+//!     `Transaction::scan` using a `Local::Transaction`.
</a><a href="#h6-0-48" id="h6-0-48" class="i">+//!
</a><a href="#h6-0-49" id="h6-0-49" class="i">+//! 12. The `Local` engine uses a `storage::BitCask` engine for local storage,
</a><a href="#h6-0-50" id="h6-0-50" class="i">+//!     with `storage::mvcc` providing transactions. See their documentation
</a><a href="#h6-0-51" id="h6-0-51" class="i">+//!     for details.
</a><a href="#h6-0-52" id="h6-0-52" class="i">+//!
</a><a href="#h6-0-53" id="h6-0-53" class="i">+//! 13. `Transaction::scan` uses `sql::engine::KeyPrefix::Table` to obtain the
</a><a href="#h6-0-54" id="h6-0-54" class="i">+//!     key prefix for the scanned table, encoded via `encoding::keycode`. It
</a><a href="#h6-0-55" id="h6-0-55" class="i">+//!     scans rows under this prefix by calling `MVCC::scan_prefix`, which in
</a><a href="#h6-0-56" id="h6-0-56" class="i">+//!     turn dispatches to `BitCask::scan_prefix`. It returns a row iterator.
</a><a href="#h6-0-57" id="h6-0-57" class="i">+//!
</a><a href="#h6-0-58" id="h6-0-58" class="i">+//! 14. A row iterator is propagated back up through the stack:
</a><a href="#h6-0-59" id="h6-0-59" class="i">+//!     `BitCask` → `MVCC` → `Local` → `State` → `Raft` → `scan` → `Plan::execute`
</a><a href="#h6-0-60" id="h6-0-60" class="i">+//!
</a><a href="#h6-0-61" id="h6-0-61" class="i">+//! 15. `Plan::execute` collects the results in a `ExecutionResult::Select`,
</a><a href="#h6-0-62" id="h6-0-62" class="i">+//!     and returns it to `Session::execute`. It in turns returns it to
</a><a href="#h6-0-63" id="h6-0-63" class="i">+//!     `Server::sql_session`, which encodes it and sends it across the wire
</a><a href="#h6-0-64" id="h6-0-64" class="i">+//!     to `toySQL`, which displays them to the user.
</a><a href="#h6-0-65" id="h6-0-65" class="i">+
</a> pub mod engine;
 pub mod execution;
 pub mod parser;
<b>diff --git a/<a id="h7" href="../file/src/sql/testscripts/writes/delete_reference.html">src/sql/testscripts/writes/delete_reference</a> b/<a href="../file/src/sql/testscripts/writes/delete_reference.html">src/sql/testscripts/writes/delete_reference</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -24,8 +24,8 @@ ok
</a> !&gt; DELETE FROM ref
 !&gt; DELETE FROM ref WHERE id = 1
 ---
<a href="#h7-0-3" id="h7-0-3" class="d">-Error: invalid input: primary key referenced by name.id=1
</a><a href="#h7-0-4" id="h7-0-4" class="d">-Error: invalid input: primary key referenced by name.id=1
</a><a href="#h7-0-5" id="h7-0-5" class="i">+Error: invalid input: row referenced by name.id=1
</a><a href="#h7-0-6" id="h7-0-6" class="i">+Error: invalid input: row referenced by name.id=1
</a> 
 &gt; SELECT * FROM ref
 ---
<a href="#h7-1" id="h7-1" class="h">@@ -97,7 +97,7 @@ ok
</a> # Deleting a referenced row errors.
 !&gt; DELETE FROM self WHERE id = 2
 ---
<a href="#h7-1-3" id="h7-1-3" class="d">-Error: invalid input: primary key referenced by self.id=3
</a><a href="#h7-1-4" id="h7-1-4" class="i">+Error: invalid input: row referenced by self.id=3
</a> 
 # Deleting an unreferenced row works.
 &gt; DELETE FROM self WHERE id = 4
<b>diff --git a/<a id="h8" href="../file/src/sql/testscripts/writes/update_reference.html">src/sql/testscripts/writes/update_reference</a> b/<a href="../file/src/sql/testscripts/writes/update_reference.html">src/sql/testscripts/writes/update_reference</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -158,8 +158,8 @@ storage delete mvcc:TxnActive(26) [&quot;\x01\x00\x00\x00\x00\x00\x00\x00\x1a&quot;]
</a> !&gt; UPDATE self SET id = 4 WHERE id = 1
 !&gt; UPDATE self SET id = 4 WHERE id = 2
 ---
<a href="#h8-0-3" id="h8-0-3" class="d">-Error: invalid input: primary key referenced by self.id=2
</a><a href="#h8-0-4" id="h8-0-4" class="d">-Error: invalid input: primary key referenced by self.id=3
</a><a href="#h8-0-5" id="h8-0-5" class="i">+Error: invalid input: row referenced by self.id=2
</a><a href="#h8-0-6" id="h8-0-6" class="i">+Error: invalid input: row referenced by self.id=3
</a> 
 # Not even when only this row points to itself.
 &gt; UPDATE self SET self_id = NULL WHERE id &gt; 1
<a href="#h8-1" id="h8-1" class="h">@@ -185,4 +185,4 @@ Error: invalid input: reference 1 not in table self
</a> 
 !&gt; UPDATE &quot;int&quot; SET id = -id
 ---
<a href="#h8-1-3" id="h8-1-3" class="d">-Error: invalid input: primary key referenced by name.id=2
</a><a href="#h8-1-4" id="h8-1-4" class="i">+Error: invalid input: row referenced by name.id=2
</a></pre>
</div>
</body>
</html>
