<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: add `Remap` node to remap column indexes - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/5c55e70e0e9fb5c9bc7802455e67446037f328a1.html">5c55e70e0e9fb5c9bc7802455e67446037f328a1</a>
<b>parent</b> <a href="../commit/f7debde44aa823c13c004f8a94a9f0921f0721af.html">f7debde44aa823c13c004f8a94a9f0921f0721af</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Mon, 15 Jul 2024 18:58:21 +0200

sql: add `Remap` node to remap column indexes

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/execution/execute.rs</a></td><td> | </td><td class="num">5</td><td><span class="i">+++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/execution/transform.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/planner/plan.rs</a></td><td> | </td><td class="num">39</td><td><span class="i">++++++++++++++++++++++++++++++++++++++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">87</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/testscripts/queries/having</a></td><td> | </td><td class="num">16</td><td><span class="i">++++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/testscripts/queries/join_inner</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/testscripts/queries/join_outer</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/testscripts/queries/order</a></td><td> | </td><td class="num">20</td><td><span class="i">++++++++++</span><span class="d">----------</span></td></tr>
</table></pre><pre>8 files changed, 142 insertions(+), 51 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a> b/<a href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -122,6 +122,11 @@ pub fn execute(node: Node, txn: &amp;impl Transaction) -&gt; Result&lt;Rows&gt; {
</a>             Ok(transform::project(source, expressions))
         }
 
<a href="#h0-0-3" id="h0-0-3" class="i">+        Node::Remap { source, targets } =&gt; {
</a><a href="#h0-0-4" id="h0-0-4" class="i">+            let source = execute(*source, txn)?;
</a><a href="#h0-0-5" id="h0-0-5" class="i">+            Ok(transform::remap(source, targets))
</a><a href="#h0-0-6" id="h0-0-6" class="i">+        }
</a><a href="#h0-0-7" id="h0-0-7" class="i">+
</a>         Node::Scan { table, filter, alias: _ } =&gt; source::scan(txn, table, filter),
 
         Node::Values { rows } =&gt; Ok(source::values(rows)),
<b>diff --git a/<a id="h1" href="../file/src/sql/execution/transform.rs.html">src/sql/execution/transform.rs</a> b/<a href="../file/src/sql/execution/transform.rs.html">src/sql/execution/transform.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -65,3 +65,19 @@ pub(super) fn project(source: Rows, expressions: Vec&lt;Expression&gt;) -&gt; Rows {
</a>         r.and_then(|row| expressions.iter().map(|e| e.evaluate(Some(&amp;row))).collect())
     }))
 }
<a href="#h1-0-3" id="h1-0-3" class="i">+
</a><a href="#h1-0-4" id="h1-0-4" class="i">+/// Remaps source columns to target column indexes, or drops them if None.
</a><a href="#h1-0-5" id="h1-0-5" class="i">+pub(super) fn remap(source: Rows, targets: Vec&lt;Option&lt;usize&gt;&gt;) -&gt; Rows {
</a><a href="#h1-0-6" id="h1-0-6" class="i">+    let size = targets.iter().filter_map(|v| *v).map(|i| i + 1).max().unwrap_or(0);
</a><a href="#h1-0-7" id="h1-0-7" class="i">+    Box::new(source.map(move |r| {
</a><a href="#h1-0-8" id="h1-0-8" class="i">+        r.map(|row| {
</a><a href="#h1-0-9" id="h1-0-9" class="i">+            let mut out = vec![Value::Null; size];
</a><a href="#h1-0-10" id="h1-0-10" class="i">+            for (value, target) in row.into_iter().zip(&amp;targets) {
</a><a href="#h1-0-11" id="h1-0-11" class="i">+                if let Some(index) = target {
</a><a href="#h1-0-12" id="h1-0-12" class="i">+                    out[*index] = value;
</a><a href="#h1-0-13" id="h1-0-13" class="i">+                }
</a><a href="#h1-0-14" id="h1-0-14" class="i">+            }
</a><a href="#h1-0-15" id="h1-0-15" class="i">+            out
</a><a href="#h1-0-16" id="h1-0-16" class="i">+        })
</a><a href="#h1-0-17" id="h1-0-17" class="i">+    }))
</a><a href="#h1-0-18" id="h1-0-18" class="i">+}
</a><b>diff --git a/<a id="h2" href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a> b/<a href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -128,6 +128,9 @@ pub enum Node {
</a>     /// Projects the input rows by evaluating the given expressions.
     /// The labels are only used when displaying the plan.
     Projection { source: Box&lt;Node&gt;, expressions: Vec&lt;Expression&gt;, labels: Vec&lt;Label&gt; },
<a href="#h2-0-3" id="h2-0-3" class="i">+    /// Remaps source columns to the given target column index, or None to drop
</a><a href="#h2-0-4" id="h2-0-4" class="i">+    /// the column. Unspecified target columns yield Value::Null.
</a><a href="#h2-0-5" id="h2-0-5" class="i">+    Remap { source: Box&lt;Node&gt;, targets: Vec&lt;Option&lt;usize&gt;&gt; },
</a>     /// A full table scan, with an optional filter pushdown. The schema is used
     /// during plan optimization. The alias is only used for formatting.
     Scan { table: Table, filter: Option&lt;Expression&gt;, alias: Option&lt;String&gt; },
<a href="#h2-1" id="h2-1" class="h">@@ -186,6 +189,7 @@ impl Node {
</a>             Self::Projection { source, labels, expressions } =&gt; {
                 Self::Projection { source: transform(source)?, labels, expressions }
             }
<a href="#h2-1-3" id="h2-1-3" class="i">+            Self::Remap { source, targets } =&gt; Self::Remap { source: transform(source)?, targets },
</a> 
             node @ (Self::IndexLookup { .. }
             | Self::KeyLookup { .. }
<a href="#h2-2" id="h2-2" class="h">@@ -249,7 +253,8 @@ impl Node {
</a>             | Self::NestedLoopJoin { predicate: None, .. }
             | Self::Nothing
             | Self::Offset { .. }
<a href="#h2-2-3" id="h2-2-3" class="d">-            | Self::Scan { filter: None, .. }) =&gt; node,
</a><a href="#h2-2-4" id="h2-2-4" class="i">+            | Self::Scan { filter: None, .. }
</a><a href="#h2-2-5" id="h2-2-5" class="i">+            | Self::Remap { .. }) =&gt; node,
</a>         })
     }
 
<a href="#h2-3" id="h2-3" class="h">@@ -267,6 +272,9 @@ impl Node {
</a>             Node::Offset { source, .. } =&gt; source.size(),
             Node::Order { source, .. } =&gt; source.size(),
             Node::Projection { expressions, .. } =&gt; expressions.len(),
<a href="#h2-3-3" id="h2-3-3" class="i">+            Node::Remap { targets, .. } =&gt; {
</a><a href="#h2-3-4" id="h2-3-4" class="i">+                targets.iter().filter_map(|v| *v).map(|i| i + 1).max().unwrap_or(0)
</a><a href="#h2-3-5" id="h2-3-5" class="i">+            }
</a>             Node::Scan { table, .. } =&gt; table.columns.len(),
             Node::Values { rows } =&gt; rows.first().map(|row| row.len()).unwrap_or(0),
         }
<a href="#h2-4" id="h2-4" class="h">@@ -419,6 +427,22 @@ impl Node {
</a>                 write!(f, &quot;Projection: {}&quot;, expressions.iter().join(&quot;, &quot;))?;
                 source.format(f, prefix, false, true)?;
             }
<a href="#h2-4-3" id="h2-4-3" class="i">+            Self::Remap { source, targets } =&gt; {
</a><a href="#h2-4-4" id="h2-4-4" class="i">+                let remap = remap_sources(targets)
</a><a href="#h2-4-5" id="h2-4-5" class="i">+                    .into_iter()
</a><a href="#h2-4-6" id="h2-4-6" class="i">+                    .map(|from| from.map(|from| format!(&quot;#{from}&quot;)).unwrap_or(&quot;Null&quot;.to_string()))
</a><a href="#h2-4-7" id="h2-4-7" class="i">+                    .join(&quot;, &quot;);
</a><a href="#h2-4-8" id="h2-4-8" class="i">+                write!(f, &quot;Remap: {remap}&quot;)?;
</a><a href="#h2-4-9" id="h2-4-9" class="i">+                let dropped = targets
</a><a href="#h2-4-10" id="h2-4-10" class="i">+                    .iter()
</a><a href="#h2-4-11" id="h2-4-11" class="i">+                    .enumerate()
</a><a href="#h2-4-12" id="h2-4-12" class="i">+                    .filter_map(|(i, v)| v.is_none().then_some(format!(&quot;#{i}&quot;)))
</a><a href="#h2-4-13" id="h2-4-13" class="i">+                    .join(&quot;, &quot;);
</a><a href="#h2-4-14" id="h2-4-14" class="i">+                if !dropped.is_empty() {
</a><a href="#h2-4-15" id="h2-4-15" class="i">+                    write!(f, &quot; (dropped: {dropped})&quot;)?;
</a><a href="#h2-4-16" id="h2-4-16" class="i">+                }
</a><a href="#h2-4-17" id="h2-4-17" class="i">+                source.format(f, prefix, false, true)?;
</a><a href="#h2-4-18" id="h2-4-18" class="i">+            }
</a>             Self::Scan { table, alias, filter } =&gt; {
                 write!(f, &quot;Scan: {}&quot;, table.name)?;
                 if let Some(alias) = alias {
<a href="#h2-5" id="h2-5" class="h">@@ -487,3 +511,16 @@ impl From&lt;ast::Order&gt; for Direction {
</a>         }
     }
 }
<a href="#h2-5-3" id="h2-5-3" class="i">+
</a><a href="#h2-5-4" id="h2-5-4" class="i">+/// Inverts a Remap targets vector to a vector of source indexes, with None
</a><a href="#h2-5-5" id="h2-5-5" class="i">+/// for columns that weren&#39;t targeted.
</a><a href="#h2-5-6" id="h2-5-6" class="i">+pub fn remap_sources(targets: &amp;[Option&lt;usize&gt;]) -&gt; Vec&lt;Option&lt;usize&gt;&gt; {
</a><a href="#h2-5-7" id="h2-5-7" class="i">+    let size = targets.iter().filter_map(|v| *v).map(|i| i + 1).max().unwrap_or(0);
</a><a href="#h2-5-8" id="h2-5-8" class="i">+    let mut sources = vec![None; size];
</a><a href="#h2-5-9" id="h2-5-9" class="i">+    for (from, to) in targets.iter().enumerate() {
</a><a href="#h2-5-10" id="h2-5-10" class="i">+        if let Some(to) = to {
</a><a href="#h2-5-11" id="h2-5-11" class="i">+            sources[*to] = Some(from);
</a><a href="#h2-5-12" id="h2-5-12" class="i">+        }
</a><a href="#h2-5-13" id="h2-5-13" class="i">+    }
</a><a href="#h2-5-14" id="h2-5-14" class="i">+    sources
</a><a href="#h2-5-15" id="h2-5-15" class="i">+}
</a><b>diff --git a/<a id="h3" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,5 +1,6 @@
</a> #![allow(clippy::module_inception)]
 
<a href="#h3-0-2" id="h3-0-2" class="i">+use super::plan::remap_sources;
</a> use super::{Aggregate, Direction, Node, Plan};
 use crate::errinput;
 use crate::error::Result;
<a href="#h3-1" id="h3-1" class="h">@@ -260,17 +261,9 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             node = Node::Limit { source: Box::new(node), limit }
         }
 
<a href="#h3-1-3" id="h3-1-3" class="d">-        // Add a final projection that removes hidden columns, only passing
</a><a href="#h3-1-4" id="h3-1-4" class="d">-        // through the originally requested columns.
</a><a href="#h3-1-5" id="h3-1-5" class="d">-        //
</a><a href="#h3-1-6" id="h3-1-6" class="d">-        // TODO: add a separate plan node kind for this, and also use it for
</a><a href="#h3-1-7" id="h3-1-7" class="d">-        // RIGHT JOIN projections.
</a><a href="#h3-1-8" id="h3-1-8" class="d">-        let hidden = scope.remove_hidden();
</a><a href="#h3-1-9" id="h3-1-9" class="d">-        if !hidden.is_empty() {
</a><a href="#h3-1-10" id="h3-1-10" class="d">-            let size = node.size() - hidden.len();
</a><a href="#h3-1-11" id="h3-1-11" class="d">-            let labels = vec![Label::None; size];
</a><a href="#h3-1-12" id="h3-1-12" class="d">-            let expressions = (0..size).map(|i| Expression::Field(i, Label::None)).collect_vec();
</a><a href="#h3-1-13" id="h3-1-13" class="d">-            node = Node::Projection { source: Box::new(node), labels, expressions }
</a><a href="#h3-1-14" id="h3-1-14" class="i">+        // Remove any hidden columns before emitting the result.
</a><a href="#h3-1-15" id="h3-1-15" class="i">+        if let Some(targets) = scope.remap_hidden() {
</a><a href="#h3-1-16" id="h3-1-16" class="i">+            node = Node::Remap { source: Box::new(node), targets }
</a>         }
 
         Ok(Plan::Select { root: node, labels: scope.columns })
<a href="#h3-2" id="h3-2" class="h">@@ -317,8 +310,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a> 
             // A two-way join. The left or right nodes may be chained joins.
             ast::From::Join { mut left, mut right, r#type, predicate } =&gt; {
<a href="#h3-2-3" id="h3-2-3" class="d">-                // Right joins are built as a left join with an additional
</a><a href="#h3-2-4" id="h3-2-4" class="d">-                // projection to swap the resulting columns.
</a><a href="#h3-2-5" id="h3-2-5" class="i">+                // Right joins are built as a left join then column swap.
</a>                 if matches!(r#type, ast::JoinType::Right) {
                     (left, right) = (right, left)
                 }
<a href="#h3-3" id="h3-3" class="h">@@ -333,15 +325,12 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 let outer = r#type.is_outer();
                 let mut node = Node::NestedLoopJoin { left, right, predicate, outer };
 
<a href="#h3-3-3" id="h3-3-3" class="d">-                // For right joins, build a projection to swap the columns.
</a><a href="#h3-3-4" id="h3-3-4" class="i">+                // For right joins, swap the columns.
</a>                 if matches!(r#type, ast::JoinType::Right) {
<a href="#h3-3-6" id="h3-3-6" class="d">-                    let labels = vec![Label::None; left_size + right_size];
</a><a href="#h3-3-7" id="h3-3-7" class="d">-                    let expressions = (left_size..left_size + right_size)
</a><a href="#h3-3-8" id="h3-3-8" class="d">-                        .chain(0..left_size)
</a><a href="#h3-3-9" id="h3-3-9" class="d">-                        .map(|i| Expression::Field(i, scope.get_label(i)))
</a><a href="#h3-3-10" id="h3-3-10" class="d">-                        .collect_vec();
</a><a href="#h3-3-11" id="h3-3-11" class="d">-                    scope = scope.project(&amp;expressions, &amp;labels)?;
</a><a href="#h3-3-12" id="h3-3-12" class="d">-                    node = Node::Projection { source: Box::new(node), expressions, labels }
</a><a href="#h3-3-13" id="h3-3-13" class="i">+                    let size = left_size + right_size;
</a><a href="#h3-3-14" id="h3-3-14" class="i">+                    let targets = (0..size).map(|i| Some((i + right_size) % size)).collect_vec();
</a><a href="#h3-3-15" id="h3-3-15" class="i">+                    scope = scope.remap(&amp;targets);
</a><a href="#h3-3-16" id="h3-3-16" class="i">+                    node = Node::Remap { source: Box::new(node), targets }
</a>                 }
                 node
             }
<a href="#h3-4" id="h3-4" class="h">@@ -749,25 +738,42 @@ impl Scope {
</a>         }
     }
 
<a href="#h3-4-3" id="h3-4-3" class="d">-    /// Removes hidden columns from the scope, returning their indexes.
</a><a href="#h3-4-4" id="h3-4-4" class="d">-    fn remove_hidden(&amp;mut self) -&gt; HashSet&lt;usize&gt; {
</a><a href="#h3-4-5" id="h3-4-5" class="i">+    /// Removes hidden columns from the scope, returning their indexes or None
</a><a href="#h3-4-6" id="h3-4-6" class="i">+    /// if no columns are hidden.
</a><a href="#h3-4-7" id="h3-4-7" class="i">+    fn remove_hidden(&amp;mut self) -&gt; Option&lt;HashSet&lt;usize&gt;&gt; {
</a>         if self.hidden.is_empty() {
<a href="#h3-4-9" id="h3-4-9" class="d">-            return HashSet::new();
</a><a href="#h3-4-10" id="h3-4-10" class="i">+            return None;
</a>         }
         let hidden = std::mem::take(&amp;mut self.hidden);
<a href="#h3-4-13" id="h3-4-13" class="d">-
</a>         let mut index = 0;
         self.columns.retain(|_| {
             let is_hidden = hidden.contains(&amp;index);
             index += 1;
             !is_hidden
         });
<a href="#h3-4-20" id="h3-4-20" class="d">-
</a>         self.qualified.retain(|_, index| !hidden.contains(index));
         self.unqualified.iter_mut().for_each(|(_, vec)| vec.retain(|i| !hidden.contains(i)));
         self.unqualified.retain(|_, vec| !vec.is_empty());
         self.aggregates.retain(|_, index| !hidden.contains(index));
<a href="#h3-4-25" id="h3-4-25" class="d">-        hidden
</a><a href="#h3-4-26" id="h3-4-26" class="i">+        Some(hidden)
</a><a href="#h3-4-27" id="h3-4-27" class="i">+    }
</a><a href="#h3-4-28" id="h3-4-28" class="i">+
</a><a href="#h3-4-29" id="h3-4-29" class="i">+    /// Removes hidden columns from the scope and returns the remaining column
</a><a href="#h3-4-30" id="h3-4-30" class="i">+    /// indexes as a Remap targets vector, or None if no columns are hidden. A
</a><a href="#h3-4-31" id="h3-4-31" class="i">+    /// Remap targets vector maps parent column indexes to child column indexes,
</a><a href="#h3-4-32" id="h3-4-32" class="i">+    /// or None if a column should be dropped.
</a><a href="#h3-4-33" id="h3-4-33" class="i">+    fn remap_hidden(&amp;mut self) -&gt; Option&lt;Vec&lt;Option&lt;usize&gt;&gt;&gt; {
</a><a href="#h3-4-34" id="h3-4-34" class="i">+        let size = self.columns.len();
</a><a href="#h3-4-35" id="h3-4-35" class="i">+        let hidden = self.remove_hidden()?;
</a><a href="#h3-4-36" id="h3-4-36" class="i">+        let mut targets = vec![None; size];
</a><a href="#h3-4-37" id="h3-4-37" class="i">+        let mut index = 0;
</a><a href="#h3-4-38" id="h3-4-38" class="i">+        for (old_index, target) in targets.iter_mut().enumerate() {
</a><a href="#h3-4-39" id="h3-4-39" class="i">+            if !hidden.contains(&amp;old_index) {
</a><a href="#h3-4-40" id="h3-4-40" class="i">+                *target = Some(index);
</a><a href="#h3-4-41" id="h3-4-41" class="i">+                index += 1;
</a><a href="#h3-4-42" id="h3-4-42" class="i">+            }
</a><a href="#h3-4-43" id="h3-4-43" class="i">+        }
</a><a href="#h3-4-44" id="h3-4-44" class="i">+        Some(targets)
</a>     }
 
     /// Merges two scopes, by appending the given scope to self.
<a href="#h3-5" id="h3-5" class="h">@@ -818,4 +824,31 @@ impl Scope {
</a>         }
         Ok(new)
     }
<a href="#h3-5-3" id="h3-5-3" class="i">+
</a><a href="#h3-5-4" id="h3-5-4" class="i">+    /// Passes the given column through from a parent scope.
</a><a href="#h3-5-5" id="h3-5-5" class="i">+    fn add_column_from(&amp;mut self, parent: &amp;Scope, parent_index: usize) -&gt; usize {
</a><a href="#h3-5-6" id="h3-5-6" class="i">+        let label = parent.get_label(parent_index);
</a><a href="#h3-5-7" id="h3-5-7" class="i">+        let index = self.add_column(label);
</a><a href="#h3-5-8" id="h3-5-8" class="i">+        for (expr, i) in &amp;parent.aggregates {
</a><a href="#h3-5-9" id="h3-5-9" class="i">+            if *i == parent_index {
</a><a href="#h3-5-10" id="h3-5-10" class="i">+                self.aggregates.entry(expr.clone()).or_insert(index);
</a><a href="#h3-5-11" id="h3-5-11" class="i">+            }
</a><a href="#h3-5-12" id="h3-5-12" class="i">+        }
</a><a href="#h3-5-13" id="h3-5-13" class="i">+        if parent.hidden.contains(&amp;parent_index) {
</a><a href="#h3-5-14" id="h3-5-14" class="i">+            self.hidden.insert(index);
</a><a href="#h3-5-15" id="h3-5-15" class="i">+        }
</a><a href="#h3-5-16" id="h3-5-16" class="i">+        index
</a><a href="#h3-5-17" id="h3-5-17" class="i">+    }
</a><a href="#h3-5-18" id="h3-5-18" class="i">+
</a><a href="#h3-5-19" id="h3-5-19" class="i">+    /// Remaps the scope using the given targets.
</a><a href="#h3-5-20" id="h3-5-20" class="i">+    fn remap(&amp;self, targets: &amp;[Option&lt;usize&gt;]) -&gt; Self {
</a><a href="#h3-5-21" id="h3-5-21" class="i">+        let mut new = Scope::new();
</a><a href="#h3-5-22" id="h3-5-22" class="i">+        new.tables = self.tables.clone();
</a><a href="#h3-5-23" id="h3-5-23" class="i">+
</a><a href="#h3-5-24" id="h3-5-24" class="i">+        for index in remap_sources(targets).into_iter().flatten() {
</a><a href="#h3-5-25" id="h3-5-25" class="i">+            new.add_column_from(self, index);
</a><a href="#h3-5-26" id="h3-5-26" class="i">+        }
</a><a href="#h3-5-27" id="h3-5-27" class="i">+
</a><a href="#h3-5-28" id="h3-5-28" class="i">+        new
</a><a href="#h3-5-29" id="h3-5-29" class="i">+    }
</a> }
<b>diff --git a/<a id="h4" href="../file/src/sql/testscripts/queries/having.html">src/sql/testscripts/queries/having</a> b/<a href="../file/src/sql/testscripts/queries/having.html">src/sql/testscripts/queries/having</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -39,7 +39,7 @@ TRUE
</a> # Having works with an aggregate function, even if it&#39;s not in SELECT.
 [plan]&gt; SELECT &quot;group&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) &gt; 10
 ---
<a href="#h4-0-3" id="h4-0-3" class="d">-Projection: #0, #1
</a><a href="#h4-0-4" id="h4-0-4" class="i">+Remap: #0, #1 (dropped: #2)
</a> └─ Filter: #2 &gt; 10
    └─ Projection: test.group, #1, #1
       └─ Aggregate: max(int) group by group
<a href="#h4-1" id="h4-1" class="h">@@ -48,7 +48,7 @@ b, 42
</a> 
 [plan]&gt; SELECT &quot;group&quot; FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) &gt; 10
 ---
<a href="#h4-1-3" id="h4-1-3" class="d">-Projection: #0
</a><a href="#h4-1-4" id="h4-1-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Filter: #1 &gt; 10
    └─ Aggregate: max(int) group by group
       └─ Scan: test
<a href="#h4-2" id="h4-2" class="h">@@ -56,7 +56,7 @@ b
</a> 
 [plan]&gt; SELECT &quot;group&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) - MIN(&quot;int&quot;) &gt; 10
 ---
<a href="#h4-2-3" id="h4-2-3" class="d">-Projection: #0, #1
</a><a href="#h4-2-4" id="h4-2-4" class="i">+Remap: #0, #1 (dropped: #2, #3)
</a> └─ Filter: #2 - #3 &gt; 10
    └─ Projection: test.group, #1, #1, #2
       └─ Aggregate: max(int), min(int) group by group
<a href="#h4-3" id="h4-3" class="h">@@ -74,7 +74,7 @@ b, 42
</a> # Having works with an aggregate function not in the SELECT clause.
 [plan]&gt; SELECT &quot;group&quot;, COUNT(*) FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) &gt; 10
 ---
<a href="#h4-3-3" id="h4-3-3" class="d">-Projection: #0, #1
</a><a href="#h4-3-4" id="h4-3-4" class="i">+Remap: #0, #1 (dropped: #2)
</a> └─ Filter: #2 &gt; 10
    └─ Aggregate: count(TRUE), max(int) group by group
       └─ Scan: test
<a href="#h4-4" id="h4-4" class="h">@@ -83,7 +83,7 @@ b, 3
</a> # Having works with compound expressions.
 [plan]&gt; SELECT &quot;group&quot;, COUNT(*) FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) / COUNT(*) &gt; 3
 ---
<a href="#h4-4-3" id="h4-4-3" class="d">-Projection: #0, #1
</a><a href="#h4-4-4" id="h4-4-4" class="i">+Remap: #0, #1 (dropped: #2, #3)
</a> └─ Filter: #2 / #3 &gt; 3
    └─ Projection: test.group, #1, #2, #1
       └─ Aggregate: count(TRUE), max(int) group by group
<a href="#h4-5" id="h4-5" class="h">@@ -94,7 +94,7 @@ b, 3
</a> # that are not on the SELECT clause.
 [plan]&gt; SELECT COUNT(*) FROM test GROUP BY id % 2 HAVING 2 - id % 2 + 1 &gt; 1
 ---
<a href="#h4-5-3" id="h4-5-3" class="d">-Projection: #0
</a><a href="#h4-5-4" id="h4-5-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Filter: 2 - #1 + 1 &gt; 1
    └─ Projection: #1, #0
       └─ Aggregate: count(TRUE) group by id % 2
<a href="#h4-6" id="h4-6" class="h">@@ -105,7 +105,7 @@ Projection: #0
</a> # Having can use (un)qualified expressions for an (un)qualified GROUP BY.
 [plan]&gt; SELECT COUNT(*) FROM test GROUP BY &quot;group&quot; HAVING test.&quot;group&quot; = &#39;a&#39;
 ---
<a href="#h4-6-3" id="h4-6-3" class="d">-Projection: #0
</a><a href="#h4-6-4" id="h4-6-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Filter: test.group = a
    └─ Projection: #1, test.group
       └─ Aggregate: count(TRUE) group by group
<a href="#h4-7" id="h4-7" class="h">@@ -114,7 +114,7 @@ Projection: #0
</a> 
 [plan]&gt; SELECT COUNT(*) FROM test GROUP BY test.&quot;group&quot; HAVING &quot;group&quot; = &#39;a&#39;
 ---
<a href="#h4-7-3" id="h4-7-3" class="d">-Projection: #0
</a><a href="#h4-7-4" id="h4-7-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Filter: group = a
    └─ Projection: #1, group
       └─ Aggregate: count(TRUE) group by test.group
<b>diff --git a/<a id="h5" href="../file/src/sql/testscripts/queries/join_inner.html">src/sql/testscripts/queries/join_inner</a> b/<a href="../file/src/sql/testscripts/queries/join_inner.html">src/sql/testscripts/queries/join_inner</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -221,7 +221,7 @@ Error: invalid input: unknown field movies.unknown_id
</a>   WHERE m.studio_id = s.id \
   ORDER BY m.rating DESC, m.released ASC, m.id ASC
 ---
<a href="#h5-0-3" id="h5-0-3" class="d">-Projection: #0, #1, #2, #3, #4
</a><a href="#h5-0-4" id="h5-0-4" class="i">+Remap: #0, #1, #2, #3, #4 (dropped: #5)
</a> └─ Order: m.rating desc, m.released asc, m.id asc
    └─ Projection: m.id, m.title, g.name, s.name, m.rating, m.released
       └─ HashJoin: inner on m.studio_id = s.id
<b>diff --git a/<a id="h6" href="../file/src/sql/testscripts/queries/join_outer.html">src/sql/testscripts/queries/join_outer</a> b/<a href="../file/src/sql/testscripts/queries/join_outer.html">src/sql/testscripts/queries/join_outer</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -70,7 +70,7 @@ HashJoin: outer on movies.id = genres.id
</a> # Right join.
 [plan]&gt; SELECT * FROM genres RIGHT JOIN movies ON movies.id = genres.id
 ---
<a href="#h6-0-3" id="h6-0-3" class="d">-Projection: genres.id, genres.name, movies.id, movies.title, movies.studio_id, movies.genre_id, movies.released, movies.rating, movies.ultrahd
</a><a href="#h6-0-4" id="h6-0-4" class="i">+Remap: #7, #8, #0, #1, #2, #3, #4, #5, #6
</a> └─ HashJoin: outer on movies.id = genres.id
    ├─ Scan: movies
    └─ Scan: genres
<a href="#h6-1" id="h6-1" class="h">@@ -104,7 +104,7 @@ HashJoin: outer on movies.id = genres.id
</a> 
 [plan]&gt; SELECT * FROM genres RIGHT OUTER JOIN movies ON movies.id = genres.id
 ---
<a href="#h6-1-3" id="h6-1-3" class="d">-Projection: genres.id, genres.name, movies.id, movies.title, movies.studio_id, movies.genre_id, movies.released, movies.rating, movies.ultrahd
</a><a href="#h6-1-4" id="h6-1-4" class="i">+Remap: #7, #8, #0, #1, #2, #3, #4, #5, #6
</a> └─ HashJoin: outer on movies.id = genres.id
    ├─ Scan: movies
    └─ Scan: genres
<a href="#h6-2" id="h6-2" class="h">@@ -131,7 +131,7 @@ HashJoin: outer on genres.id = movies.id
</a> 
 [plan]&gt; SELECT * FROM movies RIGHT JOIN genres ON movies.id = genres.id
 ---
<a href="#h6-2-3" id="h6-2-3" class="d">-Projection: movies.id, movies.title, movies.studio_id, movies.genre_id, movies.released, movies.rating, movies.ultrahd, genres.id, genres.name
</a><a href="#h6-2-4" id="h6-2-4" class="i">+Remap: #2, #3, #4, #5, #6, #7, #8, #0, #1
</a> └─ HashJoin: outer on genres.id = movies.id
    ├─ Scan: genres
    └─ Scan: movies
<a href="#h6-3" id="h6-3" class="h">@@ -164,7 +164,7 @@ NestedLoopJoin: outer on genres.id &gt; movies.id OR genres.id = movies.id
</a>     LEFT JOIN genres ON studios.id = genres.id \
     RIGHT JOIN movies ON movies.id = studios.id
 ---
<a href="#h6-3-3" id="h6-3-3" class="d">-Projection: studios.id, studios.name, studios.country_id, genres.id, genres.name, movies.id, movies.title, movies.studio_id, movies.genre_id, movies.released, movies.rating, movies.ultrahd
</a><a href="#h6-3-4" id="h6-3-4" class="i">+Remap: #7, #8, #9, #10, #11, #0, #1, #2, #3, #4, #5, #6
</a> └─ HashJoin: outer on movies.id = studios.id
    ├─ Scan: movies
    └─ HashJoin: outer on studios.id = genres.id
<b>diff --git a/<a id="h7" href="../file/src/sql/testscripts/queries/order.html">src/sql/testscripts/queries/order</a> b/<a href="../file/src/sql/testscripts/queries/order.html">src/sql/testscripts/queries/order</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -258,7 +258,7 @@ Order: float ^ 2 asc
</a> # only result in one hidden column.
 [plan]&gt; SELECT id, &quot;int&quot; FROM test ORDER BY &quot;bool&quot; DESC
 ---
<a href="#h7-0-3" id="h7-0-3" class="d">-Projection: #0, #1
</a><a href="#h7-0-4" id="h7-0-4" class="i">+Remap: #0, #1 (dropped: #2)
</a> └─ Order: bool desc
    └─ Projection: id, int, bool
       └─ Scan: test
<a href="#h7-1" id="h7-1" class="h">@@ -275,7 +275,7 @@ Projection: #0, #1
</a> 
 [plan]&gt; SELECT id, &quot;int&quot; FROM test ORDER BY &quot;bool&quot; DESC, &quot;bool&quot; ASC
 ---
<a href="#h7-1-3" id="h7-1-3" class="d">-Projection: #0, #1
</a><a href="#h7-1-4" id="h7-1-4" class="i">+Remap: #0, #1 (dropped: #2)
</a> └─ Order: bool desc, bool asc
    └─ Projection: id, int, bool
       └─ Scan: test
<a href="#h7-2" id="h7-2" class="h">@@ -293,7 +293,7 @@ Projection: #0, #1
</a> # Can order on expressions on columns not in the result.
 [plan]&gt; SELECT id FROM test ORDER BY &quot;float&quot; ^ 2 - &quot;int&quot; ^ 2 DESC
 ---
<a href="#h7-2-3" id="h7-2-3" class="d">-Projection: #0
</a><a href="#h7-2-4" id="h7-2-4" class="i">+Remap: #0 (dropped: #1, #2)
</a> └─ Order: float ^ 2 - int ^ 2 desc
    └─ Projection: id, float, int
       └─ Scan: test
<a href="#h7-3" id="h7-3" class="h">@@ -373,7 +373,7 @@ Order: int desc
</a> 
 [plan]&gt; SELECT id AS &quot;int&quot; FROM test ORDER BY test.&quot;int&quot; DESC
 ---
<a href="#h7-3-3" id="h7-3-3" class="d">-Projection: #0
</a><a href="#h7-3-4" id="h7-3-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Order: test.int desc
    └─ Projection: id, test.int
       └─ Scan: test
<a href="#h7-4" id="h7-4" class="h">@@ -472,7 +472,7 @@ Order: o.id desc, t.id asc
</a> # Order by aggregates, both when in SELECT and otherwise.
 [plan]&gt; SELECT &quot;bool&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;bool&quot; ORDER BY MAX(&quot;int&quot;) DESC
 ---
<a href="#h7-4-3" id="h7-4-3" class="d">-Projection: #0, #1
</a><a href="#h7-4-4" id="h7-4-4" class="i">+Remap: #0, #1 (dropped: #2)
</a> └─ Order: #2 desc
    └─ Projection: test.bool, #1, #1
       └─ Aggregate: max(int) group by bool
<a href="#h7-5" id="h7-5" class="h">@@ -483,7 +483,7 @@ FALSE, -1
</a> 
 [plan]&gt; SELECT &quot;bool&quot; FROM test GROUP BY &quot;bool&quot; ORDER BY MAX(&quot;int&quot;) DESC
 ---
<a href="#h7-5-3" id="h7-5-3" class="d">-Projection: #0
</a><a href="#h7-5-4" id="h7-5-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Order: #1 desc
    └─ Aggregate: max(int) group by bool
       └─ Scan: test
<a href="#h7-6" id="h7-6" class="h">@@ -493,7 +493,7 @@ FALSE
</a> 
 [plan]&gt; SELECT &quot;bool&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;bool&quot; ORDER BY MAX(&quot;int&quot;) - MIN(&quot;int&quot;) DESC
 ---
<a href="#h7-6-3" id="h7-6-3" class="d">-Projection: #0, #1
</a><a href="#h7-6-4" id="h7-6-4" class="i">+Remap: #0, #1 (dropped: #2, #3)
</a> └─ Order: #2 - #3 desc
    └─ Projection: test.bool, #1, #1, #2
       └─ Aggregate: max(int), min(int) group by bool
<a href="#h7-7" id="h7-7" class="h">@@ -506,7 +506,7 @@ TRUE, 0
</a> # that are not on the SELECT clause.
 [plan]&gt; SELECT COUNT(*) FROM test GROUP BY id % 2 ORDER BY 2 - id % 2 + 1 &gt; 1
 ---
<a href="#h7-7-3" id="h7-7-3" class="d">-Projection: #0
</a><a href="#h7-7-4" id="h7-7-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Order: 2 - #1 + 1 &gt; 1 asc
    └─ Projection: #1, #0
       └─ Aggregate: count(TRUE) group by id % 2
<a href="#h7-8" id="h7-8" class="h">@@ -517,7 +517,7 @@ Projection: #0
</a> # ORDER BY can use (un)qualified expressions for an (un)qualified GROUP BY.
 [plan]&gt; SELECT COUNT(*) FROM test GROUP BY &quot;bool&quot; ORDER BY test.&quot;bool&quot;
 ---
<a href="#h7-8-3" id="h7-8-3" class="d">-Projection: #0
</a><a href="#h7-8-4" id="h7-8-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Order: test.bool asc
    └─ Projection: #1, test.bool
       └─ Aggregate: count(TRUE) group by bool
<a href="#h7-9" id="h7-9" class="h">@@ -528,7 +528,7 @@ Projection: #0
</a> 
 [plan]&gt; SELECT COUNT(*) FROM test GROUP BY test.&quot;bool&quot; ORDER BY &quot;bool&quot;
 ---
<a href="#h7-9-3" id="h7-9-3" class="d">-Projection: #0
</a><a href="#h7-9-4" id="h7-9-4" class="i">+Remap: #0 (dropped: #1)
</a> └─ Order: bool asc
    └─ Projection: #1, bool
       └─ Aggregate: count(TRUE) group by test.bool
</pre>
</div>
</body>
</html>
