<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: remove `Expression::Field` label - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/0883278de9a2133b76a91cf06c93541373203b5d.html">0883278de9a2133b76a91cf06c93541373203b5d</a>
<b>parent</b> <a href="../commit/beb90939fdb061ed6c6d2fb1b21dd204d1914e4e.html">beb90939fdb061ed6c6d2fb1b21dd204d1914e4e</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue, 16 Jul 2024 22:35:39 +0200

sql: remove `Expression::Field` label

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/planner/optimizer.rs</a></td><td> | </td><td class="num">21</td><td><span class="i">++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/planner/plan.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">9</td><td><span class="i">++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/types/expression.rs</a></td><td> | </td><td class="num">31</td><td><span class="i">+++++++++++++++</span><span class="d">----------------</span></td></tr>
</table></pre><pre>4 files changed, 31 insertions(+), 34 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a> b/<a href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -24,8 +24,8 @@ pub(super) fn fold_constants(node: Node) -&gt; Result&lt;Node&gt; {
</a> 
     // Transforms expressions.
     let transform = |expr: Expression| {
<a href="#h0-0-3" id="h0-0-3" class="d">-        // If the expression is constant, evaulate it.
</a><a href="#h0-0-4" id="h0-0-4" class="d">-        if !expr.contains(&amp;|e| matches!(e, Expression::Field(_, _))) {
</a><a href="#h0-0-5" id="h0-0-5" class="i">+        // If the expression is constant, evaluate it.
</a><a href="#h0-0-6" id="h0-0-6" class="i">+        if !expr.contains(&amp;|e| matches!(e, Expression::Field(_))) {
</a>             return expr.evaluate(None).map(Expression::Constant);
         }
         // If the expression is a logical operator, and one of the sides is
<a href="#h0-1" id="h0-1" class="h">@@ -123,7 +123,7 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         for expr in cnf {
             let (mut ref_left, mut ref_right) = (false, false);
             expr.walk(&amp;mut |e| {
<a href="#h0-1-3" id="h0-1-3" class="d">-                if let Expression::Field(index, _) = e {
</a><a href="#h0-1-4" id="h0-1-4" class="i">+                if let Expression::Field(index) = e {
</a>                     ref_left = ref_left || *index &lt; left.size();
                     ref_right = ref_right || *index &gt;= left.size();
                 }
<a href="#h0-2" id="h0-2" class="h">@@ -160,19 +160,18 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         for expr in &amp;predicate {
             // Find equijoins.
             let Expression::Equal(lhs, rhs) = expr else { continue };
<a href="#h0-2-3" id="h0-2-3" class="d">-            let Expression::Field(l, lname) = lhs.as_ref() else { continue };
</a><a href="#h0-2-4" id="h0-2-4" class="d">-            let Expression::Field(r, rname) = rhs.as_ref() else { continue };
</a><a href="#h0-2-5" id="h0-2-5" class="i">+            let Expression::Field(l) = lhs.as_ref() else { continue };
</a><a href="#h0-2-6" id="h0-2-6" class="i">+            let Expression::Field(r) = rhs.as_ref() else { continue };
</a> 
             // The lhs may be a reference to the right source; swap them.
<a href="#h0-2-9" id="h0-2-9" class="d">-            let (l, lname, r, rname) =
</a><a href="#h0-2-10" id="h0-2-10" class="d">-                if l &gt; r { (r, rname, l, lname) } else { (l, lname, r, rname) };
</a><a href="#h0-2-11" id="h0-2-11" class="i">+            let (l, r) = if l &gt; r { (r, l) } else { (l, r) };
</a> 
             // Check if either side is a field lookup, and copy it over.
             if let Some(expr) = left_lookups.get(l).map(|i| push_left[*i].clone()) {
<a href="#h0-2-15" id="h0-2-15" class="d">-                push_right.push(expr.replace_field(*l, *r, rname));
</a><a href="#h0-2-16" id="h0-2-16" class="i">+                push_right.push(expr.replace_field(*l, *r));
</a>             }
             if let Some(expr) = right_lookups.get(r).map(|i| push_right[*i].clone()) {
<a href="#h0-2-19" id="h0-2-19" class="d">-                push_left.push(expr.replace_field(*r, *l, lname));
</a><a href="#h0-2-20" id="h0-2-20" class="i">+                push_left.push(expr.replace_field(*r, *l));
</a>             }
         }
 
<a href="#h0-3" id="h0-3" class="h">@@ -260,7 +259,7 @@ pub(super) fn join_type(node: Node) -&gt; Result&lt;Node&gt; {
</a>             predicate: Some(Expression::Equal(lhs, rhs)),
             outer,
         } =&gt; match (*lhs, *rhs) {
<a href="#h0-3-3" id="h0-3-3" class="d">-            (Expression::Field(mut left_field, _), Expression::Field(mut right_field, _)) =&gt; {
</a><a href="#h0-3-4" id="h0-3-4" class="i">+            (Expression::Field(mut left_field), Expression::Field(mut right_field)) =&gt; {
</a>                 // The LHS field may be a field in the right table; swap them.
                 if right_field &lt; left_field {
                     (left_field, right_field) = (right_field, left_field);
<a href="#h0-4" id="h0-4" class="h">@@ -343,7 +342,7 @@ pub(super) fn short_circuit(node: Node) -&gt; Result&lt;Node&gt; {
</a>                 &amp;&amp; expressions
                     .iter()
                     .enumerate()
<a href="#h0-4-3" id="h0-4-3" class="d">-                    .all(|(i, e)| matches!(e, Expression::Field(f, _) if i == *f)) =&gt;
</a><a href="#h0-4-4" id="h0-4-4" class="i">+                    .all(|(i, e)| matches!(e, Expression::Field(f) if i == *f)) =&gt;
</a>         {
             *source
         }
<b>diff --git a/<a id="h1" href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a> b/<a href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -279,13 +279,13 @@ impl Node {
</a>             // Some nodes rearrange columns. Route them to the correct
             // upstream column where appropriate.
             Self::Aggregate { source, group_by, .. } =&gt; match group_by.get(index) {
<a href="#h1-0-3" id="h1-0-3" class="d">-                Some(Expression::Field(index, _)) =&gt; source.column_label(*index),
</a><a href="#h1-0-4" id="h1-0-4" class="i">+                Some(Expression::Field(index)) =&gt; source.column_label(*index),
</a>                 Some(_) | None =&gt; Label::None,
             },
             Self::Projection { source, expressions, aliases } =&gt; match aliases.get(index) {
                 Some(Label::None) | None =&gt; match expressions.get(index) {
                     // Unaliased field references route to the source.
<a href="#h1-0-10" id="h1-0-10" class="d">-                    Some(Expression::Field(index, _)) =&gt; source.column_label(*index),
</a><a href="#h1-0-11" id="h1-0-11" class="i">+                    Some(Expression::Field(index)) =&gt; source.column_label(*index),
</a>                     // Unaliased expressions don&#39;t have a name.
                     Some(_) | None =&gt; Label::None,
                 },
<b>diff --git a/<a id="h2" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -440,7 +440,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 if let Some(index) = scope.lookup_aggregate(expr) {
                     if child_scope.lookup_aggregate(expr).is_none() {
                         child_scope.add_passthrough(scope, index, true);
<a href="#h2-0-3" id="h2-0-3" class="d">-                        hidden.push(Expression::Field(index, scope.get_label(index)));
</a><a href="#h2-0-4" id="h2-0-4" class="i">+                        hidden.push(Expression::Field(index));
</a>                         return true;
                     }
                 }
<a href="#h2-1" id="h2-1" class="h">@@ -459,7 +459,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 };
                 // Add the hidden column to the projection.
                 child_scope.add_passthrough(scope, index, true);
<a href="#h2-1-3" id="h2-1-3" class="d">-                hidden.push(Expression::Field(index, scope.get_label(index)));
</a><a href="#h2-1-4" id="h2-1-4" class="i">+                hidden.push(Expression::Field(index));
</a>                 true
             });
         }
<a href="#h2-2" id="h2-2" class="h">@@ -473,7 +473,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         // Look up aggregate functions or GROUP BY expressions. These were added
         // to the parent scope when building the Aggregate node, if any.
         if let Some(index) = scope.lookup_aggregate(&amp;expr) {
<a href="#h2-2-3" id="h2-2-3" class="d">-            return Ok(Field(index, scope.get_label(index)));
</a><a href="#h2-2-4" id="h2-2-4" class="i">+            return Ok(Field(index));
</a>         }
 
         // Helper for building a boxed expression.
<a href="#h2-3" id="h2-3" class="h">@@ -490,8 +490,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 ast::Literal::String(s) =&gt; Value::String(s),
             }),
             ast::Expression::Field(table, name) =&gt; {
<a href="#h2-3-3" id="h2-3-3" class="d">-                let index = scope.lookup_column(table.as_deref(), &amp;name)?;
</a><a href="#h2-3-4" id="h2-3-4" class="d">-                Field(index, scope.get_label(index))
</a><a href="#h2-3-5" id="h2-3-5" class="i">+                Field(scope.lookup_column(table.as_deref(), &amp;name)?)
</a>             }
             // Currently, all functions are aggregates, and processed above.
             // TODO: consider adding some basic functions for fun.
<b>diff --git a/<a id="h3" href="../file/src/sql/types/expression.rs.html">src/sql/types/expression.rs</a> b/<a href="../file/src/sql/types/expression.rs.html">src/sql/types/expression.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -15,9 +15,8 @@ use serde::{Deserialize, Serialize};
</a> pub enum Expression {
     /// A constant value.
     Constant(Value),
<a href="#h3-0-3" id="h3-0-3" class="d">-    /// A field reference (row index) with optional label. The label is only
</a><a href="#h3-0-4" id="h3-0-4" class="d">-    /// used for display purposes.
</a><a href="#h3-0-5" id="h3-0-5" class="d">-    Field(usize, Label),
</a><a href="#h3-0-6" id="h3-0-6" class="i">+    /// A field reference (row index).
</a><a href="#h3-0-7" id="h3-0-7" class="i">+    Field(usize),
</a> 
     /// Logical AND of two booleans: a AND b.
     And(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
<a href="#h3-1" id="h3-1" class="h">@@ -65,7 +64,7 @@ impl Expression {
</a>     pub fn format(&amp;self, node: &amp;Node) -&gt; String {
         let format = |expr: &amp;Expression| expr.format(node);
         match self {
<a href="#h3-1-3" id="h3-1-3" class="d">-            Self::Field(index, _) =&gt; match node.column_label(*index) {
</a><a href="#h3-1-4" id="h3-1-4" class="i">+            Self::Field(index) =&gt; match node.column_label(*index) {
</a>                 Label::None =&gt; format!(&quot;#{index}&quot;),
                 label =&gt; format!(&quot;{label}&quot;),
             },
<a href="#h3-2" id="h3-2" class="h">@@ -106,7 +105,7 @@ impl Expression {
</a> 
             // Field references look up a row value. The planner must make sure
             // the field reference is valid.
<a href="#h3-2-3" id="h3-2-3" class="d">-            Self::Field(i, _) =&gt; row.map(|row| row[*i].clone()).unwrap_or(Null),
</a><a href="#h3-2-4" id="h3-2-4" class="i">+            Self::Field(i) =&gt; row.map(|row| row[*i].clone()).unwrap_or(Null),
</a> 
             // Logical AND. Inputs must be boolean or NULL. NULLs generally
             // yield NULL, except the special case NULL AND false == false.
<a href="#h3-3" id="h3-3" class="h">@@ -243,7 +242,7 @@ impl Expression {
</a>                 | Self::Negate(expr)
                 | Self::Not(expr) =&gt; expr.walk(visitor),
 
<a href="#h3-3-3" id="h3-3-3" class="d">-                Self::Constant(_) | Self::Field(_, _) =&gt; true,
</a><a href="#h3-3-4" id="h3-3-4" class="i">+                Self::Constant(_) | Self::Field(_) =&gt; true,
</a>             }
     }
 
<a href="#h3-4" id="h3-4" class="h">@@ -289,7 +288,7 @@ impl Expression {
</a>             Self::Negate(expr) =&gt; Self::Negate(transform(expr)?),
             Self::Not(expr) =&gt; Self::Not(transform(expr)?),
 
<a href="#h3-4-3" id="h3-4-3" class="d">-            expr @ (Self::Constant(_) | Self::Field(_, _)) =&gt; expr,
</a><a href="#h3-4-4" id="h3-4-4" class="i">+            expr @ (Self::Constant(_) | Self::Field(_)) =&gt; expr,
</a>         };
         self = after(self)?;
         Ok(self)
<a href="#h3-5" id="h3-5" class="h">@@ -371,12 +370,12 @@ impl Expression {
</a>             // use index lookups. NULL and NaN won&#39;t return any matches, but we
             // handle this in into_field_values().
             Equal(lhs, rhs) =&gt; match (lhs.as_ref(), rhs.as_ref()) {
<a href="#h3-5-3" id="h3-5-3" class="d">-                (Field(f, _), Constant(_)) | (Constant(_), Field(f, _)) =&gt; Some(*f),
</a><a href="#h3-5-4" id="h3-5-4" class="i">+                (Field(f), Constant(_)) | (Constant(_), Field(f)) =&gt; Some(*f),
</a>                 _ =&gt; None,
             },
             // IS NULL and IS NAN can use index lookups, since we index these.
             IsNull(expr) | IsNaN(expr) =&gt; match expr.as_ref() {
<a href="#h3-5-9" id="h3-5-9" class="d">-                Field(f, _) =&gt; Some(*f),
</a><a href="#h3-5-10" id="h3-5-10" class="i">+                Field(f) =&gt; Some(*f),
</a>                 _ =&gt; None,
             },
             // For OR branches, check if all branches are lookups on the same
<a href="#h3-6" id="h3-6" class="h">@@ -397,20 +396,20 @@ impl Expression {
</a>                 // NULL and NAN index lookups are for IS NULL and IS NAN.
                 // Equality comparisons with = shouldn&#39;t yield any results, so
                 // just return an empty value set for these.
<a href="#h3-6-3" id="h3-6-3" class="d">-                (Field(f, _), Constant(v)) | (Constant(v), Field(f, _)) if v.is_undefined() =&gt; {
</a><a href="#h3-6-4" id="h3-6-4" class="i">+                (Field(f), Constant(v)) | (Constant(v), Field(f)) if v.is_undefined() =&gt; {
</a>                     Some((f, Vec::new()))
                 }
<a href="#h3-6-7" id="h3-6-7" class="d">-                (Field(f, _), Constant(v)) | (Constant(v), Field(f, _)) =&gt; Some((f, vec![v])),
</a><a href="#h3-6-8" id="h3-6-8" class="i">+                (Field(f), Constant(v)) | (Constant(v), Field(f)) =&gt; Some((f, vec![v])),
</a>                 _ =&gt; None,
             },
             // IS NULL index lookups should look up NULL.
             IsNull(expr) =&gt; match *expr {
<a href="#h3-6-13" id="h3-6-13" class="d">-                Field(f, _) =&gt; Some((f, vec![Value::Null])),
</a><a href="#h3-6-14" id="h3-6-14" class="i">+                Field(f) =&gt; Some((f, vec![Value::Null])),
</a>                 _ =&gt; None,
             },
             // IS NAN index lookups should look up NAN.
             IsNaN(expr) =&gt; match *expr {
<a href="#h3-6-19" id="h3-6-19" class="d">-                Field(f, _) =&gt; Some((f, vec![Value::Float(f64::NAN)])),
</a><a href="#h3-6-20" id="h3-6-20" class="i">+                Field(f) =&gt; Some((f, vec![Value::Float(f64::NAN)])),
</a>                 _ =&gt; None,
             },
             Or(lhs, rhs) =&gt; match (lhs.into_field_values(), rhs.into_field_values()) {
<a href="#h3-7" id="h3-7" class="h">@@ -424,9 +423,9 @@ impl Expression {
</a>     }
 
     /// Replaces field references with the given field.
<a href="#h3-7-3" id="h3-7-3" class="d">-    pub fn replace_field(self, from: usize, to: usize, label: &amp;Label) -&gt; Self {
</a><a href="#h3-7-4" id="h3-7-4" class="i">+    pub fn replace_field(self, from: usize, to: usize) -&gt; Self {
</a>         let transform = |expr| match expr {
<a href="#h3-7-6" id="h3-7-6" class="d">-            Expression::Field(i, _) if i == from =&gt; Expression::Field(to, label.clone()),
</a><a href="#h3-7-7" id="h3-7-7" class="i">+            Expression::Field(i) if i == from =&gt; Expression::Field(to),
</a>             expr =&gt; expr,
         };
         self.transform(&amp;|e| Ok(transform(e)), &amp;Ok).unwrap() // infallible
<a href="#h3-8" id="h3-8" class="h">@@ -435,7 +434,7 @@ impl Expression {
</a>     /// Shifts any field indexes by the given amount.
     pub fn shift_field(self, diff: isize) -&gt; Self {
         let transform = |expr| match expr {
<a href="#h3-8-3" id="h3-8-3" class="d">-            Expression::Field(i, label) =&gt; Expression::Field((i as isize + diff) as usize, label),
</a><a href="#h3-8-4" id="h3-8-4" class="i">+            Expression::Field(i) =&gt; Expression::Field((i as isize + diff) as usize),
</a>             expr =&gt; expr,
         };
         self.transform(&amp;|e| Ok(transform(e)), &amp;Ok).unwrap() // infallible
</pre>
</div>
</body>
</html>
