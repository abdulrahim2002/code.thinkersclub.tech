<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: fix SELECT * with aggregate queries - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/7ec20fb8f85147da66bf9df6776b0cc83879d9a2.html">7ec20fb8f85147da66bf9df6776b0cc83879d9a2</a>
<b>parent</b> <a href="../commit/87234b2b325879c3af70f0e981568b69e910d805.html">87234b2b325879c3af70f0e981568b69e910d805</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Mon, 15 Jul 2024 14:28:12 +0200

sql: fix SELECT * with aggregate queries

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">38</td><td><span class="i">++++++++++++++++++++++++</span><span class="d">--------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/testscripts/queries/group_by</a></td><td> | </td><td class="num">30</td><td><span class="i">++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/testscripts/queries/select</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
</table></pre><pre>4 files changed, 57 insertions(+), 21 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -229,13 +229,9 @@ impl Expression {
</a> 
     /// Find and collects expressions for which the given closure returns true,
     /// adding them to c. Does not recurse into matching expressions.
<a href="#h0-0-3" id="h0-0-3" class="d">-    pub fn collect&lt;&#39;a&gt;(
</a><a href="#h0-0-4" id="h0-0-4" class="d">-        &amp;&#39;a self,
</a><a href="#h0-0-5" id="h0-0-5" class="d">-        visitor: &amp;impl Fn(&amp;Expression) -&gt; bool,
</a><a href="#h0-0-6" id="h0-0-6" class="d">-        c: &amp;mut Vec&lt;&amp;&#39;a Expression&gt;,
</a><a href="#h0-0-7" id="h0-0-7" class="d">-    ) {
</a><a href="#h0-0-8" id="h0-0-8" class="i">+    pub fn collect(&amp;self, visitor: &amp;impl Fn(&amp;Expression) -&gt; bool, c: &amp;mut Vec&lt;Expression&gt;) {
</a>         if visitor(self) {
<a href="#h0-0-10" id="h0-0-10" class="d">-            c.push(self);
</a><a href="#h0-0-11" id="h0-0-11" class="i">+            c.push(self.clone());
</a>             return;
         }
         use Operator::*;
<b>diff --git a/<a id="h1" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -148,7 +148,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     #[allow(clippy::too_many_arguments)]
     fn build_select(
         &amp;self,
<a href="#h1-0-3" id="h1-0-3" class="d">-        select: Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h1-0-4" id="h1-0-4" class="i">+        mut select: Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a>         from: Vec&lt;ast::From&gt;,
         r#where: Option&lt;ast::Expression&gt;,
         group_by: Vec&lt;ast::Expression&gt;,
<a href="#h1-1" id="h1-1" class="h">@@ -163,7 +163,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         let mut node = if !from.is_empty() {
             self.build_from_clause(&amp;mut scope, from)?
         } else if select.is_empty() {
<a href="#h1-1-3" id="h1-1-3" class="d">-            return errinput!(&quot;can&#39;t select * without a table&quot;);
</a><a href="#h1-1-4" id="h1-1-4" class="i">+            return errinput!(&quot;SELECT * requires a FROM clause&quot;);
</a>         } else {
             // For a constant SELECT, emit a single empty row to project. This
             // allows using both a WHERE predicate and aggregate functions.
<a href="#h1-2" id="h1-2" class="h">@@ -179,6 +179,19 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         // Build aggregate functions and GROUP BY clause.
         let aggregates = Self::collect_aggregates(&amp;select, &amp;having, &amp;order);
         if !group_by.is_empty() || !aggregates.is_empty() {
<a href="#h1-2-3" id="h1-2-3" class="i">+            // If there is a SELECT * clause, specify explicit columns. This
</a><a href="#h1-2-4" id="h1-2-4" class="i">+            // ensures that the columns must be used in GROUP BY as well.
</a><a href="#h1-2-5" id="h1-2-5" class="i">+            // TODO: consider improving this.
</a><a href="#h1-2-6" id="h1-2-6" class="i">+            if select.is_empty() {
</a><a href="#h1-2-7" id="h1-2-7" class="i">+                for index in 0..node.size() {
</a><a href="#h1-2-8" id="h1-2-8" class="i">+                    let (table, column) = match scope.get_column_label(index)? {
</a><a href="#h1-2-9" id="h1-2-9" class="i">+                        Label::Qualified(table, column) =&gt; (Some(table), column),
</a><a href="#h1-2-10" id="h1-2-10" class="i">+                        Label::Unqualified(column) =&gt; (None, column),
</a><a href="#h1-2-11" id="h1-2-11" class="i">+                        Label::None =&gt; panic!(&quot;FROM clause must produce labels&quot;),
</a><a href="#h1-2-12" id="h1-2-12" class="i">+                    };
</a><a href="#h1-2-13" id="h1-2-13" class="i">+                    select.push((ast::Expression::Field(table, column), None));
</a><a href="#h1-2-14" id="h1-2-14" class="i">+                }
</a><a href="#h1-2-15" id="h1-2-15" class="i">+            }
</a>             node = self.build_aggregate(&amp;mut scope, node, group_by, aggregates)?;
         }
 
<a href="#h1-3" id="h1-3" class="h">@@ -344,15 +357,12 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     /// can look up the column index of aggregate expressions via Scope.
     /// Similarly, they are allowed to reference GROUP BY expressions by
     /// specifying the exact same expression.
<a href="#h1-3-3" id="h1-3-3" class="d">-    ///
</a><a href="#h1-3-4" id="h1-3-4" class="d">-    /// TODO: consider avoiding the expr cloning by taking &amp;Expression in
</a><a href="#h1-3-5" id="h1-3-5" class="d">-    /// various places.
</a>     fn build_aggregate(
         &amp;self,
         scope: &amp;mut Scope,
         source: Node,
         group_by: Vec&lt;ast::Expression&gt;,
<a href="#h1-3-11" id="h1-3-11" class="d">-        aggregates: Vec&lt;&amp;ast::Expression&gt;,
</a><a href="#h1-3-12" id="h1-3-12" class="i">+        aggregates: Vec&lt;ast::Expression&gt;,
</a>     ) -&gt; Result&lt;Node&gt; {
         // Construct a child scope with the group_by and aggregate AST
         // expressions, such that downstream nodes can identify and reference
<a href="#h1-4" id="h1-4" class="h">@@ -377,11 +387,11 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             .collect_vec();
         let aggregates = aggregates
             .into_iter()
<a href="#h1-4-3" id="h1-4-3" class="d">-            .filter(|&amp;expr| {
</a><a href="#h1-4-4" id="h1-4-4" class="i">+            .filter(|expr| {
</a>                 if child_scope.lookup_aggregate(expr).is_some() {
                     return false;
                 }
<a href="#h1-4-8" id="h1-4-8" class="d">-                child_scope.add_aggregate((expr).clone(), Label::None);
</a><a href="#h1-4-9" id="h1-4-9" class="i">+                child_scope.add_aggregate(expr.clone(), Label::None);
</a>                 true
             })
             .collect_vec();
<a href="#h1-5" id="h1-5" class="h">@@ -393,7 +403,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             .collect::&lt;Result&lt;_&gt;&gt;()?;
         let aggregates = aggregates
             .into_iter()
<a href="#h1-5-3" id="h1-5-3" class="d">-            .map(|expr| Self::build_aggregate_function(scope, expr.clone()))
</a><a href="#h1-5-4" id="h1-5-4" class="i">+            .map(|expr| Self::build_aggregate_function(scope, expr))
</a>             .collect::&lt;Result&lt;_&gt;&gt;()?;
 
         *scope = child_scope;
<a href="#h1-6" id="h1-6" class="h">@@ -432,11 +442,11 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     }
 
     /// Collects aggregate functions from SELECT, HAVING, and ORDER BY clauses.
<a href="#h1-6-3" id="h1-6-3" class="d">-    fn collect_aggregates&lt;&#39;c&gt;(
</a><a href="#h1-6-4" id="h1-6-4" class="d">-        select: &amp;&#39;c [(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h1-6-5" id="h1-6-5" class="d">-        having: &amp;&#39;c Option&lt;ast::Expression&gt;,
</a><a href="#h1-6-6" id="h1-6-6" class="d">-        order_by: &amp;&#39;c [(ast::Expression, ast::Order)],
</a><a href="#h1-6-7" id="h1-6-7" class="d">-    ) -&gt; Vec&lt;&amp;&#39;c ast::Expression&gt; {
</a><a href="#h1-6-8" id="h1-6-8" class="i">+    fn collect_aggregates(
</a><a href="#h1-6-9" id="h1-6-9" class="i">+        select: &amp;[(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h1-6-10" id="h1-6-10" class="i">+        having: &amp;Option&lt;ast::Expression&gt;,
</a><a href="#h1-6-11" id="h1-6-11" class="i">+        order_by: &amp;[(ast::Expression, ast::Order)],
</a><a href="#h1-6-12" id="h1-6-12" class="i">+    ) -&gt; Vec&lt;ast::Expression&gt; {
</a>         let select = select.iter().map(|(expr, _)| expr);
         let having = having.iter();
         let order_by = order_by.iter().map(|(expr, _)| expr);
<b>diff --git a/<a id="h2" href="../file/src/sql/testscripts/queries/group_by.html">src/sql/testscripts/queries/group_by</a> b/<a href="../file/src/sql/testscripts/queries/group_by.html">src/sql/testscripts/queries/group_by</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -190,3 +190,33 @@ Aggregate: count(TRUE) group by t.id % 2
</a>    ├─ Scan: test as t
    └─ Scan: other as o
 1, 3
<a href="#h2-0-3" id="h2-0-3" class="i">+
</a><a href="#h2-0-4" id="h2-0-4" class="i">+# SELECT * requires all columns to be in GROUP BY.
</a><a href="#h2-0-5" id="h2-0-5" class="i">+!&gt; SELECT * FROM test GROUP BY id
</a><a href="#h2-0-6" id="h2-0-6" class="i">+---
</a><a href="#h2-0-7" id="h2-0-7" class="i">+Error: invalid input: field test.group must be used in an aggregate or GROUP BY expression
</a><a href="#h2-0-8" id="h2-0-8" class="i">+
</a><a href="#h2-0-9" id="h2-0-9" class="i">+[plan]&gt; SELECT * FROM test GROUP BY id, &quot;group&quot;, &quot;bool&quot;, &quot;int&quot;, &quot;float&quot;, &quot;string&quot;
</a><a href="#h2-0-10" id="h2-0-10" class="i">+---
</a><a href="#h2-0-11" id="h2-0-11" class="i">+Aggregate:  group by id, group, bool, int, float, string
</a><a href="#h2-0-12" id="h2-0-12" class="i">+└─ Scan: test
</a><a href="#h2-0-13" id="h2-0-13" class="i">+0, NULL, NULL, NULL, NULL, NULL
</a><a href="#h2-0-14" id="h2-0-14" class="i">+1, a, TRUE, -1, 3.14, 
</a><a href="#h2-0-15" id="h2-0-15" class="i">+2, b, FALSE, 0, NaN, abc
</a><a href="#h2-0-16" id="h2-0-16" class="i">+3, a, TRUE, 3, 0, AB
</a><a href="#h2-0-17" id="h2-0-17" class="i">+4, b, TRUE, 42, inf, 👋
</a><a href="#h2-0-18" id="h2-0-18" class="i">+5, a, FALSE, 7, NaN, 
</a><a href="#h2-0-19" id="h2-0-19" class="i">+6, b, FALSE, -1, 0, abc
</a><a href="#h2-0-20" id="h2-0-20" class="i">+
</a><a href="#h2-0-21" id="h2-0-21" class="i">+[plan]&gt; SELECT * FROM test GROUP BY &quot;bool&quot;, &quot;int&quot;, &quot;float&quot;, &quot;string&quot;, &quot;group&quot;, id
</a><a href="#h2-0-22" id="h2-0-22" class="i">+---
</a><a href="#h2-0-23" id="h2-0-23" class="i">+Projection: test.id, test.group, test.bool, test.int, test.float, test.string
</a><a href="#h2-0-24" id="h2-0-24" class="i">+└─ Aggregate:  group by bool, int, float, string, group, id
</a><a href="#h2-0-25" id="h2-0-25" class="i">+   └─ Scan: test
</a><a href="#h2-0-26" id="h2-0-26" class="i">+0, NULL, NULL, NULL, NULL, NULL
</a><a href="#h2-0-27" id="h2-0-27" class="i">+6, b, FALSE, -1, 0, abc
</a><a href="#h2-0-28" id="h2-0-28" class="i">+2, b, FALSE, 0, NaN, abc
</a><a href="#h2-0-29" id="h2-0-29" class="i">+5, a, FALSE, 7, NaN, 
</a><a href="#h2-0-30" id="h2-0-30" class="i">+1, a, TRUE, -1, 3.14, 
</a><a href="#h2-0-31" id="h2-0-31" class="i">+3, a, TRUE, 3, 0, AB
</a><a href="#h2-0-32" id="h2-0-32" class="i">+4, b, TRUE, 42, inf, 👋
</a><b>diff --git a/<a id="h3" href="../file/src/sql/testscripts/queries/select.html">src/sql/testscripts/queries/select</a> b/<a href="../file/src/sql/testscripts/queries/select.html">src/sql/testscripts/queries/select</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -61,7 +61,7 @@ NULL
</a> !&gt; SELECT *
 !&gt; SELECT * FROM
 ---
<a href="#h3-0-3" id="h3-0-3" class="d">-Error: invalid input: can&#39;t select * without a table
</a><a href="#h3-0-4" id="h3-0-4" class="i">+Error: invalid input: SELECT * requires a FROM clause
</a> Error: invalid input: unexpected end of input
 
 # Mix fields, field expressions, and constant expressions.
</pre>
</div>
</body>
</html>
