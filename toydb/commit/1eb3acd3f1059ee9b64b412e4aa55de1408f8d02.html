<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>raft: track writes on leader - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/1eb3acd3f1059ee9b64b412e4aa55de1408f8d02.html">1eb3acd3f1059ee9b64b412e4aa55de1408f8d02</a>
<b>parent</b> <a href="../commit/87905721fd6b7027bc42a619495a97f8131299a8.html">87905721fd6b7027bc42a619495a97f8131299a8</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 19 Nov 2023 21:03:06 +0100

raft: track writes on leader

This is in preparation for moving state machine application into the
Raft node. For now, it only tracks the writes, without actually
responding to clients when applied.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/node/leader.rs</a></td><td> | </td><td class="num">41</td><td><span class="i">+++++++++++++++++++++++++++++++++++++</span><span class="d">----</span></td></tr>
</table></pre><pre>1 file changed, 37 insertions(+), 4 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -1,6 +1,6 @@
</a><a href="#h0-0-0" id="h0-0-0" class="d">-use super::super::{Address, Event, Index, Instruction, Message, Request, Status};
</a><a href="#h0-0-1" id="h0-0-1" class="i">+use super::super::{Address, Event, Index, Instruction, Message, Request, RequestID, Status};
</a> use super::{Follower, Node, NodeID, RawNode, Role, Term, Ticks, HEARTBEAT_INTERVAL};
<a href="#h0-0-3" id="h0-0-3" class="d">-use crate::error::Result;
</a><a href="#h0-0-4" id="h0-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 use ::log::{debug, info};
 use std::collections::{HashMap, HashSet};
<a href="#h0-1" id="h0-1" class="h">@@ -14,11 +14,30 @@ struct Progress {
</a>     last: Index,
 }
 
<a href="#h0-1-3" id="h0-1-3" class="i">+/// A pending client write request.
</a><a href="#h0-1-4" id="h0-1-4" class="i">+#[derive(Clone, Debug, PartialEq)]
</a><a href="#h0-1-5" id="h0-1-5" class="i">+struct Write {
</a><a href="#h0-1-6" id="h0-1-6" class="i">+    /// The client or node which submitted the write.
</a><a href="#h0-1-7" id="h0-1-7" class="i">+    from: Address,
</a><a href="#h0-1-8" id="h0-1-8" class="i">+    /// The write request ID.
</a><a href="#h0-1-9" id="h0-1-9" class="i">+    id: RequestID,
</a><a href="#h0-1-10" id="h0-1-10" class="i">+}
</a><a href="#h0-1-11" id="h0-1-11" class="i">+
</a> // A leader serves requests and replicates the log to followers.
 #[derive(Clone, Debug, PartialEq)]
 pub struct Leader {
     /// Peer replication progress.
     progress: HashMap&lt;NodeID, Progress&gt;,
<a href="#h0-1-17" id="h0-1-17" class="i">+    /// Keeps track of pending write requests, keyed by log index. These are
</a><a href="#h0-1-18" id="h0-1-18" class="i">+    /// added when the write is proposed and appended to the leader&#39;s log, and
</a><a href="#h0-1-19" id="h0-1-19" class="i">+    /// removed when the command is applied to the state machine, sending the
</a><a href="#h0-1-20" id="h0-1-20" class="i">+    /// command result to the waiting client.
</a><a href="#h0-1-21" id="h0-1-21" class="i">+    ///
</a><a href="#h0-1-22" id="h0-1-22" class="i">+    /// If the leader loses leadership, all pending write requests are aborted
</a><a href="#h0-1-23" id="h0-1-23" class="i">+    /// by returning Error::Abort.
</a><a href="#h0-1-24" id="h0-1-24" class="i">+    ///
</a><a href="#h0-1-25" id="h0-1-25" class="i">+    /// TODO: Actually return responses when applied.
</a><a href="#h0-1-26" id="h0-1-26" class="i">+    writes: HashMap&lt;Index, Write&gt;,
</a>     /// Number of ticks since last periodic heartbeat.
     since_heartbeat: Ticks,
 }
<a href="#h0-2" id="h0-2" class="h">@@ -28,7 +47,7 @@ impl Leader {
</a>     pub fn new(peers: HashSet&lt;NodeID&gt;, last_index: Index) -&gt; Self {
         let next = last_index + 1;
         let progress = peers.into_iter().map(|p| (p, Progress { next, last: 0 })).collect();
<a href="#h0-2-3" id="h0-2-3" class="d">-        Self { progress, since_heartbeat: 0 }
</a><a href="#h0-2-4" id="h0-2-4" class="i">+        Self { progress, writes: HashMap::new(), since_heartbeat: 0 }
</a>     }
 }
 
<a href="#h0-3" id="h0-3" class="h">@@ -53,9 +72,18 @@ impl RawNode&lt;Leader&gt; {
</a>         assert!(term &gt; self.term, &quot;Can only become follower in later term&quot;);
 
         info!(&quot;Discovered new term {}&quot;, term);
<a href="#h0-3-3" id="h0-3-3" class="i">+
</a><a href="#h0-3-4" id="h0-3-4" class="i">+        // Cancel in-flight requests.
</a><a href="#h0-3-5" id="h0-3-5" class="i">+        self.state_tx.send(Instruction::Abort)?;
</a><a href="#h0-3-6" id="h0-3-6" class="i">+        for write in std::mem::take(&amp;mut self.role.writes).into_values() {
</a><a href="#h0-3-7" id="h0-3-7" class="i">+            self.send(
</a><a href="#h0-3-8" id="h0-3-8" class="i">+                write.from,
</a><a href="#h0-3-9" id="h0-3-9" class="i">+                Event::ClientResponse { id: write.id, response: Err(Error::Abort) },
</a><a href="#h0-3-10" id="h0-3-10" class="i">+            )?;
</a><a href="#h0-3-11" id="h0-3-11" class="i">+        }
</a><a href="#h0-3-12" id="h0-3-12" class="i">+
</a>         self.term = term;
         self.log.set_term(term, None)?;
<a href="#h0-3-15" id="h0-3-15" class="d">-        self.state_tx.send(Instruction::Abort)?;
</a>         Ok(self.into_role(Follower::new(None, None)))
     }
 
<a href="#h0-4" id="h0-4" class="h">@@ -149,8 +177,11 @@ impl RawNode&lt;Leader&gt; {
</a>                 self.heartbeat()?;
             }
 
<a href="#h0-4-3" id="h0-4-3" class="i">+            // A client submitted a write command. Propose it, and track it
</a><a href="#h0-4-4" id="h0-4-4" class="i">+            // until it&#39;s applied and the response is returned to the client.
</a>             Event::ClientRequest { id, request: Request::Mutate(command) } =&gt; {
                 let index = self.propose(Some(command))?;
<a href="#h0-4-7" id="h0-4-7" class="i">+                self.role.writes.insert(index, Write { from: msg.from, id: id.clone() });
</a>                 self.state_tx.send(Instruction::Notify { id, address: msg.from, index })?;
                 if self.peers.is_empty() {
                     self.maybe_commit()?;
<a href="#h0-5" id="h0-5" class="h">@@ -261,6 +292,8 @@ impl RawNode&lt;Leader&gt; {
</a>             // TODO: Move application elsewhere, but needs access to applied index.
             let mut scan = self.log.scan((prev_commit_index + 1)..=commit_index)?;
             while let Some(entry) = scan.next().transpose()? {
<a href="#h0-5-3" id="h0-5-3" class="i">+                // TODO: Send response.
</a><a href="#h0-5-4" id="h0-5-4" class="i">+                self.role.writes.remove(&amp;entry.index);
</a>                 self.state_tx.send(Instruction::Apply { entry })?;
             }
         }
</pre>
</div>
</body>
</html>
