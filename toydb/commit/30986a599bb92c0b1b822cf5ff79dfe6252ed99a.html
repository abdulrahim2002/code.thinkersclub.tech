<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fix Raft term changes. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/30986a599bb92c0b1b822cf5ff79dfe6252ed99a.html">30986a599bb92c0b1b822cf5ff79dfe6252ed99a</a>
<b>parent</b> <a href="../commit/d2b1a79f2d0205902f2f01abee61d7bebf50257a.html">d2b1a79f2d0205902f2f01abee61d7bebf50257a</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 19 Nov 2023 12:44:36 +0100

Fix Raft term changes.

This patch improves Raft term changes, by becoming a leaderless follower
for new terms, and tracking voted_for properly for candidates and
leaders.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/message.rs</a></td><td> | </td><td class="num">13</td><td><span class="i">++++++++++++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">64</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/node/follower.rs</a></td><td> | </td><td class="num">153</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-----------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/node/leader.rs</a></td><td> | </td><td class="num">72</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d">--------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/node/mod.rs</a></td><td> | </td><td class="num">61</td><td><span class="i">+++++++++++++++++++++++++++++++++++</span><span class="d">--------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/raft/state.rs</a></td><td> | </td><td class="num">1</td><td><span class="i">+</span><span class="d"></span></td></tr>
</table></pre><pre>6 files changed, 231 insertions(+), 133 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/message.rs.html">src/raft/message.rs</a> b/<a href="../file/src/raft/message.rs.html">src/raft/message.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -11,10 +11,21 @@ pub enum Address {
</a>     /// A node with the specified node ID (local or remote). Valid both as
     /// sender and recipient.
     Node(NodeID),
<a href="#h0-0-3" id="h0-0-3" class="d">-    /// A local client.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+    /// A local client. Can only send ClientRequest messages, and receive
</a><a href="#h0-0-5" id="h0-0-5" class="i">+    /// ClientResponse messages.
</a>     Client,
 }
 
<a href="#h0-0-9" id="h0-0-9" class="i">+impl Address {
</a><a href="#h0-0-10" id="h0-0-10" class="i">+    /// Unwraps the node ID, or panics if address is not of kind Node.
</a><a href="#h0-0-11" id="h0-0-11" class="i">+    pub fn unwrap(&amp;self) -&gt; NodeID {
</a><a href="#h0-0-12" id="h0-0-12" class="i">+        match self {
</a><a href="#h0-0-13" id="h0-0-13" class="i">+            Self::Node(id) =&gt; *id,
</a><a href="#h0-0-14" id="h0-0-14" class="i">+            _ =&gt; panic!(&quot;unwrap called on non-Node address {:?}&quot;, self),
</a><a href="#h0-0-15" id="h0-0-15" class="i">+        }
</a><a href="#h0-0-16" id="h0-0-16" class="i">+    }
</a><a href="#h0-0-17" id="h0-0-17" class="i">+}
</a><a href="#h0-0-18" id="h0-0-18" class="i">+
</a> /// A message passed between Raft nodes.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub struct Message {
<b>diff --git a/<a id="h1" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -4,7 +4,7 @@ use super::{
</a> };
 use crate::error::{Error, Result};
 
<a href="#h1-0-3" id="h1-0-3" class="d">-use ::log::{debug, info, warn};
</a><a href="#h1-0-4" id="h1-0-4" class="i">+use ::log::{debug, error, info, warn};
</a> use rand::Rng as _;
 
 /// A candidate is campaigning to become a leader.
<a href="#h1-1" id="h1-1" class="h">@@ -31,12 +31,30 @@ impl Candidate {
</a> }
 
 impl RoleNode&lt;Candidate&gt; {
<a href="#h1-1-3" id="h1-1-3" class="d">-    /// Transition to follower role.
</a><a href="#h1-1-4" id="h1-1-4" class="d">-    fn become_follower(mut self, term: Term, leader: NodeID) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a><a href="#h1-1-5" id="h1-1-5" class="d">-        info!(&quot;Discovered leader {} for term {}, following&quot;, leader, term);
</a><a href="#h1-1-6" id="h1-1-6" class="d">-        self.term = term;
</a><a href="#h1-1-7" id="h1-1-7" class="d">-        self.log.set_term(term, None)?;
</a><a href="#h1-1-8" id="h1-1-8" class="d">-        let mut node = self.become_role(Follower::new(Some(leader), None))?;
</a><a href="#h1-1-9" id="h1-1-9" class="i">+    /// Transforms the node into a follower. We either lost the election
</a><a href="#h1-1-10" id="h1-1-10" class="i">+    /// and follow the winner, or we discovered a new term in which case
</a><a href="#h1-1-11" id="h1-1-11" class="i">+    /// we step into it as a leaderless follower.
</a><a href="#h1-1-12" id="h1-1-12" class="i">+    fn become_follower(mut self, term: Term, leader: Option&lt;NodeID&gt;) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a><a href="#h1-1-13" id="h1-1-13" class="i">+        assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
</a><a href="#h1-1-14" id="h1-1-14" class="i">+
</a><a href="#h1-1-15" id="h1-1-15" class="i">+        let mut node = if let Some(leader) = leader {
</a><a href="#h1-1-16" id="h1-1-16" class="i">+            // We lost the election, follow the winner.
</a><a href="#h1-1-17" id="h1-1-17" class="i">+            assert_eq!(term, self.term, &quot;Can&#39;t follow leader in different term&quot;);
</a><a href="#h1-1-18" id="h1-1-18" class="i">+            info!(&quot;Lost election, following leader {} in term {}&quot;, leader, term);
</a><a href="#h1-1-19" id="h1-1-19" class="i">+            let voted_for = Some(self.id); // by definition
</a><a href="#h1-1-20" id="h1-1-20" class="i">+            self.become_role(Follower::new(Some(leader), voted_for))
</a><a href="#h1-1-21" id="h1-1-21" class="i">+        } else {
</a><a href="#h1-1-22" id="h1-1-22" class="i">+            // We found a new term, but we don&#39;t necessarily know who the leader
</a><a href="#h1-1-23" id="h1-1-23" class="i">+            // is yet. We&#39;ll find out when we step a message from it.
</a><a href="#h1-1-24" id="h1-1-24" class="i">+            assert_ne!(term, self.term, &quot;Can&#39;t become leaderless follower in current term&quot;);
</a><a href="#h1-1-25" id="h1-1-25" class="i">+            info!(&quot;Discovered new term {}&quot;, term);
</a><a href="#h1-1-26" id="h1-1-26" class="i">+            self.term = term;
</a><a href="#h1-1-27" id="h1-1-27" class="i">+            self.log.set_term(term, None)?;
</a><a href="#h1-1-28" id="h1-1-28" class="i">+            self.become_role(Follower::new(None, None))
</a><a href="#h1-1-29" id="h1-1-29" class="i">+        };
</a><a href="#h1-1-30" id="h1-1-30" class="i">+        // Abort any proxied requests.
</a><a href="#h1-1-31" id="h1-1-31" class="i">+        //
</a><a href="#h1-1-32" id="h1-1-32" class="i">+        // TODO: Candidates shouldn&#39;t proxy requests.
</a>         node.abort_proxied()?;
         Ok(node)
     }
<a href="#h1-2" id="h1-2" class="h">@@ -47,7 +65,7 @@ impl RoleNode&lt;Candidate&gt; {
</a>         let peers = self.peers.clone();
         let (last_index, _) = self.log.get_last_index();
         let (commit_index, commit_term) = self.log.get_commit_index();
<a href="#h1-2-3" id="h1-2-3" class="d">-        let mut node = self.become_role(Leader::new(peers, last_index))?;
</a><a href="#h1-2-4" id="h1-2-4" class="i">+        let mut node = self.become_role(Leader::new(peers, last_index));
</a>         node.send(Address::Broadcast, Event::Heartbeat { commit_index, commit_term })?;
         node.append(None)?;
         node.abort_proxied()?;
<a href="#h1-3" id="h1-3" class="h">@@ -56,21 +74,29 @@ impl RoleNode&lt;Candidate&gt; {
</a> 
     /// Processes a message.
     pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
<a href="#h1-3-3" id="h1-3-3" class="i">+        // Drop invalid messages and messages from past terms.
</a>         if let Err(err) = self.validate(&amp;msg) {
<a href="#h1-3-5" id="h1-3-5" class="d">-            warn!(&quot;Ignoring invalid message: {}&quot;, err);
</a><a href="#h1-3-6" id="h1-3-6" class="i">+            error!(&quot;Invalid message: {} ({:?})&quot;, err, msg);
</a><a href="#h1-3-7" id="h1-3-7" class="i">+            return Ok(self.into());
</a><a href="#h1-3-8" id="h1-3-8" class="i">+        }
</a><a href="#h1-3-9" id="h1-3-9" class="i">+        if msg.term &lt; self.term &amp;&amp; msg.term &gt; 0 {
</a><a href="#h1-3-10" id="h1-3-10" class="i">+            debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
</a>             return Ok(self.into());
         }
<a href="#h1-3-13" id="h1-3-13" class="i">+
</a><a href="#h1-3-14" id="h1-3-14" class="i">+        // If we receive a message for a future term, become a leaderless
</a><a href="#h1-3-15" id="h1-3-15" class="i">+        // follower in it and step the message. If the message is a Heartbeat or
</a><a href="#h1-3-16" id="h1-3-16" class="i">+        // ReplicateEntries from the leader, stepping it will follow the leader.
</a>         if msg.term &gt; self.term {
<a href="#h1-3-18" id="h1-3-18" class="d">-            if let Address::Node(from) = msg.from {
</a><a href="#h1-3-19" id="h1-3-19" class="d">-                return self.become_follower(msg.term, from)?.step(msg);
</a><a href="#h1-3-20" id="h1-3-20" class="d">-            }
</a><a href="#h1-3-21" id="h1-3-21" class="i">+            return self.become_follower(msg.term, None)?.step(msg);
</a>         }
 
         match msg.event {
<a href="#h1-3-25" id="h1-3-25" class="d">-            Event::Heartbeat { .. } =&gt; {
</a><a href="#h1-3-26" id="h1-3-26" class="d">-                if let Address::Node(from) = msg.from {
</a><a href="#h1-3-27" id="h1-3-27" class="d">-                    return self.become_follower(msg.term, from)?.step(msg);
</a><a href="#h1-3-28" id="h1-3-28" class="d">-                }
</a><a href="#h1-3-29" id="h1-3-29" class="i">+            // If we receive a heartbeat or replicated entries in this term, we
</a><a href="#h1-3-30" id="h1-3-30" class="i">+            // lost the election and have a new leader. Follow it and process
</a><a href="#h1-3-31" id="h1-3-31" class="i">+            // the message.
</a><a href="#h1-3-32" id="h1-3-32" class="i">+            Event::Heartbeat { .. } | Event::ReplicateEntries { .. } =&gt; {
</a><a href="#h1-3-33" id="h1-3-33" class="i">+                return self.become_follower(msg.term, Some(msg.from.unwrap()))?.step(msg);
</a>             }
 
             Event::GrantVote =&gt; {
<a href="#h1-4" id="h1-4" class="h">@@ -97,8 +123,8 @@ impl RoleNode&lt;Candidate&gt; {
</a>             // Ignore other candidates when we&#39;re also campaigning
             Event::SolicitVote { .. } =&gt; {}
 
<a href="#h1-4-3" id="h1-4-3" class="i">+            // We&#39;re not a leader in this term, so we shoudn&#39;t see these.
</a>             Event::ConfirmLeader { .. }
<a href="#h1-4-5" id="h1-4-5" class="d">-            | Event::ReplicateEntries { .. }
</a>             | Event::AcceptEntries { .. }
             | Event::RejectEntries { .. } =&gt; warn!(&quot;Received unexpected message {:?}&quot;, msg),
         }
<a href="#h1-5" id="h1-5" class="h">@@ -113,7 +139,7 @@ impl RoleNode&lt;Candidate&gt; {
</a>             info!(&quot;Election timed out, starting new election for term {}&quot;, self.term + 1);
             let (last_index, last_term) = self.log.get_last_index();
             self.term += 1;
<a href="#h1-5-3" id="h1-5-3" class="d">-            self.log.set_term(self.term, None)?;
</a><a href="#h1-5-4" id="h1-5-4" class="i">+            self.log.set_term(self.term, Some(self.id))?;
</a>             self.role = Candidate::new();
             self.send(Address::Broadcast, Event::SolicitVote { last_index, last_term })?;
         }
<a href="#h1-6" id="h1-6" class="h">@@ -143,7 +169,7 @@ mod tests {
</a>         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
         log.commit(2)?;
<a href="#h1-6-3" id="h1-6-3" class="d">-        log.set_term(3, None)?;
</a><a href="#h1-6-4" id="h1-6-4" class="i">+        log.set_term(3, Some(1))?;
</a> 
         let node = RoleNode {
             id: 1,
<b>diff --git a/<a id="h2" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -2,7 +2,7 @@ use super::super::{Address, Event, Instruction, Message, Response};
</a> use super::{Candidate, Node, NodeID, RoleNode, Term, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
 use crate::error::{Error, Result};
 
<a href="#h2-0-3" id="h2-0-3" class="d">-use ::log::{debug, info, warn};
</a><a href="#h2-0-4" id="h2-0-4" class="i">+use ::log::{debug, error, info, warn};
</a> use rand::Rng as _;
 
 // A follower replicates state from a leader.
<a href="#h2-1" id="h2-1" class="h">@@ -36,62 +36,117 @@ impl RoleNode&lt;Follower&gt; {
</a>     fn become_candidate(self) -&gt; Result&lt;RoleNode&lt;Candidate&gt;&gt; {
         info!(&quot;Starting election for term {}&quot;, self.term + 1);
         let (last_index, last_term) = self.log.get_last_index();
<a href="#h2-1-3" id="h2-1-3" class="d">-        let mut node = self.become_role(Candidate::new())?;
</a><a href="#h2-1-4" id="h2-1-4" class="i">+        let mut node = self.become_role(Candidate::new());
</a>         node.term += 1;
<a href="#h2-1-6" id="h2-1-6" class="d">-        node.log.set_term(node.term, None)?;
</a><a href="#h2-1-7" id="h2-1-7" class="i">+        node.log.set_term(node.term, Some(node.id))?;
</a>         node.send(Address::Broadcast, Event::SolicitVote { last_index, last_term })?;
         Ok(node)
     }
 
<a href="#h2-1-12" id="h2-1-12" class="d">-    /// Transforms the node into a follower for a new leader.
</a><a href="#h2-1-13" id="h2-1-13" class="d">-    fn become_follower(mut self, leader: NodeID, term: Term) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a><a href="#h2-1-14" id="h2-1-14" class="d">-        let mut voted_for = None;
</a><a href="#h2-1-15" id="h2-1-15" class="d">-        if term &gt; self.term {
</a><a href="#h2-1-16" id="h2-1-16" class="d">-            info!(&quot;Discovered new term {}, following leader {}&quot;, term, leader);
</a><a href="#h2-1-17" id="h2-1-17" class="i">+    /// Transforms the node into a follower, either a leaderless follower in a
</a><a href="#h2-1-18" id="h2-1-18" class="i">+    /// new term or following a leader in the current term.
</a><a href="#h2-1-19" id="h2-1-19" class="i">+    fn become_follower(mut self, leader: Option&lt;NodeID&gt;, term: Term) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a><a href="#h2-1-20" id="h2-1-20" class="i">+        assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
</a><a href="#h2-1-21" id="h2-1-21" class="i">+
</a><a href="#h2-1-22" id="h2-1-22" class="i">+        if let Some(leader) = leader {
</a><a href="#h2-1-23" id="h2-1-23" class="i">+            // We found a leader in the current term.
</a><a href="#h2-1-24" id="h2-1-24" class="i">+            assert_eq!(self.role.leader, None, &quot;Already have leader in term&quot;);
</a><a href="#h2-1-25" id="h2-1-25" class="i">+            assert_eq!(term, self.term, &quot;Can&#39;t follow leader in different term&quot;);
</a><a href="#h2-1-26" id="h2-1-26" class="i">+            info!(&quot;Following leader {} in term {}&quot;, leader, term);
</a><a href="#h2-1-27" id="h2-1-27" class="i">+            self.role = Follower::new(Some(leader), self.role.voted_for);
</a><a href="#h2-1-28" id="h2-1-28" class="i">+        } else {
</a><a href="#h2-1-29" id="h2-1-29" class="i">+            // We found a new term, but we don&#39;t necessarily know who the leader
</a><a href="#h2-1-30" id="h2-1-30" class="i">+            // is yet. We&#39;ll find out when we step a message from it.
</a><a href="#h2-1-31" id="h2-1-31" class="i">+            assert_ne!(term, self.term, &quot;Can&#39;t become leaderless follower in current term&quot;);
</a><a href="#h2-1-32" id="h2-1-32" class="i">+            info!(&quot;Discovered new term {}&quot;, term);
</a>             self.term = term;
             self.log.set_term(term, None)?;
<a href="#h2-1-35" id="h2-1-35" class="d">-        } else {
</a><a href="#h2-1-36" id="h2-1-36" class="d">-            info!(&quot;Discovered leader {}, following&quot;, leader);
</a><a href="#h2-1-37" id="h2-1-37" class="d">-            voted_for = self.role.voted_for;
</a><a href="#h2-1-38" id="h2-1-38" class="d">-        };
</a><a href="#h2-1-39" id="h2-1-39" class="d">-        self.role = Follower::new(Some(leader), voted_for);
</a><a href="#h2-1-40" id="h2-1-40" class="i">+            self.role = Follower::new(None, None);
</a><a href="#h2-1-41" id="h2-1-41" class="i">+        }
</a><a href="#h2-1-42" id="h2-1-42" class="i">+        // Abort any proxied requests.
</a><a href="#h2-1-43" id="h2-1-43" class="i">+        //
</a><a href="#h2-1-44" id="h2-1-44" class="i">+        // TODO: Move this into the new term branch, and assert that there are
</a><a href="#h2-1-45" id="h2-1-45" class="i">+        // no proxied requests in the new leader branch.
</a>         self.abort_proxied()?;
         Ok(self)
     }
 
<a href="#h2-1-50" id="h2-1-50" class="d">-    /// Checks if an address is the current leader
</a><a href="#h2-1-51" id="h2-1-51" class="i">+    /// Checks if an address is the current leader.
</a>     fn is_leader(&amp;self, from: &amp;Address) -&gt; bool {
<a href="#h2-1-53" id="h2-1-53" class="d">-        matches!((&amp;self.role.leader, from), (Some(leader), Address::Node(from)) if leader == from)
</a><a href="#h2-1-54" id="h2-1-54" class="i">+        if let Some(leader) = &amp;self.role.leader {
</a><a href="#h2-1-55" id="h2-1-55" class="i">+            if let Address::Node(from) = from {
</a><a href="#h2-1-56" id="h2-1-56" class="i">+                return leader == from;
</a><a href="#h2-1-57" id="h2-1-57" class="i">+            }
</a><a href="#h2-1-58" id="h2-1-58" class="i">+        }
</a><a href="#h2-1-59" id="h2-1-59" class="i">+        false
</a>     }
 
     /// Processes a message.
     pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
<a href="#h2-1-64" id="h2-1-64" class="i">+        // Drop invalid messages and messages from past terms.
</a>         if let Err(err) = self.validate(&amp;msg) {
<a href="#h2-1-66" id="h2-1-66" class="d">-            warn!(&quot;Ignoring invalid message: {}&quot;, err);
</a><a href="#h2-1-67" id="h2-1-67" class="i">+            error!(&quot;Invalid message: {} ({:?})&quot;, err, msg);
</a>             return Ok(self.into());
         }
<a href="#h2-1-70" id="h2-1-70" class="d">-        if let Address::Node(from) = msg.from {
</a><a href="#h2-1-71" id="h2-1-71" class="d">-            if msg.term &gt; self.term || self.role.leader.is_none() {
</a><a href="#h2-1-72" id="h2-1-72" class="d">-                return self.become_follower(from, msg.term)?.step(msg);
</a><a href="#h2-1-73" id="h2-1-73" class="d">-            }
</a><a href="#h2-1-74" id="h2-1-74" class="i">+        if msg.term &lt; self.term &amp;&amp; msg.term &gt; 0 {
</a><a href="#h2-1-75" id="h2-1-75" class="i">+            debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
</a><a href="#h2-1-76" id="h2-1-76" class="i">+            return Ok(self.into());
</a><a href="#h2-1-77" id="h2-1-77" class="i">+        }
</a><a href="#h2-1-78" id="h2-1-78" class="i">+
</a><a href="#h2-1-79" id="h2-1-79" class="i">+        // If we receive a message for a future term, become a leaderless
</a><a href="#h2-1-80" id="h2-1-80" class="i">+        // follower in it and step the message. If the message is a Heartbeat or
</a><a href="#h2-1-81" id="h2-1-81" class="i">+        // ReplicateEntries from the leader, stepping it will follow the leader.
</a><a href="#h2-1-82" id="h2-1-82" class="i">+        if msg.term &gt; self.term {
</a><a href="#h2-1-83" id="h2-1-83" class="i">+            return self.become_follower(None, msg.term)?.step(msg);
</a>         }
<a href="#h2-1-85" id="h2-1-85" class="i">+
</a><a href="#h2-1-86" id="h2-1-86" class="i">+        // Record when we last saw a message from the leader (if any).
</a>         if self.is_leader(&amp;msg.from) {
             self.role.leader_seen_ticks = 0
         }
 
         match msg.event {
<a href="#h2-1-92" id="h2-1-92" class="i">+            // The leader will send periodic heartbeats. If we don&#39;t have a
</a><a href="#h2-1-93" id="h2-1-93" class="i">+            // leader in this term yet, follow it. If the commit_index advances,
</a><a href="#h2-1-94" id="h2-1-94" class="i">+            // apply state transitions.
</a>             Event::Heartbeat { commit_index, commit_term } =&gt; {
<a href="#h2-1-96" id="h2-1-96" class="d">-                if self.is_leader(&amp;msg.from) {
</a><a href="#h2-1-97" id="h2-1-97" class="d">-                    let has_committed = self.log.has(commit_index, commit_term)?;
</a><a href="#h2-1-98" id="h2-1-98" class="d">-                    let (old_commit_index, _) = self.log.get_commit_index();
</a><a href="#h2-1-99" id="h2-1-99" class="d">-                    if has_committed &amp;&amp; commit_index &gt; old_commit_index {
</a><a href="#h2-1-100" id="h2-1-100" class="d">-                        self.log.commit(commit_index)?;
</a><a href="#h2-1-101" id="h2-1-101" class="d">-                        let mut scan = self.log.scan((old_commit_index + 1)..=commit_index)?;
</a><a href="#h2-1-102" id="h2-1-102" class="d">-                        while let Some(entry) = scan.next().transpose()? {
</a><a href="#h2-1-103" id="h2-1-103" class="d">-                            self.state_tx.send(Instruction::Apply { entry })?;
</a><a href="#h2-1-104" id="h2-1-104" class="d">-                        }
</a><a href="#h2-1-105" id="h2-1-105" class="i">+                // Check that the heartbeat is from our leader.
</a><a href="#h2-1-106" id="h2-1-106" class="i">+                let from = msg.from.unwrap();
</a><a href="#h2-1-107" id="h2-1-107" class="i">+                match self.role.leader {
</a><a href="#h2-1-108" id="h2-1-108" class="i">+                    Some(leader) =&gt; assert_eq!(from, leader, &quot;Multiple leaders in term&quot;),
</a><a href="#h2-1-109" id="h2-1-109" class="i">+                    None =&gt; self = self.become_follower(Some(from), msg.term)?,
</a><a href="#h2-1-110" id="h2-1-110" class="i">+                }
</a><a href="#h2-1-111" id="h2-1-111" class="i">+
</a><a href="#h2-1-112" id="h2-1-112" class="i">+                // Advance commit index and apply entries if possible.
</a><a href="#h2-1-113" id="h2-1-113" class="i">+                let has_committed = self.log.has(commit_index, commit_term)?;
</a><a href="#h2-1-114" id="h2-1-114" class="i">+                let (old_commit_index, _) = self.log.get_commit_index();
</a><a href="#h2-1-115" id="h2-1-115" class="i">+                if has_committed &amp;&amp; commit_index &gt; old_commit_index {
</a><a href="#h2-1-116" id="h2-1-116" class="i">+                    self.log.commit(commit_index)?;
</a><a href="#h2-1-117" id="h2-1-117" class="i">+                    let mut scan = self.log.scan((old_commit_index + 1)..=commit_index)?;
</a><a href="#h2-1-118" id="h2-1-118" class="i">+                    while let Some(entry) = scan.next().transpose()? {
</a><a href="#h2-1-119" id="h2-1-119" class="i">+                        self.state_tx.send(Instruction::Apply { entry })?;
</a>                     }
<a href="#h2-1-121" id="h2-1-121" class="d">-                    self.send(msg.from, Event::ConfirmLeader { commit_index, has_committed })?;
</a><a href="#h2-1-122" id="h2-1-122" class="i">+                }
</a><a href="#h2-1-123" id="h2-1-123" class="i">+                self.send(msg.from, Event::ConfirmLeader { commit_index, has_committed })?;
</a><a href="#h2-1-124" id="h2-1-124" class="i">+            }
</a><a href="#h2-1-125" id="h2-1-125" class="i">+
</a><a href="#h2-1-126" id="h2-1-126" class="i">+            // Replicate entries from the leader. If we don&#39;t have a leader in
</a><a href="#h2-1-127" id="h2-1-127" class="i">+            // this term yet, follow it.
</a><a href="#h2-1-128" id="h2-1-128" class="i">+            Event::ReplicateEntries { base_index, base_term, entries } =&gt; {
</a><a href="#h2-1-129" id="h2-1-129" class="i">+                // Check that the entries are from our leader.
</a><a href="#h2-1-130" id="h2-1-130" class="i">+                let from = msg.from.unwrap();
</a><a href="#h2-1-131" id="h2-1-131" class="i">+                match self.role.leader {
</a><a href="#h2-1-132" id="h2-1-132" class="i">+                    Some(leader) =&gt; assert_eq!(from, leader, &quot;Multiple leaders in term&quot;),
</a><a href="#h2-1-133" id="h2-1-133" class="i">+                    None =&gt; self = self.become_follower(Some(from), msg.term)?,
</a><a href="#h2-1-134" id="h2-1-134" class="i">+                }
</a><a href="#h2-1-135" id="h2-1-135" class="i">+
</a><a href="#h2-1-136" id="h2-1-136" class="i">+                // Append the entries, if possible.
</a><a href="#h2-1-137" id="h2-1-137" class="i">+                if base_index &gt; 0 &amp;&amp; !self.log.has(base_index, base_term)? {
</a><a href="#h2-1-138" id="h2-1-138" class="i">+                    debug!(&quot;Rejecting log entries at base {}&quot;, base_index);
</a><a href="#h2-1-139" id="h2-1-139" class="i">+                    self.send(msg.from, Event::RejectEntries)?
</a><a href="#h2-1-140" id="h2-1-140" class="i">+                } else {
</a><a href="#h2-1-141" id="h2-1-141" class="i">+                    let last_index = self.log.splice(entries)?;
</a><a href="#h2-1-142" id="h2-1-142" class="i">+                    self.send(msg.from, Event::AcceptEntries { last_index })?
</a>                 }
             }
 
<a href="#h2-2" id="h2-2" class="h">@@ -116,18 +171,6 @@ impl RoleNode&lt;Follower&gt; {
</a>                 }
             }
 
<a href="#h2-2-3" id="h2-2-3" class="d">-            Event::ReplicateEntries { base_index, base_term, entries } =&gt; {
</a><a href="#h2-2-4" id="h2-2-4" class="d">-                if self.is_leader(&amp;msg.from) {
</a><a href="#h2-2-5" id="h2-2-5" class="d">-                    if base_index &gt; 0 &amp;&amp; !self.log.has(base_index, base_term)? {
</a><a href="#h2-2-6" id="h2-2-6" class="d">-                        debug!(&quot;Rejecting log entries at base {}&quot;, base_index);
</a><a href="#h2-2-7" id="h2-2-7" class="d">-                        self.send(msg.from, Event::RejectEntries)?
</a><a href="#h2-2-8" id="h2-2-8" class="d">-                    } else {
</a><a href="#h2-2-9" id="h2-2-9" class="d">-                        let last_index = self.log.splice(entries)?;
</a><a href="#h2-2-10" id="h2-2-10" class="d">-                        self.send(msg.from, Event::AcceptEntries { last_index })?
</a><a href="#h2-2-11" id="h2-2-11" class="d">-                    }
</a><a href="#h2-2-12" id="h2-2-12" class="d">-                }
</a><a href="#h2-2-13" id="h2-2-13" class="d">-            }
</a><a href="#h2-2-14" id="h2-2-14" class="d">-
</a>             // Forward requests to the leader, or abort them if there is none.
             Event::ClientRequest { ref id, .. } =&gt; {
                 let id = id.clone();
<a href="#h2-3" id="h2-3" class="h">@@ -150,6 +193,7 @@ impl RoleNode&lt;Follower&gt; {
</a>             // Ignore votes which are usually strays from the previous election that we lost.
             Event::GrantVote =&gt; {}
 
<a href="#h2-3-3" id="h2-3-3" class="i">+            // We&#39;re not a leader in this term, so we shoudn&#39;t see these.
</a>             Event::ConfirmLeader { .. }
             | Event::AcceptEntries { .. }
             | Event::RejectEntries { .. } =&gt; warn!(&quot;Received unexpected message {:?}&quot;, msg),
<a href="#h2-4" id="h2-4" class="h">@@ -292,19 +336,18 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h2-4-3" id="h2-4-3" class="d">-    // Heartbeat from fake leader
</a><a href="#h2-4-4" id="h2-4-4" class="d">-    fn step_heartbeat_fake_leader() -&gt; Result&lt;()&gt; {
</a><a href="#h2-4-5" id="h2-4-5" class="d">-        let (follower, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h2-4-6" id="h2-4-6" class="d">-        let mut node = follower.step(Message {
</a><a href="#h2-4-7" id="h2-4-7" class="d">-            from: Address::Node(3),
</a><a href="#h2-4-8" id="h2-4-8" class="d">-            to: Address::Node(1),
</a><a href="#h2-4-9" id="h2-4-9" class="d">-            term: 3,
</a><a href="#h2-4-10" id="h2-4-10" class="d">-            event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
</a><a href="#h2-4-11" id="h2-4-11" class="d">-        })?;
</a><a href="#h2-4-12" id="h2-4-12" class="d">-        assert_node(&amp;mut node).is_follower().term(3).leader(Some(2)).voted_for(None).committed(2);
</a><a href="#h2-4-13" id="h2-4-13" class="d">-        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h2-4-14" id="h2-4-14" class="d">-        assert_messages(&amp;mut state_rx, vec![]);
</a><a href="#h2-4-15" id="h2-4-15" class="d">-        Ok(())
</a><a href="#h2-4-16" id="h2-4-16" class="i">+    #[should_panic(expected = &quot;Multiple leaders in term&quot;)]
</a><a href="#h2-4-17" id="h2-4-17" class="i">+    // Heartbeat from other leader should panic.
</a><a href="#h2-4-18" id="h2-4-18" class="i">+    fn step_heartbeat_fake_leader() {
</a><a href="#h2-4-19" id="h2-4-19" class="i">+        let (follower, _, _) = setup().unwrap();
</a><a href="#h2-4-20" id="h2-4-20" class="i">+        follower
</a><a href="#h2-4-21" id="h2-4-21" class="i">+            .step(Message {
</a><a href="#h2-4-22" id="h2-4-22" class="i">+                from: Address::Node(3),
</a><a href="#h2-4-23" id="h2-4-23" class="i">+                to: Address::Node(1),
</a><a href="#h2-4-24" id="h2-4-24" class="i">+                term: 3,
</a><a href="#h2-4-25" id="h2-4-25" class="i">+                event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
</a><a href="#h2-4-26" id="h2-4-26" class="i">+            })
</a><a href="#h2-4-27" id="h2-4-27" class="i">+            .unwrap();
</a>     }
 
     #[test]
<b>diff --git a/<a id="h3" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -2,7 +2,7 @@ use super::super::{Address, Event, Index, Instruction, Message, Request, Respons
</a> use super::{Follower, Node, NodeID, RoleNode, Term, HEARTBEAT_INTERVAL};
 use crate::error::{Error, Result};
 
<a href="#h3-0-3" id="h3-0-3" class="d">-use ::log::{debug, info, warn};
</a><a href="#h3-0-4" id="h3-0-4" class="i">+use ::log::{debug, error, info};
</a> use std::collections::HashMap;
 
 // A leader serves requests and replicates the log to followers.
<a href="#h3-1" id="h3-1" class="h">@@ -33,13 +33,17 @@ impl Leader {
</a> }
 
 impl RoleNode&lt;Leader&gt; {
<a href="#h3-1-3" id="h3-1-3" class="d">-    /// Transforms the leader into a follower
</a><a href="#h3-1-4" id="h3-1-4" class="d">-    fn become_follower(mut self, term: Term, leader: NodeID) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a><a href="#h3-1-5" id="h3-1-5" class="d">-        info!(&quot;Discovered new leader {} for term {}, following&quot;, leader, term);
</a><a href="#h3-1-6" id="h3-1-6" class="i">+    /// Transforms the leader into a follower. This can only happen if we find a
</a><a href="#h3-1-7" id="h3-1-7" class="i">+    /// new term, so we become a leaderless follower.
</a><a href="#h3-1-8" id="h3-1-8" class="i">+    fn become_follower(mut self, term: Term) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a><a href="#h3-1-9" id="h3-1-9" class="i">+        assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
</a><a href="#h3-1-10" id="h3-1-10" class="i">+        assert!(term &gt; self.term, &quot;Can only become follower in later term&quot;);
</a><a href="#h3-1-11" id="h3-1-11" class="i">+
</a><a href="#h3-1-12" id="h3-1-12" class="i">+        info!(&quot;Discovered new term {}&quot;, term);
</a>         self.term = term;
         self.log.set_term(term, None)?;
         self.state_tx.send(Instruction::Abort)?;
<a href="#h3-1-16" id="h3-1-16" class="d">-        self.become_role(Follower::new(Some(leader), None))
</a><a href="#h3-1-17" id="h3-1-17" class="i">+        Ok(self.become_role(Follower::new(None, None)))
</a>     }
 
     /// Appends an entry to the log and replicates it to peers.
<a href="#h3-2" id="h3-2" class="h">@@ -97,17 +101,29 @@ impl RoleNode&lt;Leader&gt; {
</a> 
     /// Processes a message.
     pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
<a href="#h3-2-3" id="h3-2-3" class="i">+        // Drop invalid messages and messages from past terms.
</a>         if let Err(err) = self.validate(&amp;msg) {
<a href="#h3-2-5" id="h3-2-5" class="d">-            warn!(&quot;Ignoring invalid message: {}&quot;, err);
</a><a href="#h3-2-6" id="h3-2-6" class="i">+            error!(&quot;Invalid message: {} ({:?})&quot;, err, msg);
</a><a href="#h3-2-7" id="h3-2-7" class="i">+            return Ok(self.into());
</a><a href="#h3-2-8" id="h3-2-8" class="i">+        }
</a><a href="#h3-2-9" id="h3-2-9" class="i">+        if msg.term &lt; self.term &amp;&amp; msg.term &gt; 0 {
</a><a href="#h3-2-10" id="h3-2-10" class="i">+            debug!(&quot;Dropping message from past term ({:?})&quot;, msg);
</a>             return Ok(self.into());
         }
<a href="#h3-2-13" id="h3-2-13" class="i">+
</a><a href="#h3-2-14" id="h3-2-14" class="i">+        // If we receive a message for a future term, become a leaderless
</a><a href="#h3-2-15" id="h3-2-15" class="i">+        // follower in it and step the message. If the message is a Heartbeat or
</a><a href="#h3-2-16" id="h3-2-16" class="i">+        // ReplicateEntries from the leader, stepping it will follow the leader.
</a>         if msg.term &gt; self.term {
<a href="#h3-2-18" id="h3-2-18" class="d">-            if let Address::Node(from) = msg.from {
</a><a href="#h3-2-19" id="h3-2-19" class="d">-                return self.become_follower(msg.term, from)?.step(msg);
</a><a href="#h3-2-20" id="h3-2-20" class="d">-            }
</a><a href="#h3-2-21" id="h3-2-21" class="i">+            return self.become_follower(msg.term)?.step(msg);
</a>         }
 
         match msg.event {
<a href="#h3-2-25" id="h3-2-25" class="i">+            // There can&#39;t be two leaders in the same term.
</a><a href="#h3-2-26" id="h3-2-26" class="i">+            Event::Heartbeat { .. } | Event::ReplicateEntries { .. } =&gt; {
</a><a href="#h3-2-27" id="h3-2-27" class="i">+                panic!(&quot;Saw other leader {} in term {}&quot;, msg.from.unwrap(), msg.term);
</a><a href="#h3-2-28" id="h3-2-28" class="i">+            }
</a><a href="#h3-2-29" id="h3-2-29" class="i">+
</a>             Event::ConfirmLeader { commit_index, has_committed } =&gt; {
                 if let Address::Node(from) = msg.from {
                     self.state_tx.send(Instruction::Vote {
<a href="#h3-3" id="h3-3" class="h">@@ -191,13 +207,8 @@ impl RoleNode&lt;Leader&gt; {
</a>                 self.send(Address::Client, Event::ClientResponse { id, response })?;
             }
 
<a href="#h3-3-3" id="h3-3-3" class="d">-            // We ignore these messages, since they are typically additional votes from the previous
</a><a href="#h3-3-4" id="h3-3-4" class="d">-            // election that we won after a quorum.
</a><a href="#h3-3-5" id="h3-3-5" class="i">+            // Votes can come in after we won the election, ignore them.
</a>             Event::SolicitVote { .. } | Event::GrantVote =&gt; {}
<a href="#h3-3-7" id="h3-3-7" class="d">-
</a><a href="#h3-3-8" id="h3-3-8" class="d">-            Event::Heartbeat { .. } | Event::ReplicateEntries { .. } =&gt; {
</a><a href="#h3-3-9" id="h3-3-9" class="d">-                warn!(&quot;Received unexpected message {:?}&quot;, msg)
</a><a href="#h3-3-10" id="h3-3-10" class="d">-            }
</a>         }
 
         Ok(self.into())
<a href="#h3-4" id="h3-4" class="h">@@ -242,7 +253,7 @@ mod tests {
</a>         log.append(3, Some(vec![0x04]))?;
         log.append(3, Some(vec![0x05]))?;
         log.commit(2)?;
<a href="#h3-4-3" id="h3-4-3" class="d">-        log.set_term(3, None)?;
</a><a href="#h3-4-4" id="h3-4-4" class="i">+        log.set_term(3, Some(1))?;
</a> 
         let node = RoleNode {
             id: 1,
<a href="#h3-5" id="h3-5" class="h">@@ -308,21 +319,18 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h3-5-3" id="h3-5-3" class="d">-    // Heartbeats from other leaders in current term are ignored.
</a><a href="#h3-5-4" id="h3-5-4" class="d">-    fn step_heartbeat_current_term() -&gt; Result&lt;()&gt; {
</a><a href="#h3-5-5" id="h3-5-5" class="d">-        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h3-5-6" id="h3-5-6" class="d">-        let mut node: Node = leader.into();
</a><a href="#h3-5-7" id="h3-5-7" class="d">-
</a><a href="#h3-5-8" id="h3-5-8" class="d">-        node = node.step(Message {
</a><a href="#h3-5-9" id="h3-5-9" class="d">-            from: Address::Node(2),
</a><a href="#h3-5-10" id="h3-5-10" class="d">-            to: Address::Node(1),
</a><a href="#h3-5-11" id="h3-5-11" class="d">-            term: 3,
</a><a href="#h3-5-12" id="h3-5-12" class="d">-            event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
</a><a href="#h3-5-13" id="h3-5-13" class="d">-        })?;
</a><a href="#h3-5-14" id="h3-5-14" class="d">-        assert_node(&amp;mut node).is_leader().term(3).committed(2);
</a><a href="#h3-5-15" id="h3-5-15" class="d">-        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h3-5-16" id="h3-5-16" class="d">-        assert_messages(&amp;mut state_rx, vec![]);
</a><a href="#h3-5-17" id="h3-5-17" class="d">-        Ok(())
</a><a href="#h3-5-18" id="h3-5-18" class="i">+    #[should_panic(expected = &quot;Saw other leader 2 in term 3&quot;)]
</a><a href="#h3-5-19" id="h3-5-19" class="i">+    // Heartbeats from other leaders in current term panics.
</a><a href="#h3-5-20" id="h3-5-20" class="i">+    fn step_heartbeat_current_term() {
</a><a href="#h3-5-21" id="h3-5-21" class="i">+        let (leader, _, _) = setup().unwrap();
</a><a href="#h3-5-22" id="h3-5-22" class="i">+        leader
</a><a href="#h3-5-23" id="h3-5-23" class="i">+            .step(Message {
</a><a href="#h3-5-24" id="h3-5-24" class="i">+                from: Address::Node(2),
</a><a href="#h3-5-25" id="h3-5-25" class="i">+                to: Address::Node(1),
</a><a href="#h3-5-26" id="h3-5-26" class="i">+                term: 3,
</a><a href="#h3-5-27" id="h3-5-27" class="i">+                event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
</a><a href="#h3-5-28" id="h3-5-28" class="i">+            })
</a><a href="#h3-5-29" id="h3-5-29" class="i">+            .unwrap();
</a>     }
 
     #[test]
<a href="#h3-6" id="h3-6" class="h">@@ -654,7 +662,7 @@ mod tests {
</a>                     commit_index: 2,
                     apply_index: 0,
                     storage: &quot;memory&quot;.into(),
<a href="#h3-6-3" id="h3-6-3" class="d">-                    storage_size: 71,
</a><a href="#h3-6-4" id="h3-6-4" class="i">+                    storage_size: 72,
</a>                 }),
             }],
         );
<b>diff --git a/<a id="h4" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -76,7 +76,7 @@ impl Node {
</a>         if node.peers.is_empty() {
             info!(&quot;No peers specified, starting as leader&quot;);
             let (last_index, _) = node.log.get_last_index();
<a href="#h4-0-3" id="h4-0-3" class="d">-            Ok(node.become_role(Leader::new(vec![], last_index))?.into())
</a><a href="#h4-0-4" id="h4-0-4" class="i">+            Ok(node.become_role(Leader::new(vec![], last_index)).into())
</a>         } else {
             Ok(node.into())
         }
<a href="#h4-1" id="h4-1" class="h">@@ -144,8 +144,8 @@ pub struct RoleNode&lt;R&gt; {
</a> 
 impl&lt;R&gt; RoleNode&lt;R&gt; {
     /// Transforms the node into another role.
<a href="#h4-1-3" id="h4-1-3" class="d">-    fn become_role&lt;T&gt;(self, role: T) -&gt; Result&lt;RoleNode&lt;T&gt;&gt; {
</a><a href="#h4-1-4" id="h4-1-4" class="d">-        Ok(RoleNode {
</a><a href="#h4-1-5" id="h4-1-5" class="i">+    fn become_role&lt;T&gt;(self, role: T) -&gt; RoleNode&lt;T&gt; {
</a><a href="#h4-1-6" id="h4-1-6" class="i">+        RoleNode {
</a>             id: self.id,
             peers: self.peers,
             term: self.term,
<a href="#h4-2" id="h4-2" class="h">@@ -154,7 +154,7 @@ impl&lt;R&gt; RoleNode&lt;R&gt; {
</a>             state_tx: self.state_tx,
             proxied_reqs: self.proxied_reqs,
             role,
<a href="#h4-2-3" id="h4-2-3" class="d">-        })
</a><a href="#h4-2-4" id="h4-2-4" class="i">+        }
</a>     }
 
     /// Aborts any proxied requests.
<a href="#h4-3" id="h4-3" class="h">@@ -177,33 +177,42 @@ impl&lt;R&gt; RoleNode&lt;R&gt; {
</a>         Ok(self.node_tx.send(msg)?)
     }
 
<a href="#h4-3-3" id="h4-3-3" class="d">-    /// Validates a message
</a><a href="#h4-3-4" id="h4-3-4" class="i">+    /// Validates a message, when stepping it.
</a>     fn validate(&amp;self, msg: &amp;Message) -&gt; Result&lt;()&gt; {
<a href="#h4-3-6" id="h4-3-6" class="i">+        // Messages must be addressed to the local node, or a broadcast.
</a><a href="#h4-3-7" id="h4-3-7" class="i">+        match msg.to {
</a><a href="#h4-3-8" id="h4-3-8" class="i">+            Address::Broadcast =&gt; {}
</a><a href="#h4-3-9" id="h4-3-9" class="i">+            Address::Client =&gt; return Err(Error::Internal(&quot;Received message for client&quot;.into())),
</a><a href="#h4-3-10" id="h4-3-10" class="i">+            Address::Node(id) if id == self.id =&gt; {}
</a><a href="#h4-3-11" id="h4-3-11" class="i">+            Address::Node(_) =&gt; {
</a><a href="#h4-3-12" id="h4-3-12" class="i">+                return Err(Error::Internal(&quot;Received message for other node&quot;.into()))
</a><a href="#h4-3-13" id="h4-3-13" class="i">+            }
</a><a href="#h4-3-14" id="h4-3-14" class="i">+        }
</a><a href="#h4-3-15" id="h4-3-15" class="i">+
</a>         match msg.from {
<a href="#h4-3-17" id="h4-3-17" class="i">+            // The broadcast address can&#39;t send anything.
</a>             Address::Broadcast =&gt; {
                 return Err(Error::Internal(&quot;Message from broadcast address&quot;.into()))
             }
<a href="#h4-3-21" id="h4-3-21" class="d">-            Address::Client if !matches!(msg.event, Event::ClientRequest { .. }) =&gt; {
</a><a href="#h4-3-22" id="h4-3-22" class="d">-                return Err(Error::Internal(&quot;Non-request message from client&quot;.into()));
</a><a href="#h4-3-23" id="h4-3-23" class="i">+            // Clients can only send ClientRequest without a term.
</a><a href="#h4-3-24" id="h4-3-24" class="i">+            Address::Client =&gt; {
</a><a href="#h4-3-25" id="h4-3-25" class="i">+                if msg.term &gt; 0 {
</a><a href="#h4-3-26" id="h4-3-26" class="i">+                    return Err(Error::Internal(&quot;Client message with term&quot;.into()));
</a><a href="#h4-3-27" id="h4-3-27" class="i">+                }
</a><a href="#h4-3-28" id="h4-3-28" class="i">+                if !matches!(msg.event, Event::ClientRequest { .. }) {
</a><a href="#h4-3-29" id="h4-3-29" class="i">+                    return Err(Error::Internal(&quot;Non-request message from client&quot;.into()));
</a><a href="#h4-3-30" id="h4-3-30" class="i">+                }
</a>             }
<a href="#h4-3-32" id="h4-3-32" class="d">-            _ =&gt; {}
</a><a href="#h4-3-33" id="h4-3-33" class="d">-        }
</a><a href="#h4-3-34" id="h4-3-34" class="d">-
</a><a href="#h4-3-35" id="h4-3-35" class="d">-        // Allowing requests and responses form past terms is fine, since they don&#39;t rely on it
</a><a href="#h4-3-36" id="h4-3-36" class="d">-        if msg.term &lt; self.term
</a><a href="#h4-3-37" id="h4-3-37" class="d">-            &amp;&amp; !matches!(msg.event, Event::ClientRequest { .. } | Event::ClientResponse { .. })
</a><a href="#h4-3-38" id="h4-3-38" class="d">-        {
</a><a href="#h4-3-39" id="h4-3-39" class="d">-            return Err(Error::Internal(format!(&quot;Message from past term {}&quot;, msg.term)));
</a><a href="#h4-3-40" id="h4-3-40" class="d">-        }
</a><a href="#h4-3-41" id="h4-3-41" class="d">-
</a><a href="#h4-3-42" id="h4-3-42" class="d">-        match msg.to {
</a><a href="#h4-3-43" id="h4-3-43" class="d">-            Address::Node(id) if id == self.id =&gt; Ok(()),
</a><a href="#h4-3-44" id="h4-3-44" class="d">-            Address::Broadcast =&gt; Ok(()),
</a><a href="#h4-3-45" id="h4-3-45" class="d">-            Address::Node(id) =&gt; {
</a><a href="#h4-3-46" id="h4-3-46" class="d">-                Err(Error::Internal(format!(&quot;Received message for other node {}&quot;, id)))
</a><a href="#h4-3-47" id="h4-3-47" class="i">+            // Nodes must include their term.
</a><a href="#h4-3-48" id="h4-3-48" class="i">+            Address::Node(_) =&gt; {
</a><a href="#h4-3-49" id="h4-3-49" class="i">+                // TODO: For now, accept ClientResponse without term, since the
</a><a href="#h4-3-50" id="h4-3-50" class="i">+                // state driver does not have access to it.
</a><a href="#h4-3-51" id="h4-3-51" class="i">+                if msg.term == 0 &amp;&amp; !matches!(msg.event, Event::ClientResponse { .. }) {
</a><a href="#h4-3-52" id="h4-3-52" class="i">+                    return Err(Error::Internal(&quot;Message without term&quot;.into()));
</a><a href="#h4-3-53" id="h4-3-53" class="i">+                }
</a>             }
<a href="#h4-3-55" id="h4-3-55" class="d">-            Address::Client =&gt; Err(Error::Internal(&quot;Received message for client&quot;.into())),
</a>         }
<a href="#h4-3-57" id="h4-3-57" class="i">+        Ok(())
</a>     }
 }
 
<a href="#h4-4" id="h4-4" class="h">@@ -333,9 +342,9 @@ mod tests {
</a>             assert_eq!(
                 saved_voted_for,
                 match self.node {
<a href="#h4-4-3" id="h4-4-3" class="d">-                    Node::Candidate(_) =&gt; None,
</a><a href="#h4-4-4" id="h4-4-4" class="i">+                    Node::Candidate(n) =&gt; Some(n.id),
</a>                     Node::Follower(n) =&gt; follower_voted_for(n),
<a href="#h4-4-6" id="h4-4-6" class="d">-                    Node::Leader(_) =&gt; None,
</a><a href="#h4-4-7" id="h4-4-7" class="i">+                    Node::Leader(n) =&gt; Some(n.id),
</a>                 },
                 &quot;Incorrect voted_for stored in log&quot;
             );
<a href="#h4-5" id="h4-5" class="h">@@ -482,7 +491,7 @@ mod tests {
</a>     #[test]
     fn become_role() -&gt; Result&lt;()&gt; {
         let (node, _) = setup_rolenode()?;
<a href="#h4-5-3" id="h4-5-3" class="d">-        let new = node.become_role(&quot;role&quot;)?;
</a><a href="#h4-5-4" id="h4-5-4" class="i">+        let new = node.become_role(&quot;role&quot;);
</a>         assert_eq!(new.id, 1);
         assert_eq!(new.term, 1);
         assert_eq!(new.peers, vec![2, 3]);
<b>diff --git a/<a id="h5" href="../file/src/raft/state.rs.html">src/raft/state.rs</a> b/<a href="../file/src/raft/state.rs.html">src/raft/state.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -251,6 +251,7 @@ impl Driver {
</a> 
     /// Sends a message.
     fn send(&amp;self, to: Address, event: Event) -&gt; Result&lt;()&gt; {
<a href="#h5-0-3" id="h5-0-3" class="i">+        // TODO: This needs to use the correct term.
</a>         let msg = Message { from: Address::Node(self.node_id), to, term: 0, event };
         debug!(&quot;Sending {:?}&quot;, msg);
         Ok(self.node_tx.send(msg)?)
</pre>
</div>
</body>
</html>
