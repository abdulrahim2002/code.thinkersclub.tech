<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>add error::Result (fixes #31) - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/968284a1d865e6f4a153e8dc11d463dffce57b9c.html">968284a1d865e6f4a153e8dc11d463dffce57b9c</a>
<b>parent</b> <a href="../commit/0c81ee71593ea56fdccff782f8c854b63b897d9b.html">0c81ee71593ea56fdccff782f8c854b63b897d9b</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sat, 16 May 2020 17:35:05 +0200

add error::Result (fixes #31)

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/bin/bank.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">++++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/bin/toydb.rs</a></td><td> | </td><td class="num">7</td><td><span class="i">++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/bin/toysql.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">++++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/client.rs</a></td><td> | </td><td class="num">22</td><td><span class="i">+++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/error.rs</a></td><td> | </td><td class="num">28</td><td><span class="i">+++++++++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/lib.rs</a></td><td> | </td><td class="num">3</td><td><span class="i">+</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/raft/client.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/raft/log.rs</a></td><td> | </td><td class="num">98</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/raft/message.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">33</td><td><span class="i">+++++++++++++++</span><span class="d">------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/raft/node/follower.rs</a></td><td> | </td><td class="num">70</td><td><span class="i">++++++++++++++++++++++++++++++++++</span><span class="d">------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">src/raft/node/leader.rs</a></td><td> | </td><td class="num">59</td><td><span class="i">++++++++++++++++++++++++++++</span><span class="d">-------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">src/raft/node/mod.rs</a></td><td> | </td><td class="num">44</td><td><span class="i">+++++++++++++++++++++</span><span class="d">-----------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h13">src/raft/server.rs</a></td><td> | </td><td class="num">22</td><td><span class="i">+++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h14">src/raft/state.rs</a></td><td> | </td><td class="num">41</td><td><span class="i">++++++++++++++++++++</span><span class="d">---------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h15">src/server.rs</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h16">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">60</td><td><span class="i">+++++++++++++++++++++++++</span><span class="d">-----------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h17">src/sql/engine/mod.rs</a></td><td> | </td><td class="num">38</td><td><span class="i">++++++++++++++++++</span><span class="d">--------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h18">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">69</td><td><span class="i">++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h19">src/sql/execution/aggregation.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">++++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h20">src/sql/execution/create_table.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h21">src/sql/execution/delete.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h22">src/sql/execution/drop_table.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h23">src/sql/execution/filter.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h24">src/sql/execution/index_lookup.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h25">src/sql/execution/insert.rs</a></td><td> | </td><td class="num">10</td><td><span class="i">++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h26">src/sql/execution/key_lookup.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h27">src/sql/execution/limit.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h28">src/sql/execution/mod.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h29">src/sql/execution/nested_loop_join.rs</a></td><td> | </td><td class="num">10</td><td><span class="i">+++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h30">src/sql/execution/nothing.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h31">src/sql/execution/offset.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h32">src/sql/execution/order.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h33">src/sql/execution/projection.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h34">src/sql/execution/scan.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h35">src/sql/execution/update.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h36">src/sql/parser/lexer.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h37">src/sql/parser/mod.rs</a></td><td> | </td><td class="num">68</td><td><span class="i">++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h38">src/sql/plan/mod.rs</a></td><td> | </td><td class="num">31</td><td><span class="i">++++++++++++++</span><span class="d">-----------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h39">src/sql/plan/optimizer.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h40">src/sql/plan/planner.rs</a></td><td> | </td><td class="num">36</td><td><span class="i">+++++++++++++++++</span><span class="d">-------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h41">src/sql/schema.rs</a></td><td> | </td><td class="num">44</td><td><span class="i">++++++++++++++++++++</span><span class="d">------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h42">src/sql/types/expression.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h43">src/sql/types/mod.rs</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h44">src/storage/kv/memory.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h45">src/storage/kv/mod.rs</a></td><td> | </td><td class="num">38</td><td><span class="i">+++++++++++++++++++</span><span class="d">-------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h46">src/storage/kv/mvcc.rs</a></td><td> | </td><td class="num">122</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h47">src/storage/kv/test.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">++++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h48">src/storage/log/hybrid.rs</a></td><td> | </td><td class="num">28</td><td><span class="i">++++++++++++++</span><span class="d">--------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h49">src/storage/log/memory.rs</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h50">src/storage/log/mod.rs</a></td><td> | </td><td class="num">74</td><td><span class="i">+++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h51">src/storage/log/test.rs</a></td><td> | </td><td class="num">22</td><td><span class="i">++++++++++</span><span class="d">------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h52">tests/client/mod.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">++++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h53">tests/client/pool.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h54">tests/cluster/isolation.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h55">tests/setup.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">+++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h56">tests/sql/dml.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h57">tests/sql/expression.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h58">tests/sql/mod.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h59">tests/sql/query.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h60">tests/sql/schema.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
</table></pre><pre>61 files changed, 688 insertions(+), 729 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/bin/bank.rs.html">src/bin/bank.rs</a> b/<a href="../file/src/bin/bank.rs.html">src/bin/bank.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -12,10 +12,10 @@ use rand::Rng as _;
</a> use tokio::net::ToSocketAddrs;
 use tokio::sync::MutexGuard;
 use toydb::client::{Client, Pool};
<a href="#h0-0-3" id="h0-0-3" class="d">-use toydb::Error;
</a><a href="#h0-0-4" id="h0-0-4" class="i">+use toydb::error::{Error, Result};
</a> 
 #[tokio::main]
<a href="#h0-0-7" id="h0-0-7" class="d">-async fn main() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h0-0-8" id="h0-0-8" class="i">+async fn main() -&gt; Result&lt;()&gt; {
</a>     let opts = app_from_crate!()
         .arg(
             clap::Arg::with_name(&quot;host&quot;)
<a href="#h0-1" id="h0-1" class="h">@@ -93,7 +93,7 @@ impl Bank {
</a>         concurrency: u64,
         customers: i64,
         accounts: i64,
<a href="#h0-1-3" id="h0-1-3" class="d">-    ) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h0-1-4" id="h0-1-4" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a>         Ok(Self {
             clients: Pool::new(addrs, concurrency).await?,
             customers,
<a href="#h0-2" id="h0-2" class="h">@@ -102,7 +102,7 @@ impl Bank {
</a>     }
 
     // Runs the bank simulation
<a href="#h0-2-3" id="h0-2-3" class="d">-    async fn run(&amp;self, transactions: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h0-2-4" id="h0-2-4" class="i">+    async fn run(&amp;self, transactions: u64) -&gt; Result&lt;()&gt; {
</a>         self.setup().await?;
         self.verify().await?;
         println!();
<a href="#h0-3" id="h0-3" class="h">@@ -135,7 +135,7 @@ impl Bank {
</a>     }
 
     // Sets up the database
<a href="#h0-3-3" id="h0-3-3" class="d">-    async fn setup(&amp;self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h0-3-4" id="h0-3-4" class="i">+    async fn setup(&amp;self) -&gt; Result&lt;()&gt; {
</a>         let client = self.clients.get().await;
         let start = std::time::Instant::now();
         client.execute(&quot;BEGIN&quot;).await?;
<a href="#h0-4" id="h0-4" class="h">@@ -189,7 +189,7 @@ impl Bank {
</a>     }
 
     /// Verifies that all invariants hold
<a href="#h0-4-3" id="h0-4-3" class="d">-    async fn verify(&amp;self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h0-4-4" id="h0-4-4" class="i">+    async fn verify(&amp;self) -&gt; Result&lt;()&gt; {
</a>         let client = self.clients.get().await;
         let expect = self.customers * self.customer_accounts * Self::INITIAL_BALANCE as i64;
         let balance =
<a href="#h0-5" id="h0-5" class="h">@@ -214,7 +214,7 @@ impl Bank {
</a> 
     /// Transfers a random amount between two customers, retrying serialization failures
     /// FIXME The serialization rety with exponential backoff should be a helper on Client
<a href="#h0-5-3" id="h0-5-3" class="d">-    async fn transfer(&amp;self, from: i64, to: i64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h0-5-4" id="h0-5-4" class="i">+    async fn transfer(&amp;self, from: i64, to: i64) -&gt; Result&lt;()&gt; {
</a>         let client = self.clients.get().await;
         let mut attempts = 0;
         let start = std::time::Instant::now();
<a href="#h0-6" id="h0-6" class="h">@@ -263,7 +263,7 @@ impl Bank {
</a>         client: &amp;MutexGuard&lt;&#39;_, Client&gt;,
         from: i64,
         to: i64,
<a href="#h0-6-3" id="h0-6-3" class="d">-    ) -&gt; Result&lt;(i64, i64, i64), Error&gt; {
</a><a href="#h0-6-4" id="h0-6-4" class="i">+    ) -&gt; Result&lt;(i64, i64, i64)&gt; {
</a>         let mut row = client
             .execute(&amp;format!(
                 &quot;SELECT a.id, a.balance
<b>diff --git a/<a id="h1" href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a> b/<a href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -3,10 +3,11 @@
</a> use clap::{app_from_crate, crate_authors, crate_description, crate_name, crate_version};
 use serde_derive::Deserialize;
 use std::collections::HashMap;
<a href="#h1-0-3" id="h1-0-3" class="i">+use toydb::error::Result;
</a> use toydb::Server;
 
 #[tokio::main]
<a href="#h1-0-7" id="h1-0-7" class="d">-async fn main() -&gt; Result&lt;(), toydb::Error&gt; {
</a><a href="#h1-0-8" id="h1-0-8" class="i">+async fn main() -&gt; Result&lt;()&gt; {
</a>     let opts = app_from_crate!()
         .arg(
             clap::Arg::with_name(&quot;config&quot;)
<a href="#h1-1" id="h1-1" class="h">@@ -46,7 +47,7 @@ struct Config {
</a> }
 
 impl Config {
<a href="#h1-1-3" id="h1-1-3" class="d">-    fn new(file: &amp;str) -&gt; Result&lt;Self, config::ConfigError&gt; {
</a><a href="#h1-1-4" id="h1-1-4" class="i">+    fn new(file: &amp;str) -&gt; Result&lt;Self&gt; {
</a>         let mut c = config::Config::new();
         c.set_default(&quot;id&quot;, &quot;toydb&quot;)?;
         c.set_default(&quot;listen_sql&quot;, &quot;0.0.0.0:9605&quot;)?;
<a href="#h1-2" id="h1-2" class="h">@@ -57,6 +58,6 @@ impl Config {
</a> 
         c.merge(config::File::with_name(file))?;
         c.merge(config::Environment::with_prefix(&quot;TOYDB&quot;))?;
<a href="#h1-2-3" id="h1-2-3" class="d">-        c.try_into()
</a><a href="#h1-2-4" id="h1-2-4" class="i">+        Ok(c.try_into()?)
</a>     }
 }
<b>diff --git a/<a id="h2" href="../file/src/bin/toysql.rs.html">src/bin/toysql.rs</a> b/<a href="../file/src/bin/toysql.rs.html">src/bin/toysql.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -7,13 +7,13 @@
</a> 
 use clap::{app_from_crate, crate_authors, crate_description, crate_name, crate_version};
 use rustyline::{error::ReadlineError, Editor};
<a href="#h2-0-3" id="h2-0-3" class="i">+use toydb::error::{Error, Result};
</a> use toydb::sql::engine::Mode;
 use toydb::sql::execution::ResultSet;
 use toydb::Client;
<a href="#h2-0-7" id="h2-0-7" class="d">-use toydb::Error;
</a> 
 #[tokio::main]
<a href="#h2-0-10" id="h2-0-10" class="d">-async fn main() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h2-0-11" id="h2-0-11" class="i">+async fn main() -&gt; Result&lt;()&gt; {
</a>     let opts = app_from_crate!()
         .arg(clap::Arg::with_name(&quot;command&quot;))
         .arg(clap::Arg::with_name(&quot;headers&quot;).short(&quot;H&quot;).long(&quot;headers&quot;).help(&quot;Show column headers&quot;))
<a href="#h2-1" id="h2-1" class="h">@@ -61,7 +61,7 @@ struct ToySQL {
</a> 
 impl ToySQL {
     /// Creates a new ToySQL REPL for the given server host and port
<a href="#h2-1-3" id="h2-1-3" class="d">-    async fn new(host: &amp;str, port: u16) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    async fn new(host: &amp;str, port: u16) -&gt; Result&lt;Self&gt; {
</a>         Ok(Self {
             client: Client::new((host, port)).await?,
             editor: Editor::&lt;()&gt;::new(),
<a href="#h2-2" id="h2-2" class="h">@@ -72,7 +72,7 @@ impl ToySQL {
</a>     }
 
     /// Executes a line of input
<a href="#h2-2-3" id="h2-2-3" class="d">-    async fn execute(&amp;mut self, input: &amp;str) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h2-2-4" id="h2-2-4" class="i">+    async fn execute(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; {
</a>         if input.starts_with(&#39;!&#39;) {
             self.execute_command(&amp;input).await
         } else if !input.is_empty() {
<a href="#h2-3" id="h2-3" class="h">@@ -83,7 +83,7 @@ impl ToySQL {
</a>     }
 
     /// Handles a REPL command (prefixed by !, e.g. !help)
<a href="#h2-3-3" id="h2-3-3" class="d">-    async fn execute_command(&amp;mut self, input: &amp;str) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h2-3-4" id="h2-3-4" class="i">+    async fn execute_command(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; {
</a>         let mut input = input.split_ascii_whitespace();
         let command = input.next().ok_or_else(|| Error::Parse(&quot;Expected command.&quot;.to_string()))?;
 
<a href="#h2-4" id="h2-4" class="h">@@ -163,7 +163,7 @@ Txns:      {txns_active} active, {txns} total
</a>     }
 
     /// Runs a query and displays the results
<a href="#h2-4-3" id="h2-4-3" class="d">-    async fn execute_query(&amp;mut self, query: &amp;str) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h2-4-4" id="h2-4-4" class="i">+    async fn execute_query(&amp;mut self, query: &amp;str) -&gt; Result&lt;()&gt; {
</a>         match self.client.execute(query).await? {
             ResultSet::Begin { id, mode } =&gt; match mode {
                 Mode::ReadWrite =&gt; println!(&quot;Began transaction {}&quot;, id),
<a href="#h2-5" id="h2-5" class="h">@@ -205,7 +205,7 @@ Txns:      {txns_active} active, {txns} total
</a>     }
 
     /// Prompts the user for input
<a href="#h2-5-3" id="h2-5-3" class="d">-    fn prompt(&amp;mut self) -&gt; Result&lt;Option&lt;String&gt;, Error&gt; {
</a><a href="#h2-5-4" id="h2-5-4" class="i">+    fn prompt(&amp;mut self) -&gt; Result&lt;Option&lt;String&gt;&gt; {
</a>         let prompt = match self.client.txn() {
             Some((id, Mode::ReadWrite)) =&gt; format!(&quot;toydb:{}&gt; &quot;, id),
             Some((id, Mode::ReadOnly)) =&gt; format!(&quot;toydb:{}&gt; &quot;, id),
<a href="#h2-6" id="h2-6" class="h">@@ -223,7 +223,7 @@ Txns:      {txns_active} active, {txns} total
</a>     }
 
     /// Runs the ToySQL REPL
<a href="#h2-6-3" id="h2-6-3" class="d">-    async fn run(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h2-6-4" id="h2-6-4" class="i">+    async fn run(&amp;mut self) -&gt; Result&lt;()&gt; {
</a>         if let Some(path) = &amp;self.history_path {
             match self.editor.load_history(path) {
                 Ok(_) =&gt; {}
<b>diff --git a/<a id="h3" href="../file/src/client.rs.html">src/client.rs</a> b/<a href="../file/src/client.rs.html">src/client.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,8 +1,8 @@
</a><a href="#h3-0-0" id="h3-0-0" class="i">+use crate::error::{Error, Result};
</a> use crate::server::{Request, Response};
 use crate::sql::engine::{Mode, Status};
 use crate::sql::execution::ResultSet;
 use crate::sql::schema::Table;
<a href="#h3-0-5" id="h3-0-5" class="d">-use crate::Error;
</a> 
 use futures::future::FutureExt as _;
 use futures::sink::SinkExt as _;
<a href="#h3-1" id="h3-1" class="h">@@ -15,9 +15,9 @@ use tokio_util::codec::{Framed, LengthDelimitedCodec};
</a> 
 type Connection = tokio_serde::Framed&lt;
     Framed&lt;TcpStream, LengthDelimitedCodec&gt;,
<a href="#h3-1-3" id="h3-1-3" class="d">-    Result&lt;Response, Error&gt;,
</a><a href="#h3-1-4" id="h3-1-4" class="i">+    Result&lt;Response&gt;,
</a>     Request,
<a href="#h3-1-6" id="h3-1-6" class="d">-    tokio_serde::formats::Bincode&lt;Result&lt;Response, Error&gt;, Request&gt;,
</a><a href="#h3-1-7" id="h3-1-7" class="i">+    tokio_serde::formats::Bincode&lt;Result&lt;Response&gt;, Request&gt;,
</a> &gt;;
 
 /// A toyDB client
<a href="#h3-2" id="h3-2" class="h">@@ -28,7 +28,7 @@ pub struct Client {
</a> 
 impl Client {
     /// Creates a new client
<a href="#h3-2-3" id="h3-2-3" class="d">-    pub async fn new&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h3-2-4" id="h3-2-4" class="i">+    pub async fn new&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; Result&lt;Self&gt; {
</a>         Ok(Self {
             conn: Mutex::new(tokio_serde::Framed::new(
                 Framed::new(TcpStream::connect(addr).await?, LengthDelimitedCodec::new()),
<a href="#h3-3" id="h3-3" class="h">@@ -39,7 +39,7 @@ impl Client {
</a>     }
 
     /// Call a server method
<a href="#h3-3-3" id="h3-3-3" class="d">-    async fn call(&amp;self, request: Request) -&gt; Result&lt;Response, Error&gt; {
</a><a href="#h3-3-4" id="h3-3-4" class="i">+    async fn call(&amp;self, request: Request) -&gt; Result&lt;Response&gt; {
</a>         let mut conn = self.conn.lock().await;
         self.call_locked(&amp;mut conn, request).await
     }
<a href="#h3-4" id="h3-4" class="h">@@ -49,7 +49,7 @@ impl Client {
</a>         &amp;self,
         conn: &amp;mut MutexGuard&lt;&#39;_, Connection&gt;,
         request: Request,
<a href="#h3-4-3" id="h3-4-3" class="d">-    ) -&gt; Result&lt;Response, Error&gt; {
</a><a href="#h3-4-4" id="h3-4-4" class="i">+    ) -&gt; Result&lt;Response&gt; {
</a>         conn.send(request).await?;
         match conn.try_next().await? {
             Some(result) =&gt; result,
<a href="#h3-5" id="h3-5" class="h">@@ -58,7 +58,7 @@ impl Client {
</a>     }
 
     /// Executes a query
<a href="#h3-5-3" id="h3-5-3" class="d">-    pub async fn execute(&amp;self, query: &amp;str) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h3-5-4" id="h3-5-4" class="i">+    pub async fn execute(&amp;self, query: &amp;str) -&gt; Result&lt;ResultSet&gt; {
</a>         let mut conn = self.conn.lock().await;
         let mut resultset =
             match self.call_locked(&amp;mut conn, Request::Execute(query.into())).await? {
<a href="#h3-6" id="h3-6" class="h">@@ -89,7 +89,7 @@ impl Client {
</a>     }
 
     /// Fetches the table schema as SQL
<a href="#h3-6-3" id="h3-6-3" class="d">-    pub async fn get_table(&amp;self, table: &amp;str) -&gt; Result&lt;Table, Error&gt; {
</a><a href="#h3-6-4" id="h3-6-4" class="i">+    pub async fn get_table(&amp;self, table: &amp;str) -&gt; Result&lt;Table&gt; {
</a>         match self.call(Request::GetTable(table.into())).await? {
             Response::GetTable(t) =&gt; Ok(t),
             resp =&gt; Err(Error::Value(format!(&quot;Unexpected response: {:?}&quot;, resp))),
<a href="#h3-7" id="h3-7" class="h">@@ -97,7 +97,7 @@ impl Client {
</a>     }
 
     /// Lists database tables
<a href="#h3-7-3" id="h3-7-3" class="d">-    pub async fn list_tables(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;, Error&gt; {
</a><a href="#h3-7-4" id="h3-7-4" class="i">+    pub async fn list_tables(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
</a>         match self.call(Request::ListTables).await? {
             Response::ListTables(t) =&gt; Ok(t),
             resp =&gt; Err(Error::Value(format!(&quot;Unexpected response: {:?}&quot;, resp))),
<a href="#h3-8" id="h3-8" class="h">@@ -105,7 +105,7 @@ impl Client {
</a>     }
 
     /// Checks server status
<a href="#h3-8-3" id="h3-8-3" class="d">-    pub async fn status(&amp;self) -&gt; Result&lt;Status, Error&gt; {
</a><a href="#h3-8-4" id="h3-8-4" class="i">+    pub async fn status(&amp;self) -&gt; Result&lt;Status&gt; {
</a>         match self.call(Request::Status).await? {
             Response::Status(s) =&gt; Ok(s),
             resp =&gt; Err(Error::Value(format!(&quot;Unexpected response: {:?}&quot;, resp))),
<a href="#h3-9" id="h3-9" class="h">@@ -125,7 +125,7 @@ pub struct Pool {
</a> 
 impl Pool {
     /// Creates a new connection pool for the given servers, eagerly connecting clients.
<a href="#h3-9-3" id="h3-9-3" class="d">-    pub async fn new&lt;A: ToSocketAddrs + Clone&gt;(addrs: Vec&lt;A&gt;, size: u64) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h3-9-4" id="h3-9-4" class="i">+    pub async fn new&lt;A: ToSocketAddrs + Clone&gt;(addrs: Vec&lt;A&gt;, size: u64) -&gt; Result&lt;Self&gt; {
</a>         let mut addrs = addrs.into_iter().cycle();
         let clients = futures::future::try_join_all(
             std::iter::from_fn(|| {
<b>diff --git a/<a id="h4" href="../file/src/error.rs.html">src/error.rs</a> b/<a href="../file/src/error.rs.html">src/error.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -1,6 +1,10 @@
</a> use serde_derive::{Deserialize, Serialize};
<a href="#h4-0-1" id="h4-0-1" class="i">+use std::fmt::{self, Display};
</a> 
<a href="#h4-0-3" id="h4-0-3" class="d">-/// Errors, all except Internal are considered user-facing
</a><a href="#h4-0-4" id="h4-0-4" class="i">+/// Result returning Error
</a><a href="#h4-0-5" id="h4-0-5" class="i">+pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;
</a><a href="#h4-0-6" id="h4-0-6" class="i">+
</a><a href="#h4-0-7" id="h4-0-7" class="i">+/// toyDB errors. All except Internal are considered user-facing.
</a> #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Error {
     Abort,
<a href="#h4-1" id="h4-1" class="h">@@ -12,8 +16,10 @@ pub enum Error {
</a>     Value(String),
 }
 
<a href="#h4-1-3" id="h4-1-3" class="d">-impl std::fmt::Display for Error {
</a><a href="#h4-1-4" id="h4-1-4" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
</a><a href="#h4-1-5" id="h4-1-5" class="i">+impl std::error::Error for Error {}
</a><a href="#h4-1-6" id="h4-1-6" class="i">+
</a><a href="#h4-1-7" id="h4-1-7" class="i">+impl Display for Error {
</a><a href="#h4-1-8" id="h4-1-8" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; fmt::Result {
</a>         match self {
             Error::Config(s) | Error::Internal(s) | Error::Parse(s) | Error::Value(s) =&gt; {
                 write!(f, &quot;{}&quot;, s)
<a href="#h4-2" id="h4-2" class="h">@@ -25,8 +31,8 @@ impl std::fmt::Display for Error {
</a>     }
 }
 
<a href="#h4-2-3" id="h4-2-3" class="d">-impl From&lt;std::boxed::Box&lt;bincode::ErrorKind&gt;&gt; for Error {
</a><a href="#h4-2-4" id="h4-2-4" class="d">-    fn from(err: std::boxed::Box&lt;bincode::ErrorKind&gt;) -&gt; Self {
</a><a href="#h4-2-5" id="h4-2-5" class="i">+impl From&lt;Box&lt;bincode::ErrorKind&gt;&gt; for Error {
</a><a href="#h4-2-6" id="h4-2-6" class="i">+    fn from(err: Box&lt;bincode::ErrorKind&gt;) -&gt; Self {
</a>         Error::Internal(err.to_string())
     }
 }
<a href="#h4-3" id="h4-3" class="h">@@ -109,12 +115,6 @@ impl From&lt;tokio::sync::mpsc::error::TryRecvError&gt; for Error {
</a>     }
 }
 
<a href="#h4-3-3" id="h4-3-3" class="d">-impl From&lt;tokio::sync::oneshot::error::RecvError&gt; for Error {
</a><a href="#h4-3-4" id="h4-3-4" class="d">-    fn from(err: tokio::sync::oneshot::error::RecvError) -&gt; Self {
</a><a href="#h4-3-5" id="h4-3-5" class="d">-        Error::Internal(err.to_string())
</a><a href="#h4-3-6" id="h4-3-6" class="d">-    }
</a><a href="#h4-3-7" id="h4-3-7" class="d">-}
</a><a href="#h4-3-8" id="h4-3-8" class="d">-
</a> impl&lt;T&gt; From&lt;tokio::sync::mpsc::error::SendError&lt;T&gt;&gt; for Error {
     fn from(err: tokio::sync::mpsc::error::SendError&lt;T&gt;) -&gt; Self {
         Error::Internal(err.to_string())
<a href="#h4-4" id="h4-4" class="h">@@ -126,3 +126,9 @@ impl&lt;T&gt; From&lt;tokio::sync::mpsc::error::TrySendError&lt;T&gt;&gt; for Error {
</a>         Error::Internal(err.to_string())
     }
 }
<a href="#h4-4-3" id="h4-4-3" class="i">+
</a><a href="#h4-4-4" id="h4-4-4" class="i">+impl From&lt;tokio::sync::oneshot::error::RecvError&gt; for Error {
</a><a href="#h4-4-5" id="h4-4-5" class="i">+    fn from(err: tokio::sync::oneshot::error::RecvError) -&gt; Self {
</a><a href="#h4-4-6" id="h4-4-6" class="i">+        Error::Internal(err.to_string())
</a><a href="#h4-4-7" id="h4-4-7" class="i">+    }
</a><a href="#h4-4-8" id="h4-4-8" class="i">+}
</a><b>diff --git a/<a id="h5" href="../file/src/lib.rs.html">src/lib.rs</a> b/<a href="../file/src/lib.rs.html">src/lib.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -2,12 +2,11 @@
</a> #![allow(clippy::new_without_default)]
 
 pub mod client;
<a href="#h5-0-3" id="h5-0-3" class="d">-mod error;
</a><a href="#h5-0-4" id="h5-0-4" class="i">+pub mod error;
</a> pub mod raft;
 pub mod server;
 pub mod sql;
 pub mod storage;
 
 pub use client::Client;
<a href="#h5-0-11" id="h5-0-11" class="d">-pub use error::Error;
</a> pub use server::Server;
<b>diff --git a/<a id="h6" href="../file/src/raft/client.rs.html">src/raft/client.rs</a> b/<a href="../file/src/raft/client.rs.html">src/raft/client.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,31 +1,31 @@
</a> use super::{Request, Response, Status};
<a href="#h6-0-1" id="h6-0-1" class="d">-use crate::Error;
</a><a href="#h6-0-2" id="h6-0-2" class="i">+use crate::error::{Error, Result};
</a> 
 use tokio::sync::{mpsc, oneshot};
 
 /// A client for a local Raft server.
 #[derive(Clone)]
 pub struct Client {
<a href="#h6-0-9" id="h6-0-9" class="d">-    request_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;)&gt;,
</a><a href="#h6-0-10" id="h6-0-10" class="i">+    request_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Result&lt;Response&gt;&gt;)&gt;,
</a> }
 
 impl Client {
     /// Creates a new Raft client.
     pub fn new(
<a href="#h6-0-16" id="h6-0-16" class="d">-        request_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;)&gt;,
</a><a href="#h6-0-17" id="h6-0-17" class="i">+        request_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Result&lt;Response&gt;&gt;)&gt;,
</a>     ) -&gt; Self {
         Self { request_tx }
     }
 
     /// Executes a request against the Raft cluster.
<a href="#h6-0-23" id="h6-0-23" class="d">-    async fn request(&amp;self, request: Request) -&gt; Result&lt;Response, Error&gt; {
</a><a href="#h6-0-24" id="h6-0-24" class="i">+    async fn request(&amp;self, request: Request) -&gt; Result&lt;Response&gt; {
</a>         let (response_tx, response_rx) = oneshot::channel();
         self.request_tx.send((request, response_tx))?;
         response_rx.await?
     }
 
     /// Mutates the Raft state machine.
<a href="#h6-0-31" id="h6-0-31" class="d">-    pub async fn mutate(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h6-0-32" id="h6-0-32" class="i">+    pub async fn mutate(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         match self.request(Request::Mutate(command)).await? {
             Response::State(response) =&gt; Ok(response),
             resp =&gt; Err(Error::Internal(format!(&quot;Unexpected Raft mutate response {:?}&quot;, resp))),
<a href="#h6-1" id="h6-1" class="h">@@ -33,7 +33,7 @@ impl Client {
</a>     }
 
     /// Queries the Raft state machine.
<a href="#h6-1-3" id="h6-1-3" class="d">-    pub async fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h6-1-4" id="h6-1-4" class="i">+    pub async fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         match self.request(Request::Query(command)).await? {
             Response::State(response) =&gt; Ok(response),
             resp =&gt; Err(Error::Internal(format!(&quot;Unexpected Raft query response {:?}&quot;, resp))),
<a href="#h6-2" id="h6-2" class="h">@@ -41,7 +41,7 @@ impl Client {
</a>     }
 
     /// Fetches Raft node status.
<a href="#h6-2-3" id="h6-2-3" class="d">-    pub async fn status(&amp;self) -&gt; Result&lt;Status, Error&gt; {
</a><a href="#h6-2-4" id="h6-2-4" class="i">+    pub async fn status(&amp;self) -&gt; Result&lt;Status&gt; {
</a>         match self.request(Request::Status).await? {
             Response::Status(status) =&gt; Ok(status),
             resp =&gt; Err(Error::Internal(format!(&quot;Unexpected Raft status response {:?}&quot;, resp))),
<b>diff --git a/<a id="h7" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -1,5 +1,5 @@
</a><a href="#h7-0-0" id="h7-0-0" class="i">+use crate::error::{Error, Result};
</a> use crate::storage::log;
<a href="#h7-0-2" id="h7-0-2" class="d">-use crate::Error;
</a> 
 use ::log::debug;
 use serde::{Deserialize, Serialize};
<a href="#h7-1" id="h7-1" class="h">@@ -32,7 +32,7 @@ impl Key {
</a> }
 
 /// A log scan
<a href="#h7-1-3" id="h7-1-3" class="d">-pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Entry, Error&gt;&gt; + &#39;a&gt;;
</a><a href="#h7-1-4" id="h7-1-4" class="i">+pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Entry&gt;&gt; + &#39;a&gt;;
</a> 
 /// The replicated Raft log
 pub struct Log&lt;S: log::Store&gt; {
<a href="#h7-2" id="h7-2" class="h">@@ -50,7 +50,7 @@ pub struct Log&lt;S: log::Store&gt; {
</a> 
 impl&lt;S: log::Store&gt; Log&lt;S&gt; {
     /// Creates a new log, using a log::Store for storage.
<a href="#h7-2-3" id="h7-2-3" class="d">-    pub fn new(store: S) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h7-2-4" id="h7-2-4" class="i">+    pub fn new(store: S) -&gt; Result&lt;Self&gt; {
</a>         let (commit_index, commit_term) = match store.committed() {
             0 =&gt; (0, 0),
             index =&gt; store
<a href="#h7-3" id="h7-3" class="h">@@ -73,7 +73,7 @@ impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a>     }
 
     /// Appends a command to the log, returning the entry.
<a href="#h7-3-3" id="h7-3-3" class="d">-    pub fn append(&amp;mut self, term: u64, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;Entry, Error&gt; {
</a><a href="#h7-3-4" id="h7-3-4" class="i">+    pub fn append(&amp;mut self, term: u64, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;Entry&gt; {
</a>         let entry = Entry { index: self.last_index + 1, term, command };
         debug!(&quot;Appending log entry {}: {:?}&quot;, entry.index, entry);
         self.store.append(Self::serialize(&amp;entry)?)?;
<a href="#h7-4" id="h7-4" class="h">@@ -83,7 +83,7 @@ impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a>     }
 
     /// Commits entries up to and including an index.
<a href="#h7-4-3" id="h7-4-3" class="d">-    pub fn commit(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h7-4-4" id="h7-4-4" class="i">+    pub fn commit(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt; {
</a>         let entry = self
             .get(index)?
             .ok_or_else(|| Error::Internal(format!(&quot;Entry {} not found&quot;, index)))?;
<a href="#h7-5" id="h7-5" class="h">@@ -94,12 +94,12 @@ impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a>     }
 
     /// Fetches an entry at an index
<a href="#h7-5-3" id="h7-5-3" class="d">-    pub fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Entry&gt;, Error&gt; {
</a><a href="#h7-5-4" id="h7-5-4" class="i">+    pub fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Entry&gt;&gt; {
</a>         self.store.get(index)?.map(|v| Self::deserialize(&amp;v)).transpose()
     }
 
     /// Checks if the log contains an entry
<a href="#h7-5-9" id="h7-5-9" class="d">-    pub fn has(&amp;self, index: u64, term: u64) -&gt; Result&lt;bool, Error&gt; {
</a><a href="#h7-5-10" id="h7-5-10" class="i">+    pub fn has(&amp;self, index: u64, term: u64) -&gt; Result&lt;bool&gt; {
</a>         match self.get(index)? {
             Some(entry) =&gt; Ok(entry.term == term),
             None if index == 0 &amp;&amp; term == 0 =&gt; Ok(true),
<a href="#h7-6" id="h7-6" class="h">@@ -115,7 +115,7 @@ impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a>     /// Splices a set of entries onto an offset. The entries must be contiguous, and the first entry
     /// must be at most last_index+1. If an entry does not exist, append it. If an existing entry
     /// has a term mismatch, replace it and all following entries.
<a href="#h7-6-3" id="h7-6-3" class="d">-    pub fn splice(&amp;mut self, entries: Vec&lt;Entry&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h7-6-4" id="h7-6-4" class="i">+    pub fn splice(&amp;mut self, entries: Vec&lt;Entry&gt;) -&gt; Result&lt;u64&gt; {
</a>         for i in 0..entries.len() {
             if i == 0 &amp;&amp; entries.get(i).unwrap().index &gt; self.last_index + 1 {
                 return Err(Error::Internal(&quot;Spliced entries cannot begin past last index&quot;.into()));
<a href="#h7-7" id="h7-7" class="h">@@ -138,7 +138,7 @@ impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a> 
     /// Truncates the log such that its last item is at most index.
     /// Refuses to remove entries that have been applied or committed.
<a href="#h7-7-3" id="h7-7-3" class="d">-    pub fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h7-7-4" id="h7-7-4" class="i">+    pub fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt; {
</a>         debug!(&quot;Truncating log from entry {}&quot;, index);
         let (index, term) = match self.store.truncate(index)? {
             0 =&gt; (0, 0),
<a href="#h7-8" id="h7-8" class="h">@@ -157,7 +157,7 @@ impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a> 
     /// Loads information about the most recent term known by the log, containing the term number (0
     /// if none) and candidate voted for in current term (if any).
<a href="#h7-8-3" id="h7-8-3" class="d">-    pub fn load_term(&amp;self) -&gt; Result&lt;(u64, Option&lt;String&gt;), Error&gt; {
</a><a href="#h7-8-4" id="h7-8-4" class="i">+    pub fn load_term(&amp;self) -&gt; Result&lt;(u64, Option&lt;String&gt;)&gt; {
</a>         let (term, voted_for) = self
             .store
             .get_metadata(&amp;Key::TermVote.encode())?
<a href="#h7-9" id="h7-9" class="h">@@ -169,17 +169,17 @@ impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a>     }
 
     /// Saves information about the most recent term.
<a href="#h7-9-3" id="h7-9-3" class="d">-    pub fn save_term(&amp;mut self, term: u64, voted_for: Option&lt;&amp;str&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-9-4" id="h7-9-4" class="i">+    pub fn save_term(&amp;mut self, term: u64, voted_for: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt; {
</a>         self.store.set_metadata(&amp;Key::TermVote.encode(), Self::serialize(&amp;(term, voted_for))?)
     }
 
     /// Serializes a value for the log store.
<a href="#h7-9-9" id="h7-9-9" class="d">-    fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h7-9-10" id="h7-9-10" class="i">+    fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         Ok(bincode::serialize(value)?)
     }
 
     /// Deserializes a value from the log store.
<a href="#h7-9-15" id="h7-9-15" class="d">-    fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V, Error&gt; {
</a><a href="#h7-9-16" id="h7-9-16" class="i">+    fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a>         Ok(bincode::deserialize(bytes)?)
     }
 }
<a href="#h7-10" id="h7-10" class="h">@@ -189,14 +189,14 @@ mod tests {
</a>     use super::*;
     use pretty_assertions::assert_eq;
 
<a href="#h7-10-3" id="h7-10-3" class="d">-    fn setup() -&gt; Result&lt;(Log&lt;log::Test&gt;, log::Test), Error&gt; {
</a><a href="#h7-10-4" id="h7-10-4" class="i">+    fn setup() -&gt; Result&lt;(Log&lt;log::Test&gt;, log::Test)&gt; {
</a>         let store = log::Test::new();
         let log = Log::new(store.clone())?;
         Ok((log, store))
     }
 
     #[test]
<a href="#h7-10-11" id="h7-10-11" class="d">-    fn new() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-10-12" id="h7-10-12" class="i">+    fn new() -&gt; Result&lt;()&gt; {
</a>         let (l, _) = setup()?;
         assert_eq!(0, l.last_index);
         assert_eq!(0, l.last_term);
<a href="#h7-11" id="h7-11" class="h">@@ -207,7 +207,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-11-3" id="h7-11-3" class="d">-    fn append() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-11-4" id="h7-11-4" class="i">+    fn append() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         assert_eq!(Ok(None), l.get(1));
 
<a href="#h7-12" id="h7-12" class="h">@@ -226,7 +226,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-12-3" id="h7-12-3" class="d">-    fn append_none() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-12-4" id="h7-12-4" class="i">+    fn append_none() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         assert_eq!(Entry { index: 1, term: 3, command: None }, l.append(3, None)?);
         assert_eq!(Some(Entry { index: 1, term: 3, command: None }), l.get(1)?);
<a href="#h7-13" id="h7-13" class="h">@@ -234,7 +234,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-13-3" id="h7-13-3" class="d">-    fn append_persistence() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-13-4" id="h7-13-4" class="i">+    fn append_persistence() -&gt; Result&lt;()&gt; {
</a>         let (mut l, store) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, None)?;
<a href="#h7-14" id="h7-14" class="h">@@ -248,7 +248,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-14-3" id="h7-14-3" class="d">-    fn commit() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-14-4" id="h7-14-4" class="i">+    fn commit() -&gt; Result&lt;()&gt; {
</a>         let (mut l, store) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, None)?;
<a href="#h7-15" id="h7-15" class="h">@@ -265,7 +265,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-15-3" id="h7-15-3" class="d">-    fn commit_beyond() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-15-4" id="h7-15-4" class="i">+    fn commit_beyond() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, None)?;
<a href="#h7-16" id="h7-16" class="h">@@ -276,7 +276,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-16-3" id="h7-16-3" class="d">-    fn commit_partial() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-16-4" id="h7-16-4" class="i">+    fn commit_partial() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, None)?;
<a href="#h7-17" id="h7-17" class="h">@@ -288,7 +288,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-17-3" id="h7-17-3" class="d">-    fn get() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-17-4" id="h7-17-4" class="i">+    fn get() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         assert_eq!(None, l.get(1)?);
 
<a href="#h7-18" id="h7-18" class="h">@@ -299,7 +299,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-18-3" id="h7-18-3" class="d">-    fn has() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-18-4" id="h7-18-4" class="i">+    fn has() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(2, Some(vec![0x01]))?;
 
<a href="#h7-19" id="h7-19" class="h">@@ -314,7 +314,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-19-3" id="h7-19-3" class="d">-    fn scan() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-19-4" id="h7-19-4" class="i">+    fn scan() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(1, Some(vec![0x02]))?;
<a href="#h7-20" id="h7-20" class="h">@@ -326,21 +326,21 @@ mod tests {
</a>                 Entry { index: 2, term: 1, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 1, command: Some(vec![0x03]) },
             ],
<a href="#h7-20-3" id="h7-20-3" class="d">-            l.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-20-4" id="h7-20-4" class="i">+            l.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(
             vec![
                 Entry { index: 2, term: 1, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 1, command: Some(vec![0x03]) },
             ],
<a href="#h7-20-11" id="h7-20-11" class="d">-            l.scan(2..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-20-12" id="h7-20-12" class="i">+            l.scan(2..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
<a href="#h7-20-14" id="h7-20-14" class="d">-        assert!(l.scan(4..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h7-20-15" id="h7-20-15" class="i">+        assert!(l.scan(4..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a>         Ok(())
     }
 
     #[test]
<a href="#h7-20-20" id="h7-20-20" class="d">-    fn load_save_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-20-21" id="h7-20-21" class="i">+    fn load_save_term() -&gt; Result&lt;()&gt; {
</a>         // Test loading empty term
         let (l, _) = setup()?;
         assert_eq!((0, None), l.load_term()?);
<a href="#h7-21" id="h7-21" class="h">@@ -361,7 +361,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-21-3" id="h7-21-3" class="d">-    fn splice() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-21-4" id="h7-21-4" class="i">+    fn splice() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-22" id="h7-22" class="h">@@ -381,7 +381,7 @@ mod tests {
</a>                 Entry { index: 3, term: 3, command: Some(vec![0x03]) },
                 Entry { index: 4, term: 4, command: Some(vec![0x04]) },
             ],
<a href="#h7-22-3" id="h7-22-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-22-4" id="h7-22-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(4, l.last_index);
         assert_eq!(4, l.last_term);
<a href="#h7-23" id="h7-23" class="h">@@ -389,7 +389,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-23-3" id="h7-23-3" class="d">-    fn splice_all() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-23-4" id="h7-23-4" class="i">+    fn splice_all() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-24" id="h7-24" class="h">@@ -407,7 +407,7 @@ mod tests {
</a>                 Entry { index: 1, term: 4, command: Some(vec![0x0a]) },
                 Entry { index: 2, term: 4, command: Some(vec![0x0b]) },
             ],
<a href="#h7-24-3" id="h7-24-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-24-4" id="h7-24-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(2, l.last_index);
         assert_eq!(4, l.last_term);
<a href="#h7-25" id="h7-25" class="h">@@ -415,7 +415,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-25-3" id="h7-25-3" class="d">-    fn splice_append() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-25-4" id="h7-25-4" class="i">+    fn splice_append() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-26" id="h7-26" class="h">@@ -434,7 +434,7 @@ mod tests {
</a>                 Entry { index: 3, term: 3, command: Some(vec![0x03]) },
                 Entry { index: 4, term: 4, command: Some(vec![0x04]) },
             ],
<a href="#h7-26-3" id="h7-26-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-26-4" id="h7-26-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(4, l.last_index);
         assert_eq!(4, l.last_term);
<a href="#h7-27" id="h7-27" class="h">@@ -442,7 +442,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-27-3" id="h7-27-3" class="d">-    fn splice_conflict_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-27-4" id="h7-27-4" class="i">+    fn splice_conflict_term() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-28" id="h7-28" class="h">@@ -462,7 +462,7 @@ mod tests {
</a>                 Entry { index: 2, term: 3, command: Some(vec![0x0b]) },
                 Entry { index: 3, term: 3, command: Some(vec![0x0c]) },
             ],
<a href="#h7-28-3" id="h7-28-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-28-4" id="h7-28-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(3, l.last_index);
         assert_eq!(3, l.last_term);
<a href="#h7-29" id="h7-29" class="h">@@ -470,7 +470,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-29-3" id="h7-29-3" class="d">-    fn splice_error_noncontiguous() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-29-4" id="h7-29-4" class="i">+    fn splice_error_noncontiguous() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-30" id="h7-30" class="h">@@ -489,13 +489,13 @@ mod tests {
</a>                 Entry { index: 2, term: 2, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 3, command: Some(vec![0x03]) },
             ],
<a href="#h7-30-3" id="h7-30-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-30-4" id="h7-30-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         Ok(())
     }
 
     #[test]
<a href="#h7-30-10" id="h7-30-10" class="d">-    fn splice_error_beyond_last() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-30-11" id="h7-30-11" class="i">+    fn splice_error_beyond_last() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-31" id="h7-31" class="h">@@ -514,13 +514,13 @@ mod tests {
</a>                 Entry { index: 2, term: 2, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 3, command: Some(vec![0x03]) },
             ],
<a href="#h7-31-3" id="h7-31-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-31-4" id="h7-31-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         Ok(())
     }
 
     #[test]
<a href="#h7-31-10" id="h7-31-10" class="d">-    fn splice_overlap_inside() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-31-11" id="h7-31-11" class="i">+    fn splice_overlap_inside() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-32" id="h7-32" class="h">@@ -533,13 +533,13 @@ mod tests {
</a>                 Entry { index: 2, term: 2, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 3, command: Some(vec![0x03]) },
             ],
<a href="#h7-32-3" id="h7-32-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-32-4" id="h7-32-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         Ok(())
     }
 
     #[test]
<a href="#h7-32-10" id="h7-32-10" class="d">-    fn truncate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-32-11" id="h7-32-11" class="i">+    fn truncate() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-33" id="h7-33" class="h">@@ -551,13 +551,13 @@ mod tests {
</a>                 Entry { index: 1, term: 1, command: Some(vec![0x01]) },
                 Entry { index: 2, term: 2, command: Some(vec![0x02]) },
             ],
<a href="#h7-33-3" id="h7-33-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-33-4" id="h7-33-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         Ok(())
     }
 
     #[test]
<a href="#h7-33-10" id="h7-33-10" class="d">-    fn truncate_beyond() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-33-11" id="h7-33-11" class="i">+    fn truncate_beyond() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-34" id="h7-34" class="h">@@ -570,13 +570,13 @@ mod tests {
</a>                 Entry { index: 2, term: 2, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 3, command: Some(vec![0x03]) },
             ],
<a href="#h7-34-3" id="h7-34-3" class="d">-            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h7-34-4" id="h7-34-4" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         Ok(())
     }
 
     #[test]
<a href="#h7-34-10" id="h7-34-10" class="d">-    fn truncate_committed() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-34-11" id="h7-34-11" class="i">+    fn truncate_committed() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
<a href="#h7-35" id="h7-35" class="h">@@ -592,14 +592,14 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h7-35-3" id="h7-35-3" class="d">-    fn truncate_zero() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-35-4" id="h7-35-4" class="i">+    fn truncate_zero() -&gt; Result&lt;()&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(2, Some(vec![0x02]))?;
         l.append(3, Some(vec![0x03]))?;
 
         assert_eq!(0, l.truncate(0)?);
<a href="#h7-35-11" id="h7-35-11" class="d">-        assert!(l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h7-35-12" id="h7-35-12" class="i">+        assert!(l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a>         Ok(())
     }
 }
<b>diff --git a/<a id="h8" href="../file/src/raft/message.rs.html">src/raft/message.rs</a> b/<a href="../file/src/raft/message.rs.html">src/raft/message.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -1,5 +1,5 @@
</a> use super::{Entry, Status};
<a href="#h8-0-1" id="h8-0-1" class="d">-use crate::Error;
</a><a href="#h8-0-2" id="h8-0-2" class="i">+use crate::error::Result;
</a> 
 use serde_derive::{Deserialize, Serialize};
 
<a href="#h8-1" id="h8-1" class="h">@@ -85,7 +85,7 @@ pub enum Event {
</a>         /// The response ID.
         id: Vec&lt;u8&gt;,
         /// The response.
<a href="#h8-1-3" id="h8-1-3" class="d">-        response: Result&lt;Response, Error&gt;,
</a><a href="#h8-1-4" id="h8-1-4" class="i">+        response: Result&lt;Response&gt;,
</a>     },
 }
 
<b>diff --git a/<a id="h9" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::{Address, Event, Message, Response};
 use super::{Follower, Leader, Node, RoleNode, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
<a href="#h9-0-2" id="h9-0-2" class="i">+use crate::error::Result;
</a> use crate::storage::log;
<a href="#h9-0-4" id="h9-0-4" class="d">-use crate::Error;
</a> 
 use ::log::{debug, info, warn};
 use rand::Rng as _;
<a href="#h9-1" id="h9-1" class="h">@@ -31,7 +31,7 @@ impl Candidate {
</a> 
 impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
     /// Transition to follower role.
<a href="#h9-1-3" id="h9-1-3" class="d">-    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;, Error&gt; {
</a><a href="#h9-1-4" id="h9-1-4" class="i">+    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;&gt; {
</a>         info!(&quot;Discovered leader {} for term {}, following&quot;, leader, term);
         self.term = term;
         self.log.save_term(term, None)?;
<a href="#h9-2" id="h9-2" class="h">@@ -42,7 +42,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>     }
 
     /// Transition to leader role.
<a href="#h9-2-3" id="h9-2-3" class="d">-    fn become_leader(self) -&gt; Result&lt;RoleNode&lt;Leader, L&gt;, Error&gt; {
</a><a href="#h9-2-4" id="h9-2-4" class="i">+    fn become_leader(self) -&gt; Result&lt;RoleNode&lt;Leader, L&gt;&gt; {
</a>         info!(&quot;Won election for term {}, becoming leader&quot;, self.term);
         let peers = self.peers.clone();
         let last_index = self.log.last_index;
<a href="#h9-3" id="h9-3" class="h">@@ -60,7 +60,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>     }
 
     /// Processes a message.
<a href="#h9-3-3" id="h9-3-3" class="d">-    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h9-3-4" id="h9-3-4" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a>         if let Err(err) = self.validate(&amp;msg) {
             warn!(&quot;Ignoring invalid message: {}&quot;, err);
             return Ok(self.into());
<a href="#h9-4" id="h9-4" class="h">@@ -113,7 +113,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>     }
 
     /// Processes a logical clock tick.
<a href="#h9-4-3" id="h9-4-3" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h9-4-4" id="h9-4-4" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a>         // If the election times out, start a new one for the next term.
         self.role.election_ticks += 1;
         if self.role.election_ticks &gt;= self.role.election_timeout {
<a href="#h9-5" id="h9-5" class="h">@@ -142,14 +142,11 @@ mod tests {
</a>     use tokio::sync::mpsc;
 
     #[allow(clippy::type_complexity)]
<a href="#h9-5-3" id="h9-5-3" class="d">-    fn setup() -&gt; Result&lt;
</a><a href="#h9-5-4" id="h9-5-4" class="d">-        (
</a><a href="#h9-5-5" id="h9-5-5" class="d">-            RoleNode&lt;Candidate, log::Test&gt;,
</a><a href="#h9-5-6" id="h9-5-6" class="d">-            mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h9-5-7" id="h9-5-7" class="d">-            mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h9-5-8" id="h9-5-8" class="d">-        ),
</a><a href="#h9-5-9" id="h9-5-9" class="d">-        Error,
</a><a href="#h9-5-10" id="h9-5-10" class="d">-    &gt; {
</a><a href="#h9-5-11" id="h9-5-11" class="i">+    fn setup() -&gt; Result&lt;(
</a><a href="#h9-5-12" id="h9-5-12" class="i">+        RoleNode&lt;Candidate, log::Test&gt;,
</a><a href="#h9-5-13" id="h9-5-13" class="i">+        mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h9-5-14" id="h9-5-14" class="i">+        mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h9-5-15" id="h9-5-15" class="i">+    )&gt; {
</a>         let (node_tx, mut node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
         let mut log = Log::new(log::Test::new())?;
<a href="#h9-6" id="h9-6" class="h">@@ -186,7 +183,7 @@ mod tests {
</a>     #[test]
     // Heartbeat for current term converts to follower, forwards the queued request from setup(),
     // and emits ConfirmLeader.
<a href="#h9-6-3" id="h9-6-3" class="d">-    fn step_heartbeat_current_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h9-6-4" id="h9-6-4" class="i">+    fn step_heartbeat_current_term() -&gt; Result&lt;()&gt; {
</a>         let (candidate, mut node_rx, mut state_rx) = setup()?;
         let node = candidate.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h9-7" id="h9-7" class="h">@@ -222,7 +219,7 @@ mod tests {
</a>     #[test]
     // Heartbeat for future term converts to follower, forwards queued request, and emits
     // ConfirmLeader event
<a href="#h9-7-3" id="h9-7-3" class="d">-    fn step_heartbeat_future_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h9-7-4" id="h9-7-4" class="i">+    fn step_heartbeat_future_term() -&gt; Result&lt;()&gt; {
</a>         let (candidate, mut node_rx, mut state_rx) = setup()?;
         let node = candidate.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h9-8" id="h9-8" class="h">@@ -257,7 +254,7 @@ mod tests {
</a> 
     #[test]
     // Heartbeat for past term is ignored
<a href="#h9-8-3" id="h9-8-3" class="d">-    fn step_heartbeat_past_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h9-8-4" id="h9-8-4" class="i">+    fn step_heartbeat_past_term() -&gt; Result&lt;()&gt; {
</a>         let (candidate, mut node_rx, mut state_rx) = setup()?;
         let node = candidate.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h9-9" id="h9-9" class="h">@@ -272,7 +269,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h9-9-3" id="h9-9-3" class="d">-    fn step_grantvote() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h9-9-4" id="h9-9-4" class="i">+    fn step_grantvote() -&gt; Result&lt;()&gt; {
</a>         let (candidate, mut node_rx, mut state_rx) = setup()?;
         let peers = candidate.peers.clone();
         let mut node = Node::Candidate(candidate);
<a href="#h9-10" id="h9-10" class="h">@@ -350,7 +347,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h9-10-3" id="h9-10-3" class="d">-    fn tick() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h9-10-4" id="h9-10-4" class="i">+    fn tick() -&gt; Result&lt;()&gt; {
</a>         let (candidate, mut node_rx, mut state_rx) = setup()?;
         let timeout = candidate.role.election_timeout;
         let mut node = Node::Candidate(candidate);
<b>diff --git a/<a id="h10" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::{Address, Event, Instruction, Message, Response};
 use super::{Candidate, Node, RoleNode, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
<a href="#h10-0-2" id="h10-0-2" class="i">+use crate::error::Result;
</a> use crate::storage::log;
<a href="#h10-0-4" id="h10-0-4" class="d">-use crate::Error;
</a> 
 use ::log::{debug, info, warn};
 use rand::Rng as _;
<a href="#h10-1" id="h10-1" class="h">@@ -34,7 +34,7 @@ impl Follower {
</a> 
 impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
     /// Transforms the node into a candidate.
<a href="#h10-1-3" id="h10-1-3" class="d">-    fn become_candidate(self) -&gt; Result&lt;RoleNode&lt;Candidate, L&gt;, Error&gt; {
</a><a href="#h10-1-4" id="h10-1-4" class="i">+    fn become_candidate(self) -&gt; Result&lt;RoleNode&lt;Candidate, L&gt;&gt; {
</a>         info!(&quot;Starting election for term {}&quot;, self.term + 1);
         let mut node = self.become_role(Candidate::new())?;
         node.term += 1;
<a href="#h10-2" id="h10-2" class="h">@@ -47,7 +47,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>     }
 
     /// Transforms the node into a follower for a new leader.
<a href="#h10-2-3" id="h10-2-3" class="d">-    fn become_follower(mut self, leader: &amp;str, term: u64) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;, Error&gt; {
</a><a href="#h10-2-4" id="h10-2-4" class="i">+    fn become_follower(mut self, leader: &amp;str, term: u64) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;&gt; {
</a>         let mut voted_for = None;
         if term &gt; self.term {
             info!(&quot;Discovered new term {}, following leader {}&quot;, term, leader);
<a href="#h10-3" id="h10-3" class="h">@@ -72,7 +72,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>     }
 
     /// Processes a message.
<a href="#h10-3-3" id="h10-3-3" class="d">-    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h10-3-4" id="h10-3-4" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a>         if let Err(err) = self.validate(&amp;msg) {
             warn!(&quot;Ignoring invalid message: {}&quot;, err);
             return Ok(self.into());
<a href="#h10-4" id="h10-4" class="h">@@ -162,7 +162,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>     }
 
     /// Processes a logical clock tick.
<a href="#h10-4-3" id="h10-4-3" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h10-4-4" id="h10-4-4" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a>         self.role.leader_seen_ticks += 1;
         if self.role.leader_seen_ticks &gt;= self.role.leader_seen_timeout {
             Ok(self.become_candidate()?.into())
<a href="#h10-5" id="h10-5" class="h">@@ -177,6 +177,7 @@ pub mod tests {
</a>     use super::super::super::{Entry, Log, Request};
     use super::super::tests::{assert_messages, assert_node};
     use super::*;
<a href="#h10-5-3" id="h10-5-3" class="i">+    use crate::error::Error;
</a>     use std::collections::HashMap;
     use tokio::sync::mpsc;
 
<a href="#h10-6" id="h10-6" class="h">@@ -189,14 +190,11 @@ pub mod tests {
</a>     }
 
     #[allow(clippy::type_complexity)]
<a href="#h10-6-3" id="h10-6-3" class="d">-    fn setup() -&gt; Result&lt;
</a><a href="#h10-6-4" id="h10-6-4" class="d">-        (
</a><a href="#h10-6-5" id="h10-6-5" class="d">-            RoleNode&lt;Follower, log::Test&gt;,
</a><a href="#h10-6-6" id="h10-6-6" class="d">-            mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h10-6-7" id="h10-6-7" class="d">-            mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h10-6-8" id="h10-6-8" class="d">-        ),
</a><a href="#h10-6-9" id="h10-6-9" class="d">-        Error,
</a><a href="#h10-6-10" id="h10-6-10" class="d">-    &gt; {
</a><a href="#h10-6-11" id="h10-6-11" class="i">+    fn setup() -&gt; Result&lt;(
</a><a href="#h10-6-12" id="h10-6-12" class="i">+        RoleNode&lt;Follower, log::Test&gt;,
</a><a href="#h10-6-13" id="h10-6-13" class="i">+        mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h10-6-14" id="h10-6-14" class="i">+        mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h10-6-15" id="h10-6-15" class="i">+    )&gt; {
</a>         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
         let mut log = Log::new(log::Test::new())?;
<a href="#h10-7" id="h10-7" class="h">@@ -222,7 +220,7 @@ pub mod tests {
</a> 
     #[test]
     // Heartbeat from current leader should commit and apply
<a href="#h10-7-3" id="h10-7-3" class="d">-    fn step_heartbeat() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-7-4" id="h10-7-4" class="i">+    fn step_heartbeat() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-8" id="h10-8" class="h">@@ -251,7 +249,7 @@ pub mod tests {
</a> 
     #[test]
     // Heartbeat from current leader with conflicting commit_term
<a href="#h10-8-3" id="h10-8-3" class="d">-    fn step_heartbeat_conflict_commit_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-8-4" id="h10-8-4" class="i">+    fn step_heartbeat_conflict_commit_term() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-9" id="h10-9" class="h">@@ -275,7 +273,7 @@ pub mod tests {
</a> 
     #[test]
     // Heartbeat from current leader with a missing commit_index
<a href="#h10-9-3" id="h10-9-3" class="d">-    fn step_heartbeat_missing_commit_entry() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-9-4" id="h10-9-4" class="i">+    fn step_heartbeat_missing_commit_entry() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-10" id="h10-10" class="h">@@ -299,7 +297,7 @@ pub mod tests {
</a> 
     #[test]
     // Heartbeat from fake leader
<a href="#h10-10-3" id="h10-10-3" class="d">-    fn step_heartbeat_fake_leader() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-10-4" id="h10-10-4" class="i">+    fn step_heartbeat_fake_leader() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;c&quot;.into()),
<a href="#h10-11" id="h10-11" class="h">@@ -315,7 +313,7 @@ pub mod tests {
</a> 
     #[test]
     // Heartbeat when no current leader makes us follow the leader
<a href="#h10-11-3" id="h10-11-3" class="d">-    fn step_heartbeat_no_leader() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-11-4" id="h10-11-4" class="i">+    fn step_heartbeat_no_leader() -&gt; Result&lt;()&gt; {
</a>         let (mut follower, mut node_rx, mut state_rx) = setup()?;
         follower.role = Follower::new(None, None);
         let node = follower.step(Message {
<a href="#h10-12" id="h10-12" class="h">@@ -345,7 +343,7 @@ pub mod tests {
</a> 
     #[test]
     // Heartbeat from current leader with old commit_index
<a href="#h10-12-3" id="h10-12-3" class="d">-    fn step_heartbeat_old_commit_index() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-12-4" id="h10-12-4" class="i">+    fn step_heartbeat_old_commit_index() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-13" id="h10-13" class="h">@@ -369,7 +367,7 @@ pub mod tests {
</a> 
     #[test]
     // Heartbeat for future term with other leader changes leader
<a href="#h10-13-3" id="h10-13-3" class="d">-    fn step_heartbeat_future_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-13-4" id="h10-13-4" class="i">+    fn step_heartbeat_future_term() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;c&quot;.into()),
<a href="#h10-14" id="h10-14" class="h">@@ -398,7 +396,7 @@ pub mod tests {
</a> 
     #[test]
     // Heartbeat from past term
<a href="#h10-14-3" id="h10-14-3" class="d">-    fn step_heartbeat_past_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-14-4" id="h10-14-4" class="i">+    fn step_heartbeat_past_term() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-15" id="h10-15" class="h">@@ -414,7 +412,7 @@ pub mod tests {
</a> 
     #[test]
     // SolicitVote is granted for the first solicitor, otherwise ignored.
<a href="#h10-15-3" id="h10-15-3" class="d">-    fn step_solicitvote() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-15-4" id="h10-15-4" class="i">+    fn step_solicitvote() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
 
         // The first vote request in this term yields a vote response.
<a href="#h10-16" id="h10-16" class="h">@@ -470,7 +468,7 @@ pub mod tests {
</a> 
     #[test]
     // GrantVote messages are ignored
<a href="#h10-16-3" id="h10-16-3" class="d">-    fn step_grantvote_noop() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-16-4" id="h10-16-4" class="i">+    fn step_grantvote_noop() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-17" id="h10-17" class="h">@@ -486,7 +484,7 @@ pub mod tests {
</a> 
     #[test]
     // SolicitVote is rejected if last_term is outdated.
<a href="#h10-17-3" id="h10-17-3" class="d">-    fn step_solicitvote_last_index_outdated() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-17-4" id="h10-17-4" class="i">+    fn step_solicitvote_last_index_outdated() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;c&quot;.into()),
<a href="#h10-18" id="h10-18" class="h">@@ -502,7 +500,7 @@ pub mod tests {
</a> 
     #[test]
     // SolicitVote is rejected if last_term is outdated.
<a href="#h10-18-3" id="h10-18-3" class="d">-    fn step_solicitvote_last_term_outdated() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-18-4" id="h10-18-4" class="i">+    fn step_solicitvote_last_term_outdated() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;c&quot;.into()),
<a href="#h10-19" id="h10-19" class="h">@@ -518,7 +516,7 @@ pub mod tests {
</a> 
     #[test]
     // ReplicateEntries accepts some entries at base 0 without changes
<a href="#h10-19-3" id="h10-19-3" class="d">-    fn step_replicateentries_base0() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-19-4" id="h10-19-4" class="i">+    fn step_replicateentries_base0() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-20" id="h10-20" class="h">@@ -553,7 +551,7 @@ pub mod tests {
</a> 
     #[test]
     // ReplicateEntries appends entries but does not commit them
<a href="#h10-20-3" id="h10-20-3" class="d">-    fn step_replicateentries_append() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-20-4" id="h10-20-4" class="i">+    fn step_replicateentries_append() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-21" id="h10-21" class="h">@@ -590,7 +588,7 @@ pub mod tests {
</a> 
     #[test]
     // ReplicateEntries accepts partially overlapping entries
<a href="#h10-21-3" id="h10-21-3" class="d">-    fn step_replicateentries_partial_overlap() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-21-4" id="h10-21-4" class="i">+    fn step_replicateentries_partial_overlap() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-22" id="h10-22" class="h">@@ -627,7 +625,7 @@ pub mod tests {
</a> 
     #[test]
     // ReplicateEntries replaces conflicting entries
<a href="#h10-22-3" id="h10-22-3" class="d">-    fn step_replicateentries_replace() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-22-4" id="h10-22-4" class="i">+    fn step_replicateentries_replace() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-23" id="h10-23" class="h">@@ -663,7 +661,7 @@ pub mod tests {
</a> 
     #[test]
     // ReplicateEntries replaces partially conflicting entries
<a href="#h10-23-3" id="h10-23-3" class="d">-    fn step_replicateentries_replace_partial() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-23-4" id="h10-23-4" class="i">+    fn step_replicateentries_replace_partial() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-24" id="h10-24" class="h">@@ -699,7 +697,7 @@ pub mod tests {
</a> 
     #[test]
     // ReplicateEntries rejects missing base index
<a href="#h10-24-3" id="h10-24-3" class="d">-    fn step_replicateentries_reject_missing_base_index() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-24-4" id="h10-24-4" class="i">+    fn step_replicateentries_reject_missing_base_index() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-25" id="h10-25" class="h">@@ -731,7 +729,7 @@ pub mod tests {
</a> 
     #[test]
     // ReplicateEntries rejects conflicting base term
<a href="#h10-25-3" id="h10-25-3" class="d">-    fn step_replicateentries_reject_missing_base_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-25-4" id="h10-25-4" class="i">+    fn step_replicateentries_reject_missing_base_term() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let node = follower.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h10-26" id="h10-26" class="h">@@ -763,7 +761,7 @@ pub mod tests {
</a> 
     #[test]
     // ClientRequest is proxied, as is the response.
<a href="#h10-26-3" id="h10-26-3" class="d">-    fn step_clientrequest_clientresponse() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-26-4" id="h10-26-4" class="i">+    fn step_clientrequest_clientresponse() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let mut node = Node::Follower(follower);
 
<a href="#h10-27" id="h10-27" class="h">@@ -821,7 +819,7 @@ pub mod tests {
</a> 
     #[test]
     // ClientRequest is queued when there is no leader, and forwarded when a leader appears.
<a href="#h10-27-3" id="h10-27-3" class="d">-    fn step_clientrequest_queued() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-27-4" id="h10-27-4" class="i">+    fn step_clientrequest_queued() -&gt; Result&lt;()&gt; {
</a>         let (mut follower, mut node_rx, mut state_rx) = setup()?;
         follower.role = Follower::new(None, None);
         let mut node = Node::Follower(follower);
<a href="#h10-28" id="h10-28" class="h">@@ -883,7 +881,7 @@ pub mod tests {
</a> 
     // ClientRequest is proxied, but aborted when a new leader appears.
     #[test]
<a href="#h10-28-3" id="h10-28-3" class="d">-    fn step_clientrequest_aborted() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-28-4" id="h10-28-4" class="i">+    fn step_clientrequest_aborted() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let mut node = Node::Follower(follower);
 
<a href="#h10-29" id="h10-29" class="h">@@ -948,7 +946,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h10-29-3" id="h10-29-3" class="d">-    fn tick() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-29-4" id="h10-29-4" class="i">+    fn tick() -&gt; Result&lt;()&gt; {
</a>         let (follower, mut node_rx, mut state_rx) = setup()?;
         let timeout = follower.role.leader_seen_timeout;
         let mut node = Node::Follower(follower);
<b>diff --git a/<a id="h11" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::{Address, Event, Instruction, Message, Request, Response, Status};
 use super::{Follower, Node, RoleNode, HEARTBEAT_INTERVAL};
<a href="#h11-0-2" id="h11-0-2" class="i">+use crate::error::{Error, Result};
</a> use crate::storage::log;
<a href="#h11-0-4" id="h11-0-4" class="d">-use crate::Error;
</a> 
 use ::log::{debug, info, warn};
 use std::collections::HashMap;
<a href="#h11-1" id="h11-1" class="h">@@ -35,7 +35,7 @@ impl Leader {
</a> 
 impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
     /// Transforms the leader into a follower
<a href="#h11-1-3" id="h11-1-3" class="d">-    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;, Error&gt; {
</a><a href="#h11-1-4" id="h11-1-4" class="i">+    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;&gt; {
</a>         info!(&quot;Discovered new leader {} for term {}, following&quot;, leader, term);
         self.term = term;
         self.log.save_term(term, None)?;
<a href="#h11-2" id="h11-2" class="h">@@ -44,7 +44,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>     }
 
     /// Appends an entry to the log and replicates it to peers.
<a href="#h11-2-3" id="h11-2-3" class="d">-    pub fn append(&amp;mut self, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h11-2-4" id="h11-2-4" class="i">+    pub fn append(&amp;mut self, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;u64&gt; {
</a>         let entry = self.log.append(self.term, command)?;
         for peer in self.peers.iter() {
             self.replicate(peer)?;
<a href="#h11-3" id="h11-3" class="h">@@ -53,7 +53,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>     }
 
     /// Commits any pending log entries.
<a href="#h11-3-3" id="h11-3-3" class="d">-    fn commit(&amp;mut self) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h11-3-4" id="h11-3-4" class="i">+    fn commit(&amp;mut self) -&gt; Result&lt;u64&gt; {
</a>         let mut last_indexes = vec![self.log.last_index];
         last_indexes.extend(self.role.peer_last_index.values());
         last_indexes.sort();
<a href="#h11-4" id="h11-4" class="h">@@ -77,7 +77,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>     }
 
     /// Replicates the log to a peer.
<a href="#h11-4-3" id="h11-4-3" class="d">-    fn replicate(&amp;self, peer: &amp;str) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-4-4" id="h11-4-4" class="i">+    fn replicate(&amp;self, peer: &amp;str) -&gt; Result&lt;()&gt; {
</a>         let peer_next = self
             .role
             .peer_next_index
<a href="#h11-5" id="h11-5" class="h">@@ -90,7 +90,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>             None if base_index == 0 =&gt; 0,
             None =&gt; return Err(Error::Internal(format!(&quot;Missing base entry {}&quot;, base_index))),
         };
<a href="#h11-5-3" id="h11-5-3" class="d">-        let entries = self.log.scan(peer_next..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?;
</a><a href="#h11-5-4" id="h11-5-4" class="i">+        let entries = self.log.scan(peer_next..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a>         debug!(&quot;Replicating {} entries at base {} to {}&quot;, entries.len(), base_index, peer);
         self.send(
             Address::Peer(peer.to_string()),
<a href="#h11-6" id="h11-6" class="h">@@ -100,7 +100,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>     }
 
     /// Processes a message.
<a href="#h11-6-3" id="h11-6-3" class="d">-    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h11-6-4" id="h11-6-4" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a>         if let Err(err) = self.validate(&amp;msg) {
             warn!(&quot;Ignoring invalid message: {}&quot;, err);
             return Ok(self.into());
<a href="#h11-7" id="h11-7" class="h">@@ -207,7 +207,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>     }
 
     /// Processes a logical clock tick.
<a href="#h11-7-3" id="h11-7-3" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h11-7-4" id="h11-7-4" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a>         if !self.peers.is_empty() {
             self.role.heartbeat_ticks += 1;
             if self.role.heartbeat_ticks &gt;= HEARTBEAT_INTERVAL {
<a href="#h11-8" id="h11-8" class="h">@@ -234,14 +234,11 @@ mod tests {
</a>     use tokio::sync::mpsc;
 
     #[allow(clippy::type_complexity)]
<a href="#h11-8-3" id="h11-8-3" class="d">-    fn setup() -&gt; Result&lt;
</a><a href="#h11-8-4" id="h11-8-4" class="d">-        (
</a><a href="#h11-8-5" id="h11-8-5" class="d">-            RoleNode&lt;Leader, log::Test&gt;,
</a><a href="#h11-8-6" id="h11-8-6" class="d">-            mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h11-8-7" id="h11-8-7" class="d">-            mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h11-8-8" id="h11-8-8" class="d">-        ),
</a><a href="#h11-8-9" id="h11-8-9" class="d">-        Error,
</a><a href="#h11-8-10" id="h11-8-10" class="d">-    &gt; {
</a><a href="#h11-8-11" id="h11-8-11" class="i">+    fn setup() -&gt; Result&lt;(
</a><a href="#h11-8-12" id="h11-8-12" class="i">+        RoleNode&lt;Leader, log::Test&gt;,
</a><a href="#h11-8-13" id="h11-8-13" class="i">+        mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h11-8-14" id="h11-8-14" class="i">+        mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h11-8-15" id="h11-8-15" class="i">+    )&gt; {
</a>         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
         let peers = vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()];
<a href="#h11-9" id="h11-9" class="h">@@ -270,7 +267,7 @@ mod tests {
</a> 
     #[test]
     // ConfirmLeader triggers vote
<a href="#h11-9-3" id="h11-9-3" class="d">-    fn step_confirmleader_vote() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-9-4" id="h11-9-4" class="i">+    fn step_confirmleader_vote() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
 
<a href="#h11-10" id="h11-10" class="h">@@ -291,7 +288,7 @@ mod tests {
</a> 
     #[test]
     // ConfirmLeader without has_committed triggers replication
<a href="#h11-10-3" id="h11-10-3" class="d">-    fn step_confirmleader_replicate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-10-4" id="h11-10-4" class="i">+    fn step_confirmleader_replicate() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
 
<a href="#h11-11" id="h11-11" class="h">@@ -320,7 +317,7 @@ mod tests {
</a> 
     #[test]
     // Heartbeats from other leaders in current term are ignored.
<a href="#h11-11-3" id="h11-11-3" class="d">-    fn step_heartbeat_current_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-4" id="h11-11-4" class="i">+    fn step_heartbeat_current_term() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
 
<a href="#h11-12" id="h11-12" class="h">@@ -338,7 +335,7 @@ mod tests {
</a> 
     #[test]
     // Heartbeats from other leaders in future term converts to follower and steps.
<a href="#h11-12-3" id="h11-12-3" class="d">-    fn step_heartbeat_future_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-12-4" id="h11-12-4" class="i">+    fn step_heartbeat_future_term() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
 
<a href="#h11-13" id="h11-13" class="h">@@ -364,7 +361,7 @@ mod tests {
</a> 
     #[test]
     // Heartbeats from other leaders in past terms are ignored.
<a href="#h11-13-3" id="h11-13-3" class="d">-    fn step_heartbeat_past_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-13-4" id="h11-13-4" class="i">+    fn step_heartbeat_past_term() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
 
<a href="#h11-14" id="h11-14" class="h">@@ -381,7 +378,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h11-14-3" id="h11-14-3" class="d">-    fn step_acceptentries() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-14-4" id="h11-14-4" class="i">+    fn step_acceptentries() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
 
<a href="#h11-15" id="h11-15" class="h">@@ -436,7 +433,7 @@ mod tests {
</a> 
     #[test]
     // Duplicate AcceptEntries from single node should not trigger commit.
<a href="#h11-15-3" id="h11-15-3" class="d">-    fn step_acceptentries_duplicate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-15-4" id="h11-15-4" class="i">+    fn step_acceptentries_duplicate() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
 
<a href="#h11-16" id="h11-16" class="h">@@ -456,7 +453,7 @@ mod tests {
</a> 
     #[test]
     // AcceptEntries quorum for entry in past term should not trigger commit
<a href="#h11-16-3" id="h11-16-3" class="d">-    fn step_acceptentries_past_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-16-4" id="h11-16-4" class="i">+    fn step_acceptentries_past_term() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let peers = leader.peers.clone();
         let mut node: Node&lt;_&gt; = leader.into();
<a href="#h11-17" id="h11-17" class="h">@@ -477,7 +474,7 @@ mod tests {
</a> 
     #[test]
     // AcceptEntries quorum for missing future entry
<a href="#h11-17-3" id="h11-17-3" class="d">-    fn step_acceptentries_future_index() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-17-4" id="h11-17-4" class="i">+    fn step_acceptentries_future_index() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let peers = leader.peers.clone();
         let mut node: Node&lt;_&gt; = leader.into();
<a href="#h11-18" id="h11-18" class="h">@@ -517,9 +514,9 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h11-18-3" id="h11-18-3" class="d">-    fn step_rejectentries() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-18-4" id="h11-18-4" class="i">+    fn step_rejectentries() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h11-18-6" id="h11-18-6" class="d">-        let entries = leader.log.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?;
</a><a href="#h11-18-7" id="h11-18-7" class="i">+        let entries = leader.log.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a>         let mut node: Node&lt;_&gt; = leader.into();
 
         for i in 0..(entries.len() + 3) {
<a href="#h11-19" id="h11-19" class="h">@@ -556,7 +553,7 @@ mod tests {
</a> 
     #[test]
     // Sending a client query request will pass it to the state machine and trigger heartbeats.
<a href="#h11-19-3" id="h11-19-3" class="d">-    fn step_clientrequest_query() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-19-4" id="h11-19-4" class="i">+    fn step_clientrequest_query() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let quorum = leader.quorum();
         let mut node: Node&lt;_&gt; = leader.into();
<a href="#h11-20" id="h11-20" class="h">@@ -594,7 +591,7 @@ mod tests {
</a> 
     #[test]
     // Sending a mutate request should append it to log, replicate it to peers, and register notification.
<a href="#h11-20-3" id="h11-20-3" class="d">-    fn step_clientrequest_mutate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-20-4" id="h11-20-4" class="i">+    fn step_clientrequest_mutate() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let peers = leader.peers.clone();
         let mut node: Node&lt;_&gt; = leader.into();
<a href="#h11-21" id="h11-21" class="h">@@ -636,7 +633,7 @@ mod tests {
</a> 
     #[test]
     // Sending a status request should pass it on to state machine, to add status.
<a href="#h11-21-3" id="h11-21-3" class="d">-    fn step_clientrequest_status() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-21-4" id="h11-21-4" class="i">+    fn step_clientrequest_status() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
 
<a href="#h11-22" id="h11-22" class="h">@@ -676,7 +673,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h11-22-3" id="h11-22-3" class="d">-    fn tick() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-22-4" id="h11-22-4" class="i">+    fn tick() -&gt; Result&lt;()&gt; {
</a>         let (leader, mut node_rx, mut state_rx) = setup()?;
         let mut node: Node&lt;_&gt; = leader.into();
         for _ in 0..5 {
<b>diff --git a/<a id="h12" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -3,8 +3,8 @@ mod follower;
</a> mod leader;
 
 use super::{Address, Driver, Event, Instruction, Log, Message, State};
<a href="#h12-0-3" id="h12-0-3" class="i">+use crate::error::{Error, Result};
</a> use crate::storage::log;
<a href="#h12-0-5" id="h12-0-5" class="d">-use crate::Error;
</a> use candidate::Candidate;
 use follower::Follower;
 use leader::Leader;
<a href="#h12-1" id="h12-1" class="h">@@ -49,7 +49,7 @@ impl&lt;L: log::Store&gt; Node&lt;L&gt; {
</a>         log: Log&lt;L&gt;,
         mut state: S,
         node_tx: mpsc::UnboundedSender&lt;Message&gt;,
<a href="#h12-1-3" id="h12-1-3" class="d">-    ) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h12-1-4" id="h12-1-4" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a>         let applied_index = state.applied_index();
         if applied_index &gt; log.commit_index {
             return Err(Error::Internal(format!(
<a href="#h12-2" id="h12-2" class="h">@@ -97,7 +97,7 @@ impl&lt;L: log::Store&gt; Node&lt;L&gt; {
</a>     }
 
     /// Processes a message.
<a href="#h12-2-3" id="h12-2-3" class="d">-    pub fn step(self, msg: Message) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h12-2-4" id="h12-2-4" class="i">+    pub fn step(self, msg: Message) -&gt; Result&lt;Self&gt; {
</a>         debug!(&quot;Stepping {:?}&quot;, msg);
         match self {
             Node::Candidate(n) =&gt; n.step(msg),
<a href="#h12-3" id="h12-3" class="h">@@ -107,7 +107,7 @@ impl&lt;L: log::Store&gt; Node&lt;L&gt; {
</a>     }
 
     /// Moves time forward by a tick.
<a href="#h12-3-3" id="h12-3-3" class="d">-    pub fn tick(self) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h12-3-4" id="h12-3-4" class="i">+    pub fn tick(self) -&gt; Result&lt;Self&gt; {
</a>         match self {
             Node::Candidate(n) =&gt; n.tick(),
             Node::Follower(n) =&gt; n.tick(),
<a href="#h12-4" id="h12-4" class="h">@@ -151,7 +151,7 @@ pub struct RoleNode&lt;R, L: log::Store&gt; {
</a> 
 impl&lt;R, L: log::Store&gt; RoleNode&lt;R, L&gt; {
     /// Transforms the node into another role.
<a href="#h12-4-3" id="h12-4-3" class="d">-    fn become_role&lt;T&gt;(self, role: T) -&gt; Result&lt;RoleNode&lt;T, L&gt;, Error&gt; {
</a><a href="#h12-4-4" id="h12-4-4" class="i">+    fn become_role&lt;T&gt;(self, role: T) -&gt; Result&lt;RoleNode&lt;T, L&gt;&gt; {
</a>         Ok(RoleNode {
             id: self.id,
             peers: self.peers,
<a href="#h12-5" id="h12-5" class="h">@@ -166,7 +166,7 @@ impl&lt;R, L: log::Store&gt; RoleNode&lt;R, L&gt; {
</a>     }
 
     /// Aborts any proxied requests.
<a href="#h12-5-3" id="h12-5-3" class="d">-    fn abort_proxied(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-5-4" id="h12-5-4" class="i">+    fn abort_proxied(&amp;mut self) -&gt; Result&lt;()&gt; {
</a>         for (id, address) in std::mem::replace(&amp;mut self.proxied_reqs, HashMap::new()) {
             self.send(address, Event::ClientResponse { id, response: Err(Error::Abort) })?;
         }
<a href="#h12-6" id="h12-6" class="h">@@ -174,7 +174,7 @@ impl&lt;R, L: log::Store&gt; RoleNode&lt;R, L&gt; {
</a>     }
 
     /// Sends any queued requests to the given leader.
<a href="#h12-6-3" id="h12-6-3" class="d">-    fn forward_queued(&amp;mut self, leader: Address) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-6-4" id="h12-6-4" class="i">+    fn forward_queued(&amp;mut self, leader: Address) -&gt; Result&lt;()&gt; {
</a>         for (from, event) in std::mem::replace(&amp;mut self.queued_reqs, Vec::new()) {
             if let Event::ClientRequest { id, .. } = &amp;event {
                 self.proxied_reqs.insert(id.clone(), from.clone());
<a href="#h12-7" id="h12-7" class="h">@@ -198,14 +198,14 @@ impl&lt;R, L: log::Store&gt; RoleNode&lt;R, L&gt; {
</a>     }
 
     /// Sends an event
<a href="#h12-7-3" id="h12-7-3" class="d">-    fn send(&amp;self, to: Address, event: Event) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-7-4" id="h12-7-4" class="i">+    fn send(&amp;self, to: Address, event: Event) -&gt; Result&lt;()&gt; {
</a>         let msg = Message { term: self.term, from: Address::Local, to, event };
         debug!(&quot;Sending {:?}&quot;, msg);
         Ok(self.node_tx.send(msg)?)
     }
 
     /// Validates a message
<a href="#h12-7-11" id="h12-7-11" class="d">-    fn validate(&amp;self, msg: &amp;Message) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-7-12" id="h12-7-12" class="i">+    fn validate(&amp;self, msg: &amp;Message) -&gt; Result&lt;()&gt; {
</a>         match msg.from {
             Address::Peers =&gt; return Err(Error::Internal(&quot;Message from broadcast address&quot;.into())),
             Address::Local =&gt; return Err(Error::Internal(&quot;Message from local node&quot;.into())),
<a href="#h12-8" id="h12-8" class="h">@@ -288,7 +288,7 @@ mod tests {
</a>         }
 
         pub fn entries(self, entries: Vec&lt;Entry&gt;) -&gt; Self {
<a href="#h12-8-3" id="h12-8-3" class="d">-            assert_eq!(entries, self.log().scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;().unwrap());
</a><a href="#h12-8-4" id="h12-8-4" class="i">+            assert_eq!(entries, self.log().scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;().unwrap());
</a>             self
         }
 
<a href="#h12-9" id="h12-9" class="h">@@ -400,15 +400,13 @@ mod tests {
</a>         NodeAsserter::new(node)
     }
 
<a href="#h12-9-3" id="h12-9-3" class="d">-    fn setup_rolenode() -&gt; Result&lt;(RoleNode&lt;(), log::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;), Error&gt;
</a><a href="#h12-9-4" id="h12-9-4" class="d">-    {
</a><a href="#h12-9-5" id="h12-9-5" class="i">+    fn setup_rolenode() -&gt; Result&lt;(RoleNode&lt;(), log::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt; {
</a>         setup_rolenode_peers(vec![&quot;b&quot;.into(), &quot;c&quot;.into()])
     }
 
<a href="#h12-9-9" id="h12-9-9" class="d">-    #[allow(clippy::type_complexity)]
</a>     fn setup_rolenode_peers(
         peers: Vec&lt;String&gt;,
<a href="#h12-9-12" id="h12-9-12" class="d">-    ) -&gt; Result&lt;(RoleNode&lt;(), log::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;), Error&gt; {
</a><a href="#h12-9-13" id="h12-9-13" class="i">+    ) -&gt; Result&lt;(RoleNode&lt;(), log::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt; {
</a>         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, _) = mpsc::unbounded_channel();
         let node = RoleNode {
<a href="#h12-10" id="h12-10" class="h">@@ -426,7 +424,7 @@ mod tests {
</a>     }
 
     #[tokio::test]
<a href="#h12-10-3" id="h12-10-3" class="d">-    async fn new() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-10-4" id="h12-10-4" class="i">+    async fn new() -&gt; Result&lt;()&gt; {
</a>         let (node_tx, _) = mpsc::unbounded_channel();
         let node = Node::new(
             &quot;a&quot;,
<a href="#h12-11" id="h12-11" class="h">@@ -448,7 +446,7 @@ mod tests {
</a>     }
 
     #[tokio::test]
<a href="#h12-11-3" id="h12-11-3" class="d">-    async fn new_loads_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-11-4" id="h12-11-4" class="i">+    async fn new_loads_term() -&gt; Result&lt;()&gt; {
</a>         let (node_tx, _) = mpsc::unbounded_channel();
         let store = log::Test::new();
         Log::new(store.clone())?.save_term(3, Some(&quot;c&quot;))?;
<a href="#h12-12" id="h12-12" class="h">@@ -468,7 +466,7 @@ mod tests {
</a>     }
 
     #[tokio::test(core_threads = 2)]
<a href="#h12-12-3" id="h12-12-3" class="d">-    async fn new_state_apply_all() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-12-4" id="h12-12-4" class="i">+    async fn new_state_apply_all() -&gt; Result&lt;()&gt; {
</a>         let (node_tx, _) = mpsc::unbounded_channel();
         let mut log = Log::new(log::Test::new())?;
         log.append(1, Some(vec![0x01]))?;
<a href="#h12-13" id="h12-13" class="h">@@ -486,7 +484,7 @@ mod tests {
</a>     }
 
     #[tokio::test(core_threads = 2)]
<a href="#h12-13-3" id="h12-13-3" class="d">-    async fn new_state_apply_partial() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-13-4" id="h12-13-4" class="i">+    async fn new_state_apply_partial() -&gt; Result&lt;()&gt; {
</a>         let (node_tx, _) = mpsc::unbounded_channel();
         let mut log = Log::new(log::Test::new())?;
         log.append(1, Some(vec![0x01]))?;
<a href="#h12-14" id="h12-14" class="h">@@ -504,7 +502,7 @@ mod tests {
</a>     }
 
     #[tokio::test(core_threads = 2)]
<a href="#h12-14-3" id="h12-14-3" class="d">-    async fn new_state_apply_missing() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-14-4" id="h12-14-4" class="i">+    async fn new_state_apply_missing() -&gt; Result&lt;()&gt; {
</a>         let (node_tx, _) = mpsc::unbounded_channel();
         let mut log = Log::new(log::Test::new())?;
         log.append(1, Some(vec![0x01]))?;
<a href="#h12-15" id="h12-15" class="h">@@ -524,7 +522,7 @@ mod tests {
</a>     }
 
     #[tokio::test]
<a href="#h12-15-3" id="h12-15-3" class="d">-    async fn new_single() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-15-4" id="h12-15-4" class="i">+    async fn new_single() -&gt; Result&lt;()&gt; {
</a>         let (node_tx, _) = mpsc::unbounded_channel();
         let node =
             Node::new(&quot;a&quot;, vec![], Log::new(log::Test::new())?, TestState::new(0), node_tx).await?;
<a href="#h12-16" id="h12-16" class="h">@@ -540,7 +538,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h12-16-3" id="h12-16-3" class="d">-    fn become_role() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-16-4" id="h12-16-4" class="i">+    fn become_role() -&gt; Result&lt;()&gt; {
</a>         let (node, _) = setup_rolenode()?;
         let new = node.become_role(&quot;role&quot;)?;
         assert_eq!(new.id, &quot;a&quot;.to_owned());
<a href="#h12-17" id="h12-17" class="h">@@ -551,7 +549,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h12-17-3" id="h12-17-3" class="d">-    fn quorum() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-17-4" id="h12-17-4" class="i">+    fn quorum() -&gt; Result&lt;()&gt; {
</a>         let quorums = vec![(1, 1), (2, 2), (3, 2), (4, 3), (5, 3), (6, 4), (7, 4), (8, 5)];
         for (size, quorum) in quorums.into_iter() {
             let peers: Vec&lt;String&gt; =
<a href="#h12-18" id="h12-18" class="h">@@ -564,7 +562,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h12-18-3" id="h12-18-3" class="d">-    fn send() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-18-4" id="h12-18-4" class="i">+    fn send() -&gt; Result&lt;()&gt; {
</a>         let (node, mut rx) = setup_rolenode()?;
         node.send(Address::Peer(&quot;b&quot;.into()), Event::Heartbeat { commit_index: 1, commit_term: 1 })?;
         assert_messages(
<b>diff --git a/<a id="h13" href="../file/src/raft/server.rs.html">src/raft/server.rs</a> b/<a href="../file/src/raft/server.rs.html">src/raft/server.rs</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -1,6 +1,6 @@
</a> use super::{Address, Event, Log, Message, Node, Request, Response, State};
<a href="#h13-0-1" id="h13-0-1" class="i">+use crate::error::{Error, Result};
</a> use crate::storage::log;
<a href="#h13-0-3" id="h13-0-3" class="d">-use crate::Error;
</a> 
 use ::log::{debug, error};
 use futures::{sink::SinkExt as _, FutureExt as _};
<a href="#h13-1" id="h13-1" class="h">@@ -29,7 +29,7 @@ impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a>         peers: HashMap&lt;String, String&gt;,
         log: Log&lt;L&gt;,
         state: S,
<a href="#h13-1-3" id="h13-1-3" class="d">-    ) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h13-1-4" id="h13-1-4" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a>         let (node_tx, node_rx) = mpsc::unbounded_channel();
         Ok(Self {
             node: Node::new(
<a href="#h13-2" id="h13-2" class="h">@@ -49,8 +49,8 @@ impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a>     pub async fn serve(
         self,
         listener: TcpListener,
<a href="#h13-2-3" id="h13-2-3" class="d">-        client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;)&gt;,
</a><a href="#h13-2-4" id="h13-2-4" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h13-2-5" id="h13-2-5" class="i">+        client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Result&lt;Response&gt;&gt;)&gt;,
</a><a href="#h13-2-6" id="h13-2-6" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         let (tcp_in_tx, tcp_in_rx) = mpsc::unbounded_channel::&lt;Message&gt;();
         let (tcp_out_tx, tcp_out_rx) = mpsc::unbounded_channel::&lt;Message&gt;();
         let (task, tcp_receiver) = Self::tcp_receive(listener, tcp_in_tx).remote_handle();
<a href="#h13-3" id="h13-3" class="h">@@ -71,12 +71,12 @@ impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a>     async fn eventloop(
         mut node: Node&lt;L&gt;,
         mut node_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
<a href="#h13-3-3" id="h13-3-3" class="d">-        mut client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;)&gt;,
</a><a href="#h13-3-4" id="h13-3-4" class="i">+        mut client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Result&lt;Response&gt;&gt;)&gt;,
</a>         mut tcp_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
         tcp_tx: mpsc::UnboundedSender&lt;Message&gt;,
<a href="#h13-3-7" id="h13-3-7" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h13-3-8" id="h13-3-8" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         let mut ticker = tokio::time::interval(TICK);
<a href="#h13-3-10" id="h13-3-10" class="d">-        let mut requests = HashMap::&lt;Vec&lt;u8&gt;, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;&gt;::new();
</a><a href="#h13-3-11" id="h13-3-11" class="i">+        let mut requests = HashMap::&lt;Vec&lt;u8&gt;, oneshot::Sender&lt;Result&lt;Response&gt;&gt;&gt;::new();
</a>         loop {
             tokio::select! {
                 _ = ticker.tick() =&gt; node = node.tick()?,
<a href="#h13-4" id="h13-4" class="h">@@ -116,7 +116,7 @@ impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a>     async fn tcp_receive(
         mut listener: TcpListener,
         in_tx: mpsc::UnboundedSender&lt;Message&gt;,
<a href="#h13-4-3" id="h13-4-3" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h13-4-4" id="h13-4-4" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         while let Some(socket) = listener.try_next().await? {
             let peer = socket.peer_addr()?;
             let peer_in_tx = in_tx.clone();
<a href="#h13-5" id="h13-5" class="h">@@ -135,7 +135,7 @@ impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a>     async fn tcp_receive_peer(
         socket: TcpStream,
         in_tx: mpsc::UnboundedSender&lt;Message&gt;,
<a href="#h13-5-3" id="h13-5-3" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h13-5-4" id="h13-5-4" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         let mut stream = tokio_serde::SymmetricallyFramed::&lt;_, Message, _&gt;::new(
             Framed::new(socket, LengthDelimitedCodec::new()),
             tokio_serde::formats::SymmetricalBincode::&lt;Message&gt;::default(),
<a href="#h13-6" id="h13-6" class="h">@@ -151,7 +151,7 @@ impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a>         node_id: String,
         peers: HashMap&lt;String, String&gt;,
         mut out_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
<a href="#h13-6-3" id="h13-6-3" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h13-6-4" id="h13-6-4" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         let mut peer_txs: HashMap&lt;String, mpsc::Sender&lt;Message&gt;&gt; = HashMap::new();
 
         for (id, addr) in peers.into_iter() {
<a href="#h13-7" id="h13-7" class="h">@@ -210,7 +210,7 @@ impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a>     async fn tcp_send_peer_session(
         socket: TcpStream,
         out_rx: &amp;mut mpsc::Receiver&lt;Message&gt;,
<a href="#h13-7-3" id="h13-7-3" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h13-7-4" id="h13-7-4" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         let mut stream = tokio_serde::SymmetricallyFramed::&lt;_, Message, _&gt;::new(
             Framed::new(socket, LengthDelimitedCodec::new()),
             tokio_serde::formats::SymmetricalBincode::&lt;Message&gt;::default(),
<b>diff --git a/<a id="h14" href="../file/src/raft/state.rs.html">src/raft/state.rs</a> b/<a href="../file/src/raft/state.rs.html">src/raft/state.rs</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -1,5 +1,5 @@
</a> use super::{Address, Entry, Event, Message, Response, Scan, Status};
<a href="#h14-0-1" id="h14-0-1" class="d">-use crate::Error;
</a><a href="#h14-0-2" id="h14-0-2" class="i">+use crate::error::{Error, Result};
</a> 
 use log::{debug, error};
 use std::collections::{BTreeMap, HashMap, HashSet};
<a href="#h14-1" id="h14-1" class="h">@@ -13,10 +13,10 @@ pub trait State {
</a> 
     /// Mutates the state machine. If the state machine returns Error::Internal, the Raft node
     /// halts. For any other error, the state is applied and the error propagated to the caller.
<a href="#h14-1-3" id="h14-1-3" class="d">-    fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
</a><a href="#h14-1-4" id="h14-1-4" class="i">+    fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
</a> 
     /// Queries the state machine. All errors are propagated to the caller.
<a href="#h14-1-7" id="h14-1-7" class="d">-    fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
</a><a href="#h14-1-8" id="h14-1-8" class="i">+    fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
</a> }
 
 #[derive(Debug, PartialEq)]
<a href="#h14-2" id="h14-2" class="h">@@ -72,7 +72,7 @@ impl Driver {
</a>     }
 
     /// Drives a state machine.
<a href="#h14-2-3" id="h14-2-3" class="d">-    pub async fn drive&lt;S: State&gt;(mut self, mut state: S) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-2-4" id="h14-2-4" class="i">+    pub async fn drive&lt;S: State&gt;(mut self, mut state: S) -&gt; Result&lt;()&gt; {
</a>         debug!(&quot;Starting state machine driver&quot;);
         while let Some(instruction) = self.state_rx.next().await {
             if let Err(error) = self.execute(instruction, &amp;mut state).await {
<a href="#h14-3" id="h14-3" class="h">@@ -85,7 +85,7 @@ impl Driver {
</a>     }
 
     /// Synchronously (re)plays a set of log entries, for initial sync.
<a href="#h14-3-3" id="h14-3-3" class="d">-    pub fn replay&lt;&#39;a, S: State&gt;(&amp;mut self, state: &amp;mut S, mut scan: Scan&lt;&#39;a&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-3-4" id="h14-3-4" class="i">+    pub fn replay&lt;&#39;a, S: State&gt;(&amp;mut self, state: &amp;mut S, mut scan: Scan&lt;&#39;a&gt;) -&gt; Result&lt;()&gt; {
</a>         while let Some(entry) = scan.next().transpose()? {
             debug!(&quot;Replaying {:?}&quot;, entry);
             if let Some(command) = entry.command {
<a href="#h14-4" id="h14-4" class="h">@@ -99,7 +99,7 @@ impl Driver {
</a>     }
 
     /// Executes a state machine instruction.
<a href="#h14-4-3" id="h14-4-3" class="d">-    pub async fn execute&lt;S: State&gt;(&amp;mut self, i: Instruction, state: &amp;mut S) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-4-4" id="h14-4-4" class="i">+    pub async fn execute&lt;S: State&gt;(&amp;mut self, i: Instruction, state: &amp;mut S) -&gt; Result&lt;()&gt; {
</a>         debug!(&quot;Executing {:?}&quot;, i);
         match i {
             Instruction::Abort =&gt; {
<a href="#h14-5" id="h14-5" class="h">@@ -155,7 +155,7 @@ impl Driver {
</a>     }
 
     /// Aborts all pending notifications.
<a href="#h14-5-3" id="h14-5-3" class="d">-    fn notify_abort(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-5-4" id="h14-5-4" class="i">+    fn notify_abort(&amp;mut self) -&gt; Result&lt;()&gt; {
</a>         for (_, (address, id)) in std::mem::replace(&amp;mut self.notify, HashMap::new()) {
             self.send(address, Event::ClientResponse { id, response: Err(Error::Abort) })?;
         }
<a href="#h14-6" id="h14-6" class="h">@@ -163,7 +163,7 @@ impl Driver {
</a>     }
 
     /// Notifies a client about an applied log entry, if any.
<a href="#h14-6-3" id="h14-6-3" class="d">-    fn notify_applied(&amp;mut self, index: u64, result: Result&lt;Vec&lt;u8&gt;, Error&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-6-4" id="h14-6-4" class="i">+    fn notify_applied(&amp;mut self, index: u64, result: Result&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;()&gt; {
</a>         if let Some((to, id)) = self.notify.remove(&amp;index) {
             self.send(to, Event::ClientResponse { id, response: result.map(Response::State) })?;
         }
<a href="#h14-7" id="h14-7" class="h">@@ -171,7 +171,7 @@ impl Driver {
</a>     }
 
     /// Aborts all pending queries.
<a href="#h14-7-3" id="h14-7-3" class="d">-    fn query_abort(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-7-4" id="h14-7-4" class="i">+    fn query_abort(&amp;mut self) -&gt; Result&lt;()&gt; {
</a>         for (_, queries) in std::mem::replace(&amp;mut self.queries, BTreeMap::new()) {
             for (id, query) in queries {
                 self.send(
<a href="#h14-8" id="h14-8" class="h">@@ -184,7 +184,7 @@ impl Driver {
</a>     }
 
     /// Executes any queries that are ready.
<a href="#h14-8-3" id="h14-8-3" class="d">-    fn query_execute&lt;S: State&gt;(&amp;mut self, state: &amp;mut S) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-8-4" id="h14-8-4" class="i">+    fn query_execute&lt;S: State&gt;(&amp;mut self, state: &amp;mut S) -&gt; Result&lt;()&gt; {
</a>         for query in self.query_ready(self.applied_index) {
             debug!(&quot;Executing query {:?}&quot;, query.command);
             let result = state.query(query.command);
<a href="#h14-9" id="h14-9" class="h">@@ -235,7 +235,7 @@ impl Driver {
</a>     }
 
     /// Sends a message.
<a href="#h14-9-3" id="h14-9-3" class="d">-    fn send(&amp;self, to: Address, event: Event) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-9-4" id="h14-9-4" class="i">+    fn send(&amp;self, to: Address, event: Event) -&gt; Result&lt;()&gt; {
</a>         let msg = Message { from: Address::Local, to, term: 0, event };
         debug!(&quot;Sending {:?}&quot;, msg);
         Ok(self.node_tx.send(msg)?)
<a href="#h14-10" id="h14-10" class="h">@@ -273,23 +273,22 @@ pub mod tests {
</a>         }
 
         // Appends the command to the internal commands list.
<a href="#h14-10-3" id="h14-10-3" class="d">-        fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h14-10-4" id="h14-10-4" class="i">+        fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>             self.commands.lock()?.push(command.clone());
             *self.applied_index.lock()? = index;
             Ok(command)
         }
 
         // Appends the command to the internal commands list.
<a href="#h14-10-11" id="h14-10-11" class="d">-        fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h14-10-12" id="h14-10-12" class="i">+        fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>             self.commands.lock()?.push(command.clone());
             Ok(command)
         }
     }
 
<a href="#h14-10-18" id="h14-10-18" class="d">-    async fn setup() -&gt; Result&lt;
</a><a href="#h14-10-19" id="h14-10-19" class="d">-        (TestState, mpsc::UnboundedSender&lt;Instruction&gt;, mpsc::UnboundedReceiver&lt;Message&gt;),
</a><a href="#h14-10-20" id="h14-10-20" class="d">-        Error,
</a><a href="#h14-10-21" id="h14-10-21" class="d">-    &gt; {
</a><a href="#h14-10-22" id="h14-10-22" class="i">+    async fn setup(
</a><a href="#h14-10-23" id="h14-10-23" class="i">+    ) -&gt; Result&lt;(TestState, mpsc::UnboundedSender&lt;Instruction&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt;
</a><a href="#h14-10-24" id="h14-10-24" class="i">+    {
</a>         let state = TestState::new(0);
         let (state_tx, state_rx) = mpsc::unbounded_channel();
         let (node_tx, node_rx) = mpsc::unbounded_channel();
<a href="#h14-11" id="h14-11" class="h">@@ -298,7 +297,7 @@ pub mod tests {
</a>     }
 
     #[tokio::test(core_threads = 2)]
<a href="#h14-11-3" id="h14-11-3" class="d">-    async fn driver_abort() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-11-4" id="h14-11-4" class="i">+    async fn driver_abort() -&gt; Result&lt;()&gt; {
</a>         let (state, state_tx, node_rx) = setup().await?;
 
         state_tx.send(Instruction::Notify {
<a href="#h14-12" id="h14-12" class="h">@@ -341,7 +340,7 @@ pub mod tests {
</a>     }
 
     #[tokio::test(core_threads = 2)]
<a href="#h14-12-3" id="h14-12-3" class="d">-    async fn driver_apply() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-12-4" id="h14-12-4" class="i">+    async fn driver_apply() -&gt; Result&lt;()&gt; {
</a>         let (state, state_tx, node_rx) = setup().await?;
 
         state_tx.send(Instruction::Notify {
<a href="#h14-13" id="h14-13" class="h">@@ -373,7 +372,7 @@ pub mod tests {
</a>     }
 
     #[tokio::test(core_threads = 2)]
<a href="#h14-13-3" id="h14-13-3" class="d">-    async fn driver_query() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-13-4" id="h14-13-4" class="i">+    async fn driver_query() -&gt; Result&lt;()&gt; {
</a>         let (_, state_tx, node_rx) = setup().await?;
 
         state_tx.send(Instruction::Query {
<a href="#h14-14" id="h14-14" class="h">@@ -407,7 +406,7 @@ pub mod tests {
</a>     }
 
     #[tokio::test(core_threads = 2)]
<a href="#h14-14-3" id="h14-14-3" class="d">-    async fn driver_query_noquorum() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-14-4" id="h14-14-4" class="i">+    async fn driver_query_noquorum() -&gt; Result&lt;()&gt; {
</a>         let (_, state_tx, node_rx) = setup().await?;
 
         state_tx.send(Instruction::Query {
<b>diff --git a/<a id="h15" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -1,3 +1,4 @@
</a><a href="#h15-0-0" id="h15-0-0" class="i">+use crate::error::{Error, Result};
</a> use crate::raft;
 use crate::sql;
 use crate::sql::engine::{Engine as _, Mode};
<a href="#h15-1" id="h15-1" class="h">@@ -5,7 +6,6 @@ use crate::sql::execution::ResultSet;
</a> use crate::sql::schema::{Catalog as _, Table};
 use crate::sql::types::Row;
 use crate::storage::{kv, log};
<a href="#h15-1-3" id="h15-1-3" class="d">-use crate::Error;
</a> 
 use ::log::{error, info};
 use futures::sink::SinkExt as _;
<a href="#h15-2" id="h15-2" class="h">@@ -32,7 +32,7 @@ impl Server {
</a>         peers: HashMap&lt;String, String&gt;,
         dir: &amp;str,
         sync: bool,
<a href="#h15-2-3" id="h15-2-3" class="d">-    ) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h15-2-4" id="h15-2-4" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a>         let path = Path::new(dir);
         fs::create_dir_all(path)?;
         Ok(Server {
<a href="#h15-3" id="h15-3" class="h">@@ -50,7 +50,7 @@ impl Server {
</a>     }
 
     /// Starts listening on the given ports. Must be called before serve.
<a href="#h15-3-3" id="h15-3-3" class="d">-    pub async fn listen(mut self, sql_addr: &amp;str, raft_addr: &amp;str) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h15-3-4" id="h15-3-4" class="i">+    pub async fn listen(mut self, sql_addr: &amp;str, raft_addr: &amp;str) -&gt; Result&lt;Self&gt; {
</a>         let (sql, raft) =
             tokio::try_join!(TcpListener::bind(sql_addr), TcpListener::bind(raft_addr),)?;
         info!(&quot;Listening on {} (SQL) and {} (Raft)&quot;, sql.local_addr()?, raft.local_addr()?);
<a href="#h15-4" id="h15-4" class="h">@@ -60,7 +60,7 @@ impl Server {
</a>     }
 
     /// Serves Raft and SQL requests until the returned future is dropped. Consumes the server.
<a href="#h15-4-3" id="h15-4-3" class="d">-    pub async fn serve(self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h15-4-4" id="h15-4-4" class="i">+    pub async fn serve(self) -&gt; Result&lt;()&gt; {
</a>         let sql_listener = self
             .sql_listener
             .ok_or_else(|| Error::Internal(&quot;Must listen before serving&quot;.into()))?;
<a href="#h15-5" id="h15-5" class="h">@@ -78,7 +78,7 @@ impl Server {
</a>     }
 
     /// Serves SQL clients.
<a href="#h15-5-3" id="h15-5-3" class="d">-    async fn serve_sql(mut listener: TcpListener, engine: sql::engine::Raft) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h15-5-4" id="h15-5-4" class="i">+    async fn serve_sql(mut listener: TcpListener, engine: sql::engine::Raft) -&gt; Result&lt;()&gt; {
</a>         while let Some(socket) = listener.try_next().await? {
             let peer = socket.peer_addr()?;
             let session = Session::new(engine.clone())?;
<a href="#h15-6" id="h15-6" class="h">@@ -121,19 +121,19 @@ pub struct Session {
</a> 
 impl Session {
     /// Creates a new client session.
<a href="#h15-6-3" id="h15-6-3" class="d">-    fn new(engine: sql::engine::Raft) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h15-6-4" id="h15-6-4" class="i">+    fn new(engine: sql::engine::Raft) -&gt; Result&lt;Self&gt; {
</a>         Ok(Self { sql: engine.session()?, engine })
     }
 
     /// Handles a client connection.
<a href="#h15-6-9" id="h15-6-9" class="d">-    async fn handle(mut self, socket: TcpStream) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h15-6-10" id="h15-6-10" class="i">+    async fn handle(mut self, socket: TcpStream) -&gt; Result&lt;()&gt; {
</a>         let mut stream = tokio_serde::Framed::new(
             Framed::new(socket, LengthDelimitedCodec::new()),
             tokio_serde::formats::Bincode::default(),
         );
         while let Some(request) = stream.try_next().await? {
             let mut response = tokio::task::block_in_place(|| self.request(request));
<a href="#h15-6-17" id="h15-6-17" class="d">-            let mut rows: Box&lt;dyn Iterator&lt;Item = Result&lt;Response, Error&gt;&gt; + Send&gt; =
</a><a href="#h15-6-18" id="h15-6-18" class="i">+            let mut rows: Box&lt;dyn Iterator&lt;Item = Result&lt;Response&gt;&gt; + Send&gt; =
</a>                 Box::new(std::iter::empty());
             if let Ok(Response::Execute(ResultSet::Query { ref mut relation })) = &amp;mut response {
                 rows = Box::new(
<a href="#h15-7" id="h15-7" class="h">@@ -161,7 +161,7 @@ impl Session {
</a>     }
 
     /// Executes a request.
<a href="#h15-7-3" id="h15-7-3" class="d">-    pub fn request(&amp;mut self, request: Request) -&gt; Result&lt;Response, Error&gt; {
</a><a href="#h15-7-4" id="h15-7-4" class="i">+    pub fn request(&amp;mut self, request: Request) -&gt; Result&lt;Response&gt; {
</a>         Ok(match request {
             Request::Execute(query) =&gt; Response::Execute(self.sql.execute(&amp;query)?),
             Request::GetTable(table) =&gt; Response::GetTable(
<b>diff --git a/<a id="h16" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -1,8 +1,8 @@
</a> use super::super::schema::{Catalog, Table, Tables};
 use super::super::types::{Expression, Row, Value};
 use super::Transaction as _;
<a href="#h16-0-3" id="h16-0-3" class="i">+use crate::error::{Error, Result};
</a> use crate::storage::kv;
<a href="#h16-0-5" id="h16-0-5" class="d">-use crate::Error;
</a> 
 use serde::{Deserialize, Serialize};
 use std::collections::HashSet;
<a href="#h16-1" id="h16-1" class="h">@@ -27,12 +27,12 @@ impl&lt;S: kv::Store&gt; KV&lt;S&gt; {
</a>     }
 
     /// Fetches an unversioned metadata value
<a href="#h16-1-3" id="h16-1-3" class="d">-    pub fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h16-1-4" id="h16-1-4" class="i">+    pub fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         self.kv.get_metadata(key)
     }
 
     /// Sets an unversioned metadata value
<a href="#h16-1-9" id="h16-1-9" class="d">-    pub fn set_metadata(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-1-10" id="h16-1-10" class="i">+    pub fn set_metadata(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a>         self.kv.set_metadata(key, value)
     }
 }
<a href="#h16-2" id="h16-2" class="h">@@ -40,22 +40,22 @@ impl&lt;S: kv::Store&gt; KV&lt;S&gt; {
</a> impl&lt;S: kv::Store&gt; super::Engine for KV&lt;S&gt; {
     type Transaction = Transaction&lt;S&gt;;
 
<a href="#h16-2-3" id="h16-2-3" class="d">-    fn begin(&amp;self, mode: super::Mode) -&gt; Result&lt;Self::Transaction, Error&gt; {
</a><a href="#h16-2-4" id="h16-2-4" class="i">+    fn begin(&amp;self, mode: super::Mode) -&gt; Result&lt;Self::Transaction&gt; {
</a>         Ok(Self::Transaction::new(self.kv.begin_with_mode(mode)?))
     }
 
<a href="#h16-2-8" id="h16-2-8" class="d">-    fn resume(&amp;self, id: u64) -&gt; Result&lt;Self::Transaction, Error&gt; {
</a><a href="#h16-2-9" id="h16-2-9" class="i">+    fn resume(&amp;self, id: u64) -&gt; Result&lt;Self::Transaction&gt; {
</a>         Ok(Self::Transaction::new(self.kv.resume(id)?))
     }
 }
 
 /// Serializes SQL metadata.
<a href="#h16-2-15" id="h16-2-15" class="d">-fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h16-2-16" id="h16-2-16" class="i">+fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>     Ok(bincode::serialize(value)?)
 }
 
 /// Deserializes SQL metadata.
<a href="#h16-2-21" id="h16-2-21" class="d">-fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V, Error&gt; {
</a><a href="#h16-2-22" id="h16-2-22" class="i">+fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a>     Ok(bincode::deserialize(bytes)?)
 }
 
<a href="#h16-3" id="h16-3" class="h">@@ -71,12 +71,7 @@ impl&lt;S: kv::Store&gt; Transaction&lt;S&gt; {
</a>     }
 
     /// Loads an index entry
<a href="#h16-3-3" id="h16-3-3" class="d">-    fn index_load(
</a><a href="#h16-3-4" id="h16-3-4" class="d">-        &amp;self,
</a><a href="#h16-3-5" id="h16-3-5" class="d">-        table: &amp;str,
</a><a href="#h16-3-6" id="h16-3-6" class="d">-        column: &amp;str,
</a><a href="#h16-3-7" id="h16-3-7" class="d">-        value: &amp;Value,
</a><a href="#h16-3-8" id="h16-3-8" class="d">-    ) -&gt; Result&lt;HashSet&lt;Value&gt;, Error&gt; {
</a><a href="#h16-3-9" id="h16-3-9" class="i">+    fn index_load(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
</a>         let key = Key::Index(table, column, Some(value)).encode();
         if let Some(value) = self.txn.get(&amp;key)? {
             let item: (Value, HashSet&lt;Value&gt;) = deserialize(&amp;value)?;
<a href="#h16-4" id="h16-4" class="h">@@ -95,7 +90,7 @@ impl&lt;S: kv::Store&gt; Transaction&lt;S&gt; {
</a>         column: &amp;str,
         value: &amp;Value,
         index: HashSet&lt;Value&gt;,
<a href="#h16-4-3" id="h16-4-3" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-4-4" id="h16-4-4" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         let key = Key::Index(table, column, Some(value)).encode();
         if index.is_empty() {
             self.txn.delete(&amp;key)
<a href="#h16-5" id="h16-5" class="h">@@ -114,15 +109,15 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>         self.txn.mode()
     }
 
<a href="#h16-5-3" id="h16-5-3" class="d">-    fn commit(self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-5-4" id="h16-5-4" class="i">+    fn commit(self) -&gt; Result&lt;()&gt; {
</a>         self.txn.commit()
     }
 
<a href="#h16-5-8" id="h16-5-8" class="d">-    fn rollback(self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-5-9" id="h16-5-9" class="i">+    fn rollback(self) -&gt; Result&lt;()&gt; {
</a>         self.txn.rollback()
     }
 
<a href="#h16-5-13" id="h16-5-13" class="d">-    fn create(&amp;mut self, table: &amp;str, row: Row) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-5-14" id="h16-5-14" class="i">+    fn create(&amp;mut self, table: &amp;str, row: Row) -&gt; Result&lt;()&gt; {
</a>         let table = self.must_read_table(&amp;table)?;
         table.validate_row(&amp;row, self)?;
         let id = table.get_row_key(&amp;row)?;
<a href="#h16-6" id="h16-6" class="h">@@ -143,7 +138,7 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>         Ok(())
     }
 
<a href="#h16-6-3" id="h16-6-3" class="d">-    fn delete(&amp;mut self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-6-4" id="h16-6-4" class="i">+    fn delete(&amp;mut self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;()&gt; {
</a>         let table = self.must_read_table(&amp;table)?;
         table.assert_unreferenced_key(id, self)?;
 
<a href="#h16-7" id="h16-7" class="h">@@ -160,23 +155,18 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>         self.txn.delete(&amp;Key::Row(&amp;table.name, Some(id)).encode())
     }
 
<a href="#h16-7-3" id="h16-7-3" class="d">-    fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;, Error&gt; {
</a><a href="#h16-7-4" id="h16-7-4" class="i">+    fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
</a>         self.txn.get(&amp;Key::Row(table, Some(id)).encode())?.map(|v| deserialize(&amp;v)).transpose()
     }
 
<a href="#h16-7-8" id="h16-7-8" class="d">-    fn read_index(
</a><a href="#h16-7-9" id="h16-7-9" class="d">-        &amp;self,
</a><a href="#h16-7-10" id="h16-7-10" class="d">-        table: &amp;str,
</a><a href="#h16-7-11" id="h16-7-11" class="d">-        column: &amp;str,
</a><a href="#h16-7-12" id="h16-7-12" class="d">-        value: &amp;Value,
</a><a href="#h16-7-13" id="h16-7-13" class="d">-    ) -&gt; Result&lt;HashSet&lt;Value&gt;, Error&gt; {
</a><a href="#h16-7-14" id="h16-7-14" class="i">+    fn read_index(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
</a>         if !self.must_read_table(table)?.get_column(column)?.index {
             return Err(Error::Value(format!(&quot;No index on {}.{}&quot;, table, column)));
         }
         self.index_load(table, column, value)
     }
 
<a href="#h16-7-21" id="h16-7-21" class="d">-    fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;super::Scan, Error&gt; {
</a><a href="#h16-7-22" id="h16-7-22" class="i">+    fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;super::Scan&gt; {
</a>         let table = self.must_read_table(&amp;table)?;
         let scan = self
             .txn
<a href="#h16-8" id="h16-8" class="h">@@ -199,10 +189,10 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>             });
 
         // FIXME We buffer results here, to avoid dealing with trait lifetimes right now
<a href="#h16-8-3" id="h16-8-3" class="d">-        Ok(Box::new(scan.collect::&lt;Vec&lt;Result&lt;Row, Error&gt;&gt;&gt;().into_iter()))
</a><a href="#h16-8-4" id="h16-8-4" class="i">+        Ok(Box::new(scan.collect::&lt;Vec&lt;Result&lt;Row&gt;&gt;&gt;().into_iter()))
</a>     }
 
<a href="#h16-8-7" id="h16-8-7" class="d">-    fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;super::IndexScan, Error&gt; {
</a><a href="#h16-8-8" id="h16-8-8" class="i">+    fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;super::IndexScan&gt; {
</a>         let table = self.must_read_table(&amp;table)?;
         let column = table.get_column(column)?;
         if !column.index {
<a href="#h16-9" id="h16-9" class="h">@@ -215,10 +205,10 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>             .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)));
 
         // FIXME We buffer results here, to avoid dealing with trait lifetimes right now
<a href="#h16-9-3" id="h16-9-3" class="d">-        Ok(Box::new(scan.collect::&lt;Vec&lt;Result&lt;(Value, HashSet&lt;Value&gt;), Error&gt;&gt;&gt;().into_iter()))
</a><a href="#h16-9-4" id="h16-9-4" class="i">+        Ok(Box::new(scan.collect::&lt;Vec&lt;Result&lt;(Value, HashSet&lt;Value&gt;)&gt;&gt;&gt;().into_iter()))
</a>     }
 
<a href="#h16-9-7" id="h16-9-7" class="d">-    fn update(&amp;mut self, table: &amp;str, id: &amp;Value, row: Row) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-9-8" id="h16-9-8" class="i">+    fn update(&amp;mut self, table: &amp;str, id: &amp;Value, row: Row) -&gt; Result&lt;()&gt; {
</a>         let table = self.must_read_table(&amp;table)?;
         // If the primary key changes we do a delete and create, otherwise we replace the row
         if id != &amp;table.get_row_key(&amp;row)? {
<a href="#h16-10" id="h16-10" class="h">@@ -251,7 +241,7 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a> }
 
 impl&lt;S: kv::Store&gt; Catalog for Transaction&lt;S&gt; {
<a href="#h16-10-3" id="h16-10-3" class="d">-    fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-10-4" id="h16-10-4" class="i">+    fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;()&gt; {
</a>         if self.read_table(&amp;table.name)?.is_some() {
             return Err(Error::Value(format!(&quot;Table {} already exists&quot;, table.name)));
         }
<a href="#h16-11" id="h16-11" class="h">@@ -259,7 +249,7 @@ impl&lt;S: kv::Store&gt; Catalog for Transaction&lt;S&gt; {
</a>         self.txn.set(&amp;Key::Table(Some(&amp;table.name)).encode(), serialize(table)?)
     }
 
<a href="#h16-11-3" id="h16-11-3" class="d">-    fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-11-4" id="h16-11-4" class="i">+    fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;()&gt; {
</a>         let table = self.must_read_table(&amp;table)?;
         table.assert_unreferenced(self)?;
         let mut scan = self.scan(&amp;table.name, None)?;
<a href="#h16-12" id="h16-12" class="h">@@ -269,16 +259,16 @@ impl&lt;S: kv::Store&gt; Catalog for Transaction&lt;S&gt; {
</a>         self.txn.delete(&amp;Key::Table(Some(&amp;table.name)).encode())
     }
 
<a href="#h16-12-3" id="h16-12-3" class="d">-    fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;, Error&gt; {
</a><a href="#h16-12-4" id="h16-12-4" class="i">+    fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;&gt; {
</a>         self.txn.get(&amp;Key::Table(Some(table)).encode())?.map(|v| deserialize(&amp;v)).transpose()
     }
 
<a href="#h16-12-8" id="h16-12-8" class="d">-    fn scan_tables(&amp;self) -&gt; Result&lt;Tables, Error&gt; {
</a><a href="#h16-12-9" id="h16-12-9" class="i">+    fn scan_tables(&amp;self) -&gt; Result&lt;Tables&gt; {
</a>         Ok(Box::new(
             self.txn
                 .scan_prefix(&amp;Key::Table(None).encode())?
                 .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)))
<a href="#h16-12-14" id="h16-12-14" class="d">-                .collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h16-12-15" id="h16-12-15" class="i">+                .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>                 .into_iter(),
         ))
     }
<b>diff --git a/<a id="h17" href="../file/src/sql/engine/mod.rs.html">src/sql/engine/mod.rs</a> b/<a href="../file/src/sql/engine/mod.rs.html">src/sql/engine/mod.rs</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -9,7 +9,7 @@ use super::parser::{ast, Parser};
</a> use super::plan::Plan;
 use super::schema::Catalog;
 use super::types::{Expression, Row, Value};
<a href="#h17-0-3" id="h17-0-3" class="d">-use crate::Error;
</a><a href="#h17-0-4" id="h17-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 use std::collections::HashSet;
 
<a href="#h17-1" id="h17-1" class="h">@@ -19,15 +19,15 @@ pub trait Engine: Clone {
</a>     type Transaction: Transaction;
 
     /// Begins a transaction in the given mode
<a href="#h17-1-3" id="h17-1-3" class="d">-    fn begin(&amp;self, mode: Mode) -&gt; Result&lt;Self::Transaction, Error&gt;;
</a><a href="#h17-1-4" id="h17-1-4" class="i">+    fn begin(&amp;self, mode: Mode) -&gt; Result&lt;Self::Transaction&gt;;
</a> 
     /// Begins a session for executing individual statements
<a href="#h17-1-7" id="h17-1-7" class="d">-    fn session(&amp;self) -&gt; Result&lt;Session&lt;Self&gt;, Error&gt; {
</a><a href="#h17-1-8" id="h17-1-8" class="i">+    fn session(&amp;self) -&gt; Result&lt;Session&lt;Self&gt;&gt; {
</a>         Ok(Session { engine: self.clone(), txn: None })
     }
 
     /// Resumes an active transaction with the given ID
<a href="#h17-1-13" id="h17-1-13" class="d">-    fn resume(&amp;self, id: u64) -&gt; Result&lt;Self::Transaction, Error&gt;;
</a><a href="#h17-1-14" id="h17-1-14" class="i">+    fn resume(&amp;self, id: u64) -&gt; Result&lt;Self::Transaction&gt;;
</a> }
 
 /// An SQL transaction
<a href="#h17-2" id="h17-2" class="h">@@ -37,25 +37,24 @@ pub trait Transaction: Catalog {
</a>     /// The transaction mode
     fn mode(&amp;self) -&gt; Mode;
     /// Commits the transaction
<a href="#h17-2-3" id="h17-2-3" class="d">-    fn commit(self) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h17-2-4" id="h17-2-4" class="i">+    fn commit(self) -&gt; Result&lt;()&gt;;
</a>     /// Rolls back the transaction
<a href="#h17-2-6" id="h17-2-6" class="d">-    fn rollback(self) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h17-2-7" id="h17-2-7" class="i">+    fn rollback(self) -&gt; Result&lt;()&gt;;
</a> 
     /// Creates a new table row
<a href="#h17-2-10" id="h17-2-10" class="d">-    fn create(&amp;mut self, table: &amp;str, row: Row) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h17-2-11" id="h17-2-11" class="i">+    fn create(&amp;mut self, table: &amp;str, row: Row) -&gt; Result&lt;()&gt;;
</a>     /// Deletes a table row
<a href="#h17-2-13" id="h17-2-13" class="d">-    fn delete(&amp;mut self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h17-2-14" id="h17-2-14" class="i">+    fn delete(&amp;mut self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;()&gt;;
</a>     /// Reads a table row, if it exists
<a href="#h17-2-16" id="h17-2-16" class="d">-    fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;, Error&gt;;
</a><a href="#h17-2-17" id="h17-2-17" class="i">+    fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;&gt;;
</a>     /// Reads an index entry, if it exists
<a href="#h17-2-19" id="h17-2-19" class="d">-    fn read_index(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value)
</a><a href="#h17-2-20" id="h17-2-20" class="d">-        -&gt; Result&lt;HashSet&lt;Value&gt;, Error&gt;;
</a><a href="#h17-2-21" id="h17-2-21" class="i">+    fn read_index(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value) -&gt; Result&lt;HashSet&lt;Value&gt;&gt;;
</a>     /// Scans a table&#39;s rows
<a href="#h17-2-23" id="h17-2-23" class="d">-    fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Scan, Error&gt;;
</a><a href="#h17-2-24" id="h17-2-24" class="i">+    fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Scan&gt;;
</a>     /// Scans a column&#39;s index entries
<a href="#h17-2-26" id="h17-2-26" class="d">-    fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;IndexScan, Error&gt;;
</a><a href="#h17-2-27" id="h17-2-27" class="i">+    fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;IndexScan&gt;;
</a>     /// Updates a table row
<a href="#h17-2-29" id="h17-2-29" class="d">-    fn update(&amp;mut self, table: &amp;str, id: &amp;Value, row: Row) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h17-2-30" id="h17-2-30" class="i">+    fn update(&amp;mut self, table: &amp;str, id: &amp;Value, row: Row) -&gt; Result&lt;()&gt;;
</a> }
 
 /// An SQL session, which handles transaction control and simplified query execution
<a href="#h17-3" id="h17-3" class="h">@@ -68,7 +67,7 @@ pub struct Session&lt;E: Engine&gt; {
</a> 
 impl&lt;E: Engine + &#39;static&gt; Session&lt;E&gt; {
     /// Executes a query, managing transaction status for the session
<a href="#h17-3-3" id="h17-3-3" class="d">-    pub fn execute(&amp;mut self, query: &amp;str) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h17-3-4" id="h17-3-4" class="i">+    pub fn execute(&amp;mut self, query: &amp;str) -&gt; Result&lt;ResultSet&gt; {
</a>         // FIXME We should match on self.txn as well, but get this error:
         // error[E0009]: cannot bind by-move and by-ref in the same pattern
         // ...which seems like an arbitrary compiler limitation
<a href="#h17-4" id="h17-4" class="h">@@ -143,9 +142,9 @@ impl&lt;E: Engine + &#39;static&gt; Session&lt;E&gt; {
</a>     }
 
     /// Runs a closure in the session&#39;s transaction, or a new transaction if none is active.
<a href="#h17-4-3" id="h17-4-3" class="d">-    pub fn with_txn&lt;R, F&gt;(&amp;mut self, mode: Mode, f: F) -&gt; Result&lt;R, Error&gt;
</a><a href="#h17-4-4" id="h17-4-4" class="i">+    pub fn with_txn&lt;R, F&gt;(&amp;mut self, mode: Mode, f: F) -&gt; Result&lt;R&gt;
</a>     where
<a href="#h17-4-6" id="h17-4-6" class="d">-        F: FnOnce(&amp;mut E::Transaction) -&gt; Result&lt;R, Error&gt;,
</a><a href="#h17-4-7" id="h17-4-7" class="i">+        F: FnOnce(&amp;mut E::Transaction) -&gt; Result&lt;R&gt;,
</a>     {
         if let Some(ref mut txn) = self.txn {
             if !txn.mode().satisfies(&amp;mode) {
<a href="#h17-5" id="h17-5" class="h">@@ -166,8 +165,7 @@ impl&lt;E: Engine + &#39;static&gt; Session&lt;E&gt; {
</a> pub type Mode = crate::storage::kv::mvcc::Mode;
 
 /// A row scan iterator
<a href="#h17-5-3" id="h17-5-3" class="d">-pub type Scan = Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;Row, Error&gt;&gt; + Send&gt;;
</a><a href="#h17-5-4" id="h17-5-4" class="i">+pub type Scan = Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;Row&gt;&gt; + Send&gt;;
</a> 
 /// An index scan iterator
<a href="#h17-5-7" id="h17-5-7" class="d">-pub type IndexScan =
</a><a href="#h17-5-8" id="h17-5-8" class="d">-    Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Value, HashSet&lt;Value&gt;), Error&gt;&gt; + Send&gt;;
</a><a href="#h17-5-9" id="h17-5-9" class="i">+pub type IndexScan = Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Value, HashSet&lt;Value&gt;)&gt;&gt; + Send&gt;;
</a><b>diff --git a/<a id="h18" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -1,9 +1,9 @@
</a> use super::super::schema::{Catalog, Table, Tables};
 use super::super::types::{Expression, Row, Value};
 use super::{Engine as _, IndexScan, Mode, Scan, Transaction as _};
<a href="#h18-0-3" id="h18-0-3" class="i">+use crate::error::{Error, Result};
</a> use crate::raft;
 use crate::storage::kv;
<a href="#h18-0-6" id="h18-0-6" class="d">-use crate::Error;
</a> 
 use serde::{Deserialize, Serialize};
 use serde_derive::{Deserialize, Serialize};
<a href="#h18-1" id="h18-1" class="h">@@ -75,12 +75,12 @@ impl Raft {
</a>     }
 
     /// Creates an underlying state machine for a Raft engine.
<a href="#h18-1-3" id="h18-1-3" class="d">-    pub fn new_state&lt;S: kv::Store&gt;(kv: kv::MVCC&lt;S&gt;) -&gt; Result&lt;State&lt;S&gt;, Error&gt; {
</a><a href="#h18-1-4" id="h18-1-4" class="i">+    pub fn new_state&lt;S: kv::Store&gt;(kv: kv::MVCC&lt;S&gt;) -&gt; Result&lt;State&lt;S&gt;&gt; {
</a>         State::new(kv)
     }
 
     /// Returns Raft SQL engine status.
<a href="#h18-1-9" id="h18-1-9" class="d">-    pub fn status(&amp;self) -&gt; Result&lt;Status, Error&gt; {
</a><a href="#h18-1-10" id="h18-1-10" class="i">+    pub fn status(&amp;self) -&gt; Result&lt;Status&gt; {
</a>         Ok(Status {
             raft: futures::executor::block_on(self.client.status())?,
             mvcc: Raft::deserialize(&amp;futures::executor::block_on(
<a href="#h18-2" id="h18-2" class="h">@@ -90,12 +90,12 @@ impl Raft {
</a>     }
 
     /// Serializes a command for the Raft SQL state machine.
<a href="#h18-2-3" id="h18-2-3" class="d">-    fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h18-2-4" id="h18-2-4" class="i">+    fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         Ok(bincode::serialize(value)?)
     }
 
     /// Deserializes a command for the Raft SQL state machine.
<a href="#h18-2-9" id="h18-2-9" class="d">-    fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V, Error&gt; {
</a><a href="#h18-2-10" id="h18-2-10" class="i">+    fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a>         Ok(bincode::deserialize(bytes)?)
     }
 }
<a href="#h18-3" id="h18-3" class="h">@@ -103,11 +103,11 @@ impl Raft {
</a> impl super::Engine for Raft {
     type Transaction = Transaction;
 
<a href="#h18-3-3" id="h18-3-3" class="d">-    fn begin(&amp;self, mode: Mode) -&gt; Result&lt;Self::Transaction, Error&gt; {
</a><a href="#h18-3-4" id="h18-3-4" class="i">+    fn begin(&amp;self, mode: Mode) -&gt; Result&lt;Self::Transaction&gt; {
</a>         Transaction::begin(self.client.clone(), mode)
     }
 
<a href="#h18-3-8" id="h18-3-8" class="d">-    fn resume(&amp;self, id: u64) -&gt; Result&lt;Self::Transaction, Error&gt; {
</a><a href="#h18-3-9" id="h18-3-9" class="i">+    fn resume(&amp;self, id: u64) -&gt; Result&lt;Self::Transaction&gt; {
</a>         Transaction::resume(self.client.clone(), id)
     }
 }
<a href="#h18-4" id="h18-4" class="h">@@ -125,7 +125,7 @@ pub struct Transaction {
</a> 
 impl Transaction {
     /// Starts a transaction in the given mode
<a href="#h18-4-3" id="h18-4-3" class="d">-    fn begin(client: raft::Client, mode: Mode) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h18-4-4" id="h18-4-4" class="i">+    fn begin(client: raft::Client, mode: Mode) -&gt; Result&lt;Self&gt; {
</a>         let id = Raft::deserialize(&amp;futures::executor::block_on(
             client.mutate(Raft::serialize(&amp;Mutation::Begin(mode))?),
         )?)?;
<a href="#h18-5" id="h18-5" class="h">@@ -133,7 +133,7 @@ impl Transaction {
</a>     }
 
     /// Resumes an active transaction
<a href="#h18-5-3" id="h18-5-3" class="d">-    fn resume(client: raft::Client, id: u64) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h18-5-4" id="h18-5-4" class="i">+    fn resume(client: raft::Client, id: u64) -&gt; Result&lt;Self&gt; {
</a>         let (id, mode) = Raft::deserialize(&amp;futures::executor::block_on(
             client.query(Raft::serialize(&amp;Query::Resume(id))?),
         )?)?;
<a href="#h18-6" id="h18-6" class="h">@@ -141,12 +141,12 @@ impl Transaction {
</a>     }
 
     /// Executes a mutation
<a href="#h18-6-3" id="h18-6-3" class="d">-    fn mutate(&amp;self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h18-6-4" id="h18-6-4" class="i">+    fn mutate(&amp;self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         futures::executor::block_on(self.client.mutate(Raft::serialize(&amp;mutation)?))
     }
 
     /// Executes a query
<a href="#h18-6-9" id="h18-6-9" class="d">-    fn query(&amp;self, query: Query) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h18-6-10" id="h18-6-10" class="i">+    fn query(&amp;self, query: Query) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         futures::executor::block_on(self.client.query(Raft::serialize(&amp;query)?))
     }
 }
<a href="#h18-7" id="h18-7" class="h">@@ -160,15 +160,15 @@ impl super::Transaction for Transaction {
</a>         self.mode
     }
 
<a href="#h18-7-3" id="h18-7-3" class="d">-    fn commit(self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-7-4" id="h18-7-4" class="i">+    fn commit(self) -&gt; Result&lt;()&gt; {
</a>         Raft::deserialize(&amp;self.mutate(Mutation::Commit(self.id))?)
     }
 
<a href="#h18-7-8" id="h18-7-8" class="d">-    fn rollback(self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-7-9" id="h18-7-9" class="i">+    fn rollback(self) -&gt; Result&lt;()&gt; {
</a>         Raft::deserialize(&amp;self.mutate(Mutation::Rollback(self.id))?)
     }
 
<a href="#h18-7-13" id="h18-7-13" class="d">-    fn create(&amp;mut self, table: &amp;str, row: Row) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-7-14" id="h18-7-14" class="i">+    fn create(&amp;mut self, table: &amp;str, row: Row) -&gt; Result&lt;()&gt; {
</a>         Raft::deserialize(&amp;self.mutate(Mutation::Create {
             txn_id: self.id,
             table: table.to_string(),
<a href="#h18-8" id="h18-8" class="h">@@ -176,7 +176,7 @@ impl super::Transaction for Transaction {
</a>         })?)
     }
 
<a href="#h18-8-3" id="h18-8-3" class="d">-    fn delete(&amp;mut self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-8-4" id="h18-8-4" class="i">+    fn delete(&amp;mut self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;()&gt; {
</a>         Raft::deserialize(&amp;self.mutate(Mutation::Delete {
             txn_id: self.id,
             table: table.to_string(),
<a href="#h18-9" id="h18-9" class="h">@@ -184,7 +184,7 @@ impl super::Transaction for Transaction {
</a>         })?)
     }
 
<a href="#h18-9-3" id="h18-9-3" class="d">-    fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;, Error&gt; {
</a><a href="#h18-9-4" id="h18-9-4" class="i">+    fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
</a>         Raft::deserialize(&amp;self.query(Query::Read {
             txn_id: self.id,
             table: table.to_string(),
<a href="#h18-10" id="h18-10" class="h">@@ -192,12 +192,7 @@ impl super::Transaction for Transaction {
</a>         })?)
     }
 
<a href="#h18-10-3" id="h18-10-3" class="d">-    fn read_index(
</a><a href="#h18-10-4" id="h18-10-4" class="d">-        &amp;self,
</a><a href="#h18-10-5" id="h18-10-5" class="d">-        table: &amp;str,
</a><a href="#h18-10-6" id="h18-10-6" class="d">-        column: &amp;str,
</a><a href="#h18-10-7" id="h18-10-7" class="d">-        value: &amp;Value,
</a><a href="#h18-10-8" id="h18-10-8" class="d">-    ) -&gt; Result&lt;HashSet&lt;Value&gt;, Error&gt; {
</a><a href="#h18-10-9" id="h18-10-9" class="i">+    fn read_index(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
</a>         Raft::deserialize(&amp;self.query(Query::ReadIndex {
             txn_id: self.id,
             table: table.to_string(),
<a href="#h18-11" id="h18-11" class="h">@@ -206,7 +201,7 @@ impl super::Transaction for Transaction {
</a>         })?)
     }
 
<a href="#h18-11-3" id="h18-11-3" class="d">-    fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Scan, Error&gt; {
</a><a href="#h18-11-4" id="h18-11-4" class="i">+    fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Scan&gt; {
</a>         Ok(Box::new(
             Raft::deserialize::&lt;Vec&lt;_&gt;&gt;(&amp;self.query(Query::Scan {
                 txn_id: self.id,
<a href="#h18-12" id="h18-12" class="h">@@ -218,7 +213,7 @@ impl super::Transaction for Transaction {
</a>         ))
     }
 
<a href="#h18-12-3" id="h18-12-3" class="d">-    fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;IndexScan, Error&gt; {
</a><a href="#h18-12-4" id="h18-12-4" class="i">+    fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;IndexScan&gt; {
</a>         Ok(Box::new(
             Raft::deserialize::&lt;Vec&lt;_&gt;&gt;(&amp;self.query(Query::ScanIndex {
                 txn_id: self.id,
<a href="#h18-13" id="h18-13" class="h">@@ -230,7 +225,7 @@ impl super::Transaction for Transaction {
</a>         ))
     }
 
<a href="#h18-13-3" id="h18-13-3" class="d">-    fn update(&amp;mut self, table: &amp;str, id: &amp;Value, row: Row) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-13-4" id="h18-13-4" class="i">+    fn update(&amp;mut self, table: &amp;str, id: &amp;Value, row: Row) -&gt; Result&lt;()&gt; {
</a>         Raft::deserialize(&amp;self.mutate(Mutation::Update {
             txn_id: self.id,
             table: table.to_string(),
<a href="#h18-14" id="h18-14" class="h">@@ -241,25 +236,25 @@ impl super::Transaction for Transaction {
</a> }
 
 impl Catalog for Transaction {
<a href="#h18-14-3" id="h18-14-3" class="d">-    fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-14-4" id="h18-14-4" class="i">+    fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;()&gt; {
</a>         Raft::deserialize(
             &amp;self.mutate(Mutation::CreateTable { txn_id: self.id, schema: table.clone() })?,
         )
     }
 
<a href="#h18-14-10" id="h18-14-10" class="d">-    fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-14-11" id="h18-14-11" class="i">+    fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;()&gt; {
</a>         Raft::deserialize(
             &amp;self.mutate(Mutation::DeleteTable { txn_id: self.id, table: table.to_string() })?,
         )
     }
 
<a href="#h18-14-17" id="h18-14-17" class="d">-    fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;, Error&gt; {
</a><a href="#h18-14-18" id="h18-14-18" class="i">+    fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;&gt; {
</a>         Raft::deserialize(
             &amp;self.query(Query::ReadTable { txn_id: self.id, table: table.to_string() })?,
         )
     }
 
<a href="#h18-14-24" id="h18-14-24" class="d">-    fn scan_tables(&amp;self) -&gt; Result&lt;Tables, Error&gt; {
</a><a href="#h18-14-25" id="h18-14-25" class="i">+    fn scan_tables(&amp;self) -&gt; Result&lt;Tables&gt; {
</a>         Ok(Box::new(
             Raft::deserialize::&lt;Vec&lt;_&gt;&gt;(&amp;self.query(Query::ScanTables { txn_id: self.id })?)?
                 .into_iter(),
<a href="#h18-15" id="h18-15" class="h">@@ -277,7 +272,7 @@ pub struct State&lt;S: kv::Store&gt; {
</a> 
 impl&lt;S: kv::Store&gt; State&lt;S&gt; {
     /// Creates a new Raft state maching using the given MVCC key/value store
<a href="#h18-15-3" id="h18-15-3" class="d">-    pub fn new(store: kv::MVCC&lt;S&gt;) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h18-15-4" id="h18-15-4" class="i">+    pub fn new(store: kv::MVCC&lt;S&gt;) -&gt; Result&lt;Self&gt; {
</a>         let engine = super::KV::new(store);
         let applied_index = engine
             .get_metadata(b&quot;applied_index&quot;)?
<a href="#h18-16" id="h18-16" class="h">@@ -287,7 +282,7 @@ impl&lt;S: kv::Store&gt; State&lt;S&gt; {
</a>     }
 
     /// Applies a state machine mutation
<a href="#h18-16-3" id="h18-16-3" class="d">-    fn apply(&amp;mut self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h18-16-4" id="h18-16-4" class="i">+    fn apply(&amp;mut self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         match mutation {
             Mutation::Begin(mode) =&gt; Raft::serialize(&amp;self.engine.begin(mode)?.id()),
             Mutation::Commit(txn_id) =&gt; Raft::serialize(&amp;self.engine.resume(txn_id)?.commit()?),
<a href="#h18-17" id="h18-17" class="h">@@ -318,7 +313,7 @@ impl&lt;S: kv::Store&gt; raft::State for State&lt;S&gt; {
</a>         self.applied_index
     }
 
<a href="#h18-17-3" id="h18-17-3" class="d">-    fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h18-17-4" id="h18-17-4" class="i">+    fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         // We don&#39;t check that index == applied_index + 1, since the Raft log commits no-op
         // entries during leader election which we need to ignore.
         match self.apply(Raft::deserialize(&amp;command)?) {
<a href="#h18-18" id="h18-18" class="h">@@ -331,7 +326,7 @@ impl&lt;S: kv::Store&gt; raft::State for State&lt;S&gt; {
</a>         }
     }
 
<a href="#h18-18-3" id="h18-18-3" class="d">-    fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h18-18-4" id="h18-18-4" class="i">+    fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         match Raft::deserialize(&amp;command)? {
             Query::Resume(id) =&gt; {
                 let txn = self.engine.resume(id)?;
<a href="#h18-19" id="h18-19" class="h">@@ -346,18 +341,14 @@ impl&lt;S: kv::Store&gt; raft::State for State&lt;S&gt; {
</a>             }
             // FIXME These need to stream rows somehow
             Query::Scan { txn_id, table, filter } =&gt; Raft::serialize(
<a href="#h18-19-3" id="h18-19-3" class="d">-                &amp;self
</a><a href="#h18-19-4" id="h18-19-4" class="d">-                    .engine
</a><a href="#h18-19-5" id="h18-19-5" class="d">-                    .resume(txn_id)?
</a><a href="#h18-19-6" id="h18-19-6" class="d">-                    .scan(&amp;table, filter)?
</a><a href="#h18-19-7" id="h18-19-7" class="d">-                    .collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?,
</a><a href="#h18-19-8" id="h18-19-8" class="i">+                &amp;self.engine.resume(txn_id)?.scan(&amp;table, filter)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             ),
             Query::ScanIndex { txn_id, table, column } =&gt; Raft::serialize(
                 &amp;self
                     .engine
                     .resume(txn_id)?
                     .scan_index(&amp;table, &amp;column)?
<a href="#h18-19-15" id="h18-19-15" class="d">-                    .collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?,
</a><a href="#h18-19-16" id="h18-19-16" class="i">+                    .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>             ),
             Query::Status =&gt; Raft::serialize(&amp;self.engine.kv.status()?),
 
<b>diff --git a/<a id="h19" href="../file/src/sql/execution/aggregation.rs.html">src/sql/execution/aggregation.rs</a> b/<a href="../file/src/sql/execution/aggregation.rs.html">src/sql/execution/aggregation.rs</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -2,7 +2,7 @@ use super::super::engine::Transaction;
</a> use super::super::plan::Aggregate;
 use super::super::types::{Column, Relation, Value};
 use super::{Context, Executor, ResultSet};
<a href="#h19-0-3" id="h19-0-3" class="d">-use crate::Error;
</a><a href="#h19-0-4" id="h19-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 use std::cmp::Ordering;
 use std::collections::HashMap;
<a href="#h19-1" id="h19-1" class="h">@@ -25,7 +25,7 @@ impl&lt;T: Transaction&gt; Aggregation&lt;T&gt; {
</a> 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Aggregation&lt;T&gt; {
     #[allow(clippy::or_fun_call)]
<a href="#h19-1-3" id="h19-1-3" class="d">-    fn execute(mut self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h19-1-4" id="h19-1-4" class="i">+    fn execute(mut self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let agg_count = self.aggregates.len();
         match self.source.execute(ctx)? {
             ResultSet::Query { mut relation } =&gt; {
<a href="#h19-2" id="h19-2" class="h">@@ -81,7 +81,7 @@ impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Aggregation&lt;T&gt; {
</a> // An accumulator
 pub trait Accumulator: std::fmt::Debug + Send {
     // Accumulates a value
<a href="#h19-2-3" id="h19-2-3" class="d">-    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h19-2-4" id="h19-2-4" class="i">+    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;()&gt;;
</a> 
     // Calculates a final aggregate
     fn aggregate(&amp;self) -&gt; Value;
<a href="#h19-3" id="h19-3" class="h">@@ -112,7 +112,7 @@ impl Count {
</a> }
 
 impl Accumulator for Count {
<a href="#h19-3-3" id="h19-3-3" class="d">-    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h19-3-4" id="h19-3-4" class="i">+    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;()&gt; {
</a>         match value {
             Value::Null =&gt; {}
             _ =&gt; self.count += 1,
<a href="#h19-4" id="h19-4" class="h">@@ -139,7 +139,7 @@ impl Average {
</a> }
 
 impl Accumulator for Average {
<a href="#h19-4-3" id="h19-4-3" class="d">-    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h19-4-4" id="h19-4-4" class="i">+    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;()&gt; {
</a>         self.count.accumulate(value)?;
         self.sum.accumulate(value)?;
         Ok(())
<a href="#h19-5" id="h19-5" class="h">@@ -167,7 +167,7 @@ impl Max {
</a> }
 
 impl Accumulator for Max {
<a href="#h19-5-3" id="h19-5-3" class="d">-    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h19-5-4" id="h19-5-4" class="i">+    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;()&gt; {
</a>         if let Some(max) = &amp;mut self.max {
             match value.partial_cmp(max) {
                 _ if max.datatype() != value.datatype() =&gt; *max = Value::Null,
<a href="#h19-6" id="h19-6" class="h">@@ -202,7 +202,7 @@ impl Min {
</a> }
 
 impl Accumulator for Min {
<a href="#h19-6-3" id="h19-6-3" class="d">-    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h19-6-4" id="h19-6-4" class="i">+    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;()&gt; {
</a>         if let Some(min) = &amp;mut self.min {
             match value.partial_cmp(min) {
                 _ if min.datatype() != value.datatype() =&gt; *min = Value::Null,
<a href="#h19-7" id="h19-7" class="h">@@ -237,7 +237,7 @@ impl Sum {
</a> }
 
 impl Accumulator for Sum {
<a href="#h19-7-3" id="h19-7-3" class="d">-    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h19-7-4" id="h19-7-4" class="i">+    fn accumulate(&amp;mut self, value: &amp;Value) -&gt; Result&lt;()&gt; {
</a>         self.sum = match (&amp;self.sum, value) {
             (Some(Value::Integer(s)), Value::Integer(i)) =&gt; Some(Value::Integer(s + i)),
             (Some(Value::Float(s)), Value::Float(f)) =&gt; Some(Value::Float(s + f)),
<b>diff --git a/<a id="h20" href="../file/src/sql/execution/create_table.rs.html">src/sql/execution/create_table.rs</a> b/<a href="../file/src/sql/execution/create_table.rs.html">src/sql/execution/create_table.rs</a></b>
<a href="#h20-0" id="h20-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::schema::Table;
 use super::{Context, Executor, ResultSet};
<a href="#h20-0-3" id="h20-0-3" class="d">-use crate::Error;
</a><a href="#h20-0-4" id="h20-0-4" class="i">+use crate::error::Result;
</a> 
 /// A CREATE TABLE executor
 pub struct CreateTable {
<a href="#h20-1" id="h20-1" class="h">@@ -16,7 +16,7 @@ impl CreateTable {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for CreateTable {
<a href="#h20-1-3" id="h20-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h20-1-4" id="h20-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         ctx.txn.create_table(&amp;self.table)?;
         Ok(ResultSet::CreateTable { name: self.table.name })
     }
<b>diff --git a/<a id="h21" href="../file/src/sql/execution/delete.rs.html">src/sql/execution/delete.rs</a> b/<a href="../file/src/sql/execution/delete.rs.html">src/sql/execution/delete.rs</a></b>
<a href="#h21-0" id="h21-0" class="h">@@ -1,6 +1,6 @@
</a> use super::super::engine::Transaction;
 use super::{Context, Executor, ResultSet};
<a href="#h21-0-2" id="h21-0-2" class="d">-use crate::Error;
</a><a href="#h21-0-3" id="h21-0-3" class="i">+use crate::error::{Error, Result};
</a> 
 /// A DELETE executor
 pub struct Delete&lt;T: Transaction&gt; {
<a href="#h21-1" id="h21-1" class="h">@@ -17,7 +17,7 @@ impl&lt;T: Transaction&gt; Delete&lt;T&gt; {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Delete&lt;T&gt; {
<a href="#h21-1-3" id="h21-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h21-1-4" id="h21-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let table = ctx.txn.must_read_table(&amp;self.table)?;
         let mut count = 0;
         match self.source.execute(ctx)? {
<b>diff --git a/<a id="h22" href="../file/src/sql/execution/drop_table.rs.html">src/sql/execution/drop_table.rs</a> b/<a href="../file/src/sql/execution/drop_table.rs.html">src/sql/execution/drop_table.rs</a></b>
<a href="#h22-0" id="h22-0" class="h">@@ -1,6 +1,6 @@
</a> use super::super::engine::Transaction;
 use super::{Context, Executor, ResultSet};
<a href="#h22-0-2" id="h22-0-2" class="d">-use crate::Error;
</a><a href="#h22-0-3" id="h22-0-3" class="i">+use crate::error::Result;
</a> 
 /// A DROP TABLE executor
 pub struct DropTable {
<a href="#h22-1" id="h22-1" class="h">@@ -15,7 +15,7 @@ impl DropTable {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for DropTable {
<a href="#h22-1-3" id="h22-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h22-1-4" id="h22-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         ctx.txn.delete_table(&amp;self.table)?;
         Ok(ResultSet::DropTable { name: self.table })
     }
<b>diff --git a/<a id="h23" href="../file/src/sql/execution/filter.rs.html">src/sql/execution/filter.rs</a> b/<a href="../file/src/sql/execution/filter.rs.html">src/sql/execution/filter.rs</a></b>
<a href="#h23-0" id="h23-0" class="h">@@ -2,7 +2,7 @@ use super::super::engine::Transaction;
</a> use super::super::types::Expression;
 use super::super::types::Value;
 use super::{Context, Executor, ResultColumns, ResultSet};
<a href="#h23-0-3" id="h23-0-3" class="d">-use crate::Error;
</a><a href="#h23-0-4" id="h23-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 /// A filter executor
 pub struct Filter&lt;T: Transaction&gt; {
<a href="#h23-1" id="h23-1" class="h">@@ -19,7 +19,7 @@ impl&lt;T: Transaction&gt; Filter&lt;T&gt; {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Filter&lt;T&gt; {
<a href="#h23-1-3" id="h23-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h23-1-4" id="h23-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let result = self.source.execute(ctx)?;
         if let ResultSet::Query { mut relation } = result {
             if let Some(rows) = relation.rows {
<b>diff --git a/<a id="h24" href="../file/src/sql/execution/index_lookup.rs.html">src/sql/execution/index_lookup.rs</a> b/<a href="../file/src/sql/execution/index_lookup.rs.html">src/sql/execution/index_lookup.rs</a></b>
<a href="#h24-0" id="h24-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::types::{Column, Relation, Row, Value};
 use super::{Context, Executor, ResultSet};
<a href="#h24-0-3" id="h24-0-3" class="d">-use crate::Error;
</a><a href="#h24-0-4" id="h24-0-4" class="i">+use crate::error::Result;
</a> 
 use std::collections::HashSet;
 
<a href="#h24-1" id="h24-1" class="h">@@ -30,7 +30,7 @@ impl IndexLookup {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for IndexLookup {
<a href="#h24-1-3" id="h24-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h24-1-4" id="h24-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let table = ctx.txn.must_read_table(&amp;self.table)?;
         let name = if let Some(alias) = &amp;self.alias { alias } else { &amp;table.name };
 
<a href="#h24-2" id="h24-2" class="h">@@ -43,7 +43,7 @@ impl&lt;T: Transaction&gt; Executor&lt;T&gt; for IndexLookup {
</a>         let rows = pks
             .into_iter()
             .filter_map(|pk| ctx.txn.read(&amp;table.name, &amp;pk).transpose())
<a href="#h24-2-3" id="h24-2-3" class="d">-            .collect::&lt;Result&lt;Vec&lt;Row&gt;, Error&gt;&gt;()?;
</a><a href="#h24-2-4" id="h24-2-4" class="i">+            .collect::&lt;Result&lt;Vec&lt;Row&gt;&gt;&gt;()?;
</a> 
         Ok(ResultSet::Query {
             relation: Relation {
<b>diff --git a/<a id="h25" href="../file/src/sql/execution/insert.rs.html">src/sql/execution/insert.rs</a> b/<a href="../file/src/sql/execution/insert.rs.html">src/sql/execution/insert.rs</a></b>
<a href="#h25-0" id="h25-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::types::{Environment, Expressions};
 use super::{Context, Executor, ResultSet};
<a href="#h25-0-3" id="h25-0-3" class="d">-use crate::Error;
</a><a href="#h25-0-4" id="h25-0-4" class="i">+use crate::error::Result;
</a> 
 /// An INSERT executor
 pub struct Insert {
<a href="#h25-1" id="h25-1" class="h">@@ -20,15 +20,13 @@ impl Insert {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Insert {
<a href="#h25-1-3" id="h25-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h25-1-4" id="h25-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let table = ctx.txn.must_read_table(&amp;self.table)?;
         let env = Environment::new();
         let mut count = 0;
         for expressions in self.rows {
<a href="#h25-1-9" id="h25-1-9" class="d">-            let mut row = expressions
</a><a href="#h25-1-10" id="h25-1-10" class="d">-                .into_iter()
</a><a href="#h25-1-11" id="h25-1-11" class="d">-                .map(|expr| expr.evaluate(&amp;env))
</a><a href="#h25-1-12" id="h25-1-12" class="d">-                .collect::&lt;Result&lt;_, Error&gt;&gt;()?;
</a><a href="#h25-1-13" id="h25-1-13" class="i">+            let mut row =
</a><a href="#h25-1-14" id="h25-1-14" class="i">+                expressions.into_iter().map(|expr| expr.evaluate(&amp;env)).collect::&lt;Result&lt;_&gt;&gt;()?;
</a>             if self.columns.is_empty() {
                 row = table.pad_row(row)?;
             } else {
<b>diff --git a/<a id="h26" href="../file/src/sql/execution/key_lookup.rs.html">src/sql/execution/key_lookup.rs</a> b/<a href="../file/src/sql/execution/key_lookup.rs.html">src/sql/execution/key_lookup.rs</a></b>
<a href="#h26-0" id="h26-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::types::{Column, Relation, Row, Value};
 use super::{Context, Executor, ResultSet};
<a href="#h26-0-3" id="h26-0-3" class="d">-use crate::Error;
</a><a href="#h26-0-4" id="h26-0-4" class="i">+use crate::error::Result;
</a> 
 /// A primary key lookup executor
 pub struct KeyLookup {
<a href="#h26-1" id="h26-1" class="h">@@ -21,7 +21,7 @@ impl KeyLookup {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for KeyLookup {
<a href="#h26-1-3" id="h26-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h26-1-4" id="h26-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let table = ctx.txn.must_read_table(&amp;self.table)?;
         let name = if let Some(alias) = &amp;self.alias { alias } else { &amp;table.name };
 
<a href="#h26-2" id="h26-2" class="h">@@ -30,7 +30,7 @@ impl&lt;T: Transaction&gt; Executor&lt;T&gt; for KeyLookup {
</a>             .keys
             .into_iter()
             .filter_map(|key| ctx.txn.read(&amp;table.name, &amp;key).transpose())
<a href="#h26-2-3" id="h26-2-3" class="d">-            .collect::&lt;Result&lt;Vec&lt;Row&gt;, Error&gt;&gt;()?;
</a><a href="#h26-2-4" id="h26-2-4" class="i">+            .collect::&lt;Result&lt;Vec&lt;Row&gt;&gt;&gt;()?;
</a> 
         Ok(ResultSet::Query {
             relation: Relation {
<b>diff --git a/<a id="h27" href="../file/src/sql/execution/limit.rs.html">src/sql/execution/limit.rs</a> b/<a href="../file/src/sql/execution/limit.rs.html">src/sql/execution/limit.rs</a></b>
<a href="#h27-0" id="h27-0" class="h">@@ -1,6 +1,6 @@
</a> use super::super::engine::Transaction;
 use super::{Context, Executor, ResultSet};
<a href="#h27-0-2" id="h27-0-2" class="d">-use crate::Error;
</a><a href="#h27-0-3" id="h27-0-3" class="i">+use crate::error::{Error, Result};
</a> 
 /// A LIMIT executor
 pub struct Limit&lt;T: Transaction&gt; {
<a href="#h27-1" id="h27-1" class="h">@@ -17,13 +17,13 @@ impl&lt;T: Transaction&gt; Limit&lt;T&gt; {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Limit&lt;T&gt; {
<a href="#h27-1-3" id="h27-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h27-1-4" id="h27-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let result = self.source.execute(ctx)?;
         if let ResultSet::Query { mut relation } = result {
             if let Some(rows) = relation.rows {
                 relation.rows = Some(Box::new(rows.take(self.limit as usize)))
             }
<a href="#h27-1-10" id="h27-1-10" class="d">-            return Ok(ResultSet::Query { relation })
</a><a href="#h27-1-11" id="h27-1-11" class="i">+            return Ok(ResultSet::Query { relation });
</a>         }
         Err(Error::Internal(&quot;Unexpected result&quot;.into()))
     }
<b>diff --git a/<a id="h28" href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a> b/<a href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a></b>
<a href="#h28-0" id="h28-0" class="h">@@ -36,14 +36,14 @@ use super::engine::{Mode, Transaction};
</a> use super::plan::Node;
 use super::types::Environment;
 use super::types::{Columns, Relation, Row, Value};
<a href="#h28-0-3" id="h28-0-3" class="d">-use crate::Error;
</a><a href="#h28-0-4" id="h28-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 use serde_derive::{Deserialize, Serialize};
 
 /// A plan executor
 pub trait Executor&lt;T: Transaction&gt; {
     /// Executes the executor, consuming it and returning a result set
<a href="#h28-0-11" id="h28-0-11" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt;;
</a><a href="#h28-0-12" id="h28-0-12" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt;;
</a> }
 
 impl&lt;T: Transaction + &#39;static&gt; dyn Executor&lt;T&gt; {
<a href="#h28-1" id="h28-1" class="h">@@ -115,7 +115,7 @@ pub enum ResultSet {
</a> 
 impl ResultSet {
     /// Converts the ResultSet into a Relation, or errors if not a query result.
<a href="#h28-1-3" id="h28-1-3" class="d">-    pub fn into_relation(self) -&gt; Result&lt;Relation, Error&gt; {
</a><a href="#h28-1-4" id="h28-1-4" class="i">+    pub fn into_relation(self) -&gt; Result&lt;Relation&gt; {
</a>         match self {
             ResultSet::Query { relation } =&gt; Ok(relation),
             r =&gt; Err(Error::Value(format!(&quot;Not a query result: {:?}&quot;, r))),
<a href="#h28-2" id="h28-2" class="h">@@ -123,12 +123,12 @@ impl ResultSet {
</a>     }
 
     /// Converts the ResultSet into a Row, or errors if not a query result with rows.
<a href="#h28-2-3" id="h28-2-3" class="d">-    pub fn into_row(self) -&gt; Result&lt;Row, Error&gt; {
</a><a href="#h28-2-4" id="h28-2-4" class="i">+    pub fn into_row(self) -&gt; Result&lt;Row&gt; {
</a>         self.into_relation()?.into_row()?.ok_or_else(|| Error::Value(&quot;No rows returned&quot;.into()))
     }
 
     /// Converts the ResultSet into a Value, if possible.
<a href="#h28-2-9" id="h28-2-9" class="d">-    pub fn into_value(self) -&gt; Result&lt;Value, Error&gt; {
</a><a href="#h28-2-10" id="h28-2-10" class="i">+    pub fn into_value(self) -&gt; Result&lt;Value&gt; {
</a>         self.into_relation()?.into_value()?.ok_or_else(|| Error::Value(&quot;No value returned&quot;.into()))
     }
 }
<a href="#h28-3" id="h28-3" class="h">@@ -169,7 +169,7 @@ impl ResultColumns {
</a>         s
     }
 
<a href="#h28-3-3" id="h28-3-3" class="d">-    fn get(&amp;self, relation: Option&lt;&amp;str&gt;, field: &amp;str) -&gt; Result&lt;(Option&lt;String&gt;, String), Error&gt; {
</a><a href="#h28-3-4" id="h28-3-4" class="i">+    fn get(&amp;self, relation: Option&lt;&amp;str&gt;, field: &amp;str) -&gt; Result&lt;(Option&lt;String&gt;, String)&gt; {
</a>         let matches: Vec&lt;_&gt; = self
             .columns
             .iter()
<a href="#h28-4" id="h28-4" class="h">@@ -192,7 +192,7 @@ impl ResultColumns {
</a>         }
     }
 
<a href="#h28-4-3" id="h28-4-3" class="d">-    pub fn index(&amp;self, relation: Option&lt;&amp;str&gt;, field: &amp;str) -&gt; Result&lt;usize, Error&gt; {
</a><a href="#h28-4-4" id="h28-4-4" class="i">+    pub fn index(&amp;self, relation: Option&lt;&amp;str&gt;, field: &amp;str) -&gt; Result&lt;usize&gt; {
</a>         let matches: Vec&lt;_&gt; = self
             .columns
             .iter()
<b>diff --git a/<a id="h29" href="../file/src/sql/execution/nested_loop_join.rs.html">src/sql/execution/nested_loop_join.rs</a> b/<a href="../file/src/sql/execution/nested_loop_join.rs.html">src/sql/execution/nested_loop_join.rs</a></b>
<a href="#h29-0" id="h29-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::types::{Columns, Expression, Relation, Rows};
 use super::{Context, Executor, ResultColumns, ResultSet, Row, Value};
<a href="#h29-0-3" id="h29-0-3" class="d">-use crate::Error;
</a><a href="#h29-0-4" id="h29-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 /// A nested loop join executor
 /// FIXME This code is horrible, clean it up at some point
<a href="#h29-1" id="h29-1" class="h">@@ -31,7 +31,7 @@ impl&lt;T: Transaction&gt; NestedLoopJoin&lt;T&gt; {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for NestedLoopJoin&lt;T&gt; {
<a href="#h29-1-3" id="h29-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h29-1-4" id="h29-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let (result, inner) = if self.flip {
             (self.inner.execute(ctx)?, self.outer.execute(ctx)?)
         } else {
<a href="#h29-2" id="h29-2" class="h">@@ -78,7 +78,7 @@ struct NestedLoopRows {
</a>     columns: ResultColumns,
     predicate: Option&lt;Expression&gt;,
     outer: Rows,
<a href="#h29-2-3" id="h29-2-3" class="d">-    outer_cur: Option&lt;Result&lt;Row, Error&gt;&gt;,
</a><a href="#h29-2-4" id="h29-2-4" class="i">+    outer_cur: Option&lt;Result&lt;Row&gt;&gt;,
</a>     // FIXME inner should be Rows too, but requires impl Clone
     inner: Box&lt;dyn Iterator&lt;Item = Row&gt; + Send&gt;,
     inner_orig: Vec&lt;Row&gt;,
<a href="#h29-3" id="h29-3" class="h">@@ -109,7 +109,7 @@ impl NestedLoopRows {
</a>         }
     }
 
<a href="#h29-3-3" id="h29-3-3" class="d">-    fn next_inner(&amp;mut self) -&gt; Result&lt;Option&lt;Row&gt;, Error&gt; {
</a><a href="#h29-3-4" id="h29-3-4" class="i">+    fn next_inner(&amp;mut self) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
</a>         let o = match self.outer_cur.clone() {
             Some(Ok(o)) =&gt; o,
             Some(Err(e)) =&gt; return Err(e),
<a href="#h29-4" id="h29-4" class="h">@@ -140,7 +140,7 @@ impl NestedLoopRows {
</a> }
 
 impl Iterator for NestedLoopRows {
<a href="#h29-4-3" id="h29-4-3" class="d">-    type Item = Result&lt;Row, Error&gt;;
</a><a href="#h29-4-4" id="h29-4-4" class="i">+    type Item = Result&lt;Row&gt;;
</a> 
     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
         while self.outer_cur.is_some() {
<b>diff --git a/<a id="h30" href="../file/src/sql/execution/nothing.rs.html">src/sql/execution/nothing.rs</a> b/<a href="../file/src/sql/execution/nothing.rs.html">src/sql/execution/nothing.rs</a></b>
<a href="#h30-0" id="h30-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::types::Row;
 use super::{Context, Executor, Relation, ResultSet};
<a href="#h30-0-3" id="h30-0-3" class="d">-use crate::Error;
</a><a href="#h30-0-4" id="h30-0-4" class="i">+use crate::error::Result;
</a> 
 /// An executor that produces a single empty row
 pub struct Nothing;
<a href="#h30-1" id="h30-1" class="h">@@ -13,7 +13,7 @@ impl Nothing {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Nothing {
<a href="#h30-1-3" id="h30-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, _ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h30-1-4" id="h30-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, _ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         Ok(ResultSet::Query {
             relation: Relation {
                 columns: Vec::new(),
<b>diff --git a/<a id="h31" href="../file/src/sql/execution/offset.rs.html">src/sql/execution/offset.rs</a> b/<a href="../file/src/sql/execution/offset.rs.html">src/sql/execution/offset.rs</a></b>
<a href="#h31-0" id="h31-0" class="h">@@ -1,6 +1,6 @@
</a> use super::super::engine::Transaction;
 use super::{Context, Executor, ResultSet};
<a href="#h31-0-2" id="h31-0-2" class="d">-use crate::Error;
</a><a href="#h31-0-3" id="h31-0-3" class="i">+use crate::error::{Error, Result};
</a> 
 /// An OFFSET executor
 pub struct Offset&lt;T: Transaction&gt; {
<a href="#h31-1" id="h31-1" class="h">@@ -17,7 +17,7 @@ impl&lt;T: Transaction&gt; Offset&lt;T&gt; {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Offset&lt;T&gt; {
<a href="#h31-1-3" id="h31-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h31-1-4" id="h31-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let result = self.source.execute(ctx)?;
         if let ResultSet::Query { mut relation } = result {
             if let Some(rows) = relation.rows {
<b>diff --git a/<a id="h32" href="../file/src/sql/execution/order.rs.html">src/sql/execution/order.rs</a> b/<a href="../file/src/sql/execution/order.rs.html">src/sql/execution/order.rs</a></b>
<a href="#h32-0" id="h32-0" class="h">@@ -2,7 +2,7 @@ use super::super::engine::Transaction;
</a> use super::super::plan::Direction;
 use super::super::types::{Expression, Row, Value};
 use super::{Context, Executor, ResultColumns, ResultSet};
<a href="#h32-0-3" id="h32-0-3" class="d">-use crate::Error;
</a><a href="#h32-0-4" id="h32-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 /// An order executor
 pub struct Order&lt;T: Transaction&gt; {
<a href="#h32-1" id="h32-1" class="h">@@ -19,7 +19,7 @@ impl&lt;T: Transaction&gt; Order&lt;T&gt; {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Order&lt;T&gt; {
<a href="#h32-1-3" id="h32-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h32-1-4" id="h32-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         match self.source.execute(ctx)? {
             ResultSet::Query { mut relation } =&gt; {
                 if let Some(mut rows) = relation.rows {
<b>diff --git a/<a id="h33" href="../file/src/sql/execution/projection.rs.html">src/sql/execution/projection.rs</a> b/<a href="../file/src/sql/execution/projection.rs.html">src/sql/execution/projection.rs</a></b>
<a href="#h33-0" id="h33-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::types::{Column, Expression, Expressions, Relation};
 use super::{Context, Executor, ResultColumns, ResultSet};
<a href="#h33-0-3" id="h33-0-3" class="d">-use crate::Error;
</a><a href="#h33-0-4" id="h33-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 /// A filter executor
 pub struct Projection&lt;T: Transaction&gt; {
<a href="#h33-1" id="h33-1" class="h">@@ -24,7 +24,7 @@ impl&lt;T: Transaction&gt; Projection&lt;T&gt; {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Projection&lt;T&gt; {
<a href="#h33-1-3" id="h33-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h33-1-4" id="h33-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         match self.source.execute(ctx)? {
             ResultSet::Query { relation } =&gt; {
                 let labels = self.labels;
<a href="#h33-2" id="h33-2" class="h">@@ -47,7 +47,7 @@ impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Projection&lt;T&gt; {
</a>                                 Column { relation: None, name: None }
                             })
                         })
<a href="#h33-2-3" id="h33-2-3" class="d">-                        .collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?,
</a><a href="#h33-2-4" id="h33-2-4" class="i">+                        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>                     rows: None,
                 };
                 if let Some(rows) = relation.rows {
<a href="#h33-3" id="h33-3" class="h">@@ -58,7 +58,7 @@ impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Projection&lt;T&gt; {
</a>                             Ok(expressions
                                 .iter()
                                 .map(|e| e.evaluate(&amp;env))
<a href="#h33-3-3" id="h33-3-3" class="d">-                                .collect::&lt;Result&lt;_, Error&gt;&gt;()?)
</a><a href="#h33-3-4" id="h33-3-4" class="i">+                                .collect::&lt;Result&lt;_&gt;&gt;()?)
</a>                         })
                     })));
                 }
<b>diff --git a/<a id="h34" href="../file/src/sql/execution/scan.rs.html">src/sql/execution/scan.rs</a> b/<a href="../file/src/sql/execution/scan.rs.html">src/sql/execution/scan.rs</a></b>
<a href="#h34-0" id="h34-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::types::{Column, Expression, Relation};
 use super::{Context, Executor, ResultSet};
<a href="#h34-0-3" id="h34-0-3" class="d">-use crate::Error;
</a><a href="#h34-0-4" id="h34-0-4" class="i">+use crate::error::Result;
</a> 
 /// A table scan executor
 pub struct Scan {
<a href="#h34-1" id="h34-1" class="h">@@ -20,7 +20,7 @@ impl Scan {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Scan {
<a href="#h34-1-3" id="h34-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h34-1-4" id="h34-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         let table = ctx.txn.must_read_table(&amp;self.table)?;
         let name = if let Some(alias) = &amp;self.alias { alias } else { &amp;table.name };
         Ok(ResultSet::Query {
<b>diff --git a/<a id="h35" href="../file/src/sql/execution/update.rs.html">src/sql/execution/update.rs</a> b/<a href="../file/src/sql/execution/update.rs.html">src/sql/execution/update.rs</a></b>
<a href="#h35-0" id="h35-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::engine::Transaction;
 use super::super::types::Expression;
 use super::{Context, Executor, ResultSet};
<a href="#h35-0-3" id="h35-0-3" class="d">-use crate::Error;
</a><a href="#h35-0-4" id="h35-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 use std::collections::BTreeMap;
 
<a href="#h35-1" id="h35-1" class="h">@@ -27,7 +27,7 @@ impl&lt;T: Transaction&gt; Update&lt;T&gt; {
</a> }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Update&lt;T&gt; {
<a href="#h35-1-3" id="h35-1-3" class="d">-    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h35-1-4" id="h35-1-4" class="i">+    fn execute(self: Box&lt;Self&gt;, ctx: &amp;mut Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         match self.source.execute(ctx)? {
             ResultSet::Query { mut relation } =&gt; {
                 let table = ctx.txn.must_read_table(&amp;self.table)?;
<b>diff --git a/<a id="h36" href="../file/src/sql/parser/lexer.rs.html">src/sql/parser/lexer.rs</a> b/<a href="../file/src/sql/parser/lexer.rs.html">src/sql/parser/lexer.rs</a></b>
<a href="#h36-0" id="h36-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h36-0-0" id="h36-0-0" class="d">-use crate::Error;
</a><a href="#h36-0-1" id="h36-0-1" class="i">+use crate::error::{Error, Result};
</a> 
 use std::iter::Peekable;
 use std::str::Chars;
<a href="#h36-1" id="h36-1" class="h">@@ -293,9 +293,9 @@ pub struct Lexer&lt;&#39;a&gt; {
</a> }
 
 impl&lt;&#39;a&gt; Iterator for Lexer&lt;&#39;a&gt; {
<a href="#h36-1-3" id="h36-1-3" class="d">-    type Item = Result&lt;Token, Error&gt;;
</a><a href="#h36-1-4" id="h36-1-4" class="i">+    type Item = Result&lt;Token&gt;;
</a> 
<a href="#h36-1-6" id="h36-1-6" class="d">-    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;Token, Error&gt;&gt; {
</a><a href="#h36-1-7" id="h36-1-7" class="i">+    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;Token&gt;&gt; {
</a>         match self.scan() {
             Ok(Some(token)) =&gt; Some(Ok(token)),
             Ok(None) =&gt; match self.iter.peek() {
<a href="#h36-2" id="h36-2" class="h">@@ -342,7 +342,7 @@ impl&lt;&#39;a&gt; Lexer&lt;&#39;a&gt; {
</a>     }
 
     /// Scans the input for the next token if any, ignoring leading whitespace
<a href="#h36-2-3" id="h36-2-3" class="d">-    fn scan(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;, Error&gt; {
</a><a href="#h36-2-4" id="h36-2-4" class="i">+    fn scan(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;&gt; {
</a>         self.consume_whitespace();
         match self.iter.peek() {
             Some(&#39;\&#39;&#39;) =&gt; self.scan_string(),
<a href="#h36-3" id="h36-3" class="h">@@ -366,7 +366,7 @@ impl&lt;&#39;a&gt; Lexer&lt;&#39;a&gt; {
</a>     }
 
     /// Scans the input for the next quoted ident, if any
<a href="#h36-3-3" id="h36-3-3" class="d">-    fn scan_ident_quoted(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;, Error&gt; {
</a><a href="#h36-3-4" id="h36-3-4" class="i">+    fn scan_ident_quoted(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;&gt; {
</a>         if self.next_if(|c| c == &#39;&quot;&#39;).is_none() {
             return Ok(None);
         }
<a href="#h36-4" id="h36-4" class="h">@@ -404,7 +404,7 @@ impl&lt;&#39;a&gt; Lexer&lt;&#39;a&gt; {
</a>     }
 
     /// Scans the input for the next string literal, if any
<a href="#h36-4-3" id="h36-4-3" class="d">-    fn scan_string(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;, Error&gt; {
</a><a href="#h36-4-4" id="h36-4-4" class="i">+    fn scan_string(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;&gt; {
</a>         if self.next_if(|c| c == &#39;\&#39;&#39;).is_none() {
             return Ok(None);
         }
<b>diff --git a/<a id="h37" href="../file/src/sql/parser/mod.rs.html">src/sql/parser/mod.rs</a> b/<a href="../file/src/sql/parser/mod.rs.html">src/sql/parser/mod.rs</a></b>
<a href="#h37-0" id="h37-0" class="h">@@ -3,7 +3,7 @@ mod lexer;
</a> pub use lexer::{Keyword, Lexer, Token};
 
 use super::types::DataType;
<a href="#h37-0-3" id="h37-0-3" class="d">-use crate::Error;
</a><a href="#h37-0-4" id="h37-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 use lazy_static::lazy_static;
 use regex::Regex;
<a href="#h37-1" id="h37-1" class="h">@@ -21,20 +21,20 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses the input string into an AST statement
<a href="#h37-1-3" id="h37-1-3" class="d">-    pub fn parse(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-1-4" id="h37-1-4" class="i">+    pub fn parse(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         let statement = self.parse_statement()?;
         self.next_expect(None)?;
         Ok(statement)
     }
 
     /// Grabs the next lexer token, or throws an error if none is found.
<a href="#h37-1-11" id="h37-1-11" class="d">-    fn next(&amp;mut self) -&gt; Result&lt;Token, Error&gt; {
</a><a href="#h37-1-12" id="h37-1-12" class="i">+    fn next(&amp;mut self) -&gt; Result&lt;Token&gt; {
</a>         self.lexer.next().unwrap_or_else(|| Err(Error::Parse(&quot;Unexpected end of input&quot;.into())))
     }
 
     /// Grabs the next lexer token, and returns it if it was expected or
     /// otherwise throws an error.
<a href="#h37-1-18" id="h37-1-18" class="d">-    fn next_expect(&amp;mut self, expect: Option&lt;Token&gt;) -&gt; Result&lt;Option&lt;Token&gt;, Error&gt; {
</a><a href="#h37-1-19" id="h37-1-19" class="i">+    fn next_expect(&amp;mut self, expect: Option&lt;Token&gt;) -&gt; Result&lt;Option&lt;Token&gt;&gt; {
</a>         if let Some(t) = expect {
             let token = self.next()?;
             if token == t {
<a href="#h37-2" id="h37-2" class="h">@@ -50,7 +50,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Grabs the next identifier, or errors if not found
<a href="#h37-2-3" id="h37-2-3" class="d">-    fn next_ident(&amp;mut self) -&gt; Result&lt;String, Error&gt; {
</a><a href="#h37-2-4" id="h37-2-4" class="i">+    fn next_ident(&amp;mut self) -&gt; Result&lt;String&gt; {
</a>         match self.next()? {
             Token::Ident(ident) =&gt; Ok(ident),
             token =&gt; Err(Error::Parse(format!(&quot;Expected identifier, got {}&quot;, token))),
<a href="#h37-3" id="h37-3" class="h">@@ -64,7 +64,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Grabs the next operator if it satisfies the type and precedence
<a href="#h37-3-3" id="h37-3-3" class="d">-    fn next_if_operator&lt;O: Operator&gt;(&amp;mut self, min_prec: u8) -&gt; Result&lt;Option&lt;O&gt;, Error&gt; {
</a><a href="#h37-3-4" id="h37-3-4" class="i">+    fn next_if_operator&lt;O: Operator&gt;(&amp;mut self, min_prec: u8) -&gt; Result&lt;Option&lt;O&gt;&gt; {
</a>         if let Some(operator) = self
             .peek()
             .unwrap_or(None)
<a href="#h37-4" id="h37-4" class="h">@@ -92,14 +92,14 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Peeks the next lexer token if any, but converts it from
<a href="#h37-4-3" id="h37-4-3" class="d">-    /// Option&lt;Result&lt;Token, Error&gt;&gt; to Result&lt;Option&lt;Token&gt;, Error&gt; which is
</a><a href="#h37-4-4" id="h37-4-4" class="i">+    /// Option&lt;Result&lt;Token&gt;&gt; to Result&lt;Option&lt;Token&gt;&gt; which is
</a>     /// more convenient to work with (the Iterator trait requires Option&lt;T&gt;).
<a href="#h37-4-6" id="h37-4-6" class="d">-    fn peek(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;, Error&gt; {
</a><a href="#h37-4-7" id="h37-4-7" class="i">+    fn peek(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;&gt; {
</a>         self.lexer.peek().cloned().transpose()
     }
 
     /// Parses an SQL statement
<a href="#h37-4-12" id="h37-4-12" class="d">-    fn parse_statement(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-4-13" id="h37-4-13" class="i">+    fn parse_statement(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         match self.peek()? {
             Some(Token::Keyword(Keyword::Begin)) =&gt; self.parse_transaction(),
             Some(Token::Keyword(Keyword::Commit)) =&gt; self.parse_transaction(),
<a href="#h37-5" id="h37-5" class="h">@@ -121,7 +121,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a DDL statement
<a href="#h37-5-3" id="h37-5-3" class="d">-    fn parse_ddl(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-5-4" id="h37-5-4" class="i">+    fn parse_ddl(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         match self.next()? {
             Token::Keyword(Keyword::Create) =&gt; match self.next()? {
                 Token::Keyword(Keyword::Table) =&gt; self.parse_ddl_create_table(),
<a href="#h37-6" id="h37-6" class="h">@@ -137,7 +137,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a> 
     /// Parses a CREATE TABLE DDL statement. The CREATE TABLE prefix has
     /// already been consumed.
<a href="#h37-6-3" id="h37-6-3" class="d">-    fn parse_ddl_create_table(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-6-4" id="h37-6-4" class="i">+    fn parse_ddl_create_table(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         let name = self.next_ident()?;
         self.next_expect(Some(Token::OpenParen))?;
 
<a href="#h37-7" id="h37-7" class="h">@@ -154,12 +154,12 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a> 
     /// Parses a DROP TABLE DDL statement. The DROP TABLE prefix has
     /// already been consumed.
<a href="#h37-7-3" id="h37-7-3" class="d">-    fn parse_ddl_drop_table(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-7-4" id="h37-7-4" class="i">+    fn parse_ddl_drop_table(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         Ok(ast::Statement::DropTable(self.next_ident()?))
     }
 
     /// Parses a column specification
<a href="#h37-7-9" id="h37-7-9" class="d">-    fn parse_ddl_columnspec(&amp;mut self) -&gt; Result&lt;ast::ColumnSpec, Error&gt; {
</a><a href="#h37-7-10" id="h37-7-10" class="i">+    fn parse_ddl_columnspec(&amp;mut self) -&gt; Result&lt;ast::ColumnSpec&gt; {
</a>         let mut column = ast::ColumnSpec {
             name: self.next_ident()?,
             datatype: match self.next()? {
<a href="#h37-8" id="h37-8" class="h">@@ -218,7 +218,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a delete statement
<a href="#h37-8-3" id="h37-8-3" class="d">-    fn parse_statement_delete(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-8-4" id="h37-8-4" class="i">+    fn parse_statement_delete(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         self.next_expect(Some(Keyword::Delete.into()))?;
         self.next_expect(Some(Keyword::From.into()))?;
         let table = self.next_ident()?;
<a href="#h37-9" id="h37-9" class="h">@@ -226,7 +226,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a delete statement
<a href="#h37-9-3" id="h37-9-3" class="d">-    fn parse_statement_explain(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-9-4" id="h37-9-4" class="i">+    fn parse_statement_explain(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         self.next_expect(Some(Keyword::Explain.into()))?;
         if let Some(Token::Keyword(Keyword::Explain)) = self.peek()? {
             return Err(Error::Parse(&quot;Cannot nest EXPLAIN statements&quot;.into()));
<a href="#h37-10" id="h37-10" class="h">@@ -235,7 +235,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses an insert statement
<a href="#h37-10-3" id="h37-10-3" class="d">-    fn parse_statement_insert(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-10-4" id="h37-10-4" class="i">+    fn parse_statement_insert(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         self.next_expect(Some(Keyword::Insert.into()))?;
         self.next_expect(Some(Keyword::Into.into()))?;
         let table = self.next_ident()?;
<a href="#h37-11" id="h37-11" class="h">@@ -278,7 +278,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a select statement
<a href="#h37-11-3" id="h37-11-3" class="d">-    fn parse_statement_select(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-11-4" id="h37-11-4" class="i">+    fn parse_statement_select(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         Ok(ast::Statement::Select {
             select: self.parse_clause_select()?.unwrap(),
             from: self.parse_clause_from()?,
<a href="#h37-12" id="h37-12" class="h">@@ -300,7 +300,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses an update statement
<a href="#h37-12-3" id="h37-12-3" class="d">-    fn parse_statement_update(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-12-4" id="h37-12-4" class="i">+    fn parse_statement_update(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         self.next_expect(Some(Keyword::Update.into()))?;
         let table = self.next_ident()?;
         self.next_expect(Some(Keyword::Set.into()))?;
<a href="#h37-13" id="h37-13" class="h">@@ -323,7 +323,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a transaction statement
<a href="#h37-13-3" id="h37-13-3" class="d">-    fn parse_transaction(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h37-13-4" id="h37-13-4" class="i">+    fn parse_transaction(&amp;mut self) -&gt; Result&lt;ast::Statement&gt; {
</a>         match self.next()? {
             Token::Keyword(Keyword::Begin) =&gt; {
                 let mut readonly = false;
<a href="#h37-14" id="h37-14" class="h">@@ -359,7 +359,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a from clause
<a href="#h37-14-3" id="h37-14-3" class="d">-    fn parse_clause_from(&amp;mut self) -&gt; Result&lt;Option&lt;ast::FromClause&gt;, Error&gt; {
</a><a href="#h37-14-4" id="h37-14-4" class="i">+    fn parse_clause_from(&amp;mut self) -&gt; Result&lt;Option&lt;ast::FromClause&gt;&gt; {
</a>         if self.next_if_token(Keyword::From.into()).is_none() {
             return Ok(None);
         }
<a href="#h37-15" id="h37-15" class="h">@@ -388,12 +388,12 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a from clause item
<a href="#h37-15-3" id="h37-15-3" class="d">-    fn parse_clause_from_item(&amp;mut self) -&gt; Result&lt;ast::FromItem, Error&gt; {
</a><a href="#h37-15-4" id="h37-15-4" class="i">+    fn parse_clause_from_item(&amp;mut self) -&gt; Result&lt;ast::FromItem&gt; {
</a>         self.parse_clause_from_table()
     }
 
     // Parses a from clause table
<a href="#h37-15-9" id="h37-15-9" class="d">-    fn parse_clause_from_table(&amp;mut self) -&gt; Result&lt;ast::FromItem, Error&gt; {
</a><a href="#h37-15-10" id="h37-15-10" class="i">+    fn parse_clause_from_table(&amp;mut self) -&gt; Result&lt;ast::FromItem&gt; {
</a>         let name = self.next_ident()?;
         let alias = if self.next_if_token(Keyword::As.into()).is_some() {
             Some(self.next_ident()?)
<a href="#h37-16" id="h37-16" class="h">@@ -406,7 +406,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     // Parses a from clause join type
<a href="#h37-16-3" id="h37-16-3" class="d">-    fn parse_clause_from_jointype(&amp;mut self) -&gt; Result&lt;Option&lt;ast::JoinType&gt;, Error&gt; {
</a><a href="#h37-16-4" id="h37-16-4" class="i">+    fn parse_clause_from_jointype(&amp;mut self) -&gt; Result&lt;Option&lt;ast::JoinType&gt;&gt; {
</a>         if self.next_if_token(Keyword::Cross.into()).is_some() {
             self.next_expect(Some(Keyword::Join.into()))?;
             Ok(Some(ast::JoinType::Cross))
<a href="#h37-17" id="h37-17" class="h">@@ -429,7 +429,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a group by clause
<a href="#h37-17-3" id="h37-17-3" class="d">-    fn parse_clause_group_by(&amp;mut self) -&gt; Result&lt;Option&lt;ast::GroupByClause&gt;, Error&gt; {
</a><a href="#h37-17-4" id="h37-17-4" class="i">+    fn parse_clause_group_by(&amp;mut self) -&gt; Result&lt;Option&lt;ast::GroupByClause&gt;&gt; {
</a>         if self.next_if_token(Keyword::Group.into()).is_none() {
             return Ok(None);
         }
<a href="#h37-18" id="h37-18" class="h">@@ -445,7 +445,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a HAVING clause
<a href="#h37-18-3" id="h37-18-3" class="d">-    fn parse_clause_having(&amp;mut self) -&gt; Result&lt;Option&lt;ast::HavingClause&gt;, Error&gt; {
</a><a href="#h37-18-4" id="h37-18-4" class="i">+    fn parse_clause_having(&amp;mut self) -&gt; Result&lt;Option&lt;ast::HavingClause&gt;&gt; {
</a>         if self.next_if_token(Keyword::Having.into()).is_none() {
             return Ok(None);
         }
<a href="#h37-19" id="h37-19" class="h">@@ -453,7 +453,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses an order clause
<a href="#h37-19-3" id="h37-19-3" class="d">-    fn parse_clause_order(&amp;mut self) -&gt; Result&lt;Vec&lt;(ast::Expression, ast::Order)&gt;, Error&gt; {
</a><a href="#h37-19-4" id="h37-19-4" class="i">+    fn parse_clause_order(&amp;mut self) -&gt; Result&lt;Vec&lt;(ast::Expression, ast::Order)&gt;&gt; {
</a>         if self.next_if_token(Keyword::Order.into()).is_none() {
             return Ok(Vec::new());
         }
<a href="#h37-20" id="h37-20" class="h">@@ -478,7 +478,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a select clause
<a href="#h37-20-3" id="h37-20-3" class="d">-    fn parse_clause_select(&amp;mut self) -&gt; Result&lt;Option&lt;ast::SelectClause&gt;, Error&gt; {
</a><a href="#h37-20-4" id="h37-20-4" class="i">+    fn parse_clause_select(&amp;mut self) -&gt; Result&lt;Option&lt;ast::SelectClause&gt;&gt; {
</a>         if self.next_if_token(Keyword::Select.into()).is_none() {
             return Ok(None);
         }
<a href="#h37-21" id="h37-21" class="h">@@ -504,7 +504,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses a WHERE clause
<a href="#h37-21-3" id="h37-21-3" class="d">-    fn parse_clause_where(&amp;mut self) -&gt; Result&lt;Option&lt;ast::WhereClause&gt;, Error&gt; {
</a><a href="#h37-21-4" id="h37-21-4" class="i">+    fn parse_clause_where(&amp;mut self) -&gt; Result&lt;Option&lt;ast::WhereClause&gt;&gt; {
</a>         if self.next_if_token(Keyword::Where.into()).is_none() {
             return Ok(None);
         }
<a href="#h37-22" id="h37-22" class="h">@@ -513,7 +513,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a> 
     /// Parses an expression consisting of at least one atom operated on by any
     /// number of operators, using the precedence climbing algorithm.
<a href="#h37-22-3" id="h37-22-3" class="d">-    fn parse_expression(&amp;mut self, min_prec: u8) -&gt; Result&lt;ast::Expression, Error&gt; {
</a><a href="#h37-22-4" id="h37-22-4" class="i">+    fn parse_expression(&amp;mut self, min_prec: u8) -&gt; Result&lt;ast::Expression&gt; {
</a>         let mut lhs = if let Some(prefix) = self.next_if_operator::&lt;PrefixOperator&gt;(min_prec)? {
             prefix.build(self.parse_expression(prefix.prec() + prefix.assoc())?)
         } else {
<a href="#h37-23" id="h37-23" class="h">@@ -529,7 +529,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses an expression atom
<a href="#h37-23-3" id="h37-23-3" class="d">-    fn parse_expression_atom(&amp;mut self) -&gt; Result&lt;ast::Expression, Error&gt; {
</a><a href="#h37-23-4" id="h37-23-4" class="i">+    fn parse_expression_atom(&amp;mut self) -&gt; Result&lt;ast::Expression&gt; {
</a>         Ok(match self.next()? {
             Token::Ident(i) =&gt; {
                 if self.next_if_token(Token::OpenParen).is_some() {
<a href="#h37-24" id="h37-24" class="h">@@ -584,7 +584,7 @@ trait Operator: Sized {
</a>     /// Looks up the corresponding operator for a token, if one exists
     fn from(token: &amp;Token) -&gt; Option&lt;Self&gt;;
     /// Augments an operator by allowing it to parse any modifiers.
<a href="#h37-24-3" id="h37-24-3" class="d">-    fn augment(self, parser: &amp;mut Parser) -&gt; Result&lt;Self, Error&gt;;
</a><a href="#h37-24-4" id="h37-24-4" class="i">+    fn augment(self, parser: &amp;mut Parser) -&gt; Result&lt;Self&gt;;
</a>     /// Returns the operator&#39;s associativity
     fn assoc(&amp;self) -&gt; u8;
     /// Returns the operator&#39;s precedence
<a href="#h37-25" id="h37-25" class="h">@@ -621,7 +621,7 @@ impl Operator for PrefixOperator {
</a>         }
     }
 
<a href="#h37-25-3" id="h37-25-3" class="d">-    fn augment(self, _parser: &amp;mut Parser) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h37-25-4" id="h37-25-4" class="i">+    fn augment(self, _parser: &amp;mut Parser) -&gt; Result&lt;Self&gt; {
</a>         Ok(self)
     }
 
<a href="#h37-26" id="h37-26" class="h">@@ -699,7 +699,7 @@ impl Operator for InfixOperator {
</a>         })
     }
 
<a href="#h37-26-3" id="h37-26-3" class="d">-    fn augment(self, _parser: &amp;mut Parser) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h37-26-4" id="h37-26-4" class="i">+    fn augment(self, _parser: &amp;mut Parser) -&gt; Result&lt;Self&gt; {
</a>         Ok(self)
     }
 
<a href="#h37-27" id="h37-27" class="h">@@ -758,7 +758,7 @@ impl Operator for PostfixOperator {
</a>         }
     }
 
<a href="#h37-27-3" id="h37-27-3" class="d">-    fn augment(mut self, parser: &amp;mut Parser) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h37-27-4" id="h37-27-4" class="i">+    fn augment(mut self, parser: &amp;mut Parser) -&gt; Result&lt;Self&gt; {
</a>         #[allow(clippy::single_match)]
         match &amp;mut self {
             Self::IsNull { ref mut not } =&gt; {
<b>diff --git a/<a id="h38" href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a> b/<a href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a></b>
<a href="#h38-0" id="h38-0" class="h">@@ -8,7 +8,7 @@ use super::execution::{Context, Executor, ResultSet};
</a> use super::parser::ast;
 use super::schema::{Catalog, Table};
 use super::types::{Expression, Expressions, Value};
<a href="#h38-0-3" id="h38-0-3" class="d">-use crate::Error;
</a><a href="#h38-0-4" id="h38-0-4" class="i">+use crate::error::Result;
</a> 
 use serde_derive::{Deserialize, Serialize};
 use std::collections::BTreeMap;
<a href="#h38-1" id="h38-1" class="h">@@ -19,20 +19,17 @@ pub struct Plan(pub Node);
</a> 
 impl Plan {
     /// Builds a plan from an AST statement
<a href="#h38-1-3" id="h38-1-3" class="d">-    pub fn build(statement: ast::Statement) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h38-1-4" id="h38-1-4" class="i">+    pub fn build(statement: ast::Statement) -&gt; Result&lt;Self&gt; {
</a>         Planner::new().build(statement)
     }
 
     /// Executes the plan, consuming it
<a href="#h38-1-9" id="h38-1-9" class="d">-    pub fn execute&lt;T: Transaction + &#39;static&gt;(
</a><a href="#h38-1-10" id="h38-1-10" class="d">-        self,
</a><a href="#h38-1-11" id="h38-1-11" class="d">-        mut ctx: Context&lt;T&gt;,
</a><a href="#h38-1-12" id="h38-1-12" class="d">-    ) -&gt; Result&lt;ResultSet, Error&gt; {
</a><a href="#h38-1-13" id="h38-1-13" class="i">+    pub fn execute&lt;T: Transaction + &#39;static&gt;(self, mut ctx: Context&lt;T&gt;) -&gt; Result&lt;ResultSet&gt; {
</a>         Executor::build(self.0).execute(&amp;mut ctx)
     }
 
     /// Optimizes the plan, consuming it
<a href="#h38-1-18" id="h38-1-18" class="d">-    pub fn optimize&lt;C: Catalog + &#39;static&gt;(self, catalog: &amp;mut C) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h38-1-19" id="h38-1-19" class="i">+    pub fn optimize&lt;C: Catalog + &#39;static&gt;(self, catalog: &amp;mut C) -&gt; Result&lt;Self&gt; {
</a>         let mut root = self.0;
         root = optimizer::ConstantFolder.optimize(root)?;
         root = optimizer::FilterPushdown.optimize(root)?;
<a href="#h38-2" id="h38-2" class="h">@@ -118,10 +115,10 @@ pub enum Node {
</a> 
 impl Node {
     /// Recursively transforms nodes by applying functions before and after descending.
<a href="#h38-2-3" id="h38-2-3" class="d">-    pub fn transform&lt;B, A&gt;(mut self, pre: &amp;B, post: &amp;A) -&gt; Result&lt;Self, Error&gt;
</a><a href="#h38-2-4" id="h38-2-4" class="i">+    pub fn transform&lt;B, A&gt;(mut self, pre: &amp;B, post: &amp;A) -&gt; Result&lt;Self&gt;
</a>     where
<a href="#h38-2-6" id="h38-2-6" class="d">-        B: Fn(Self) -&gt; Result&lt;Self, Error&gt;,
</a><a href="#h38-2-7" id="h38-2-7" class="d">-        A: Fn(Self) -&gt; Result&lt;Self, Error&gt;,
</a><a href="#h38-2-8" id="h38-2-8" class="i">+        B: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h38-2-9" id="h38-2-9" class="i">+        A: Fn(Self) -&gt; Result&lt;Self&gt;,
</a>     {
         self = pre(self)?;
         self = match self {
<a href="#h38-3" id="h38-3" class="h">@@ -171,10 +168,10 @@ impl Node {
</a> 
     /// Transforms all expressions in a node by calling .transform() on them
     /// with the given functions.
<a href="#h38-3-3" id="h38-3-3" class="d">-    pub fn transform_expressions&lt;B, A&gt;(self, pre: &amp;B, post: &amp;A) -&gt; Result&lt;Self, Error&gt;
</a><a href="#h38-3-4" id="h38-3-4" class="i">+    pub fn transform_expressions&lt;B, A&gt;(self, pre: &amp;B, post: &amp;A) -&gt; Result&lt;Self&gt;
</a>     where
<a href="#h38-3-6" id="h38-3-6" class="d">-        B: Fn(Expression) -&gt; Result&lt;Expression, Error&gt;,
</a><a href="#h38-3-7" id="h38-3-7" class="d">-        A: Fn(Expression) -&gt; Result&lt;Expression, Error&gt;,
</a><a href="#h38-3-8" id="h38-3-8" class="i">+        B: Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h38-3-9" id="h38-3-9" class="i">+        A: Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a>     {
         Ok(match self {
             n @ Self::Aggregation { .. } =&gt; n,
<a href="#h38-4" id="h38-4" class="h">@@ -197,14 +194,14 @@ impl Node {
</a>                 expressions: expressions
                     .into_iter()
                     .map(|exprs| exprs.into_iter().map(|e| e.transform(pre, post)).collect())
<a href="#h38-4-3" id="h38-4-3" class="d">-                    .collect::&lt;Result&lt;_, Error&gt;&gt;()?,
</a><a href="#h38-4-4" id="h38-4-4" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a>             },
             Self::Order { source, orders } =&gt; Self::Order {
                 source,
                 orders: orders
                     .into_iter()
                     .map(|(e, o)| e.transform(pre, post).map(|e| (e, o)))
<a href="#h38-4-11" id="h38-4-11" class="d">-                    .collect::&lt;Result&lt;_, Error&gt;&gt;()?,
</a><a href="#h38-4-12" id="h38-4-12" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a>             },
             Self::Projection { source, labels, expressions } =&gt; Self::Projection {
                 source,
<a href="#h38-5" id="h38-5" class="h">@@ -212,7 +209,7 @@ impl Node {
</a>                 expressions: expressions
                     .into_iter()
                     .map(|e| e.transform(pre, post))
<a href="#h38-5-3" id="h38-5-3" class="d">-                    .collect::&lt;Result&lt;_, Error&gt;&gt;()?,
</a><a href="#h38-5-4" id="h38-5-4" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a>             },
             Self::Scan { table, alias, filter: Some(filter) } =&gt; {
                 Self::Scan { table, alias, filter: Some(filter.transform(pre, post)?) }
<a href="#h38-6" id="h38-6" class="h">@@ -223,7 +220,7 @@ impl Node {
</a>                 expressions: expressions
                     .into_iter()
                     .map(|(k, e)| e.transform(pre, post).map(|e| (k, e)))
<a href="#h38-6-3" id="h38-6-3" class="d">-                    .collect::&lt;Result&lt;_, Error&gt;&gt;()?,
</a><a href="#h38-6-4" id="h38-6-4" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a>             },
         })
     }
<b>diff --git a/<a id="h39" href="../file/src/sql/plan/optimizer.rs.html">src/sql/plan/optimizer.rs</a> b/<a href="../file/src/sql/plan/optimizer.rs.html">src/sql/plan/optimizer.rs</a></b>
<a href="#h39-0" id="h39-0" class="h">@@ -1,13 +1,13 @@
</a> use super::super::schema::Catalog;
 use super::super::types::{Environment, Expression, Value};
 use super::Node;
<a href="#h39-0-3" id="h39-0-3" class="d">-use crate::Error;
</a><a href="#h39-0-4" id="h39-0-4" class="i">+use crate::error::Result;
</a> 
 use std::collections::HashMap;
 
 /// A plan optimizer
 pub trait Optimizer {
<a href="#h39-0-10" id="h39-0-10" class="d">-    fn optimize(&amp;mut self, node: Node) -&gt; Result&lt;Node, Error&gt;;
</a><a href="#h39-0-11" id="h39-0-11" class="i">+    fn optimize(&amp;mut self, node: Node) -&gt; Result&lt;Node&gt;;
</a> }
 
 /// A constant folding optimizer, which replaces constant expressions
<a href="#h39-1" id="h39-1" class="h">@@ -16,7 +16,7 @@ pub trait Optimizer {
</a> pub struct ConstantFolder;
 
 impl Optimizer for ConstantFolder {
<a href="#h39-1-3" id="h39-1-3" class="d">-    fn optimize(&amp;mut self, node: Node) -&gt; Result&lt;Node, Error&gt; {
</a><a href="#h39-1-4" id="h39-1-4" class="i">+    fn optimize(&amp;mut self, node: Node) -&gt; Result&lt;Node&gt; {
</a>         let env = Environment::new();
         node.transform(&amp;|n| Ok(n), &amp;|n| {
             n.transform_expressions(&amp;|e| Ok(e), &amp;|e| {
<a href="#h39-2" id="h39-2" class="h">@@ -31,7 +31,7 @@ impl Optimizer for ConstantFolder {
</a> pub struct FilterPushdown;
 
 impl Optimizer for FilterPushdown {
<a href="#h39-2-3" id="h39-2-3" class="d">-    fn optimize(&amp;mut self, node: Node) -&gt; Result&lt;Node, Error&gt; {
</a><a href="#h39-2-4" id="h39-2-4" class="i">+    fn optimize(&amp;mut self, node: Node) -&gt; Result&lt;Node&gt; {
</a>         node.transform(
             &amp;|n| match n {
                 Node::Filter { source, predicate } =&gt; Self::pushdown(predicate, *source),
<a href="#h39-3" id="h39-3" class="h">@@ -44,7 +44,7 @@ impl Optimizer for FilterPushdown {
</a> 
 impl FilterPushdown {
     /// Attempts to push a predicate down into a target node, or returns a regular filter node.
<a href="#h39-3-3" id="h39-3-3" class="d">-    fn pushdown(mut predicate: Expression, target: Node) -&gt; Result&lt;Node, Error&gt; {
</a><a href="#h39-3-4" id="h39-3-4" class="i">+    fn pushdown(mut predicate: Expression, target: Node) -&gt; Result&lt;Node&gt; {
</a>         Ok(match target {
             // Filter nodes immediately before a scan node can be trivially pushed down, as long as
             // we remove any field qualifyers (e.g. movies table aliased as m).
<a href="#h39-4" id="h39-4" class="h">@@ -76,7 +76,7 @@ impl FilterPushdown {
</a>     fn requalify(
         expr: Expression,
         map: &amp;HashMap&lt;Option&lt;String&gt;, Option&lt;String&gt;&gt;,
<a href="#h39-4-3" id="h39-4-3" class="d">-    ) -&gt; Result&lt;Expression, Error&gt; {
</a><a href="#h39-4-4" id="h39-4-4" class="i">+    ) -&gt; Result&lt;Expression&gt; {
</a>         Ok(match expr {
             Expression::Field(relation, name) =&gt; match map.get(&amp;relation) {
                 Some(mapped) =&gt; Expression::Field(mapped.clone(), name),
<a href="#h39-5" id="h39-5" class="h">@@ -118,7 +118,7 @@ impl&lt;&#39;a, C: Catalog&gt; IndexLookup&lt;&#39;a, C&gt; {
</a> }
 
 impl&lt;&#39;a, C: Catalog&gt; Optimizer for IndexLookup&lt;&#39;a, C&gt; {
<a href="#h39-5-3" id="h39-5-3" class="d">-    fn optimize(&amp;mut self, node: Node) -&gt; Result&lt;Node, Error&gt; {
</a><a href="#h39-5-4" id="h39-5-4" class="i">+    fn optimize(&amp;mut self, node: Node) -&gt; Result&lt;Node&gt; {
</a>         node.transform(
             &amp;|n| match n {
                 // FIXME This needs to be smarter - at least handle ORs. Could be prettier too.
<b>diff --git a/<a id="h40" href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a> b/<a href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a></b>
<a href="#h40-0" id="h40-0" class="h">@@ -2,7 +2,7 @@ use super::super::parser::ast;
</a> use super::super::schema;
 use super::super::types::{Environment, Expression, Expressions, Value};
 use super::{Aggregate, Aggregates, Node, Plan};
<a href="#h40-0-3" id="h40-0-3" class="d">-use crate::Error;
</a><a href="#h40-0-4" id="h40-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 /// The plan builder
 pub struct Planner {}
<a href="#h40-1" id="h40-1" class="h">@@ -14,12 +14,12 @@ impl Planner {
</a>     }
 
     /// Builds a plan tree for an AST statement
<a href="#h40-1-3" id="h40-1-3" class="d">-    pub fn build(&amp;self, statement: ast::Statement) -&gt; Result&lt;Plan, Error&gt; {
</a><a href="#h40-1-4" id="h40-1-4" class="i">+    pub fn build(&amp;self, statement: ast::Statement) -&gt; Result&lt;Plan&gt; {
</a>         Ok(Plan(self.build_statement(statement)?))
     }
 
     /// Builds a plan node for a statement
<a href="#h40-1-9" id="h40-1-9" class="d">-    fn build_statement(&amp;self, statement: ast::Statement) -&gt; Result&lt;Node, Error&gt; {
</a><a href="#h40-1-10" id="h40-1-10" class="i">+    fn build_statement(&amp;self, statement: ast::Statement) -&gt; Result&lt;Node&gt; {
</a>         Ok(match statement {
             ast::Statement::Begin { .. } | ast::Statement::Commit | ast::Statement::Rollback =&gt; {
                 return Err(Error::Internal(format!(
<a href="#h40-2" id="h40-2" class="h">@@ -51,7 +51,7 @@ impl Planner {
</a>                 expressions: values
                     .into_iter()
                     .map(|exprs| self.build_expressions(exprs))
<a href="#h40-2-3" id="h40-2-3" class="d">-                    .collect::&lt;Result&lt;_, Error&gt;&gt;()?,
</a><a href="#h40-2-4" id="h40-2-4" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a>             },
             ast::Statement::Select {
                 select,
<a href="#h40-3" id="h40-3" class="h">@@ -175,7 +175,7 @@ impl Planner {
</a>                         orders: order
                             .into_iter()
                             .map(|(e, o)| self.build_expression(e).map(|e| (e, o.into())))
<a href="#h40-3-3" id="h40-3-3" class="d">-                            .collect::&lt;Result&lt;_, _&gt;&gt;()?,
</a><a href="#h40-3-4" id="h40-3-4" class="i">+                            .collect::&lt;Result&lt;_&gt;&gt;()?,
</a>                     };
                 }
                 if let Some(expr) = offset {
<a href="#h40-4" id="h40-4" class="h">@@ -223,13 +223,13 @@ impl Planner {
</a>                 expressions: set
                     .into_iter()
                     .map(|(c, e)| self.build_expression(e).map(|e| (c, e)))
<a href="#h40-4-3" id="h40-4-3" class="d">-                    .collect::&lt;Result&lt;_, _&gt;&gt;()?,
</a><a href="#h40-4-4" id="h40-4-4" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a>             },
         })
     }
 
     /// Builds FROM items
<a href="#h40-4-10" id="h40-4-10" class="d">-    fn build_from_item(&amp;self, item: ast::FromItem) -&gt; Result&lt;Node, Error&gt; {
</a><a href="#h40-4-11" id="h40-4-11" class="i">+    fn build_from_item(&amp;self, item: ast::FromItem) -&gt; Result&lt;Node&gt; {
</a>         Ok(match item {
             ast::FromItem::Table { name, alias } =&gt; Node::Scan { table: name, alias, filter: None },
             ast::FromItem::Join { left, right, r#type, predicate } =&gt; match r#type {
<a href="#h40-5" id="h40-5" class="h">@@ -259,12 +259,12 @@ impl Planner {
</a>     }
 
     /// Builds an expression from an AST expression
<a href="#h40-5-3" id="h40-5-3" class="d">-    fn build_expression(&amp;self, expr: ast::Expression) -&gt; Result&lt;Expression, Error&gt; {
</a><a href="#h40-5-4" id="h40-5-4" class="i">+    fn build_expression(&amp;self, expr: ast::Expression) -&gt; Result&lt;Expression&gt; {
</a>         ExpressionBuilder::build(expr)
     }
 
     /// Builds expressions from AST expressions
<a href="#h40-5-9" id="h40-5-9" class="d">-    fn build_expressions(&amp;self, exprs: ast::Expressions) -&gt; Result&lt;Expressions, Error&gt; {
</a><a href="#h40-5-10" id="h40-5-10" class="i">+    fn build_expressions(&amp;self, exprs: ast::Expressions) -&gt; Result&lt;Expressions&gt; {
</a>         ExpressionBuilder::build_many(exprs)
     }
 
<a href="#h40-6" id="h40-6" class="h">@@ -272,7 +272,7 @@ impl Planner {
</a>     fn build_aggregate_expressions(
         &amp;self,
         exprs: ast::Expressions,
<a href="#h40-6-3" id="h40-6-3" class="d">-    ) -&gt; Result&lt;(Expressions, Vec&lt;Aggregate&gt;, Expressions), Error&gt; {
</a><a href="#h40-6-4" id="h40-6-4" class="i">+    ) -&gt; Result&lt;(Expressions, Vec&lt;Aggregate&gt;, Expressions)&gt; {
</a>         ExpressionBuilder::build_aggregates(exprs)
     }
 
<a href="#h40-7" id="h40-7" class="h">@@ -281,7 +281,7 @@ impl Planner {
</a>         &amp;self,
         name: String,
         columns: Vec&lt;ast::ColumnSpec&gt;,
<a href="#h40-7-3" id="h40-7-3" class="d">-    ) -&gt; Result&lt;schema::Table, Error&gt; {
</a><a href="#h40-7-4" id="h40-7-4" class="i">+    ) -&gt; Result&lt;schema::Table&gt; {
</a>         schema::Table::new(
             name,
             columns
<a href="#h40-8" id="h40-8" class="h">@@ -314,7 +314,7 @@ impl Planner {
</a>                         references: c.references,
                     })
                 })
<a href="#h40-8-3" id="h40-8-3" class="d">-                .collect::&lt;Result&lt;_, Error&gt;&gt;()?,
</a><a href="#h40-8-4" id="h40-8-4" class="i">+                .collect::&lt;Result&lt;_&gt;&gt;()?,
</a>         )
     }
 }
<a href="#h40-9" id="h40-9" class="h">@@ -328,13 +328,13 @@ struct ExpressionBuilder {
</a> 
 impl ExpressionBuilder {
     /// Builds a single expression.
<a href="#h40-9-3" id="h40-9-3" class="d">-    fn build(expr: ast::Expression) -&gt; Result&lt;Expression, Error&gt; {
</a><a href="#h40-9-4" id="h40-9-4" class="i">+    fn build(expr: ast::Expression) -&gt; Result&lt;Expression&gt; {
</a>         Ok(*ExpressionBuilder { agg_allow: false, aggs: Vec::new(), agg_args: Vec::new() }
             .make(Box::new(expr))?)
     }
 
     /// Builds multiple expressions.
<a href="#h40-9-10" id="h40-9-10" class="d">-    fn build_many(exprs: ast::Expressions) -&gt; Result&lt;Expressions, Error&gt; {
</a><a href="#h40-9-11" id="h40-9-11" class="i">+    fn build_many(exprs: ast::Expressions) -&gt; Result&lt;Expressions&gt; {
</a>         exprs.into_iter().map(Self::build).collect()
     }
 
<a href="#h40-10" id="h40-10" class="h">@@ -342,9 +342,7 @@ impl ExpressionBuilder {
</a>     /// non-constant, non-aggregate expressions are pushed to the pre-projection as grouping
     /// expressions (caller should validate against GROUP BY), following expressions referenced by
     /// the aggregates.
<a href="#h40-10-3" id="h40-10-3" class="d">-    fn build_aggregates(
</a><a href="#h40-10-4" id="h40-10-4" class="d">-        exprs: ast::Expressions,
</a><a href="#h40-10-5" id="h40-10-5" class="d">-    ) -&gt; Result&lt;(Expressions, Aggregates, Expressions), Error&gt; {
</a><a href="#h40-10-6" id="h40-10-6" class="i">+    fn build_aggregates(exprs: ast::Expressions) -&gt; Result&lt;(Expressions, Aggregates, Expressions)&gt; {
</a>         let mut builder =
             ExpressionBuilder { agg_allow: true, aggs: Vec::new(), agg_args: Vec::new() };
 
<a href="#h40-11" id="h40-11" class="h">@@ -360,7 +358,7 @@ impl ExpressionBuilder {
</a> 
     /// Used internally, with more convenient signature.
     #[allow(clippy::boxed_local)]
<a href="#h40-11-3" id="h40-11-3" class="d">-    fn make(&amp;mut self, expr: Box&lt;ast::Expression&gt;) -&gt; Result&lt;Box&lt;Expression&gt;, Error&gt; {
</a><a href="#h40-11-4" id="h40-11-4" class="i">+    fn make(&amp;mut self, expr: Box&lt;ast::Expression&gt;) -&gt; Result&lt;Box&lt;Expression&gt;&gt; {
</a>         use Expression::*;
         Ok(Box::new(match *expr {
             ast::Expression::Literal(l) =&gt; Constant(match l {
<a href="#h40-12" id="h40-12" class="h">@@ -429,7 +427,7 @@ impl ExpressionBuilder {
</a>         &amp;mut self,
         name: &amp;str,
         expr: Box&lt;ast::Expression&gt;,
<a href="#h40-12-3" id="h40-12-3" class="d">-    ) -&gt; Result&lt;Box&lt;Expression&gt;, Error&gt; {
</a><a href="#h40-12-4" id="h40-12-4" class="i">+    ) -&gt; Result&lt;Box&lt;Expression&gt;&gt; {
</a>         if !self.agg_allow {
             return Err(Error::Value(format!(
                 &quot;Aggregate function {}() not allowed here&quot;,
<b>diff --git a/<a id="h41" href="../file/src/sql/schema.rs.html">src/sql/schema.rs</a> b/<a href="../file/src/sql/schema.rs.html">src/sql/schema.rs</a></b>
<a href="#h41-0" id="h41-0" class="h">@@ -1,7 +1,7 @@
</a> use super::engine::Transaction;
 use super::parser::format_ident;
 use super::types::{DataType, Environment, Row, Value};
<a href="#h41-0-3" id="h41-0-3" class="d">-use crate::Error;
</a><a href="#h41-0-4" id="h41-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 use serde_derive::{Deserialize, Serialize};
 use std::collections::HashMap;
<a href="#h41-1" id="h41-1" class="h">@@ -9,16 +9,16 @@ use std::collections::HashMap;
</a> /// The catalog stores schema information
 pub trait Catalog {
     /// Creates a new table
<a href="#h41-1-3" id="h41-1-3" class="d">-    fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h41-1-4" id="h41-1-4" class="i">+    fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;()&gt;;
</a>     /// Deletes an existing table, or errors if it does not exist
<a href="#h41-1-6" id="h41-1-6" class="d">-    fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h41-1-7" id="h41-1-7" class="i">+    fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;()&gt;;
</a>     /// Reads a table, if it exists
<a href="#h41-1-9" id="h41-1-9" class="d">-    fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;, Error&gt;;
</a><a href="#h41-1-10" id="h41-1-10" class="i">+    fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;&gt;;
</a>     /// Iterates over all tables
<a href="#h41-1-12" id="h41-1-12" class="d">-    fn scan_tables(&amp;self) -&gt; Result&lt;Tables, Error&gt;;
</a><a href="#h41-1-13" id="h41-1-13" class="i">+    fn scan_tables(&amp;self) -&gt; Result&lt;Tables&gt;;
</a> 
     /// Reads a table, and errors if it does not exist
<a href="#h41-1-16" id="h41-1-16" class="d">-    fn must_read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Table, Error&gt; {
</a><a href="#h41-1-17" id="h41-1-17" class="i">+    fn must_read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Table&gt; {
</a>         self.read_table(table)?
             .ok_or_else(|| Error::Value(format!(&quot;Table {} does not exist&quot;, table)))
     }
<a href="#h41-2" id="h41-2" class="h">@@ -38,7 +38,7 @@ pub struct Table {
</a> 
 impl Table {
     /// Creates a new table schema
<a href="#h41-2-3" id="h41-2-3" class="d">-    pub fn new(name: String, columns: Vec&lt;Column&gt;) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h41-2-4" id="h41-2-4" class="i">+    pub fn new(name: String, columns: Vec&lt;Column&gt;) -&gt; Result&lt;Self&gt; {
</a>         let table = Self { name, columns };
         Ok(table)
     }
<a href="#h41-3" id="h41-3" class="h">@@ -57,7 +57,7 @@ impl Table {
</a>     }
 
     /// Asserts that the table is not referenced by other tables, otherwise returns an error
<a href="#h41-3-3" id="h41-3-3" class="d">-    pub fn assert_unreferenced(&amp;self, txn: &amp;mut dyn Transaction) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h41-3-4" id="h41-3-4" class="i">+    pub fn assert_unreferenced(&amp;self, txn: &amp;mut dyn Transaction) -&gt; Result&lt;()&gt; {
</a>         for source in txn.scan_tables()?.filter(|t| t.name != self.name) {
             if let Some(column) =
                 source.columns.iter().find(|c| c.references.as_ref() == Some(&amp;self.name))
<a href="#h41-4" id="h41-4" class="h">@@ -72,11 +72,7 @@ impl Table {
</a>     }
 
     /// Asserts that this primary key is not referenced from any other rows, otherwise errors
<a href="#h41-4-3" id="h41-4-3" class="d">-    pub fn assert_unreferenced_key(
</a><a href="#h41-4-4" id="h41-4-4" class="d">-        &amp;self,
</a><a href="#h41-4-5" id="h41-4-5" class="d">-        pk: &amp;Value,
</a><a href="#h41-4-6" id="h41-4-6" class="d">-        txn: &amp;mut dyn Transaction,
</a><a href="#h41-4-7" id="h41-4-7" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h41-4-8" id="h41-4-8" class="i">+    pub fn assert_unreferenced_key(&amp;self, pk: &amp;Value, txn: &amp;mut dyn Transaction) -&gt; Result&lt;()&gt; {
</a>         for source in txn.scan_tables()? {
             let refs = source
                 .columns
<a href="#h41-5" id="h41-5" class="h">@@ -105,21 +101,21 @@ impl Table {
</a>     }
 
     /// Fetches a column by name
<a href="#h41-5-3" id="h41-5-3" class="d">-    pub fn get_column(&amp;self, name: &amp;str) -&gt; Result&lt;&amp;Column, Error&gt; {
</a><a href="#h41-5-4" id="h41-5-4" class="i">+    pub fn get_column(&amp;self, name: &amp;str) -&gt; Result&lt;&amp;Column&gt; {
</a>         self.columns.iter().find(|c| c.name == name).ok_or_else(|| {
             Error::Value(format!(&quot;Column {} not found in table {}&quot;, name, self.name))
         })
     }
 
     /// Fetches a column index by name
<a href="#h41-5-11" id="h41-5-11" class="d">-    pub fn get_column_index(&amp;self, name: &amp;str) -&gt; Result&lt;usize, Error&gt; {
</a><a href="#h41-5-12" id="h41-5-12" class="i">+    pub fn get_column_index(&amp;self, name: &amp;str) -&gt; Result&lt;usize&gt; {
</a>         self.columns.iter().position(|c| c.name == name).ok_or_else(|| {
             Error::Value(format!(&quot;Column {} not found in table {}&quot;, name, self.name))
         })
     }
 
     /// Returns the primary key column of the table
<a href="#h41-5-19" id="h41-5-19" class="d">-    pub fn get_primary_key(&amp;self) -&gt; Result&lt;&amp;Column, Error&gt; {
</a><a href="#h41-5-20" id="h41-5-20" class="i">+    pub fn get_primary_key(&amp;self) -&gt; Result&lt;&amp;Column&gt; {
</a>         self.columns
             .iter()
             .find(|c| c.primary_key)
<a href="#h41-6" id="h41-6" class="h">@@ -127,7 +123,7 @@ impl Table {
</a>     }
 
     /// Returns the primary key value of a row
<a href="#h41-6-3" id="h41-6-3" class="d">-    pub fn get_row_key(&amp;self, row: &amp;[Value]) -&gt; Result&lt;Value, Error&gt; {
</a><a href="#h41-6-4" id="h41-6-4" class="i">+    pub fn get_row_key(&amp;self, row: &amp;[Value]) -&gt; Result&lt;Value&gt; {
</a>         row.get(
             self.columns
                 .iter()
<a href="#h41-7" id="h41-7" class="h">@@ -140,7 +136,7 @@ impl Table {
</a> 
     // Builds a row from a set of values, optionally with a set of column names, padding
     // it with default values as necessary.
<a href="#h41-7-3" id="h41-7-3" class="d">-    pub fn make_row(&amp;self, columns: &amp;[String], values: Vec&lt;Value&gt;) -&gt; Result&lt;Row, Error&gt; {
</a><a href="#h41-7-4" id="h41-7-4" class="i">+    pub fn make_row(&amp;self, columns: &amp;[String], values: Vec&lt;Value&gt;) -&gt; Result&lt;Row&gt; {
</a>         if columns.len() != values.len() {
             return Err(Error::Value(&quot;Column and value counts do not match&quot;.into()));
         }
<a href="#h41-8" id="h41-8" class="h">@@ -165,7 +161,7 @@ impl Table {
</a>     }
 
     /// Pads a row with default values where possible
<a href="#h41-8-3" id="h41-8-3" class="d">-    pub fn pad_row(&amp;self, mut row: Row) -&gt; Result&lt;Row, Error&gt; {
</a><a href="#h41-8-4" id="h41-8-4" class="i">+    pub fn pad_row(&amp;self, mut row: Row) -&gt; Result&lt;Row&gt; {
</a>         for column in self.columns.iter().skip(row.len()) {
             if let Some(default) = &amp;column.default {
                 row.push(default.clone())
<a href="#h41-9" id="h41-9" class="h">@@ -187,14 +183,14 @@ impl Table {
</a>     }
 
     /// Sets a named row field to a value
<a href="#h41-9-3" id="h41-9-3" class="d">-    pub fn set_row_field(&amp;self, row: &amp;mut Row, field: &amp;str, value: Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h41-9-4" id="h41-9-4" class="i">+    pub fn set_row_field(&amp;self, row: &amp;mut Row, field: &amp;str, value: Value) -&gt; Result&lt;()&gt; {
</a>         *row.get_mut(self.get_column_index(field)?)
             .ok_or_else(|| Error::Value(format!(&quot;Field {} not found in row&quot;, field)))? = value;
         Ok(())
     }
 
     /// Validates the table schema
<a href="#h41-9-11" id="h41-9-11" class="d">-    pub fn validate(&amp;self, txn: &amp;mut dyn Transaction) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h41-9-12" id="h41-9-12" class="i">+    pub fn validate(&amp;self, txn: &amp;mut dyn Transaction) -&gt; Result&lt;()&gt; {
</a>         if self.columns.is_empty() {
             return Err(Error::Value(format!(&quot;Table {} has no columns&quot;, self.name)));
         }
<a href="#h41-10" id="h41-10" class="h">@@ -210,7 +206,7 @@ impl Table {
</a>     }
 
     /// Validates a row
<a href="#h41-10-3" id="h41-10-3" class="d">-    pub fn validate_row(&amp;self, row: &amp;[Value], txn: &amp;mut dyn Transaction) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h41-10-4" id="h41-10-4" class="i">+    pub fn validate_row(&amp;self, row: &amp;[Value], txn: &amp;mut dyn Transaction) -&gt; Result&lt;()&gt; {
</a>         if row.len() != self.columns.len() {
             return Err(Error::Value(format!(&quot;Invalid row size for table {}&quot;, self.name)));
         }
<a href="#h41-11" id="h41-11" class="h">@@ -270,7 +266,7 @@ impl Column {
</a>     }
 
     /// Validates the column schema
<a href="#h41-11-3" id="h41-11-3" class="d">-    pub fn validate(&amp;self, table: &amp;Table, txn: &amp;mut dyn Transaction) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h41-11-4" id="h41-11-4" class="i">+    pub fn validate(&amp;self, table: &amp;Table, txn: &amp;mut dyn Transaction) -&gt; Result&lt;()&gt; {
</a>         // Validate primary key
         if self.primary_key &amp;&amp; self.nullable {
             return Err(Error::Value(format!(&quot;Primary key {} cannot be nullable&quot;, self.name)));
<a href="#h41-12" id="h41-12" class="h">@@ -334,7 +330,7 @@ impl Column {
</a>         pk: &amp;Value,
         value: &amp;Value,
         txn: &amp;mut dyn Transaction,
<a href="#h41-12-3" id="h41-12-3" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h41-12-4" id="h41-12-4" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         // Validate datatype
         match value.datatype() {
             None if self.nullable =&gt; Ok(()),
<b>diff --git a/<a id="h42" href="../file/src/sql/types/expression.rs.html">src/sql/types/expression.rs</a> b/<a href="../file/src/sql/types/expression.rs.html">src/sql/types/expression.rs</a></b>
<a href="#h42-0" id="h42-0" class="h">@@ -1,5 +1,5 @@
</a> use super::Value;
<a href="#h42-0-1" id="h42-0-1" class="d">-use crate::Error;
</a><a href="#h42-0-2" id="h42-0-2" class="i">+use crate::error::{Error, Result};
</a> 
 use regex::Regex;
 use serde_derive::{Deserialize, Serialize};
<a href="#h42-1" id="h42-1" class="h">@@ -44,7 +44,7 @@ pub type Expressions = Vec&lt;Expression&gt;;
</a> 
 impl Expression {
     /// Evaluates an expression to a value, given an environment
<a href="#h42-1-3" id="h42-1-3" class="d">-    pub fn evaluate(&amp;self, env: &amp;Environment) -&gt; Result&lt;Value, Error&gt; {
</a><a href="#h42-1-4" id="h42-1-4" class="i">+    pub fn evaluate(&amp;self, env: &amp;Environment) -&gt; Result&lt;Value&gt; {
</a>         use Value::*;
         Ok(match self {
             // Constant values
<a href="#h42-2" id="h42-2" class="h">@@ -274,10 +274,10 @@ impl Expression {
</a> 
     /// Transforms the expression tree, by applying a callback function to it
     /// before and/or after descending into it.
<a href="#h42-2-3" id="h42-2-3" class="d">-    pub fn transform&lt;B, A&gt;(mut self, pre: &amp;B, post: &amp;A) -&gt; Result&lt;Self, Error&gt;
</a><a href="#h42-2-4" id="h42-2-4" class="i">+    pub fn transform&lt;B, A&gt;(mut self, pre: &amp;B, post: &amp;A) -&gt; Result&lt;Self&gt;
</a>     where
<a href="#h42-2-6" id="h42-2-6" class="d">-        B: Fn(Self) -&gt; Result&lt;Self, Error&gt;,
</a><a href="#h42-2-7" id="h42-2-7" class="d">-        A: Fn(Self) -&gt; Result&lt;Self, Error&gt;,
</a><a href="#h42-2-8" id="h42-2-8" class="i">+        B: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h42-2-9" id="h42-2-9" class="i">+        A: Fn(Self) -&gt; Result&lt;Self&gt;,
</a>     {
         self = pre(self)?;
         // FIXME Ugly having to explicitly reconstruct each variant, but unable to
<a href="#h42-3" id="h42-3" class="h">@@ -412,7 +412,7 @@ impl&lt;&#39;a&gt; Environment&lt;&#39;a&gt; {
</a>     }
 
     /// Looks up a value by field
<a href="#h42-3-3" id="h42-3-3" class="d">-    pub fn lookup_field(&amp;self, relation: Option&lt;&amp;&#39;a str&gt;, field: &amp;&#39;a str) -&gt; Result&lt;Value, Error&gt; {
</a><a href="#h42-3-4" id="h42-3-4" class="i">+    pub fn lookup_field(&amp;self, relation: Option&lt;&amp;&#39;a str&gt;, field: &amp;&#39;a str) -&gt; Result&lt;Value&gt; {
</a>         if let Some(relation) = relation {
             match self.qualified.get(&amp;(relation, field)) {
                 Some(r) =&gt; Ok((*r).clone()),
<a href="#h42-4" id="h42-4" class="h">@@ -429,7 +429,7 @@ impl&lt;&#39;a&gt; Environment&lt;&#39;a&gt; {
</a>     }
 
     /// Looks up a value by index
<a href="#h42-4-3" id="h42-4-3" class="d">-    pub fn lookup_index(&amp;self, index: usize) -&gt; Result&lt;Value, Error&gt; {
</a><a href="#h42-4-4" id="h42-4-4" class="i">+    pub fn lookup_index(&amp;self, index: usize) -&gt; Result&lt;Value&gt; {
</a>         match self.index.get(index) {
             Some(r) =&gt; Ok((*r).clone()),
             None =&gt; Err(Error::Value(format!(&quot;Index {} out of bounds&quot;, index))),
<b>diff --git a/<a id="h43" href="../file/src/sql/types/mod.rs.html">src/sql/types/mod.rs</a> b/<a href="../file/src/sql/types/mod.rs.html">src/sql/types/mod.rs</a></b>
<a href="#h43-0" id="h43-0" class="h">@@ -1,7 +1,7 @@
</a> mod expression;
 pub use expression::{Environment, Expression, Expressions};
 
<a href="#h43-0-3" id="h43-0-3" class="d">-use crate::Error;
</a><a href="#h43-0-4" id="h43-0-4" class="i">+use crate::error::{Error, Result};
</a> 
 use derivative::Derivative;
 use serde_derive::{Deserialize, Serialize};
<a href="#h43-1" id="h43-1" class="h">@@ -67,7 +67,7 @@ impl Value {
</a>     }
 
     /// Returns the inner boolean, or an error if not a boolean
<a href="#h43-1-3" id="h43-1-3" class="d">-    pub fn boolean(self) -&gt; Result&lt;bool, Error&gt; {
</a><a href="#h43-1-4" id="h43-1-4" class="i">+    pub fn boolean(self) -&gt; Result&lt;bool&gt; {
</a>         match self {
             Self::Boolean(b) =&gt; Ok(b),
             v =&gt; Err(Error::Value(format!(&quot;Not a boolean: {:?}&quot;, v))),
<a href="#h43-2" id="h43-2" class="h">@@ -75,7 +75,7 @@ impl Value {
</a>     }
 
     /// Returns the inner float, or an error if not a float
<a href="#h43-2-3" id="h43-2-3" class="d">-    pub fn float(self) -&gt; Result&lt;f64, Error&gt; {
</a><a href="#h43-2-4" id="h43-2-4" class="i">+    pub fn float(self) -&gt; Result&lt;f64&gt; {
</a>         match self {
             Self::Float(f) =&gt; Ok(f),
             v =&gt; Err(Error::Value(format!(&quot;Not a float: {:?}&quot;, v))),
<a href="#h43-3" id="h43-3" class="h">@@ -83,7 +83,7 @@ impl Value {
</a>     }
 
     /// Returns the inner integer, or an error if not an integer
<a href="#h43-3-3" id="h43-3-3" class="d">-    pub fn integer(self) -&gt; Result&lt;i64, Error&gt; {
</a><a href="#h43-3-4" id="h43-3-4" class="i">+    pub fn integer(self) -&gt; Result&lt;i64&gt; {
</a>         match self {
             Self::Integer(i) =&gt; Ok(i),
             v =&gt; Err(Error::Value(format!(&quot;Not an integer: {:?}&quot;, v))),
<a href="#h43-4" id="h43-4" class="h">@@ -91,7 +91,7 @@ impl Value {
</a>     }
 
     /// Returns the inner string, or an error if not a string
<a href="#h43-4-3" id="h43-4-3" class="d">-    pub fn string(self) -&gt; Result&lt;String, Error&gt; {
</a><a href="#h43-4-4" id="h43-4-4" class="i">+    pub fn string(self) -&gt; Result&lt;String&gt; {
</a>         match self {
             Self::String(s) =&gt; Ok(s),
             v =&gt; Err(Error::Value(format!(&quot;Not a string: {:?}&quot;, v))),
<a href="#h43-5" id="h43-5" class="h">@@ -166,7 +166,7 @@ impl From&lt;&amp;str&gt; for Value {
</a> pub type Row = Vec&lt;Value&gt;;
 
 /// A row iterator
<a href="#h43-5-3" id="h43-5-3" class="d">-pub type Rows = Box&lt;dyn Iterator&lt;Item = Result&lt;Row, Error&gt;&gt; + Send&gt;;
</a><a href="#h43-5-4" id="h43-5-4" class="i">+pub type Rows = Box&lt;dyn Iterator&lt;Item = Result&lt;Row&gt;&gt; + Send&gt;;
</a> 
 /// A column (in a result set, see schema::Column for table columns)
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
<a href="#h43-6" id="h43-6" class="h">@@ -192,18 +192,18 @@ pub struct Relation {
</a> 
 impl Relation {
     /// Converts the relation into a single row, if any
<a href="#h43-6-3" id="h43-6-3" class="d">-    pub fn into_row(mut self) -&gt; Result&lt;Option&lt;Row&gt;, Error&gt; {
</a><a href="#h43-6-4" id="h43-6-4" class="i">+    pub fn into_row(mut self) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
</a>         self.next().transpose()
     }
 
     /// Converts the relation into the first value of the first row, if any
<a href="#h43-6-9" id="h43-6-9" class="d">-    pub fn into_value(self) -&gt; Result&lt;Option&lt;Value&gt;, Error&gt; {
</a><a href="#h43-6-10" id="h43-6-10" class="i">+    pub fn into_value(self) -&gt; Result&lt;Option&lt;Value&gt;&gt; {
</a>         Ok(self.into_row()?.filter(|row| !row.is_empty()).map(|mut row| row.remove(0)))
     }
 }
 
 impl Iterator for Relation {
<a href="#h43-6-16" id="h43-6-16" class="d">-    type Item = Result&lt;Row, Error&gt;;
</a><a href="#h43-6-17" id="h43-6-17" class="i">+    type Item = Result&lt;Row&gt;;
</a> 
     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
         // Make sure iteration is aborted on the first error, otherwise callers
<b>diff --git a/<a id="h44" href="../file/src/storage/kv/memory.rs.html">src/storage/kv/memory.rs</a> b/<a href="../file/src/storage/kv/memory.rs.html">src/storage/kv/memory.rs</a></b>
<a href="#h44-0" id="h44-0" class="h">@@ -1,5 +1,5 @@
</a> use super::{Scan, Store};
<a href="#h44-0-1" id="h44-0-1" class="d">-use crate::Error;
</a><a href="#h44-0-2" id="h44-0-2" class="i">+use crate::error::Result;
</a> 
 use std::collections::BTreeMap;
 use std::ops::RangeBounds;
<a href="#h44-1" id="h44-1" class="h">@@ -17,16 +17,16 @@ impl Memory {
</a> }
 
 impl Store for Memory {
<a href="#h44-1-3" id="h44-1-3" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h44-1-4" id="h44-1-4" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a>         Ok(())
     }
 
<a href="#h44-1-8" id="h44-1-8" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h44-1-9" id="h44-1-9" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a>         self.data.remove(key);
         Ok(())
     }
 
<a href="#h44-1-14" id="h44-1-14" class="d">-    fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h44-1-15" id="h44-1-15" class="i">+    fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         Ok(self.data.get(key).cloned())
     }
 
<a href="#h44-2" id="h44-2" class="h">@@ -34,7 +34,7 @@ impl Store for Memory {
</a>         Box::new(self.data.range(range).map(|(k, v)| Ok((k.clone(), v.clone()))))
     }
 
<a href="#h44-2-3" id="h44-2-3" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h44-2-4" id="h44-2-4" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a>         self.data.insert(key.to_vec(), value);
         Ok(())
     }
<a href="#h44-3" id="h44-3" class="h">@@ -42,13 +42,13 @@ impl Store for Memory {
</a> 
 #[cfg(test)]
 impl super::TestSuite&lt;Memory&gt; for Memory {
<a href="#h44-3-3" id="h44-3-3" class="d">-    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h44-3-4" id="h44-3-4" class="i">+    fn setup() -&gt; Result&lt;Self&gt; {
</a>         Ok(Memory::new())
     }
 }
 
 #[test]
<a href="#h44-3-10" id="h44-3-10" class="d">-fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h44-3-11" id="h44-3-11" class="i">+fn tests() -&gt; Result&lt;()&gt; {
</a>     use super::TestSuite;
     Memory::test()
 }
<b>diff --git a/<a id="h45" href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a> b/<a href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a></b>
<a href="#h45-0" id="h45-0" class="h">@@ -8,35 +8,35 @@ pub use mvcc::MVCC;
</a> #[cfg(test)]
 pub use test::Test;
 
<a href="#h45-0-3" id="h45-0-3" class="d">-use crate::Error;
</a><a href="#h45-0-4" id="h45-0-4" class="i">+use crate::error::Result;
</a> use std::ops::RangeBounds;
 
 /// Key/value store.
 pub trait Store {
     /// Deletes a key, if it exists.
<a href="#h45-0-10" id="h45-0-10" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h45-0-11" id="h45-0-11" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt;;
</a> 
     /// Flushes data to storage.
<a href="#h45-0-14" id="h45-0-14" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h45-0-15" id="h45-0-15" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</a> 
     /// Gets a value for a key, or `None` if it does not exist.
<a href="#h45-0-18" id="h45-0-18" class="d">-    fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt;;
</a><a href="#h45-0-19" id="h45-0-19" class="i">+    fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
</a> 
     /// Returns an iterator over a range of key/value pairs.
     fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Scan;
 
     /// Writes a value for a key, replacing the existing value if any.
<a href="#h45-0-25" id="h45-0-25" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h45-0-26" id="h45-0-26" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;
</a> }
 
 /// Iterator over a key/value range.
<a href="#h45-0-30" id="h45-0-30" class="d">-pub type Scan&lt;&#39;a&gt; = Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;), Error&gt;&gt; + &#39;a&gt;;
</a><a href="#h45-0-31" id="h45-0-31" class="i">+pub type Scan&lt;&#39;a&gt; = Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; + &#39;a&gt;;
</a> 
 #[cfg(test)]
 trait TestSuite&lt;S: Store&gt; {
<a href="#h45-0-35" id="h45-0-35" class="d">-    fn setup() -&gt; Result&lt;S, Error&gt;;
</a><a href="#h45-0-36" id="h45-0-36" class="i">+    fn setup() -&gt; Result&lt;S&gt;;
</a> 
<a href="#h45-0-38" id="h45-0-38" class="d">-    fn test() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h45-0-39" id="h45-0-39" class="i">+    fn test() -&gt; Result&lt;()&gt; {
</a>         Self::test_delete()?;
         Self::test_get()?;
         Self::test_scan()?;
<a href="#h45-1" id="h45-1" class="h">@@ -44,7 +44,7 @@ trait TestSuite&lt;S: Store&gt; {
</a>         Ok(())
     }
 
<a href="#h45-1-3" id="h45-1-3" class="d">-    fn test_get() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h45-1-4" id="h45-1-4" class="i">+    fn test_get() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
         s.set(b&quot;a&quot;, vec![0x01])?;
         assert_eq!(Some(vec![0x01]), s.get(b&quot;a&quot;)?);
<a href="#h45-2" id="h45-2" class="h">@@ -52,7 +52,7 @@ trait TestSuite&lt;S: Store&gt; {
</a>         Ok(())
     }
 
<a href="#h45-2-3" id="h45-2-3" class="d">-    fn test_delete() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h45-2-4" id="h45-2-4" class="i">+    fn test_delete() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
         s.set(b&quot;a&quot;, vec![0x01])?;
         assert_eq!(Some(vec![0x01]), s.get(b&quot;a&quot;)?);
<a href="#h45-3" id="h45-3" class="h">@@ -62,7 +62,7 @@ trait TestSuite&lt;S: Store&gt; {
</a>         Ok(())
     }
 
<a href="#h45-3-3" id="h45-3-3" class="d">-    fn test_scan() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h45-3-4" id="h45-3-4" class="i">+    fn test_scan() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
         s.set(b&quot;a&quot;, vec![0x01])?;
         s.set(b&quot;b&quot;, vec![0x02])?;
<a href="#h45-4" id="h45-4" class="h">@@ -77,7 +77,7 @@ trait TestSuite&lt;S: Store&gt; {
</a>                 (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                 (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
             ],
<a href="#h45-4-3" id="h45-4-3" class="d">-            s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h45-4-4" id="h45-4-4" class="i">+            s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(
             vec![
<a href="#h45-5" id="h45-5" class="h">@@ -85,13 +85,13 @@ trait TestSuite&lt;S: Store&gt; {
</a>                 (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                 (b&quot;b&quot;.to_vec(), vec![0x02]),
             ],
<a href="#h45-5-3" id="h45-5-3" class="d">-            s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).rev().collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h45-5-4" id="h45-5-4" class="i">+            s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Inclusive/exclusive ranges
         assert_eq!(
             vec![(b&quot;b&quot;.to_vec(), vec![0x02]), (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),],
<a href="#h45-5-10" id="h45-5-10" class="d">-            s.scan(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h45-5-11" id="h45-5-11" class="i">+            s.scan(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(
             vec![
<a href="#h45-6" id="h45-6" class="h">@@ -99,17 +99,17 @@ trait TestSuite&lt;S: Store&gt; {
</a>                 (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                 (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
             ],
<a href="#h45-6-3" id="h45-6-3" class="d">-            s.scan(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h45-6-4" id="h45-6-4" class="i">+            s.scan(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Open ranges
         assert_eq!(
             vec![(b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]), (b&quot;c&quot;.to_vec(), vec![0x03]),],
<a href="#h45-6-10" id="h45-6-10" class="d">-            s.scan(b&quot;bb&quot;.to_vec()..).collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h45-6-11" id="h45-6-11" class="i">+            s.scan(b&quot;bb&quot;.to_vec()..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(
             vec![(b&quot;a&quot;.to_vec(), vec![0x01]), (b&quot;b&quot;.to_vec(), vec![0x02]),],
<a href="#h45-6-15" id="h45-6-15" class="d">-            s.scan(..=b&quot;b&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h45-6-16" id="h45-6-16" class="i">+            s.scan(..=b&quot;b&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Full range
<a href="#h45-7" id="h45-7" class="h">@@ -121,12 +121,12 @@ trait TestSuite&lt;S: Store&gt; {
</a>                 (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
                 (b&quot;c&quot;.to_vec(), vec![0x03]),
             ],
<a href="#h45-7-3" id="h45-7-3" class="d">-            s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h45-7-4" id="h45-7-4" class="i">+            s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         Ok(())
     }
 
<a href="#h45-7-9" id="h45-7-9" class="d">-    fn test_set() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h45-7-10" id="h45-7-10" class="i">+    fn test_set() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
         s.set(b&quot;a&quot;, vec![0x01])?;
         assert_eq!(Some(vec![0x01]), s.get(b&quot;a&quot;)?);
<b>diff --git a/<a id="h46" href="../file/src/storage/kv/mvcc.rs.html">src/storage/kv/mvcc.rs</a> b/<a href="../file/src/storage/kv/mvcc.rs.html">src/storage/kv/mvcc.rs</a></b>
<a href="#h46-0" id="h46-0" class="h">@@ -1,5 +1,5 @@
</a> use super::Store;
<a href="#h46-0-1" id="h46-0-1" class="d">-use crate::Error;
</a><a href="#h46-0-2" id="h46-0-2" class="i">+use crate::error::{Error, Result};
</a> 
 use serde::{Deserialize, Serialize};
 use serde_derive::{Deserialize, Serialize};
<a href="#h46-1" id="h46-1" class="h">@@ -36,28 +36,28 @@ impl&lt;S: Store&gt; MVCC&lt;S&gt; {
</a> 
     /// Begins a new transaction in read-write mode.
     #[allow(dead_code)]
<a href="#h46-1-3" id="h46-1-3" class="d">-    pub fn begin(&amp;self) -&gt; Result&lt;Transaction&lt;S&gt;, Error&gt; {
</a><a href="#h46-1-4" id="h46-1-4" class="i">+    pub fn begin(&amp;self) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a>         Transaction::begin(self.store.clone(), Mode::ReadWrite)
     }
 
     /// Begins a new transaction in the given mode.
<a href="#h46-1-9" id="h46-1-9" class="d">-    pub fn begin_with_mode(&amp;self, mode: Mode) -&gt; Result&lt;Transaction&lt;S&gt;, Error&gt; {
</a><a href="#h46-1-10" id="h46-1-10" class="i">+    pub fn begin_with_mode(&amp;self, mode: Mode) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a>         Transaction::begin(self.store.clone(), mode)
     }
 
     /// Resumes a transaction with the given ID.
<a href="#h46-1-15" id="h46-1-15" class="d">-    pub fn resume(&amp;self, id: u64) -&gt; Result&lt;Transaction&lt;S&gt;, Error&gt; {
</a><a href="#h46-1-16" id="h46-1-16" class="i">+    pub fn resume(&amp;self, id: u64) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a>         Transaction::resume(self.store.clone(), id)
     }
 
     /// Fetches an unversioned metadata value
<a href="#h46-1-21" id="h46-1-21" class="d">-    pub fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h46-1-22" id="h46-1-22" class="i">+    pub fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         let session = self.store.read()?;
         session.get(key)
     }
 
     /// Sets an unversioned metadata value
<a href="#h46-1-28" id="h46-1-28" class="d">-    pub fn set_metadata(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-1-29" id="h46-1-29" class="i">+    pub fn set_metadata(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a>         let mut session = self.store.write()?;
         session.set(key, value)
     }
<a href="#h46-2" id="h46-2" class="h">@@ -67,7 +67,7 @@ impl&lt;S: Store&gt; MVCC&lt;S&gt; {
</a>     // Bizarrely, the return statement is in fact necessary - see:
     // https://github.com/rust-lang/reference/issues/452
     #[allow(clippy::needless_return)]
<a href="#h46-2-3" id="h46-2-3" class="d">-    pub fn status(&amp;self) -&gt; Result&lt;Status, Error&gt; {
</a><a href="#h46-2-4" id="h46-2-4" class="i">+    pub fn status(&amp;self) -&gt; Result&lt;Status&gt; {
</a>         let session = self.store.read()?;
         return Ok(Status {
             txns: match session.get(&amp;Key::TxnNext.encode())? {
<a href="#h46-3" id="h46-3" class="h">@@ -82,12 +82,12 @@ impl&lt;S: Store&gt; MVCC&lt;S&gt; {
</a> }
 
 /// Serializes MVCC metadata.
<a href="#h46-3-3" id="h46-3-3" class="d">-fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h46-3-4" id="h46-3-4" class="i">+fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>     Ok(bincode::serialize(value)?)
 }
 
 /// Deserializes MVCC metadata.
<a href="#h46-3-9" id="h46-3-9" class="d">-fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V, Error&gt; {
</a><a href="#h46-3-10" id="h46-3-10" class="i">+fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a>     Ok(bincode::deserialize(bytes)?)
 }
 
<a href="#h46-4" id="h46-4" class="h">@@ -105,7 +105,7 @@ pub struct Transaction&lt;S: Store&gt; {
</a> 
 impl&lt;S: Store&gt; Transaction&lt;S&gt; {
     /// Begins a new transaction in the given mode.
<a href="#h46-4-3" id="h46-4-3" class="d">-    fn begin(store: Arc&lt;RwLock&lt;S&gt;&gt;, mode: Mode) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h46-4-4" id="h46-4-4" class="i">+    fn begin(store: Arc&lt;RwLock&lt;S&gt;&gt;, mode: Mode) -&gt; Result&lt;Self&gt; {
</a>         let mut session = store.write()?;
 
         let id = match session.get(&amp;Key::TxnNext.encode())? {
<a href="#h46-5" id="h46-5" class="h">@@ -128,7 +128,7 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>     }
 
     /// Resumes an active transaction with the given ID. Errors if the transaction is not active.
<a href="#h46-5-3" id="h46-5-3" class="d">-    fn resume(store: Arc&lt;RwLock&lt;S&gt;&gt;, id: u64) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h46-5-4" id="h46-5-4" class="i">+    fn resume(store: Arc&lt;RwLock&lt;S&gt;&gt;, id: u64) -&gt; Result&lt;Self&gt; {
</a>         let session = store.read()?;
         let mode = match session.get(&amp;Key::TxnActive(id).encode())? {
             Some(v) =&gt; deserialize(&amp;v)?,
<a href="#h46-6" id="h46-6" class="h">@@ -153,14 +153,14 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>     }
 
     /// Commits the transaction, by removing the txn from the active set.
<a href="#h46-6-3" id="h46-6-3" class="d">-    pub fn commit(self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-6-4" id="h46-6-4" class="i">+    pub fn commit(self) -&gt; Result&lt;()&gt; {
</a>         let mut session = self.store.write()?;
         session.delete(&amp;Key::TxnActive(self.id).encode())?;
         session.flush()
     }
 
     /// Rolls back the transaction, by removing all updated entries.
<a href="#h46-6-11" id="h46-6-11" class="d">-    pub fn rollback(self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-6-12" id="h46-6-12" class="i">+    pub fn rollback(self) -&gt; Result&lt;()&gt; {
</a>         let mut session = self.store.write()?;
         if self.mode.mutable() {
             let mut rollback = Vec::new();
<a href="#h46-7" id="h46-7" class="h">@@ -184,12 +184,12 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>     }
 
     /// Deletes a key.
<a href="#h46-7-3" id="h46-7-3" class="d">-    pub fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-7-4" id="h46-7-4" class="i">+    pub fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a>         self.write(key, None)
     }
 
     /// Fetches a key.
<a href="#h46-7-9" id="h46-7-9" class="d">-    pub fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h46-7-10" id="h46-7-10" class="i">+    pub fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         let session = self.store.read()?;
         let mut scan = session
             .scan(
<a href="#h46-8" id="h46-8" class="h">@@ -210,12 +210,12 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>     }
 
     /// Scans a key range.
<a href="#h46-8-3" id="h46-8-3" class="d">-    pub fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;super::Scan, Error&gt; {
</a><a href="#h46-8-4" id="h46-8-4" class="i">+    pub fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;super::Scan&gt; {
</a>         Ok(Box::new(Scan::new(self.store.clone(), self.snapshot.clone(), range)?))
     }
 
     /// Scans keys under a given prefix.
<a href="#h46-8-9" id="h46-8-9" class="d">-    pub fn scan_prefix(&amp;self, prefix: &amp;[u8]) -&gt; Result&lt;super::Scan, Error&gt; {
</a><a href="#h46-8-10" id="h46-8-10" class="i">+    pub fn scan_prefix(&amp;self, prefix: &amp;[u8]) -&gt; Result&lt;super::Scan&gt; {
</a>         if prefix.is_empty() {
             return Err(Error::Internal(&quot;Scan prefix cannot be empty&quot;.into()));
         }
<a href="#h46-9" id="h46-9" class="h">@@ -239,12 +239,12 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>     }
 
     /// Sets a key.
<a href="#h46-9-3" id="h46-9-3" class="d">-    pub fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-9-4" id="h46-9-4" class="i">+    pub fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a>         self.write(key, Some(value))
     }
 
     /// Writes a value for a key. None is used for deletion.
<a href="#h46-9-9" id="h46-9-9" class="d">-    fn write(&amp;self, key: &amp;[u8], value: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-9-10" id="h46-9-10" class="i">+    fn write(&amp;self, key: &amp;[u8], value: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;()&gt; {
</a>         if !self.mode.mutable() {
             return Err(Error::ReadOnly);
         }
<a href="#h46-10" id="h46-10" class="h">@@ -327,7 +327,7 @@ struct Snapshot {
</a> 
 impl Snapshot {
     /// Takes a new snapshot, persisting it as `Key::TxnSnapshot(version)`.
<a href="#h46-10-3" id="h46-10-3" class="d">-    fn take(session: &amp;mut RwLockWriteGuard&lt;impl Store&gt;, version: u64) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h46-10-4" id="h46-10-4" class="i">+    fn take(session: &amp;mut RwLockWriteGuard&lt;impl Store&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a>         let mut snapshot = Self { version, invisible: HashSet::new() };
         let mut scan = session.scan(&amp;Key::TxnActive(0).encode()..&amp;Key::TxnActive(version).encode());
         while let Some((key, _)) = scan.next().transpose()? {
<a href="#h46-11" id="h46-11" class="h">@@ -342,7 +342,7 @@ impl Snapshot {
</a>     }
 
     /// Restores an existing snapshot from `Key::TxnSnapshot(version)`, or errors if not found.
<a href="#h46-11-3" id="h46-11-3" class="d">-    fn restore(session: &amp;RwLockReadGuard&lt;impl Store&gt;, version: u64) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h46-11-4" id="h46-11-4" class="i">+    fn restore(session: &amp;RwLockReadGuard&lt;impl Store&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a>         match session.get(&amp;Key::TxnSnapshot(version).encode())? {
             Some(ref v) =&gt; Ok(Self { version, invisible: deserialize(v)? }),
             None =&gt; Err(Error::Value(format!(&quot;Snapshot not found for version {}&quot;, version))),
<a href="#h46-12" id="h46-12" class="h">@@ -380,7 +380,7 @@ enum Key {
</a> 
 impl Key {
     /// Decodes a key from a byte representation.
<a href="#h46-12-3" id="h46-12-3" class="d">-    fn decode(key: &amp;[u8]) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h46-12-4" id="h46-12-4" class="i">+    fn decode(key: &amp;[u8]) -&gt; Result&lt;Self&gt; {
</a>         let mut iter = key.iter();
         match iter.next() {
             Some(0x01) =&gt; Ok(Key::TxnNext),
<a href="#h46-13" id="h46-13" class="h">@@ -396,7 +396,7 @@ impl Key {
</a>     }
 
     /// Decodes a byte vector from a byte representation. See encode_bytes() for format.
<a href="#h46-13-3" id="h46-13-3" class="d">-    fn decode_bytes&lt;&#39;a, I: Iterator&lt;Item = &amp;&#39;a u8&gt;&gt;(iter: &amp;mut I) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h46-13-4" id="h46-13-4" class="i">+    fn decode_bytes&lt;&#39;a, I: Iterator&lt;Item = &amp;&#39;a u8&gt;&gt;(iter: &amp;mut I) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a>         let mut bytes = Vec::new();
         loop {
             match iter.next() {
<a href="#h46-14" id="h46-14" class="h">@@ -413,7 +413,7 @@ impl Key {
</a>     }
 
     /// Decodes a u64 from a byte representation.
<a href="#h46-14-3" id="h46-14-3" class="d">-    fn decode_u64&lt;&#39;a, I: Iterator&lt;Item = &amp;&#39;a u8&gt;&gt;(iter: &amp;mut I) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h46-14-4" id="h46-14-4" class="i">+    fn decode_u64&lt;&#39;a, I: Iterator&lt;Item = &amp;&#39;a u8&gt;&gt;(iter: &amp;mut I) -&gt; Result&lt;u64&gt; {
</a>         let bytes = iter.take(8).cloned().collect::&lt;Vec&lt;u8&gt;&gt;();
         if bytes.len() &lt; 8 {
             return Err(Error::Value(format!(&quot;Unable to decode u64, got {} bytes&quot;, bytes.len())));
<a href="#h46-15" id="h46-15" class="h">@@ -480,7 +480,7 @@ impl&lt;S: Store&gt; Scan&lt;S&gt; {
</a>         store: Arc&lt;RwLock&lt;S&gt;&gt;,
         snapshot: Snapshot,
         range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;,
<a href="#h46-15-3" id="h46-15-3" class="d">-    ) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h46-15-4" id="h46-15-4" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a>         let start = match range.start_bound() {
             Bound::Excluded(k) =&gt; Bound::Excluded(Key::Record(k.clone(), std::u64::MAX).encode()),
             Bound::Included(k) =&gt; Bound::Included(Key::Record(k.clone(), 0).encode()),
<a href="#h46-16" id="h46-16" class="h">@@ -502,8 +502,7 @@ impl&lt;S: Store&gt; Scan&lt;S&gt; {
</a>     }
 
     // next() with error handling.
<a href="#h46-16-3" id="h46-16-3" class="d">-    #[allow(clippy::type_complexity)]
</a><a href="#h46-16-4" id="h46-16-4" class="d">-    fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;, Error&gt; {
</a><a href="#h46-16-5" id="h46-16-5" class="i">+    fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; {
</a>         let session = self.store.read()?;
         let mut range = session.scan(self.bounds.clone());
         while let Some((k, v)) = range.next().transpose()? {
<a href="#h46-17" id="h46-17" class="h">@@ -539,8 +538,7 @@ impl&lt;S: Store&gt; Scan&lt;S&gt; {
</a>     }
 
     /// next_back() with error handling.
<a href="#h46-17-3" id="h46-17-3" class="d">-    #[allow(clippy::type_complexity)]
</a><a href="#h46-17-4" id="h46-17-4" class="d">-    fn try_next_back(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;, Error&gt; {
</a><a href="#h46-17-5" id="h46-17-5" class="i">+    fn try_next_back(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; {
</a>         let session = self.store.read()?;
         let mut range = session.scan(self.bounds.clone());
         while let Some((k, v)) = range.next_back().transpose()? {
<a href="#h46-18" id="h46-18" class="h">@@ -570,7 +568,7 @@ impl&lt;S: Store&gt; Scan&lt;S&gt; {
</a> }
 
 impl&lt;S: Store&gt; Iterator for Scan&lt;S&gt; {
<a href="#h46-18-3" id="h46-18-3" class="d">-    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;), Error&gt;;
</a><a href="#h46-18-4" id="h46-18-4" class="i">+    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a> 
     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
         self.try_next().transpose()
<a href="#h46-19" id="h46-19" class="h">@@ -593,7 +591,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-19-3" id="h46-19-3" class="d">-    fn test_begin() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-19-4" id="h46-19-4" class="i">+    fn test_begin() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let txn = mvcc.begin()?;
<a href="#h46-20" id="h46-20" class="h">@@ -613,7 +611,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-20-3" id="h46-20-3" class="d">-    fn test_begin_with_mode_readonly() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-20-4" id="h46-20-4" class="i">+    fn test_begin_with_mode_readonly() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
         let txn = mvcc.begin_with_mode(Mode::ReadOnly)?;
         assert_eq!(1, txn.id());
<a href="#h46-21" id="h46-21" class="h">@@ -623,7 +621,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-21-3" id="h46-21-3" class="d">-    fn test_begin_with_mode_readwrite() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-21-4" id="h46-21-4" class="i">+    fn test_begin_with_mode_readwrite() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
         let txn = mvcc.begin_with_mode(Mode::ReadWrite)?;
         assert_eq!(1, txn.id());
<a href="#h46-22" id="h46-22" class="h">@@ -633,7 +631,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-22-3" id="h46-22-3" class="d">-    fn test_begin_with_mode_snapshot() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-22-4" id="h46-22-4" class="i">+    fn test_begin_with_mode_snapshot() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         // Write a couple of versions for a key
<a href="#h46-23" id="h46-23" class="h">@@ -692,7 +690,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-23-3" id="h46-23-3" class="d">-    fn test_resume() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-23-4" id="h46-23-4" class="i">+    fn test_resume() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         // We first write a set of values that should be visible
<a href="#h46-24" id="h46-24" class="h">@@ -763,7 +761,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-24-3" id="h46-24-3" class="d">-    fn test_txn_delete_conflict() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-24-4" id="h46-24-4" class="i">+    fn test_txn_delete_conflict() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut txn = mvcc.begin()?;
<a href="#h46-25" id="h46-25" class="h">@@ -783,7 +781,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-25-3" id="h46-25-3" class="d">-    fn test_txn_delete_idempotent() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-25-4" id="h46-25-4" class="i">+    fn test_txn_delete_idempotent() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut txn = mvcc.begin()?;
<a href="#h46-26" id="h46-26" class="h">@@ -794,7 +792,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-26-3" id="h46-26-3" class="d">-    fn test_txn_get() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-26-4" id="h46-26-4" class="i">+    fn test_txn_get() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut txn = mvcc.begin()?;
<a href="#h46-27" id="h46-27" class="h">@@ -809,7 +807,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-27-3" id="h46-27-3" class="d">-    fn test_txn_get_deleted() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-27-4" id="h46-27-4" class="i">+    fn test_txn_get_deleted() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
         let mut txn = mvcc.begin()?;
         txn.set(b&quot;a&quot;, vec![0x01])?;
<a href="#h46-28" id="h46-28" class="h">@@ -827,7 +825,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-28-3" id="h46-28-3" class="d">-    fn test_txn_get_hides_newer() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-28-4" id="h46-28-4" class="i">+    fn test_txn_get_hides_newer() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t1 = mvcc.begin()?;
<a href="#h46-29" id="h46-29" class="h">@@ -846,7 +844,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-29-3" id="h46-29-3" class="d">-    fn test_txn_get_hides_uncommitted() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-29-4" id="h46-29-4" class="i">+    fn test_txn_get_hides_uncommitted() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t1 = mvcc.begin()?;
<a href="#h46-30" id="h46-30" class="h">@@ -862,7 +860,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-30-3" id="h46-30-3" class="d">-    fn test_txn_get_readonly_historical() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-30-4" id="h46-30-4" class="i">+    fn test_txn_get_readonly_historical() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut txn = mvcc.begin()?;
<a href="#h46-31" id="h46-31" class="h">@@ -886,7 +884,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-31-3" id="h46-31-3" class="d">-    fn test_txn_get_serial() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-31-4" id="h46-31-4" class="i">+    fn test_txn_get_serial() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut txn = mvcc.begin()?;
<a href="#h46-32" id="h46-32" class="h">@@ -900,7 +898,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-32-3" id="h46-32-3" class="d">-    fn test_txn_scan() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-32-4" id="h46-32-4" class="i">+    fn test_txn_scan() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
         let mut txn = mvcc.begin()?;
 
<a href="#h46-33" id="h46-33" class="h">@@ -935,7 +933,7 @@ pub mod tests {
</a>                 (b&quot;c&quot;.to_vec(), vec![0x03]),
                 (b&quot;e&quot;.to_vec(), vec![0x05]),
             ],
<a href="#h46-33-3" id="h46-33-3" class="d">-            txn.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h46-33-4" id="h46-33-4" class="i">+            txn.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Reverse scan
<a href="#h46-34" id="h46-34" class="h">@@ -945,7 +943,7 @@ pub mod tests {
</a>                 (b&quot;c&quot;.to_vec(), vec![0x03]),
                 (b&quot;a&quot;.to_vec(), vec![0x01]),
             ],
<a href="#h46-34-3" id="h46-34-3" class="d">-            txn.scan(..)?.rev().collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h46-34-4" id="h46-34-4" class="i">+            txn.scan(..)?.rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Alternate forward/backward scan
<a href="#h46-35" id="h46-35" class="h">@@ -961,7 +959,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-35-3" id="h46-35-3" class="d">-    fn test_txn_scan_key_version_overlap() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-35-4" id="h46-35-4" class="i">+    fn test_txn_scan_key_version_overlap() -&gt; Result&lt;()&gt; {
</a>         // The idea here is that with a naive key/version concatenation
         // we get overlapping entries that mess up scans. For example:
         //
<a href="#h46-36" id="h46-36" class="h">@@ -982,13 +980,13 @@ pub mod tests {
</a>         let txn = mvcc.begin()?;
         assert_eq!(
             vec![(vec![0].to_vec(), vec![3]), (vec![0, 0, 0, 0, 0, 0, 0, 0, 2].to_vec(), vec![2]),],
<a href="#h46-36-3" id="h46-36-3" class="d">-            txn.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h46-36-4" id="h46-36-4" class="i">+            txn.scan(..)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         Ok(())
     }
 
     #[test]
<a href="#h46-36-10" id="h46-36-10" class="d">-    fn test_txn_scan_prefix() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-36-11" id="h46-36-11" class="i">+    fn test_txn_scan_prefix() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
         let mut txn = mvcc.begin()?;
 
<a href="#h46-37" id="h46-37" class="h">@@ -1010,7 +1008,7 @@ pub mod tests {
</a>                 (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
                 (b&quot;bc&quot;.to_vec(), vec![0x02, 0x03]),
             ],
<a href="#h46-37-3" id="h46-37-3" class="d">-            txn.scan_prefix(b&quot;b&quot;)?.collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h46-37-4" id="h46-37-4" class="i">+            txn.scan_prefix(b&quot;b&quot;)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Reverse scan
<a href="#h46-38" id="h46-38" class="h">@@ -1021,7 +1019,7 @@ pub mod tests {
</a>                 (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                 (b&quot;b&quot;.to_vec(), vec![0x02]),
             ],
<a href="#h46-38-3" id="h46-38-3" class="d">-            txn.scan_prefix(b&quot;b&quot;)?.rev().collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()?
</a><a href="#h46-38-4" id="h46-38-4" class="i">+            txn.scan_prefix(b&quot;b&quot;)?.rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Alternate forward/backward scan
<a href="#h46-39" id="h46-39" class="h">@@ -1038,7 +1036,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-39-3" id="h46-39-3" class="d">-    fn test_txn_set_conflict() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-39-4" id="h46-39-4" class="i">+    fn test_txn_set_conflict() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t1 = mvcc.begin()?;
<a href="#h46-40" id="h46-40" class="h">@@ -1054,7 +1052,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-40-3" id="h46-40-3" class="d">-    fn test_txn_set_conflict_committed() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-40-4" id="h46-40-4" class="i">+    fn test_txn_set_conflict_committed() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t1 = mvcc.begin()?;
<a href="#h46-41" id="h46-41" class="h">@@ -1070,7 +1068,7 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h46-41-3" id="h46-41-3" class="d">-    fn test_txn_set_rollback() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-41-4" id="h46-41-4" class="i">+    fn test_txn_set_rollback() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut txn = mvcc.begin()?;
<a href="#h46-42" id="h46-42" class="h">@@ -1093,7 +1091,7 @@ pub mod tests {
</a> 
     #[test]
     // A dirty write is when t2 overwrites an uncommitted value written by t1.
<a href="#h46-42-3" id="h46-42-3" class="d">-    fn test_txn_anomaly_dirty_write() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-42-4" id="h46-42-4" class="i">+    fn test_txn_anomaly_dirty_write() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t1 = mvcc.begin()?;
<a href="#h46-43" id="h46-43" class="h">@@ -1107,7 +1105,7 @@ pub mod tests {
</a> 
     #[test]
     // A dirty read is when t2 can read an uncommitted value set by t1.
<a href="#h46-43-3" id="h46-43-3" class="d">-    fn test_txn_anomaly_dirty_read() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-43-4" id="h46-43-4" class="i">+    fn test_txn_anomaly_dirty_read() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t1 = mvcc.begin()?;
<a href="#h46-44" id="h46-44" class="h">@@ -1121,7 +1119,7 @@ pub mod tests {
</a> 
     #[test]
     // A lost update is when t1 and t2 both read a value and update it, where t2&#39;s update replaces t1.
<a href="#h46-44-3" id="h46-44-3" class="d">-    fn test_txn_anomaly_lost_update() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-44-4" id="h46-44-4" class="i">+    fn test_txn_anomaly_lost_update() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t0 = mvcc.begin()?;
<a href="#h46-45" id="h46-45" class="h">@@ -1142,7 +1140,7 @@ pub mod tests {
</a> 
     #[test]
     // A fuzzy (or unrepeatable) read is when t2 sees a value change after t1 updates it.
<a href="#h46-45-3" id="h46-45-3" class="d">-    fn test_txn_anomaly_fuzzy_read() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-45-4" id="h46-45-4" class="i">+    fn test_txn_anomaly_fuzzy_read() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t0 = mvcc.begin()?;
<a href="#h46-46" id="h46-46" class="h">@@ -1162,7 +1160,7 @@ pub mod tests {
</a> 
     #[test]
     // Read skew is when t1 reads a and b, but t2 modifies b in between the reads.
<a href="#h46-46-3" id="h46-46-3" class="d">-    fn test_txn_anomaly_read_skew() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-46-4" id="h46-46-4" class="i">+    fn test_txn_anomaly_read_skew() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t0 = mvcc.begin()?;
<a href="#h46-47" id="h46-47" class="h">@@ -1185,7 +1183,7 @@ pub mod tests {
</a>     #[test]
     // A phantom read is when t1 reads entries matching some predicate, but a modification by
     // t2 changes the entries that match the predicate such that a later read by t1 returns them.
<a href="#h46-47-3" id="h46-47-3" class="d">-    fn test_txn_anomaly_phantom_read() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-47-4" id="h46-47-4" class="i">+    fn test_txn_anomaly_phantom_read() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t0 = mvcc.begin()?;
<a href="#h46-48" id="h46-48" class="h">@@ -1211,7 +1209,7 @@ pub mod tests {
</a>     /* FIXME To avoid write skew we need to implement serializable snapshot isolation.
     #[test]
     // Write skew is when t1 reads b and writes it to a while t2 reads a and writes it to b.¨
<a href="#h46-48-3" id="h46-48-3" class="d">-    fn test_txn_anomaly_write_skew() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-48-4" id="h46-48-4" class="i">+    fn test_txn_anomaly_write_skew() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         let mut t0 = mvcc.begin()?;
<a href="#h46-49" id="h46-49" class="h">@@ -1236,7 +1234,7 @@ pub mod tests {
</a>     }*/
 
     #[test]
<a href="#h46-49-3" id="h46-49-3" class="d">-    fn test_metadata() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h46-49-4" id="h46-49-4" class="i">+    fn test_metadata() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
 
         mvcc.set_metadata(b&quot;foo&quot;, b&quot;bar&quot;.to_vec())?;
<b>diff --git a/<a id="h47" href="../file/src/storage/kv/test.rs.html">src/storage/kv/test.rs</a> b/<a href="../file/src/storage/kv/test.rs.html">src/storage/kv/test.rs</a></b>
<a href="#h47-0" id="h47-0" class="h">@@ -1,5 +1,5 @@
</a> use super::{Memory, Scan, Store};
<a href="#h47-0-1" id="h47-0-1" class="d">-use crate::Error;
</a><a href="#h47-0-2" id="h47-0-2" class="i">+use crate::error::Result;
</a> 
 use std::ops::RangeBounds;
 use std::sync::{Arc, RwLock};
<a href="#h47-1" id="h47-1" class="h">@@ -19,37 +19,37 @@ impl Test {
</a> }
 
 impl Store for Test {
<a href="#h47-1-3" id="h47-1-3" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h47-1-4" id="h47-1-4" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a>         self.kv.write()?.delete(key)
     }
 
<a href="#h47-1-8" id="h47-1-8" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h47-1-9" id="h47-1-9" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a>         Ok(())
     }
 
<a href="#h47-1-13" id="h47-1-13" class="d">-    fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h47-1-14" id="h47-1-14" class="i">+    fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         self.kv.read()?.get(key)
     }
 
     fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Scan {
         // Since the mutex guard is scoped to this method, we simply buffer the result.
<a href="#h47-1-20" id="h47-1-20" class="d">-        Box::new(self.kv.read().unwrap().scan(range).collect::&lt;Vec&lt;Result&lt;_, Error&gt;&gt;&gt;().into_iter())
</a><a href="#h47-1-21" id="h47-1-21" class="i">+        Box::new(self.kv.read().unwrap().scan(range).collect::&lt;Vec&lt;Result&lt;_&gt;&gt;&gt;().into_iter())
</a>     }
 
<a href="#h47-1-24" id="h47-1-24" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h47-1-25" id="h47-1-25" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a>         self.kv.write()?.set(key, value)
     }
 }
 
 #[cfg(test)]
 impl super::TestSuite&lt;Test&gt; for Test {
<a href="#h47-1-32" id="h47-1-32" class="d">-    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h47-1-33" id="h47-1-33" class="i">+    fn setup() -&gt; Result&lt;Self&gt; {
</a>         Ok(Test::new())
     }
 }
 
 #[test]
<a href="#h47-1-39" id="h47-1-39" class="d">-fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h47-1-40" id="h47-1-40" class="i">+fn tests() -&gt; Result&lt;()&gt; {
</a>     use super::TestSuite;
     Test::test()
 }
<b>diff --git a/<a id="h48" href="../file/src/storage/log/hybrid.rs.html">src/storage/log/hybrid.rs</a> b/<a href="../file/src/storage/log/hybrid.rs.html">src/storage/log/hybrid.rs</a></b>
<a href="#h48-0" id="h48-0" class="h">@@ -1,5 +1,5 @@
</a> use super::{Scan, Store};
<a href="#h48-0-1" id="h48-0-1" class="d">-use crate::Error;
</a><a href="#h48-0-2" id="h48-0-2" class="i">+use crate::error::{Error, Result};
</a> 
 use std::cmp::{max, min};
 use std::collections::{BTreeMap, HashMap, VecDeque};
<a href="#h48-1" id="h48-1" class="h">@@ -38,7 +38,7 @@ pub struct Hybrid {
</a> 
 impl Hybrid {
     /// Creates or opens a new hybrid log, with files in the given directory.
<a href="#h48-1-3" id="h48-1-3" class="d">-    pub fn new(dir: &amp;Path, sync: bool) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h48-1-4" id="h48-1-4" class="i">+    pub fn new(dir: &amp;Path, sync: bool) -&gt; Result&lt;Self&gt; {
</a>         let file =
             OpenOptions::new().read(true).write(true).create(true).open(dir.join(&quot;raft-log&quot;))?;
 
<a href="#h48-2" id="h48-2" class="h">@@ -59,7 +59,7 @@ impl Hybrid {
</a>     }
 
     /// Builds the index by scanning the log file.
<a href="#h48-2-3" id="h48-2-3" class="d">-    fn build_index(file: &amp;File) -&gt; Result&lt;BTreeMap&lt;u64, (u64, u32)&gt;, Error&gt; {
</a><a href="#h48-2-4" id="h48-2-4" class="i">+    fn build_index(file: &amp;File) -&gt; Result&lt;BTreeMap&lt;u64, (u64, u32)&gt;&gt; {
</a>         let filesize = file.metadata()?.len();
         let mut bufreader = BufReader::new(file);
         let mut index = BTreeMap::new();
<a href="#h48-3" id="h48-3" class="h">@@ -80,7 +80,7 @@ impl Hybrid {
</a>     }
 
     /// Loads metadata from a file.
<a href="#h48-3-3" id="h48-3-3" class="d">-    fn load_metadata(file: &amp;File) -&gt; Result&lt;HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h48-3-4" id="h48-3-4" class="i">+    fn load_metadata(file: &amp;File) -&gt; Result&lt;HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;&gt; {
</a>         match serde_cbor::from_reader(file) {
             Ok(metadata) =&gt; Ok(metadata),
             Err(err) if err.is_eof() =&gt; Ok(HashMap::new()),
<a href="#h48-4" id="h48-4" class="h">@@ -90,12 +90,12 @@ impl Hybrid {
</a> }
 
 impl Store for Hybrid {
<a href="#h48-4-3" id="h48-4-3" class="d">-    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h48-4-4" id="h48-4-4" class="i">+    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64&gt; {
</a>         self.uncommitted.push_back(entry);
         Ok(self.len())
     }
 
<a href="#h48-4-9" id="h48-4-9" class="d">-    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h48-4-10" id="h48-4-10" class="i">+    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;()&gt; {
</a>         if index &gt; self.len() {
             return Err(Error::Internal(format!(&quot;Cannot commit non-existant index {}&quot;, index)));
         }
<a href="#h48-5" id="h48-5" class="h">@@ -135,7 +135,7 @@ impl Store for Hybrid {
</a>         self.index.len() as u64
     }
 
<a href="#h48-5-3" id="h48-5-3" class="d">-    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h48-5-4" id="h48-5-4" class="i">+    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         match index {
             0 =&gt; Ok(None),
             i if i &lt;= self.index.len() as u64 =&gt; {
<a href="#h48-6" id="h48-6" class="h">@@ -207,7 +207,7 @@ impl Store for Hybrid {
</a>         scan
     }
 
<a href="#h48-6-3" id="h48-6-3" class="d">-    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h48-6-4" id="h48-6-4" class="i">+    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt; {
</a>         if index &lt; self.index.len() as u64 {
             return Err(Error::Internal(format!(
                 &quot;Cannot truncate below committed index {}&quot;,
<a href="#h48-7" id="h48-7" class="h">@@ -218,11 +218,11 @@ impl Store for Hybrid {
</a>         Ok(self.len())
     }
 
<a href="#h48-7-3" id="h48-7-3" class="d">-    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h48-7-4" id="h48-7-4" class="i">+    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         Ok(self.metadata.get(key).cloned())
     }
 
<a href="#h48-7-8" id="h48-7-8" class="d">-    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h48-7-9" id="h48-7-9" class="i">+    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a>         self.metadata.insert(key.to_vec(), value);
         self.metadata_file.set_len(0)?;
         self.metadata_file.seek(SeekFrom::Start(0))?;
<a href="#h48-8" id="h48-8" class="h">@@ -252,20 +252,20 @@ impl&lt;&#39;a&gt; Read for MutexReader&lt;&#39;a&gt; {
</a> 
 #[cfg(test)]
 impl super::TestSuite&lt;Hybrid&gt; for Hybrid {
<a href="#h48-8-3" id="h48-8-3" class="d">-    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h48-8-4" id="h48-8-4" class="i">+    fn setup() -&gt; Result&lt;Self&gt; {
</a>         let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
         Hybrid::new(dir.as_ref(), false)
     }
 }
 
 #[test]
<a href="#h48-8-11" id="h48-8-11" class="d">-fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h48-8-12" id="h48-8-12" class="i">+fn tests() -&gt; Result&lt;()&gt; {
</a>     use super::TestSuite;
     Hybrid::test()
 }
 
 #[test]
<a href="#h48-8-18" id="h48-8-18" class="d">-fn test_persistent() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h48-8-19" id="h48-8-19" class="i">+fn test_persistent() -&gt; Result&lt;()&gt; {
</a>     let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
     let mut l = Hybrid::new(dir.as_ref(), true)?;
 
<a href="#h48-9" id="h48-9" class="h">@@ -278,7 +278,7 @@ fn test_persistent() -&gt; Result&lt;(), Error&gt; {
</a> 
     let l = Hybrid::new(dir.as_ref(), true)?;
 
<a href="#h48-9-3" id="h48-9-3" class="d">-    assert_eq!(vec![vec![1], vec![2], vec![3]], l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h48-9-4" id="h48-9-4" class="i">+    assert_eq!(vec![vec![1], vec![2], vec![3]], l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
     Ok(())
 }
<b>diff --git a/<a id="h49" href="../file/src/storage/log/memory.rs.html">src/storage/log/memory.rs</a> b/<a href="../file/src/storage/log/memory.rs.html">src/storage/log/memory.rs</a></b>
<a href="#h49-0" id="h49-0" class="h">@@ -1,5 +1,5 @@
</a> use super::Store;
<a href="#h49-0-1" id="h49-0-1" class="d">-use crate::Error;
</a><a href="#h49-0-2" id="h49-0-2" class="i">+use crate::error::{Error, Result};
</a> 
 use std::collections::HashMap;
 use std::ops::{Bound, RangeBounds};
<a href="#h49-1" id="h49-1" class="h">@@ -19,12 +19,12 @@ impl Memory {
</a> }
 
 impl Store for Memory {
<a href="#h49-1-3" id="h49-1-3" class="d">-    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h49-1-4" id="h49-1-4" class="i">+    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64&gt; {
</a>         self.log.push(entry);
         Ok(self.log.len() as u64)
     }
 
<a href="#h49-1-9" id="h49-1-9" class="d">-    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h49-1-10" id="h49-1-10" class="i">+    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;()&gt; {
</a>         if index &gt; self.len() {
             return Err(Error::Internal(format!(&quot;Cannot commit non-existant index {}&quot;, index)));
         }
<a href="#h49-2" id="h49-2" class="h">@@ -42,7 +42,7 @@ impl Store for Memory {
</a>         self.committed
     }
 
<a href="#h49-2-3" id="h49-2-3" class="d">-    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h49-2-4" id="h49-2-4" class="i">+    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         match index {
             0 =&gt; Ok(None),
             i =&gt; Ok(self.log.get(i as usize - 1).cloned()),
<a href="#h49-3" id="h49-3" class="h">@@ -74,7 +74,7 @@ impl Store for Memory {
</a>         )
     }
 
<a href="#h49-3-3" id="h49-3-3" class="d">-    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h49-3-4" id="h49-3-4" class="i">+    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt; {
</a>         if index &lt; self.committed {
             return Err(Error::Internal(format!(
                 &quot;Cannot truncate below committed index {}&quot;,
<a href="#h49-4" id="h49-4" class="h">@@ -85,11 +85,11 @@ impl Store for Memory {
</a>         Ok(self.log.len() as u64)
     }
 
<a href="#h49-4-3" id="h49-4-3" class="d">-    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h49-4-4" id="h49-4-4" class="i">+    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         Ok(self.metadata.get(key).cloned())
     }
 
<a href="#h49-4-8" id="h49-4-8" class="d">-    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h49-4-9" id="h49-4-9" class="i">+    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a>         self.metadata.insert(key.to_vec(), value);
         Ok(())
     }
<a href="#h49-5" id="h49-5" class="h">@@ -97,13 +97,13 @@ impl Store for Memory {
</a> 
 #[cfg(test)]
 impl super::TestSuite&lt;Memory&gt; for Memory {
<a href="#h49-5-3" id="h49-5-3" class="d">-    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h49-5-4" id="h49-5-4" class="i">+    fn setup() -&gt; Result&lt;Self&gt; {
</a>         Ok(Memory::new())
     }
 }
 
 #[test]
<a href="#h49-5-10" id="h49-5-10" class="d">-fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h49-5-11" id="h49-5-11" class="i">+fn tests() -&gt; Result&lt;()&gt; {
</a>     use super::TestSuite;
     Memory::test()
 }
<b>diff --git a/<a id="h50" href="../file/src/storage/log/mod.rs.html">src/storage/log/mod.rs</a> b/<a href="../file/src/storage/log/mod.rs.html">src/storage/log/mod.rs</a></b>
<a href="#h50-0" id="h50-0" class="h">@@ -8,23 +8,23 @@ pub use memory::Memory;
</a> #[cfg(test)]
 pub use test::Test;
 
<a href="#h50-0-3" id="h50-0-3" class="d">-use crate::Error;
</a><a href="#h50-0-4" id="h50-0-4" class="i">+use crate::error::Result;
</a> 
 use std::ops::RangeBounds;
 
 /// A log store. Entry indexes are 1-based, to match Raft semantics.
 pub trait Store {
     /// Appends a log entry, returning its index.
<a href="#h50-0-11" id="h50-0-11" class="d">-    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64, Error&gt;;
</a><a href="#h50-0-12" id="h50-0-12" class="i">+    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64&gt;;
</a> 
     /// Commits log entries up to and including the given index, making them immutable.
<a href="#h50-0-15" id="h50-0-15" class="d">-    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h50-0-16" id="h50-0-16" class="i">+    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;()&gt;;
</a> 
     /// Returns the committed index, if any.
     fn committed(&amp;self) -&gt; u64;
 
     /// Fetches a log entry, if it exists.
<a href="#h50-0-22" id="h50-0-22" class="d">-    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt;;
</a><a href="#h50-0-23" id="h50-0-23" class="i">+    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
</a> 
     /// Returns the number of entries in the log.
     fn len(&amp;self) -&gt; u64;
<a href="#h50-1" id="h50-1" class="h">@@ -34,13 +34,13 @@ pub trait Store {
</a> 
     /// Truncates the log be removing any entries above the given index, and returns the
     /// highest index. Errors if asked to truncate any committed entries.
<a href="#h50-1-3" id="h50-1-3" class="d">-    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt;;
</a><a href="#h50-1-4" id="h50-1-4" class="i">+    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt;;
</a> 
     /// Gets a metadata value.
<a href="#h50-1-7" id="h50-1-7" class="d">-    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt;;
</a><a href="#h50-1-8" id="h50-1-8" class="i">+    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
</a> 
     /// Sets a metadata value.
<a href="#h50-1-11" id="h50-1-11" class="d">-    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h50-1-12" id="h50-1-12" class="i">+    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;
</a> 
     /// Returns true if the log has no entries.
     fn is_empty(&amp;self) -&gt; bool {
<a href="#h50-2" id="h50-2" class="h">@@ -49,13 +49,16 @@ pub trait Store {
</a> }
 
 /// Iterator over a log range.
<a href="#h50-2-3" id="h50-2-3" class="d">-pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Vec&lt;u8&gt;, Error&gt;&gt; + &#39;a&gt;;
</a><a href="#h50-2-4" id="h50-2-4" class="i">+pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Vec&lt;u8&gt;&gt;&gt; + &#39;a&gt;;
</a><a href="#h50-2-5" id="h50-2-5" class="i">+
</a><a href="#h50-2-6" id="h50-2-6" class="i">+#[cfg(test)]
</a><a href="#h50-2-7" id="h50-2-7" class="i">+use crate::error::Error;
</a> 
 #[cfg(test)]
 trait TestSuite&lt;S: Store&gt; {
<a href="#h50-2-11" id="h50-2-11" class="d">-    fn setup() -&gt; Result&lt;S, Error&gt;;
</a><a href="#h50-2-12" id="h50-2-12" class="i">+    fn setup() -&gt; Result&lt;S&gt;;
</a> 
<a href="#h50-2-14" id="h50-2-14" class="d">-    fn test() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h50-2-15" id="h50-2-15" class="i">+    fn test() -&gt; Result&lt;()&gt; {
</a>         Self::test_append()?;
         Self::test_commit_truncate()?;
         Self::test_get()?;
<a href="#h50-3" id="h50-3" class="h">@@ -64,18 +67,18 @@ trait TestSuite&lt;S: Store&gt; {
</a>         Ok(())
     }
 
<a href="#h50-3-3" id="h50-3-3" class="d">-    fn test_append() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h50-3-4" id="h50-3-4" class="i">+    fn test_append() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
         assert_eq!(0, s.len());
         assert_eq!(1, s.append(vec![0x01])?);
         assert_eq!(2, s.append(vec![0x02])?);
         assert_eq!(3, s.append(vec![0x03])?);
         assert_eq!(3, s.len());
<a href="#h50-3-11" id="h50-3-11" class="d">-        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-3-12" id="h50-3-12" class="i">+        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a>         Ok(())
     }
 
<a href="#h50-3-16" id="h50-3-16" class="d">-    fn test_commit_truncate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h50-3-17" id="h50-3-17" class="i">+    fn test_commit_truncate() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
 
         assert_eq!(0, s.committed());
<a href="#h50-4" id="h50-4" class="h">@@ -91,7 +94,7 @@ trait TestSuite&lt;S: Store&gt; {
</a> 
         // Truncating beyond the end should be fine.
         assert_eq!(3, s.truncate(4)?);
<a href="#h50-4-3" id="h50-4-3" class="d">-        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-4-4" id="h50-4-4" class="i">+        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
         // Truncating a committed entry should error.
         assert_eq!(
<a href="#h50-5" id="h50-5" class="h">@@ -101,12 +104,12 @@ trait TestSuite&lt;S: Store&gt; {
</a> 
         // Truncating above should work.
         assert_eq!(1, s.truncate(1)?);
<a href="#h50-5-3" id="h50-5-3" class="d">-        assert_eq!(vec![vec![1]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-5-4" id="h50-5-4" class="i">+        assert_eq!(vec![vec![1]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
         Ok(())
     }
 
<a href="#h50-5-9" id="h50-5-9" class="d">-    fn test_get() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h50-5-10" id="h50-5-10" class="i">+    fn test_get() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
         s.append(vec![0x01])?;
         s.append(vec![0x02])?;
<a href="#h50-6" id="h50-6" class="h">@@ -117,7 +120,7 @@ trait TestSuite&lt;S: Store&gt; {
</a>         Ok(())
     }
 
<a href="#h50-6-3" id="h50-6-3" class="d">-    fn test_metadata() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h50-6-4" id="h50-6-4" class="i">+    fn test_metadata() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
         s.set_metadata(b&quot;a&quot;, vec![0x01])?;
         assert_eq!(Some(vec![0x01]), s.get_metadata(b&quot;a&quot;)?);
<a href="#h50-7" id="h50-7" class="h">@@ -125,33 +128,30 @@ trait TestSuite&lt;S: Store&gt; {
</a>         Ok(())
     }
 
<a href="#h50-7-3" id="h50-7-3" class="d">-    fn test_scan() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h50-7-4" id="h50-7-4" class="i">+    fn test_scan() -&gt; Result&lt;()&gt; {
</a>         let mut s = Self::setup()?;
         s.append(vec![0x01])?;
         s.append(vec![0x02])?;
         s.append(vec![0x03])?;
         s.commit(2)?;
 
<a href="#h50-7-11" id="h50-7-11" class="d">-        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-12" id="h50-7-12" class="i">+        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
<a href="#h50-7-14" id="h50-7-14" class="d">-        assert_eq!(vec![vec![1]], s.scan(0..2).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-15" id="h50-7-15" class="d">-        assert_eq!(vec![vec![1], vec![2]], s.scan(1..3).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-16" id="h50-7-16" class="d">-        assert_eq!(
</a><a href="#h50-7-17" id="h50-7-17" class="d">-            vec![vec![1], vec![2], vec![3]],
</a><a href="#h50-7-18" id="h50-7-18" class="d">-            s.scan(1..=3).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h50-7-19" id="h50-7-19" class="d">-        );
</a><a href="#h50-7-20" id="h50-7-20" class="d">-        assert!(s.scan(3..1).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h50-7-21" id="h50-7-21" class="d">-        assert!(s.scan(1..1).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h50-7-22" id="h50-7-22" class="d">-        assert_eq!(vec![vec![2]], s.scan(2..=2).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-23" id="h50-7-23" class="d">-        assert_eq!(vec![vec![2], vec![3]], s.scan(2..5).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-24" id="h50-7-24" class="d">-
</a><a href="#h50-7-25" id="h50-7-25" class="d">-        assert!(s.scan(..0).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h50-7-26" id="h50-7-26" class="d">-        assert_eq!(vec![vec![1]], s.scan(..=1).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-27" id="h50-7-27" class="d">-        assert_eq!(vec![vec![1], vec![2]], s.scan(..3).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-28" id="h50-7-28" class="d">-
</a><a href="#h50-7-29" id="h50-7-29" class="d">-        assert!(s.scan(4..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h50-7-30" id="h50-7-30" class="d">-        assert_eq!(vec![vec![3]], s.scan(3..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-31" id="h50-7-31" class="d">-        assert_eq!(vec![vec![2], vec![3]], s.scan(2..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h50-7-32" id="h50-7-32" class="i">+        assert_eq!(vec![vec![1]], s.scan(0..2).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h50-7-33" id="h50-7-33" class="i">+        assert_eq!(vec![vec![1], vec![2]], s.scan(1..3).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h50-7-34" id="h50-7-34" class="i">+        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(1..=3).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h50-7-35" id="h50-7-35" class="i">+        assert!(s.scan(3..1).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h50-7-36" id="h50-7-36" class="i">+        assert!(s.scan(1..1).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h50-7-37" id="h50-7-37" class="i">+        assert_eq!(vec![vec![2]], s.scan(2..=2).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h50-7-38" id="h50-7-38" class="i">+        assert_eq!(vec![vec![2], vec![3]], s.scan(2..5).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h50-7-39" id="h50-7-39" class="i">+
</a><a href="#h50-7-40" id="h50-7-40" class="i">+        assert!(s.scan(..0).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h50-7-41" id="h50-7-41" class="i">+        assert_eq!(vec![vec![1]], s.scan(..=1).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h50-7-42" id="h50-7-42" class="i">+        assert_eq!(vec![vec![1], vec![2]], s.scan(..3).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h50-7-43" id="h50-7-43" class="i">+
</a><a href="#h50-7-44" id="h50-7-44" class="i">+        assert!(s.scan(4..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h50-7-45" id="h50-7-45" class="i">+        assert_eq!(vec![vec![3]], s.scan(3..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h50-7-46" id="h50-7-46" class="i">+        assert_eq!(vec![vec![2], vec![3]], s.scan(2..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
         Ok(())
     }
<b>diff --git a/<a id="h51" href="../file/src/storage/log/test.rs.html">src/storage/log/test.rs</a> b/<a href="../file/src/storage/log/test.rs.html">src/storage/log/test.rs</a></b>
<a href="#h51-0" id="h51-0" class="h">@@ -1,5 +1,5 @@
</a> use super::{Memory, Scan, Store};
<a href="#h51-0-1" id="h51-0-1" class="d">-use crate::Error;
</a><a href="#h51-0-2" id="h51-0-2" class="i">+use crate::error::Result;
</a> 
 use std::ops::RangeBounds;
 use std::sync::{Arc, RwLock};
<a href="#h51-1" id="h51-1" class="h">@@ -19,11 +19,11 @@ impl Test {
</a> }
 
 impl Store for Test {
<a href="#h51-1-3" id="h51-1-3" class="d">-    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h51-1-4" id="h51-1-4" class="i">+    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64&gt; {
</a>         self.store.write()?.append(entry)
     }
 
<a href="#h51-1-8" id="h51-1-8" class="d">-    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h51-1-9" id="h51-1-9" class="i">+    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;()&gt; {
</a>         self.store.write()?.commit(index)
     }
 
<a href="#h51-2" id="h51-2" class="h">@@ -31,7 +31,7 @@ impl Store for Test {
</a>         self.store.read().unwrap().committed()
     }
 
<a href="#h51-2-3" id="h51-2-3" class="d">-    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h51-2-4" id="h51-2-4" class="i">+    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         self.store.read()?.get(index)
     }
 
<a href="#h51-3" id="h51-3" class="h">@@ -41,33 +41,31 @@ impl Store for Test {
</a> 
     fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan {
         // Since the mutex guard is scoped to this method, we simply buffer the result.
<a href="#h51-3-3" id="h51-3-3" class="d">-        Box::new(
</a><a href="#h51-3-4" id="h51-3-4" class="d">-            self.store.read().unwrap().scan(range).collect::&lt;Vec&lt;Result&lt;_, Error&gt;&gt;&gt;().into_iter(),
</a><a href="#h51-3-5" id="h51-3-5" class="d">-        )
</a><a href="#h51-3-6" id="h51-3-6" class="i">+        Box::new(self.store.read().unwrap().scan(range).collect::&lt;Vec&lt;Result&lt;_&gt;&gt;&gt;().into_iter())
</a>     }
 
<a href="#h51-3-9" id="h51-3-9" class="d">-    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h51-3-10" id="h51-3-10" class="i">+    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt; {
</a>         self.store.write()?.truncate(index)
     }
 
<a href="#h51-3-14" id="h51-3-14" class="d">-    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h51-3-15" id="h51-3-15" class="i">+    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a>         self.store.read()?.get_metadata(key)
     }
 
<a href="#h51-3-19" id="h51-3-19" class="d">-    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h51-3-20" id="h51-3-20" class="i">+    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a>         self.store.write()?.set_metadata(key, value)
     }
 }
 
 #[cfg(test)]
 impl super::TestSuite&lt;Test&gt; for Test {
<a href="#h51-3-27" id="h51-3-27" class="d">-    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h51-3-28" id="h51-3-28" class="i">+    fn setup() -&gt; Result&lt;Self&gt; {
</a>         Ok(Test::new())
     }
 }
 
 #[test]
<a href="#h51-3-34" id="h51-3-34" class="d">-fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h51-3-35" id="h51-3-35" class="i">+fn tests() -&gt; Result&lt;()&gt; {
</a>     use super::TestSuite;
     Test::test()
 }
<b>diff --git a/<a id="h52" href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a> b/<a href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a></b>
<a href="#h52-0" id="h52-0" class="h">@@ -2,20 +2,21 @@ mod pool;
</a> 
 use super::{assert_row, assert_rows, setup};
 
<a href="#h52-0-3" id="h52-0-3" class="i">+use toydb::error::{Error, Result};
</a> use toydb::raft;
 use toydb::sql::engine::{Mode, Status};
 use toydb::sql::execution::ResultSet;
 use toydb::sql::schema;
 use toydb::sql::types::{Column, DataType, Relation, Value};
 use toydb::storage::kv;
<a href="#h52-0-10" id="h52-0-10" class="d">-use toydb::{Client, Error};
</a><a href="#h52-0-11" id="h52-0-11" class="i">+use toydb::Client;
</a> 
 use pretty_assertions::assert_eq;
 use serial_test::serial;
 
 #[tokio::test(core_threads = 2)]
 #[serial]
<a href="#h52-0-18" id="h52-0-18" class="d">-async fn get_table() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h52-0-19" id="h52-0-19" class="i">+async fn get_table() -&gt; Result&lt;()&gt; {
</a>     let (c, _teardown) = setup::server_with_client(setup::movies()).await?;
 
     assert_eq!(
<a href="#h52-1" id="h52-1" class="h">@@ -105,7 +106,7 @@ async fn get_table() -&gt; Result&lt;(), Error&gt; {
</a> 
 #[tokio::test(core_threads = 2)]
 #[serial]
<a href="#h52-1-3" id="h52-1-3" class="d">-async fn list_tables() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h52-1-4" id="h52-1-4" class="i">+async fn list_tables() -&gt; Result&lt;()&gt; {
</a>     let (c, _teardown) = setup::server_with_client(setup::movies()).await?;
 
     assert_eq!(c.list_tables().await?, vec![&quot;countries&quot;, &quot;genres&quot;, &quot;movies&quot;, &quot;studios&quot;]);
<a href="#h52-2" id="h52-2" class="h">@@ -114,7 +115,7 @@ async fn list_tables() -&gt; Result&lt;(), Error&gt; {
</a> 
 #[tokio::test(core_threads = 2)]
 #[serial]
<a href="#h52-2-3" id="h52-2-3" class="d">-async fn status() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h52-2-4" id="h52-2-4" class="i">+async fn status() -&gt; Result&lt;()&gt; {
</a>     let (c, _teardown) = setup::server_with_client(setup::movies()).await?;
 
     assert_eq!(
<a href="#h52-3" id="h52-3" class="h">@@ -136,7 +137,7 @@ async fn status() -&gt; Result&lt;(), Error&gt; {
</a> 
 #[tokio::test(core_threads = 2)]
 #[serial]
<a href="#h52-3-3" id="h52-3-3" class="d">-async fn execute() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h52-3-4" id="h52-3-4" class="i">+async fn execute() -&gt; Result&lt;()&gt; {
</a>     let (c, _teardown) = setup::server_with_client(setup::movies()).await?;
 
     // SELECT
<a href="#h52-4" id="h52-4" class="h">@@ -229,7 +230,7 @@ async fn execute() -&gt; Result&lt;(), Error&gt; {
</a> 
 #[tokio::test(core_threads = 2)]
 #[serial]
<a href="#h52-4-3" id="h52-4-3" class="d">-async fn execute_txn() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h52-4-4" id="h52-4-4" class="i">+async fn execute_txn() -&gt; Result&lt;()&gt; {
</a>     let (c, _teardown) = setup::server_with_client(setup::movies()).await?;
 
     assert_eq!(c.txn(), None);
<a href="#h52-5" id="h52-5" class="h">@@ -319,7 +320,7 @@ async fn execute_txn() -&gt; Result&lt;(), Error&gt; {
</a> 
 #[tokio::test(core_threads = 2)]
 #[serial]
<a href="#h52-5-3" id="h52-5-3" class="d">-async fn execute_txn_concurrent() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h52-5-4" id="h52-5-4" class="i">+async fn execute_txn_concurrent() -&gt; Result&lt;()&gt; {
</a>     let (a, _teardown) = setup::server_with_client(setup::movies()).await?;
     let b = Client::new(&quot;127.0.0.1:9605&quot;).await?;
 
<b>diff --git a/<a id="h53" href="../file/tests/client/pool.rs.html">tests/client/pool.rs</a> b/<a href="../file/tests/client/pool.rs.html">tests/client/pool.rs</a></b>
<a href="#h53-0" id="h53-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::{assert_rows, setup};
 
<a href="#h53-0-2" id="h53-0-2" class="i">+use toydb::error::Result;
</a> use toydb::sql::types::Value;
<a href="#h53-0-4" id="h53-0-4" class="d">-use toydb::Error;
</a> 
 use futures::future::FutureExt as _;
 use pretty_assertions::assert_eq;
<a href="#h53-1" id="h53-1" class="h">@@ -12,7 +12,7 @@ use std::iter::FromIterator as _;
</a> #[tokio::test(core_threads = 4)]
 #[serial]
 #[allow(clippy::many_single_char_names)]
<a href="#h53-1-3" id="h53-1-3" class="d">-async fn get() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h53-1-4" id="h53-1-4" class="i">+async fn get() -&gt; Result&lt;()&gt; {
</a>     let (pool, _teardown) = setup::cluster_with_pool(3, 5, setup::simple()).await?;
 
     // The clients are allocated to all servers
<a href="#h53-2" id="h53-2" class="h">@@ -42,7 +42,7 @@ async fn get() -&gt; Result&lt;(), Error&gt; {
</a> 
 #[tokio::test(core_threads = 4)]
 #[serial]
<a href="#h53-2-3" id="h53-2-3" class="d">-async fn drop_rollback() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h53-2-4" id="h53-2-4" class="i">+async fn drop_rollback() -&gt; Result&lt;()&gt; {
</a>     let (pool, _teardown) = setup::cluster_with_pool(3, 1, setup::simple()).await?;
 
     // Starting a client and dropping it mid-transaction should work.
<b>diff --git a/<a id="h54" href="../file/tests/cluster/isolation.rs.html">tests/cluster/isolation.rs</a> b/<a href="../file/tests/cluster/isolation.rs.html">tests/cluster/isolation.rs</a></b>
<a href="#h54-0" id="h54-0" class="h">@@ -1,14 +1,14 @@
</a> use super::super::{assert_row, assert_rows, setup};
 
<a href="#h54-0-2" id="h54-0-2" class="i">+use toydb::error::{Error, Result};
</a> use toydb::sql::types::Value;
<a href="#h54-0-4" id="h54-0-4" class="d">-use toydb::Error;
</a> 
 use serial_test::serial;
 
 #[tokio::test(core_threads = 2)]
 #[serial]
 // A dirty write is when b overwrites an uncommitted value written by a.
<a href="#h54-0-11" id="h54-0-11" class="d">-async fn anomaly_dirty_write() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h54-0-12" id="h54-0-12" class="i">+async fn anomaly_dirty_write() -&gt; Result&lt;()&gt; {
</a>     let (a, b, _, _teardown) = setup::cluster_simple().await?;
 
     a.execute(&quot;BEGIN&quot;).await?;
<a href="#h54-1" id="h54-1" class="h">@@ -28,7 +28,7 @@ async fn anomaly_dirty_write() -&gt; Result&lt;(), Error&gt; {
</a> #[tokio::test(core_threads = 2)]
 #[serial]
 // A dirty read is when b can read an uncommitted value set by a.
<a href="#h54-1-3" id="h54-1-3" class="d">-async fn anomaly_dirty_read() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h54-1-4" id="h54-1-4" class="i">+async fn anomaly_dirty_read() -&gt; Result&lt;()&gt; {
</a>     let (a, b, _, _teardown) = setup::cluster_simple().await?;
 
     a.execute(&quot;BEGIN&quot;).await?;
<a href="#h54-2" id="h54-2" class="h">@@ -42,7 +42,7 @@ async fn anomaly_dirty_read() -&gt; Result&lt;(), Error&gt; {
</a> #[tokio::test(core_threads = 2)]
 #[serial]
 // A lost update is when a and b both read a value and update it, where b&#39;s update replaces a.
<a href="#h54-2-3" id="h54-2-3" class="d">-async fn anomaly_lost_update() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h54-2-4" id="h54-2-4" class="i">+async fn anomaly_lost_update() -&gt; Result&lt;()&gt; {
</a>     let (a, b, c, _teardown) = setup::cluster_simple().await?;
 
     c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;)&quot;).await?;
<a href="#h54-3" id="h54-3" class="h">@@ -68,7 +68,7 @@ async fn anomaly_lost_update() -&gt; Result&lt;(), Error&gt; {
</a> #[tokio::test(core_threads = 2)]
 #[serial]
 // A fuzzy (or unrepeatable) read is when b sees a value change after a updates it.
<a href="#h54-3-3" id="h54-3-3" class="d">-async fn anomaly_fuzzy_read() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h54-3-4" id="h54-3-4" class="i">+async fn anomaly_fuzzy_read() -&gt; Result&lt;()&gt; {
</a>     let (a, b, c, _teardown) = setup::cluster_simple().await?;
 
     c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;)&quot;).await?;
<a href="#h54-4" id="h54-4" class="h">@@ -93,7 +93,7 @@ async fn anomaly_fuzzy_read() -&gt; Result&lt;(), Error&gt; {
</a> #[tokio::test(core_threads = 2)]
 #[serial]
 // Read skew is when a reads 1 and 2, but b modifies 2 in between the reads.
<a href="#h54-4-3" id="h54-4-3" class="d">-async fn anomaly_read_skew() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h54-4-4" id="h54-4-4" class="i">+async fn anomaly_read_skew() -&gt; Result&lt;()&gt; {
</a>     let (a, b, c, _teardown) = setup::cluster_simple().await?;
 
     c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;), (2, &#39;c&#39;)&quot;).await?;
<a href="#h54-5" id="h54-5" class="h">@@ -119,7 +119,7 @@ async fn anomaly_read_skew() -&gt; Result&lt;(), Error&gt; {
</a> #[serial]
 // A phantom read is when a reads entries matching some predicate, but a modification by
 // b changes the entries that match the predicate such that a later read by a returns them.
<a href="#h54-5-3" id="h54-5-3" class="d">-async fn anomaly_phantom_read() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h54-5-4" id="h54-5-4" class="i">+async fn anomaly_phantom_read() -&gt; Result&lt;()&gt; {
</a>     let (a, b, c, _teardown) = setup::cluster_simple().await?;
 
     c.execute(&quot;INSERT INTO test VALUES (1, &#39;true&#39;), (2, &#39;false&#39;)&quot;).await?;
<b>diff --git a/<a id="h55" href="../file/tests/setup.rs.html">tests/setup.rs</a> b/<a href="../file/tests/setup.rs.html">tests/setup.rs</a></b>
<a href="#h55-0" id="h55-0" class="h">@@ -1,9 +1,8 @@
</a> #![allow(clippy::implicit_hasher)]
<a href="#h55-0-1" id="h55-0-1" class="d">-#![allow(clippy::type_complexity)]
</a> 
 use toydb::client::{Client, Pool};
<a href="#h55-0-4" id="h55-0-4" class="i">+use toydb::error::Result;
</a> use toydb::server::Server;
<a href="#h55-0-6" id="h55-0-6" class="d">-use toydb::Error;
</a> 
 use futures_util::future::FutureExt as _;
 use pretty_assertions::assert_eq;
<a href="#h55-1" id="h55-1" class="h">@@ -73,7 +72,7 @@ pub async fn server(
</a>     addr_sql: &amp;str,
     addr_raft: &amp;str,
     peers: HashMap&lt;String, String&gt;,
<a href="#h55-1-3" id="h55-1-3" class="d">-) -&gt; Result&lt;Teardown, Error&gt; {
</a><a href="#h55-1-4" id="h55-1-4" class="i">+) -&gt; Result&lt;Teardown&gt; {
</a>     let dir = TempDir::new(&quot;toydb&quot;)?;
     let mut srv = Server::new(id, peers, &amp;dir.path().to_string_lossy(), false).await?;
 
<a href="#h55-2" id="h55-2" class="h">@@ -88,7 +87,7 @@ pub async fn server(
</a> }
 
 /// Sets up a server with a client
<a href="#h55-2-3" id="h55-2-3" class="d">-pub async fn server_with_client(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;(Client, Teardown), Error&gt; {
</a><a href="#h55-2-4" id="h55-2-4" class="i">+pub async fn server_with_client(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;(Client, Teardown)&gt; {
</a>     let teardown = server(&quot;test&quot;, &quot;127.0.0.1:9605&quot;, &quot;127.0.0.1:9705&quot;, HashMap::new()).await?;
     let client = Client::new(&quot;127.0.0.1:9605&quot;).await?;
     if !queries.is_empty() {
<a href="#h55-3" id="h55-3" class="h">@@ -102,7 +101,7 @@ pub async fn server_with_client(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;(Client, Teardown)
</a> }
 
 /// Sets up a server cluster
<a href="#h55-3-3" id="h55-3-3" class="d">-pub async fn cluster(nodes: HashMap&lt;String, (String, String)&gt;) -&gt; Result&lt;Teardown, Error&gt; {
</a><a href="#h55-3-4" id="h55-3-4" class="i">+pub async fn cluster(nodes: HashMap&lt;String, (String, String)&gt;) -&gt; Result&lt;Teardown&gt; {
</a>     let mut teardown = Teardown::empty();
     for (id, (addr_sql, addr_raft)) in nodes.iter() {
         let peers = nodes
<a href="#h55-4" id="h55-4" class="h">@@ -119,7 +118,7 @@ pub async fn cluster(nodes: HashMap&lt;String, (String, String)&gt;) -&gt; Result&lt;Teardow
</a> pub async fn cluster_with_clients(
     size: u64,
     queries: Vec&lt;&amp;str&gt;,
<a href="#h55-4-3" id="h55-4-3" class="d">-) -&gt; Result&lt;(Vec&lt;Client&gt;, Teardown), Error&gt; {
</a><a href="#h55-4-4" id="h55-4-4" class="i">+) -&gt; Result&lt;(Vec&lt;Client&gt;, Teardown)&gt; {
</a>     let mut nodes = HashMap::new();
     for i in 0..size {
         nodes.insert(
<a href="#h55-5" id="h55-5" class="h">@@ -153,7 +152,7 @@ pub async fn cluster_with_pool(
</a>     cluster_size: u64,
     pool_size: u64,
     queries: Vec&lt;&amp;str&gt;,
<a href="#h55-5-3" id="h55-5-3" class="d">-) -&gt; Result&lt;(Pool, Teardown), Error&gt; {
</a><a href="#h55-5-4" id="h55-5-4" class="i">+) -&gt; Result&lt;(Pool, Teardown)&gt; {
</a>     let mut nodes = HashMap::new();
     for i in 0..cluster_size {
         nodes.insert(
<a href="#h55-6" id="h55-6" class="h">@@ -179,7 +178,7 @@ pub async fn cluster_with_pool(
</a> }
 
 /// Sets up a simple cluster with 3 clients and a test table
<a href="#h55-6-3" id="h55-6-3" class="d">-pub async fn cluster_simple() -&gt; Result&lt;(Client, Client, Client, Teardown), Error&gt; {
</a><a href="#h55-6-4" id="h55-6-4" class="i">+pub async fn cluster_simple() -&gt; Result&lt;(Client, Client, Client, Teardown)&gt; {
</a>     let (mut clients, teardown) = cluster_with_clients(3, simple()).await?;
     let a = clients.remove(0);
     let b = clients.remove(0);
<b>diff --git a/<a id="h56" href="../file/tests/sql/dml.rs.html">tests/sql/dml.rs</a> b/<a href="../file/tests/sql/dml.rs.html">tests/sql/dml.rs</a></b>
<a href="#h56-0" id="h56-0" class="h">@@ -1,8 +1,8 @@
</a> ///! DML-related tests, using an in-memory database against golden files in tests/sql/dml/
 ///! Note that schema-related tests are in schema.rs, this is just for the basic DML functionality
<a href="#h56-0-2" id="h56-0-2" class="i">+use toydb::error::Result;
</a> use toydb::sql::engine::{Engine as _, Mode, Transaction as _};
 use toydb::sql::schema::Catalog as _;
<a href="#h56-0-5" id="h56-0-5" class="d">-use toydb::Error;
</a> 
 use goldenfile::Mint;
 use std::io::Write;
<a href="#h56-1" id="h56-1" class="h">@@ -16,7 +16,7 @@ macro_rules! test_dml {
</a>     ( with $setup:expr; $( $name:ident: $query:expr, )* ) =&gt; {
         $(
             #[test]
<a href="#h56-1-3" id="h56-1-3" class="d">-            fn $name() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h56-1-4" id="h56-1-4" class="i">+            fn $name() -&gt; Result&lt;()&gt; {
</a>                 let setup: &amp;[&amp;str] = &amp;$setup;
                 let engine = super::setup(setup.into())?;
                 let mut mint = Mint::new(&quot;tests/sql/dml&quot;);
<b>diff --git a/<a id="h57" href="../file/tests/sql/expression.rs.html">tests/sql/expression.rs</a> b/<a href="../file/tests/sql/expression.rs.html">tests/sql/expression.rs</a></b>
<a href="#h57-0" id="h57-0" class="h">@@ -1,10 +1,10 @@
</a> ///! Evaluates SQL expressions and compares with expectations.
<a href="#h57-0-1" id="h57-0-1" class="i">+use toydb::error::{Error, Result};
</a> use toydb::sql::engine::Engine;
 use toydb::sql::execution::ResultSet;
 use toydb::sql::types::Value;
<a href="#h57-0-5" id="h57-0-5" class="d">-use toydb::Error;
</a> 
<a href="#h57-0-7" id="h57-0-7" class="d">-fn eval_expr(expr: &amp;str) -&gt; Result&lt;Value, Error&gt; {
</a><a href="#h57-0-8" id="h57-0-8" class="i">+fn eval_expr(expr: &amp;str) -&gt; Result&lt;Value&gt; {
</a>     let engine = super::setup(Vec::new())?;
     match engine.session()?.execute(&amp;format!(&quot;SELECT {}&quot;, expr))? {
         ResultSet::Query { mut relation } =&gt; {
<a href="#h57-1" id="h57-1" class="h">@@ -18,8 +18,8 @@ macro_rules! test_expr {
</a>     ( $( $name:ident: $expr:expr =&gt; $expect:expr, )* ) =&gt; {
     $(
         #[test]
<a href="#h57-1-3" id="h57-1-3" class="d">-        fn $name() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h57-1-4" id="h57-1-4" class="d">-            let expect: Result&lt;Value, Error&gt; = $expect;
</a><a href="#h57-1-5" id="h57-1-5" class="i">+        fn $name() -&gt; Result&lt;()&gt; {
</a><a href="#h57-1-6" id="h57-1-6" class="i">+            let expect: Result&lt;Value&gt; = $expect;
</a>             let actual = eval_expr($expr);
             match expect {
                 Ok(Float(e)) if e.is_nan() =&gt; match actual {
<b>diff --git a/<a id="h58" href="../file/tests/sql/mod.rs.html">tests/sql/mod.rs</a> b/<a href="../file/tests/sql/mod.rs.html">tests/sql/mod.rs</a></b>
<a href="#h58-0" id="h58-0" class="h">@@ -3,11 +3,11 @@ mod expression;
</a> mod query;
 mod schema;
 
<a href="#h58-0-3" id="h58-0-3" class="i">+use toydb::error::Result;
</a> use toydb::sql::engine::{Engine, KV};
 use toydb::storage::kv;
<a href="#h58-0-6" id="h58-0-6" class="d">-use toydb::Error;
</a> 
<a href="#h58-0-8" id="h58-0-8" class="d">-fn setup(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;KV&lt;kv::Memory&gt;, Error&gt; {
</a><a href="#h58-0-9" id="h58-0-9" class="i">+fn setup(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;KV&lt;kv::Memory&gt;&gt; {
</a>     let engine = KV::new(kv::MVCC::new(kv::Memory::new()));
     let mut session = engine.session()?;
     session.execute(&quot;BEGIN&quot;)?;
<b>diff --git a/<a id="h59" href="../file/tests/sql/query.rs.html">tests/sql/query.rs</a> b/<a href="../file/tests/sql/query.rs.html">tests/sql/query.rs</a></b>
<a href="#h59-0" id="h59-0" class="h">@@ -1,11 +1,11 @@
</a> ///! Tests for the SQL query engine. Runs SQL queries against an in-memory database,
 ///! and compares the results with golden files stored under tests/sql/query/
<a href="#h59-0-2" id="h59-0-2" class="i">+use toydb::error::{Error, Result};
</a> use toydb::sql::engine::{Engine, Mode, Transaction};
 use toydb::sql::execution::{Context, ResultSet};
 use toydb::sql::parser::Parser;
 use toydb::sql::plan::Plan;
 use toydb::sql::types::Row;
<a href="#h59-0-8" id="h59-0-8" class="d">-use toydb::Error;
</a> 
 use goldenfile::Mint;
 use std::io::Write;
<a href="#h59-1" id="h59-1" class="h">@@ -19,7 +19,7 @@ macro_rules! test_query {
</a>     ( with $setup:expr; $( $name:ident: $query:expr, )* ) =&gt; {
     $(
         #[test]
<a href="#h59-1-3" id="h59-1-3" class="d">-        fn $name() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h59-1-4" id="h59-1-4" class="i">+        fn $name() -&gt; Result&lt;()&gt; {
</a>             let mut setup = $setup.to_vec();
             setup.extend(vec![
                 &quot;CREATE TABLE countries (
<b>diff --git a/<a id="h60" href="../file/tests/sql/schema.rs.html">tests/sql/schema.rs</a> b/<a href="../file/tests/sql/schema.rs.html">tests/sql/schema.rs</a></b>
<a href="#h60-0" id="h60-0" class="h">@@ -1,7 +1,7 @@
</a> ///! Schema-related tests, using an in-memory database against golden files in tests/sql/chema/
<a href="#h60-0-1" id="h60-0-1" class="i">+use toydb::error::Result;
</a> use toydb::sql::engine::{Engine as _, Mode, Transaction as _};
 use toydb::sql::schema::Catalog as _;
<a href="#h60-0-4" id="h60-0-4" class="d">-use toydb::Error;
</a> 
 use goldenfile::Mint;
 use std::io::Write;
<a href="#h60-1" id="h60-1" class="h">@@ -15,7 +15,7 @@ macro_rules! test_schema {
</a>     ( with $setup:expr; $( $name:ident: $query:expr, )* ) =&gt; {
         $(
             #[test]
<a href="#h60-1-3" id="h60-1-3" class="d">-            fn $name() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h60-1-4" id="h60-1-4" class="i">+            fn $name() -&gt; Result&lt;()&gt; {
</a>                 let setup: &amp;[&amp;str] = &amp;$setup;
                 let engine = super::setup(setup.into())?;
                 let mut mint = Mint::new(&quot;tests/sql/schema&quot;);
</pre>
</div>
</body>
</html>
