<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rename &quot;field&quot; to &quot;column&quot; throughout - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/b08ac1e960bdebc0a8a103caff9bdb0386bbb587.html">b08ac1e960bdebc0a8a103caff9bdb0386bbb587</a>
<b>parent</b> <a href="../commit/dfe775b3ac23201844db898c93de9b26799aa120.html">dfe775b3ac23201844db898c93de9b26799aa120</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Wed, 17 Jul 2024 14:23:54 +0200

Rename &quot;field&quot; to &quot;column&quot; throughout

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">docs/architecture.md</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">docs/sql.md</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/engine/session.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/execution/execute.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/execution/join.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/execution/write.rs</a></td><td> | </td><td class="num">10</td><td><span class="i">+++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/parser/parser.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/sql/planner/optimizer.rs</a></td><td> | </td><td class="num">58</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d">-----------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">src/sql/planner/plan.rs</a></td><td> | </td><td class="num">28</td><td><span class="i">++++++++++++++</span><span class="d">--------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">34</td><td><span class="i">+++++++++++++++++</span><span class="d">-----------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">src/sql/testscripts/expressions/literals</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">src/sql/testscripts/queries/aggregate</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h13">src/sql/testscripts/queries/group_by</a></td><td> | </td><td class="num">10</td><td><span class="i">+++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h14">src/sql/testscripts/queries/having</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h15">src/sql/testscripts/queries/join_inner</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h16">src/sql/testscripts/queries/limit</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h17">src/sql/testscripts/queries/offset</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h18">src/sql/testscripts/queries/order</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h19">src/sql/testscripts/queries/select</a></td><td> | </td><td class="num">22</td><td><span class="i">+++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h20">src/sql/testscripts/queries/where_</a></td><td> | </td><td class="num">16</td><td><span class="i">++++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h21">src/sql/testscripts/writes/delete_where</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h22">src/sql/testscripts/writes/insert</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h23">src/sql/testscripts/writes/update</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h24">src/sql/testscripts/writes/update_index</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h25">src/sql/testscripts/writes/update_null</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h26">src/sql/testscripts/writes/update_where</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h27">src/sql/types/expression.rs</a></td><td> | </td><td class="num">70</td><td><span class="i">++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h28">src/sql/types/value.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h29">tests/e2e/client.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
</table></pre><pre>30 files changed, 179 insertions(+), 177 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/docs/architecture.md.html">docs/architecture.md</a> b/<a href="../file/docs/architecture.md.html">docs/architecture.md</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -479,7 +479,7 @@ ast::Statement::Select{
</a> 
 The parser will interpret the SQL _syntax_, determining the type of query and its parameters,
 returning an error for any invalid syntax. However, it has no idea if the table `people`
<a href="#h0-0-3" id="h0-0-3" class="d">-actually exists, or if the field `birthyear` is an integer - that is the job of the planner.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+actually exists, or if the column `birthyear` is an integer - that is the job of the planner.
</a> 
 Notably, the parser also parses expressions, such as `1 + 2 * 3`. This is non-trivial due to
 precedence rules, i.e. `2 * 3` should be evaluated first, but not if there are parentheses
<b>diff --git a/<a id="h1" href="../file/docs/sql.md.html">docs/sql.md</a> b/<a href="../file/docs/sql.md.html">docs/sql.md</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -57,7 +57,7 @@ The `-` prefix operator can be used to take negative numbers.
</a> 
 ### Expressions
 
<a href="#h1-0-3" id="h1-0-3" class="d">-Expressions can be used wherever a value is expected, e.g. as `SELECT` fields and `INSERT` values. They are made up of constants, a column references, an operator invocations, and a function calls.
</a><a href="#h1-0-4" id="h1-0-4" class="i">+Expressions can be used wherever a value is expected, e.g. as `SELECT` columns nd `INSERT` values. They are made up of constants, a column references, an operator invocations, and a function calls.
</a> 
 Column references can either be unqualified, e.g. `name`, or prefixed with the relation identifier separated by `.`, e.g. `person.name`. Unqualified identifiers must be unambiguous.
 
<a href="#h1-1" id="h1-1" class="h">@@ -290,7 +290,7 @@ If column names are given, an identical number of values must be given. If no co
</a> 
 * ***`column_name`***: a column to insert into in the given table. Errors if it does not exist.
 
<a href="#h1-1-3" id="h1-1-3" class="d">-* ***`expression`***: an expression to insert into the corresponding column. Must be a constant expression, i.e. it cannot refer to table fields.
</a><a href="#h1-1-4" id="h1-1-4" class="i">+* ***`expression`***: an expression to insert into the corresponding column. Must be a constant expression, i.e. it cannot refer to table columns.
</a> 
 #### Example
 
<a href="#h1-2" id="h1-2" class="h">@@ -337,9 +337,9 @@ RIGHT [ OUTER ] JOIN
</a> 
 Fetches rows or expressions, either from table ***`table_name`*** (if given) or generated.
 
<a href="#h1-2-3" id="h1-2-3" class="d">-* ***`expression`***: [expression](#expressions) to fetch (can be a simple field name).
</a><a href="#h1-2-4" id="h1-2-4" class="i">+* ***`expression`***: [expression](#expressions) to fetch (can be a simple column name).
</a> 
<a href="#h1-2-6" id="h1-2-6" class="d">-* ***`output_name`***: output column [identifier](#identifier), defaults to field name (if single field) otherwise nothing (displayed as `?`).
</a><a href="#h1-2-7" id="h1-2-7" class="i">+* ***`output_name`***: output column [identifier](#identifier), defaults to column name (if single column) otherwise nothing (displayed as `?`).
</a> 
 * ***`table_name`***: table to fetch rows from.
 
<a href="#h1-3" id="h1-3" class="h">@@ -347,11 +347,11 @@ Fetches rows or expressions, either from table ***`table_name`*** (if given) or 
</a> 
 * ***`predicate`***: only return rows for which this [expression](#expressions) evaluates to `TRUE`.
 
<a href="#h1-3-3" id="h1-3-3" class="d">-* ***`group_expr`***: an expression to group aggregates by. Non-aggregate `SELECT` expressions must either reference a field given in `group_expr`, be idential with a `group_expr`, or have an `output_name` that is referenced by a `group_expr` field.
</a><a href="#h1-3-4" id="h1-3-4" class="i">+* ***`group_expr`***: an expression to group aggregates by. Non-aggregate `SELECT` expressions must either reference a column given in `group_expr`, be idential with a `group_expr`, or have an `output_name` that is referenced by a `group_expr` column.
</a> 
 * ***`having_expr`***: only return aggregate results for which this [expression](#expressions) evaluates to `TRUE`.
 
<a href="#h1-3-8" id="h1-3-8" class="d">-* ***`order_expr`***: order rows by this expression (can be a simple field name).
</a><a href="#h1-3-9" id="h1-3-9" class="i">+* ***`order_expr`***: order rows by this expression (can be a simple column name).
</a> 
 * ***`count`***: maximum number of rows to return. Must be a constant integer expression.
 
<b>diff --git a/<a id="h2" href="../file/src/sql/engine/session.rs.html">src/sql/engine/session.rs</a> b/<a href="../file/src/sql/engine/session.rs.html">src/sql/engine/session.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -184,17 +184,17 @@ impl TryFrom&lt;StatementResult&gt; for Row {
</a>     }
 }
 
<a href="#h2-0-3" id="h2-0-3" class="d">-/// Extracts the value of the first field in the first row.
</a><a href="#h2-0-4" id="h2-0-4" class="i">+/// Extracts the value of the first column in the first row.
</a> impl TryFrom&lt;StatementResult&gt; for Value {
     type Error = Error;
 
     fn try_from(result: StatementResult) -&gt; Result&lt;Self&gt; {
         let row: Row = result.try_into()?;
<a href="#h2-0-10" id="h2-0-10" class="d">-        row.into_iter().next().ok_or(errdata!(&quot;no fields returned&quot;))
</a><a href="#h2-0-11" id="h2-0-11" class="i">+        row.into_iter().next().ok_or(errdata!(&quot;no columns returned&quot;))
</a>     }
 }
 
<a href="#h2-0-15" id="h2-0-15" class="d">-/// Extracts the first boolean value of the first field in the first row.
</a><a href="#h2-0-16" id="h2-0-16" class="i">+/// Extracts the first boolean value of the first column in the first row.
</a> impl TryFrom&lt;StatementResult&gt; for bool {
     type Error = Error;
 
<a href="#h2-1" id="h2-1" class="h">@@ -204,7 +204,7 @@ impl TryFrom&lt;StatementResult&gt; for bool {
</a>     }
 }
 
<a href="#h2-1-3" id="h2-1-3" class="d">-/// Extracts the first f64 value of the first field in the first row.
</a><a href="#h2-1-4" id="h2-1-4" class="i">+/// Extracts the first f64 value of the first column in the first row.
</a> impl TryFrom&lt;StatementResult&gt; for f64 {
     type Error = Error;
 
<a href="#h2-2" id="h2-2" class="h">@@ -214,7 +214,7 @@ impl TryFrom&lt;StatementResult&gt; for f64 {
</a>     }
 }
 
<a href="#h2-2-3" id="h2-2-3" class="d">-/// Extracts the first i64 value of the first field in the first row.
</a><a href="#h2-2-4" id="h2-2-4" class="i">+/// Extracts the first i64 value of the first column in the first row.
</a> impl TryFrom&lt;StatementResult&gt; for i64 {
     type Error = Error;
 
<a href="#h2-3" id="h2-3" class="h">@@ -224,7 +224,7 @@ impl TryFrom&lt;StatementResult&gt; for i64 {
</a>     }
 }
 
<a href="#h2-3-3" id="h2-3-3" class="d">-/// Extracts the first string value of the first field in the first row.
</a><a href="#h2-3-4" id="h2-3-4" class="i">+/// Extracts the first string value of the first column in the first row.
</a> impl TryFrom&lt;StatementResult&gt; for String {
     type Error = Error;
 
<b>diff --git a/<a id="h3" href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a> b/<a href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -70,11 +70,11 @@ pub fn execute(node: Node, txn: &amp;impl Transaction) -&gt; Result&lt;Rows&gt; {
</a>             Ok(transform::filter(source, predicate))
         }
 
<a href="#h3-0-3" id="h3-0-3" class="d">-        Node::HashJoin { left, left_field, right, right_field, outer } =&gt; {
</a><a href="#h3-0-4" id="h3-0-4" class="i">+        Node::HashJoin { left, left_column, right, right_column, outer } =&gt; {
</a>             let right_size = right.size();
             let left = execute(*left, txn)?;
             let right = execute(*right, txn)?;
<a href="#h3-0-8" id="h3-0-8" class="d">-            join::hash(left, left_field, right, right_field, right_size, outer)
</a><a href="#h3-0-9" id="h3-0-9" class="i">+            join::hash(left, left_column, right, right_column, right_size, outer)
</a>         }
 
         Node::IndexLookup { table, column, values, alias: _ } =&gt; {
<b>diff --git a/<a id="h4" href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a> b/<a href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -122,9 +122,9 @@ impl Iterator for NestedLoopIterator {
</a> /// TODO: add more tests for the multiple match case.
 pub(super) fn hash(
     left: Rows,
<a href="#h4-0-3" id="h4-0-3" class="d">-    left_field: usize,
</a><a href="#h4-0-4" id="h4-0-4" class="i">+    left_column: usize,
</a>     right: Rows,
<a href="#h4-0-6" id="h4-0-6" class="d">-    right_field: usize,
</a><a href="#h4-0-7" id="h4-0-7" class="i">+    right_column: usize,
</a>     right_size: usize,
     outer: bool,
 ) -&gt; Result&lt;Rows&gt; {
<a href="#h4-1" id="h4-1" class="h">@@ -132,7 +132,7 @@ pub(super) fn hash(
</a>     let mut rows = right;
     let mut right: HashMap&lt;Value, Vec&lt;Row&gt;&gt; = HashMap::new();
     while let Some(row) = rows.next().transpose()? {
<a href="#h4-1-3" id="h4-1-3" class="d">-        let id = row[right_field].clone();
</a><a href="#h4-1-4" id="h4-1-4" class="i">+        let id = row[right_column].clone();
</a>         right.entry(id).or_default().push(row);
     }
 
<a href="#h4-2" id="h4-2" class="h">@@ -146,7 +146,7 @@ pub(super) fn hash(
</a>             return Box::new(std::iter::once(result));
         };
         // Join the left row with any matching right rows.
<a href="#h4-2-3" id="h4-2-3" class="d">-        match right.get(&amp;row[left_field]) {
</a><a href="#h4-2-4" id="h4-2-4" class="i">+        match right.get(&amp;row[left_column]) {
</a>             Some(matches) =&gt; Box::new(
                 std::iter::once(row)
                     .cartesian_product(matches.clone())
<b>diff --git a/<a id="h5" href="../file/src/sql/execution/write.rs.html">src/sql/execution/write.rs</a> b/<a href="../file/src/sql/execution/write.rs.html">src/sql/execution/write.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -6,7 +6,7 @@ use crate::{errdata, errinput};
</a> use std::collections::{BTreeMap, HashMap};
 
 /// Deletes rows, taking primary keys from the source (i.e. DELETE) using the
<a href="#h5-0-3" id="h5-0-3" class="d">-/// primary_key field index. Returns the number of rows deleted.
</a><a href="#h5-0-4" id="h5-0-4" class="i">+/// primary_key column index. Returns the number of rows deleted.
</a> pub(super) fn delete(
     txn: &amp;impl Transaction,
     table: String,
<a href="#h5-1" id="h5-1" class="h">@@ -51,8 +51,8 @@ pub(super) fn insert(
</a>             }
         }
 
<a href="#h5-1-3" id="h5-1-3" class="d">-        // Fill in the row with default values for missing fields, and map
</a><a href="#h5-1-4" id="h5-1-4" class="d">-        // source fields to table fields.
</a><a href="#h5-1-5" id="h5-1-5" class="i">+        // Fill in the row with default values for missing columns, and map
</a><a href="#h5-1-6" id="h5-1-6" class="i">+        // source columns to table columns.
</a>         let mut row = Vec::with_capacity(table.columns.len());
         for (cidx, column) in table.columns.iter().enumerate() {
             if column_map.is_none() &amp;&amp; cidx &lt; values.len() {
<a href="#h5-2" id="h5-2" class="h">@@ -87,8 +87,8 @@ pub(super) fn update(
</a>     let mut updates = BTreeMap::new();
     while let Some(row) = source.next().transpose()? {
         let mut new = row.clone();
<a href="#h5-2-3" id="h5-2-3" class="d">-        for (field, expr) in &amp;expressions {
</a><a href="#h5-2-4" id="h5-2-4" class="d">-            new[*field] = expr.evaluate(Some(&amp;row))?;
</a><a href="#h5-2-5" id="h5-2-5" class="i">+        for (column, expr) in &amp;expressions {
</a><a href="#h5-2-6" id="h5-2-6" class="i">+            new[*column] = expr.evaluate(Some(&amp;row))?;
</a>         }
         let id = row.into_iter().nth(primary_key).ok_or::&lt;Error&gt;(errdata!(&quot;short row&quot;))?;
         updates.insert(id, new);
<b>diff --git a/<a id="h6" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -98,8 +98,8 @@ pub enum Order {
</a> /// Expressions. Can be nested.
 #[derive(Clone, Debug, Eq, Hash, PartialEq)]
 pub enum Expression {
<a href="#h6-0-3" id="h6-0-3" class="d">-    /// A field reference, with an optional table qualifier.
</a><a href="#h6-0-4" id="h6-0-4" class="d">-    Field(Option&lt;String&gt;, String),
</a><a href="#h6-0-5" id="h6-0-5" class="i">+    /// A column reference, optionally qualified with a table name.
</a><a href="#h6-0-6" id="h6-0-6" class="i">+    Column(Option&lt;String&gt;, String),
</a>     /// A literal value.
     Literal(Literal),
     /// A function call (name and parameters).
<a href="#h6-1" id="h6-1" class="h">@@ -217,7 +217,7 @@ impl Expression {
</a> 
             Self::Function(_, exprs) =&gt; exprs.iter().any(|expr| expr.walk(visitor)),
 
<a href="#h6-1-3" id="h6-1-3" class="d">-            Self::Literal(_) | Self::Field(_, _) =&gt; true,
</a><a href="#h6-1-4" id="h6-1-4" class="i">+            Self::Literal(_) | Self::Column(_, _) =&gt; true,
</a>         }
     }
 
<a href="#h6-2" id="h6-2" class="h">@@ -264,7 +264,7 @@ impl Expression {
</a> 
             Self::Function(_, exprs) =&gt; exprs.iter().for_each(|expr| expr.collect(visitor, c)),
 
<a href="#h6-2-3" id="h6-2-3" class="d">-            Self::Literal(_) | Self::Field(_, _) =&gt; {}
</a><a href="#h6-2-4" id="h6-2-4" class="i">+            Self::Literal(_) | Self::Column(_, _) =&gt; {}
</a>         }
     }
 }
<b>diff --git a/<a id="h7" href="../file/src/sql/parser/parser.rs.html">src/sql/parser/parser.rs</a> b/<a href="../file/src/sql/parser/parser.rs.html">src/sql/parser/parser.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -510,7 +510,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     /// Parses an expression atom. This is either:
     ///
     /// * A literal value.
<a href="#h7-0-3" id="h7-0-3" class="d">-    /// * A field name.
</a><a href="#h7-0-4" id="h7-0-4" class="i">+    /// * A column name.
</a>     /// * A function call.
     /// * A parenthesized expression.
     fn parse_expression_atom(&amp;mut self) -&gt; Result&lt;ast::Expression&gt; {
<a href="#h7-1" id="h7-1" class="h">@@ -544,11 +544,11 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>                 ast::Expression::Function(name, args)
             }
 
<a href="#h7-1-3" id="h7-1-3" class="d">-            // Field name, either qualified as table.field or unqualified.
</a><a href="#h7-1-4" id="h7-1-4" class="i">+            // Column name, either qualified as table.column or unqualified.
</a>             Token::Ident(table) if self.next_is(Token::Period) =&gt; {
<a href="#h7-1-6" id="h7-1-6" class="d">-                ast::Expression::Field(Some(table), self.next_ident()?)
</a><a href="#h7-1-7" id="h7-1-7" class="i">+                ast::Expression::Column(Some(table), self.next_ident()?)
</a>             }
<a href="#h7-1-9" id="h7-1-9" class="d">-            Token::Ident(field) =&gt; ast::Expression::Field(None, field),
</a><a href="#h7-1-10" id="h7-1-10" class="i">+            Token::Ident(column) =&gt; ast::Expression::Column(None, column),
</a> 
             // Parenthesized expression.
             Token::OpenParen =&gt; {
<b>diff --git a/<a id="h8" href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a> b/<a href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -25,7 +25,7 @@ pub(super) fn fold_constants(node: Node) -&gt; Result&lt;Node&gt; {
</a>     // Transforms expressions.
     let transform = |expr: Expression| {
         // If the expression is constant, evaluate it.
<a href="#h8-0-3" id="h8-0-3" class="d">-        if !expr.contains(&amp;|e| matches!(e, Expression::Field(_))) {
</a><a href="#h8-0-4" id="h8-0-4" class="i">+        if !expr.contains(&amp;|e| matches!(e, Expression::Column(_))) {
</a>             return expr.evaluate(None).map(Expression::Constant);
         }
         // If the expression is a logical operator, and one of the sides is
<a href="#h8-1" id="h8-1" class="h">@@ -55,7 +55,7 @@ pub(super) fn fold_constants(node: Node) -&gt; Result&lt;Node&gt; {
</a> 
     // Transform expressions after descending, both to perform the logical
     // short-circuiting on child expressions that have already been folded, and
<a href="#h8-1-3" id="h8-1-3" class="d">-    // to reduce the quadratic cost when an expression contains a field.
</a><a href="#h8-1-4" id="h8-1-4" class="i">+    // to reduce the quadratic cost when an expression contains a column.
</a>     node.transform(&amp;|n| n.transform_expressions(&amp;Ok, &amp;transform), &amp;Ok)
 }
 
<a href="#h8-2" id="h8-2" class="h">@@ -123,7 +123,7 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         for expr in cnf {
             let (mut ref_left, mut ref_right) = (false, false);
             expr.walk(&amp;mut |e| {
<a href="#h8-2-3" id="h8-2-3" class="d">-                if let Expression::Field(index) = e {
</a><a href="#h8-2-4" id="h8-2-4" class="i">+                if let Expression::Column(index) = e {
</a>                     ref_left = ref_left || *index &lt; left.size();
                     ref_right = ref_right || *index &gt;= left.size();
                 }
<a href="#h8-3" id="h8-3" class="h">@@ -146,32 +146,32 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         // commonly happens when joining a foreign key (which is indexed) on a
         // primary key, and we want to make use of the foreign key index, e.g.:
         // SELECT m.name, g.name FROM movies m JOIN genres g ON m.genre_id = g.id AND g.id = 7;
<a href="#h8-3-3" id="h8-3-3" class="d">-        let left_lookups: HashMap&lt;usize, usize&gt; = push_left // field → push_left index
</a><a href="#h8-3-4" id="h8-3-4" class="i">+        let left_lookups: HashMap&lt;usize, usize&gt; = push_left // column → push_left index
</a>             .iter()
             .enumerate()
<a href="#h8-3-7" id="h8-3-7" class="d">-            .filter_map(|(i, expr)| expr.is_field_lookup().map(|field| (field, i)))
</a><a href="#h8-3-8" id="h8-3-8" class="i">+            .filter_map(|(i, expr)| expr.is_column_lookup().map(|column| (column, i)))
</a>             .collect();
<a href="#h8-3-10" id="h8-3-10" class="d">-        let right_lookups: HashMap&lt;usize, usize&gt; = push_right // field → push_right index
</a><a href="#h8-3-11" id="h8-3-11" class="i">+        let right_lookups: HashMap&lt;usize, usize&gt; = push_right // column → push_right index
</a>             .iter()
             .enumerate()
<a href="#h8-3-14" id="h8-3-14" class="d">-            .filter_map(|(i, expr)| expr.is_field_lookup().map(|field| (field, i)))
</a><a href="#h8-3-15" id="h8-3-15" class="i">+            .filter_map(|(i, expr)| expr.is_column_lookup().map(|column| (column, i)))
</a>             .collect();
 
         for expr in &amp;predicate {
             // Find equijoins.
             let Expression::Equal(lhs, rhs) = expr else { continue };
<a href="#h8-3-21" id="h8-3-21" class="d">-            let Expression::Field(l) = lhs.as_ref() else { continue };
</a><a href="#h8-3-22" id="h8-3-22" class="d">-            let Expression::Field(r) = rhs.as_ref() else { continue };
</a><a href="#h8-3-23" id="h8-3-23" class="i">+            let Expression::Column(l) = lhs.as_ref() else { continue };
</a><a href="#h8-3-24" id="h8-3-24" class="i">+            let Expression::Column(r) = rhs.as_ref() else { continue };
</a> 
             // The lhs may be a reference to the right source; swap them.
             let (l, r) = if l &gt; r { (r, l) } else { (l, r) };
 
<a href="#h8-3-29" id="h8-3-29" class="d">-            // Check if either side is a field lookup, and copy it over.
</a><a href="#h8-3-30" id="h8-3-30" class="i">+            // Check if either side is a column lookup, and copy it over.
</a>             if let Some(expr) = left_lookups.get(l).map(|i| push_left[*i].clone()) {
<a href="#h8-3-32" id="h8-3-32" class="d">-                push_right.push(expr.replace_field(*l, *r));
</a><a href="#h8-3-33" id="h8-3-33" class="i">+                push_right.push(expr.replace_column(*l, *r));
</a>             }
             if let Some(expr) = right_lookups.get(r).map(|i| push_right[*i].clone()) {
<a href="#h8-3-36" id="h8-3-36" class="d">-                push_left.push(expr.replace_field(*r, *l));
</a><a href="#h8-3-37" id="h8-3-37" class="i">+                push_left.push(expr.replace_column(*r, *l));
</a>             }
         }
 
<a href="#h8-4" id="h8-4" class="h">@@ -184,11 +184,11 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         }
 
         if let Some(mut expr) = Expression::and_vec(push_right) {
<a href="#h8-4-3" id="h8-4-3" class="d">-            // Right fields have indexes in the joined row; shift them left.
</a><a href="#h8-4-4" id="h8-4-4" class="d">-            expr = expr.shift_field(-(left.size() as isize));
</a><a href="#h8-4-5" id="h8-4-5" class="i">+            // Right columns have indexes in the joined row; shift them left.
</a><a href="#h8-4-6" id="h8-4-6" class="i">+            expr = expr.shift_column(-(left.size() as isize));
</a>             if let Some(mut expr) = push_into(expr, &amp;mut right) {
<a href="#h8-4-8" id="h8-4-8" class="d">-                // Pushdown failed, undo the field index shift.
</a><a href="#h8-4-9" id="h8-4-9" class="d">-                expr = expr.shift_field(left.size() as isize);
</a><a href="#h8-4-10" id="h8-4-10" class="i">+                // Pushdown failed, undo the column index shift.
</a><a href="#h8-4-11" id="h8-4-11" class="i">+                expr = expr.shift_column(left.size() as isize);
</a>                 predicate.push(expr)
             }
         }
<a href="#h8-5" id="h8-5" class="h">@@ -222,7 +222,7 @@ pub(super) fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a>         // Find the first expression that&#39;s either a primary key or secondary
         // index lookup. We could be more clever here, but this is fine.
         let Some(i) = cnf.iter().enumerate().find_map(|(i, e)| {
<a href="#h8-5-3" id="h8-5-3" class="d">-            e.is_field_lookup()
</a><a href="#h8-5-4" id="h8-5-4" class="i">+            e.is_column_lookup()
</a>                 .filter(|f| *f == table.primary_key || table.columns[*f].index)
                 .and(Some(i))
         }) else {
<a href="#h8-6" id="h8-6" class="h">@@ -230,7 +230,7 @@ pub(super) fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a>         };
 
         // Extract the lookup values and expression from the cnf vector.
<a href="#h8-6-3" id="h8-6-3" class="d">-        let (column, values) = cnf.remove(i).into_field_values().expect(&quot;field lookup failed&quot;);
</a><a href="#h8-6-4" id="h8-6-4" class="i">+        let (column, values) = cnf.remove(i).into_column_values().expect(&quot;column lookup failed&quot;);
</a> 
         // Build the primary key or secondary index lookup node.
         if column == table.primary_key {
<a href="#h8-7" id="h8-7" class="h">@@ -249,7 +249,7 @@ pub(super) fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a>     node.transform(&amp;Ok, &amp;|n| Ok(transform(n)))
 }
 
<a href="#h8-7-3" id="h8-7-3" class="d">-/// Uses a hash join instead of a nested loop join for single-field equijoins.
</a><a href="#h8-7-4" id="h8-7-4" class="i">+/// Uses a hash join instead of a nested loop join for single-column equijoins.
</a> pub(super) fn join_type(node: Node) -&gt; Result&lt;Node&gt; {
     let transform = |node| match node {
         // We could use a single match if we had deref patterns, but alas.
<a href="#h8-8" id="h8-8" class="h">@@ -259,16 +259,16 @@ pub(super) fn join_type(node: Node) -&gt; Result&lt;Node&gt; {
</a>             predicate: Some(Expression::Equal(lhs, rhs)),
             outer,
         } =&gt; match (*lhs, *rhs) {
<a href="#h8-8-3" id="h8-8-3" class="d">-            (Expression::Field(mut left_field), Expression::Field(mut right_field)) =&gt; {
</a><a href="#h8-8-4" id="h8-8-4" class="d">-                // The LHS field may be a field in the right table; swap them.
</a><a href="#h8-8-5" id="h8-8-5" class="d">-                if right_field &lt; left_field {
</a><a href="#h8-8-6" id="h8-8-6" class="d">-                    (left_field, right_field) = (right_field, left_field);
</a><a href="#h8-8-7" id="h8-8-7" class="i">+            (Expression::Column(mut left_column), Expression::Column(mut right_column)) =&gt; {
</a><a href="#h8-8-8" id="h8-8-8" class="i">+                // The LHS column may be a column in the right table; swap them.
</a><a href="#h8-8-9" id="h8-8-9" class="i">+                if right_column &lt; left_column {
</a><a href="#h8-8-10" id="h8-8-10" class="i">+                    (left_column, right_column) = (right_column, left_column);
</a>                 }
<a href="#h8-8-12" id="h8-8-12" class="d">-                // The NestedLoopJoin predicate uses field indexes in the joined
</a><a href="#h8-8-13" id="h8-8-13" class="d">-                // row, while the HashJoin uses field indexes for each table
</a><a href="#h8-8-14" id="h8-8-14" class="d">-                // individually. Adjust the RHS field reference.
</a><a href="#h8-8-15" id="h8-8-15" class="d">-                right_field -= left.size();
</a><a href="#h8-8-16" id="h8-8-16" class="d">-                Node::HashJoin { left, left_field, right, right_field, outer }
</a><a href="#h8-8-17" id="h8-8-17" class="i">+                // The NestedLoopJoin predicate uses column indexes in the
</a><a href="#h8-8-18" id="h8-8-18" class="i">+                // joined row, while the HashJoin uses column indexes for each
</a><a href="#h8-8-19" id="h8-8-19" class="i">+                // table individually. Adjust the RHS column reference.
</a><a href="#h8-8-20" id="h8-8-20" class="i">+                right_column -= left.size();
</a><a href="#h8-8-21" id="h8-8-21" class="i">+                Node::HashJoin { left, left_column, right, right_column, outer }
</a>             }
             (lhs, rhs) =&gt; {
                 let predicate = Some(Expression::Equal(lhs.into(), rhs.into()));
<a href="#h8-9" id="h8-9" class="h">@@ -342,7 +342,7 @@ pub(super) fn short_circuit(node: Node) -&gt; Result&lt;Node&gt; {
</a>                 &amp;&amp; expressions
                     .iter()
                     .enumerate()
<a href="#h8-9-3" id="h8-9-3" class="d">-                    .all(|(i, e)| matches!(e, Expression::Field(f) if i == *f)) =&gt;
</a><a href="#h8-9-4" id="h8-9-4" class="i">+                    .all(|(i, e)| matches!(e, Expression::Column(f) if i == *f)) =&gt;
</a>         {
             *source
         }
<b>diff --git a/<a id="h9" href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a> b/<a href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -82,15 +82,15 @@ pub enum Node {
</a>     /// Filters source rows, by only emitting rows for which the predicate
     /// evaluates to true.
     Filter { source: Box&lt;Node&gt;, predicate: Expression },
<a href="#h9-0-3" id="h9-0-3" class="d">-    /// Joins the left and right sources on the given fields by building an
</a><a href="#h9-0-4" id="h9-0-4" class="i">+    /// Joins the left and right sources on the given columns by building an
</a>     /// in-memory hashmap of the right source and looking up matches for each
     /// row in the left source. When outer is true (e.g. LEFT JOIN), a left row
     /// without a right match is emitted anyway, with NULLs for the right row.
     HashJoin {
         left: Box&lt;Node&gt;,
<a href="#h9-0-10" id="h9-0-10" class="d">-        left_field: usize,
</a><a href="#h9-0-11" id="h9-0-11" class="i">+        left_column: usize,
</a>         right: Box&lt;Node&gt;,
<a href="#h9-0-13" id="h9-0-13" class="d">-        right_field: usize,
</a><a href="#h9-0-14" id="h9-0-14" class="i">+        right_column: usize,
</a>         outer: bool,
     },
     /// Looks up the given values in a secondary index and emits matching rows.
<a href="#h9-1" id="h9-1" class="h">@@ -149,11 +149,11 @@ impl Node {
</a>             Self::Filter { source, predicate } =&gt; {
                 Self::Filter { source: transform(source)?, predicate }
             }
<a href="#h9-1-3" id="h9-1-3" class="d">-            Self::HashJoin { left, left_field, right, right_field, outer } =&gt; Self::HashJoin {
</a><a href="#h9-1-4" id="h9-1-4" class="i">+            Self::HashJoin { left, left_column, right, right_column, outer } =&gt; Self::HashJoin {
</a>                 left: transform(left)?,
<a href="#h9-1-6" id="h9-1-6" class="d">-                left_field,
</a><a href="#h9-1-7" id="h9-1-7" class="i">+                left_column,
</a>                 right: transform(right)?,
<a href="#h9-1-9" id="h9-1-9" class="d">-                right_field,
</a><a href="#h9-1-10" id="h9-1-10" class="i">+                right_column,
</a>                 outer,
             },
             Self::Limit { source, limit } =&gt; Self::Limit { source: transform(source)?, limit },
<a href="#h9-2" id="h9-2" class="h">@@ -252,13 +252,13 @@ impl Node {
</a>             // Some nodes rearrange columns. Route them to the correct
             // upstream column where appropriate.
             Self::Aggregate { source, group_by, .. } =&gt; match group_by.get(index) {
<a href="#h9-2-3" id="h9-2-3" class="d">-                Some(Expression::Field(index)) =&gt; source.column_label(*index),
</a><a href="#h9-2-4" id="h9-2-4" class="i">+                Some(Expression::Column(index)) =&gt; source.column_label(*index),
</a>                 Some(_) | None =&gt; Label::None,
             },
             Self::Projection { source, expressions, aliases } =&gt; match aliases.get(index) {
                 Some(Label::None) | None =&gt; match expressions.get(index) {
<a href="#h9-2-9" id="h9-2-9" class="d">-                    // Unaliased field references route to the source.
</a><a href="#h9-2-10" id="h9-2-10" class="d">-                    Some(Expression::Field(index)) =&gt; source.column_label(*index),
</a><a href="#h9-2-11" id="h9-2-11" class="i">+                    // Unaliased column references route to the source.
</a><a href="#h9-2-12" id="h9-2-12" class="i">+                    Some(Expression::Column(index)) =&gt; source.column_label(*index),
</a>                     // Unaliased expressions don&#39;t have a name.
                     Some(_) | None =&gt; Label::None,
                 },
<a href="#h9-3" id="h9-3" class="h">@@ -403,14 +403,14 @@ impl Node {
</a>                 write!(f, &quot;Filter: {}&quot;, predicate.format(source))?;
                 source.format(f, prefix, false, true)?;
             }
<a href="#h9-3-3" id="h9-3-3" class="d">-            Self::HashJoin { left, left_field, right, right_field, outer } =&gt; {
</a><a href="#h9-3-4" id="h9-3-4" class="i">+            Self::HashJoin { left, left_column, right, right_column, outer } =&gt; {
</a>                 let kind = if *outer { &quot;outer&quot; } else { &quot;inner&quot; };
<a href="#h9-3-6" id="h9-3-6" class="d">-                let left_label = match left.column_label(*left_field) {
</a><a href="#h9-3-7" id="h9-3-7" class="d">-                    Label::None =&gt; format!(&quot;left #{left_field}&quot;),
</a><a href="#h9-3-8" id="h9-3-8" class="i">+                let left_label = match left.column_label(*left_column) {
</a><a href="#h9-3-9" id="h9-3-9" class="i">+                    Label::None =&gt; format!(&quot;left #{left_column}&quot;),
</a>                     label =&gt; format!(&quot;{label}&quot;),
                 };
<a href="#h9-3-12" id="h9-3-12" class="d">-                let right_label = match right.column_label(*right_field) {
</a><a href="#h9-3-13" id="h9-3-13" class="d">-                    Label::None =&gt; format!(&quot;right #{right_field}&quot;),
</a><a href="#h9-3-14" id="h9-3-14" class="i">+                let right_label = match right.column_label(*right_column) {
</a><a href="#h9-3-15" id="h9-3-15" class="i">+                    Label::None =&gt; format!(&quot;right #{right_column}&quot;),
</a>                     label =&gt; format!(&quot;{label}&quot;),
                 };
                 write!(f, &quot;HashJoin: {kind} on {left_label} = {right_label}&quot;)?;
<b>diff --git a/<a id="h10" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -414,7 +414,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         aggregates
     }
 
<a href="#h10-0-3" id="h10-0-3" class="d">-    /// Builds hidden columns for a projection to pass through fields that are
</a><a href="#h10-0-4" id="h10-0-4" class="i">+    /// Builds hidden columns for a projection to pass through columns that are
</a>     /// used by downstream nodes. Consider e.g.:
     ///
     /// SELECT id FROM table ORDER BY value
<a href="#h10-1" id="h10-1" class="h">@@ -440,13 +440,13 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 if let Some(index) = scope.lookup_aggregate(expr) {
                     if child_scope.lookup_aggregate(expr).is_none() {
                         child_scope.add_passthrough(scope, index, true);
<a href="#h10-1-3" id="h10-1-3" class="d">-                        hidden.push(Expression::Field(index));
</a><a href="#h10-1-4" id="h10-1-4" class="i">+                        hidden.push(Expression::Column(index));
</a>                         return true;
                     }
                 }
 
<a href="#h10-1-9" id="h10-1-9" class="d">-                // Look for field references that don&#39;t exist post-projection.
</a><a href="#h10-1-10" id="h10-1-10" class="d">-                let ast::Expression::Field(table, column) = expr else {
</a><a href="#h10-1-11" id="h10-1-11" class="i">+                // Look for column references that don&#39;t exist post-projection.
</a><a href="#h10-1-12" id="h10-1-12" class="i">+                let ast::Expression::Column(table, column) = expr else {
</a>                     return true;
                 };
                 if child_scope.lookup_column(table.as_deref(), column).is_ok() {
<a href="#h10-2" id="h10-2" class="h">@@ -459,7 +459,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 };
                 // Add the hidden column to the projection.
                 child_scope.add_passthrough(scope, index, true);
<a href="#h10-2-3" id="h10-2-3" class="d">-                hidden.push(Expression::Field(index));
</a><a href="#h10-2-4" id="h10-2-4" class="i">+                hidden.push(Expression::Column(index));
</a>                 true
             });
         }
<a href="#h10-3" id="h10-3" class="h">@@ -473,7 +473,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         // Look up aggregate functions or GROUP BY expressions. These were added
         // to the parent scope when building the Aggregate node, if any.
         if let Some(index) = scope.lookup_aggregate(&amp;expr) {
<a href="#h10-3-3" id="h10-3-3" class="d">-            return Ok(Field(index));
</a><a href="#h10-3-4" id="h10-3-4" class="i">+            return Ok(Column(index));
</a>         }
 
         // Helper for building a boxed expression.
<a href="#h10-4" id="h10-4" class="h">@@ -489,8 +489,8 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 ast::Literal::Float(f) =&gt; Value::Float(f),
                 ast::Literal::String(s) =&gt; Value::String(s),
             }),
<a href="#h10-4-3" id="h10-4-3" class="d">-            ast::Expression::Field(table, name) =&gt; {
</a><a href="#h10-4-4" id="h10-4-4" class="d">-                Field(scope.lookup_column(table.as_deref(), &amp;name)?)
</a><a href="#h10-4-5" id="h10-4-5" class="i">+            ast::Expression::Column(table, name) =&gt; {
</a><a href="#h10-4-6" id="h10-4-6" class="i">+                Column(scope.lookup_column(table.as_deref(), &amp;name)?)
</a>             }
             // Currently, all functions are aggregates, and processed above.
             // TODO: consider adding some basic functions for fun.
<a href="#h10-5" id="h10-5" class="h">@@ -547,7 +547,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a> /// the plan and used during execution.
 pub struct Scope {
     /// The currently visible columns. If empty, only constant expressions can
<a href="#h10-5-3" id="h10-5-3" class="d">-    /// be used (no field references).
</a><a href="#h10-5-4" id="h10-5-4" class="i">+    /// be used (no column references).
</a>     columns: Vec&lt;Label&gt;,
     /// Index of currently visible tables, by query name (e.g. may be aliased).
     tables: HashSet&lt;String&gt;,
<a href="#h10-6" id="h10-6" class="h">@@ -625,7 +625,7 @@ impl Scope {
</a>     fn lookup_column(&amp;self, table: Option&lt;&amp;str&gt;, name: &amp;str) -&gt; Result&lt;usize&gt; {
         let fmtname = || table.map(|table| format!(&quot;{table}.{name}&quot;)).unwrap_or(name.to_string());
         if self.columns.is_empty() {
<a href="#h10-6-3" id="h10-6-3" class="d">-            return errinput!(&quot;expression must be constant, found field {}&quot;, fmtname());
</a><a href="#h10-6-4" id="h10-6-4" class="i">+            return errinput!(&quot;expression must be constant, found column {}&quot;, fmtname());
</a>         }
         if let Some(table) = table {
             if !self.tables.contains(table) {
<a href="#h10-7" id="h10-7" class="h">@@ -636,17 +636,17 @@ impl Scope {
</a>             }
         } else if let Some(indexes) = self.unqualified.get(name) {
             if indexes.len() &gt; 1 {
<a href="#h10-7-3" id="h10-7-3" class="d">-                return errinput!(&quot;ambiguous field {name}&quot;);
</a><a href="#h10-7-4" id="h10-7-4" class="i">+                return errinput!(&quot;ambiguous column {name}&quot;);
</a>             }
             return Ok(indexes[0]);
         }
         if !self.aggregates.is_empty() {
             return errinput!(
<a href="#h10-7-10" id="h10-7-10" class="d">-                &quot;field {} must be used in an aggregate or GROUP BY expression&quot;,
</a><a href="#h10-7-11" id="h10-7-11" class="i">+                &quot;column {} must be used in an aggregate or GROUP BY expression&quot;,
</a>                 fmtname()
             );
         }
<a href="#h10-7-15" id="h10-7-15" class="d">-        errinput!(&quot;unknown field {}&quot;, fmtname())
</a><a href="#h10-7-16" id="h10-7-16" class="i">+        errinput!(&quot;unknown column {}&quot;, fmtname())
</a>     }
 
     /// Adds an aggregate expression to the scope, returning the new column
<a href="#h10-8" id="h10-8" class="h">@@ -661,7 +661,7 @@ impl Scope {
</a>         // If this is a simple column reference (i.e. GROUP BY foo), pass
         // through the column label from the parent scope for lookups.
         let mut label = Label::None;
<a href="#h10-8-3" id="h10-8-3" class="d">-        if let ast::Expression::Field(table, column) = expr {
</a><a href="#h10-8-4" id="h10-8-4" class="i">+        if let ast::Expression::Column(table, column) = expr {
</a>             // Ignore errors, they will be emitted when building the expression.
             if let Ok(index) = parent.lookup_column(table.as_deref(), column.as_str()) {
                 label = parent.columns[index].clone();
<a href="#h10-9" id="h10-9" class="h">@@ -715,10 +715,10 @@ impl Scope {
</a>     }
 
     /// Projects the scope via the given expressions and aliases, creating a new
<a href="#h10-9-3" id="h10-9-3" class="d">-    /// child scope with one column per expression. These may be a simple field
</a><a href="#h10-9-4" id="h10-9-4" class="i">+    /// child scope with one column per expression. These may be a simple column
</a>     /// reference (e.g. &quot;SELECT a, b FROM table&quot;), which passes through the
     /// corresponding column from the original scope and retains its qualified
<a href="#h10-9-7" id="h10-9-7" class="d">-    /// and unqualified names. Otherwise, for non-trivial field references, a
</a><a href="#h10-9-8" id="h10-9-8" class="i">+    /// and unqualified names. Otherwise, for non-trivial column references, a
</a>     /// new column is created for the expression. Explicit aliases may be given.
     fn project(&amp;self, expressions: &amp;[(ast::Expression, Option&lt;String&gt;)]) -&gt; Self {
         let mut child = self.spawn();
<a href="#h10-10" id="h10-10" class="h">@@ -727,7 +727,7 @@ impl Scope {
</a>             let mut label = Label::None;
             if let Some(alias) = alias {
                 label = Label::Unqualified(alias.clone());
<a href="#h10-10-3" id="h10-10-3" class="d">-            } else if let ast::Expression::Field(table, column) = expr {
</a><a href="#h10-10-4" id="h10-10-4" class="i">+            } else if let ast::Expression::Column(table, column) = expr {
</a>                 // Ignore errors, they will be surfaced by build_expression().
                 if let Ok(index) = self.lookup_column(table.as_deref(), column.as_str()) {
                     label = self.columns[index].clone();
<b>diff --git a/<a id="h11" href="../file/src/sql/testscripts/expressions/literals.html">src/sql/testscripts/expressions/literals</a> b/<a href="../file/src/sql/testscripts/expressions/literals.html">src/sql/testscripts/expressions/literals</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -104,4 +104,4 @@ String(&quot;Try \\n newlines and \\t tabs&quot;)
</a> # a constant expression.
 !&gt; &quot;Hi!&quot;
 ---
<a href="#h11-0-3" id="h11-0-3" class="d">-Error: invalid input: expression must be constant, found field Hi!
</a><a href="#h11-0-4" id="h11-0-4" class="i">+Error: invalid input: expression must be constant, found column Hi!
</a><b>diff --git a/<a id="h12" href="../file/src/sql/testscripts/queries/aggregate.html">src/sql/testscripts/queries/aggregate</a> b/<a href="../file/src/sql/testscripts/queries/aggregate.html">src/sql/testscripts/queries/aggregate</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -226,7 +226,7 @@ Aggregate: count(1), min(1), max(1), sum(1), avg(1)
</a> [plan]!&gt; SELECT id, COUNT(1), MIN(1), MAX(1), SUM(1), AVG(1) FROM test
 ---
 Error: invalid input: unexpected token ,
<a href="#h12-0-3" id="h12-0-3" class="d">-Error: invalid input: field id must be used in an aggregate or GROUP BY expression
</a><a href="#h12-0-4" id="h12-0-4" class="i">+Error: invalid input: column id must be used in an aggregate or GROUP BY expression
</a> 
 # Repeated aggregates work.
 [plan]&gt; SELECT MAX(&quot;int&quot;), MAX(&quot;int&quot;), MAX(&quot;int&quot;) FROM test
<a href="#h12-1" id="h12-1" class="h">@@ -252,4 +252,4 @@ Error: invalid input: aggregate functions can&#39;t be nested
</a> # Can&#39;t mix aggregate and non-aggregate expressions.
 !&gt; SELECT MAX(&quot;int&quot;) - &quot;int&quot; FROM test
 ---
<a href="#h12-1-3" id="h12-1-3" class="d">-Error: invalid input: field int must be used in an aggregate or GROUP BY expression
</a><a href="#h12-1-4" id="h12-1-4" class="i">+Error: invalid input: column int must be used in an aggregate or GROUP BY expression
</a><b>diff --git a/<a id="h13" href="../file/src/sql/testscripts/queries/group_by.html">src/sql/testscripts/queries/group_by</a> b/<a href="../file/src/sql/testscripts/queries/group_by.html">src/sql/testscripts/queries/group_by</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -111,7 +111,7 @@ b
</a> # GROUP BY does not work with SELECT aliases (also the case in e.g. SQL server).
 !&gt; SELECT &quot;group&quot; AS g, COUNT(*) FROM test GROUP BY g
 ---
<a href="#h13-0-3" id="h13-0-3" class="d">-Error: invalid input: unknown field g
</a><a href="#h13-0-4" id="h13-0-4" class="i">+Error: invalid input: unknown column g
</a> 
 [plan]&gt; SELECT &quot;group&quot;, COUNT(*) FROM test AS t GROUP BY t.&quot;group&quot;
 ---
<a href="#h13-1" id="h13-1" class="h">@@ -128,13 +128,13 @@ Error: invalid input: unknown table test
</a> # It errors when there is a non-group column.
 !&gt; SELECT &quot;group&quot;, id FROM test GROUP BY &quot;group&quot;
 ---
<a href="#h13-1-3" id="h13-1-3" class="d">-Error: invalid input: field id must be used in an aggregate or GROUP BY expression
</a><a href="#h13-1-4" id="h13-1-4" class="i">+Error: invalid input: column id must be used in an aggregate or GROUP BY expression
</a> 
 # It errors on unknown tables and columns.
 !&gt; SELECT COUNT(*) FROM test GROUP BY unknown
 !&gt; SELECT COUNT(*) FROM test GROUP BY unknown.id
 ---
<a href="#h13-1-10" id="h13-1-10" class="d">-Error: invalid input: unknown field unknown
</a><a href="#h13-1-11" id="h13-1-11" class="i">+Error: invalid input: unknown column unknown
</a> Error: invalid input: unknown table unknown
 
 # GROUP BY can be arbitrary expressions.
<a href="#h13-2" id="h13-2" class="h">@@ -178,7 +178,7 @@ NULL
</a> # GROUP BY can&#39;t use an aliased expression.
 !&gt; SELECT id % 2 AS mod, COUNT(*) FROM test GROUP BY mod
 ---
<a href="#h13-2-3" id="h13-2-3" class="d">-Error: invalid input: unknown field mod
</a><a href="#h13-2-4" id="h13-2-4" class="i">+Error: invalid input: unknown column mod
</a> 
 # GROUP BY can&#39;t use aggregate functions.
 !&gt; SELECT COUNT(*) FROM test GROUP BY MIN(id)
<a href="#h13-3" id="h13-3" class="h">@@ -218,7 +218,7 @@ Aggregate: t.id % 2, count(TRUE)
</a> # SELECT * requires all columns to be in GROUP BY.
 !&gt; SELECT * FROM test GROUP BY id
 ---
<a href="#h13-3-3" id="h13-3-3" class="d">-Error: invalid input: field test.group must be used in an aggregate or GROUP BY expression
</a><a href="#h13-3-4" id="h13-3-4" class="i">+Error: invalid input: column test.group must be used in an aggregate or GROUP BY expression
</a> 
 [plan]&gt; SELECT * FROM test GROUP BY id, &quot;group&quot;, &quot;bool&quot;, &quot;int&quot;, &quot;float&quot;, &quot;string&quot;
 ---
<b>diff --git a/<a id="h14" href="../file/src/sql/testscripts/queries/having.html">src/sql/testscripts/queries/having</a> b/<a href="../file/src/sql/testscripts/queries/having.html">src/sql/testscripts/queries/having</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -123,7 +123,7 @@ Remap: #0 (dropped: test.group)
</a> ---
 Error: invalid input: aggregate functions can&#39;t be nested
 
<a href="#h14-0-3" id="h14-0-3" class="d">-# Having errors on fields not in the SELECT or GROUP BY clauses.
</a><a href="#h14-0-4" id="h14-0-4" class="i">+# Having errors on columns not in the SELECT or GROUP BY clauses.
</a> !&gt; SELECT &quot;group&quot;, COUNT(*) FROM test GROUP BY &quot;group&quot; HAVING id &gt; 3
 ---
<a href="#h14-0-7" id="h14-0-7" class="d">-Error: invalid input: field id must be used in an aggregate or GROUP BY expression
</a><a href="#h14-0-8" id="h14-0-8" class="i">+Error: invalid input: column id must be used in an aggregate or GROUP BY expression
</a><b>diff --git a/<a id="h15" href="../file/src/sql/testscripts/queries/join_inner.html">src/sql/testscripts/queries/join_inner</a> b/<a href="../file/src/sql/testscripts/queries/join_inner.html">src/sql/testscripts/queries/join_inner</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -210,7 +210,7 @@ Error: invalid input: expected token ON, found WHERE
</a> !&gt; SELECT * FROM movies INNER JOIN genres on movies.unknown_id = genres.id
 ---
 Error: invalid input: table unknown does not exist
<a href="#h15-0-3" id="h15-0-3" class="d">-Error: invalid input: unknown field movies.unknown_id
</a><a href="#h15-0-4" id="h15-0-4" class="i">+Error: invalid input: unknown column movies.unknown_id
</a> 
 # Try a multi-way join with multiple joins of the same table. This will result
 # in expected duplicates due to the cross join. The query finds all movies
<b>diff --git a/<a id="h16" href="../file/src/sql/testscripts/queries/limit.html">src/sql/testscripts/queries/limit</a> b/<a href="../file/src/sql/testscripts/queries/limit.html">src/sql/testscripts/queries/limit</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -62,7 +62,7 @@ Limit: 2
</a> 
 !&gt; SELECT * FROM test LIMIT id
 ---
<a href="#h16-0-3" id="h16-0-3" class="d">-Error: invalid input: expression must be constant, found field id
</a><a href="#h16-0-4" id="h16-0-4" class="i">+Error: invalid input: expression must be constant, found column id
</a> 
 # Negative and NULL limits error.
 !&gt; SELECT * FROM test LIMIT -1
<b>diff --git a/<a id="h17" href="../file/src/sql/testscripts/queries/offset.html">src/sql/testscripts/queries/offset</a> b/<a href="../file/src/sql/testscripts/queries/offset.html">src/sql/testscripts/queries/offset</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -61,7 +61,7 @@ Offset: 1
</a> 
 !&gt; SELECT * FROM test OFFSET id
 ---
<a href="#h17-0-3" id="h17-0-3" class="d">-Error: invalid input: expression must be constant, found field id
</a><a href="#h17-0-4" id="h17-0-4" class="i">+Error: invalid input: expression must be constant, found column id
</a> 
 # Negative and NULL offset error.
 !&gt; SELECT * FROM test OFFSET -1
<b>diff --git a/<a id="h18" href="../file/src/sql/testscripts/queries/order.html">src/sql/testscripts/queries/order</a> b/<a href="../file/src/sql/testscripts/queries/order.html">src/sql/testscripts/queries/order</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -349,10 +349,10 @@ Remap: test.id (dropped: test.float, test.int)
</a> 4, 1000000
 5, 1000000
 
<a href="#h18-0-3" id="h18-0-3" class="d">-# Errors if the field is ambiguous.
</a><a href="#h18-0-4" id="h18-0-4" class="i">+# Errors if the column is ambiguous.
</a> !&gt; SELECT id, &quot;int&quot; ^ 2 AS foo, &quot;int&quot; AS foo FROM test ORDER BY foo ASC
 ---
<a href="#h18-0-7" id="h18-0-7" class="d">-Error: invalid input: ambiguous field foo
</a><a href="#h18-0-8" id="h18-0-8" class="i">+Error: invalid input: ambiguous column foo
</a> 
 # Prefers alias over table column if ambiguous, but not if fully qualified.
 [plan]&gt; SELECT id AS &quot;int&quot; FROM test ORDER BY &quot;int&quot; DESC
<a href="#h18-1" id="h18-1" class="h">@@ -394,8 +394,8 @@ Remap: int (dropped: test.int)
</a> !&gt; SELECT * FROM test ORDER BY unknown.id
 !&gt; SELECT * FROM test AS t ORDER BY test.&quot;int&quot;
 ---
<a href="#h18-1-3" id="h18-1-3" class="d">-Error: invalid input: unknown field unknown
</a><a href="#h18-1-4" id="h18-1-4" class="d">-Error: invalid input: unknown field test.unknown
</a><a href="#h18-1-5" id="h18-1-5" class="i">+Error: invalid input: unknown column unknown
</a><a href="#h18-1-6" id="h18-1-6" class="i">+Error: invalid input: unknown column test.unknown
</a> Error: invalid input: unknown table unknown
 Error: invalid input: unknown table test
 
<a href="#h18-2" id="h18-2" class="h">@@ -409,12 +409,12 @@ Error: invalid input: unexpected token unknown
</a> ---
 Error: invalid input: unexpected end of input
 
<a href="#h18-2-3" id="h18-2-3" class="d">-# Errors on ambiguous fields.
</a><a href="#h18-2-4" id="h18-2-4" class="i">+# Errors on ambiguous columns.
</a> !&gt; SELECT * FROM test, other ORDER BY id DESC
 ---
<a href="#h18-2-7" id="h18-2-7" class="d">-Error: invalid input: ambiguous field id
</a><a href="#h18-2-8" id="h18-2-8" class="i">+Error: invalid input: ambiguous column id
</a> 
<a href="#h18-2-10" id="h18-2-10" class="d">-# Works with qualified fields, even when aliased.
</a><a href="#h18-2-11" id="h18-2-11" class="i">+# Works with qualified columns, even when aliased.
</a> [plan]&gt; SELECT * FROM test, other ORDER BY other.id DESC
 ---
 Order: other.id desc
<a href="#h18-3" id="h18-3" class="h">@@ -534,7 +534,7 @@ Remap: #0 (dropped: test.bool)
</a> 1
 1
 
<a href="#h18-3-3" id="h18-3-3" class="d">-# ORDER BY errors on fields not in the SELECT or GROUP BY clauses.
</a><a href="#h18-3-4" id="h18-3-4" class="i">+# ORDER BY errors on columns not in the SELECT or GROUP BY clauses.
</a> !&gt; SELECT &quot;bool&quot;, COUNT(*) FROM test GROUP BY &quot;bool&quot; ORDER BY id
 ---
<a href="#h18-3-7" id="h18-3-7" class="d">-Error: invalid input: field id must be used in an aggregate or GROUP BY expression
</a><a href="#h18-3-8" id="h18-3-8" class="i">+Error: invalid input: column id must be used in an aggregate or GROUP BY expression
</a><b>diff --git a/<a id="h19" href="../file/src/sql/testscripts/queries/select.html">src/sql/testscripts/queries/select</a> b/<a href="../file/src/sql/testscripts/queries/select.html">src/sql/testscripts/queries/select</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -1,6 +1,6 @@
</a> # Tests the SELECT part of queries.
 
<a href="#h19-0-2" id="h19-0-2" class="d">-# Create a basic test table, and a secondary table for join field lookups.
</a><a href="#h19-0-3" id="h19-0-3" class="i">+# Create a basic test table, and a secondary table for join column lookups.
</a> &gt; CREATE TABLE test ( \
     id INT PRIMARY KEY, \
     &quot;bool&quot; BOOLEAN, \
<a href="#h19-1" id="h19-1" class="h">@@ -37,7 +37,7 @@ NULL, TRUE, 5, 6.28, Hi 👋
</a> ---
 Error: invalid input: unexpected end of input
 Error: invalid input: unexpected end of input
<a href="#h19-1-3" id="h19-1-3" class="d">-Error: invalid input: expression must be constant, found field foo
</a><a href="#h19-1-4" id="h19-1-4" class="i">+Error: invalid input: expression must be constant, found column foo
</a> 
 # Select from a table.
 [plan,header]&gt; SELECT * FROM test
<a href="#h19-2" id="h19-2" class="h">@@ -64,7 +64,7 @@ NULL
</a> Error: invalid input: SELECT * requires a FROM clause
 Error: invalid input: unexpected end of input
 
<a href="#h19-2-3" id="h19-2-3" class="d">-# Mix fields, field expressions, and constant expressions.
</a><a href="#h19-2-4" id="h19-2-4" class="i">+# Mix columns, column expressions, and constant expressions.
</a> [plan,header]&gt; SELECT id, 7-4, &quot;float&quot;^2 FROM test
 ---
 Projection: test.id, 3, test.float ^ 2
<a href="#h19-3" id="h19-3" class="h">@@ -109,8 +109,8 @@ t.id, t.bool
</a> !&gt; SELECT test.id FROM test AS t
 ---
 Error: invalid input: table unknown does not exist
<a href="#h19-3-3" id="h19-3-3" class="d">-Error: invalid input: unknown field unknown
</a><a href="#h19-3-4" id="h19-3-4" class="d">-Error: invalid input: unknown field test.unknown
</a><a href="#h19-3-5" id="h19-3-5" class="i">+Error: invalid input: unknown column unknown
</a><a href="#h19-3-6" id="h19-3-6" class="i">+Error: invalid input: unknown column test.unknown
</a> Error: invalid input: unexpected token .
 Error: invalid input: unknown table unknown
 Error: invalid input: unknown table test
<a href="#h19-4" id="h19-4" class="h">@@ -136,8 +136,8 @@ integer, hi 👋
</a> !&gt; SELECT 1 AS one, one + 1
 !&gt; SELECT id AS alias, alias + 1 FROM test
 ---
<a href="#h19-4-3" id="h19-4-3" class="d">-Error: invalid input: expression must be constant, found field one
</a><a href="#h19-4-4" id="h19-4-4" class="d">-Error: invalid input: unknown field alias
</a><a href="#h19-4-5" id="h19-4-5" class="i">+Error: invalid input: expression must be constant, found column one
</a><a href="#h19-4-6" id="h19-4-6" class="i">+Error: invalid input: unknown column alias
</a> 
 # Aliases can have the same name as table columns, but won&#39;t shadow them.
 [header]&gt; SELECT &#39;foo&#39; AS id, id, id + 3 FROM test
<a href="#h19-5" id="h19-5" class="h">@@ -167,12 +167,12 @@ Error: invalid input: unexpected token .
</a> Error: invalid input: unexpected end of input
 Error: invalid input: unexpected token AS
 
<a href="#h19-5-3" id="h19-5-3" class="d">-# Ambiguous fields error.
</a><a href="#h19-5-4" id="h19-5-4" class="i">+# Ambiguous columns error.
</a> !&gt; SELECT id FROM test, other
 ---
<a href="#h19-5-7" id="h19-5-7" class="d">-Error: invalid input: ambiguous field id
</a><a href="#h19-5-8" id="h19-5-8" class="i">+Error: invalid input: ambiguous column id
</a> 
<a href="#h19-5-10" id="h19-5-10" class="d">-# Unambiguous fields don&#39;t, resulting in a cross join.
</a><a href="#h19-5-11" id="h19-5-11" class="i">+# Unambiguous columns don&#39;t, resulting in a cross join.
</a> &gt; SELECT &quot;bool&quot;, value FROM test, other
 ---
 TRUE, a
<a href="#h19-6" id="h19-6" class="h">@@ -182,7 +182,7 @@ FALSE, b
</a> NULL, a
 NULL, b
 
<a href="#h19-6-3" id="h19-6-3" class="d">-# Qualified fields work, also when aliased.
</a><a href="#h19-6-4" id="h19-6-4" class="i">+# Qualified columns work, also when aliased.
</a> &gt; SELECT test.id, other.id FROM test, other
 ---
 1, 1
<b>diff --git a/<a id="h20" href="../file/src/sql/testscripts/queries/where_.html">src/sql/testscripts/queries/where_</a> b/<a href="../file/src/sql/testscripts/queries/where_.html">src/sql/testscripts/queries/where_</a></b>
<a href="#h20-0" id="h20-0" class="h">@@ -53,11 +53,11 @@ Error: invalid input: filter returned , expected boolean
</a> Error: invalid input: unexpected end of input
 Error: invalid input: unexpected token ,
 
<a href="#h20-0-3" id="h20-0-3" class="d">-# Errors on unknown tables and fields.
</a><a href="#h20-0-4" id="h20-0-4" class="i">+# Errors on unknown tables and columns.
</a> !&gt; SELECT * FROM test WHERE unknown &gt; 0
 !&gt; SELECT * FROM test WHERE unknown.id &gt; 0
 ---
<a href="#h20-0-8" id="h20-0-8" class="d">-Error: invalid input: unknown field unknown
</a><a href="#h20-0-9" id="h20-0-9" class="i">+Error: invalid input: unknown column unknown
</a> Error: invalid input: unknown table unknown
 
 # Qualified names are valid.
<a href="#h20-1" id="h20-1" class="h">@@ -69,27 +69,27 @@ Error: invalid input: unknown table unknown
</a> !&gt; SELECT value AS v FROM test WHERE v = &#39;b&#39;
 !&gt; SELECT 1 + 1 AS two WHERE two = 2
 ---
<a href="#h20-1-3" id="h20-1-3" class="d">-Error: invalid input: unknown field v
</a><a href="#h20-1-4" id="h20-1-4" class="d">-Error: invalid input: expression must be constant, found field two
</a><a href="#h20-1-5" id="h20-1-5" class="i">+Error: invalid input: unknown column v
</a><a href="#h20-1-6" id="h20-1-6" class="i">+Error: invalid input: expression must be constant, found column two
</a> 
 # Table aliases are visible.
 &gt; SELECT * FROM test AS t WHERE t.id = 2
 ---
 2, b
 
<a href="#h20-1-13" id="h20-1-13" class="d">-# Ambiguous fields error.
</a><a href="#h20-1-14" id="h20-1-14" class="i">+# Ambiguous columns error.
</a> !&gt; SELECT * FROM test, other WHERE id &gt; 1
 ---
<a href="#h20-1-17" id="h20-1-17" class="d">-Error: invalid input: ambiguous field id
</a><a href="#h20-1-18" id="h20-1-18" class="i">+Error: invalid input: ambiguous column id
</a> 
<a href="#h20-1-20" id="h20-1-20" class="d">-# Unambiguous fields work.
</a><a href="#h20-1-21" id="h20-1-21" class="i">+# Unambiguous columns work.
</a> &gt; SELECT * FROM test, other WHERE value = &#39;b&#39;
 ---
 2, b, 1, FALSE
 2, b, 2, TRUE
 
 
<a href="#h20-1-28" id="h20-1-28" class="d">-# Qualified fields work, also when aliased.
</a><a href="#h20-1-29" id="h20-1-29" class="i">+# Qualified columns work, also when aliased.
</a> &gt; SELECT * FROM test, other WHERE test.id = 2 AND other.id = 2
 ---
 2, b, 2, TRUE
<b>diff --git a/<a id="h21" href="../file/src/sql/testscripts/writes/delete_where.html">src/sql/testscripts/writes/delete_where</a> b/<a href="../file/src/sql/testscripts/writes/delete_where.html">src/sql/testscripts/writes/delete_where</a></b>
<a href="#h21-0" id="h21-0" class="h">@@ -102,4 +102,4 @@ Error: invalid input: unexpected end of input
</a> # Missing column errors.
 !&gt; DELETE FROM name WHERE missing = &#39;foo&#39;
 ---
<a href="#h21-0-3" id="h21-0-3" class="d">-Error: invalid input: unknown field missing
</a><a href="#h21-0-4" id="h21-0-4" class="i">+Error: invalid input: unknown column missing
</a><b>diff --git a/<a id="h22" href="../file/src/sql/testscripts/writes/insert.html">src/sql/testscripts/writes/insert</a> b/<a href="../file/src/sql/testscripts/writes/insert.html">src/sql/testscripts/writes/insert</a></b>
<a href="#h22-0" id="h22-0" class="h">@@ -64,7 +64,7 @@ mvcc:Version(sql:Row(name, 4), 3) → 4,&quot;d&quot; [&quot;\x04\x02name\x00\xff\x00\xff\x02\x
</a> 
 !&gt; INSERT INTO name VALUES (id + 2, &#39;abc&#39;)
 ---
<a href="#h22-0-3" id="h22-0-3" class="d">-Error: invalid input: expression must be constant, found field id
</a><a href="#h22-0-4" id="h22-0-4" class="i">+Error: invalid input: expression must be constant, found column id
</a> 
 # INSERTs with too many columns errors. Fewer are tested by insert_default.
 !&gt; INSERT INTO name VALUES (6, &#39;e&#39;, NULL)
<b>diff --git a/<a id="h23" href="../file/src/sql/testscripts/writes/update.html">src/sql/testscripts/writes/update</a> b/<a href="../file/src/sql/testscripts/writes/update.html">src/sql/testscripts/writes/update</a></b>
<a href="#h23-0" id="h23-0" class="h">@@ -51,7 +51,7 @@ Error: invalid input: unexpected end of input
</a> !&gt; UPDATE name SET foo = &#39;bar&#39;
 ---
 Error: invalid input: table foo does not exist
<a href="#h23-0-3" id="h23-0-3" class="d">-Error: invalid input: unknown field foo
</a><a href="#h23-0-4" id="h23-0-4" class="i">+Error: invalid input: unknown column foo
</a> 
 # Specifying the same column multiple times errors.
 !&gt; UPDATE name SET value = &#39;e&#39;, value = &#39;f&#39;
<b>diff --git a/<a id="h24" href="../file/src/sql/testscripts/writes/update_index.html">src/sql/testscripts/writes/update_index</a> b/<a href="../file/src/sql/testscripts/writes/update_index.html">src/sql/testscripts/writes/update_index</a></b>
<a href="#h24-0" id="h24-0" class="h">@@ -45,7 +45,7 @@ storage delete mvcc:TxnWrite(3, sql:Index(index.string, &quot;foo&quot;)) [&quot;\x03\x00\x00\x
</a> storage delete mvcc:TxnWrite(3, sql:Row(index, 1)) [&quot;\x03\x00\x00\x00\x00\x00\x00\x00\x03\x02index\x00\xff\x00\xff\x02\x80\x00\xff\x00\xff\x00\xff\x00\xff\x00\xff\x00\xff\x01\x00\x00&quot;]
 storage delete mvcc:TxnActive(3) [&quot;\x01\x00\x00\x00\x00\x00\x00\x00\x03&quot;]
 
<a href="#h24-0-3" id="h24-0-3" class="d">-# A single-field update only updates the relevant index.
</a><a href="#h24-0-4" id="h24-0-4" class="i">+# A single-column update only updates the relevant index.
</a> [ops]&gt; UPDATE &quot;index&quot; SET &quot;bool&quot; = TRUE
 ---
 storage set mvcc:NextVersion → 5 [&quot;\x00&quot; → &quot;\x05&quot;]
<b>diff --git a/<a id="h25" href="../file/src/sql/testscripts/writes/update_null.html">src/sql/testscripts/writes/update_null</a> b/<a href="../file/src/sql/testscripts/writes/update_null.html">src/sql/testscripts/writes/update_null</a></b>
<a href="#h25-0" id="h25-0" class="h">@@ -21,4 +21,4 @@ ok
</a> !&gt; UPDATE name SET non_null = NULL
 ---
 Error: invalid input: invalid primary key NULL
<a href="#h25-0-3" id="h25-0-3" class="d">-Error: invalid input: unknown field non_null
</a><a href="#h25-0-4" id="h25-0-4" class="i">+Error: invalid input: unknown column non_null
</a><b>diff --git a/<a id="h26" href="../file/src/sql/testscripts/writes/update_where.html">src/sql/testscripts/writes/update_where</a> b/<a href="../file/src/sql/testscripts/writes/update_where.html">src/sql/testscripts/writes/update_where</a></b>
<a href="#h26-0" id="h26-0" class="h">@@ -105,4 +105,4 @@ Error: invalid input: unexpected end of input
</a> # Missing column errors.
 !&gt; UPDATE name SET value = &#39;foo&#39; WHERE missing = &#39;foo&#39;
 ---
<a href="#h26-0-3" id="h26-0-3" class="d">-Error: invalid input: unknown field missing
</a><a href="#h26-0-4" id="h26-0-4" class="i">+Error: invalid input: unknown column missing
</a><b>diff --git a/<a id="h27" href="../file/src/sql/types/expression.rs.html">src/sql/types/expression.rs</a> b/<a href="../file/src/sql/types/expression.rs.html">src/sql/types/expression.rs</a></b>
<a href="#h27-0" id="h27-0" class="h">@@ -6,7 +6,7 @@ use crate::sql::planner::Node;
</a> use serde::{Deserialize, Serialize};
 
 /// An expression, made up of nested values and operators. Values can either be
<a href="#h27-0-3" id="h27-0-3" class="d">-/// constants or row field references.
</a><a href="#h27-0-4" id="h27-0-4" class="i">+/// constants or row column references.
</a> ///
 /// Since this is a recursive data structure, we have to box each child
 /// expression, which incurs a heap allocation. There are clever ways to get
<a href="#h27-1" id="h27-1" class="h">@@ -15,8 +15,8 @@ use serde::{Deserialize, Serialize};
</a> pub enum Expression {
     /// A constant value.
     Constant(Value),
<a href="#h27-1-3" id="h27-1-3" class="d">-    /// A field reference (row index).
</a><a href="#h27-1-4" id="h27-1-4" class="d">-    Field(usize),
</a><a href="#h27-1-5" id="h27-1-5" class="i">+    /// A column reference. Used as row index when evaluating expressions.
</a><a href="#h27-1-6" id="h27-1-6" class="i">+    Column(usize),
</a> 
     /// Logical AND of two booleans: a AND b.
     And(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
<a href="#h27-2" id="h27-2" class="h">@@ -64,7 +64,7 @@ impl Expression {
</a>     pub fn format(&amp;self, node: &amp;Node) -&gt; String {
         let format = |expr: &amp;Expression| expr.format(node);
         match self {
<a href="#h27-2-3" id="h27-2-3" class="d">-            Self::Field(index) =&gt; match node.column_label(*index) {
</a><a href="#h27-2-4" id="h27-2-4" class="i">+            Self::Column(index) =&gt; match node.column_label(*index) {
</a>                 Label::None =&gt; format!(&quot;#{index}&quot;),
                 label =&gt; format!(&quot;{label}&quot;),
             },
<a href="#h27-3" id="h27-3" class="h">@@ -94,18 +94,19 @@ impl Expression {
</a>         }
     }
 
<a href="#h27-3-3" id="h27-3-3" class="d">-    /// Evaluates an expression, returning a value. If a row is given, Field
</a><a href="#h27-3-4" id="h27-3-4" class="d">-    /// references will look up the row value at the field index. If no row is
</a><a href="#h27-3-5" id="h27-3-5" class="d">-    /// given, any field references yield NULL.
</a><a href="#h27-3-6" id="h27-3-6" class="i">+    /// Evaluates an expression, returning a value. If a row is given, Column
</a><a href="#h27-3-7" id="h27-3-7" class="i">+    /// references will look up the row value at the column index. If no row is
</a><a href="#h27-3-8" id="h27-3-8" class="i">+    /// given, any column references yield NULL.
</a>     pub fn evaluate(&amp;self, row: Option&lt;&amp;Row&gt;) -&gt; Result&lt;Value&gt; {
         use Value::*;
         Ok(match self {
             // Constant values return itself.
             Self::Constant(value) =&gt; value.clone(),
 
<a href="#h27-3-15" id="h27-3-15" class="d">-            // Field references look up a row value. The planner must make sure
</a><a href="#h27-3-16" id="h27-3-16" class="d">-            // the field reference is valid.
</a><a href="#h27-3-17" id="h27-3-17" class="d">-            Self::Field(i) =&gt; row.map(|row| row[*i].clone()).unwrap_or(Null),
</a><a href="#h27-3-18" id="h27-3-18" class="i">+            // Column references look up a row value. The planner must make sure
</a><a href="#h27-3-19" id="h27-3-19" class="i">+            // the column reference is valid.
</a><a href="#h27-3-20" id="h27-3-20" class="i">+            // TODO: error instead.
</a><a href="#h27-3-21" id="h27-3-21" class="i">+            Self::Column(i) =&gt; row.map(|row| row[*i].clone()).unwrap_or(Null),
</a> 
             // Logical AND. Inputs must be boolean or NULL. NULLs generally
             // yield NULL, except the special case NULL AND false == false.
<a href="#h27-4" id="h27-4" class="h">@@ -242,7 +243,7 @@ impl Expression {
</a>                 | Self::Negate(expr)
                 | Self::Not(expr) =&gt; expr.walk(visitor),
 
<a href="#h27-4-3" id="h27-4-3" class="d">-                Self::Constant(_) | Self::Field(_) =&gt; true,
</a><a href="#h27-4-4" id="h27-4-4" class="i">+                Self::Constant(_) | Self::Column(_) =&gt; true,
</a>             }
     }
 
<a href="#h27-5" id="h27-5" class="h">@@ -288,7 +289,7 @@ impl Expression {
</a>             Self::Negate(expr) =&gt; Self::Negate(transform(expr)?),
             Self::Not(expr) =&gt; Self::Not(transform(expr)?),
 
<a href="#h27-5-3" id="h27-5-3" class="d">-            expr @ (Self::Constant(_) | Self::Field(_)) =&gt; expr,
</a><a href="#h27-5-4" id="h27-5-4" class="i">+            expr @ (Self::Constant(_) | Self::Column(_)) =&gt; expr,
</a>         };
         self = after(self)?;
         Ok(self)
<a href="#h27-6" id="h27-6" class="h">@@ -361,26 +362,27 @@ impl Expression {
</a>         Some(expr)
     }
 
<a href="#h27-6-3" id="h27-6-3" class="d">-    /// Checks if an expression is a single field lookup (i.e. a disjunction of
</a><a href="#h27-6-4" id="h27-6-4" class="d">-    /// = or IS NULL/NAN referencing a single field), returning the field index.
</a><a href="#h27-6-5" id="h27-6-5" class="d">-    pub fn is_field_lookup(&amp;self) -&gt; Option&lt;usize&gt; {
</a><a href="#h27-6-6" id="h27-6-6" class="i">+    /// Checks if an expression is a single column lookup (i.e. a disjunction of
</a><a href="#h27-6-7" id="h27-6-7" class="i">+    /// = or IS NULL/NAN referencing a single column), returning the column
</a><a href="#h27-6-8" id="h27-6-8" class="i">+    /// index.
</a><a href="#h27-6-9" id="h27-6-9" class="i">+    pub fn is_column_lookup(&amp;self) -&gt; Option&lt;usize&gt; {
</a>         use Expression::*;
         match &amp;self {
<a href="#h27-6-12" id="h27-6-12" class="d">-            // Equality comparisons with = between field and constant value can
</a><a href="#h27-6-13" id="h27-6-13" class="i">+            // Equality comparisons with = between column and constant value can
</a>             // use index lookups. NULL and NaN won&#39;t return any matches, but we
<a href="#h27-6-15" id="h27-6-15" class="d">-            // handle this in into_field_values().
</a><a href="#h27-6-16" id="h27-6-16" class="i">+            // handle this in into_column_values().
</a>             Equal(lhs, rhs) =&gt; match (lhs.as_ref(), rhs.as_ref()) {
<a href="#h27-6-18" id="h27-6-18" class="d">-                (Field(f), Constant(_)) | (Constant(_), Field(f)) =&gt; Some(*f),
</a><a href="#h27-6-19" id="h27-6-19" class="i">+                (Column(f), Constant(_)) | (Constant(_), Column(f)) =&gt; Some(*f),
</a>                 _ =&gt; None,
             },
             // IS NULL and IS NAN can use index lookups, since we index these.
             IsNull(expr) | IsNaN(expr) =&gt; match expr.as_ref() {
<a href="#h27-6-24" id="h27-6-24" class="d">-                Field(f) =&gt; Some(*f),
</a><a href="#h27-6-25" id="h27-6-25" class="i">+                Column(f) =&gt; Some(*f),
</a>                 _ =&gt; None,
             },
             // For OR branches, check if all branches are lookups on the same
<a href="#h27-6-29" id="h27-6-29" class="d">-            // field, i.e. foo = 1 OR foo = 2 OR foo = 3.
</a><a href="#h27-6-30" id="h27-6-30" class="d">-            Or(lhs, rhs) =&gt; match (lhs.is_field_lookup(), rhs.is_field_lookup()) {
</a><a href="#h27-6-31" id="h27-6-31" class="i">+            // column, i.e. foo = 1 OR foo = 2 OR foo = 3.
</a><a href="#h27-6-32" id="h27-6-32" class="i">+            Or(lhs, rhs) =&gt; match (lhs.is_column_lookup(), rhs.is_column_lookup()) {
</a>                 (Some(l), Some(r)) if l == r =&gt; Some(l),
                 _ =&gt; None,
             },
<a href="#h27-7" id="h27-7" class="h">@@ -388,31 +390,31 @@ impl Expression {
</a>         }
     }
 
<a href="#h27-7-3" id="h27-7-3" class="d">-    /// Converts the expression into a set of single-field lookup values if possible.
</a><a href="#h27-7-4" id="h27-7-4" class="d">-    pub fn into_field_values(self) -&gt; Option&lt;(usize, Vec&lt;Value&gt;)&gt; {
</a><a href="#h27-7-5" id="h27-7-5" class="i">+    /// Converts the expression into a set of single-column lookup values if possible.
</a><a href="#h27-7-6" id="h27-7-6" class="i">+    pub fn into_column_values(self) -&gt; Option&lt;(usize, Vec&lt;Value&gt;)&gt; {
</a>         use Expression::*;
         match self {
             Equal(lhs, rhs) =&gt; match (*lhs, *rhs) {
                 // NULL and NAN index lookups are for IS NULL and IS NAN.
                 // Equality comparisons with = shouldn&#39;t yield any results, so
                 // just return an empty value set for these.
<a href="#h27-7-13" id="h27-7-13" class="d">-                (Field(f), Constant(v)) | (Constant(v), Field(f)) if v.is_undefined() =&gt; {
</a><a href="#h27-7-14" id="h27-7-14" class="i">+                (Column(f), Constant(v)) | (Constant(v), Column(f)) if v.is_undefined() =&gt; {
</a>                     Some((f, Vec::new()))
                 }
<a href="#h27-7-17" id="h27-7-17" class="d">-                (Field(f), Constant(v)) | (Constant(v), Field(f)) =&gt; Some((f, vec![v])),
</a><a href="#h27-7-18" id="h27-7-18" class="i">+                (Column(f), Constant(v)) | (Constant(v), Column(f)) =&gt; Some((f, vec![v])),
</a>                 _ =&gt; None,
             },
             // IS NULL index lookups should look up NULL.
             IsNull(expr) =&gt; match *expr {
<a href="#h27-7-23" id="h27-7-23" class="d">-                Field(f) =&gt; Some((f, vec![Value::Null])),
</a><a href="#h27-7-24" id="h27-7-24" class="i">+                Column(f) =&gt; Some((f, vec![Value::Null])),
</a>                 _ =&gt; None,
             },
             // IS NAN index lookups should look up NAN.
             IsNaN(expr) =&gt; match *expr {
<a href="#h27-7-29" id="h27-7-29" class="d">-                Field(f) =&gt; Some((f, vec![Value::Float(f64::NAN)])),
</a><a href="#h27-7-30" id="h27-7-30" class="i">+                Column(f) =&gt; Some((f, vec![Value::Float(f64::NAN)])),
</a>                 _ =&gt; None,
             },
<a href="#h27-7-33" id="h27-7-33" class="d">-            Or(lhs, rhs) =&gt; match (lhs.into_field_values(), rhs.into_field_values()) {
</a><a href="#h27-7-34" id="h27-7-34" class="i">+            Or(lhs, rhs) =&gt; match (lhs.into_column_values(), rhs.into_column_values()) {
</a>                 (Some((l, lvec)), Some((r, rvec))) if l == r =&gt; {
                     Some((l, lvec.into_iter().chain(rvec).collect()))
                 }
<a href="#h27-8" id="h27-8" class="h">@@ -422,19 +424,19 @@ impl Expression {
</a>         }
     }
 
<a href="#h27-8-3" id="h27-8-3" class="d">-    /// Replaces field references with the given field.
</a><a href="#h27-8-4" id="h27-8-4" class="d">-    pub fn replace_field(self, from: usize, to: usize) -&gt; Self {
</a><a href="#h27-8-5" id="h27-8-5" class="i">+    /// Replaces column references with the given column.
</a><a href="#h27-8-6" id="h27-8-6" class="i">+    pub fn replace_column(self, from: usize, to: usize) -&gt; Self {
</a>         let transform = |expr| match expr {
<a href="#h27-8-8" id="h27-8-8" class="d">-            Expression::Field(i) if i == from =&gt; Expression::Field(to),
</a><a href="#h27-8-9" id="h27-8-9" class="i">+            Expression::Column(i) if i == from =&gt; Expression::Column(to),
</a>             expr =&gt; expr,
         };
         self.transform(&amp;|e| Ok(transform(e)), &amp;Ok).unwrap() // infallible
     }
 
<a href="#h27-8-15" id="h27-8-15" class="d">-    /// Shifts any field indexes by the given amount.
</a><a href="#h27-8-16" id="h27-8-16" class="d">-    pub fn shift_field(self, diff: isize) -&gt; Self {
</a><a href="#h27-8-17" id="h27-8-17" class="i">+    /// Shifts any column indexes by the given amount.
</a><a href="#h27-8-18" id="h27-8-18" class="i">+    pub fn shift_column(self, diff: isize) -&gt; Self {
</a>         let transform = |expr| match expr {
<a href="#h27-8-20" id="h27-8-20" class="d">-            Expression::Field(i) =&gt; Expression::Field((i as isize + diff) as usize),
</a><a href="#h27-8-21" id="h27-8-21" class="i">+            Expression::Column(i) =&gt; Expression::Column((i as isize + diff) as usize),
</a>             expr =&gt; expr,
         };
         self.transform(&amp;|e| Ok(transform(e)), &amp;Ok).unwrap() // infallible
<b>diff --git a/<a id="h28" href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a> b/<a href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a></b>
<a href="#h28-0" id="h28-0" class="h">@@ -405,11 +405,11 @@ impl Label {
</a> }
 
 impl From&lt;Label&gt; for ast::Expression {
<a href="#h28-0-3" id="h28-0-3" class="d">-    /// Builds an ast::Expression::Field for a label. Can&#39;t be None.
</a><a href="#h28-0-4" id="h28-0-4" class="i">+    /// Builds an ast::Expression::Column for a label. Can&#39;t be None.
</a>     fn from(label: Label) -&gt; Self {
         match label {
<a href="#h28-0-7" id="h28-0-7" class="d">-            Label::Qualified(table, column) =&gt; ast::Expression::Field(Some(table), column),
</a><a href="#h28-0-8" id="h28-0-8" class="d">-            Label::Unqualified(column) =&gt; ast::Expression::Field(None, column),
</a><a href="#h28-0-9" id="h28-0-9" class="i">+            Label::Qualified(table, column) =&gt; ast::Expression::Column(Some(table), column),
</a><a href="#h28-0-10" id="h28-0-10" class="i">+            Label::Unqualified(column) =&gt; ast::Expression::Column(None, column),
</a>             Label::None =&gt; panic!(&quot;can&#39;t convert None label to AST expression&quot;), // shouldn&#39;t happen
         }
     }
<b>diff --git a/<a id="h29" href="../file/tests/e2e/client.rs.html">tests/e2e/client.rs</a> b/<a href="../file/tests/e2e/client.rs.html">tests/e2e/client.rs</a></b>
<a href="#h29-0" id="h29-0" class="h">@@ -225,7 +225,7 @@ fn execute() -&gt; Result&lt;()&gt; {
</a>     );
     assert_eq!(
         c.execute(&quot;DELETE FROM genres WHERE x = 1&quot;),
<a href="#h29-0-3" id="h29-0-3" class="d">-        Err(Error::InvalidInput(&quot;unknown field x&quot;.into()))
</a><a href="#h29-0-4" id="h29-0-4" class="i">+        Err(Error::InvalidInput(&quot;unknown column x&quot;.into()))
</a>     );
 
     Ok(())
</pre>
</div>
</body>
</html>
