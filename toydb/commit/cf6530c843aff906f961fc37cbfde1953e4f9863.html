<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>raft: use new goldenscript argument consumer in tests - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/cf6530c843aff906f961fc37cbfde1953e4f9863.html">cf6530c843aff906f961fc37cbfde1953e4f9863</a>
<b>parent</b> <a href="../commit/98e31e82b6a47fd13a02239f0d782a6656cb83b5.html">98e31e82b6a47fd13a02239f0d782a6656cb83b5</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue, 28 May 2024 19:52:52 +0200

raft: use new goldenscript argument consumer in tests

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">Cargo.lock</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">Cargo.toml</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/node.rs</a></td><td> | </td><td class="num">106</td><td><span class="i">++++++++++++++++++++++++++</span><span class="d">-----------------------------------------------------</span></td></tr>
</table></pre><pre>3 files changed, 37 insertions(+), 75 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/Cargo.lock.html">Cargo.lock</a> b/<a href="../file/Cargo.lock.html">Cargo.lock</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -614,9 +614,9 @@ dependencies = [
</a> 
 [[package]]
 name = &quot;goldenscript&quot;
<a href="#h0-0-3" id="h0-0-3" class="d">-version = &quot;0.3.0&quot;
</a><a href="#h0-0-4" id="h0-0-4" class="i">+version = &quot;0.4.0&quot;
</a> source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
<a href="#h0-0-6" id="h0-0-6" class="d">-checksum = &quot;0169ef881fb6dd6578ee6de31fca3bd5f6827bdb65980ab00d73288fedfecebb&quot;
</a><a href="#h0-0-7" id="h0-0-7" class="i">+checksum = &quot;a26382869e4845509917e9412b56ccb1c8061bee0cd965710a73c071b6d567d6&quot;
</a> dependencies = [
  &quot;goldenfile&quot;,
  &quot;nom&quot;,
<b>diff --git a/<a id="h1" href="../file/Cargo.toml.html">Cargo.toml</a> b/<a href="../file/Cargo.toml.html">Cargo.toml</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -34,7 +34,7 @@ uuid = { version = &quot;1.8.0&quot;, features = [&quot;v4&quot;] }
</a> [dev-dependencies]
 escargot = &quot;0.5.10&quot;
 goldenfile = &quot;1.7.1&quot;
<a href="#h1-0-3" id="h1-0-3" class="d">-goldenscript = &quot;0.3.0&quot;
</a><a href="#h1-0-4" id="h1-0-4" class="i">+goldenscript = &quot;0.4.0&quot;
</a> paste = &quot;1.0.14&quot;
 pretty_assertions = &quot;1.4.0&quot;
 serde_json = &quot;1.0.117&quot;
<b>diff --git a/<a id="h2" href="../file/src/raft/node.rs.html">src/raft/node.rs</a> b/<a href="../file/src/raft/node.rs.html">src/raft/node.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1180,19 +1180,15 @@ mod tests {
</a>                 //
                 // Creates a new Raft cluster.
                 &quot;cluster&quot; =&gt; {
<a href="#h2-0-3" id="h2-0-3" class="d">-                    let mut nodes = 0;
</a><a href="#h2-0-4" id="h2-0-4" class="d">-                    let mut leader = None;
</a><a href="#h2-0-5" id="h2-0-5" class="d">-                    let mut heartbeat_interval = HEARTBEAT_INTERVAL;
</a><a href="#h2-0-6" id="h2-0-6" class="d">-                    let mut election_timeout = ELECTION_TIMEOUT_RANGE.start;
</a><a href="#h2-0-7" id="h2-0-7" class="d">-                    for arg in &amp;command.args {
</a><a href="#h2-0-8" id="h2-0-8" class="d">-                        match arg.key.as_deref() {
</a><a href="#h2-0-9" id="h2-0-9" class="d">-                            Some(&quot;election_timeout&quot;) =&gt; election_timeout = arg.parse()?,
</a><a href="#h2-0-10" id="h2-0-10" class="d">-                            Some(&quot;heartbeat_interval&quot;) =&gt; heartbeat_interval = arg.parse()?,
</a><a href="#h2-0-11" id="h2-0-11" class="d">-                            Some(&quot;leader&quot;) =&gt; leader = Some(arg.parse()?),
</a><a href="#h2-0-12" id="h2-0-12" class="d">-                            Some(&quot;nodes&quot;) =&gt; nodes = arg.parse()?,
</a><a href="#h2-0-13" id="h2-0-13" class="d">-                            _ =&gt; return Err(format!(&quot;invalid argument &#39;{}&#39;&quot;, arg.name()).into()),
</a><a href="#h2-0-14" id="h2-0-14" class="d">-                        }
</a><a href="#h2-0-15" id="h2-0-15" class="d">-                    }
</a><a href="#h2-0-16" id="h2-0-16" class="i">+                    let mut args = command.consume_args();
</a><a href="#h2-0-17" id="h2-0-17" class="i">+                    let nodes = args.lookup_parse(&quot;nodes&quot;)?.unwrap_or(0);
</a><a href="#h2-0-18" id="h2-0-18" class="i">+                    let leader = args.lookup_parse(&quot;leader&quot;)?;
</a><a href="#h2-0-19" id="h2-0-19" class="i">+                    let heartbeat_interval =
</a><a href="#h2-0-20" id="h2-0-20" class="i">+                        args.lookup_parse(&quot;heartbeat_interval&quot;)?.unwrap_or(HEARTBEAT_INTERVAL);
</a><a href="#h2-0-21" id="h2-0-21" class="i">+                    let election_timeout = args
</a><a href="#h2-0-22" id="h2-0-22" class="i">+                        .lookup_parse(&quot;election_timeout&quot;)?
</a><a href="#h2-0-23" id="h2-0-23" class="i">+                        .unwrap_or(ELECTION_TIMEOUT_RANGE.start);
</a><a href="#h2-0-24" id="h2-0-24" class="i">+                    args.reject_rest()?;
</a>                     self.cluster(nodes, leader, heartbeat_interval, election_timeout, &amp;mut output)?;
                 }
 
<a href="#h2-1" id="h2-1" class="h">@@ -1202,14 +1198,9 @@ mod tests {
</a>                 // is given, only messages from the given node is delivered, the
                 // others are left pending.
                 &quot;deliver&quot; =&gt; {
<a href="#h2-1-3" id="h2-1-3" class="d">-                    let ids = self.parse_ids_or_all(&amp;command.pos_args())?;
</a><a href="#h2-1-4" id="h2-1-4" class="d">-                    let mut from = None;
</a><a href="#h2-1-5" id="h2-1-5" class="d">-                    for arg in command.key_args() {
</a><a href="#h2-1-6" id="h2-1-6" class="d">-                        match arg.key.as_deref().unwrap() {
</a><a href="#h2-1-7" id="h2-1-7" class="d">-                            &quot;from&quot; =&gt; from = Some(arg.parse()?),
</a><a href="#h2-1-8" id="h2-1-8" class="d">-                            key =&gt; return Err(format!(&quot;invalid argument &#39;{key}&#39;&quot;).into()),
</a><a href="#h2-1-9" id="h2-1-9" class="d">-                        }
</a><a href="#h2-1-10" id="h2-1-10" class="d">-                    }
</a><a href="#h2-1-11" id="h2-1-11" class="i">+                    let mut args = command.consume_args();
</a><a href="#h2-1-12" id="h2-1-12" class="i">+                    let from = args.lookup_parse(&quot;from&quot;)?;
</a><a href="#h2-1-13" id="h2-1-13" class="i">+                    let ids = self.parse_ids_or_all(&amp;args.rest())?;
</a>                     self.deliver(&amp;ids, from, &amp;mut output)?;
                 }
 
<a href="#h2-2" id="h2-2" class="h">@@ -1218,11 +1209,10 @@ mod tests {
</a>                 // Sends a client request to the given node to read the given
                 // key from the state machine (key/value store).
                 &quot;get&quot; =&gt; {
<a href="#h2-2-3" id="h2-2-3" class="d">-                    self.reject_args(&amp;command.key_args())?;
</a><a href="#h2-2-4" id="h2-2-4" class="d">-                    let mut args = command.pos_args().into_iter();
</a><a href="#h2-2-5" id="h2-2-5" class="d">-                    let id = args.next().ok_or(&quot;must specify node ID&quot;)?.parse()?;
</a><a href="#h2-2-6" id="h2-2-6" class="d">-                    let key = args.next().ok_or(&quot;must specify key&quot;)?.value.clone();
</a><a href="#h2-2-7" id="h2-2-7" class="d">-                    self.reject_args(&amp;args.collect_vec())?;
</a><a href="#h2-2-8" id="h2-2-8" class="i">+                    let mut args = command.consume_args();
</a><a href="#h2-2-9" id="h2-2-9" class="i">+                    let id = args.next_pos().ok_or(&quot;must specify node ID&quot;)?.parse()?;
</a><a href="#h2-2-10" id="h2-2-10" class="i">+                    let key = args.next_pos().ok_or(&quot;must specify key&quot;)?.value.clone();
</a><a href="#h2-2-11" id="h2-2-11" class="i">+                    args.reject_rest()?;
</a>                     let request = Request::Read(TestCommand::Get { key }.encode()?);
                     self.request(id, request, &amp;mut output)?;
                 }
<a href="#h2-3" id="h2-3" class="h">@@ -1266,12 +1256,11 @@ mod tests {
</a>                 // Sends a client request to the given node to write a key/value
                 // pair to the state machine (key/value store).
                 &quot;put&quot; =&gt; {
<a href="#h2-3-3" id="h2-3-3" class="d">-                    let mut args = command.args.iter();
</a><a href="#h2-3-4" id="h2-3-4" class="d">-                    let id = args.next().ok_or(&quot;must specify node ID&quot;)?.parse()?;
</a><a href="#h2-3-5" id="h2-3-5" class="d">-                    let kv = args.next().ok_or(&quot;must specify key/value pair&quot;)?;
</a><a href="#h2-3-6" id="h2-3-6" class="d">-                    let key = kv.key.clone().ok_or(&quot;must specify key/value pair&quot;)?;
</a><a href="#h2-3-7" id="h2-3-7" class="d">-                    let value = kv.value.clone();
</a><a href="#h2-3-8" id="h2-3-8" class="d">-                    self.reject_args(&amp;args.collect_vec())?;
</a><a href="#h2-3-9" id="h2-3-9" class="i">+                    let mut args = command.consume_args();
</a><a href="#h2-3-10" id="h2-3-10" class="i">+                    let id = args.next_pos().ok_or(&quot;must specify node ID&quot;)?.parse()?;
</a><a href="#h2-3-11" id="h2-3-11" class="i">+                    let kv = args.next_key().ok_or(&quot;must specify key/value pair&quot;)?.clone();
</a><a href="#h2-3-12" id="h2-3-12" class="i">+                    let (key, value) = (kv.key.unwrap(), kv.value);
</a><a href="#h2-3-13" id="h2-3-13" class="i">+                    args.reject_rest()?;
</a>                     let request = Request::Write(TestCommand::Put { key, value }.encode()?);
                     self.request(id, request, &amp;mut output)?;
                 }
<a href="#h2-4" id="h2-4" class="h">@@ -1283,14 +1272,9 @@ mod tests {
</a>                 // emits a heartbeat from the leader and restabilizes, e.g. to
                 // propagate the commit index.
                 &quot;stabilize&quot; =&gt; {
<a href="#h2-4-3" id="h2-4-3" class="d">-                    let ids = self.parse_ids_or_all(&amp;command.pos_args())?;
</a><a href="#h2-4-4" id="h2-4-4" class="d">-                    let mut heartbeat = false;
</a><a href="#h2-4-5" id="h2-4-5" class="d">-                    for arg in command.key_args() {
</a><a href="#h2-4-6" id="h2-4-6" class="d">-                        match arg.key.as_deref().unwrap() {
</a><a href="#h2-4-7" id="h2-4-7" class="d">-                            &quot;heartbeat&quot; =&gt; heartbeat = arg.parse()?,
</a><a href="#h2-4-8" id="h2-4-8" class="d">-                            key =&gt; return Err(format!(&quot;invalid argument &#39;{key}&#39;&quot;).into()),
</a><a href="#h2-4-9" id="h2-4-9" class="d">-                        }
</a><a href="#h2-4-10" id="h2-4-10" class="d">-                    }
</a><a href="#h2-4-11" id="h2-4-11" class="i">+                    let mut args = command.consume_args();
</a><a href="#h2-4-12" id="h2-4-12" class="i">+                    let heartbeat = args.lookup_parse(&quot;heartbeat&quot;)?.unwrap_or(false);
</a><a href="#h2-4-13" id="h2-4-13" class="i">+                    let ids = self.parse_ids_or_all(&amp;args.rest())?;
</a>                     self.stabilize(&amp;ids, heartbeat, &amp;mut output)?;
                 }
 
<a href="#h2-5" id="h2-5" class="h">@@ -1308,14 +1292,9 @@ mod tests {
</a>                 // is true, sends a status client request to a single node,
                 // otherwise fetches status directly from each node.
                 &quot;status&quot; =&gt; {
<a href="#h2-5-3" id="h2-5-3" class="d">-                    let ids = self.parse_ids_or_all(&amp;command.pos_args())?;
</a><a href="#h2-5-4" id="h2-5-4" class="d">-                    let mut request = false;
</a><a href="#h2-5-5" id="h2-5-5" class="d">-                    for arg in command.key_args() {
</a><a href="#h2-5-6" id="h2-5-6" class="d">-                        match arg.key.as_deref().unwrap() {
</a><a href="#h2-5-7" id="h2-5-7" class="d">-                            &quot;request&quot; =&gt; request = arg.parse()?,
</a><a href="#h2-5-8" id="h2-5-8" class="d">-                            key =&gt; return Err(format!(&quot;invalid argument &#39;{key}&#39;&quot;).into()),
</a><a href="#h2-5-9" id="h2-5-9" class="d">-                        }
</a><a href="#h2-5-10" id="h2-5-10" class="d">-                    }
</a><a href="#h2-5-11" id="h2-5-11" class="i">+                    let mut args = command.consume_args();
</a><a href="#h2-5-12" id="h2-5-12" class="i">+                    let request = args.lookup_parse(&quot;request&quot;)?.unwrap_or(false);
</a><a href="#h2-5-13" id="h2-5-13" class="i">+                    let ids = self.parse_ids_or_all(&amp;args.rest())?;
</a>                     if request {
                         if ids.len() != 1 {
                             return Err(&quot;request=true requires 1 node ID&quot;.into());
<a href="#h2-6" id="h2-6" class="h">@@ -1326,22 +1305,16 @@ mod tests {
</a>                     }
                 }
 
<a href="#h2-6-3" id="h2-6-3" class="d">-                // step ID JSON
</a><a href="#h2-6-4" id="h2-6-4" class="i">+                // step [panic=BOOL] ID JSON
</a>                 //
                 // Steps a manually generated JSON message on the given node.
                 &quot;step&quot; =&gt; {
<a href="#h2-6-8" id="h2-6-8" class="d">-                    let mut pos_args = command.pos_args().into_iter();
</a><a href="#h2-6-9" id="h2-6-9" class="d">-                    let id = pos_args.next().ok_or(&quot;node ID not given&quot;)?.parse()?;
</a><a href="#h2-6-10" id="h2-6-10" class="d">-                    let raw = pos_args.next().ok_or(&quot;message not given&quot;)?.value.clone();
</a><a href="#h2-6-11" id="h2-6-11" class="d">-                    let msg = serde_json::from_str(&amp;raw)?;
</a><a href="#h2-6-12" id="h2-6-12" class="d">-                    self.reject_args(&amp;pos_args.collect_vec())?;
</a><a href="#h2-6-13" id="h2-6-13" class="d">-                    let mut panic = false;
</a><a href="#h2-6-14" id="h2-6-14" class="d">-                    for arg in command.key_args() {
</a><a href="#h2-6-15" id="h2-6-15" class="d">-                        match arg.key.as_deref().unwrap() {
</a><a href="#h2-6-16" id="h2-6-16" class="d">-                            &quot;panic&quot; =&gt; panic = arg.parse()?,
</a><a href="#h2-6-17" id="h2-6-17" class="d">-                            key =&gt; return Err(format!(&quot;unknown key &#39;{key}&#39;&quot;).into()),
</a><a href="#h2-6-18" id="h2-6-18" class="d">-                        }
</a><a href="#h2-6-19" id="h2-6-19" class="d">-                    }
</a><a href="#h2-6-20" id="h2-6-20" class="i">+                    let mut args = command.consume_args();
</a><a href="#h2-6-21" id="h2-6-21" class="i">+                    let panic = args.lookup_parse(&quot;panic&quot;)?.unwrap_or(false);
</a><a href="#h2-6-22" id="h2-6-22" class="i">+                    let id = args.next_pos().ok_or(&quot;node ID not given&quot;)?.parse()?;
</a><a href="#h2-6-23" id="h2-6-23" class="i">+                    let raw = &amp;args.next_pos().ok_or(&quot;message not given&quot;)?.value;
</a><a href="#h2-6-24" id="h2-6-24" class="i">+                    let msg = serde_json::from_str(raw)?;
</a><a href="#h2-6-25" id="h2-6-25" class="i">+                    args.reject_rest()?;
</a>                     self.transition_catch(id, |n| n.step(msg), panic, &amp;mut output)?;
                 }
 
<a href="#h2-7" id="h2-7" class="h">@@ -1807,17 +1780,6 @@ mod tests {
</a>             Ok(ids)
         }
 
<a href="#h2-7-3" id="h2-7-3" class="d">-        // Errors if any arguments are passed.
</a><a href="#h2-7-4" id="h2-7-4" class="d">-        fn reject_args&lt;A&gt;(&amp;self, args: &amp;[A]) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;
</a><a href="#h2-7-5" id="h2-7-5" class="d">-        where
</a><a href="#h2-7-6" id="h2-7-6" class="d">-            A: Borrow&lt;goldenscript::Argument&gt;,
</a><a href="#h2-7-7" id="h2-7-7" class="d">-        {
</a><a href="#h2-7-8" id="h2-7-8" class="d">-            if let Some(arg) = args.first().map(|a| a.borrow()) {
</a><a href="#h2-7-9" id="h2-7-9" class="d">-                return Err(format!(&quot;unexpected argument &#39;{}&#39;&quot;, arg.name()).into());
</a><a href="#h2-7-10" id="h2-7-10" class="d">-            }
</a><a href="#h2-7-11" id="h2-7-11" class="d">-            Ok(())
</a><a href="#h2-7-12" id="h2-7-12" class="d">-        }
</a><a href="#h2-7-13" id="h2-7-13" class="d">-
</a>         /// Formats network partitions.
         fn format_disconnected(disconnected: &amp;HashMap&lt;NodeID, HashSet&lt;NodeID&gt;&gt;) -&gt; String {
             // Return early if the cluster is fully connected.
</pre>
</div>
</body>
</html>
