<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: make `Rows` clonable, and use it with nested loop joins - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/36c6e989849220c401b585808f4e5eefd083af80.html">36c6e989849220c401b585808f4e5eefd083af80</a>
<b>parent</b> <a href="../commit/b01161e7f96e660d4dbe77b2ad21bcae82559c00.html">b01161e7f96e660d4dbe77b2ad21bcae82559c00</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue,  9 Jul 2024 21:26:31 +0200

sql: make `Rows` clonable, and use it with nested loop joins

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">Cargo.lock</a></td><td> | </td><td class="num">7</td><td><span class="i">+++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">Cargo.toml</a></td><td> | </td><td class="num">1</td><td><span class="i">+</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/execution/aggregate.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/execution/join.rs</a></td><td> | </td><td class="num">22</td><td><span class="i">++++++++</span><span class="d">--------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/types/value.rs</a></td><td> | </td><td class="num">11</td><td><span class="i">++++++++++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/storage/mvcc.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++++++++</span><span class="d"></span></td></tr>
</table></pre><pre>6 files changed, 43 insertions(+), 16 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/Cargo.lock.html">Cargo.lock</a> b/<a href="../file/Cargo.lock.html">Cargo.lock</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -408,6 +408,12 @@ dependencies = [
</a> ]
 
 [[package]]
<a href="#h0-0-3" id="h0-0-3" class="i">+name = &quot;dyn-clone&quot;
</a><a href="#h0-0-4" id="h0-0-4" class="i">+version = &quot;1.0.17&quot;
</a><a href="#h0-0-5" id="h0-0-5" class="i">+source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-0-6" id="h0-0-6" class="i">+checksum = &quot;0d6ef0072f8a535281e4876be788938b528e9a1d43900b82c2569af7da799125&quot;
</a><a href="#h0-0-7" id="h0-0-7" class="i">+
</a><a href="#h0-0-8" id="h0-0-8" class="i">+[[package]]
</a> name = &quot;either&quot;
 version = &quot;1.11.0&quot;
 source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
<a href="#h0-1" id="h0-1" class="h">@@ -1498,6 +1504,7 @@ dependencies = [
</a>  &quot;config&quot;,
  &quot;crossbeam&quot;,
  &quot;derivative&quot;,
<a href="#h0-1-3" id="h0-1-3" class="i">+ &quot;dyn-clone&quot;,
</a>  &quot;escargot&quot;,
  &quot;fs4&quot;,
  &quot;goldenfile&quot;,
<b>diff --git a/<a id="h1" href="../file/Cargo.toml.html">Cargo.toml</a> b/<a href="../file/Cargo.toml.html">Cargo.toml</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -15,6 +15,7 @@ clap = { version = &quot;4.5.4&quot;, features = [&quot;cargo&quot;, &quot;derive&quot;] }
</a> config = &quot;0.14.0&quot;
 crossbeam = { version = &quot;0.8.4&quot;, features = [&quot;crossbeam-channel&quot;] }
 derivative = &quot;2.2.0&quot;
<a href="#h1-0-3" id="h1-0-3" class="i">+dyn-clone = &quot;1.0.17&quot;
</a> fs4 = &quot;0.8.2&quot;
 hdrhistogram = &quot;7.5.4&quot;
 hex = &quot;0.4.3&quot;
<b>diff --git a/<a id="h2" href="../file/src/sql/execution/aggregate.rs.html">src/sql/execution/aggregate.rs</a> b/<a href="../file/src/sql/execution/aggregate.rs.html">src/sql/execution/aggregate.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -2,6 +2,7 @@ use crate::error::Result;
</a> use crate::sql::planner::Aggregate;
 use crate::sql::types::{Row, Rows, Value};
 
<a href="#h2-0-3" id="h2-0-3" class="i">+use itertools::Itertools as _;
</a> use std::collections::BTreeMap;
 
 /// Aggregates rows (i.e. GROUP BY).
<a href="#h2-1" id="h2-1" class="h">@@ -30,7 +31,9 @@ pub(super) fn aggregate(
</a>         accumulators.insert(Vec::new(), aggregates.iter().map(Accumulator::new).collect());
     }
 
<a href="#h2-1-3" id="h2-1-3" class="d">-    // Emit the aggregate and row values for each row bucket.
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    // Emit the aggregate and row values for each row bucket. We use an
</a><a href="#h2-1-5" id="h2-1-5" class="i">+    // intermediate vec since btree_map::IntoIter doesn&#39;t implement Clone.
</a><a href="#h2-1-6" id="h2-1-6" class="i">+    let accumulators = accumulators.into_iter().collect_vec();
</a>     Ok(Box::new(accumulators.into_iter().map(|(row, accs)| {
         accs.into_iter()
             .map(|acc| acc.value())
<a href="#h2-2" id="h2-2" class="h">@@ -41,6 +44,7 @@ pub(super) fn aggregate(
</a> 
 /// Accumulates aggregate values. Uses an enum rather than a trait since we need
 /// to keep these in a vector (could use boxed trait objects too).
<a href="#h2-2-3" id="h2-2-3" class="i">+#[derive(Clone)]
</a> pub enum Accumulator {
     Average { count: i64, sum: Value },
     Count(i64),
<b>diff --git a/<a id="h3" href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a> b/<a href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -26,13 +26,14 @@ pub(super) fn nested_loop(
</a> /// This could be trivially implemented with carthesian_product(), but we need
 /// to handle the left outer join case where there is no match in the right
 /// source.
<a href="#h3-0-3" id="h3-0-3" class="i">+#[derive(Clone)]
</a> struct NestedLoopIterator {
     /// The left source.
     left: Peekable&lt;Rows&gt;,
     /// The right source.
<a href="#h3-0-8" id="h3-0-8" class="d">-    right: std::vec::IntoIter&lt;Row&gt;,
</a><a href="#h3-0-9" id="h3-0-9" class="d">-    /// The buffered right result.
</a><a href="#h3-0-10" id="h3-0-10" class="d">-    right_vec: Vec&lt;Row&gt;,
</a><a href="#h3-0-11" id="h3-0-11" class="i">+    right: Rows,
</a><a href="#h3-0-12" id="h3-0-12" class="i">+    /// The initial right iterator state. Cloned to reset right.
</a><a href="#h3-0-13" id="h3-0-13" class="i">+    right_init: Rows,
</a>     /// The column width of the right source.
     right_size: usize,
     /// True if a right match has been seen for the current left row.
<a href="#h3-1" id="h3-1" class="h">@@ -51,16 +52,9 @@ impl NestedLoopIterator {
</a>         predicate: Option&lt;Expression&gt;,
         outer: bool,
     ) -&gt; Result&lt;Self&gt; {
<a href="#h3-1-3" id="h3-1-3" class="d">-        // Collect the right source into a vector. We could use a borrowing
</a><a href="#h3-1-4" id="h3-1-4" class="d">-        // iterator into the vec instead of cloning an owned iterator, but it
</a><a href="#h3-1-5" id="h3-1-5" class="d">-        // comes with lifetime hassles and we end up cloning each row when
</a><a href="#h3-1-6" id="h3-1-6" class="d">-        // iterating anyway.
</a><a href="#h3-1-7" id="h3-1-7" class="d">-        //
</a><a href="#h3-1-8" id="h3-1-8" class="d">-        // TODO: consider making the iterators clonable.
</a><a href="#h3-1-9" id="h3-1-9" class="d">-        let right_vec = right.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h3-1-10" id="h3-1-10" class="d">-        let right = right_vec.clone().into_iter();
</a>         let left = left.peekable();
<a href="#h3-1-12" id="h3-1-12" class="d">-        Ok(Self { left, right, right_vec, right_size, right_match: false, predicate, outer })
</a><a href="#h3-1-13" id="h3-1-13" class="i">+        let right_init = right.clone();
</a><a href="#h3-1-14" id="h3-1-14" class="i">+        Ok(Self { left, right, right_init, right_size, right_match: false, predicate, outer })
</a>     }
 
     // Returns the next joined row, if any, with error handling.
<a href="#h3-2" id="h3-2" class="h">@@ -68,7 +62,7 @@ impl NestedLoopIterator {
</a>         // While there is a valid left row, look for a right-hand match to return.
         while let Some(Ok(left_row)) = self.left.peek() {
             // If there is a match in the remaining right rows, return it.
<a href="#h3-2-3" id="h3-2-3" class="d">-            for right_row in &amp;mut self.right {
</a><a href="#h3-2-4" id="h3-2-4" class="i">+            while let Some(right_row) = self.right.next().transpose()? {
</a>                 // We could avoid cloning here unless we&#39;re actually emitting
                 // the row, but we keep it simple.
                 let row = left_row.iter().cloned().chain(right_row).collect();
<a href="#h3-3" id="h3-3" class="h">@@ -87,7 +81,7 @@ impl NestedLoopIterator {
</a>             }
 
             // We reached the end of the right source, reset it.
<a href="#h3-3-3" id="h3-3-3" class="d">-            self.right = self.right_vec.clone().into_iter();
</a><a href="#h3-3-4" id="h3-3-4" class="i">+            self.right = self.right_init.clone();
</a> 
             // If there was no match for this row, and this is an outer join,
             // emit a row with right NULLs.
<b>diff --git a/<a id="h4" href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a> b/<a href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -5,6 +5,7 @@ use crate::errdata;
</a> use crate::errinput;
 use crate::error::{Error, Result};
 
<a href="#h4-0-3" id="h4-0-3" class="i">+use dyn_clone::DynClone;
</a> use serde::{Deserialize, Serialize};
 
 /// A primitive data type.
<a href="#h4-1" id="h4-1" class="h">@@ -361,7 +362,15 @@ pub type Row = Vec&lt;Value&gt;;
</a> /// A row iterator.
 ///
 /// TODO: try to avoid boxing here.
<a href="#h4-1-3" id="h4-1-3" class="d">-pub type Rows = Box&lt;dyn Iterator&lt;Item = Result&lt;Row&gt;&gt;&gt;;
</a><a href="#h4-1-4" id="h4-1-4" class="i">+pub type Rows = Box&lt;dyn RowIterator&gt;;
</a><a href="#h4-1-5" id="h4-1-5" class="i">+
</a><a href="#h4-1-6" id="h4-1-6" class="i">+/// A row iterator trait, which requires it to be clonable and object-safe. It
</a><a href="#h4-1-7" id="h4-1-7" class="i">+/// has a blanket implementation for all iterators.
</a><a href="#h4-1-8" id="h4-1-8" class="i">+pub trait RowIterator: Iterator&lt;Item = Result&lt;Row&gt;&gt; + DynClone {}
</a><a href="#h4-1-9" id="h4-1-9" class="i">+
</a><a href="#h4-1-10" id="h4-1-10" class="i">+dyn_clone::clone_trait_object!(RowIterator);
</a><a href="#h4-1-11" id="h4-1-11" class="i">+
</a><a href="#h4-1-12" id="h4-1-12" class="i">+impl&lt;I: Iterator&lt;Item = Result&lt;Row&gt;&gt; + DynClone&gt; RowIterator for I {}
</a> 
 /// A column label, used in result sets and query plans.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
<b>diff --git a/<a id="h5" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -623,6 +623,18 @@ pub struct ScanIterator&lt;E: Engine&gt; {
</a>     remainder: Option&lt;(Bound&lt;RawKey&gt;, Bound&lt;RawKey&gt;)&gt;,
 }
 
<a href="#h5-0-3" id="h5-0-3" class="i">+/// Implement Clone manually. Deriving it requires Engine: Clone.
</a><a href="#h5-0-4" id="h5-0-4" class="i">+impl&lt;E: Engine&gt; Clone for ScanIterator&lt;E&gt; {
</a><a href="#h5-0-5" id="h5-0-5" class="i">+    fn clone(&amp;self) -&gt; Self {
</a><a href="#h5-0-6" id="h5-0-6" class="i">+        Self {
</a><a href="#h5-0-7" id="h5-0-7" class="i">+            engine: self.engine.clone(),
</a><a href="#h5-0-8" id="h5-0-8" class="i">+            txn: self.txn.clone(),
</a><a href="#h5-0-9" id="h5-0-9" class="i">+            buffer: self.buffer.clone(),
</a><a href="#h5-0-10" id="h5-0-10" class="i">+            remainder: self.remainder.clone(),
</a><a href="#h5-0-11" id="h5-0-11" class="i">+        }
</a><a href="#h5-0-12" id="h5-0-12" class="i">+    }
</a><a href="#h5-0-13" id="h5-0-13" class="i">+}
</a><a href="#h5-0-14" id="h5-0-14" class="i">+
</a> // Helper types to distinguish raw engine key/values from encoded user
 // key/values (which are encoded inside mvcc::Key). Mostly to appease Clippy&#39;s
 // type complexity lint, but TODO: consider using elsewhere.
</pre>
</div>
</body>
</html>
