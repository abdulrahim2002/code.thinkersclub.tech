<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>make storage backends configurable - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/2b90ebe5cf1a2f316333eff2565dd52adf484669.html">2b90ebe5cf1a2f316333eff2565dd52adf484669</a>
<b>parent</b> <a href="../commit/7f17d53cb50b926960e283f8d27e0b99962fd403.html">7f17d53cb50b926960e283f8d27e0b99962fd403</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sat, 23 May 2020 12:07:11 +0200

make storage backends configurable

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">README.md</a></td><td> | </td><td class="num">4</td><td><span class="i">+++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">config/toydb.yaml</a></td><td> | </td><td class="num">21</td><td><span class="i">+++++++++++++++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/bin/toydb.rs</a></td><td> | </td><td class="num">23</td><td><span class="i">++++++++++++++++++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/bin/toysql.rs</a></td><td> | </td><td class="num">9</td><td><span class="i">++++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/log.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">++++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/raft/node/follower.rs</a></td><td> | </td><td class="num">20</td><td><span class="i">++++++++++</span><span class="d">----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/raft/node/leader.rs</a></td><td> | </td><td class="num">54</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d">-------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/raft/node/mod.rs</a></td><td> | </td><td class="num">90</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++</span><span class="d">------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">src/raft/server.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">+++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/raft/state.rs</a></td><td> | </td><td class="num">26</td><td><span class="i">++++++++++++++</span><span class="d">------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">src/server.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">+++++</span><span class="d">----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">27</td><td><span class="i">++++++++++++++</span><span class="d">-------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h13">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h14">src/storage/kv/memory.rs</a></td><td> | </td><td class="num">34</td><td><span class="i">+++++++++++++++</span><span class="d">-------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h15">src/storage/kv/mod.rs</a></td><td> | </td><td class="num">84</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h16">src/storage/kv/mvcc.rs</a></td><td> | </td><td class="num">83</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h17">src/storage/kv/std_memory.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">+++++++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h18">src/storage/kv/test.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">+++++++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h19">src/storage/log/hybrid.rs</a></td><td> | </td><td class="num">38</td><td><span class="i">+++++++++++++++++++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h20">src/storage/log/memory.rs</a></td><td> | </td><td class="num">29</td><td><span class="i">++++++++++++++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h21">src/storage/log/mod.rs</a></td><td> | </td><td class="num">85</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">---------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h22">src/storage/log/test.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">+++++++++++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h23">tests/client/mod.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">+++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h24">tests/setup.rs</a></td><td> | </td><td class="num">9</td><td><span class="i">++++++++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h25">tests/sql/mod.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
</table></pre><pre>26 files changed, 481 insertions(+), 278 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/README.md.html">README.md</a> b/<a href="../file/README.md.html">README.md</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -4,13 +4,15 @@
</a> 
 Distributed SQL database in Rust, written as a learning project. Most components have been built from scratch, including:
 
<a href="#h0-0-3" id="h0-0-3" class="i">+* Pluggable storage engine with B+tree and log-structured backends.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+
</a> * Raft-based distributed consensus engine for linearizable state machine replication.
 
 * ACID-compliant transaction engine with MVCC-based snapshot isolation.
 
 * Iterator-based query engine with heuristic optimization and time-travel support.
 
<a href="#h0-0-11" id="h0-0-11" class="d">-* SQL interface including projections, filters, joins, and aggregates.
</a><a href="#h0-0-12" id="h0-0-12" class="i">+* SQL interface including projections, filters, joins, aggregates, and transactions.
</a> 
 For details, see the [documentation](docs/).
 
<b>diff --git a/<a id="h1" href="../file/config/toydb.yaml.html">config/toydb.yaml</a> b/<a href="../file/config/toydb.yaml.html">config/toydb.yaml</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,12 +1,25 @@
</a><a href="#h1-0-0" id="h1-0-0" class="d">-# The cluster node ID and peer ID/address map (empty for single node)
</a><a href="#h1-0-1" id="h1-0-1" class="i">+# The node ID, peer ID/address map (empty for single node), and log level.
</a> id: toydb
 peers: {}
<a href="#h1-0-4" id="h1-0-4" class="i">+log_level: INFO
</a> 
<a href="#h1-0-6" id="h1-0-6" class="d">-# Network addresses to bind the SQL and Raft servers to
</a><a href="#h1-0-7" id="h1-0-7" class="i">+# Network addresses to bind the SQL and Raft servers to.
</a> listen_sql: 0.0.0.0:9605
 listen_raft: 0.0.0.0:9705
 
<a href="#h1-0-11" id="h1-0-11" class="d">-# The node log level, data directory, and whether to fsync writes
</a><a href="#h1-0-12" id="h1-0-12" class="d">-log_level: INFO
</a><a href="#h1-0-13" id="h1-0-13" class="i">+# Node data directory, and whether to fsync writes. Fsyncing guarantees that committed data is
</a><a href="#h1-0-14" id="h1-0-14" class="i">+# persisted to disk, but has a high performance penalty. Disabling fsync and relying on cluster
</a><a href="#h1-0-15" id="h1-0-15" class="i">+# redundancy for data durability may be a reasonable trade-off, although this can compromise Raft
</a><a href="#h1-0-16" id="h1-0-16" class="i">+# linearizability guarantees in rare edge cases where committed entries lose majority.
</a> data_dir: /var/lib/toydb
 sync: true
<a href="#h1-0-19" id="h1-0-19" class="i">+
</a><a href="#h1-0-20" id="h1-0-20" class="i">+# Raft log storage engine
</a><a href="#h1-0-21" id="h1-0-21" class="i">+# - hybrid: (default) stores committed entries in an indexed append-only file, the rest in memory.
</a><a href="#h1-0-22" id="h1-0-22" class="i">+# - memory: stores all entries in memory.
</a><a href="#h1-0-23" id="h1-0-23" class="i">+storage_raft: hybrid
</a><a href="#h1-0-24" id="h1-0-24" class="i">+
</a><a href="#h1-0-25" id="h1-0-25" class="i">+# SQL key-value storage engine
</a><a href="#h1-0-26" id="h1-0-26" class="i">+# - memory: (default) uses an in-memory B+tree. Durability is provided by the Raft log.
</a><a href="#h1-0-27" id="h1-0-27" class="i">+# - stdmemory: uses the Rust standard library BTreeMap.
</a><a href="#h1-0-28" id="h1-0-28" class="i">+storage_sql: memory
</a><b>diff --git a/<a id="h2" href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a> b/<a href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -3,7 +3,8 @@
</a> use clap::{app_from_crate, crate_authors, crate_description, crate_name, crate_version};
 use serde_derive::Deserialize;
 use std::collections::HashMap;
<a href="#h2-0-3" id="h2-0-3" class="d">-use toydb::error::Result;
</a><a href="#h2-0-4" id="h2-0-4" class="i">+use toydb::error::{Error, Result};
</a><a href="#h2-0-5" id="h2-0-5" class="i">+use toydb::storage;
</a> use toydb::Server;
 
 #[tokio::main]
<a href="#h2-1" id="h2-1" class="h">@@ -27,7 +28,19 @@ async fn main() -&gt; Result&lt;()&gt; {
</a>     }
     simplelog::SimpleLogger::init(loglevel, logconfig.build())?;
 
<a href="#h2-1-3" id="h2-1-3" class="d">-    Server::new(&amp;cfg.id, cfg.peers, &amp;cfg.data_dir, cfg.sync)
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    let path = std::path::Path::new(&amp;cfg.data_dir);
</a><a href="#h2-1-5" id="h2-1-5" class="i">+    let raft_store: Box&lt;dyn storage::log::Store&gt; = match cfg.storage_raft.as_str() {
</a><a href="#h2-1-6" id="h2-1-6" class="i">+        &quot;hybrid&quot; | &quot;&quot; =&gt; Box::new(storage::log::Hybrid::new(&amp;path, cfg.sync)?),
</a><a href="#h2-1-7" id="h2-1-7" class="i">+        &quot;memory&quot; =&gt; Box::new(storage::log::Memory::new()),
</a><a href="#h2-1-8" id="h2-1-8" class="i">+        name =&gt; return Err(Error::Config(format!(&quot;Unknown Raft storage engine {}&quot;, name))),
</a><a href="#h2-1-9" id="h2-1-9" class="i">+    };
</a><a href="#h2-1-10" id="h2-1-10" class="i">+    let sql_store: Box&lt;dyn storage::kv::Store&gt; = match cfg.storage_sql.as_str() {
</a><a href="#h2-1-11" id="h2-1-11" class="i">+        &quot;memory&quot; | &quot;&quot; =&gt; Box::new(storage::kv::Memory::new()),
</a><a href="#h2-1-12" id="h2-1-12" class="i">+        &quot;stdmemory&quot; =&gt; Box::new(storage::kv::StdMemory::new()),
</a><a href="#h2-1-13" id="h2-1-13" class="i">+        name =&gt; return Err(Error::Config(format!(&quot;Unknown SQL storage engine {}&quot;, name))),
</a><a href="#h2-1-14" id="h2-1-14" class="i">+    };
</a><a href="#h2-1-15" id="h2-1-15" class="i">+
</a><a href="#h2-1-16" id="h2-1-16" class="i">+    Server::new(&amp;cfg.id, cfg.peers, raft_store, sql_store)
</a>         .await?
         .listen(&amp;cfg.listen_sql, &amp;cfg.listen_raft)
         .await?
<a href="#h2-2" id="h2-2" class="h">@@ -38,12 +51,14 @@ async fn main() -&gt; Result&lt;()&gt; {
</a> #[derive(Debug, Deserialize)]
 struct Config {
     id: String,
<a href="#h2-2-3" id="h2-2-3" class="i">+    peers: HashMap&lt;String, String&gt;,
</a>     listen_sql: String,
     listen_raft: String,
     log_level: String,
     data_dir: String,
     sync: bool,
<a href="#h2-2-9" id="h2-2-9" class="d">-    peers: HashMap&lt;String, String&gt;,
</a><a href="#h2-2-10" id="h2-2-10" class="i">+    storage_raft: String,
</a><a href="#h2-2-11" id="h2-2-11" class="i">+    storage_sql: String,
</a> }
 
 impl Config {
<a href="#h2-3" id="h2-3" class="h">@@ -55,6 +70,8 @@ impl Config {
</a>         c.set_default(&quot;log_level&quot;, &quot;info&quot;)?;
         c.set_default(&quot;data_dir&quot;, &quot;/var/lib/toydb&quot;)?;
         c.set_default(&quot;sync&quot;, true)?;
<a href="#h2-3-3" id="h2-3-3" class="i">+        c.set_default(&quot;storage_raft&quot;, &quot;hybrid&quot;)?;
</a><a href="#h2-3-4" id="h2-3-4" class="i">+        c.set_default(&quot;storage_sql&quot;, &quot;memory&quot;)?;
</a> 
         c.merge(config::File::with_name(file))?;
         c.merge(config::Environment::with_prefix(&quot;TOYDB&quot;))?;
<b>diff --git a/<a id="h3" href="../file/src/bin/toysql.rs.html">src/bin/toysql.rs</a> b/<a href="../file/src/bin/toysql.rs.html">src/bin/toysql.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -132,9 +132,9 @@ Semicolons are not supported. The following commands are also available:
</a>                 println!(
                     r#&quot;
 Server:    {server} (leader {leader} in term {term} with {nodes} nodes)
<a href="#h3-0-3" id="h3-0-3" class="d">-Raft log:  {committed} committed, {applied} applied entries
</a><a href="#h3-0-4" id="h3-0-4" class="i">+Raft log:  {committed} committed, {applied} applied, {raft_size} MB ({raft_storage} storage)
</a> Node logs: {logs}
<a href="#h3-0-6" id="h3-0-6" class="d">-Txns:      {txns_active} active, {txns} total
</a><a href="#h3-0-7" id="h3-0-7" class="i">+SQL txns:  {txns_active} active, {txns} total ({sql_storage} storage)
</a> &quot;#,
                     server = status.raft.server,
                     leader = status.raft.leader,
<a href="#h3-1" id="h3-1" class="h">@@ -142,9 +142,12 @@ Txns:      {txns_active} active, {txns} total
</a>                     nodes = status.raft.node_last_index.len(),
                     committed = status.raft.commit_index,
                     applied = status.raft.apply_index,
<a href="#h3-1-3" id="h3-1-3" class="i">+                    raft_storage = status.raft.storage,
</a><a href="#h3-1-4" id="h3-1-4" class="i">+                    raft_size = format!(&quot;{:.3}&quot;, status.raft.storage_size as f64 / 1000.0 / 1000.0),
</a>                     logs = node_logs.join(&quot; &quot;),
                     txns = status.mvcc.txns,
<a href="#h3-1-7" id="h3-1-7" class="d">-                    txns_active = status.mvcc.txns_active
</a><a href="#h3-1-8" id="h3-1-8" class="i">+                    txns_active = status.mvcc.txns_active,
</a><a href="#h3-1-9" id="h3-1-9" class="i">+                    sql_storage = status.mvcc.storage
</a>                 )
             }
             &quot;!table&quot; =&gt; {
<b>diff --git a/<a id="h4" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -1,5 +1,6 @@
</a> use crate::error::{Error, Result};
 use crate::storage::log;
<a href="#h4-0-2" id="h4-0-2" class="i">+use crate::storage::log::Range;
</a> 
 use ::log::debug;
 use serde::{Deserialize, Serialize};
<a href="#h4-1" id="h4-1" class="h">@@ -35,9 +36,9 @@ impl Key {
</a> pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Entry&gt;&gt; + &#39;a&gt;;
 
 /// The replicated Raft log
<a href="#h4-1-3" id="h4-1-3" class="d">-pub struct Log&lt;S: log::Store&gt; {
</a><a href="#h4-1-4" id="h4-1-4" class="i">+pub struct Log {
</a>     /// The underlying log store.
<a href="#h4-1-6" id="h4-1-6" class="d">-    store: S,
</a><a href="#h4-1-7" id="h4-1-7" class="i">+    pub(super) store: Box&lt;dyn log::Store&gt;,
</a>     /// The index of the last stored entry.
     pub(super) last_index: u64,
     /// The term of the last stored entry.
<a href="#h4-2" id="h4-2" class="h">@@ -48,9 +49,9 @@ pub struct Log&lt;S: log::Store&gt; {
</a>     pub(super) commit_term: u64,
 }
 
<a href="#h4-2-3" id="h4-2-3" class="d">-impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a><a href="#h4-2-4" id="h4-2-4" class="i">+impl Log {
</a>     /// Creates a new log, using a log::Store for storage.
<a href="#h4-2-6" id="h4-2-6" class="d">-    pub fn new(store: S) -&gt; Result&lt;Self&gt; {
</a><a href="#h4-2-7" id="h4-2-7" class="i">+    pub fn new(store: Box&lt;dyn log::Store&gt;) -&gt; Result&lt;Self&gt; {
</a>         let (commit_index, commit_term) = match store.committed() {
             0 =&gt; (0, 0),
             index =&gt; store
<a href="#h4-3" id="h4-3" class="h">@@ -109,7 +110,7 @@ impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a> 
     /// Iterates over log entries
     pub fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan {
<a href="#h4-3-3" id="h4-3-3" class="d">-        Box::new(self.store.scan(range).map(|r| r.and_then(|v| Self::deserialize(&amp;v))))
</a><a href="#h4-3-4" id="h4-3-4" class="i">+        Box::new(self.store.scan(Range::from(range)).map(|r| r.and_then(|v| Self::deserialize(&amp;v))))
</a>     }
 
     /// Splices a set of entries onto an offset. The entries must be contiguous, and the first entry
<a href="#h4-4" id="h4-4" class="h">@@ -189,8 +190,8 @@ mod tests {
</a>     use super::*;
     use pretty_assertions::assert_eq;
 
<a href="#h4-4-3" id="h4-4-3" class="d">-    fn setup() -&gt; Result&lt;(Log&lt;log::Test&gt;, log::Test)&gt; {
</a><a href="#h4-4-4" id="h4-4-4" class="d">-        let store = log::Test::new();
</a><a href="#h4-4-5" id="h4-4-5" class="i">+    fn setup() -&gt; Result&lt;(Log, Box&lt;log::Test&gt;)&gt; {
</a><a href="#h4-4-6" id="h4-4-6" class="i">+        let store = Box::new(log::Test::new());
</a>         let log = Log::new(store.clone())?;
         Ok((log, store))
     }
<b>diff --git a/<a id="h5" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,7 +1,6 @@
</a> use super::super::{Address, Event, Message, Response};
 use super::{Follower, Leader, Node, RoleNode, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
 use crate::error::Result;
<a href="#h5-0-3" id="h5-0-3" class="d">-use crate::storage::log;
</a> 
 use ::log::{debug, info, warn};
 use rand::Rng as _;
<a href="#h5-1" id="h5-1" class="h">@@ -29,9 +28,9 @@ impl Candidate {
</a>     }
 }
 
<a href="#h5-1-3" id="h5-1-3" class="d">-impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a><a href="#h5-1-4" id="h5-1-4" class="i">+impl RoleNode&lt;Candidate&gt; {
</a>     /// Transition to follower role.
<a href="#h5-1-6" id="h5-1-6" class="d">-    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;&gt; {
</a><a href="#h5-1-7" id="h5-1-7" class="i">+    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a>         info!(&quot;Discovered leader {} for term {}, following&quot;, leader, term);
         self.term = term;
         self.log.save_term(term, None)?;
<a href="#h5-2" id="h5-2" class="h">@@ -42,7 +41,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>     }
 
     /// Transition to leader role.
<a href="#h5-2-3" id="h5-2-3" class="d">-    fn become_leader(self) -&gt; Result&lt;RoleNode&lt;Leader, L&gt;&gt; {
</a><a href="#h5-2-4" id="h5-2-4" class="i">+    fn become_leader(self) -&gt; Result&lt;RoleNode&lt;Leader&gt;&gt; {
</a>         info!(&quot;Won election for term {}, becoming leader&quot;, self.term);
         let peers = self.peers.clone();
         let last_index = self.log.last_index;
<a href="#h5-3" id="h5-3" class="h">@@ -60,7 +59,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>     }
 
     /// Processes a message.
<a href="#h5-3-3" id="h5-3-3" class="d">-    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a><a href="#h5-3-4" id="h5-3-4" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
</a>         if let Err(err) = self.validate(&amp;msg) {
             warn!(&quot;Ignoring invalid message: {}&quot;, err);
             return Ok(self.into());
<a href="#h5-4" id="h5-4" class="h">@@ -83,7 +82,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>                 self.role.votes += 1;
                 if self.role.votes &gt;= self.quorum() {
                     let queued = std::mem::replace(&amp;mut self.queued_reqs, Vec::new());
<a href="#h5-4-3" id="h5-4-3" class="d">-                    let mut node: Node&lt;_&gt; = self.become_leader()?.into();
</a><a href="#h5-4-4" id="h5-4-4" class="i">+                    let mut node: Node = self.become_leader()?.into();
</a>                     for (from, event) in queued {
                         node = node.step(Message { from, to: Address::Local, term: 0, event })?;
                     }
<a href="#h5-5" id="h5-5" class="h">@@ -113,7 +112,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>     }
 
     /// Processes a logical clock tick.
<a href="#h5-5-3" id="h5-5-3" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a><a href="#h5-5-4" id="h5-5-4" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&gt; {
</a>         // If the election times out, start a new one for the next term.
         self.role.election_ticks += 1;
         if self.role.election_ticks &gt;= self.role.election_timeout {
<a href="#h5-6" id="h5-6" class="h">@@ -138,18 +137,19 @@ mod tests {
</a>     use super::super::super::{Entry, Instruction, Log, Request};
     use super::super::tests::{assert_messages, assert_node};
     use super::*;
<a href="#h5-6-3" id="h5-6-3" class="i">+    use crate::storage::log;
</a>     use std::collections::HashMap;
     use tokio::sync::mpsc;
 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;(
<a href="#h5-6-9" id="h5-6-9" class="d">-        RoleNode&lt;Candidate, log::Test&gt;,
</a><a href="#h5-6-10" id="h5-6-10" class="i">+        RoleNode&lt;Candidate&gt;,
</a>         mpsc::UnboundedReceiver&lt;Message&gt;,
         mpsc::UnboundedReceiver&lt;Instruction&gt;,
     )&gt; {
         let (node_tx, mut node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
<a href="#h5-6-16" id="h5-6-16" class="d">-        let mut log = Log::new(log::Test::new())?;
</a><a href="#h5-6-17" id="h5-6-17" class="i">+        let mut log = Log::new(Box::new(log::Test::new()))?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<b>diff --git a/<a id="h6" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,7 +1,6 @@
</a> use super::super::{Address, Event, Instruction, Message, Response};
 use super::{Candidate, Node, RoleNode, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
 use crate::error::Result;
<a href="#h6-0-3" id="h6-0-3" class="d">-use crate::storage::log;
</a> 
 use ::log::{debug, info, warn};
 use rand::Rng as _;
<a href="#h6-1" id="h6-1" class="h">@@ -32,9 +31,9 @@ impl Follower {
</a>     }
 }
 
<a href="#h6-1-3" id="h6-1-3" class="d">-impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
</a><a href="#h6-1-4" id="h6-1-4" class="i">+impl RoleNode&lt;Follower&gt; {
</a>     /// Transforms the node into a candidate.
<a href="#h6-1-6" id="h6-1-6" class="d">-    fn become_candidate(self) -&gt; Result&lt;RoleNode&lt;Candidate, L&gt;&gt; {
</a><a href="#h6-1-7" id="h6-1-7" class="i">+    fn become_candidate(self) -&gt; Result&lt;RoleNode&lt;Candidate&gt;&gt; {
</a>         info!(&quot;Starting election for term {}&quot;, self.term + 1);
         let mut node = self.become_role(Candidate::new())?;
         node.term += 1;
<a href="#h6-2" id="h6-2" class="h">@@ -47,7 +46,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>     }
 
     /// Transforms the node into a follower for a new leader.
<a href="#h6-2-3" id="h6-2-3" class="d">-    fn become_follower(mut self, leader: &amp;str, term: u64) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;&gt; {
</a><a href="#h6-2-4" id="h6-2-4" class="i">+    fn become_follower(mut self, leader: &amp;str, term: u64) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a>         let mut voted_for = None;
         if term &gt; self.term {
             info!(&quot;Discovered new term {}, following leader {}&quot;, term, leader);
<a href="#h6-3" id="h6-3" class="h">@@ -72,7 +71,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>     }
 
     /// Processes a message.
<a href="#h6-3-3" id="h6-3-3" class="d">-    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a><a href="#h6-3-4" id="h6-3-4" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
</a>         if let Err(err) = self.validate(&amp;msg) {
             warn!(&quot;Ignoring invalid message: {}&quot;, err);
             return Ok(self.into());
<a href="#h6-4" id="h6-4" class="h">@@ -162,7 +161,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>     }
 
     /// Processes a logical clock tick.
<a href="#h6-4-3" id="h6-4-3" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a><a href="#h6-4-4" id="h6-4-4" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&gt; {
</a>         self.role.leader_seen_ticks += 1;
         if self.role.leader_seen_ticks &gt;= self.role.leader_seen_timeout {
             Ok(self.become_candidate()?.into())
<a href="#h6-5" id="h6-5" class="h">@@ -178,26 +177,27 @@ pub mod tests {
</a>     use super::super::tests::{assert_messages, assert_node};
     use super::*;
     use crate::error::Error;
<a href="#h6-5-3" id="h6-5-3" class="i">+    use crate::storage::log;
</a>     use std::collections::HashMap;
     use tokio::sync::mpsc;
 
<a href="#h6-5-7" id="h6-5-7" class="d">-    pub fn follower_leader&lt;L: log::Store&gt;(node: &amp;RoleNode&lt;Follower, L&gt;) -&gt; Option&lt;String&gt; {
</a><a href="#h6-5-8" id="h6-5-8" class="i">+    pub fn follower_leader(node: &amp;RoleNode&lt;Follower&gt;) -&gt; Option&lt;String&gt; {
</a>         node.role.leader.clone()
     }
 
<a href="#h6-5-12" id="h6-5-12" class="d">-    pub fn follower_voted_for&lt;L: log::Store&gt;(node: &amp;RoleNode&lt;Follower, L&gt;) -&gt; Option&lt;String&gt; {
</a><a href="#h6-5-13" id="h6-5-13" class="i">+    pub fn follower_voted_for(node: &amp;RoleNode&lt;Follower&gt;) -&gt; Option&lt;String&gt; {
</a>         node.role.voted_for.clone()
     }
 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;(
<a href="#h6-5-19" id="h6-5-19" class="d">-        RoleNode&lt;Follower, log::Test&gt;,
</a><a href="#h6-5-20" id="h6-5-20" class="i">+        RoleNode&lt;Follower&gt;,
</a>         mpsc::UnboundedReceiver&lt;Message&gt;,
         mpsc::UnboundedReceiver&lt;Instruction&gt;,
     )&gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
<a href="#h6-5-26" id="h6-5-26" class="d">-        let mut log = Log::new(log::Test::new())?;
</a><a href="#h6-5-27" id="h6-5-27" class="i">+        let mut log = Log::new(Box::new(log::Test::new()))?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<b>diff --git a/<a id="h7" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -1,7 +1,6 @@
</a> use super::super::{Address, Event, Instruction, Message, Request, Response, Status};
 use super::{Follower, Node, RoleNode, HEARTBEAT_INTERVAL};
 use crate::error::{Error, Result};
<a href="#h7-0-3" id="h7-0-3" class="d">-use crate::storage::log;
</a> 
 use ::log::{debug, info, warn};
 use std::collections::HashMap;
<a href="#h7-1" id="h7-1" class="h">@@ -33,9 +32,9 @@ impl Leader {
</a>     }
 }
 
<a href="#h7-1-3" id="h7-1-3" class="d">-impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a><a href="#h7-1-4" id="h7-1-4" class="i">+impl RoleNode&lt;Leader&gt; {
</a>     /// Transforms the leader into a follower
<a href="#h7-1-6" id="h7-1-6" class="d">-    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;&gt; {
</a><a href="#h7-1-7" id="h7-1-7" class="i">+    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower&gt;&gt; {
</a>         info!(&quot;Discovered new leader {} for term {}, following&quot;, leader, term);
         self.term = term;
         self.log.save_term(term, None)?;
<a href="#h7-2" id="h7-2" class="h">@@ -100,7 +99,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>     }
 
     /// Processes a message.
<a href="#h7-2-3" id="h7-2-3" class="d">-    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a><a href="#h7-2-4" id="h7-2-4" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&gt; {
</a>         if let Err(err) = self.validate(&amp;msg) {
             warn!(&quot;Ignoring invalid message: {}&quot;, err);
             return Ok(self.into());
<a href="#h7-3" id="h7-3" class="h">@@ -175,14 +174,16 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>             }
 
             Event::ClientRequest { id, request: Request::Status } =&gt; {
<a href="#h7-3-3" id="h7-3-3" class="d">-                let mut status = Status {
</a><a href="#h7-3-4" id="h7-3-4" class="i">+                let mut status = Box::new(Status {
</a>                     server: self.id.clone(),
                     leader: self.id.clone(),
                     term: self.term,
                     node_last_index: self.role.peer_last_index.clone(),
                     commit_index: self.log.commit_index,
                     apply_index: 0,
<a href="#h7-3-11" id="h7-3-11" class="d">-                };
</a><a href="#h7-3-12" id="h7-3-12" class="i">+                    storage: self.log.store.to_string(),
</a><a href="#h7-3-13" id="h7-3-13" class="i">+                    storage_size: self.log.store.size(),
</a><a href="#h7-3-14" id="h7-3-14" class="i">+                });
</a>                 status.node_last_index.insert(self.id.clone(), self.log.last_index);
                 self.state_tx.send(Instruction::Status { id, address: msg.from, status })?
             }
<a href="#h7-4" id="h7-4" class="h">@@ -207,7 +208,7 @@ impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>     }
 
     /// Processes a logical clock tick.
<a href="#h7-4-3" id="h7-4-3" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;&gt; {
</a><a href="#h7-4-4" id="h7-4-4" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&gt; {
</a>         if !self.peers.is_empty() {
             self.role.heartbeat_ticks += 1;
             if self.role.heartbeat_ticks &gt;= HEARTBEAT_INTERVAL {
<a href="#h7-5" id="h7-5" class="h">@@ -230,19 +231,20 @@ mod tests {
</a>     use super::super::super::{Entry, Log};
     use super::super::tests::{assert_messages, assert_node};
     use super::*;
<a href="#h7-5-3" id="h7-5-3" class="i">+    use crate::storage::log;
</a>     use pretty_assertions::assert_eq;
     use tokio::sync::mpsc;
 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;(
<a href="#h7-5-9" id="h7-5-9" class="d">-        RoleNode&lt;Leader, log::Test&gt;,
</a><a href="#h7-5-10" id="h7-5-10" class="i">+        RoleNode&lt;Leader&gt;,
</a>         mpsc::UnboundedReceiver&lt;Message&gt;,
         mpsc::UnboundedReceiver&lt;Instruction&gt;,
     )&gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
         let peers = vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()];
<a href="#h7-5-17" id="h7-5-17" class="d">-        let mut log = Log::new(log::Test::new())?;
</a><a href="#h7-5-18" id="h7-5-18" class="i">+        let mut log = Log::new(Box::new(log::Test::new()))?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<a href="#h7-6" id="h7-6" class="h">@@ -269,7 +271,7 @@ mod tests {
</a>     // ConfirmLeader triggers vote
     fn step_confirmleader_vote() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-6-3" id="h7-6-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-6-4" id="h7-6-4" class="i">+        let mut node: Node = leader.into();
</a> 
         node = node.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h7-7" id="h7-7" class="h">@@ -290,7 +292,7 @@ mod tests {
</a>     // ConfirmLeader without has_committed triggers replication
     fn step_confirmleader_replicate() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-7-3" id="h7-7-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-7-4" id="h7-7-4" class="i">+        let mut node: Node = leader.into();
</a> 
         node = node.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h7-8" id="h7-8" class="h">@@ -319,7 +321,7 @@ mod tests {
</a>     // Heartbeats from other leaders in current term are ignored.
     fn step_heartbeat_current_term() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-8-3" id="h7-8-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-8-4" id="h7-8-4" class="i">+        let mut node: Node = leader.into();
</a> 
         node = node.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h7-9" id="h7-9" class="h">@@ -337,7 +339,7 @@ mod tests {
</a>     // Heartbeats from other leaders in future term converts to follower and steps.
     fn step_heartbeat_future_term() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-9-3" id="h7-9-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-9-4" id="h7-9-4" class="i">+        let mut node: Node = leader.into();
</a> 
         node = node.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h7-10" id="h7-10" class="h">@@ -363,7 +365,7 @@ mod tests {
</a>     // Heartbeats from other leaders in past terms are ignored.
     fn step_heartbeat_past_term() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-10-3" id="h7-10-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-10-4" id="h7-10-4" class="i">+        let mut node: Node = leader.into();
</a> 
         node = node.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h7-11" id="h7-11" class="h">@@ -380,7 +382,7 @@ mod tests {
</a>     #[test]
     fn step_acceptentries() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-11-3" id="h7-11-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-11-4" id="h7-11-4" class="i">+        let mut node: Node = leader.into();
</a> 
         node = node.step(Message {
             from: Address::Peer(&quot;b&quot;.into()),
<a href="#h7-12" id="h7-12" class="h">@@ -435,7 +437,7 @@ mod tests {
</a>     // Duplicate AcceptEntries from single node should not trigger commit.
     fn step_acceptentries_duplicate() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-12-3" id="h7-12-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-12-4" id="h7-12-4" class="i">+        let mut node: Node = leader.into();
</a> 
         for _ in 0..5 {
             node = node.step(Message {
<a href="#h7-13" id="h7-13" class="h">@@ -456,7 +458,7 @@ mod tests {
</a>     fn step_acceptentries_past_term() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
         let peers = leader.peers.clone();
<a href="#h7-13-3" id="h7-13-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-13-4" id="h7-13-4" class="i">+        let mut node: Node = leader.into();
</a> 
         for peer in peers.into_iter() {
             node = node.step(Message {
<a href="#h7-14" id="h7-14" class="h">@@ -477,7 +479,7 @@ mod tests {
</a>     fn step_acceptentries_future_index() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
         let peers = leader.peers.clone();
<a href="#h7-14-3" id="h7-14-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-14-4" id="h7-14-4" class="i">+        let mut node: Node = leader.into();
</a> 
         for (i, peer) in peers.into_iter().enumerate() {
             node = node.step(Message {
<a href="#h7-15" id="h7-15" class="h">@@ -517,7 +519,7 @@ mod tests {
</a>     fn step_rejectentries() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
         let entries = leader.log.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
<a href="#h7-15-3" id="h7-15-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-15-4" id="h7-15-4" class="i">+        let mut node: Node = leader.into();
</a> 
         for i in 0..(entries.len() + 3) {
             node = node.step(Message {
<a href="#h7-16" id="h7-16" class="h">@@ -556,7 +558,7 @@ mod tests {
</a>     fn step_clientrequest_query() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
         let quorum = leader.quorum();
<a href="#h7-16-3" id="h7-16-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-16-4" id="h7-16-4" class="i">+        let mut node: Node = leader.into();
</a>         node = node.step(Message {
             from: Address::Client,
             to: Address::Local,
<a href="#h7-17" id="h7-17" class="h">@@ -594,7 +596,7 @@ mod tests {
</a>     fn step_clientrequest_mutate() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
         let peers = leader.peers.clone();
<a href="#h7-17-3" id="h7-17-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-17-4" id="h7-17-4" class="i">+        let mut node: Node = leader.into();
</a> 
         node = node.step(Message {
             from: Address::Client,
<a href="#h7-18" id="h7-18" class="h">@@ -635,7 +637,7 @@ mod tests {
</a>     // Sending a status request should pass it on to state machine, to add status.
     fn step_clientrequest_status() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-18-3" id="h7-18-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-18-4" id="h7-18-4" class="i">+        let mut node: Node = leader.into();
</a> 
         node = node.step(Message {
             from: Address::Client,
<a href="#h7-19" id="h7-19" class="h">@@ -650,7 +652,7 @@ mod tests {
</a>             vec![Instruction::Status {
                 id: vec![0x01],
                 address: Address::Client,
<a href="#h7-19-3" id="h7-19-3" class="d">-                status: Status {
</a><a href="#h7-19-4" id="h7-19-4" class="i">+                status: Box::new(Status {
</a>                     server: &quot;a&quot;.into(),
                     leader: &quot;a&quot;.into(),
                     term: 3,
<a href="#h7-20" id="h7-20" class="h">@@ -665,7 +667,9 @@ mod tests {
</a>                     .collect(),
                     commit_index: 2,
                     apply_index: 0,
<a href="#h7-20-3" id="h7-20-3" class="d">-                },
</a><a href="#h7-20-4" id="h7-20-4" class="i">+                    storage: &quot;test&quot;.into(),
</a><a href="#h7-20-5" id="h7-20-5" class="i">+                    storage_size: 130,
</a><a href="#h7-20-6" id="h7-20-6" class="i">+                }),
</a>             }],
         );
 
<a href="#h7-21" id="h7-21" class="h">@@ -675,7 +679,7 @@ mod tests {
</a>     #[test]
     fn tick() -&gt; Result&lt;()&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h7-21-3" id="h7-21-3" class="d">-        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h7-21-4" id="h7-21-4" class="i">+        let mut node: Node = leader.into();
</a>         for _ in 0..5 {
             for _ in 0..HEARTBEAT_INTERVAL {
                 assert_messages(&amp;mut node_rx, vec![]);
<b>diff --git a/<a id="h8" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -4,7 +4,6 @@ mod leader;
</a> 
 use super::{Address, Driver, Event, Instruction, Log, Message, State};
 use crate::error::{Error, Result};
<a href="#h8-0-3" id="h8-0-3" class="d">-use crate::storage::log;
</a> use candidate::Candidate;
 use follower::Follower;
 use leader::Leader;
<a href="#h8-1" id="h8-1" class="h">@@ -32,22 +31,24 @@ pub struct Status {
</a>     pub node_last_index: HashMap&lt;String, u64&gt;,
     pub commit_index: u64,
     pub apply_index: u64,
<a href="#h8-1-3" id="h8-1-3" class="i">+    pub storage: String,
</a><a href="#h8-1-4" id="h8-1-4" class="i">+    pub storage_size: u64,
</a> }
 
 /// The local Raft node state machine.
<a href="#h8-1-8" id="h8-1-8" class="d">-pub enum Node&lt;L: log::Store&gt; {
</a><a href="#h8-1-9" id="h8-1-9" class="d">-    Candidate(RoleNode&lt;Candidate, L&gt;),
</a><a href="#h8-1-10" id="h8-1-10" class="d">-    Follower(RoleNode&lt;Follower, L&gt;),
</a><a href="#h8-1-11" id="h8-1-11" class="d">-    Leader(RoleNode&lt;Leader, L&gt;),
</a><a href="#h8-1-12" id="h8-1-12" class="i">+pub enum Node {
</a><a href="#h8-1-13" id="h8-1-13" class="i">+    Candidate(RoleNode&lt;Candidate&gt;),
</a><a href="#h8-1-14" id="h8-1-14" class="i">+    Follower(RoleNode&lt;Follower&gt;),
</a><a href="#h8-1-15" id="h8-1-15" class="i">+    Leader(RoleNode&lt;Leader&gt;),
</a> }
 
<a href="#h8-1-18" id="h8-1-18" class="d">-impl&lt;L: log::Store&gt; Node&lt;L&gt; {
</a><a href="#h8-1-19" id="h8-1-19" class="i">+impl Node {
</a>     /// Creates a new Raft node, starting as a follower, or leader if no peers.
<a href="#h8-1-21" id="h8-1-21" class="d">-    pub async fn new&lt;S: State + Send + &#39;static&gt;(
</a><a href="#h8-1-22" id="h8-1-22" class="i">+    pub async fn new(
</a>         id: &amp;str,
         peers: Vec&lt;String&gt;,
<a href="#h8-1-25" id="h8-1-25" class="d">-        log: Log&lt;L&gt;,
</a><a href="#h8-1-26" id="h8-1-26" class="d">-        mut state: S,
</a><a href="#h8-1-27" id="h8-1-27" class="i">+        log: Log,
</a><a href="#h8-1-28" id="h8-1-28" class="i">+        mut state: Box&lt;dyn State&gt;,
</a>         node_tx: mpsc::UnboundedSender&lt;Message&gt;,
     ) -&gt; Result&lt;Self&gt; {
         let applied_index = state.applied_index();
<a href="#h8-2" id="h8-2" class="h">@@ -62,7 +63,7 @@ impl&lt;L: log::Store&gt; Node&lt;L&gt; {
</a>         let mut driver = Driver::new(state_rx, node_tx.clone());
         if log.commit_index &gt; applied_index {
             info!(&quot;Replaying log entries {} to {}&quot;, applied_index + 1, log.commit_index);
<a href="#h8-2-3" id="h8-2-3" class="d">-            driver.replay(&amp;mut state, log.scan((applied_index + 1)..=log.commit_index))?;
</a><a href="#h8-2-4" id="h8-2-4" class="i">+            driver.replay(&amp;mut *state, log.scan((applied_index + 1)..=log.commit_index))?;
</a>         };
         tokio::spawn(driver.drive(state));
 
<a href="#h8-3" id="h8-3" class="h">@@ -116,30 +117,30 @@ impl&lt;L: log::Store&gt; Node&lt;L&gt; {
</a>     }
 }
 
<a href="#h8-3-3" id="h8-3-3" class="d">-impl&lt;L: log::Store&gt; From&lt;RoleNode&lt;Candidate, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h8-3-4" id="h8-3-4" class="d">-    fn from(rn: RoleNode&lt;Candidate, L&gt;) -&gt; Self {
</a><a href="#h8-3-5" id="h8-3-5" class="i">+impl From&lt;RoleNode&lt;Candidate&gt;&gt; for Node {
</a><a href="#h8-3-6" id="h8-3-6" class="i">+    fn from(rn: RoleNode&lt;Candidate&gt;) -&gt; Self {
</a>         Node::Candidate(rn)
     }
 }
 
<a href="#h8-3-11" id="h8-3-11" class="d">-impl&lt;L: log::Store&gt; From&lt;RoleNode&lt;Follower, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h8-3-12" id="h8-3-12" class="d">-    fn from(rn: RoleNode&lt;Follower, L&gt;) -&gt; Self {
</a><a href="#h8-3-13" id="h8-3-13" class="i">+impl From&lt;RoleNode&lt;Follower&gt;&gt; for Node {
</a><a href="#h8-3-14" id="h8-3-14" class="i">+    fn from(rn: RoleNode&lt;Follower&gt;) -&gt; Self {
</a>         Node::Follower(rn)
     }
 }
 
<a href="#h8-3-19" id="h8-3-19" class="d">-impl&lt;L: log::Store&gt; From&lt;RoleNode&lt;Leader, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h8-3-20" id="h8-3-20" class="d">-    fn from(rn: RoleNode&lt;Leader, L&gt;) -&gt; Self {
</a><a href="#h8-3-21" id="h8-3-21" class="i">+impl From&lt;RoleNode&lt;Leader&gt;&gt; for Node {
</a><a href="#h8-3-22" id="h8-3-22" class="i">+    fn from(rn: RoleNode&lt;Leader&gt;) -&gt; Self {
</a>         Node::Leader(rn)
     }
 }
 
 // A Raft node with role R
<a href="#h8-3-28" id="h8-3-28" class="d">-pub struct RoleNode&lt;R, L: log::Store&gt; {
</a><a href="#h8-3-29" id="h8-3-29" class="i">+pub struct RoleNode&lt;R&gt; {
</a>     id: String,
     peers: Vec&lt;String&gt;,
     term: u64,
<a href="#h8-3-33" id="h8-3-33" class="d">-    log: Log&lt;L&gt;,
</a><a href="#h8-3-34" id="h8-3-34" class="i">+    log: Log,
</a>     node_tx: mpsc::UnboundedSender&lt;Message&gt;,
     state_tx: mpsc::UnboundedSender&lt;Instruction&gt;,
     /// Keeps track of queued client requests received e.g. during elections.
<a href="#h8-4" id="h8-4" class="h">@@ -149,9 +150,9 @@ pub struct RoleNode&lt;R, L: log::Store&gt; {
</a>     role: R,
 }
 
<a href="#h8-4-3" id="h8-4-3" class="d">-impl&lt;R, L: log::Store&gt; RoleNode&lt;R, L&gt; {
</a><a href="#h8-4-4" id="h8-4-4" class="i">+impl&lt;R&gt; RoleNode&lt;R&gt; {
</a>     /// Transforms the node into another role.
<a href="#h8-4-6" id="h8-4-6" class="d">-    fn become_role&lt;T&gt;(self, role: T) -&gt; Result&lt;RoleNode&lt;T, L&gt;&gt; {
</a><a href="#h8-4-7" id="h8-4-7" class="i">+    fn become_role&lt;T&gt;(self, role: T) -&gt; Result&lt;RoleNode&lt;T&gt;&gt; {
</a>         Ok(RoleNode {
             id: self.id,
             peers: self.peers,
<a href="#h8-5" id="h8-5" class="h">@@ -240,6 +241,7 @@ mod tests {
</a>     use super::super::Entry;
     use super::follower::tests::{follower_leader, follower_voted_for};
     use super::*;
<a href="#h8-5-3" id="h8-5-3" class="i">+    use crate::storage::log;
</a>     use pretty_assertions::assert_eq;
     use tokio::sync::mpsc;
 
<a href="#h8-6" id="h8-6" class="h">@@ -254,16 +256,16 @@ mod tests {
</a>         assert_eq!(msgs, actual);
     }
 
<a href="#h8-6-3" id="h8-6-3" class="d">-    pub struct NodeAsserter&lt;&#39;a, L: log::Store&gt; {
</a><a href="#h8-6-4" id="h8-6-4" class="d">-        node: &amp;&#39;a Node&lt;L&gt;,
</a><a href="#h8-6-5" id="h8-6-5" class="i">+    pub struct NodeAsserter&lt;&#39;a&gt; {
</a><a href="#h8-6-6" id="h8-6-6" class="i">+        node: &amp;&#39;a Node,
</a>     }
 
<a href="#h8-6-9" id="h8-6-9" class="d">-    impl&lt;&#39;a, L: log::Store&gt; NodeAsserter&lt;&#39;a, L&gt; {
</a><a href="#h8-6-10" id="h8-6-10" class="d">-        pub fn new(node: &amp;&#39;a Node&lt;L&gt;) -&gt; Self {
</a><a href="#h8-6-11" id="h8-6-11" class="i">+    impl&lt;&#39;a&gt; NodeAsserter&lt;&#39;a&gt; {
</a><a href="#h8-6-12" id="h8-6-12" class="i">+        pub fn new(node: &amp;&#39;a Node) -&gt; Self {
</a>             Self { node }
         }
 
<a href="#h8-6-16" id="h8-6-16" class="d">-        fn log(&amp;self) -&gt; &amp;&#39;a Log&lt;L&gt; {
</a><a href="#h8-6-17" id="h8-6-17" class="i">+        fn log(&amp;self) -&gt; &amp;&#39;a Log {
</a>             match self.node {
                 Node::Candidate(n) =&gt; &amp;n.log,
                 Node::Follower(n) =&gt; &amp;n.log,
<a href="#h8-7" id="h8-7" class="h">@@ -396,17 +398,17 @@ mod tests {
</a>         }
     }
 
<a href="#h8-7-3" id="h8-7-3" class="d">-    pub fn assert_node&lt;L: log::Store&gt;(node: &amp;Node&lt;L&gt;) -&gt; NodeAsserter&lt;L&gt; {
</a><a href="#h8-7-4" id="h8-7-4" class="i">+    pub fn assert_node(node: &amp;Node) -&gt; NodeAsserter {
</a>         NodeAsserter::new(node)
     }
 
<a href="#h8-7-8" id="h8-7-8" class="d">-    fn setup_rolenode() -&gt; Result&lt;(RoleNode&lt;(), log::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt; {
</a><a href="#h8-7-9" id="h8-7-9" class="i">+    fn setup_rolenode() -&gt; Result&lt;(RoleNode&lt;()&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt; {
</a>         setup_rolenode_peers(vec![&quot;b&quot;.into(), &quot;c&quot;.into()])
     }
 
     fn setup_rolenode_peers(
         peers: Vec&lt;String&gt;,
<a href="#h8-7-15" id="h8-7-15" class="d">-    ) -&gt; Result&lt;(RoleNode&lt;(), log::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt; {
</a><a href="#h8-7-16" id="h8-7-16" class="i">+    ) -&gt; Result&lt;(RoleNode&lt;()&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt; {
</a>         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, _) = mpsc::unbounded_channel();
         let node = RoleNode {
<a href="#h8-8" id="h8-8" class="h">@@ -414,7 +416,7 @@ mod tests {
</a>             id: &quot;a&quot;.into(),
             peers,
             term: 1,
<a href="#h8-8-3" id="h8-8-3" class="d">-            log: Log::new(log::Test::new())?,
</a><a href="#h8-8-4" id="h8-8-4" class="i">+            log: Log::new(Box::new(log::Test::new()))?,
</a>             node_tx,
             state_tx,
             proxied_reqs: HashMap::new(),
<a href="#h8-9" id="h8-9" class="h">@@ -429,8 +431,8 @@ mod tests {
</a>         let node = Node::new(
             &quot;a&quot;,
             vec![&quot;b&quot;.into(), &quot;c&quot;.into()],
<a href="#h8-9-3" id="h8-9-3" class="d">-            Log::new(log::Test::new())?,
</a><a href="#h8-9-4" id="h8-9-4" class="d">-            TestState::new(0),
</a><a href="#h8-9-5" id="h8-9-5" class="i">+            Log::new(Box::new(log::Test::new()))?,
</a><a href="#h8-9-6" id="h8-9-6" class="i">+            Box::new(TestState::new(0)),
</a>             node_tx,
         )
         .await?;
<a href="#h8-10" id="h8-10" class="h">@@ -448,13 +450,13 @@ mod tests {
</a>     #[tokio::test]
     async fn new_loads_term() -&gt; Result&lt;()&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h8-10-3" id="h8-10-3" class="d">-        let store = log::Test::new();
</a><a href="#h8-10-4" id="h8-10-4" class="i">+        let store = Box::new(log::Test::new());
</a>         Log::new(store.clone())?.save_term(3, Some(&quot;c&quot;))?;
         let node = Node::new(
             &quot;a&quot;,
             vec![&quot;b&quot;.into(), &quot;c&quot;.into()],
             Log::new(store)?,
<a href="#h8-10-10" id="h8-10-10" class="d">-            TestState::new(0),
</a><a href="#h8-10-11" id="h8-10-11" class="i">+            Box::new(TestState::new(0)),
</a>             node_tx,
         )
         .await?;
<a href="#h8-11" id="h8-11" class="h">@@ -468,13 +470,13 @@ mod tests {
</a>     #[tokio::test(core_threads = 2)]
     async fn new_state_apply_all() -&gt; Result&lt;()&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h8-11-3" id="h8-11-3" class="d">-        let mut log = Log::new(log::Test::new())?;
</a><a href="#h8-11-4" id="h8-11-4" class="i">+        let mut log = Log::new(Box::new(log::Test::new()))?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
         log.commit(3)?;
         log.append(2, Some(vec![0x03]))?;
<a href="#h8-11-10" id="h8-11-10" class="d">-        let state = TestState::new(0);
</a><a href="#h8-11-11" id="h8-11-11" class="i">+        let state = Box::new(TestState::new(0));
</a> 
         Node::new(&quot;a&quot;, vec![&quot;b&quot;.into(), &quot;c&quot;.into()], log, state.clone(), node_tx).await?;
         tokio::time::delay_for(std::time::Duration::from_millis(100)).await;
<a href="#h8-12" id="h8-12" class="h">@@ -486,13 +488,13 @@ mod tests {
</a>     #[tokio::test(core_threads = 2)]
     async fn new_state_apply_partial() -&gt; Result&lt;()&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h8-12-3" id="h8-12-3" class="d">-        let mut log = Log::new(log::Test::new())?;
</a><a href="#h8-12-4" id="h8-12-4" class="i">+        let mut log = Log::new(Box::new(log::Test::new()))?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
         log.commit(3)?;
         log.append(2, Some(vec![0x03]))?;
<a href="#h8-12-10" id="h8-12-10" class="d">-        let state = TestState::new(2);
</a><a href="#h8-12-11" id="h8-12-11" class="i">+        let state = Box::new(TestState::new(2));
</a> 
         Node::new(&quot;a&quot;, vec![&quot;b&quot;.into(), &quot;c&quot;.into()], log, state.clone(), node_tx).await?;
         tokio::time::delay_for(std::time::Duration::from_millis(100)).await;
<a href="#h8-13" id="h8-13" class="h">@@ -504,13 +506,13 @@ mod tests {
</a>     #[tokio::test(core_threads = 2)]
     async fn new_state_apply_missing() -&gt; Result&lt;()&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h8-13-3" id="h8-13-3" class="d">-        let mut log = Log::new(log::Test::new())?;
</a><a href="#h8-13-4" id="h8-13-4" class="i">+        let mut log = Log::new(Box::new(log::Test::new()))?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
         log.commit(3)?;
         log.append(2, Some(vec![0x03]))?;
<a href="#h8-13-10" id="h8-13-10" class="d">-        let state = TestState::new(4);
</a><a href="#h8-13-11" id="h8-13-11" class="i">+        let state = Box::new(TestState::new(4));
</a> 
         assert_eq!(
             Node::new(&quot;a&quot;, vec![&quot;b&quot;.into(), &quot;c&quot;.into()], log, state.clone(), node_tx).await.err(),
<a href="#h8-14" id="h8-14" class="h">@@ -524,8 +526,14 @@ mod tests {
</a>     #[tokio::test]
     async fn new_single() -&gt; Result&lt;()&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h8-14-3" id="h8-14-3" class="d">-        let node =
</a><a href="#h8-14-4" id="h8-14-4" class="d">-            Node::new(&quot;a&quot;, vec![], Log::new(log::Test::new())?, TestState::new(0), node_tx).await?;
</a><a href="#h8-14-5" id="h8-14-5" class="i">+        let node = Node::new(
</a><a href="#h8-14-6" id="h8-14-6" class="i">+            &quot;a&quot;,
</a><a href="#h8-14-7" id="h8-14-7" class="i">+            vec![],
</a><a href="#h8-14-8" id="h8-14-8" class="i">+            Log::new(Box::new(log::Test::new()))?,
</a><a href="#h8-14-9" id="h8-14-9" class="i">+            Box::new(TestState::new(0)),
</a><a href="#h8-14-10" id="h8-14-10" class="i">+            node_tx,
</a><a href="#h8-14-11" id="h8-14-11" class="i">+        )
</a><a href="#h8-14-12" id="h8-14-12" class="i">+        .await?;
</a>         match node {
             Node::Leader(rolenode) =&gt; {
                 assert_eq!(rolenode.id, &quot;a&quot;.to_owned());
<b>diff --git a/<a id="h9" href="../file/src/raft/server.rs.html">src/raft/server.rs</a> b/<a href="../file/src/raft/server.rs.html">src/raft/server.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,6 +1,5 @@
</a> use super::{Address, Event, Log, Message, Node, Request, Response, State};
 use crate::error::{Error, Result};
<a href="#h9-0-2" id="h9-0-2" class="d">-use crate::storage::log;
</a> 
 use ::log::{debug, error};
 use futures::{sink::SinkExt as _, FutureExt as _};
<a href="#h9-1" id="h9-1" class="h">@@ -16,19 +15,19 @@ use uuid::Uuid;
</a> const TICK: Duration = Duration::from_millis(100);
 
 /// A Raft server.
<a href="#h9-1-3" id="h9-1-3" class="d">-pub struct Server&lt;L: log::Store&gt; {
</a><a href="#h9-1-4" id="h9-1-4" class="d">-    node: Node&lt;L&gt;,
</a><a href="#h9-1-5" id="h9-1-5" class="i">+pub struct Server {
</a><a href="#h9-1-6" id="h9-1-6" class="i">+    node: Node,
</a>     peers: HashMap&lt;String, String&gt;,
     node_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
 }
 
<a href="#h9-1-11" id="h9-1-11" class="d">-impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a><a href="#h9-1-12" id="h9-1-12" class="i">+impl Server {
</a>     /// Creates a new Raft cluster
<a href="#h9-1-14" id="h9-1-14" class="d">-    pub async fn new&lt;S: State + Send + &#39;static&gt;(
</a><a href="#h9-1-15" id="h9-1-15" class="i">+    pub async fn new(
</a>         id: &amp;str,
         peers: HashMap&lt;String, String&gt;,
<a href="#h9-1-18" id="h9-1-18" class="d">-        log: Log&lt;L&gt;,
</a><a href="#h9-1-19" id="h9-1-19" class="d">-        state: S,
</a><a href="#h9-1-20" id="h9-1-20" class="i">+        log: Log,
</a><a href="#h9-1-21" id="h9-1-21" class="i">+        state: Box&lt;dyn State&gt;,
</a>     ) -&gt; Result&lt;Self&gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         Ok(Self {
<a href="#h9-2" id="h9-2" class="h">@@ -69,7 +68,7 @@ impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a> 
     /// Runs the event loop.
     async fn eventloop(
<a href="#h9-2-3" id="h9-2-3" class="d">-        mut node: Node&lt;L&gt;,
</a><a href="#h9-2-4" id="h9-2-4" class="i">+        mut node: Node,
</a>         mut node_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
         mut client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Result&lt;Response&gt;&gt;)&gt;,
         mut tcp_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
<b>diff --git a/<a id="h10" href="../file/src/raft/state.rs.html">src/raft/state.rs</a> b/<a href="../file/src/raft/state.rs.html">src/raft/state.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -7,7 +7,7 @@ use tokio::stream::StreamExt as _;
</a> use tokio::sync::mpsc;
 
 /// A Raft-managed state machine.
<a href="#h10-0-3" id="h10-0-3" class="d">-pub trait State {
</a><a href="#h10-0-4" id="h10-0-4" class="i">+pub trait State: Send {
</a>     /// Returns the last applied index from the state machine, used when initializing the driver.
     fn applied_index(&amp;self) -&gt; u64;
 
<a href="#h10-1" id="h10-1" class="h">@@ -31,7 +31,7 @@ pub enum Instruction {
</a>     /// Query the state machine when the given index has been confirmed by vote.
     Query { id: Vec&lt;u8&gt;, address: Address, command: Vec&lt;u8&gt;, index: u64, quorum: u64 },
     /// Extend the given server status and return it to the given address.
<a href="#h10-1-3" id="h10-1-3" class="d">-    Status { id: Vec&lt;u8&gt;, address: Address, status: Status },
</a><a href="#h10-1-4" id="h10-1-4" class="i">+    Status { id: Vec&lt;u8&gt;, address: Address, status: Box&lt;Status&gt; },
</a>     /// Votes for queries at the given commit index.
     Vote { index: u64, address: Address },
 }
<a href="#h10-2" id="h10-2" class="h">@@ -72,10 +72,10 @@ impl Driver {
</a>     }
 
     /// Drives a state machine.
<a href="#h10-2-3" id="h10-2-3" class="d">-    pub async fn drive&lt;S: State&gt;(mut self, mut state: S) -&gt; Result&lt;()&gt; {
</a><a href="#h10-2-4" id="h10-2-4" class="i">+    pub async fn drive(mut self, mut state: Box&lt;dyn State&gt;) -&gt; Result&lt;()&gt; {
</a>         debug!(&quot;Starting state machine driver&quot;);
         while let Some(instruction) = self.state_rx.next().await {
<a href="#h10-2-7" id="h10-2-7" class="d">-            if let Err(error) = self.execute(instruction, &amp;mut state).await {
</a><a href="#h10-2-8" id="h10-2-8" class="i">+            if let Err(error) = self.execute(instruction, &amp;mut *state).await {
</a>                 error!(&quot;Halting state machine due to error: {}&quot;, error);
                 return Err(error);
             }
<a href="#h10-3" id="h10-3" class="h">@@ -85,7 +85,7 @@ impl Driver {
</a>     }
 
     /// Synchronously (re)plays a set of log entries, for initial sync.
<a href="#h10-3-3" id="h10-3-3" class="d">-    pub fn replay&lt;&#39;a, S: State&gt;(&amp;mut self, state: &amp;mut S, mut scan: Scan&lt;&#39;a&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h10-3-4" id="h10-3-4" class="i">+    pub fn replay&lt;&#39;a&gt;(&amp;mut self, state: &amp;mut dyn State, mut scan: Scan&lt;&#39;a&gt;) -&gt; Result&lt;()&gt; {
</a>         while let Some(entry) = scan.next().transpose()? {
             debug!(&quot;Replaying {:?}&quot;, entry);
             if let Some(command) = entry.command {
<a href="#h10-4" id="h10-4" class="h">@@ -99,7 +99,7 @@ impl Driver {
</a>     }
 
     /// Executes a state machine instruction.
<a href="#h10-4-3" id="h10-4-3" class="d">-    pub async fn execute&lt;S: State&gt;(&amp;mut self, i: Instruction, state: &amp;mut S) -&gt; Result&lt;()&gt; {
</a><a href="#h10-4-4" id="h10-4-4" class="i">+    pub async fn execute(&amp;mut self, i: Instruction, state: &amp;mut dyn State) -&gt; Result&lt;()&gt; {
</a>         debug!(&quot;Executing {:?}&quot;, i);
         match i {
             Instruction::Abort =&gt; {
<a href="#h10-5" id="h10-5" class="h">@@ -142,7 +142,7 @@ impl Driver {
</a>                 status.apply_index = state.applied_index();
                 self.send(
                     address,
<a href="#h10-5-3" id="h10-5-3" class="d">-                    Event::ClientResponse { id, response: Ok(Response::Status(status)) },
</a><a href="#h10-5-4" id="h10-5-4" class="i">+                    Event::ClientResponse { id, response: Ok(Response::Status(*status)) },
</a>                 )?;
             }
 
<a href="#h10-6" id="h10-6" class="h">@@ -184,7 +184,7 @@ impl Driver {
</a>     }
 
     /// Executes any queries that are ready.
<a href="#h10-6-3" id="h10-6-3" class="d">-    fn query_execute&lt;S: State&gt;(&amp;mut self, state: &amp;mut S) -&gt; Result&lt;()&gt; {
</a><a href="#h10-6-4" id="h10-6-4" class="i">+    fn query_execute(&amp;mut self, state: &amp;mut dyn State) -&gt; Result&lt;()&gt; {
</a>         for query in self.query_ready(self.applied_index) {
             debug!(&quot;Executing query {:?}&quot;, query.command);
             let result = state.query(query.command);
<a href="#h10-7" id="h10-7" class="h">@@ -286,10 +286,12 @@ pub mod tests {
</a>         }
     }
 
<a href="#h10-7-3" id="h10-7-3" class="d">-    async fn setup(
</a><a href="#h10-7-4" id="h10-7-4" class="d">-    ) -&gt; Result&lt;(TestState, mpsc::UnboundedSender&lt;Instruction&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt;
</a><a href="#h10-7-5" id="h10-7-5" class="d">-    {
</a><a href="#h10-7-6" id="h10-7-6" class="d">-        let state = TestState::new(0);
</a><a href="#h10-7-7" id="h10-7-7" class="i">+    async fn setup() -&gt; Result&lt;(
</a><a href="#h10-7-8" id="h10-7-8" class="i">+        Box&lt;TestState&gt;,
</a><a href="#h10-7-9" id="h10-7-9" class="i">+        mpsc::UnboundedSender&lt;Instruction&gt;,
</a><a href="#h10-7-10" id="h10-7-10" class="i">+        mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h10-7-11" id="h10-7-11" class="i">+    )&gt; {
</a><a href="#h10-7-12" id="h10-7-12" class="i">+        let state = Box::new(TestState::new(0));
</a>         let (state_tx, state_rx) = mpsc::unbounded_channel();
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         tokio::spawn(Driver::new(state_rx, node_tx).drive(state.clone()));
<b>diff --git a/<a id="h11" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -11,8 +11,6 @@ use ::log::{error, info};
</a> use futures::sink::SinkExt as _;
 use serde_derive::{Deserialize, Serialize};
 use std::collections::HashMap;
<a href="#h11-0-3" id="h11-0-3" class="d">-use std::fs;
</a><a href="#h11-0-4" id="h11-0-4" class="d">-use std::path::Path;
</a> use tokio::net::{TcpListener, TcpStream};
 use tokio::stream::StreamExt as _;
 use tokio::sync::mpsc;
<a href="#h11-1" id="h11-1" class="h">@@ -20,7 +18,7 @@ use tokio_util::codec::{Framed, LengthDelimitedCodec};
</a> 
 /// A toyDB server.
 pub struct Server {
<a href="#h11-1-3" id="h11-1-3" class="d">-    raft: raft::Server&lt;log::Hybrid&gt;,
</a><a href="#h11-1-4" id="h11-1-4" class="i">+    raft: raft::Server,
</a>     raft_listener: Option&lt;TcpListener&gt;,
     sql_listener: Option&lt;TcpListener&gt;,
 }
<a href="#h11-2" id="h11-2" class="h">@@ -30,18 +28,15 @@ impl Server {
</a>     pub async fn new(
         id: &amp;str,
         peers: HashMap&lt;String, String&gt;,
<a href="#h11-2-3" id="h11-2-3" class="d">-        dir: &amp;str,
</a><a href="#h11-2-4" id="h11-2-4" class="d">-        sync: bool,
</a><a href="#h11-2-5" id="h11-2-5" class="i">+        raft_store: Box&lt;dyn log::Store&gt;,
</a><a href="#h11-2-6" id="h11-2-6" class="i">+        sql_store: Box&lt;dyn kv::Store&gt;,
</a>     ) -&gt; Result&lt;Self&gt; {
<a href="#h11-2-8" id="h11-2-8" class="d">-        let path = Path::new(dir);
</a><a href="#h11-2-9" id="h11-2-9" class="d">-        fs::create_dir_all(path)?;
</a>         Ok(Server {
             raft: raft::Server::new(
                 id,
                 peers,
<a href="#h11-2-14" id="h11-2-14" class="d">-                raft::Log::new(log::Hybrid::new(&amp;path, sync)?)?,
</a><a href="#h11-2-15" id="h11-2-15" class="d">-                // Use an in-memory database since the Raft log is durable
</a><a href="#h11-2-16" id="h11-2-16" class="d">-                sql::engine::Raft::new_state(kv::MVCC::new(kv::Memory::new()))?,
</a><a href="#h11-2-17" id="h11-2-17" class="i">+                raft::Log::new(raft_store)?,
</a><a href="#h11-2-18" id="h11-2-18" class="i">+                Box::new(sql::engine::Raft::new_state(kv::MVCC::new(sql_store))?),
</a>             )
             .await?,
             raft_listener: None,
<b>diff --git a/<a id="h12" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -5,24 +5,25 @@ use crate::error::{Error, Result};
</a> use crate::storage::kv;
 
 use serde::{Deserialize, Serialize};
<a href="#h12-0-3" id="h12-0-3" class="i">+use std::clone::Clone;
</a> use std::collections::HashSet;
 
 /// A SQL engine based on an underlying MVCC key/value store
<a href="#h12-0-7" id="h12-0-7" class="d">-pub struct KV&lt;S: kv::Store&gt; {
</a><a href="#h12-0-8" id="h12-0-8" class="i">+pub struct KV {
</a>     /// The underlying key/value store
<a href="#h12-0-10" id="h12-0-10" class="d">-    pub(super) kv: kv::MVCC&lt;S&gt;,
</a><a href="#h12-0-11" id="h12-0-11" class="i">+    pub(super) kv: kv::MVCC,
</a> }
 
 // FIXME Implement Clone manually due to https://github.com/rust-lang/rust/issues/26925
<a href="#h12-0-15" id="h12-0-15" class="d">-impl&lt;S: kv::Store&gt; std::clone::Clone for KV&lt;S&gt; {
</a><a href="#h12-0-16" id="h12-0-16" class="i">+impl Clone for KV {
</a>     fn clone(&amp;self) -&gt; Self {
         KV::new(self.kv.clone())
     }
 }
 
<a href="#h12-0-22" id="h12-0-22" class="d">-impl&lt;S: kv::Store&gt; KV&lt;S&gt; {
</a><a href="#h12-0-23" id="h12-0-23" class="i">+impl KV {
</a>     /// Creates a new key/value-based SQL engine
<a href="#h12-0-25" id="h12-0-25" class="d">-    pub fn new(kv: kv::MVCC&lt;S&gt;) -&gt; Self {
</a><a href="#h12-0-26" id="h12-0-26" class="i">+    pub fn new(kv: kv::MVCC) -&gt; Self {
</a>         Self { kv }
     }
 
<a href="#h12-1" id="h12-1" class="h">@@ -37,8 +38,8 @@ impl&lt;S: kv::Store&gt; KV&lt;S&gt; {
</a>     }
 }
 
<a href="#h12-1-3" id="h12-1-3" class="d">-impl&lt;S: kv::Store&gt; super::Engine for KV&lt;S&gt; {
</a><a href="#h12-1-4" id="h12-1-4" class="d">-    type Transaction = Transaction&lt;S&gt;;
</a><a href="#h12-1-5" id="h12-1-5" class="i">+impl super::Engine for KV {
</a><a href="#h12-1-6" id="h12-1-6" class="i">+    type Transaction = Transaction;
</a> 
     fn begin(&amp;self, mode: super::Mode) -&gt; Result&lt;Self::Transaction&gt; {
         Ok(Self::Transaction::new(self.kv.begin_with_mode(mode)?))
<a href="#h12-2" id="h12-2" class="h">@@ -60,13 +61,13 @@ fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a> }
 
 /// An SQL transaction based on an MVCC key/value transaction
<a href="#h12-2-3" id="h12-2-3" class="d">-pub struct Transaction&lt;S: kv::Store&gt; {
</a><a href="#h12-2-4" id="h12-2-4" class="d">-    txn: kv::mvcc::Transaction&lt;S&gt;,
</a><a href="#h12-2-5" id="h12-2-5" class="i">+pub struct Transaction {
</a><a href="#h12-2-6" id="h12-2-6" class="i">+    txn: kv::mvcc::Transaction,
</a> }
 
<a href="#h12-2-9" id="h12-2-9" class="d">-impl&lt;S: kv::Store&gt; Transaction&lt;S&gt; {
</a><a href="#h12-2-10" id="h12-2-10" class="i">+impl Transaction {
</a>     /// Creates a new SQL transaction from an MVCC transaction
<a href="#h12-2-12" id="h12-2-12" class="d">-    fn new(txn: kv::mvcc::Transaction&lt;S&gt;) -&gt; Self {
</a><a href="#h12-2-13" id="h12-2-13" class="i">+    fn new(txn: kv::mvcc::Transaction) -&gt; Self {
</a>         Self { txn }
     }
 
<a href="#h12-3" id="h12-3" class="h">@@ -100,7 +101,7 @@ impl&lt;S: kv::Store&gt; Transaction&lt;S&gt; {
</a>     }
 }
 
<a href="#h12-3-3" id="h12-3-3" class="d">-impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a><a href="#h12-3-4" id="h12-3-4" class="i">+impl super::Transaction for Transaction {
</a>     fn id(&amp;self) -&gt; u64 {
         self.txn.id()
     }
<a href="#h12-4" id="h12-4" class="h">@@ -240,7 +241,7 @@ impl&lt;S: kv::Store&gt; super::Transaction for Transaction&lt;S&gt; {
</a>     }
 }
 
<a href="#h12-4-3" id="h12-4-3" class="d">-impl&lt;S: kv::Store&gt; Catalog for Transaction&lt;S&gt; {
</a><a href="#h12-4-4" id="h12-4-4" class="i">+impl Catalog for Transaction {
</a>     fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;()&gt; {
         if self.read_table(&amp;table.name)?.is_some() {
             return Err(Error::Value(format!(&quot;Table {} already exists&quot;, table.name)));
<b>diff --git a/<a id="h13" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -75,7 +75,7 @@ impl Raft {
</a>     }
 
     /// Creates an underlying state machine for a Raft engine.
<a href="#h13-0-3" id="h13-0-3" class="d">-    pub fn new_state&lt;S: kv::Store&gt;(kv: kv::MVCC&lt;S&gt;) -&gt; Result&lt;State&lt;S&gt;&gt; {
</a><a href="#h13-0-4" id="h13-0-4" class="i">+    pub fn new_state(kv: kv::MVCC) -&gt; Result&lt;State&gt; {
</a>         State::new(kv)
     }
 
<a href="#h13-1" id="h13-1" class="h">@@ -263,16 +263,16 @@ impl Catalog for Transaction {
</a> }
 
 /// The Raft state machine for the Raft-based SQL engine, using a KV SQL engine
<a href="#h13-1-3" id="h13-1-3" class="d">-pub struct State&lt;S: kv::Store&gt; {
</a><a href="#h13-1-4" id="h13-1-4" class="i">+pub struct State {
</a>     /// The underlying KV SQL engine
<a href="#h13-1-6" id="h13-1-6" class="d">-    engine: super::KV&lt;S&gt;,
</a><a href="#h13-1-7" id="h13-1-7" class="i">+    engine: super::KV,
</a>     /// The last applied index
     applied_index: u64,
 }
 
<a href="#h13-1-12" id="h13-1-12" class="d">-impl&lt;S: kv::Store&gt; State&lt;S&gt; {
</a><a href="#h13-1-13" id="h13-1-13" class="i">+impl State {
</a>     /// Creates a new Raft state maching using the given MVCC key/value store
<a href="#h13-1-15" id="h13-1-15" class="d">-    pub fn new(store: kv::MVCC&lt;S&gt;) -&gt; Result&lt;Self&gt; {
</a><a href="#h13-1-16" id="h13-1-16" class="i">+    pub fn new(store: kv::MVCC) -&gt; Result&lt;Self&gt; {
</a>         let engine = super::KV::new(store);
         let applied_index = engine
             .get_metadata(b&quot;applied_index&quot;)?
<a href="#h13-2" id="h13-2" class="h">@@ -308,7 +308,7 @@ impl&lt;S: kv::Store&gt; State&lt;S&gt; {
</a>     }
 }
 
<a href="#h13-2-3" id="h13-2-3" class="d">-impl&lt;S: kv::Store&gt; raft::State for State&lt;S&gt; {
</a><a href="#h13-2-4" id="h13-2-4" class="i">+impl raft::State for State {
</a>     fn applied_index(&amp;self) -&gt; u64 {
         self.applied_index
     }
<b>diff --git a/<a id="h14" href="../file/src/storage/kv/memory.rs.html">src/storage/kv/memory.rs</a> b/<a href="../file/src/storage/kv/memory.rs.html">src/storage/kv/memory.rs</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -1,9 +1,10 @@
</a><a href="#h14-0-0" id="h14-0-0" class="d">-use super::{Scan, Store};
</a><a href="#h14-0-1" id="h14-0-1" class="i">+use super::{Range, Scan, Store};
</a> use crate::error::{Error, Result};
 
 use std::cmp::Ordering;
<a href="#h14-0-5" id="h14-0-5" class="i">+use std::fmt::Display;
</a> use std::mem::replace;
<a href="#h14-0-7" id="h14-0-7" class="d">-use std::ops::{Bound, Deref, DerefMut, RangeBounds};
</a><a href="#h14-0-8" id="h14-0-8" class="i">+use std::ops::{Bound, Deref, DerefMut};
</a> use std::sync::{Arc, RwLock};
 
 /// The default B+tree order, i.e. maximum number of children per node.
<a href="#h14-1" id="h14-1" class="h">@@ -24,6 +25,12 @@ pub struct Memory {
</a>     root: Arc&lt;RwLock&lt;Node&gt;&gt;,
 }
 
<a href="#h14-1-3" id="h14-1-3" class="i">+impl Display for Memory {
</a><a href="#h14-1-4" id="h14-1-4" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h14-1-5" id="h14-1-5" class="i">+        write!(f, &quot;memory&quot;)
</a><a href="#h14-1-6" id="h14-1-6" class="i">+    }
</a><a href="#h14-1-7" id="h14-1-7" class="i">+}
</a><a href="#h14-1-8" id="h14-1-8" class="i">+
</a> impl Memory {
     /// Creates a new in-memory store using the default order.
     pub fn new() -&gt; Self {
<a href="#h14-2" id="h14-2" class="h">@@ -53,7 +60,7 @@ impl Store for Memory {
</a>         Ok(self.root.read()?.get(key))
     }
 
<a href="#h14-2-3" id="h14-2-3" class="d">-    fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Scan {
</a><a href="#h14-2-4" id="h14-2-4" class="i">+    fn scan(&amp;self, range: Range) -&gt; Scan {
</a>         Box::new(Iter::new(self.root.clone(), range))
     }
 
<a href="#h14-3" id="h14-3" class="h">@@ -606,7 +613,7 @@ struct Iter {
</a>     /// The root node of the tree we&#39;re iterating across.
     root: Arc&lt;RwLock&lt;Node&gt;&gt;,
     /// The range we&#39;re iterating over.
<a href="#h14-3-3" id="h14-3-3" class="d">-    range: (Bound&lt;Vec&lt;u8&gt;&gt;, Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h14-3-4" id="h14-3-4" class="i">+    range: Range,
</a>     /// The front cursor keeps track of the last returned value from the front.
     front_cursor: Option&lt;Vec&lt;u8&gt;&gt;,
     /// The back cursor keeps track of the last returned value from the back.
<a href="#h14-4" id="h14-4" class="h">@@ -615,26 +622,15 @@ struct Iter {
</a> 
 impl Iter {
     /// Creates a new iterator.
<a href="#h14-4-3" id="h14-4-3" class="d">-    fn new(root: Arc&lt;RwLock&lt;Node&gt;&gt;, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self {
</a><a href="#h14-4-4" id="h14-4-4" class="d">-        // FIXME https://github.com/rust-lang/rust/issues/61356
</a><a href="#h14-4-5" id="h14-4-5" class="d">-        let start = match range.start_bound() {
</a><a href="#h14-4-6" id="h14-4-6" class="d">-            Bound::Excluded(k) =&gt; Bound::Excluded(k.clone()),
</a><a href="#h14-4-7" id="h14-4-7" class="d">-            Bound::Included(k) =&gt; Bound::Included(k.clone()),
</a><a href="#h14-4-8" id="h14-4-8" class="d">-            Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h14-4-9" id="h14-4-9" class="d">-        };
</a><a href="#h14-4-10" id="h14-4-10" class="d">-        let end = match range.end_bound() {
</a><a href="#h14-4-11" id="h14-4-11" class="d">-            Bound::Excluded(k) =&gt; Bound::Excluded(k.clone()),
</a><a href="#h14-4-12" id="h14-4-12" class="d">-            Bound::Included(k) =&gt; Bound::Included(k.clone()),
</a><a href="#h14-4-13" id="h14-4-13" class="d">-            Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h14-4-14" id="h14-4-14" class="d">-        };
</a><a href="#h14-4-15" id="h14-4-15" class="d">-        Self { root, range: (start, end), front_cursor: None, back_cursor: None }
</a><a href="#h14-4-16" id="h14-4-16" class="i">+    fn new(root: Arc&lt;RwLock&lt;Node&gt;&gt;, range: Range) -&gt; Self {
</a><a href="#h14-4-17" id="h14-4-17" class="i">+        Self { root, range, front_cursor: None, back_cursor: None }
</a>     }
 
     // next() with error handling.
     fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; {
         let root = self.root.read()?;
         let next = match &amp;self.front_cursor {
<a href="#h14-4-24" id="h14-4-24" class="d">-            None =&gt; match &amp;self.range.0 {
</a><a href="#h14-4-25" id="h14-4-25" class="i">+            None =&gt; match &amp;self.range.start {
</a>                 Bound::Included(k) =&gt; {
                     root.get(k).map(|v| (k.clone(), v)).or_else(|| root.get_next(k))
                 }
<a href="#h14-5" id="h14-5" class="h">@@ -661,7 +657,7 @@ impl Iter {
</a>     fn try_next_back(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; {
         let root = self.root.read()?;
         let prev = match &amp;self.back_cursor {
<a href="#h14-5-3" id="h14-5-3" class="d">-            None =&gt; match &amp;self.range.1 {
</a><a href="#h14-5-4" id="h14-5-4" class="i">+            None =&gt; match &amp;self.range.end {
</a>                 Bound::Included(k) =&gt; {
                     root.get(k).map(|v| (k.clone(), v)).or_else(|| root.get_prev(k))
                 }
<b>diff --git a/<a id="h15" href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a> b/<a href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -11,10 +11,11 @@ pub use std_memory::StdMemory;
</a> pub use test::Test;
 
 use crate::error::Result;
<a href="#h15-0-3" id="h15-0-3" class="d">-use std::ops::RangeBounds;
</a><a href="#h15-0-4" id="h15-0-4" class="i">+use std::fmt::Display;
</a><a href="#h15-0-5" id="h15-0-5" class="i">+use std::ops::{Bound, RangeBounds};
</a> 
 /// Key/value store.
<a href="#h15-0-8" id="h15-0-8" class="d">-pub trait Store {
</a><a href="#h15-0-9" id="h15-0-9" class="i">+pub trait Store: Display + Send + Sync {
</a>     /// Deletes a key, if it exists.
     fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt;;
 
<a href="#h15-1" id="h15-1" class="h">@@ -25,12 +26,69 @@ pub trait Store {
</a>     fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
 
     /// Returns an iterator over a range of key/value pairs.
<a href="#h15-1-3" id="h15-1-3" class="d">-    fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Scan;
</a><a href="#h15-1-4" id="h15-1-4" class="i">+    fn scan(&amp;self, range: Range) -&gt; Scan;
</a> 
     /// Writes a value for a key, replacing the existing value if any.
     fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;
 }
 
<a href="#h15-1-10" id="h15-1-10" class="i">+/// A scan range.
</a><a href="#h15-1-11" id="h15-1-11" class="i">+pub struct Range {
</a><a href="#h15-1-12" id="h15-1-12" class="i">+    start: Bound&lt;Vec&lt;u8&gt;&gt;,
</a><a href="#h15-1-13" id="h15-1-13" class="i">+    end: Bound&lt;Vec&lt;u8&gt;&gt;,
</a><a href="#h15-1-14" id="h15-1-14" class="i">+}
</a><a href="#h15-1-15" id="h15-1-15" class="i">+
</a><a href="#h15-1-16" id="h15-1-16" class="i">+impl Range {
</a><a href="#h15-1-17" id="h15-1-17" class="i">+    /// Creates a new range from the given Rust range. We can&#39;t use the RangeBounds directly in
</a><a href="#h15-1-18" id="h15-1-18" class="i">+    /// scan() since that prevents us from using Store as a trait object. Also, we can&#39;t take
</a><a href="#h15-1-19" id="h15-1-19" class="i">+    /// AsRef&lt;[u8]&gt; or other convenient types, since that won&#39;t work with e.g. .. ranges.
</a><a href="#h15-1-20" id="h15-1-20" class="i">+    pub fn from&lt;R: RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(range: R) -&gt; Self {
</a><a href="#h15-1-21" id="h15-1-21" class="i">+        Self {
</a><a href="#h15-1-22" id="h15-1-22" class="i">+            start: match range.start_bound() {
</a><a href="#h15-1-23" id="h15-1-23" class="i">+                Bound::Included(v) =&gt; Bound::Included(v.to_vec()),
</a><a href="#h15-1-24" id="h15-1-24" class="i">+                Bound::Excluded(v) =&gt; Bound::Excluded(v.to_vec()),
</a><a href="#h15-1-25" id="h15-1-25" class="i">+                Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h15-1-26" id="h15-1-26" class="i">+            },
</a><a href="#h15-1-27" id="h15-1-27" class="i">+            end: match range.end_bound() {
</a><a href="#h15-1-28" id="h15-1-28" class="i">+                Bound::Included(v) =&gt; Bound::Included(v.to_vec()),
</a><a href="#h15-1-29" id="h15-1-29" class="i">+                Bound::Excluded(v) =&gt; Bound::Excluded(v.to_vec()),
</a><a href="#h15-1-30" id="h15-1-30" class="i">+                Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h15-1-31" id="h15-1-31" class="i">+            },
</a><a href="#h15-1-32" id="h15-1-32" class="i">+        }
</a><a href="#h15-1-33" id="h15-1-33" class="i">+    }
</a><a href="#h15-1-34" id="h15-1-34" class="i">+
</a><a href="#h15-1-35" id="h15-1-35" class="i">+    /// Checks if the given value is contained in the range.
</a><a href="#h15-1-36" id="h15-1-36" class="i">+    fn contains(&amp;self, v: &amp;[u8]) -&gt; bool {
</a><a href="#h15-1-37" id="h15-1-37" class="i">+        (match &amp;self.start {
</a><a href="#h15-1-38" id="h15-1-38" class="i">+            Bound::Included(start) =&gt; &amp;**start &lt;= v,
</a><a href="#h15-1-39" id="h15-1-39" class="i">+            Bound::Excluded(start) =&gt; &amp;**start &lt; v,
</a><a href="#h15-1-40" id="h15-1-40" class="i">+            Bound::Unbounded =&gt; true,
</a><a href="#h15-1-41" id="h15-1-41" class="i">+        }) &amp;&amp; (match &amp;self.end {
</a><a href="#h15-1-42" id="h15-1-42" class="i">+            Bound::Included(end) =&gt; v &lt;= &amp;**end,
</a><a href="#h15-1-43" id="h15-1-43" class="i">+            Bound::Excluded(end) =&gt; v &lt; &amp;**end,
</a><a href="#h15-1-44" id="h15-1-44" class="i">+            Bound::Unbounded =&gt; true,
</a><a href="#h15-1-45" id="h15-1-45" class="i">+        })
</a><a href="#h15-1-46" id="h15-1-46" class="i">+    }
</a><a href="#h15-1-47" id="h15-1-47" class="i">+}
</a><a href="#h15-1-48" id="h15-1-48" class="i">+
</a><a href="#h15-1-49" id="h15-1-49" class="i">+impl RangeBounds&lt;Vec&lt;u8&gt;&gt; for Range {
</a><a href="#h15-1-50" id="h15-1-50" class="i">+    fn start_bound(&amp;self) -&gt; Bound&lt;&amp;Vec&lt;u8&gt;&gt; {
</a><a href="#h15-1-51" id="h15-1-51" class="i">+        match &amp;self.start {
</a><a href="#h15-1-52" id="h15-1-52" class="i">+            Bound::Included(v) =&gt; Bound::Included(v),
</a><a href="#h15-1-53" id="h15-1-53" class="i">+            Bound::Excluded(v) =&gt; Bound::Excluded(v),
</a><a href="#h15-1-54" id="h15-1-54" class="i">+            Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h15-1-55" id="h15-1-55" class="i">+        }
</a><a href="#h15-1-56" id="h15-1-56" class="i">+    }
</a><a href="#h15-1-57" id="h15-1-57" class="i">+
</a><a href="#h15-1-58" id="h15-1-58" class="i">+    fn end_bound(&amp;self) -&gt; Bound&lt;&amp;Vec&lt;u8&gt;&gt; {
</a><a href="#h15-1-59" id="h15-1-59" class="i">+        match &amp;self.end {
</a><a href="#h15-1-60" id="h15-1-60" class="i">+            Bound::Included(v) =&gt; Bound::Included(v),
</a><a href="#h15-1-61" id="h15-1-61" class="i">+            Bound::Excluded(v) =&gt; Bound::Excluded(v),
</a><a href="#h15-1-62" id="h15-1-62" class="i">+            Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h15-1-63" id="h15-1-63" class="i">+        }
</a><a href="#h15-1-64" id="h15-1-64" class="i">+    }
</a><a href="#h15-1-65" id="h15-1-65" class="i">+}
</a><a href="#h15-1-66" id="h15-1-66" class="i">+
</a> /// Iterator over a key/value range.
 pub type Scan&lt;&#39;a&gt; = Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; + &#39;a&gt;;
 
<a href="#h15-2" id="h15-2" class="h">@@ -85,16 +143,16 @@ trait TestSuite&lt;S: Store&gt; {
</a>         }
         let mut expect = items.clone();
         expect.sort_by(|a, b| a.0.cmp(&amp;b.0));
<a href="#h15-2-3" id="h15-2-3" class="d">-        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h15-2-4" id="h15-2-4" class="i">+        assert_eq!(expect, s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a>         expect.reverse();
<a href="#h15-2-6" id="h15-2-6" class="d">-        assert_eq!(expect, s.scan(..).rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h15-2-7" id="h15-2-7" class="i">+        assert_eq!(expect, s.scan(Range::from(..)).rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
         // Remove the items
         for (key, _) in items {
             s.delete(&amp;key)?;
             assert_eq!(None, s.get(&amp;key)?);
         }
<a href="#h15-2-14" id="h15-2-14" class="d">-        assert!(s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h15-2-15" id="h15-2-15" class="i">+        assert!(s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a> 
         Ok(())
     }
<a href="#h15-3" id="h15-3" class="h">@@ -114,7 +172,7 @@ trait TestSuite&lt;S: Store&gt; {
</a>                 (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                 (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
             ],
<a href="#h15-3-3" id="h15-3-3" class="d">-            s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h15-3-4" id="h15-3-4" class="i">+            s.scan(Range::from(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec())).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(
             vec![
<a href="#h15-4" id="h15-4" class="h">@@ -122,13 +180,13 @@ trait TestSuite&lt;S: Store&gt; {
</a>                 (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                 (b&quot;b&quot;.to_vec(), vec![0x02]),
             ],
<a href="#h15-4-3" id="h15-4-3" class="d">-            s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h15-4-4" id="h15-4-4" class="i">+            s.scan(Range::from(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec())).rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Inclusive/exclusive ranges
         assert_eq!(
             vec![(b&quot;b&quot;.to_vec(), vec![0x02]), (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),],
<a href="#h15-4-10" id="h15-4-10" class="d">-            s.scan(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h15-4-11" id="h15-4-11" class="i">+            s.scan(Range::from(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec())).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(
             vec![
<a href="#h15-5" id="h15-5" class="h">@@ -136,17 +194,17 @@ trait TestSuite&lt;S: Store&gt; {
</a>                 (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                 (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
             ],
<a href="#h15-5-3" id="h15-5-3" class="d">-            s.scan(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h15-5-4" id="h15-5-4" class="i">+            s.scan(Range::from(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec())).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Open ranges
         assert_eq!(
             vec![(b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]), (b&quot;c&quot;.to_vec(), vec![0x03]),],
<a href="#h15-5-10" id="h15-5-10" class="d">-            s.scan(b&quot;bb&quot;.to_vec()..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h15-5-11" id="h15-5-11" class="i">+            s.scan(Range::from(b&quot;bb&quot;.to_vec()..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         assert_eq!(
             vec![(b&quot;a&quot;.to_vec(), vec![0x01]), (b&quot;b&quot;.to_vec(), vec![0x02]),],
<a href="#h15-5-15" id="h15-5-15" class="d">-            s.scan(..=b&quot;b&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h15-5-16" id="h15-5-16" class="i">+            s.scan(Range::from(..=b&quot;b&quot;.to_vec())).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
 
         // Full range
<a href="#h15-6" id="h15-6" class="h">@@ -158,7 +216,7 @@ trait TestSuite&lt;S: Store&gt; {
</a>                 (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
                 (b&quot;c&quot;.to_vec(), vec![0x03]),
             ],
<a href="#h15-6-3" id="h15-6-3" class="d">-            s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h15-6-4" id="h15-6-4" class="i">+            s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>         );
         Ok(())
     }
<b>diff --git a/<a id="h16" href="../file/src/storage/kv/mvcc.rs.html">src/storage/kv/mvcc.rs</a> b/<a href="../file/src/storage/kv/mvcc.rs.html">src/storage/kv/mvcc.rs</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h16-0-0" id="h16-0-0" class="d">-use super::Store;
</a><a href="#h16-0-1" id="h16-0-1" class="i">+use super::{Range, Store};
</a> use crate::error::{Error, Result};
 
 use serde::{Deserialize, Serialize};
<a href="#h16-1" id="h16-1" class="h">@@ -12,41 +12,42 @@ use std::sync::{Arc, RwLock, RwLockReadGuard, RwLockWriteGuard};
</a> pub struct Status {
     pub txns: u64,
     pub txns_active: u64,
<a href="#h16-1-3" id="h16-1-3" class="i">+    pub storage: String,
</a> }
 
 /// An MVCC-based transactional key-value store.
<a href="#h16-1-7" id="h16-1-7" class="d">-pub struct MVCC&lt;S: Store&gt; {
</a><a href="#h16-1-8" id="h16-1-8" class="i">+pub struct MVCC {
</a>     /// The underlying KV store. It is protected by a mutex so it can be shared between multiple
     /// transactions.
<a href="#h16-1-11" id="h16-1-11" class="d">-    store: Arc&lt;RwLock&lt;S&gt;&gt;,
</a><a href="#h16-1-12" id="h16-1-12" class="i">+    store: Arc&lt;RwLock&lt;Box&lt;dyn Store&gt;&gt;&gt;,
</a> }
 
 // FIXME Implement Clone manually due to https://github.com/rust-lang/rust/issues/26925
<a href="#h16-1-16" id="h16-1-16" class="d">-impl&lt;S: Store&gt; Clone for MVCC&lt;S&gt; {
</a><a href="#h16-1-17" id="h16-1-17" class="i">+impl Clone for MVCC {
</a>     fn clone(&amp;self) -&gt; Self {
         MVCC { store: self.store.clone() }
     }
 }
 
<a href="#h16-1-23" id="h16-1-23" class="d">-impl&lt;S: Store&gt; MVCC&lt;S&gt; {
</a><a href="#h16-1-24" id="h16-1-24" class="i">+impl MVCC {
</a>     /// Creates a new MVCC key-value store with the given key-value store for storage.
<a href="#h16-1-26" id="h16-1-26" class="d">-    pub fn new(store: S) -&gt; Self {
</a><a href="#h16-1-27" id="h16-1-27" class="i">+    pub fn new(store: Box&lt;dyn Store&gt;) -&gt; Self {
</a>         Self { store: Arc::new(RwLock::new(store)) }
     }
 
     /// Begins a new transaction in read-write mode.
     #[allow(dead_code)]
<a href="#h16-1-33" id="h16-1-33" class="d">-    pub fn begin(&amp;self) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a><a href="#h16-1-34" id="h16-1-34" class="i">+    pub fn begin(&amp;self) -&gt; Result&lt;Transaction&gt; {
</a>         Transaction::begin(self.store.clone(), Mode::ReadWrite)
     }
 
     /// Begins a new transaction in the given mode.
<a href="#h16-1-39" id="h16-1-39" class="d">-    pub fn begin_with_mode(&amp;self, mode: Mode) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a><a href="#h16-1-40" id="h16-1-40" class="i">+    pub fn begin_with_mode(&amp;self, mode: Mode) -&gt; Result&lt;Transaction&gt; {
</a>         Transaction::begin(self.store.clone(), mode)
     }
 
     /// Resumes a transaction with the given ID.
<a href="#h16-1-45" id="h16-1-45" class="d">-    pub fn resume(&amp;self, id: u64) -&gt; Result&lt;Transaction&lt;S&gt;&gt; {
</a><a href="#h16-1-46" id="h16-1-46" class="i">+    pub fn resume(&amp;self, id: u64) -&gt; Result&lt;Transaction&gt; {
</a>         Transaction::resume(self.store.clone(), id)
     }
 
<a href="#h16-2" id="h16-2" class="h">@@ -68,15 +69,18 @@ impl&lt;S: Store&gt; MVCC&lt;S&gt; {
</a>     // https://github.com/rust-lang/reference/issues/452
     #[allow(clippy::needless_return)]
     pub fn status(&amp;self) -&gt; Result&lt;Status&gt; {
<a href="#h16-2-3" id="h16-2-3" class="d">-        let session = self.store.read()?;
</a><a href="#h16-2-4" id="h16-2-4" class="i">+        let store = self.store.read()?;
</a>         return Ok(Status {
<a href="#h16-2-6" id="h16-2-6" class="d">-            txns: match session.get(&amp;Key::TxnNext.encode())? {
</a><a href="#h16-2-7" id="h16-2-7" class="i">+            txns: match store.get(&amp;Key::TxnNext.encode())? {
</a>                 Some(ref v) =&gt; deserialize(v)?,
                 None =&gt; 1,
             } - 1,
<a href="#h16-2-11" id="h16-2-11" class="d">-            txns_active: session
</a><a href="#h16-2-12" id="h16-2-12" class="d">-                .scan(&amp;Key::TxnActive(0).encode()..&amp;Key::TxnActive(std::u64::MAX).encode())
</a><a href="#h16-2-13" id="h16-2-13" class="i">+            txns_active: store
</a><a href="#h16-2-14" id="h16-2-14" class="i">+                .scan(Range::from(
</a><a href="#h16-2-15" id="h16-2-15" class="i">+                    Key::TxnActive(0).encode()..Key::TxnActive(std::u64::MAX).encode(),
</a><a href="#h16-2-16" id="h16-2-16" class="i">+                ))
</a>                 .try_fold(0, |count, r| r.map(|_| count + 1))?,
<a href="#h16-2-18" id="h16-2-18" class="i">+            storage: store.to_string(),
</a>         });
     }
 }
<a href="#h16-3" id="h16-3" class="h">@@ -92,9 +96,9 @@ fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a> }
 
 /// An MVCC transaction.
<a href="#h16-3-3" id="h16-3-3" class="d">-pub struct Transaction&lt;S: Store&gt; {
</a><a href="#h16-3-4" id="h16-3-4" class="i">+pub struct Transaction {
</a>     /// The underlying store for the transaction. Shared between transactions using a mutex.
<a href="#h16-3-6" id="h16-3-6" class="d">-    store: Arc&lt;RwLock&lt;S&gt;&gt;,
</a><a href="#h16-3-7" id="h16-3-7" class="i">+    store: Arc&lt;RwLock&lt;Box&lt;dyn Store&gt;&gt;&gt;,
</a>     /// The unique transaction ID.
     id: u64,
     /// The transaction mode.
<a href="#h16-4" id="h16-4" class="h">@@ -103,9 +107,9 @@ pub struct Transaction&lt;S: Store&gt; {
</a>     snapshot: Snapshot,
 }
 
<a href="#h16-4-3" id="h16-4-3" class="d">-impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a><a href="#h16-4-4" id="h16-4-4" class="i">+impl Transaction {
</a>     /// Begins a new transaction in the given mode.
<a href="#h16-4-6" id="h16-4-6" class="d">-    fn begin(store: Arc&lt;RwLock&lt;S&gt;&gt;, mode: Mode) -&gt; Result&lt;Self&gt; {
</a><a href="#h16-4-7" id="h16-4-7" class="i">+    fn begin(store: Arc&lt;RwLock&lt;Box&lt;dyn Store&gt;&gt;&gt;, mode: Mode) -&gt; Result&lt;Self&gt; {
</a>         let mut session = store.write()?;
 
         let id = match session.get(&amp;Key::TxnNext.encode())? {
<a href="#h16-5" id="h16-5" class="h">@@ -128,7 +132,7 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>     }
 
     /// Resumes an active transaction with the given ID. Errors if the transaction is not active.
<a href="#h16-5-3" id="h16-5-3" class="d">-    fn resume(store: Arc&lt;RwLock&lt;S&gt;&gt;, id: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h16-5-4" id="h16-5-4" class="i">+    fn resume(store: Arc&lt;RwLock&lt;Box&lt;dyn Store&gt;&gt;&gt;, id: u64) -&gt; Result&lt;Self&gt; {
</a>         let session = store.read()?;
         let mode = match session.get(&amp;Key::TxnActive(id).encode())? {
             Some(v) =&gt; deserialize(&amp;v)?,
<a href="#h16-6" id="h16-6" class="h">@@ -164,10 +168,10 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>         let mut session = self.store.write()?;
         if self.mode.mutable() {
             let mut rollback = Vec::new();
<a href="#h16-6-3" id="h16-6-3" class="d">-            let mut scan = session.scan(
</a><a href="#h16-6-4" id="h16-6-4" class="d">-                &amp;Key::TxnUpdate(self.id, vec![]).encode()
</a><a href="#h16-6-5" id="h16-6-5" class="d">-                    ..&amp;Key::TxnUpdate(self.id + 1, vec![]).encode(),
</a><a href="#h16-6-6" id="h16-6-6" class="d">-            );
</a><a href="#h16-6-7" id="h16-6-7" class="i">+            let mut scan = session.scan(Range::from(
</a><a href="#h16-6-8" id="h16-6-8" class="i">+                Key::TxnUpdate(self.id, vec![]).encode()
</a><a href="#h16-6-9" id="h16-6-9" class="i">+                    ..Key::TxnUpdate(self.id + 1, vec![]).encode(),
</a><a href="#h16-6-10" id="h16-6-10" class="i">+            ));
</a>             while let Some((key, _)) = scan.next().transpose()? {
                 match Key::decode(&amp;key)? {
                     Key::TxnUpdate(_, updated_key) =&gt; rollback.push(updated_key),
<a href="#h16-7" id="h16-7" class="h">@@ -192,9 +196,9 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>     pub fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
         let session = self.store.read()?;
         let mut scan = session
<a href="#h16-7-3" id="h16-7-3" class="d">-            .scan(
</a><a href="#h16-7-4" id="h16-7-4" class="i">+            .scan(Range::from(
</a>                 Key::Record(key.to_vec(), 0).encode()..=Key::Record(key.to_vec(), self.id).encode(),
<a href="#h16-7-6" id="h16-7-6" class="d">-            )
</a><a href="#h16-7-7" id="h16-7-7" class="i">+            ))
</a>             .rev();
         while let Some((k, v)) = scan.next().transpose()? {
             match Key::decode(&amp;k)? {
<a href="#h16-8" id="h16-8" class="h">@@ -254,10 +258,10 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>         // versions that aren&#39;t visible to us.
         let min = self.snapshot.invisible.iter().min().cloned().unwrap_or(self.id + 1);
         let mut scan = session
<a href="#h16-8-3" id="h16-8-3" class="d">-            .scan(
</a><a href="#h16-8-4" id="h16-8-4" class="i">+            .scan(Range::from(
</a>                 Key::Record(key.to_vec(), min).encode()
                     ..=Key::Record(key.to_vec(), std::u64::MAX).encode(),
<a href="#h16-8-7" id="h16-8-7" class="d">-            )
</a><a href="#h16-8-8" id="h16-8-8" class="i">+            ))
</a>             .rev();
         while let Some((k, _)) = scan.next().transpose()? {
             match Key::decode(&amp;k)? {
<a href="#h16-9" id="h16-9" class="h">@@ -327,9 +331,10 @@ struct Snapshot {
</a> 
 impl Snapshot {
     /// Takes a new snapshot, persisting it as `Key::TxnSnapshot(version)`.
<a href="#h16-9-3" id="h16-9-3" class="d">-    fn take(session: &amp;mut RwLockWriteGuard&lt;impl Store&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h16-9-4" id="h16-9-4" class="i">+    fn take(session: &amp;mut RwLockWriteGuard&lt;Box&lt;dyn Store&gt;&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a>         let mut snapshot = Self { version, invisible: HashSet::new() };
<a href="#h16-9-6" id="h16-9-6" class="d">-        let mut scan = session.scan(&amp;Key::TxnActive(0).encode()..&amp;Key::TxnActive(version).encode());
</a><a href="#h16-9-7" id="h16-9-7" class="i">+        let mut scan =
</a><a href="#h16-9-8" id="h16-9-8" class="i">+            session.scan(Range::from(Key::TxnActive(0).encode()..Key::TxnActive(version).encode()));
</a>         while let Some((key, _)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::TxnActive(id) =&gt; snapshot.invisible.insert(id),
<a href="#h16-10" id="h16-10" class="h">@@ -342,7 +347,7 @@ impl Snapshot {
</a>     }
 
     /// Restores an existing snapshot from `Key::TxnSnapshot(version)`, or errors if not found.
<a href="#h16-10-3" id="h16-10-3" class="d">-    fn restore(session: &amp;RwLockReadGuard&lt;impl Store&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h16-10-4" id="h16-10-4" class="i">+    fn restore(session: &amp;RwLockReadGuard&lt;Box&lt;dyn Store&gt;&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a>         match session.get(&amp;Key::TxnSnapshot(version).encode())? {
             Some(ref v) =&gt; Ok(Self { version, invisible: deserialize(v)? }),
             None =&gt; Err(Error::Value(format!(&quot;Snapshot not found for version {}&quot;, version))),
<a href="#h16-11" id="h16-11" class="h">@@ -461,9 +466,9 @@ impl Key {
</a> /// FIXME This should really just wrap the underlying iterator via a RwLock guard for the store,
 /// but making the lifetimes work out is non-trivial. See also:
 /// https://users.rust-lang.org/t/creating-an-iterator-over-mutex-contents-cannot-infer-an-appropriate-lifetime/24458
<a href="#h16-11-3" id="h16-11-3" class="d">-pub struct Scan&lt;S: Store&gt; {
</a><a href="#h16-11-4" id="h16-11-4" class="i">+pub struct Scan {
</a>     /// The KV store used for the scan.
<a href="#h16-11-6" id="h16-11-6" class="d">-    store: Arc&lt;RwLock&lt;S&gt;&gt;,
</a><a href="#h16-11-7" id="h16-11-7" class="i">+    store: Arc&lt;RwLock&lt;Box&lt;dyn Store&gt;&gt;&gt;,
</a>     /// The snapshot the scan is running in.
     snapshot: Snapshot,
     /// Keeps track of the remaining range bounds we&#39;re iterating over.
<a href="#h16-12" id="h16-12" class="h">@@ -474,10 +479,10 @@ pub struct Scan&lt;S: Store&gt; {
</a>     next_back_returned: Option&lt;Vec&lt;u8&gt;&gt;,
 }
 
<a href="#h16-12-3" id="h16-12-3" class="d">-impl&lt;S: Store&gt; Scan&lt;S&gt; {
</a><a href="#h16-12-4" id="h16-12-4" class="i">+impl Scan {
</a>     /// Creates a new scan.
     fn new(
<a href="#h16-12-7" id="h16-12-7" class="d">-        store: Arc&lt;RwLock&lt;S&gt;&gt;,
</a><a href="#h16-12-8" id="h16-12-8" class="i">+        store: Arc&lt;RwLock&lt;Box&lt;dyn Store&gt;&gt;&gt;,
</a>         snapshot: Snapshot,
         range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;,
     ) -&gt; Result&lt;Self&gt; {
<a href="#h16-13" id="h16-13" class="h">@@ -504,7 +509,7 @@ impl&lt;S: Store&gt; Scan&lt;S&gt; {
</a>     // next() with error handling.
     fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; {
         let session = self.store.read()?;
<a href="#h16-13-3" id="h16-13-3" class="d">-        let mut range = session.scan(self.bounds.clone());
</a><a href="#h16-13-4" id="h16-13-4" class="i">+        let mut range = session.scan(Range::from(self.bounds.clone()));
</a>         while let Some((k, v)) = range.next().transpose()? {
             // Keep track of iterator progress
             self.bounds.0 = Bound::Excluded(k.clone());
<a href="#h16-14" id="h16-14" class="h">@@ -540,7 +545,7 @@ impl&lt;S: Store&gt; Scan&lt;S&gt; {
</a>     /// next_back() with error handling.
     fn try_next_back(&amp;mut self) -&gt; Result&lt;Option&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; {
         let session = self.store.read()?;
<a href="#h16-14-3" id="h16-14-3" class="d">-        let mut range = session.scan(self.bounds.clone());
</a><a href="#h16-14-4" id="h16-14-4" class="i">+        let mut range = session.scan(Range::from(self.bounds.clone()));
</a>         while let Some((k, v)) = range.next_back().transpose()? {
             // Keep track of iterator progress
             self.bounds.1 = Bound::Excluded(k.clone());
<a href="#h16-15" id="h16-15" class="h">@@ -567,7 +572,7 @@ impl&lt;S: Store&gt; Scan&lt;S&gt; {
</a>     }
 }
 
<a href="#h16-15-3" id="h16-15-3" class="d">-impl&lt;S: Store&gt; Iterator for Scan&lt;S&gt; {
</a><a href="#h16-15-4" id="h16-15-4" class="i">+impl Iterator for Scan {
</a>     type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
 
     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
<a href="#h16-16" id="h16-16" class="h">@@ -575,7 +580,7 @@ impl&lt;S: Store&gt; Iterator for Scan&lt;S&gt; {
</a>     }
 }
 
<a href="#h16-16-3" id="h16-16-3" class="d">-impl&lt;S: Store&gt; DoubleEndedIterator for Scan&lt;S&gt; {
</a><a href="#h16-16-4" id="h16-16-4" class="i">+impl DoubleEndedIterator for Scan {
</a>     fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
         self.try_next_back().transpose()
     }
<a href="#h16-17" id="h16-17" class="h">@@ -586,8 +591,8 @@ pub mod tests {
</a>     use super::super::Test;
     use super::*;
 
<a href="#h16-17-3" id="h16-17-3" class="d">-    fn setup() -&gt; MVCC&lt;Test&gt; {
</a><a href="#h16-17-4" id="h16-17-4" class="d">-        MVCC::new(Test::new())
</a><a href="#h16-17-5" id="h16-17-5" class="i">+    fn setup() -&gt; MVCC {
</a><a href="#h16-17-6" id="h16-17-6" class="i">+        MVCC::new(Box::new(Test::new()))
</a>     }
 
     #[test]
<b>diff --git a/<a id="h17" href="../file/src/storage/kv/std_memory.rs.html">src/storage/kv/std_memory.rs</a> b/<a href="../file/src/storage/kv/std_memory.rs.html">src/storage/kv/std_memory.rs</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -1,8 +1,8 @@
</a><a href="#h17-0-0" id="h17-0-0" class="d">-use super::{Scan, Store};
</a><a href="#h17-0-1" id="h17-0-1" class="i">+use super::{Range, Scan, Store};
</a> use crate::error::Result;
 
 use std::collections::BTreeMap;
<a href="#h17-0-5" id="h17-0-5" class="d">-use std::ops::RangeBounds;
</a><a href="#h17-0-6" id="h17-0-6" class="i">+use std::fmt::Display;
</a> 
 /// In-memory key-value store using the Rust standard library B-tree implementation.
 pub struct StdMemory {
<a href="#h17-1" id="h17-1" class="h">@@ -16,6 +16,12 @@ impl StdMemory {
</a>     }
 }
 
<a href="#h17-1-3" id="h17-1-3" class="i">+impl Display for StdMemory {
</a><a href="#h17-1-4" id="h17-1-4" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h17-1-5" id="h17-1-5" class="i">+        write!(f, &quot;stdmemory&quot;)
</a><a href="#h17-1-6" id="h17-1-6" class="i">+    }
</a><a href="#h17-1-7" id="h17-1-7" class="i">+}
</a><a href="#h17-1-8" id="h17-1-8" class="i">+
</a> impl Store for StdMemory {
     fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
         Ok(())
<a href="#h17-2" id="h17-2" class="h">@@ -30,7 +36,7 @@ impl Store for StdMemory {
</a>         Ok(self.data.get(key).cloned())
     }
 
<a href="#h17-2-3" id="h17-2-3" class="d">-    fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Scan {
</a><a href="#h17-2-4" id="h17-2-4" class="i">+    fn scan(&amp;self, range: Range) -&gt; Scan {
</a>         Box::new(self.data.range(range).map(|(k, v)| Ok((k.clone(), v.clone()))))
     }
 
<b>diff --git a/<a id="h18" href="../file/src/storage/kv/test.rs.html">src/storage/kv/test.rs</a> b/<a href="../file/src/storage/kv/test.rs.html">src/storage/kv/test.rs</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -1,7 +1,7 @@
</a><a href="#h18-0-0" id="h18-0-0" class="d">-use super::{Memory, Scan, Store};
</a><a href="#h18-0-1" id="h18-0-1" class="i">+use super::{Memory, Range, Scan, Store};
</a> use crate::error::Result;
 
<a href="#h18-0-4" id="h18-0-4" class="d">-use std::ops::RangeBounds;
</a><a href="#h18-0-5" id="h18-0-5" class="i">+use std::fmt::Display;
</a> use std::sync::{Arc, RwLock};
 
 /// Key-value storage backend for testing. Protects an inner Memory backend using a mutex, so it can
<a href="#h18-1" id="h18-1" class="h">@@ -18,6 +18,12 @@ impl Test {
</a>     }
 }
 
<a href="#h18-1-3" id="h18-1-3" class="i">+impl Display for Test {
</a><a href="#h18-1-4" id="h18-1-4" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h18-1-5" id="h18-1-5" class="i">+        write!(f, &quot;test&quot;)
</a><a href="#h18-1-6" id="h18-1-6" class="i">+    }
</a><a href="#h18-1-7" id="h18-1-7" class="i">+}
</a><a href="#h18-1-8" id="h18-1-8" class="i">+
</a> impl Store for Test {
     fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
         self.kv.write()?.delete(key)
<a href="#h18-2" id="h18-2" class="h">@@ -31,7 +37,7 @@ impl Store for Test {
</a>         self.kv.read()?.get(key)
     }
 
<a href="#h18-2-3" id="h18-2-3" class="d">-    fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Scan {
</a><a href="#h18-2-4" id="h18-2-4" class="i">+    fn scan(&amp;self, range: Range) -&gt; Scan {
</a>         // Since the mutex guard is scoped to this method, we simply buffer the result.
         Box::new(self.kv.read().unwrap().scan(range).collect::&lt;Vec&lt;Result&lt;_&gt;&gt;&gt;().into_iter())
     }
<b>diff --git a/<a id="h19" href="../file/src/storage/log/hybrid.rs.html">src/storage/log/hybrid.rs</a> b/<a href="../file/src/storage/log/hybrid.rs.html">src/storage/log/hybrid.rs</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -1,11 +1,12 @@
</a><a href="#h19-0-0" id="h19-0-0" class="d">-use super::{Scan, Store};
</a><a href="#h19-0-1" id="h19-0-1" class="i">+use super::{Range, Scan, Store};
</a> use crate::error::{Error, Result};
 
 use std::cmp::{max, min};
 use std::collections::{BTreeMap, HashMap, VecDeque};
<a href="#h19-0-6" id="h19-0-6" class="d">-use std::fs::{File, OpenOptions};
</a><a href="#h19-0-7" id="h19-0-7" class="i">+use std::fmt::Display;
</a><a href="#h19-0-8" id="h19-0-8" class="i">+use std::fs::{create_dir_all, File, OpenOptions};
</a> use std::io::{BufReader, BufWriter, Read, Seek as _, SeekFrom, Write};
<a href="#h19-0-10" id="h19-0-10" class="d">-use std::ops::{Bound, RangeBounds};
</a><a href="#h19-0-11" id="h19-0-11" class="i">+use std::ops::Bound;
</a> use std::path::Path;
 use std::sync::{Mutex, MutexGuard};
 
<a href="#h19-1" id="h19-1" class="h">@@ -36,9 +37,17 @@ pub struct Hybrid {
</a>     sync: bool,
 }
 
<a href="#h19-1-3" id="h19-1-3" class="i">+impl Display for Hybrid {
</a><a href="#h19-1-4" id="h19-1-4" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h19-1-5" id="h19-1-5" class="i">+        write!(f, &quot;hybrid&quot;)
</a><a href="#h19-1-6" id="h19-1-6" class="i">+    }
</a><a href="#h19-1-7" id="h19-1-7" class="i">+}
</a><a href="#h19-1-8" id="h19-1-8" class="i">+
</a> impl Hybrid {
     /// Creates or opens a new hybrid log, with files in the given directory.
     pub fn new(dir: &amp;Path, sync: bool) -&gt; Result&lt;Self&gt; {
<a href="#h19-1-12" id="h19-1-12" class="i">+        create_dir_all(dir)?;
</a><a href="#h19-1-13" id="h19-1-13" class="i">+
</a>         let file =
             OpenOptions::new().read(true).write(true).create(true).open(dir.join(&quot;raft-log&quot;))?;
 
<a href="#h19-2" id="h19-2" class="h">@@ -156,17 +165,17 @@ impl Store for Hybrid {
</a>         self.index.len() as u64 + self.uncommitted.len() as u64
     }
 
<a href="#h19-2-3" id="h19-2-3" class="d">-    fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan {
</a><a href="#h19-2-4" id="h19-2-4" class="d">-        let start = match range.start_bound() {
</a><a href="#h19-2-5" id="h19-2-5" class="i">+    fn scan(&amp;self, range: Range) -&gt; Scan {
</a><a href="#h19-2-6" id="h19-2-6" class="i">+        let start = match range.start {
</a>             Bound::Included(0) =&gt; 1,
<a href="#h19-2-8" id="h19-2-8" class="d">-            Bound::Included(n) =&gt; *n,
</a><a href="#h19-2-9" id="h19-2-9" class="d">-            Bound::Excluded(n) =&gt; *n + 1,
</a><a href="#h19-2-10" id="h19-2-10" class="i">+            Bound::Included(n) =&gt; n,
</a><a href="#h19-2-11" id="h19-2-11" class="i">+            Bound::Excluded(n) =&gt; n + 1,
</a>             Bound::Unbounded =&gt; 1,
         };
<a href="#h19-2-14" id="h19-2-14" class="d">-        let end = match range.end_bound() {
</a><a href="#h19-2-15" id="h19-2-15" class="d">-            Bound::Included(n) =&gt; *n,
</a><a href="#h19-2-16" id="h19-2-16" class="i">+        let end = match range.end {
</a><a href="#h19-2-17" id="h19-2-17" class="i">+            Bound::Included(n) =&gt; n,
</a>             Bound::Excluded(0) =&gt; 0,
<a href="#h19-2-19" id="h19-2-19" class="d">-            Bound::Excluded(n) =&gt; *n - 1,
</a><a href="#h19-2-20" id="h19-2-20" class="i">+            Bound::Excluded(n) =&gt; n - 1,
</a>             Bound::Unbounded =&gt; self.len(),
         };
 
<a href="#h19-3" id="h19-3" class="h">@@ -207,6 +216,10 @@ impl Store for Hybrid {
</a>         scan
     }
 
<a href="#h19-3-3" id="h19-3-3" class="i">+    fn size(&amp;self) -&gt; u64 {
</a><a href="#h19-3-4" id="h19-3-4" class="i">+        self.index.iter().next_back().map(|(_, (pos, size))| *pos + *size as u64).unwrap_or(0)
</a><a href="#h19-3-5" id="h19-3-5" class="i">+    }
</a><a href="#h19-3-6" id="h19-3-6" class="i">+
</a>     fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt; {
         if index &lt; self.index.len() as u64 {
             return Err(Error::Internal(format!(
<a href="#h19-4" id="h19-4" class="h">@@ -278,7 +291,10 @@ fn test_persistent() -&gt; Result&lt;()&gt; {
</a> 
     let l = Hybrid::new(dir.as_ref(), true)?;
 
<a href="#h19-4-3" id="h19-4-3" class="d">-    assert_eq!(vec![vec![1], vec![2], vec![3]], l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h19-4-4" id="h19-4-4" class="i">+    assert_eq!(
</a><a href="#h19-4-5" id="h19-4-5" class="i">+        vec![vec![1], vec![2], vec![3]],
</a><a href="#h19-4-6" id="h19-4-6" class="i">+        l.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h19-4-7" id="h19-4-7" class="i">+    );
</a> 
     Ok(())
 }
<b>diff --git a/<a id="h20" href="../file/src/storage/log/memory.rs.html">src/storage/log/memory.rs</a> b/<a href="../file/src/storage/log/memory.rs.html">src/storage/log/memory.rs</a></b>
<a href="#h20-0" id="h20-0" class="h">@@ -1,8 +1,9 @@
</a><a href="#h20-0-0" id="h20-0-0" class="d">-use super::Store;
</a><a href="#h20-0-1" id="h20-0-1" class="i">+use super::{Range, Store};
</a> use crate::error::{Error, Result};
 
 use std::collections::HashMap;
<a href="#h20-0-5" id="h20-0-5" class="d">-use std::ops::{Bound, RangeBounds};
</a><a href="#h20-0-6" id="h20-0-6" class="i">+use std::fmt::Display;
</a><a href="#h20-0-7" id="h20-0-7" class="i">+use std::ops::Bound;
</a> 
 // An in-memory log store.
 pub struct Memory {
<a href="#h20-1" id="h20-1" class="h">@@ -18,6 +19,12 @@ impl Memory {
</a>     }
 }
 
<a href="#h20-1-3" id="h20-1-3" class="i">+impl Display for Memory {
</a><a href="#h20-1-4" id="h20-1-4" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h20-1-5" id="h20-1-5" class="i">+        write!(f, &quot;memory&quot;)
</a><a href="#h20-1-6" id="h20-1-6" class="i">+    }
</a><a href="#h20-1-7" id="h20-1-7" class="i">+}
</a><a href="#h20-1-8" id="h20-1-8" class="i">+
</a> impl Store for Memory {
     fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64&gt; {
         self.log.push(entry);
<a href="#h20-2" id="h20-2" class="h">@@ -53,20 +60,20 @@ impl Store for Memory {
</a>         self.log.len() as u64
     }
 
<a href="#h20-2-3" id="h20-2-3" class="d">-    fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; super::Scan {
</a><a href="#h20-2-4" id="h20-2-4" class="i">+    fn scan(&amp;self, range: Range) -&gt; super::Scan {
</a>         Box::new(
             self.log
                 .iter()
<a href="#h20-2-8" id="h20-2-8" class="d">-                .take(match range.end_bound() {
</a><a href="#h20-2-9" id="h20-2-9" class="d">-                    Bound::Included(n) =&gt; *n as usize,
</a><a href="#h20-2-10" id="h20-2-10" class="i">+                .take(match range.end {
</a><a href="#h20-2-11" id="h20-2-11" class="i">+                    Bound::Included(n) =&gt; n as usize,
</a>                     Bound::Excluded(0) =&gt; 0,
<a href="#h20-2-13" id="h20-2-13" class="d">-                    Bound::Excluded(n) =&gt; *n as usize - 1,
</a><a href="#h20-2-14" id="h20-2-14" class="i">+                    Bound::Excluded(n) =&gt; n as usize - 1,
</a>                     Bound::Unbounded =&gt; std::usize::MAX,
                 })
<a href="#h20-2-17" id="h20-2-17" class="d">-                .skip(match range.start_bound() {
</a><a href="#h20-2-18" id="h20-2-18" class="i">+                .skip(match range.start {
</a>                     Bound::Included(0) =&gt; 0,
<a href="#h20-2-20" id="h20-2-20" class="d">-                    Bound::Included(n) =&gt; *n as usize - 1,
</a><a href="#h20-2-21" id="h20-2-21" class="d">-                    Bound::Excluded(n) =&gt; *n as usize,
</a><a href="#h20-2-22" id="h20-2-22" class="i">+                    Bound::Included(n) =&gt; n as usize - 1,
</a><a href="#h20-2-23" id="h20-2-23" class="i">+                    Bound::Excluded(n) =&gt; n as usize,
</a>                     Bound::Unbounded =&gt; 0,
                 })
                 .cloned()
<a href="#h20-3" id="h20-3" class="h">@@ -74,6 +81,10 @@ impl Store for Memory {
</a>         )
     }
 
<a href="#h20-3-3" id="h20-3-3" class="i">+    fn size(&amp;self) -&gt; u64 {
</a><a href="#h20-3-4" id="h20-3-4" class="i">+        self.log.iter().map(|v| v.len() as u64).sum()
</a><a href="#h20-3-5" id="h20-3-5" class="i">+    }
</a><a href="#h20-3-6" id="h20-3-6" class="i">+
</a>     fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt; {
         if index &lt; self.committed {
             return Err(Error::Internal(format!(
<b>diff --git a/<a id="h21" href="../file/src/storage/log/mod.rs.html">src/storage/log/mod.rs</a> b/<a href="../file/src/storage/log/mod.rs.html">src/storage/log/mod.rs</a></b>
<a href="#h21-0" id="h21-0" class="h">@@ -10,10 +10,11 @@ pub use test::Test;
</a> 
 use crate::error::Result;
 
<a href="#h21-0-3" id="h21-0-3" class="d">-use std::ops::RangeBounds;
</a><a href="#h21-0-4" id="h21-0-4" class="i">+use std::fmt::Display;
</a><a href="#h21-0-5" id="h21-0-5" class="i">+use std::ops::{Bound, RangeBounds};
</a> 
 /// A log store. Entry indexes are 1-based, to match Raft semantics.
<a href="#h21-0-8" id="h21-0-8" class="d">-pub trait Store {
</a><a href="#h21-0-9" id="h21-0-9" class="i">+pub trait Store: Display + Sync + Send {
</a>     /// Appends a log entry, returning its index.
     fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64&gt;;
 
<a href="#h21-1" id="h21-1" class="h">@@ -30,7 +31,10 @@ pub trait Store {
</a>     fn len(&amp;self) -&gt; u64;
 
     /// Scans the log between the given indexes.
<a href="#h21-1-3" id="h21-1-3" class="d">-    fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan;
</a><a href="#h21-1-4" id="h21-1-4" class="i">+    fn scan(&amp;self, range: Range) -&gt; Scan;
</a><a href="#h21-1-5" id="h21-1-5" class="i">+
</a><a href="#h21-1-6" id="h21-1-6" class="i">+    /// Returns the size of the log, in bytes.
</a><a href="#h21-1-7" id="h21-1-7" class="i">+    fn size(&amp;self) -&gt; u64;
</a> 
     /// Truncates the log be removing any entries above the given index, and returns the
     /// highest index. Errors if asked to truncate any committed entries.
<a href="#h21-2" id="h21-2" class="h">@@ -48,6 +52,31 @@ pub trait Store {
</a>     }
 }
 
<a href="#h21-2-3" id="h21-2-3" class="i">+/// A scan range.
</a><a href="#h21-2-4" id="h21-2-4" class="i">+pub struct Range {
</a><a href="#h21-2-5" id="h21-2-5" class="i">+    start: Bound&lt;u64&gt;,
</a><a href="#h21-2-6" id="h21-2-6" class="i">+    end: Bound&lt;u64&gt;,
</a><a href="#h21-2-7" id="h21-2-7" class="i">+}
</a><a href="#h21-2-8" id="h21-2-8" class="i">+
</a><a href="#h21-2-9" id="h21-2-9" class="i">+impl Range {
</a><a href="#h21-2-10" id="h21-2-10" class="i">+    /// Creates a new range from the given Rust range. We can&#39;t use the RangeBounds directly in
</a><a href="#h21-2-11" id="h21-2-11" class="i">+    /// scan() since that prevents us from Store into a trait object.
</a><a href="#h21-2-12" id="h21-2-12" class="i">+    pub fn from(range: impl RangeBounds&lt;u64&gt;) -&gt; Self {
</a><a href="#h21-2-13" id="h21-2-13" class="i">+        Self {
</a><a href="#h21-2-14" id="h21-2-14" class="i">+            start: match range.start_bound() {
</a><a href="#h21-2-15" id="h21-2-15" class="i">+                Bound::Included(v) =&gt; Bound::Included(*v),
</a><a href="#h21-2-16" id="h21-2-16" class="i">+                Bound::Excluded(v) =&gt; Bound::Excluded(*v),
</a><a href="#h21-2-17" id="h21-2-17" class="i">+                Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h21-2-18" id="h21-2-18" class="i">+            },
</a><a href="#h21-2-19" id="h21-2-19" class="i">+            end: match range.end_bound() {
</a><a href="#h21-2-20" id="h21-2-20" class="i">+                Bound::Included(v) =&gt; Bound::Included(*v),
</a><a href="#h21-2-21" id="h21-2-21" class="i">+                Bound::Excluded(v) =&gt; Bound::Excluded(*v),
</a><a href="#h21-2-22" id="h21-2-22" class="i">+                Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h21-2-23" id="h21-2-23" class="i">+            },
</a><a href="#h21-2-24" id="h21-2-24" class="i">+        }
</a><a href="#h21-2-25" id="h21-2-25" class="i">+    }
</a><a href="#h21-2-26" id="h21-2-26" class="i">+}
</a><a href="#h21-2-27" id="h21-2-27" class="i">+
</a> /// Iterator over a log range.
 pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Vec&lt;u8&gt;&gt;&gt; + &#39;a&gt;;
 
<a href="#h21-3" id="h21-3" class="h">@@ -74,7 +103,10 @@ trait TestSuite&lt;S: Store&gt; {
</a>         assert_eq!(2, s.append(vec![0x02])?);
         assert_eq!(3, s.append(vec![0x03])?);
         assert_eq!(3, s.len());
<a href="#h21-3-3" id="h21-3-3" class="d">-        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-3-4" id="h21-3-4" class="i">+        assert_eq!(
</a><a href="#h21-3-5" id="h21-3-5" class="i">+            vec![vec![1], vec![2], vec![3]],
</a><a href="#h21-3-6" id="h21-3-6" class="i">+            s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h21-3-7" id="h21-3-7" class="i">+        );
</a>         Ok(())
     }
 
<a href="#h21-4" id="h21-4" class="h">@@ -94,7 +126,10 @@ trait TestSuite&lt;S: Store&gt; {
</a> 
         // Truncating beyond the end should be fine.
         assert_eq!(3, s.truncate(4)?);
<a href="#h21-4-3" id="h21-4-3" class="d">-        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-4-4" id="h21-4-4" class="i">+        assert_eq!(
</a><a href="#h21-4-5" id="h21-4-5" class="i">+            vec![vec![1], vec![2], vec![3]],
</a><a href="#h21-4-6" id="h21-4-6" class="i">+            s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h21-4-7" id="h21-4-7" class="i">+        );
</a> 
         // Truncating a committed entry should error.
         assert_eq!(
<a href="#h21-5" id="h21-5" class="h">@@ -104,7 +139,7 @@ trait TestSuite&lt;S: Store&gt; {
</a> 
         // Truncating above should work.
         assert_eq!(1, s.truncate(1)?);
<a href="#h21-5-3" id="h21-5-3" class="d">-        assert_eq!(vec![vec![1]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-5-4" id="h21-5-4" class="i">+        assert_eq!(vec![vec![1]], s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
         Ok(())
     }
<a href="#h21-6" id="h21-6" class="h">@@ -135,23 +170,29 @@ trait TestSuite&lt;S: Store&gt; {
</a>         s.append(vec![0x03])?;
         s.commit(2)?;
 
<a href="#h21-6-3" id="h21-6-3" class="d">-        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-4" id="h21-6-4" class="d">-
</a><a href="#h21-6-5" id="h21-6-5" class="d">-        assert_eq!(vec![vec![1]], s.scan(0..2).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-6" id="h21-6-6" class="d">-        assert_eq!(vec![vec![1], vec![2]], s.scan(1..3).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-7" id="h21-6-7" class="d">-        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(1..=3).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-8" id="h21-6-8" class="d">-        assert!(s.scan(3..1).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h21-6-9" id="h21-6-9" class="d">-        assert!(s.scan(1..1).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h21-6-10" id="h21-6-10" class="d">-        assert_eq!(vec![vec![2]], s.scan(2..=2).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-11" id="h21-6-11" class="d">-        assert_eq!(vec![vec![2], vec![3]], s.scan(2..5).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-12" id="h21-6-12" class="d">-
</a><a href="#h21-6-13" id="h21-6-13" class="d">-        assert!(s.scan(..0).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h21-6-14" id="h21-6-14" class="d">-        assert_eq!(vec![vec![1]], s.scan(..=1).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-15" id="h21-6-15" class="d">-        assert_eq!(vec![vec![1], vec![2]], s.scan(..3).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-16" id="h21-6-16" class="i">+        assert_eq!(
</a><a href="#h21-6-17" id="h21-6-17" class="i">+            vec![vec![1], vec![2], vec![3]],
</a><a href="#h21-6-18" id="h21-6-18" class="i">+            s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h21-6-19" id="h21-6-19" class="i">+        );
</a> 
<a href="#h21-6-21" id="h21-6-21" class="d">-        assert!(s.scan(4..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h21-6-22" id="h21-6-22" class="d">-        assert_eq!(vec![vec![3]], s.scan(3..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-23" id="h21-6-23" class="d">-        assert_eq!(vec![vec![2], vec![3]], s.scan(2..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-24" id="h21-6-24" class="i">+        assert_eq!(vec![vec![1]], s.scan(Range::from(0..2)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-25" id="h21-6-25" class="i">+        assert_eq!(vec![vec![1], vec![2]], s.scan(Range::from(1..3)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-26" id="h21-6-26" class="i">+        assert_eq!(
</a><a href="#h21-6-27" id="h21-6-27" class="i">+            vec![vec![1], vec![2], vec![3]],
</a><a href="#h21-6-28" id="h21-6-28" class="i">+            s.scan(Range::from(1..=3)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h21-6-29" id="h21-6-29" class="i">+        );
</a><a href="#h21-6-30" id="h21-6-30" class="i">+        assert!(s.scan(Range::from(3..1)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h21-6-31" id="h21-6-31" class="i">+        assert!(s.scan(Range::from(1..1)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h21-6-32" id="h21-6-32" class="i">+        assert_eq!(vec![vec![2]], s.scan(Range::from(2..=2)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-33" id="h21-6-33" class="i">+        assert_eq!(vec![vec![2], vec![3]], s.scan(Range::from(2..5)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-34" id="h21-6-34" class="i">+
</a><a href="#h21-6-35" id="h21-6-35" class="i">+        assert!(s.scan(Range::from(..0)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h21-6-36" id="h21-6-36" class="i">+        assert_eq!(vec![vec![1]], s.scan(Range::from(..=1)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-37" id="h21-6-37" class="i">+        assert_eq!(vec![vec![1], vec![2]], s.scan(Range::from(..3)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-38" id="h21-6-38" class="i">+
</a><a href="#h21-6-39" id="h21-6-39" class="i">+        assert!(s.scan(Range::from(4..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h21-6-40" id="h21-6-40" class="i">+        assert_eq!(vec![vec![3]], s.scan(Range::from(3..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h21-6-41" id="h21-6-41" class="i">+        assert_eq!(vec![vec![2], vec![3]], s.scan(Range::from(2..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
         Ok(())
     }
<b>diff --git a/<a id="h22" href="../file/src/storage/log/test.rs.html">src/storage/log/test.rs</a> b/<a href="../file/src/storage/log/test.rs.html">src/storage/log/test.rs</a></b>
<a href="#h22-0" id="h22-0" class="h">@@ -1,7 +1,7 @@
</a><a href="#h22-0-0" id="h22-0-0" class="d">-use super::{Memory, Scan, Store};
</a><a href="#h22-0-1" id="h22-0-1" class="i">+use super::{Memory, Range, Scan, Store};
</a> use crate::error::Result;
 
<a href="#h22-0-4" id="h22-0-4" class="d">-use std::ops::RangeBounds;
</a><a href="#h22-0-5" id="h22-0-5" class="i">+use std::fmt::Display;
</a> use std::sync::{Arc, RwLock};
 
 /// Log storage backend for testing. Protects an inner Memory backend using a mutex, so it can
<a href="#h22-1" id="h22-1" class="h">@@ -18,6 +18,12 @@ impl Test {
</a>     }
 }
 
<a href="#h22-1-3" id="h22-1-3" class="i">+impl Display for Test {
</a><a href="#h22-1-4" id="h22-1-4" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h22-1-5" id="h22-1-5" class="i">+        write!(f, &quot;test&quot;)
</a><a href="#h22-1-6" id="h22-1-6" class="i">+    }
</a><a href="#h22-1-7" id="h22-1-7" class="i">+}
</a><a href="#h22-1-8" id="h22-1-8" class="i">+
</a> impl Store for Test {
     fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64&gt; {
         self.store.write()?.append(entry)
<a href="#h22-2" id="h22-2" class="h">@@ -39,11 +45,15 @@ impl Store for Test {
</a>         self.store.read().unwrap().len()
     }
 
<a href="#h22-2-3" id="h22-2-3" class="d">-    fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan {
</a><a href="#h22-2-4" id="h22-2-4" class="i">+    fn scan(&amp;self, range: Range) -&gt; Scan {
</a>         // Since the mutex guard is scoped to this method, we simply buffer the result.
         Box::new(self.store.read().unwrap().scan(range).collect::&lt;Vec&lt;Result&lt;_&gt;&gt;&gt;().into_iter())
     }
 
<a href="#h22-2-9" id="h22-2-9" class="i">+    fn size(&amp;self) -&gt; u64 {
</a><a href="#h22-2-10" id="h22-2-10" class="i">+        self.store.read().unwrap().size()
</a><a href="#h22-2-11" id="h22-2-11" class="i">+    }
</a><a href="#h22-2-12" id="h22-2-12" class="i">+
</a>     fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64&gt; {
         self.store.write()?.truncate(index)
     }
<b>diff --git a/<a id="h23" href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a> b/<a href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a></b>
<a href="#h23-0" id="h23-0" class="h">@@ -128,8 +128,10 @@ async fn status() -&gt; Result&lt;()&gt; {
</a>                 node_last_index: vec![(&quot;test&quot;.to_string(), 26)].into_iter().collect(),
                 commit_index: 26,
                 apply_index: 26,
<a href="#h23-0-3" id="h23-0-3" class="i">+                storage: &quot;hybrid&quot;.into(),
</a><a href="#h23-0-4" id="h23-0-4" class="i">+                storage_size: 3239,
</a>             },
<a href="#h23-0-6" id="h23-0-6" class="d">-            mvcc: kv::mvcc::Status { txns: 1, txns_active: 0 },
</a><a href="#h23-0-7" id="h23-0-7" class="i">+            mvcc: kv::mvcc::Status { txns: 1, txns_active: 0, storage: &quot;memory&quot;.into() },
</a>         }
     );
     Ok(())
<b>diff --git a/<a id="h24" href="../file/tests/setup.rs.html">tests/setup.rs</a> b/<a href="../file/tests/setup.rs.html">tests/setup.rs</a></b>
<a href="#h24-0" id="h24-0" class="h">@@ -3,6 +3,7 @@
</a> use toydb::client::{Client, Pool};
 use toydb::error::Result;
 use toydb::server::Server;
<a href="#h24-0-3" id="h24-0-3" class="i">+use toydb::storage;
</a> 
 use futures_util::future::FutureExt as _;
 use pretty_assertions::assert_eq;
<a href="#h24-1" id="h24-1" class="h">@@ -74,7 +75,13 @@ pub async fn server(
</a>     peers: HashMap&lt;String, String&gt;,
 ) -&gt; Result&lt;Teardown&gt; {
     let dir = TempDir::new(&quot;toydb&quot;)?;
<a href="#h24-1-3" id="h24-1-3" class="d">-    let mut srv = Server::new(id, peers, &amp;dir.path().to_string_lossy(), false).await?;
</a><a href="#h24-1-4" id="h24-1-4" class="i">+    let mut srv = Server::new(
</a><a href="#h24-1-5" id="h24-1-5" class="i">+        id,
</a><a href="#h24-1-6" id="h24-1-6" class="i">+        peers,
</a><a href="#h24-1-7" id="h24-1-7" class="i">+        Box::new(storage::log::Hybrid::new(&amp;dir.path(), false)?),
</a><a href="#h24-1-8" id="h24-1-8" class="i">+        Box::new(storage::kv::Memory::new()),
</a><a href="#h24-1-9" id="h24-1-9" class="i">+    )
</a><a href="#h24-1-10" id="h24-1-10" class="i">+    .await?;
</a> 
     srv = srv.listen(addr_sql, addr_raft).await?;
     let (task, abort) = srv.serve().remote_handle();
<b>diff --git a/<a id="h25" href="../file/tests/sql/mod.rs.html">tests/sql/mod.rs</a> b/<a href="../file/tests/sql/mod.rs.html">tests/sql/mod.rs</a></b>
<a href="#h25-0" id="h25-0" class="h">@@ -7,8 +7,8 @@ use toydb::error::Result;
</a> use toydb::sql::engine::{Engine, KV};
 use toydb::storage::kv;
 
<a href="#h25-0-3" id="h25-0-3" class="d">-fn setup(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;KV&lt;kv::StdMemory&gt;&gt; {
</a><a href="#h25-0-4" id="h25-0-4" class="d">-    let engine = KV::new(kv::MVCC::new(kv::StdMemory::new()));
</a><a href="#h25-0-5" id="h25-0-5" class="i">+fn setup(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;KV&gt; {
</a><a href="#h25-0-6" id="h25-0-6" class="i">+    let engine = KV::new(kv::MVCC::new(Box::new(kv::Memory::new())));
</a>     let mut session = engine.session()?;
     session.execute(&quot;BEGIN&quot;)?;
     for query in queries {
</pre>
</div>
</body>
</html>
