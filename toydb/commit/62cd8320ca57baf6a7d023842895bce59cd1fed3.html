<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: moved all row validation into schema module - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/62cd8320ca57baf6a7d023842895bce59cd1fed3.html">62cd8320ca57baf6a7d023842895bce59cd1fed3</a>
<b>parent</b> <a href="../commit/1ca5e45a126f56d6ee3f189ffe00bdfd26967417.html">1ca5e45a126f56d6ee3f189ffe00bdfd26967417</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sat, 11 Jan 2020 14:53:18 +0100

sql: moved all row validation into schema module

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">148</td><td><span class="i">+++++++</span><span class="d">------------------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/types/schema.rs</a></td><td> | </td><td class="num">117</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">---------------------</span></td></tr>
</table></pre><pre>2 files changed, 99 insertions(+), 166 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -58,11 +58,7 @@ impl&lt;S: kv::storage::Storage&gt; super::Transaction for Transaction&lt;S&gt; {
</a>         let table = self
             .read_table(&amp;table)?
             .ok_or_else(|| Error::Value(format!(&quot;Table {} does not exist&quot;, table)))?;
<a href="#h0-0-3" id="h0-0-3" class="d">-
</a><a href="#h0-0-4" id="h0-0-4" class="d">-        // Validate row
</a><a href="#h0-0-5" id="h0-0-5" class="d">-        table.validate_row(&amp;row)?;
</a><a href="#h0-0-6" id="h0-0-6" class="d">-
</a><a href="#h0-0-7" id="h0-0-7" class="d">-        // Validate primary key conflicts
</a><a href="#h0-0-8" id="h0-0-8" class="i">+        table.validate_row(&amp;row, self)?;
</a>         let id = table.row_key(&amp;row)?;
         if self.read(&amp;table.name, &amp;id)?.is_some() {
             return Err(Error::Value(format!(
<a href="#h0-1" id="h0-1" class="h">@@ -70,45 +66,6 @@ impl&lt;S: kv::storage::Storage&gt; super::Transaction for Transaction&lt;S&gt; {
</a>                 id, table.name
             )));
         }
<a href="#h0-1-3" id="h0-1-3" class="d">-
</a><a href="#h0-1-4" id="h0-1-4" class="d">-        // Validate referential integrity
</a><a href="#h0-1-5" id="h0-1-5" class="d">-        for (target, pks) in table.row_references(&amp;row)?.into_iter() {
</a><a href="#h0-1-6" id="h0-1-6" class="d">-            for pk in pks.into_iter() {
</a><a href="#h0-1-7" id="h0-1-7" class="d">-                if target == table.name &amp;&amp; pk == table.row_key(&amp;row)? {
</a><a href="#h0-1-8" id="h0-1-8" class="d">-                    continue;
</a><a href="#h0-1-9" id="h0-1-9" class="d">-                }
</a><a href="#h0-1-10" id="h0-1-10" class="d">-                if self.read(&amp;target, &amp;pk)?.is_none() {
</a><a href="#h0-1-11" id="h0-1-11" class="d">-                    return Err(Error::Value(format!(
</a><a href="#h0-1-12" id="h0-1-12" class="d">-                        &quot;Referenced primary key {} in table {} does not exist&quot;,
</a><a href="#h0-1-13" id="h0-1-13" class="d">-                        pk, target,
</a><a href="#h0-1-14" id="h0-1-14" class="d">-                    )));
</a><a href="#h0-1-15" id="h0-1-15" class="d">-                }
</a><a href="#h0-1-16" id="h0-1-16" class="d">-            }
</a><a href="#h0-1-17" id="h0-1-17" class="d">-        }
</a><a href="#h0-1-18" id="h0-1-18" class="d">-
</a><a href="#h0-1-19" id="h0-1-19" class="d">-        // Validate uniqueness
</a><a href="#h0-1-20" id="h0-1-20" class="d">-        let unique: Vec&lt;_&gt; = table
</a><a href="#h0-1-21" id="h0-1-21" class="d">-            .columns
</a><a href="#h0-1-22" id="h0-1-22" class="d">-            .iter()
</a><a href="#h0-1-23" id="h0-1-23" class="d">-            .zip(row.iter())
</a><a href="#h0-1-24" id="h0-1-24" class="d">-            .enumerate()
</a><a href="#h0-1-25" id="h0-1-25" class="d">-            .filter(|(_i, (c, v))| c.unique &amp;&amp; !c.primary_key &amp;&amp; v != &amp;&amp;types::Value::Null)
</a><a href="#h0-1-26" id="h0-1-26" class="d">-            .map(|(i, (c, v))| (i, c, v))
</a><a href="#h0-1-27" id="h0-1-27" class="d">-            .collect();
</a><a href="#h0-1-28" id="h0-1-28" class="d">-        if !unique.is_empty() {
</a><a href="#h0-1-29" id="h0-1-29" class="d">-            let mut scan = self.scan(&amp;table.name)?;
</a><a href="#h0-1-30" id="h0-1-30" class="d">-            while let Some(r) = scan.next().transpose()? {
</a><a href="#h0-1-31" id="h0-1-31" class="d">-                for (i, c, v) in unique.iter() {
</a><a href="#h0-1-32" id="h0-1-32" class="d">-                    if &amp;r.get(*i).unwrap_or_else(|| &amp;types::Value::Null) == v {
</a><a href="#h0-1-33" id="h0-1-33" class="d">-                        return Err(Error::Value(format!(
</a><a href="#h0-1-34" id="h0-1-34" class="d">-                            &quot;Unique value {} already exists for column {}&quot;,
</a><a href="#h0-1-35" id="h0-1-35" class="d">-                            v, c.name
</a><a href="#h0-1-36" id="h0-1-36" class="d">-                        )));
</a><a href="#h0-1-37" id="h0-1-37" class="d">-                    }
</a><a href="#h0-1-38" id="h0-1-38" class="d">-                }
</a><a href="#h0-1-39" id="h0-1-39" class="d">-            }
</a><a href="#h0-1-40" id="h0-1-40" class="d">-        }
</a><a href="#h0-1-41" id="h0-1-41" class="d">-
</a>         self.txn.set(&amp;Key::Row(&amp;table.name, &amp;id).encode(), serialize(&amp;row)?)
     }
 
<a href="#h0-2" id="h0-2" class="h">@@ -116,36 +73,7 @@ impl&lt;S: kv::storage::Storage&gt; super::Transaction for Transaction&lt;S&gt; {
</a>         let table = self
             .read_table(&amp;table)?
             .ok_or_else(|| Error::Value(format!(&quot;Table {} does not exist&quot;, table)))?;
<a href="#h0-2-3" id="h0-2-3" class="d">-
</a><a href="#h0-2-4" id="h0-2-4" class="d">-        // FIXME We should avoid full table scans here, but let&#39;s wait until we build the
</a><a href="#h0-2-5" id="h0-2-5" class="d">-        // predicate pushdown infrastructure which we can use for this as well.
</a><a href="#h0-2-6" id="h0-2-6" class="d">-        for source in self.scan_tables()? {
</a><a href="#h0-2-7" id="h0-2-7" class="d">-            let refs: Vec&lt;_&gt; = source
</a><a href="#h0-2-8" id="h0-2-8" class="d">-                .references()
</a><a href="#h0-2-9" id="h0-2-9" class="d">-                .into_iter()
</a><a href="#h0-2-10" id="h0-2-10" class="d">-                .filter(|c| c.references == Some(table.name.clone()))
</a><a href="#h0-2-11" id="h0-2-11" class="d">-                .collect();
</a><a href="#h0-2-12" id="h0-2-12" class="d">-            if refs.is_empty() {
</a><a href="#h0-2-13" id="h0-2-13" class="d">-                continue;
</a><a href="#h0-2-14" id="h0-2-14" class="d">-            }
</a><a href="#h0-2-15" id="h0-2-15" class="d">-            let mut scan = self.scan(&amp;source.name)?;
</a><a href="#h0-2-16" id="h0-2-16" class="d">-            while let Some(row) = scan.next().transpose()? {
</a><a href="#h0-2-17" id="h0-2-17" class="d">-                let row = source.row_to_hashmap(row);
</a><a href="#h0-2-18" id="h0-2-18" class="d">-                for r in refs.iter() {
</a><a href="#h0-2-19" id="h0-2-19" class="d">-                    if row.get(&amp;r.name).unwrap_or(&amp;types::Value::Null) == id
</a><a href="#h0-2-20" id="h0-2-20" class="d">-                        &amp;&amp; (source.name != table.name
</a><a href="#h0-2-21" id="h0-2-21" class="d">-                            || row.get(&amp;table.primary_key()?.name).unwrap_or(&amp;types::Value::Null)
</a><a href="#h0-2-22" id="h0-2-22" class="d">-                                != id)
</a><a href="#h0-2-23" id="h0-2-23" class="d">-                    {
</a><a href="#h0-2-24" id="h0-2-24" class="d">-                        return Err(Error::Value(format!(
</a><a href="#h0-2-25" id="h0-2-25" class="d">-                            &quot;Primary key {} is referenced by table {} column {}&quot;,
</a><a href="#h0-2-26" id="h0-2-26" class="d">-                            id, source.name, r.name
</a><a href="#h0-2-27" id="h0-2-27" class="d">-                        )));
</a><a href="#h0-2-28" id="h0-2-28" class="d">-                    }
</a><a href="#h0-2-29" id="h0-2-29" class="d">-                }
</a><a href="#h0-2-30" id="h0-2-30" class="d">-            }
</a><a href="#h0-2-31" id="h0-2-31" class="d">-        }
</a><a href="#h0-2-32" id="h0-2-32" class="d">-
</a><a href="#h0-2-33" id="h0-2-33" class="i">+        table.assert_pk_unreferenced(id, self)?;
</a>         self.txn.delete(&amp;Key::Row(&amp;table.name, id).encode())
     }
 
<a href="#h0-3" id="h0-3" class="h">@@ -154,78 +82,26 @@ impl&lt;S: kv::storage::Storage&gt; super::Transaction for Transaction&lt;S&gt; {
</a>     }
 
     fn scan(&amp;self, table: &amp;str) -&gt; Result&lt;super::Scan, Error&gt; {
<a href="#h0-3-3" id="h0-3-3" class="d">-        let from = Key::RowStart(table).encode();
</a><a href="#h0-3-4" id="h0-3-4" class="d">-        let to = Key::RowEnd(table).encode();
</a><a href="#h0-3-5" id="h0-3-5" class="d">-        // FIXME We buffer results here, to avoid dealing with trait lifetimes
</a><a href="#h0-3-6" id="h0-3-6" class="d">-        // right now
</a><a href="#h0-3-7" id="h0-3-7" class="d">-        let iter = self
</a><a href="#h0-3-8" id="h0-3-8" class="d">-            .txn
</a><a href="#h0-3-9" id="h0-3-9" class="d">-            .scan(&amp;from..&amp;to)?
</a><a href="#h0-3-10" id="h0-3-10" class="d">-            .map(|res| match res {
</a><a href="#h0-3-11" id="h0-3-11" class="d">-                Ok((_, v)) =&gt; deserialize(&amp;v),
</a><a href="#h0-3-12" id="h0-3-12" class="d">-                Err(err) =&gt; Err(err),
</a><a href="#h0-3-13" id="h0-3-13" class="d">-            })
</a><a href="#h0-3-14" id="h0-3-14" class="d">-            .collect::&lt;Vec&lt;Result&lt;_, Error&gt;&gt;&gt;()
</a><a href="#h0-3-15" id="h0-3-15" class="d">-            .into_iter();
</a><a href="#h0-3-16" id="h0-3-16" class="d">-        Ok(Box::new(iter))
</a><a href="#h0-3-17" id="h0-3-17" class="i">+        // FIXME We buffer results here, to avoid dealing with trait lifetimes right now
</a><a href="#h0-3-18" id="h0-3-18" class="i">+        Ok(Box::new(
</a><a href="#h0-3-19" id="h0-3-19" class="i">+            self.txn
</a><a href="#h0-3-20" id="h0-3-20" class="i">+                .scan(&amp;Key::RowStart(table).encode()..&amp;Key::RowEnd(table).encode())?
</a><a href="#h0-3-21" id="h0-3-21" class="i">+                .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)))
</a><a href="#h0-3-22" id="h0-3-22" class="i">+                .collect::&lt;Vec&lt;Result&lt;_, Error&gt;&gt;&gt;()
</a><a href="#h0-3-23" id="h0-3-23" class="i">+                .into_iter(),
</a><a href="#h0-3-24" id="h0-3-24" class="i">+        ))
</a>     }
 
     fn update(&amp;mut self, table: &amp;str, id: &amp;types::Value, row: types::Row) -&gt; Result&lt;(), Error&gt; {
         let table = self
             .read_table(&amp;table)?
             .ok_or_else(|| Error::Value(format!(&quot;Table {} does not exist&quot;, table)))?;
<a href="#h0-3-31" id="h0-3-31" class="d">-
</a><a href="#h0-3-32" id="h0-3-32" class="d">-        // If the primary key changes, we do a delete and create
</a><a href="#h0-3-33" id="h0-3-33" class="i">+        // If the primary key changes we do a delete and create, otherwise we replace the row
</a>         if id != &amp;table.row_key(&amp;row)? {
             self.delete(&amp;table.name, id)?;
             self.create(&amp;table.name, row)
<a href="#h0-3-37" id="h0-3-37" class="d">-
</a><a href="#h0-3-38" id="h0-3-38" class="d">-        // Otherwise, we validate the new row and replace the existing one
</a>         } else {
<a href="#h0-3-40" id="h0-3-40" class="d">-            // Validate row
</a><a href="#h0-3-41" id="h0-3-41" class="d">-            table.validate_row(&amp;row)?;
</a><a href="#h0-3-42" id="h0-3-42" class="d">-
</a><a href="#h0-3-43" id="h0-3-43" class="d">-            // Validate referential integrity
</a><a href="#h0-3-44" id="h0-3-44" class="d">-            for (target, pks) in table.row_references(&amp;row)?.into_iter() {
</a><a href="#h0-3-45" id="h0-3-45" class="d">-                for pk in pks.into_iter() {
</a><a href="#h0-3-46" id="h0-3-46" class="d">-                    if target == table.name &amp;&amp; &amp;pk == id {
</a><a href="#h0-3-47" id="h0-3-47" class="d">-                        continue;
</a><a href="#h0-3-48" id="h0-3-48" class="d">-                    }
</a><a href="#h0-3-49" id="h0-3-49" class="d">-                    if self.read(&amp;target, &amp;pk)?.is_none() {
</a><a href="#h0-3-50" id="h0-3-50" class="d">-                        return Err(Error::Value(format!(
</a><a href="#h0-3-51" id="h0-3-51" class="d">-                            &quot;Referenced primary key {} in table {} does not exist&quot;,
</a><a href="#h0-3-52" id="h0-3-52" class="d">-                            pk, target,
</a><a href="#h0-3-53" id="h0-3-53" class="d">-                        )));
</a><a href="#h0-3-54" id="h0-3-54" class="d">-                    }
</a><a href="#h0-3-55" id="h0-3-55" class="d">-                }
</a><a href="#h0-3-56" id="h0-3-56" class="d">-            }
</a><a href="#h0-3-57" id="h0-3-57" class="d">-
</a><a href="#h0-3-58" id="h0-3-58" class="d">-            // Validate uniqueness
</a><a href="#h0-3-59" id="h0-3-59" class="d">-            let unique: Vec&lt;_&gt; = table
</a><a href="#h0-3-60" id="h0-3-60" class="d">-                .columns
</a><a href="#h0-3-61" id="h0-3-61" class="d">-                .iter()
</a><a href="#h0-3-62" id="h0-3-62" class="d">-                .zip(row.iter())
</a><a href="#h0-3-63" id="h0-3-63" class="d">-                .enumerate()
</a><a href="#h0-3-64" id="h0-3-64" class="d">-                .filter(|(_i, (c, v))| c.unique &amp;&amp; !c.primary_key &amp;&amp; v != &amp;&amp;types::Value::Null)
</a><a href="#h0-3-65" id="h0-3-65" class="d">-                .map(|(i, (c, v))| (i, c, v))
</a><a href="#h0-3-66" id="h0-3-66" class="d">-                .collect();
</a><a href="#h0-3-67" id="h0-3-67" class="d">-            if !unique.is_empty() {
</a><a href="#h0-3-68" id="h0-3-68" class="d">-                let mut scan = self.scan(&amp;table.name)?;
</a><a href="#h0-3-69" id="h0-3-69" class="d">-                while let Some(r) = scan.next().transpose()? {
</a><a href="#h0-3-70" id="h0-3-70" class="d">-                    if &amp;table.row_key(&amp;r)? == id {
</a><a href="#h0-3-71" id="h0-3-71" class="d">-                        continue;
</a><a href="#h0-3-72" id="h0-3-72" class="d">-                    }
</a><a href="#h0-3-73" id="h0-3-73" class="d">-                    for (i, c, v) in unique.iter() {
</a><a href="#h0-3-74" id="h0-3-74" class="d">-                        if &amp;r.get(*i).unwrap_or_else(|| &amp;types::Value::Null) == v {
</a><a href="#h0-3-75" id="h0-3-75" class="d">-                            return Err(Error::Value(format!(
</a><a href="#h0-3-76" id="h0-3-76" class="d">-                                &quot;Unique value {} already exists for column {}&quot;,
</a><a href="#h0-3-77" id="h0-3-77" class="d">-                                v, c.name
</a><a href="#h0-3-78" id="h0-3-78" class="d">-                            )));
</a><a href="#h0-3-79" id="h0-3-79" class="d">-                        }
</a><a href="#h0-3-80" id="h0-3-80" class="d">-                    }
</a><a href="#h0-3-81" id="h0-3-81" class="d">-                }
</a><a href="#h0-3-82" id="h0-3-82" class="d">-            }
</a><a href="#h0-3-83" id="h0-3-83" class="d">-
</a><a href="#h0-3-84" id="h0-3-84" class="i">+            table.validate_row(&amp;row, self)?;
</a>             self.txn.set(&amp;Key::Row(&amp;table.name, &amp;id).encode(), serialize(&amp;row)?)
         }
     }
<b>diff --git a/<a id="h1" href="../file/src/sql/types/schema.rs.html">src/sql/types/schema.rs</a> b/<a href="../file/src/sql/types/schema.rs.html">src/sql/types/schema.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -61,12 +61,51 @@ impl Table {
</a>         Ok(())
     }
 
<a href="#h1-0-3" id="h1-0-3" class="i">+    /// Asserts that this primary key is not referenced from any other rows, otherwise errors
</a><a href="#h1-0-4" id="h1-0-4" class="i">+    pub fn assert_pk_unreferenced(
</a><a href="#h1-0-5" id="h1-0-5" class="i">+        &amp;self,
</a><a href="#h1-0-6" id="h1-0-6" class="i">+        pk: &amp;Value,
</a><a href="#h1-0-7" id="h1-0-7" class="i">+        txn: &amp;mut dyn Transaction,
</a><a href="#h1-0-8" id="h1-0-8" class="i">+    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h1-0-9" id="h1-0-9" class="i">+        for source in txn.scan_tables()? {
</a><a href="#h1-0-10" id="h1-0-10" class="i">+            let refs = source
</a><a href="#h1-0-11" id="h1-0-11" class="i">+                .columns
</a><a href="#h1-0-12" id="h1-0-12" class="i">+                .iter()
</a><a href="#h1-0-13" id="h1-0-13" class="i">+                .enumerate()
</a><a href="#h1-0-14" id="h1-0-14" class="i">+                .filter(|(_, c)| c.references.as_deref() == Some(&amp;self.name))
</a><a href="#h1-0-15" id="h1-0-15" class="i">+                .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h1-0-16" id="h1-0-16" class="i">+            if refs.is_empty() {
</a><a href="#h1-0-17" id="h1-0-17" class="i">+                continue;
</a><a href="#h1-0-18" id="h1-0-18" class="i">+            }
</a><a href="#h1-0-19" id="h1-0-19" class="i">+            let mut scan = txn.scan(&amp;source.name)?;
</a><a href="#h1-0-20" id="h1-0-20" class="i">+            while let Some(row) = scan.next().transpose()? {
</a><a href="#h1-0-21" id="h1-0-21" class="i">+                for (i, column) in refs.iter() {
</a><a href="#h1-0-22" id="h1-0-22" class="i">+                    if row.get(*i).unwrap_or(&amp;Value::Null) == pk
</a><a href="#h1-0-23" id="h1-0-23" class="i">+                        &amp;&amp; (source.name != self.name || &amp;source.row_key(&amp;row)? != pk)
</a><a href="#h1-0-24" id="h1-0-24" class="i">+                    {
</a><a href="#h1-0-25" id="h1-0-25" class="i">+                        return Err(Error::Value(format!(
</a><a href="#h1-0-26" id="h1-0-26" class="i">+                            &quot;Primary key {} is referenced by table {} column {}&quot;,
</a><a href="#h1-0-27" id="h1-0-27" class="i">+                            pk, source.name, column.name
</a><a href="#h1-0-28" id="h1-0-28" class="i">+                        )));
</a><a href="#h1-0-29" id="h1-0-29" class="i">+                    }
</a><a href="#h1-0-30" id="h1-0-30" class="i">+                }
</a><a href="#h1-0-31" id="h1-0-31" class="i">+            }
</a><a href="#h1-0-32" id="h1-0-32" class="i">+        }
</a><a href="#h1-0-33" id="h1-0-33" class="i">+        Ok(())
</a><a href="#h1-0-34" id="h1-0-34" class="i">+    }
</a><a href="#h1-0-35" id="h1-0-35" class="i">+
</a>     /// Fetches a column by name
     /// FIXME Should index these for performance
     pub fn get_column(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;Column&gt; {
         self.columns.iter().find(|c| c.name == name)
     }
 
<a href="#h1-0-42" id="h1-0-42" class="i">+    /// Fetches a column index by name
</a><a href="#h1-0-43" id="h1-0-43" class="i">+    /// FIXME Should index this for performance
</a><a href="#h1-0-44" id="h1-0-44" class="i">+    pub fn get_column_index(&amp;self, name: &amp;str) -&gt; Option&lt;usize&gt; {
</a><a href="#h1-0-45" id="h1-0-45" class="i">+        self.columns.iter().position(|c| c.name == name)
</a><a href="#h1-0-46" id="h1-0-46" class="i">+    }
</a><a href="#h1-0-47" id="h1-0-47" class="i">+
</a>     // Builds a row from a set of values, optionally with a set of column names, padding
     // it with default values as necessary.
     pub fn make_row(&amp;self, values: Vec&lt;Value&gt;, columns: Option&lt;&amp;[String]&gt;) -&gt; Result&lt;Row, Error&gt; {
<a href="#h1-1" id="h1-1" class="h">@@ -120,11 +159,6 @@ impl Table {
</a>             .ok_or_else(|| Error::Value(&quot;Primary key not found&quot;.into()))
     }
 
<a href="#h1-1-3" id="h1-1-3" class="d">-    /// Returns the set of tables references by this table
</a><a href="#h1-1-4" id="h1-1-4" class="d">-    pub fn references(&amp;self) -&gt; Vec&lt;Column&gt; {
</a><a href="#h1-1-5" id="h1-1-5" class="d">-        self.columns.iter().filter(|c| c.references.is_some()).cloned().collect()
</a><a href="#h1-1-6" id="h1-1-6" class="d">-    }
</a><a href="#h1-1-7" id="h1-1-7" class="d">-
</a>     /// Returns a row from a hashmap keyed by column name, padding it with nulls if needed
     pub fn row_from_hashmap(&amp;self, row: HashMap&lt;String, Value&gt;) -&gt; Row {
         self.columns.iter().map(|c| row.get(&amp;c.name).cloned().unwrap_or(Value::Null)).collect()
<a href="#h1-2" id="h1-2" class="h">@@ -152,28 +186,6 @@ impl Table {
</a>         .ok_or_else(|| Error::Value(&quot;Primary key value not found for row&quot;.into()))
     }
 
<a href="#h1-2-3" id="h1-2-3" class="d">-    /// Returns outbound references from a row as a table/pk hash map
</a><a href="#h1-2-4" id="h1-2-4" class="d">-    // FIXME Should remove duplicates, for performance
</a><a href="#h1-2-5" id="h1-2-5" class="d">-    pub fn row_references(&amp;self, row: &amp;[Value]) -&gt; Result&lt;HashMap&lt;String, Vec&lt;Value&gt;&gt;, Error&gt; {
</a><a href="#h1-2-6" id="h1-2-6" class="d">-        let mut refs = HashMap::new();
</a><a href="#h1-2-7" id="h1-2-7" class="d">-        for (i, column) in self.columns.iter().enumerate() {
</a><a href="#h1-2-8" id="h1-2-8" class="d">-            if let Some(target) = &amp;column.references {
</a><a href="#h1-2-9" id="h1-2-9" class="d">-                match row.get(i).cloned() {
</a><a href="#h1-2-10" id="h1-2-10" class="d">-                    Some(Value::Null) =&gt; {}
</a><a href="#h1-2-11" id="h1-2-11" class="d">-                    Some(Value::Float(f)) if f.is_nan() =&gt; {}
</a><a href="#h1-2-12" id="h1-2-12" class="d">-                    Some(v) =&gt; refs.entry(target.clone()).or_insert_with(Vec::new).push(v),
</a><a href="#h1-2-13" id="h1-2-13" class="d">-                    None =&gt; {
</a><a href="#h1-2-14" id="h1-2-14" class="d">-                        return Err(Error::Value(format!(
</a><a href="#h1-2-15" id="h1-2-15" class="d">-                            &quot;No value found for column {}&quot;,
</a><a href="#h1-2-16" id="h1-2-16" class="d">-                            column.name
</a><a href="#h1-2-17" id="h1-2-17" class="d">-                        )))
</a><a href="#h1-2-18" id="h1-2-18" class="d">-                    }
</a><a href="#h1-2-19" id="h1-2-19" class="d">-                }
</a><a href="#h1-2-20" id="h1-2-20" class="d">-            }
</a><a href="#h1-2-21" id="h1-2-21" class="d">-        }
</a><a href="#h1-2-22" id="h1-2-22" class="d">-        Ok(refs)
</a><a href="#h1-2-23" id="h1-2-23" class="d">-    }
</a><a href="#h1-2-24" id="h1-2-24" class="d">-
</a>     /// Validates the table schema
     pub fn validate(&amp;self, txn: &amp;mut dyn Transaction) -&gt; Result&lt;(), Error&gt; {
         if self.columns.is_empty() {
<a href="#h1-3" id="h1-3" class="h">@@ -191,12 +203,13 @@ impl Table {
</a>     }
 
     /// Validates a row
<a href="#h1-3-3" id="h1-3-3" class="d">-    pub fn validate_row(&amp;self, row: &amp;[Value]) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h1-3-4" id="h1-3-4" class="i">+    pub fn validate_row(&amp;self, row: &amp;[Value], txn: &amp;mut dyn Transaction) -&gt; Result&lt;(), Error&gt; {
</a>         if row.len() != self.columns.len() {
             return Err(Error::Value(format!(&quot;Invalid row size for table {}&quot;, self.name)));
         }
<a href="#h1-3-8" id="h1-3-8" class="i">+        let pk = self.row_key(row)?;
</a>         for (column, value) in self.columns.iter().zip(row.iter()) {
<a href="#h1-3-10" id="h1-3-10" class="d">-            column.validate_value(value)?;
</a><a href="#h1-3-11" id="h1-3-11" class="i">+            column.validate_value(self, &amp;pk, value, txn)?;
</a>         }
         Ok(())
     }
<a href="#h1-4" id="h1-4" class="h">@@ -302,7 +315,14 @@ impl Column {
</a>     }
 
     /// Validates a column value
<a href="#h1-4-3" id="h1-4-3" class="d">-    pub fn validate_value(&amp;self, value: &amp;Value) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h1-4-4" id="h1-4-4" class="i">+    pub fn validate_value(
</a><a href="#h1-4-5" id="h1-4-5" class="i">+        &amp;self,
</a><a href="#h1-4-6" id="h1-4-6" class="i">+        table: &amp;Table,
</a><a href="#h1-4-7" id="h1-4-7" class="i">+        pk: &amp;Value,
</a><a href="#h1-4-8" id="h1-4-8" class="i">+        value: &amp;Value,
</a><a href="#h1-4-9" id="h1-4-9" class="i">+        txn: &amp;mut dyn Transaction,
</a><a href="#h1-4-10" id="h1-4-10" class="i">+    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h1-4-11" id="h1-4-11" class="i">+        // Validate datatype
</a>         match value.datatype() {
             None if self.nullable =&gt; Ok(()),
             None =&gt; Err(Error::Value(format!(&quot;NULL value not allowed for column {}&quot;, self.name))),
<a href="#h1-5" id="h1-5" class="h">@@ -312,11 +332,48 @@ impl Column {
</a>             ))),
             _ =&gt; Ok(()),
         }?;
<a href="#h1-5-3" id="h1-5-3" class="i">+
</a><a href="#h1-5-4" id="h1-5-4" class="i">+        // Validate value
</a>         match value {
             Value::String(s) if s.len() &gt; 1024 =&gt; {
                 Err(Error::Value(&quot;Strings cannot be more than 1024 bytes&quot;.into()))
             }
             _ =&gt; Ok(()),
<a href="#h1-5-10" id="h1-5-10" class="i">+        }?;
</a><a href="#h1-5-11" id="h1-5-11" class="i">+
</a><a href="#h1-5-12" id="h1-5-12" class="i">+        // Validate outgoing references
</a><a href="#h1-5-13" id="h1-5-13" class="i">+        if let Some(target) = &amp;self.references {
</a><a href="#h1-5-14" id="h1-5-14" class="i">+            match value {
</a><a href="#h1-5-15" id="h1-5-15" class="i">+                Value::Null =&gt; Ok(()),
</a><a href="#h1-5-16" id="h1-5-16" class="i">+                Value::Float(f) if f.is_nan() =&gt; Ok(()),
</a><a href="#h1-5-17" id="h1-5-17" class="i">+                v if target == &amp;table.name &amp;&amp; v == pk =&gt; Ok(()),
</a><a href="#h1-5-18" id="h1-5-18" class="i">+                v if txn.read(target, v)?.is_none() =&gt; Err(Error::Value(format!(
</a><a href="#h1-5-19" id="h1-5-19" class="i">+                    &quot;Referenced primary key {} in table {} does not exist&quot;,
</a><a href="#h1-5-20" id="h1-5-20" class="i">+                    v, target,
</a><a href="#h1-5-21" id="h1-5-21" class="i">+                ))),
</a><a href="#h1-5-22" id="h1-5-22" class="i">+                _ =&gt; Ok(()),
</a><a href="#h1-5-23" id="h1-5-23" class="i">+            }?;
</a>         }
<a href="#h1-5-25" id="h1-5-25" class="i">+
</a><a href="#h1-5-26" id="h1-5-26" class="i">+        // Validate uniqueness constraints
</a><a href="#h1-5-27" id="h1-5-27" class="i">+        if self.unique &amp;&amp; !self.primary_key &amp;&amp; value != &amp;Value::Null {
</a><a href="#h1-5-28" id="h1-5-28" class="i">+            let index = table.get_column_index(&amp;self.name).ok_or_else(|| {
</a><a href="#h1-5-29" id="h1-5-29" class="i">+                Error::Internal(format!(
</a><a href="#h1-5-30" id="h1-5-30" class="i">+                    &quot;Unable to find column {} in table {}&quot;,
</a><a href="#h1-5-31" id="h1-5-31" class="i">+                    self.name, table.name,
</a><a href="#h1-5-32" id="h1-5-32" class="i">+                ))
</a><a href="#h1-5-33" id="h1-5-33" class="i">+            })?;
</a><a href="#h1-5-34" id="h1-5-34" class="i">+            let mut scan = txn.scan(&amp;table.name)?;
</a><a href="#h1-5-35" id="h1-5-35" class="i">+            while let Some(row) = scan.next().transpose()? {
</a><a href="#h1-5-36" id="h1-5-36" class="i">+                if row.get(index).unwrap_or(&amp;Value::Null) == value &amp;&amp; &amp;table.row_key(&amp;row)? != pk {
</a><a href="#h1-5-37" id="h1-5-37" class="i">+                    return Err(Error::Value(format!(
</a><a href="#h1-5-38" id="h1-5-38" class="i">+                        &quot;Unique value {} already exists for column {}&quot;,
</a><a href="#h1-5-39" id="h1-5-39" class="i">+                        value, self.name
</a><a href="#h1-5-40" id="h1-5-40" class="i">+                    )));
</a><a href="#h1-5-41" id="h1-5-41" class="i">+                }
</a><a href="#h1-5-42" id="h1-5-42" class="i">+            }
</a><a href="#h1-5-43" id="h1-5-43" class="i">+        }
</a><a href="#h1-5-44" id="h1-5-44" class="i">+
</a><a href="#h1-5-45" id="h1-5-45" class="i">+        Ok(())
</a>     }
 }
</pre>
</div>
</body>
</html>
