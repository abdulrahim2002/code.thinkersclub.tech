<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Redesign how read-only transactions work. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/8c02de6830e60a982920dd307c64c7e62199c31e.html">8c02de6830e60a982920dd307c64c7e62199c31e</a>
<b>parent</b> <a href="../commit/3be2413202018666cc22260cc8cedebc09e5d1e9.html">3be2413202018666cc22260cc8cedebc09e5d1e9</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue,  5 Sep 2023 00:09:39 +0200

Redesign how read-only transactions work.

This patch redesigns how read-only transactions work. Previously,
read-only transactions would allocate a new transaction ID and store the
active set, just like read-write transactions. This was necessary to
resume the transaction after traversing the Raft boundary.

Now that the transaction state can be serialized and passed across Raft,
this is no longer necessary, making read-only transaction truly
read-only at the MVCC level. New versions are only allocated for
read-write transactions (since these are the only ones that can mutate
the MVCC state), and only these store their active set.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/bin/toysql.rs</a></td><td> | </td><td class="num">20</td><td><span class="i">+++++++</span><span class="d">-------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/client.rs</a></td><td> | </td><td class="num">10</td><td><span class="i">+++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/server.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">20</td><td><span class="i">++++++++++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/engine/mod.rs</a></td><td> | </td><td class="num">70</td><td><span class="i">++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">40</td><td><span class="i">+++++++++++++++++++++++++++</span><span class="d">-------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/execution/mod.rs</a></td><td> | </td><td class="num">10</td><td><span class="i">+++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/sql/parser/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">src/storage/mvcc.rs</a></td><td> | </td><td class="num">415</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">tests/client/mod.rs</a></td><td> | </td><td class="num">45</td><td><span class="i">+++++++++++++++++++++++</span><span class="d">----------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">tests/sql/mutation.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">tests/sql/query.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h13">tests/sql/schema.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
</table></pre><pre>14 files changed, 355 insertions(+), 307 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/bin/toysql.rs.html">src/bin/toysql.rs</a> b/<a href="../file/src/bin/toysql.rs.html">src/bin/toysql.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -10,7 +10,6 @@ use rustyline::validate::{ValidationContext, ValidationResult, Validator};
</a> use rustyline::{error::ReadlineError, Editor, Modifiers};
 use rustyline_derive::{Completer, Helper, Highlighter, Hinter};
 use toydb::error::{Error, Result};
<a href="#h0-0-3" id="h0-0-3" class="d">-use toydb::sql::engine::Mode;
</a> use toydb::sql::execution::ResultSet;
 use toydb::sql::parser::{Lexer, Token};
 use toydb::Client;
<a href="#h0-1" id="h0-1" class="h">@@ -165,16 +164,12 @@ SQL txns:  {txns_active} active, {txns} total ({sql_storage} storage)
</a>     /// Runs a query and displays the results
     async fn execute_query(&amp;mut self, query: &amp;str) -&gt; Result&lt;()&gt; {
         match self.client.execute(query).await? {
<a href="#h0-1-3" id="h0-1-3" class="d">-            ResultSet::Begin { id, mode } =&gt; match mode {
</a><a href="#h0-1-4" id="h0-1-4" class="d">-                Mode::ReadWrite =&gt; println!(&quot;Began transaction {}&quot;, id),
</a><a href="#h0-1-5" id="h0-1-5" class="d">-                Mode::ReadOnly =&gt; println!(&quot;Began read-only transaction {}&quot;, id),
</a><a href="#h0-1-6" id="h0-1-6" class="d">-                Mode::Snapshot { version, .. } =&gt; println!(
</a><a href="#h0-1-7" id="h0-1-7" class="d">-                    &quot;Began read-only transaction {} in snapshot at version {}&quot;,
</a><a href="#h0-1-8" id="h0-1-8" class="d">-                    id, version
</a><a href="#h0-1-9" id="h0-1-9" class="d">-                ),
</a><a href="#h0-1-10" id="h0-1-10" class="i">+            ResultSet::Begin { version, read_only } =&gt; match read_only {
</a><a href="#h0-1-11" id="h0-1-11" class="i">+                false =&gt; println!(&quot;Began transaction at new version {}&quot;, version),
</a><a href="#h0-1-12" id="h0-1-12" class="i">+                true =&gt; println!(&quot;Began read-only transaction at version {}&quot;, version),
</a>             },
<a href="#h0-1-14" id="h0-1-14" class="d">-            ResultSet::Commit { id } =&gt; println!(&quot;Committed transaction {}&quot;, id),
</a><a href="#h0-1-15" id="h0-1-15" class="d">-            ResultSet::Rollback { id } =&gt; println!(&quot;Rolled back transaction {}&quot;, id),
</a><a href="#h0-1-16" id="h0-1-16" class="i">+            ResultSet::Commit { version: id } =&gt; println!(&quot;Committed transaction {}&quot;, id),
</a><a href="#h0-1-17" id="h0-1-17" class="i">+            ResultSet::Rollback { version: id } =&gt; println!(&quot;Rolled back transaction {}&quot;, id),
</a>             ResultSet::Create { count } =&gt; println!(&quot;Created {} rows&quot;, count),
             ResultSet::Delete { count } =&gt; println!(&quot;Deleted {} rows&quot;, count),
             ResultSet::Update { count } =&gt; println!(&quot;Updated {} rows&quot;, count),
<a href="#h0-2" id="h0-2" class="h">@@ -206,9 +201,8 @@ SQL txns:  {txns_active} active, {txns} total ({sql_storage} storage)
</a>     /// Prompts the user for input
     fn prompt(&amp;mut self) -&gt; Result&lt;Option&lt;String&gt;&gt; {
         let prompt = match self.client.txn() {
<a href="#h0-2-3" id="h0-2-3" class="d">-            Some((id, Mode::ReadWrite)) =&gt; format!(&quot;toydb:{}&gt; &quot;, id),
</a><a href="#h0-2-4" id="h0-2-4" class="d">-            Some((id, Mode::ReadOnly)) =&gt; format!(&quot;toydb:{}&gt; &quot;, id),
</a><a href="#h0-2-5" id="h0-2-5" class="d">-            Some((_, Mode::Snapshot { version })) =&gt; format!(&quot;toydb@{}&gt; &quot;, version),
</a><a href="#h0-2-6" id="h0-2-6" class="i">+            Some((version, false)) =&gt; format!(&quot;toydb:{}&gt; &quot;, version),
</a><a href="#h0-2-7" id="h0-2-7" class="i">+            Some((version, true)) =&gt; format!(&quot;toydb@{}&gt; &quot;, version),
</a>             None =&gt; &quot;toydb&gt; &quot;.into(),
         };
         match self.editor.readline(&amp;prompt) {
<b>diff --git a/<a id="h1" href="../file/src/client.rs.html">src/client.rs</a> b/<a href="../file/src/client.rs.html">src/client.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,6 +1,6 @@
</a> use crate::error::{Error, Result};
 use crate::server::{Request, Response};
<a href="#h1-0-2" id="h1-0-2" class="d">-use crate::sql::engine::{Mode, Status};
</a><a href="#h1-0-3" id="h1-0-3" class="i">+use crate::sql::engine::Status;
</a> use crate::sql::execution::ResultSet;
 use crate::sql::schema::Table;
 
<a href="#h1-1" id="h1-1" class="h">@@ -30,7 +30,7 @@ const WITH_TXN_RETRIES: u8 = 8;
</a> #[derive(Clone)]
 pub struct Client {
     conn: Arc&lt;Mutex&lt;Connection&gt;&gt;,
<a href="#h1-1-3" id="h1-1-3" class="d">-    txn: Cell&lt;Option&lt;(u64, Mode)&gt;&gt;,
</a><a href="#h1-1-4" id="h1-1-4" class="i">+    txn: Cell&lt;Option&lt;(u64, bool)&gt;&gt;,
</a> }
 
 impl Client {
<a href="#h1-2" id="h1-2" class="h">@@ -87,7 +87,7 @@ impl Client {
</a>             resultset = ResultSet::Query { columns, rows: Box::new(rows.into_iter().map(Ok)) }
         };
         match &amp;resultset {
<a href="#h1-2-3" id="h1-2-3" class="d">-            ResultSet::Begin { id, mode } =&gt; self.txn.set(Some((*id, *mode))),
</a><a href="#h1-2-4" id="h1-2-4" class="i">+            ResultSet::Begin { version, read_only } =&gt; self.txn.set(Some((*version, *read_only))),
</a>             ResultSet::Commit { .. } =&gt; self.txn.set(None),
             ResultSet::Rollback { .. } =&gt; self.txn.set(None),
             _ =&gt; {}
<a href="#h1-3" id="h1-3" class="h">@@ -119,8 +119,8 @@ impl Client {
</a>         }
     }
 
<a href="#h1-3-3" id="h1-3-3" class="d">-    /// Returns the transaction status of the client
</a><a href="#h1-3-4" id="h1-3-4" class="d">-    pub fn txn(&amp;self) -&gt; Option&lt;(u64, Mode)&gt; {
</a><a href="#h1-3-5" id="h1-3-5" class="i">+    /// Returns the version and read-only state of the txn
</a><a href="#h1-3-6" id="h1-3-6" class="i">+    pub fn txn(&amp;self) -&gt; Option&lt;(u64, bool)&gt; {
</a>         self.txn.get()
     }
 
<b>diff --git a/<a id="h2" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,7 +1,7 @@
</a> use crate::error::{Error, Result};
 use crate::raft;
 use crate::sql;
<a href="#h2-0-3" id="h2-0-3" class="d">-use crate::sql::engine::{Engine as _, Mode};
</a><a href="#h2-0-4" id="h2-0-4" class="i">+use crate::sql::engine::Engine as _;
</a> use crate::sql::execution::ResultSet;
 use crate::sql::schema::{Catalog as _, Table};
 use crate::sql::types::Row;
<a href="#h2-1" id="h2-1" class="h">@@ -155,14 +155,12 @@ impl Session {
</a>         debug!(&quot;Processing request {:?}&quot;, request);
         let response = match request {
             Request::Execute(query) =&gt; Response::Execute(self.sql.execute(&amp;query)?),
<a href="#h2-1-3" id="h2-1-3" class="d">-            Request::GetTable(table) =&gt; Response::GetTable(
</a><a href="#h2-1-4" id="h2-1-4" class="d">-                self.sql.with_txn(Mode::ReadOnly, |txn| txn.must_read_table(&amp;table))?,
</a><a href="#h2-1-5" id="h2-1-5" class="d">-            ),
</a><a href="#h2-1-6" id="h2-1-6" class="d">-            Request::ListTables =&gt; {
</a><a href="#h2-1-7" id="h2-1-7" class="d">-                Response::ListTables(self.sql.with_txn(Mode::ReadOnly, |txn| {
</a><a href="#h2-1-8" id="h2-1-8" class="d">-                    Ok(txn.scan_tables()?.map(|t| t.name).collect())
</a><a href="#h2-1-9" id="h2-1-9" class="d">-                })?)
</a><a href="#h2-1-10" id="h2-1-10" class="i">+            Request::GetTable(table) =&gt; {
</a><a href="#h2-1-11" id="h2-1-11" class="i">+                Response::GetTable(self.sql.read_with_txn(|txn| txn.must_read_table(&amp;table))?)
</a>             }
<a href="#h2-1-13" id="h2-1-13" class="i">+            Request::ListTables =&gt; Response::ListTables(
</a><a href="#h2-1-14" id="h2-1-14" class="i">+                self.sql.read_with_txn(|txn| Ok(txn.scan_tables()?.map(|t| t.name).collect()))?,
</a><a href="#h2-1-15" id="h2-1-15" class="i">+            ),
</a>             Request::Status =&gt; Response::Status(self.engine.status()?),
         };
         debug!(&quot;Returning response {:?}&quot;, response);
<b>diff --git a/<a id="h3" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -50,8 +50,16 @@ impl&lt;E: storage::Engine&gt; KV&lt;E&gt; {
</a> impl&lt;E: storage::Engine&gt; super::Engine for KV&lt;E&gt; {
     type Transaction = Transaction&lt;E&gt;;
 
<a href="#h3-0-3" id="h3-0-3" class="d">-    fn begin(&amp;self, mode: super::Mode) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h3-0-4" id="h3-0-4" class="d">-        Ok(Self::Transaction::new(self.kv.begin_with_mode(mode)?))
</a><a href="#h3-0-5" id="h3-0-5" class="i">+    fn begin(&amp;self) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h3-0-6" id="h3-0-6" class="i">+        Ok(Self::Transaction::new(self.kv.begin()?))
</a><a href="#h3-0-7" id="h3-0-7" class="i">+    }
</a><a href="#h3-0-8" id="h3-0-8" class="i">+
</a><a href="#h3-0-9" id="h3-0-9" class="i">+    fn begin_read_only(&amp;self) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h3-0-10" id="h3-0-10" class="i">+        Ok(Self::Transaction::new(self.kv.begin_read_only()?))
</a><a href="#h3-0-11" id="h3-0-11" class="i">+    }
</a><a href="#h3-0-12" id="h3-0-12" class="i">+
</a><a href="#h3-0-13" id="h3-0-13" class="i">+    fn begin_as_of(&amp;self, version: u64) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h3-0-14" id="h3-0-14" class="i">+        Ok(Self::Transaction::new(self.kv.begin_as_of(version)?))
</a>     }
 }
 
<a href="#h3-1" id="h3-1" class="h">@@ -109,12 +117,12 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a> }
 
 impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
<a href="#h3-1-3" id="h3-1-3" class="d">-    fn id(&amp;self) -&gt; u64 {
</a><a href="#h3-1-4" id="h3-1-4" class="d">-        self.txn.id()
</a><a href="#h3-1-5" id="h3-1-5" class="i">+    fn version(&amp;self) -&gt; u64 {
</a><a href="#h3-1-6" id="h3-1-6" class="i">+        self.txn.version()
</a>     }
 
<a href="#h3-1-9" id="h3-1-9" class="d">-    fn mode(&amp;self) -&gt; super::Mode {
</a><a href="#h3-1-10" id="h3-1-10" class="d">-        self.txn.mode()
</a><a href="#h3-1-11" id="h3-1-11" class="i">+    fn read_only(&amp;self) -&gt; bool {
</a><a href="#h3-1-12" id="h3-1-12" class="i">+        self.txn.read_only()
</a>     }
 
     fn commit(self) -&gt; Result&lt;()&gt; {
<b>diff --git a/<a id="h4" href="../file/src/sql/engine/mod.rs.html">src/sql/engine/mod.rs</a> b/<a href="../file/src/sql/engine/mod.rs.html">src/sql/engine/mod.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -18,8 +18,14 @@ pub trait Engine: Clone {
</a>     /// The transaction type
     type Transaction: Transaction;
 
<a href="#h4-0-3" id="h4-0-3" class="d">-    /// Begins a transaction in the given mode
</a><a href="#h4-0-4" id="h4-0-4" class="d">-    fn begin(&amp;self, mode: Mode) -&gt; Result&lt;Self::Transaction&gt;;
</a><a href="#h4-0-5" id="h4-0-5" class="i">+    /// Begins a read-write transaction.
</a><a href="#h4-0-6" id="h4-0-6" class="i">+    fn begin(&amp;self) -&gt; Result&lt;Self::Transaction&gt;;
</a><a href="#h4-0-7" id="h4-0-7" class="i">+
</a><a href="#h4-0-8" id="h4-0-8" class="i">+    /// Begins a read-only transaction.
</a><a href="#h4-0-9" id="h4-0-9" class="i">+    fn begin_read_only(&amp;self) -&gt; Result&lt;Self::Transaction&gt;;
</a><a href="#h4-0-10" id="h4-0-10" class="i">+
</a><a href="#h4-0-11" id="h4-0-11" class="i">+    /// Begins a read-only transaction as of a historical version.
</a><a href="#h4-0-12" id="h4-0-12" class="i">+    fn begin_as_of(&amp;self, version: u64) -&gt; Result&lt;Self::Transaction&gt;;
</a> 
     /// Begins a session for executing individual statements
     fn session(&amp;self) -&gt; Result&lt;Session&lt;Self&gt;&gt; {
<a href="#h4-1" id="h4-1" class="h">@@ -29,10 +35,11 @@ pub trait Engine: Clone {
</a> 
 /// An SQL transaction
 pub trait Transaction: Catalog {
<a href="#h4-1-3" id="h4-1-3" class="d">-    /// The transaction ID
</a><a href="#h4-1-4" id="h4-1-4" class="d">-    fn id(&amp;self) -&gt; u64;
</a><a href="#h4-1-5" id="h4-1-5" class="d">-    /// The transaction mode
</a><a href="#h4-1-6" id="h4-1-6" class="d">-    fn mode(&amp;self) -&gt; Mode;
</a><a href="#h4-1-7" id="h4-1-7" class="i">+    /// The transaction&#39;s version
</a><a href="#h4-1-8" id="h4-1-8" class="i">+    fn version(&amp;self) -&gt; u64;
</a><a href="#h4-1-9" id="h4-1-9" class="i">+    /// Whether the transaction is read-only
</a><a href="#h4-1-10" id="h4-1-10" class="i">+    fn read_only(&amp;self) -&gt; bool;
</a><a href="#h4-1-11" id="h4-1-11" class="i">+
</a>     /// Commits the transaction
     fn commit(self) -&gt; Result&lt;()&gt;;
     /// Rolls back the transaction
<a href="#h4-2" id="h4-2" class="h">@@ -72,24 +79,24 @@ impl&lt;E: Engine + &#39;static&gt; Session&lt;E&gt; {
</a>             ast::Statement::Begin { .. } if self.txn.is_some() =&gt; {
                 Err(Error::Value(&quot;Already in a transaction&quot;.into()))
             }
<a href="#h4-2-3" id="h4-2-3" class="d">-            ast::Statement::Begin { readonly: true, version: None } =&gt; {
</a><a href="#h4-2-4" id="h4-2-4" class="d">-                let txn = self.engine.begin(Mode::ReadOnly)?;
</a><a href="#h4-2-5" id="h4-2-5" class="d">-                let result = ResultSet::Begin { id: txn.id(), mode: txn.mode() };
</a><a href="#h4-2-6" id="h4-2-6" class="i">+            ast::Statement::Begin { read_only: true, as_of: None } =&gt; {
</a><a href="#h4-2-7" id="h4-2-7" class="i">+                let txn = self.engine.begin_read_only()?;
</a><a href="#h4-2-8" id="h4-2-8" class="i">+                let result = ResultSet::Begin { version: txn.version(), read_only: true };
</a>                 self.txn = Some(txn);
                 Ok(result)
             }
<a href="#h4-2-12" id="h4-2-12" class="d">-            ast::Statement::Begin { readonly: true, version: Some(version) } =&gt; {
</a><a href="#h4-2-13" id="h4-2-13" class="d">-                let txn = self.engine.begin(Mode::Snapshot { version })?;
</a><a href="#h4-2-14" id="h4-2-14" class="d">-                let result = ResultSet::Begin { id: txn.id(), mode: txn.mode() };
</a><a href="#h4-2-15" id="h4-2-15" class="i">+            ast::Statement::Begin { read_only: true, as_of: Some(version) } =&gt; {
</a><a href="#h4-2-16" id="h4-2-16" class="i">+                let txn = self.engine.begin_as_of(version)?;
</a><a href="#h4-2-17" id="h4-2-17" class="i">+                let result = ResultSet::Begin { version, read_only: true };
</a>                 self.txn = Some(txn);
                 Ok(result)
             }
<a href="#h4-2-21" id="h4-2-21" class="d">-            ast::Statement::Begin { readonly: false, version: Some(_) } =&gt; {
</a><a href="#h4-2-22" id="h4-2-22" class="i">+            ast::Statement::Begin { read_only: false, as_of: Some(_) } =&gt; {
</a>                 Err(Error::Value(&quot;Can&#39;t start read-write transaction in a given version&quot;.into()))
             }
<a href="#h4-2-25" id="h4-2-25" class="d">-            ast::Statement::Begin { readonly: false, version: None } =&gt; {
</a><a href="#h4-2-26" id="h4-2-26" class="d">-                let txn = self.engine.begin(Mode::ReadWrite)?;
</a><a href="#h4-2-27" id="h4-2-27" class="d">-                let result = ResultSet::Begin { id: txn.id(), mode: txn.mode() };
</a><a href="#h4-2-28" id="h4-2-28" class="i">+            ast::Statement::Begin { read_only: false, as_of: None } =&gt; {
</a><a href="#h4-2-29" id="h4-2-29" class="i">+                let txn = self.engine.begin()?;
</a><a href="#h4-2-30" id="h4-2-30" class="i">+                let result = ResultSet::Begin { version: txn.version(), read_only: false };
</a>                 self.txn = Some(txn);
                 Ok(result)
             }
<a href="#h4-3" id="h4-3" class="h">@@ -98,31 +105,31 @@ impl&lt;E: Engine + &#39;static&gt; Session&lt;E&gt; {
</a>             }
             ast::Statement::Commit =&gt; {
                 let txn = self.txn.take().unwrap();
<a href="#h4-3-3" id="h4-3-3" class="d">-                let id = txn.id();
</a><a href="#h4-3-4" id="h4-3-4" class="i">+                let version = txn.version();
</a>                 txn.commit()?;
<a href="#h4-3-6" id="h4-3-6" class="d">-                Ok(ResultSet::Commit { id })
</a><a href="#h4-3-7" id="h4-3-7" class="i">+                Ok(ResultSet::Commit { version })
</a>             }
             ast::Statement::Rollback =&gt; {
                 let txn = self.txn.take().unwrap();
<a href="#h4-3-11" id="h4-3-11" class="d">-                let id = txn.id();
</a><a href="#h4-3-12" id="h4-3-12" class="i">+                let version = txn.version();
</a>                 txn.rollback()?;
<a href="#h4-3-14" id="h4-3-14" class="d">-                Ok(ResultSet::Rollback { id })
</a><a href="#h4-3-15" id="h4-3-15" class="i">+                Ok(ResultSet::Rollback { version })
</a>             }
<a href="#h4-3-17" id="h4-3-17" class="d">-            ast::Statement::Explain(statement) =&gt; self.with_txn(Mode::ReadOnly, |txn| {
</a><a href="#h4-3-18" id="h4-3-18" class="i">+            ast::Statement::Explain(statement) =&gt; self.read_with_txn(|txn| {
</a>                 Ok(ResultSet::Explain(Plan::build(*statement, txn)?.optimize(txn)?.0))
             }),
             statement if self.txn.is_some() =&gt; Plan::build(statement, self.txn.as_mut().unwrap())?
                 .optimize(self.txn.as_mut().unwrap())?
                 .execute(self.txn.as_mut().unwrap()),
             statement @ ast::Statement::Select { .. } =&gt; {
<a href="#h4-3-25" id="h4-3-25" class="d">-                let mut txn = self.engine.begin(Mode::ReadOnly)?;
</a><a href="#h4-3-26" id="h4-3-26" class="i">+                let mut txn = self.engine.begin_read_only()?;
</a>                 let result =
                     Plan::build(statement, &amp;mut txn)?.optimize(&amp;mut txn)?.execute(&amp;mut txn);
                 txn.rollback()?;
                 result
             }
             statement =&gt; {
<a href="#h4-3-33" id="h4-3-33" class="d">-                let mut txn = self.engine.begin(Mode::ReadWrite)?;
</a><a href="#h4-3-34" id="h4-3-34" class="i">+                let mut txn = self.engine.begin()?;
</a>                 match Plan::build(statement, &amp;mut txn)?.optimize(&amp;mut txn)?.execute(&amp;mut txn) {
                     Ok(result) =&gt; {
                         txn.commit()?;
<a href="#h4-4" id="h4-4" class="h">@@ -137,29 +144,24 @@ impl&lt;E: Engine + &#39;static&gt; Session&lt;E&gt; {
</a>         }
     }
 
<a href="#h4-4-3" id="h4-4-3" class="d">-    /// Runs a closure in the session&#39;s transaction, or a new transaction if none is active.
</a><a href="#h4-4-4" id="h4-4-4" class="d">-    pub fn with_txn&lt;R, F&gt;(&amp;mut self, mode: Mode, f: F) -&gt; Result&lt;R&gt;
</a><a href="#h4-4-5" id="h4-4-5" class="i">+    /// Runs a read-only closure in the session&#39;s transaction, or a new
</a><a href="#h4-4-6" id="h4-4-6" class="i">+    /// transaction if none is active.
</a><a href="#h4-4-7" id="h4-4-7" class="i">+    ///
</a><a href="#h4-4-8" id="h4-4-8" class="i">+    /// TODO: reconsider this
</a><a href="#h4-4-9" id="h4-4-9" class="i">+    pub fn read_with_txn&lt;R, F&gt;(&amp;mut self, f: F) -&gt; Result&lt;R&gt;
</a>     where
         F: FnOnce(&amp;mut E::Transaction) -&gt; Result&lt;R&gt;,
     {
         if let Some(ref mut txn) = self.txn {
<a href="#h4-4-14" id="h4-4-14" class="d">-            if !txn.mode().satisfies(&amp;mode) {
</a><a href="#h4-4-15" id="h4-4-15" class="d">-                return Err(Error::Value(
</a><a href="#h4-4-16" id="h4-4-16" class="d">-                    &quot;The operation cannot run in the current transaction&quot;.into(),
</a><a href="#h4-4-17" id="h4-4-17" class="d">-                ));
</a><a href="#h4-4-18" id="h4-4-18" class="d">-            }
</a>             return f(txn);
         }
<a href="#h4-4-21" id="h4-4-21" class="d">-        let mut txn = self.engine.begin(mode)?;
</a><a href="#h4-4-22" id="h4-4-22" class="i">+        let mut txn = self.engine.begin_read_only()?;
</a>         let result = f(&amp;mut txn);
         txn.rollback()?;
         result
     }
 }
 
<a href="#h4-4-29" id="h4-4-29" class="d">-/// The transaction mode
</a><a href="#h4-4-30" id="h4-4-30" class="d">-pub type Mode = crate::storage::mvcc::Mode;
</a><a href="#h4-4-31" id="h4-4-31" class="d">-
</a> /// A row scan iterator
 pub type Scan = Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;Row&gt;&gt; + Send&gt;;
 
<b>diff --git a/<a id="h5" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,6 +1,6 @@
</a> use super::super::schema::{Catalog, Table, Tables};
 use super::super::types::{Expression, Row, Value};
<a href="#h5-0-2" id="h5-0-2" class="d">-use super::{Engine as _, IndexScan, Mode, Scan, Transaction as _};
</a><a href="#h5-0-3" id="h5-0-3" class="i">+use super::{Engine as _, IndexScan, Scan, Transaction as _};
</a> use crate::error::{Error, Result};
 use crate::raft;
 use crate::storage::{self, mvcc::TransactionState};
<a href="#h5-1" id="h5-1" class="h">@@ -13,8 +13,8 @@ use std::collections::HashSet;
</a> /// TODO: use Cows for these.
 #[derive(Clone, Serialize, Deserialize)]
 enum Mutation {
<a href="#h5-1-3" id="h5-1-3" class="d">-    /// Begins a transaction in the given mode
</a><a href="#h5-1-4" id="h5-1-4" class="d">-    Begin(Mode),
</a><a href="#h5-1-5" id="h5-1-5" class="i">+    /// Begins a transaction
</a><a href="#h5-1-6" id="h5-1-6" class="i">+    Begin { read_only: bool, as_of: Option&lt;u64&gt; },
</a>     /// Commits the given transaction
     Commit(TransactionState),
     /// Rolls back the given transaction
<a href="#h5-2" id="h5-2" class="h">@@ -104,8 +104,16 @@ impl Raft {
</a> impl super::Engine for Raft {
     type Transaction = Transaction;
 
<a href="#h5-2-3" id="h5-2-3" class="d">-    fn begin(&amp;self, mode: Mode) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h5-2-4" id="h5-2-4" class="d">-        Transaction::begin(self.client.clone(), mode)
</a><a href="#h5-2-5" id="h5-2-5" class="i">+    fn begin(&amp;self) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h5-2-6" id="h5-2-6" class="i">+        Transaction::begin(self.client.clone(), false, None)
</a><a href="#h5-2-7" id="h5-2-7" class="i">+    }
</a><a href="#h5-2-8" id="h5-2-8" class="i">+
</a><a href="#h5-2-9" id="h5-2-9" class="i">+    fn begin_read_only(&amp;self) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h5-2-10" id="h5-2-10" class="i">+        Transaction::begin(self.client.clone(), true, None)
</a><a href="#h5-2-11" id="h5-2-11" class="i">+    }
</a><a href="#h5-2-12" id="h5-2-12" class="i">+
</a><a href="#h5-2-13" id="h5-2-13" class="i">+    fn begin_as_of(&amp;self, version: u64) -&gt; Result&lt;Self::Transaction&gt; {
</a><a href="#h5-2-14" id="h5-2-14" class="i">+        Transaction::begin(self.client.clone(), true, Some(version))
</a>     }
 }
 
<a href="#h5-3" id="h5-3" class="h">@@ -120,9 +128,9 @@ pub struct Transaction {
</a> 
 impl Transaction {
     /// Starts a transaction in the given mode
<a href="#h5-3-3" id="h5-3-3" class="d">-    fn begin(client: raft::Client, mode: Mode) -&gt; Result&lt;Self&gt; {
</a><a href="#h5-3-4" id="h5-3-4" class="i">+    fn begin(client: raft::Client, read_only: bool, as_of: Option&lt;u64&gt;) -&gt; Result&lt;Self&gt; {
</a>         let state = Raft::deserialize(&amp;futures::executor::block_on(
<a href="#h5-3-6" id="h5-3-6" class="d">-            client.mutate(Raft::serialize(&amp;Mutation::Begin(mode))?),
</a><a href="#h5-3-7" id="h5-3-7" class="i">+            client.mutate(Raft::serialize(&amp;Mutation::Begin { read_only, as_of })?),
</a>         )?)?;
         Ok(Self { client, state })
     }
<a href="#h5-4" id="h5-4" class="h">@@ -139,12 +147,12 @@ impl Transaction {
</a> }
 
 impl super::Transaction for Transaction {
<a href="#h5-4-3" id="h5-4-3" class="d">-    fn id(&amp;self) -&gt; u64 {
</a><a href="#h5-4-4" id="h5-4-4" class="d">-        self.state.id
</a><a href="#h5-4-5" id="h5-4-5" class="i">+    fn version(&amp;self) -&gt; u64 {
</a><a href="#h5-4-6" id="h5-4-6" class="i">+        self.state.version
</a>     }
 
<a href="#h5-4-9" id="h5-4-9" class="d">-    fn mode(&amp;self) -&gt; Mode {
</a><a href="#h5-4-10" id="h5-4-10" class="d">-        self.state.mode
</a><a href="#h5-4-11" id="h5-4-11" class="i">+    fn read_only(&amp;self) -&gt; bool {
</a><a href="#h5-4-12" id="h5-4-12" class="i">+        self.state.read_only
</a>     }
 
     fn commit(self) -&gt; Result&lt;()&gt; {
<a href="#h5-5" id="h5-5" class="h">@@ -276,8 +284,14 @@ impl&lt;E: storage::Engine&gt; State&lt;E&gt; {
</a>     /// Applies a state machine mutation
     fn apply(&amp;mut self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
         match mutation {
<a href="#h5-5-3" id="h5-5-3" class="d">-            Mutation::Begin(mode) =&gt; {
</a><a href="#h5-5-4" id="h5-5-4" class="d">-                let txn = self.engine.begin(mode)?;
</a><a href="#h5-5-5" id="h5-5-5" class="i">+            Mutation::Begin { read_only, as_of } =&gt; {
</a><a href="#h5-5-6" id="h5-5-6" class="i">+                let txn = if !read_only {
</a><a href="#h5-5-7" id="h5-5-7" class="i">+                    self.engine.begin()?
</a><a href="#h5-5-8" id="h5-5-8" class="i">+                } else if let Some(version) = as_of {
</a><a href="#h5-5-9" id="h5-5-9" class="i">+                    self.engine.begin_as_of(version)?
</a><a href="#h5-5-10" id="h5-5-10" class="i">+                } else {
</a><a href="#h5-5-11" id="h5-5-11" class="i">+                    self.engine.begin_read_only()?
</a><a href="#h5-5-12" id="h5-5-12" class="i">+                };
</a>                 Raft::serialize(&amp;txn.state())
             }
             Mutation::Commit(txn) =&gt; Raft::serialize(&amp;self.engine.resume(txn)?.commit()?),
<b>diff --git a/<a id="h6" href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a> b/<a href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -12,7 +12,7 @@ use query::{Filter, Limit, Offset, Order, Projection};
</a> use schema::{CreateTable, DropTable};
 use source::{IndexLookup, KeyLookup, Nothing, Scan};
 
<a href="#h6-0-3" id="h6-0-3" class="d">-use super::engine::{Mode, Transaction};
</a><a href="#h6-0-4" id="h6-0-4" class="i">+use super::engine::Transaction;
</a> use super::plan::Node;
 use super::types::{Columns, Row, Rows, Value};
 use crate::error::{Error, Result};
<a href="#h6-1" id="h6-1" class="h">@@ -77,16 +77,16 @@ impl&lt;T: Transaction + &#39;static&gt; dyn Executor&lt;T&gt; {
</a> pub enum ResultSet {
     // Transaction started
     Begin {
<a href="#h6-1-3" id="h6-1-3" class="d">-        id: u64,
</a><a href="#h6-1-4" id="h6-1-4" class="d">-        mode: Mode,
</a><a href="#h6-1-5" id="h6-1-5" class="i">+        version: u64,
</a><a href="#h6-1-6" id="h6-1-6" class="i">+        read_only: bool,
</a>     },
     // Transaction committed
     Commit {
<a href="#h6-1-10" id="h6-1-10" class="d">-        id: u64,
</a><a href="#h6-1-11" id="h6-1-11" class="i">+        version: u64,
</a>     },
     // Transaction rolled back
     Rollback {
<a href="#h6-1-15" id="h6-1-15" class="d">-        id: u64,
</a><a href="#h6-1-16" id="h6-1-16" class="i">+        version: u64,
</a>     },
     // Rows created
     Create {
<b>diff --git a/<a id="h7" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -9,8 +9,8 @@ use std::mem::replace;
</a> #[allow(clippy::large_enum_variant)]
 pub enum Statement {
     Begin {
<a href="#h7-0-3" id="h7-0-3" class="d">-        readonly: bool,
</a><a href="#h7-0-4" id="h7-0-4" class="d">-        version: Option&lt;u64&gt;,
</a><a href="#h7-0-5" id="h7-0-5" class="i">+        read_only: bool,
</a><a href="#h7-0-6" id="h7-0-6" class="i">+        as_of: Option&lt;u64&gt;,
</a>     },
     Commit,
     Rollback,
<b>diff --git a/<a id="h8" href="../file/src/sql/parser/mod.rs.html">src/sql/parser/mod.rs</a> b/<a href="../file/src/sql/parser/mod.rs.html">src/sql/parser/mod.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -348,7 +348,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>                         }
                     }
                 }
<a href="#h8-0-3" id="h8-0-3" class="d">-                Ok(ast::Statement::Begin { readonly, version })
</a><a href="#h8-0-4" id="h8-0-4" class="i">+                Ok(ast::Statement::Begin { read_only: readonly, as_of: version })
</a>             }
             Token::Keyword(Keyword::Commit) =&gt; Ok(ast::Statement::Commit),
             Token::Keyword(Keyword::Rollback) =&gt; Ok(ast::Statement::Rollback),
<b>diff --git a/<a id="h9" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -8,24 +8,18 @@ use std::iter::Peekable;
</a> use std::ops::{Bound, RangeBounds};
 use std::sync::{Arc, Mutex, MutexGuard};
 
<a href="#h9-0-3" id="h9-0-3" class="d">-// TODO: for read-only transactions, don&#39;t allocate a transaction ID. Instead,
</a><a href="#h9-0-4" id="h9-0-4" class="d">-// keep the snapshot in the transaction object, and retain it in the SQL engine
</a><a href="#h9-0-5" id="h9-0-5" class="d">-// session to synthesize a new transaction from it (in particular, in the Raft
</a><a href="#h9-0-6" id="h9-0-6" class="d">-// engine). This removes the need to persist transaction IDs and snapshots for
</a><a href="#h9-0-7" id="h9-0-7" class="d">-// read-only transactions (including AOST transactions).
</a><a href="#h9-0-8" id="h9-0-8" class="d">-
</a> /// MVCC keys, using the KeyCode encoding which preserves the ordering and
 /// grouping of keys. Cow byte slices allow encoding borrowed values and
 /// decoding into owned values.
 #[derive(Debug, Deserialize, Serialize)]
 enum Key&lt;&#39;a&gt; {
<a href="#h9-0-14" id="h9-0-14" class="d">-    /// The next available transaction ID.
</a><a href="#h9-0-15" id="h9-0-15" class="i">+    /// The next available transaction version.
</a>     TxnNext,
<a href="#h9-0-17" id="h9-0-17" class="d">-    /// Markers for active (uncommitted) transactions by ID, storing the mode.
</a><a href="#h9-0-18" id="h9-0-18" class="i">+    /// Active (uncommitted) transactions by version.
</a>     TxnActive(u64),
<a href="#h9-0-20" id="h9-0-20" class="d">-    /// Transaction snapshot by ID, storing concurrent active transaction IDs.
</a><a href="#h9-0-21" id="h9-0-21" class="d">-    TxnSnapshot(u64),
</a><a href="#h9-0-22" id="h9-0-22" class="d">-    /// Update marker for a txn ID and key, used for rollback.
</a><a href="#h9-0-23" id="h9-0-23" class="i">+    /// Active set snapshots by version.
</a><a href="#h9-0-24" id="h9-0-24" class="i">+    TxnActiveSnapshot(u64),
</a><a href="#h9-0-25" id="h9-0-25" class="i">+    /// Update marker for a version and key, used for rollback.
</a>     TxnUpdate(
         u64,
         #[serde(with = &quot;serde_bytes&quot;)]
<a href="#h9-1" id="h9-1" class="h">@@ -85,18 +79,22 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a>         Self { engine: Arc::new(Mutex::new(engine)) }
     }
 
<a href="#h9-1-3" id="h9-1-3" class="d">-    /// Begins a new transaction in read-write mode.
</a><a href="#h9-1-4" id="h9-1-4" class="d">-    #[allow(dead_code)]
</a><a href="#h9-1-5" id="h9-1-5" class="i">+    /// Begins a new read-write transaction.
</a>     pub fn begin(&amp;self) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
<a href="#h9-1-7" id="h9-1-7" class="d">-        Transaction::begin(self.engine.clone(), Mode::ReadWrite)
</a><a href="#h9-1-8" id="h9-1-8" class="i">+        Transaction::begin(self.engine.clone())
</a>     }
 
<a href="#h9-1-11" id="h9-1-11" class="d">-    /// Begins a new transaction in the given mode.
</a><a href="#h9-1-12" id="h9-1-12" class="d">-    pub fn begin_with_mode(&amp;self, mode: Mode) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a><a href="#h9-1-13" id="h9-1-13" class="d">-        Transaction::begin(self.engine.clone(), mode)
</a><a href="#h9-1-14" id="h9-1-14" class="i">+    /// Begins a new read-only transaction at the latest version.
</a><a href="#h9-1-15" id="h9-1-15" class="i">+    pub fn begin_read_only(&amp;self) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a><a href="#h9-1-16" id="h9-1-16" class="i">+        Transaction::begin_read_only(self.engine.clone(), None)
</a>     }
 
<a href="#h9-1-19" id="h9-1-19" class="d">-    /// Resumes a transaction from the given state.
</a><a href="#h9-1-20" id="h9-1-20" class="i">+    /// Begins a new read-only transaction as of the given version.
</a><a href="#h9-1-21" id="h9-1-21" class="i">+    pub fn begin_as_of(&amp;self, version: u64) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a><a href="#h9-1-22" id="h9-1-22" class="i">+        Transaction::begin_read_only(self.engine.clone(), Some(version))
</a><a href="#h9-1-23" id="h9-1-23" class="i">+    }
</a><a href="#h9-1-24" id="h9-1-24" class="i">+
</a><a href="#h9-1-25" id="h9-1-25" class="i">+    /// Resumes a transaction from the given transaction state.
</a>     pub fn resume(&amp;self, state: TransactionState) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
         Transaction::resume(self.engine.clone(), state)
     }
<a href="#h9-2" id="h9-2" class="h">@@ -135,12 +133,16 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a> pub struct Transaction&lt;E: Engine&gt; {
     /// The underlying engine for the transaction. Shared between transactions using a mutex.
     engine: Arc&lt;Mutex&lt;E&gt;&gt;,
<a href="#h9-2-3" id="h9-2-3" class="d">-    /// The unique transaction ID.
</a><a href="#h9-2-4" id="h9-2-4" class="d">-    id: u64,
</a><a href="#h9-2-5" id="h9-2-5" class="d">-    /// The transaction mode.
</a><a href="#h9-2-6" id="h9-2-6" class="d">-    mode: Mode,
</a><a href="#h9-2-7" id="h9-2-7" class="d">-    /// The snapshot that the transaction is running in.
</a><a href="#h9-2-8" id="h9-2-8" class="d">-    snapshot: Snapshot,
</a><a href="#h9-2-9" id="h9-2-9" class="i">+    /// The version this transaction is running at. Only one read-write
</a><a href="#h9-2-10" id="h9-2-10" class="i">+    /// transaction can run at a given version, since this identifies its
</a><a href="#h9-2-11" id="h9-2-11" class="i">+    /// writes.
</a><a href="#h9-2-12" id="h9-2-12" class="i">+    version: u64,
</a><a href="#h9-2-13" id="h9-2-13" class="i">+    /// If true, the transaction is read only.
</a><a href="#h9-2-14" id="h9-2-14" class="i">+    read_only: bool,
</a><a href="#h9-2-15" id="h9-2-15" class="i">+    /// The set of concurrent active (uncommitted) transactions. Their writes
</a><a href="#h9-2-16" id="h9-2-16" class="i">+    /// should be invisible to this transaction even if they&#39;re writing at a
</a><a href="#h9-2-17" id="h9-2-17" class="i">+    /// lower version, since they&#39;re not committed yet.
</a><a href="#h9-2-18" id="h9-2-18" class="i">+    active: HashSet&lt;u64&gt;,
</a> }
 
 /// A serializable representation of a Transaction&#39;s state. It can be exported
<a href="#h9-3" id="h9-3" class="h">@@ -150,92 +152,157 @@ pub struct Transaction&lt;E: Engine&gt; {
</a> /// across the Raft state machine boundary.
 #[derive(Clone, Serialize, Deserialize)]
 pub struct TransactionState {
<a href="#h9-3-3" id="h9-3-3" class="d">-    pub id: u64,
</a><a href="#h9-3-4" id="h9-3-4" class="d">-    pub mode: Mode,
</a><a href="#h9-3-5" id="h9-3-5" class="d">-    pub snapshot: Snapshot,
</a><a href="#h9-3-6" id="h9-3-6" class="i">+    pub version: u64,
</a><a href="#h9-3-7" id="h9-3-7" class="i">+    pub read_only: bool,
</a><a href="#h9-3-8" id="h9-3-8" class="i">+    pub active: HashSet&lt;u64&gt;,
</a> }
 
 impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
<a href="#h9-3-12" id="h9-3-12" class="d">-    /// Begins a new transaction in the given mode.
</a><a href="#h9-3-13" id="h9-3-13" class="d">-    fn begin(engine: Arc&lt;Mutex&lt;E&gt;&gt;, mode: Mode) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-3-14" id="h9-3-14" class="i">+    /// Begins a new transaction in read-write mode. This will allocate a new
</a><a href="#h9-3-15" id="h9-3-15" class="i">+    /// version that the transaction can write at, add it to the active set, and
</a><a href="#h9-3-16" id="h9-3-16" class="i">+    /// record its active snapshot for time-travel queries.
</a><a href="#h9-3-17" id="h9-3-17" class="i">+    fn begin(engine: Arc&lt;Mutex&lt;E&gt;&gt;) -&gt; Result&lt;Self&gt; {
</a>         let mut session = engine.lock()?;
 
<a href="#h9-3-20" id="h9-3-20" class="d">-        let id = match session.get(&amp;Key::TxnNext.encode()?)? {
</a><a href="#h9-3-21" id="h9-3-21" class="i">+        // Allocate a new version to write at.
</a><a href="#h9-3-22" id="h9-3-22" class="i">+        let version = match session.get(&amp;Key::TxnNext.encode()?)? {
</a>             Some(ref v) =&gt; bincode::deserialize(v)?,
             None =&gt; 1,
         };
<a href="#h9-3-26" id="h9-3-26" class="d">-        session.set(&amp;Key::TxnNext.encode()?, bincode::serialize(&amp;(id + 1))?)?;
</a><a href="#h9-3-27" id="h9-3-27" class="d">-        session.set(&amp;Key::TxnActive(id).encode()?, bincode::serialize(&amp;mode)?)?;
</a><a href="#h9-3-28" id="h9-3-28" class="d">-
</a><a href="#h9-3-29" id="h9-3-29" class="d">-        // We always take a new snapshot, even for snapshot transactions, because all transactions
</a><a href="#h9-3-30" id="h9-3-30" class="d">-        // increment the transaction ID and we need to properly record currently active transactions
</a><a href="#h9-3-31" id="h9-3-31" class="d">-        // for any future snapshot transactions looking at this one.
</a><a href="#h9-3-32" id="h9-3-32" class="d">-        let mut snapshot = Snapshot::take(&amp;mut session, id)?;
</a><a href="#h9-3-33" id="h9-3-33" class="d">-        if let Mode::Snapshot { version } = &amp;mode {
</a><a href="#h9-3-34" id="h9-3-34" class="d">-            snapshot = Snapshot::restore(&amp;mut session, *version)?
</a><a href="#h9-3-35" id="h9-3-35" class="i">+        session.set(&amp;Key::TxnNext.encode()?, bincode::serialize(&amp;(version + 1))?)?;
</a><a href="#h9-3-36" id="h9-3-36" class="i">+
</a><a href="#h9-3-37" id="h9-3-37" class="i">+        // Fetch the current set of active transactions, persist it for
</a><a href="#h9-3-38" id="h9-3-38" class="i">+        // time-travel queries if non-empty, then add this txn to it.
</a><a href="#h9-3-39" id="h9-3-39" class="i">+        let active = Self::scan_active(&amp;mut session)?;
</a><a href="#h9-3-40" id="h9-3-40" class="i">+        if !active.is_empty() {
</a><a href="#h9-3-41" id="h9-3-41" class="i">+            session.set(&amp;Key::TxnActiveSnapshot(version).encode()?, bincode::serialize(&amp;active)?)?
</a>         }
<a href="#h9-3-43" id="h9-3-43" class="i">+        session.set(&amp;Key::TxnActive(version).encode()?, vec![])?;
</a>         drop(session);
 
<a href="#h9-3-46" id="h9-3-46" class="d">-        Ok(Self { engine, id, mode, snapshot })
</a><a href="#h9-3-47" id="h9-3-47" class="i">+        Ok(Self { engine, version, read_only: false, active })
</a><a href="#h9-3-48" id="h9-3-48" class="i">+    }
</a><a href="#h9-3-49" id="h9-3-49" class="i">+
</a><a href="#h9-3-50" id="h9-3-50" class="i">+    /// Begins a new read-only transaction. If version is given it will see the
</a><a href="#h9-3-51" id="h9-3-51" class="i">+    /// state as of the beginning of that version (ignoring writes at that
</a><a href="#h9-3-52" id="h9-3-52" class="i">+    /// version). In other words, it sees the same state as the read-write
</a><a href="#h9-3-53" id="h9-3-53" class="i">+    /// transaction at that version saw when it began.
</a><a href="#h9-3-54" id="h9-3-54" class="i">+    fn begin_read_only(engine: Arc&lt;Mutex&lt;E&gt;&gt;, as_of: Option&lt;u64&gt;) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-3-55" id="h9-3-55" class="i">+        let mut session = engine.lock()?;
</a><a href="#h9-3-56" id="h9-3-56" class="i">+
</a><a href="#h9-3-57" id="h9-3-57" class="i">+        // Fetch the latest version.
</a><a href="#h9-3-58" id="h9-3-58" class="i">+        let mut version = match session.get(&amp;Key::TxnNext.encode()?)? {
</a><a href="#h9-3-59" id="h9-3-59" class="i">+            Some(ref v) =&gt; bincode::deserialize(v)?,
</a><a href="#h9-3-60" id="h9-3-60" class="i">+            None =&gt; 1,
</a><a href="#h9-3-61" id="h9-3-61" class="i">+        };
</a><a href="#h9-3-62" id="h9-3-62" class="i">+
</a><a href="#h9-3-63" id="h9-3-63" class="i">+        // If requested, create the transaction as of a past version, restoring
</a><a href="#h9-3-64" id="h9-3-64" class="i">+        // the active snapshot as of the beginning of that version. Otherwise,
</a><a href="#h9-3-65" id="h9-3-65" class="i">+        // use the latest version and get the current, real-time snapshot.
</a><a href="#h9-3-66" id="h9-3-66" class="i">+        let mut active = HashSet::new();
</a><a href="#h9-3-67" id="h9-3-67" class="i">+        if let Some(as_of) = as_of {
</a><a href="#h9-3-68" id="h9-3-68" class="i">+            if as_of &gt;= version {
</a><a href="#h9-3-69" id="h9-3-69" class="i">+                return Err(Error::Value(format!(&quot;Version {} does not exist&quot;, as_of)));
</a><a href="#h9-3-70" id="h9-3-70" class="i">+            }
</a><a href="#h9-3-71" id="h9-3-71" class="i">+            version = as_of;
</a><a href="#h9-3-72" id="h9-3-72" class="i">+            if let Some(value) = session.get(&amp;Key::TxnActiveSnapshot(version).encode()?)? {
</a><a href="#h9-3-73" id="h9-3-73" class="i">+                active = bincode::deserialize(&amp;value)?;
</a><a href="#h9-3-74" id="h9-3-74" class="i">+            }
</a><a href="#h9-3-75" id="h9-3-75" class="i">+        } else {
</a><a href="#h9-3-76" id="h9-3-76" class="i">+            active = Self::scan_active(&amp;mut session)?;
</a><a href="#h9-3-77" id="h9-3-77" class="i">+        }
</a><a href="#h9-3-78" id="h9-3-78" class="i">+
</a><a href="#h9-3-79" id="h9-3-79" class="i">+        drop(session);
</a><a href="#h9-3-80" id="h9-3-80" class="i">+
</a><a href="#h9-3-81" id="h9-3-81" class="i">+        Ok(Self { engine, version, read_only: true, active })
</a>     }
 
     /// Resumes a transaction from the given state.
<a href="#h9-3-85" id="h9-3-85" class="d">-    fn resume(engine: Arc&lt;Mutex&lt;E&gt;&gt;, state: TransactionState) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-3-86" id="h9-3-86" class="i">+    fn resume(engine: Arc&lt;Mutex&lt;E&gt;&gt;, s: TransactionState) -&gt; Result&lt;Self&gt; {
</a>         // For read-write transactions, verify that the transaction is still
         // active before making further writes.
<a href="#h9-3-89" id="h9-3-89" class="d">-        if state.mode == Mode::ReadWrite
</a><a href="#h9-3-90" id="h9-3-90" class="d">-            &amp;&amp; engine.lock()?.get(&amp;Key::TxnActive(state.id).encode()?)?.is_none()
</a><a href="#h9-3-91" id="h9-3-91" class="d">-        {
</a><a href="#h9-3-92" id="h9-3-92" class="d">-            return Err(Error::Internal(format!(&quot;No active transaction with ID {}&quot;, state.id)));
</a><a href="#h9-3-93" id="h9-3-93" class="i">+        if !s.read_only &amp;&amp; engine.lock()?.get(&amp;Key::TxnActive(s.version).encode()?)?.is_none() {
</a><a href="#h9-3-94" id="h9-3-94" class="i">+            return Err(Error::Internal(format!(&quot;No active transaction at version {}&quot;, s.version)));
</a>         }
<a href="#h9-3-96" id="h9-3-96" class="d">-        Ok(Self { engine, id: state.id, mode: state.mode, snapshot: state.snapshot })
</a><a href="#h9-3-97" id="h9-3-97" class="i">+        Ok(Self { engine, version: s.version, read_only: s.read_only, active: s.active })
</a>     }
 
<a href="#h9-3-100" id="h9-3-100" class="d">-    /// Returns the transaction ID.
</a><a href="#h9-3-101" id="h9-3-101" class="d">-    pub fn id(&amp;self) -&gt; u64 {
</a><a href="#h9-3-102" id="h9-3-102" class="d">-        self.id
</a><a href="#h9-3-103" id="h9-3-103" class="i">+    /// Scans the set of currently active transactions.
</a><a href="#h9-3-104" id="h9-3-104" class="i">+    fn scan_active(session: &amp;mut MutexGuard&lt;E&gt;) -&gt; Result&lt;HashSet&lt;u64&gt;&gt; {
</a><a href="#h9-3-105" id="h9-3-105" class="i">+        let mut active = HashSet::new();
</a><a href="#h9-3-106" id="h9-3-106" class="i">+        // TODO: Add Engine.scan_prefix() trait method.
</a><a href="#h9-3-107" id="h9-3-107" class="i">+        let mut scan =
</a><a href="#h9-3-108" id="h9-3-108" class="i">+            session.scan(Key::TxnActive(0).encode()?..=Key::TxnActive(u64::MAX).encode()?);
</a><a href="#h9-3-109" id="h9-3-109" class="i">+        while let Some((key, _)) = scan.next().transpose()? {
</a><a href="#h9-3-110" id="h9-3-110" class="i">+            match Key::decode(&amp;key)? {
</a><a href="#h9-3-111" id="h9-3-111" class="i">+                Key::TxnActive(version) =&gt; active.insert(version),
</a><a href="#h9-3-112" id="h9-3-112" class="i">+                _ =&gt; return Err(Error::Internal(format!(&quot;Expected TxnActive key, got {:?}&quot;, key))),
</a><a href="#h9-3-113" id="h9-3-113" class="i">+            };
</a><a href="#h9-3-114" id="h9-3-114" class="i">+        }
</a><a href="#h9-3-115" id="h9-3-115" class="i">+        Ok(active)
</a><a href="#h9-3-116" id="h9-3-116" class="i">+    }
</a><a href="#h9-3-117" id="h9-3-117" class="i">+
</a><a href="#h9-3-118" id="h9-3-118" class="i">+    /// Returns the version the transaction is running at.
</a><a href="#h9-3-119" id="h9-3-119" class="i">+    pub fn version(&amp;self) -&gt; u64 {
</a><a href="#h9-3-120" id="h9-3-120" class="i">+        self.version
</a>     }
 
<a href="#h9-3-123" id="h9-3-123" class="d">-    /// Returns the transaction mode.
</a><a href="#h9-3-124" id="h9-3-124" class="d">-    pub fn mode(&amp;self) -&gt; Mode {
</a><a href="#h9-3-125" id="h9-3-125" class="d">-        self.mode
</a><a href="#h9-3-126" id="h9-3-126" class="i">+    /// Returns whether the transaction is read-only.
</a><a href="#h9-3-127" id="h9-3-127" class="i">+    pub fn read_only(&amp;self) -&gt; bool {
</a><a href="#h9-3-128" id="h9-3-128" class="i">+        self.read_only
</a>     }
 
     /// Returns the transaction&#39;s state. This can be used to instantiate a
     /// functionally equivalent transaction via resume().
     pub fn state(&amp;self) -&gt; TransactionState {
<a href="#h9-3-134" id="h9-3-134" class="d">-        TransactionState { id: self.id, mode: self.mode, snapshot: self.snapshot.clone() }
</a><a href="#h9-3-135" id="h9-3-135" class="i">+        TransactionState {
</a><a href="#h9-3-136" id="h9-3-136" class="i">+            version: self.version,
</a><a href="#h9-3-137" id="h9-3-137" class="i">+            read_only: self.read_only,
</a><a href="#h9-3-138" id="h9-3-138" class="i">+            active: self.active.clone(), // TODO: avoid cloning
</a><a href="#h9-3-139" id="h9-3-139" class="i">+        }
</a>     }
 
     /// Commits the transaction, by removing the txn from the active set.
     pub fn commit(self) -&gt; Result&lt;()&gt; {
         let mut session = self.engine.lock()?;
<a href="#h9-3-145" id="h9-3-145" class="d">-        session.delete(&amp;Key::TxnActive(self.id).encode()?)?;
</a><a href="#h9-3-146" id="h9-3-146" class="i">+        session.delete(&amp;Key::TxnActive(self.version).encode()?)?;
</a>         session.flush()
     }
 
     /// Rolls back the transaction, by removing all updated entries.
     pub fn rollback(self) -&gt; Result&lt;()&gt; {
<a href="#h9-3-152" id="h9-3-152" class="i">+        if self.read_only {
</a><a href="#h9-3-153" id="h9-3-153" class="i">+            return Ok(());
</a><a href="#h9-3-154" id="h9-3-154" class="i">+        }
</a>         let mut session = self.engine.lock()?;
<a href="#h9-3-156" id="h9-3-156" class="d">-        if self.mode.mutable() {
</a><a href="#h9-3-157" id="h9-3-157" class="d">-            let mut rollback = Vec::new();
</a><a href="#h9-3-158" id="h9-3-158" class="d">-            let mut scan = session.scan(
</a><a href="#h9-3-159" id="h9-3-159" class="d">-                Key::TxnUpdate(self.id, vec![].into()).encode()?
</a><a href="#h9-3-160" id="h9-3-160" class="d">-                    ..Key::TxnUpdate(self.id + 1, vec![].into()).encode()?,
</a><a href="#h9-3-161" id="h9-3-161" class="d">-            );
</a><a href="#h9-3-162" id="h9-3-162" class="d">-            while let Some((key, _)) = scan.next().transpose()? {
</a><a href="#h9-3-163" id="h9-3-163" class="d">-                match Key::decode(&amp;key)? {
</a><a href="#h9-3-164" id="h9-3-164" class="d">-                    Key::TxnUpdate(_, updated_key) =&gt; rollback.push(updated_key.into_owned()),
</a><a href="#h9-3-165" id="h9-3-165" class="d">-                    k =&gt; return Err(Error::Internal(format!(&quot;Expected TxnUpdate, got {:?}&quot;, k))),
</a><a href="#h9-3-166" id="h9-3-166" class="d">-                };
</a><a href="#h9-3-167" id="h9-3-167" class="d">-                rollback.push(key);
</a><a href="#h9-3-168" id="h9-3-168" class="d">-            }
</a><a href="#h9-3-169" id="h9-3-169" class="d">-            std::mem::drop(scan);
</a><a href="#h9-3-170" id="h9-3-170" class="d">-            for key in rollback.into_iter() {
</a><a href="#h9-3-171" id="h9-3-171" class="d">-                session.delete(&amp;key)?;
</a><a href="#h9-3-172" id="h9-3-172" class="d">-            }
</a><a href="#h9-3-173" id="h9-3-173" class="i">+        let mut rollback = Vec::new();
</a><a href="#h9-3-174" id="h9-3-174" class="i">+        let mut scan = session.scan(
</a><a href="#h9-3-175" id="h9-3-175" class="i">+            Key::TxnUpdate(self.version, vec![].into()).encode()?
</a><a href="#h9-3-176" id="h9-3-176" class="i">+                ..Key::TxnUpdate(self.version + 1, vec![].into()).encode()?,
</a><a href="#h9-3-177" id="h9-3-177" class="i">+        );
</a><a href="#h9-3-178" id="h9-3-178" class="i">+        while let Some((key, _)) = scan.next().transpose()? {
</a><a href="#h9-3-179" id="h9-3-179" class="i">+            match Key::decode(&amp;key)? {
</a><a href="#h9-3-180" id="h9-3-180" class="i">+                Key::TxnUpdate(_, updated_key) =&gt; rollback.push(updated_key.into_owned()),
</a><a href="#h9-3-181" id="h9-3-181" class="i">+                k =&gt; return Err(Error::Internal(format!(&quot;Expected TxnUpdate, got {:?}&quot;, k))),
</a><a href="#h9-3-182" id="h9-3-182" class="i">+            };
</a><a href="#h9-3-183" id="h9-3-183" class="i">+            rollback.push(key);
</a><a href="#h9-3-184" id="h9-3-184" class="i">+        }
</a><a href="#h9-3-185" id="h9-3-185" class="i">+        std::mem::drop(scan);
</a><a href="#h9-3-186" id="h9-3-186" class="i">+        for key in rollback.into_iter() {
</a><a href="#h9-3-187" id="h9-3-187" class="i">+            session.delete(&amp;key)?;
</a><a href="#h9-3-188" id="h9-3-188" class="i">+        }
</a><a href="#h9-3-189" id="h9-3-189" class="i">+        session.delete(&amp;Key::TxnActive(self.version).encode()?)
</a><a href="#h9-3-190" id="h9-3-190" class="i">+    }
</a><a href="#h9-3-191" id="h9-3-191" class="i">+
</a><a href="#h9-3-192" id="h9-3-192" class="i">+    /// Checks whether the given version is visible to this transaction.
</a><a href="#h9-3-193" id="h9-3-193" class="i">+    fn is_visible(&amp;self, version: u64) -&gt; bool {
</a><a href="#h9-3-194" id="h9-3-194" class="i">+        if self.active.get(&amp;version).is_some() {
</a><a href="#h9-3-195" id="h9-3-195" class="i">+            false
</a><a href="#h9-3-196" id="h9-3-196" class="i">+        } else if self.read_only {
</a><a href="#h9-3-197" id="h9-3-197" class="i">+            version &lt; self.version
</a><a href="#h9-3-198" id="h9-3-198" class="i">+        } else {
</a><a href="#h9-3-199" id="h9-3-199" class="i">+            version &lt;= self.version
</a>         }
<a href="#h9-3-201" id="h9-3-201" class="d">-        session.delete(&amp;Key::TxnActive(self.id).encode()?)
</a>     }
 
     /// Deletes a key.
<a href="#h9-4" id="h9-4" class="h">@@ -249,13 +316,13 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         let mut scan = session
             .scan(
                 Key::Version(key.into(), 0).encode()?
<a href="#h9-4-3" id="h9-4-3" class="d">-                    ..=Key::Version(key.into(), self.id).encode()?,
</a><a href="#h9-4-4" id="h9-4-4" class="i">+                    ..=Key::Version(key.into(), self.version).encode()?,
</a>             )
             .rev();
         while let Some((k, v)) = scan.next().transpose()? {
             match Key::decode(&amp;k)? {
                 Key::Version(_, version) =&gt; {
<a href="#h9-4-10" id="h9-4-10" class="d">-                    if self.snapshot.is_visible(version) {
</a><a href="#h9-4-11" id="h9-4-11" class="i">+                    if self.is_visible(version) {
</a>                         return Ok(bincode::deserialize(&amp;v)?);
                     }
                 }
<a href="#h9-5" id="h9-5" class="h">@@ -279,7 +346,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         };
         // TODO: For now, collect results from the engine to not have to deal with lifetimes.
         let scan = Box::new(self.engine.lock()?.scan((start, end)).collect::&lt;Vec&lt;_&gt;&gt;().into_iter());
<a href="#h9-5-3" id="h9-5-3" class="d">-        Ok(Box::new(Scan::new(scan, self.snapshot.clone())))
</a><a href="#h9-5-4" id="h9-5-4" class="i">+        Ok(Box::new(Scan::new(scan, self.version, self.read_only, self.active.clone())))
</a>     }
 
     /// Scans keys under a given prefix.
<a href="#h9-6" id="h9-6" class="h">@@ -313,14 +380,14 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a> 
     /// Writes a value for a key. None is used for deletion.
     fn write(&amp;self, key: &amp;[u8], value: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;()&gt; {
<a href="#h9-6-3" id="h9-6-3" class="d">-        if !self.mode.mutable() {
</a><a href="#h9-6-4" id="h9-6-4" class="i">+        if self.read_only {
</a>             return Err(Error::ReadOnly);
         }
         let mut session = self.engine.lock()?;
 
         // Check if the key is dirty, i.e. if it has any uncommitted changes, by scanning for any
         // versions that aren&#39;t visible to us.
<a href="#h9-6-11" id="h9-6-11" class="d">-        let min = self.snapshot.invisible.iter().min().cloned().unwrap_or(self.id + 1);
</a><a href="#h9-6-12" id="h9-6-12" class="i">+        let min = self.active.iter().min().cloned().unwrap_or(self.version + 1);
</a>         let mut scan = session
             .scan(
                 Key::Version(key.into(), min).encode()?
<a href="#h9-7" id="h9-7" class="h">@@ -330,7 +397,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         while let Some((k, _)) = scan.next().transpose()? {
             match Key::decode(&amp;k)? {
                 Key::Version(_, version) =&gt; {
<a href="#h9-7-3" id="h9-7-3" class="d">-                    if !self.snapshot.is_visible(version) {
</a><a href="#h9-7-4" id="h9-7-4" class="i">+                    if !self.is_visible(version) {
</a>                         return Err(Error::Serialization);
                     }
                 }
<a href="#h9-8" id="h9-8" class="h">@@ -340,8 +407,8 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         std::mem::drop(scan);
 
         // Write the key and its update record.
<a href="#h9-8-3" id="h9-8-3" class="d">-        let key = Key::Version(key.into(), self.id).encode()?;
</a><a href="#h9-8-4" id="h9-8-4" class="d">-        let update = Key::TxnUpdate(self.id, (&amp;key).into()).encode()?;
</a><a href="#h9-8-5" id="h9-8-5" class="i">+        let key = Key::Version(key.into(), self.version).encode()?;
</a><a href="#h9-8-6" id="h9-8-6" class="i">+        let update = Key::TxnUpdate(self.version, (&amp;key).into()).encode()?;
</a>         session.set(&amp;update, vec![])?;
         session.set(&amp;key, bincode::serialize(&amp;value)?)
     }
<a href="#h9-9" id="h9-9" class="h">@@ -383,47 +450,6 @@ impl Mode {
</a>     }
 }
 
<a href="#h9-9-3" id="h9-9-3" class="d">-/// A versioned snapshot, containing visibility information about concurrent transactions.
</a><a href="#h9-9-4" id="h9-9-4" class="d">-#[derive(Clone, Deserialize, Serialize)]
</a><a href="#h9-9-5" id="h9-9-5" class="d">-pub struct Snapshot {
</a><a href="#h9-9-6" id="h9-9-6" class="d">-    /// The version (i.e. transaction ID) that the snapshot belongs to.
</a><a href="#h9-9-7" id="h9-9-7" class="d">-    pub version: u64,
</a><a href="#h9-9-8" id="h9-9-8" class="d">-    /// The set of transaction IDs that were active at the start of the transactions,
</a><a href="#h9-9-9" id="h9-9-9" class="d">-    /// and thus should be invisible to the snapshot.
</a><a href="#h9-9-10" id="h9-9-10" class="d">-    pub invisible: HashSet&lt;u64&gt;,
</a><a href="#h9-9-11" id="h9-9-11" class="d">-}
</a><a href="#h9-9-12" id="h9-9-12" class="d">-
</a><a href="#h9-9-13" id="h9-9-13" class="d">-impl Snapshot {
</a><a href="#h9-9-14" id="h9-9-14" class="d">-    /// Takes a new snapshot, persisting it as `Key::TxnSnapshot(version)`.
</a><a href="#h9-9-15" id="h9-9-15" class="d">-    fn take&lt;E: Engine&gt;(session: &amp;mut MutexGuard&lt;E&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-9-16" id="h9-9-16" class="d">-        let mut snapshot = Self { version, invisible: HashSet::new() };
</a><a href="#h9-9-17" id="h9-9-17" class="d">-        let mut scan = session.scan(Key::TxnActive(0).encode()?..Key::TxnActive(version).encode()?);
</a><a href="#h9-9-18" id="h9-9-18" class="d">-        while let Some((key, _)) = scan.next().transpose()? {
</a><a href="#h9-9-19" id="h9-9-19" class="d">-            match Key::decode(&amp;key)? {
</a><a href="#h9-9-20" id="h9-9-20" class="d">-                Key::TxnActive(id) =&gt; snapshot.invisible.insert(id),
</a><a href="#h9-9-21" id="h9-9-21" class="d">-                k =&gt; return Err(Error::Internal(format!(&quot;Expected TxnActive, got {:?}&quot;, k))),
</a><a href="#h9-9-22" id="h9-9-22" class="d">-            };
</a><a href="#h9-9-23" id="h9-9-23" class="d">-        }
</a><a href="#h9-9-24" id="h9-9-24" class="d">-        std::mem::drop(scan);
</a><a href="#h9-9-25" id="h9-9-25" class="d">-        session
</a><a href="#h9-9-26" id="h9-9-26" class="d">-            .set(&amp;Key::TxnSnapshot(version).encode()?, bincode::serialize(&amp;snapshot.invisible)?)?;
</a><a href="#h9-9-27" id="h9-9-27" class="d">-        Ok(snapshot)
</a><a href="#h9-9-28" id="h9-9-28" class="d">-    }
</a><a href="#h9-9-29" id="h9-9-29" class="d">-
</a><a href="#h9-9-30" id="h9-9-30" class="d">-    /// Restores an existing snapshot from `Key::TxnSnapshot(version)`, or errors if not found.
</a><a href="#h9-9-31" id="h9-9-31" class="d">-    fn restore&lt;E: Engine&gt;(session: &amp;mut MutexGuard&lt;E&gt;, version: u64) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-9-32" id="h9-9-32" class="d">-        match session.get(&amp;Key::TxnSnapshot(version).encode()?)? {
</a><a href="#h9-9-33" id="h9-9-33" class="d">-            Some(ref v) =&gt; Ok(Self { version, invisible: bincode::deserialize(v)? }),
</a><a href="#h9-9-34" id="h9-9-34" class="d">-            None =&gt; Err(Error::Value(format!(&quot;Snapshot not found for version {}&quot;, version))),
</a><a href="#h9-9-35" id="h9-9-35" class="d">-        }
</a><a href="#h9-9-36" id="h9-9-36" class="d">-    }
</a><a href="#h9-9-37" id="h9-9-37" class="d">-
</a><a href="#h9-9-38" id="h9-9-38" class="d">-    /// Checks whether the given version is visible in this snapshot.
</a><a href="#h9-9-39" id="h9-9-39" class="d">-    fn is_visible(&amp;self, version: u64) -&gt; bool {
</a><a href="#h9-9-40" id="h9-9-40" class="d">-        version &lt;= self.version &amp;&amp; self.invisible.get(&amp;version).is_none()
</a><a href="#h9-9-41" id="h9-9-41" class="d">-    }
</a><a href="#h9-9-42" id="h9-9-42" class="d">-}
</a><a href="#h9-9-43" id="h9-9-43" class="d">-
</a> pub type ScanIterator&lt;&#39;a&gt; =
     Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; + Send + &#39;a&gt;;
 
<a href="#h9-10" id="h9-10" class="h">@@ -438,7 +464,28 @@ pub struct Scan&lt;&#39;a&gt; {
</a> 
 impl&lt;&#39;a&gt; Scan&lt;&#39;a&gt; {
     /// Creates a new scan.
<a href="#h9-10-3" id="h9-10-3" class="d">-    fn new(mut scan: ScanIterator&lt;&#39;a&gt;, snapshot: Snapshot) -&gt; Self {
</a><a href="#h9-10-4" id="h9-10-4" class="i">+    fn new(
</a><a href="#h9-10-5" id="h9-10-5" class="i">+        mut scan: ScanIterator&lt;&#39;a&gt;,
</a><a href="#h9-10-6" id="h9-10-6" class="i">+        txn_version: u64,
</a><a href="#h9-10-7" id="h9-10-7" class="i">+        read_only: bool,
</a><a href="#h9-10-8" id="h9-10-8" class="i">+        snapshot: HashSet&lt;u64&gt;,
</a><a href="#h9-10-9" id="h9-10-9" class="i">+    ) -&gt; Self {
</a><a href="#h9-10-10" id="h9-10-10" class="i">+        /// Checks whether the given version is visible to this transaction.
</a><a href="#h9-10-11" id="h9-10-11" class="i">+        fn is_visible(
</a><a href="#h9-10-12" id="h9-10-12" class="i">+            txn_version: u64,
</a><a href="#h9-10-13" id="h9-10-13" class="i">+            read_only: bool,
</a><a href="#h9-10-14" id="h9-10-14" class="i">+            snapshot: &amp;HashSet&lt;u64&gt;,
</a><a href="#h9-10-15" id="h9-10-15" class="i">+            version: u64,
</a><a href="#h9-10-16" id="h9-10-16" class="i">+        ) -&gt; bool {
</a><a href="#h9-10-17" id="h9-10-17" class="i">+            if snapshot.get(&amp;version).is_some() {
</a><a href="#h9-10-18" id="h9-10-18" class="i">+                false
</a><a href="#h9-10-19" id="h9-10-19" class="i">+            } else if read_only {
</a><a href="#h9-10-20" id="h9-10-20" class="i">+                version &lt; txn_version
</a><a href="#h9-10-21" id="h9-10-21" class="i">+            } else {
</a><a href="#h9-10-22" id="h9-10-22" class="i">+                version &lt;= txn_version
</a><a href="#h9-10-23" id="h9-10-23" class="i">+            }
</a><a href="#h9-10-24" id="h9-10-24" class="i">+        }
</a><a href="#h9-10-25" id="h9-10-25" class="i">+
</a>         // Augment the underlying scan to decode the key and filter invisible versions. We don&#39;t
         // return the version, since we don&#39;t need it, but beware that all versions of the key
         // will still be returned - we usually only need the last, which is what the next() and
<a href="#h9-11" id="h9-11" class="h">@@ -446,7 +493,11 @@ impl&lt;&#39;a&gt; Scan&lt;&#39;a&gt; {
</a>         // to decode the last version.
         scan = Box::new(scan.filter_map(move |r| {
             r.and_then(|(k, v)| match Key::decode(&amp;k)? {
<a href="#h9-11-3" id="h9-11-3" class="d">-                Key::Version(_, version) if !snapshot.is_visible(version) =&gt; Ok(None),
</a><a href="#h9-11-4" id="h9-11-4" class="i">+                Key::Version(_, version)
</a><a href="#h9-11-5" id="h9-11-5" class="i">+                    if !is_visible(txn_version, read_only, &amp;snapshot, version) =&gt;
</a><a href="#h9-11-6" id="h9-11-6" class="i">+                {
</a><a href="#h9-11-7" id="h9-11-7" class="i">+                    Ok(None)
</a><a href="#h9-11-8" id="h9-11-8" class="i">+                }
</a>                 Key::Version(key, _) =&gt; Ok(Some((key.into_owned(), v))),
                 k =&gt; Err(Error::Internal(format!(&quot;Expected Record, got {:?}&quot;, k))),
             })
<a href="#h9-12" id="h9-12" class="h">@@ -521,97 +572,77 @@ pub mod tests {
</a>         let mvcc = setup();
 
         let txn = mvcc.begin()?;
<a href="#h9-12-3" id="h9-12-3" class="d">-        assert_eq!(1, txn.id());
</a><a href="#h9-12-4" id="h9-12-4" class="d">-        assert_eq!(Mode::ReadWrite, txn.mode());
</a><a href="#h9-12-5" id="h9-12-5" class="i">+        assert_eq!(1, txn.version());
</a><a href="#h9-12-6" id="h9-12-6" class="i">+        assert!(!txn.read_only());
</a>         txn.commit()?;
 
         let txn = mvcc.begin()?;
<a href="#h9-12-10" id="h9-12-10" class="d">-        assert_eq!(2, txn.id());
</a><a href="#h9-12-11" id="h9-12-11" class="i">+        assert_eq!(2, txn.version());
</a>         txn.rollback()?;
 
         let txn = mvcc.begin()?;
<a href="#h9-12-15" id="h9-12-15" class="d">-        assert_eq!(3, txn.id());
</a><a href="#h9-12-16" id="h9-12-16" class="i">+        assert_eq!(3, txn.version());
</a>         txn.commit()?;
 
         Ok(())
     }
 
     #[test]
<a href="#h9-12-23" id="h9-12-23" class="d">-    fn test_begin_with_mode_readonly() -&gt; Result&lt;()&gt; {
</a><a href="#h9-12-24" id="h9-12-24" class="i">+    fn test_begin_read_only() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
<a href="#h9-12-26" id="h9-12-26" class="d">-        let txn = mvcc.begin_with_mode(Mode::ReadOnly)?;
</a><a href="#h9-12-27" id="h9-12-27" class="d">-        assert_eq!(1, txn.id());
</a><a href="#h9-12-28" id="h9-12-28" class="d">-        assert_eq!(Mode::ReadOnly, txn.mode());
</a><a href="#h9-12-29" id="h9-12-29" class="i">+        let txn = mvcc.begin_read_only()?;
</a><a href="#h9-12-30" id="h9-12-30" class="i">+        assert_eq!(txn.version(), 1);
</a><a href="#h9-12-31" id="h9-12-31" class="i">+        assert!(txn.read_only());
</a>         txn.commit()?;
         Ok(())
     }
 
     #[test]
<a href="#h9-12-37" id="h9-12-37" class="d">-    fn test_begin_with_mode_readwrite() -&gt; Result&lt;()&gt; {
</a><a href="#h9-12-38" id="h9-12-38" class="i">+    fn test_begin_as_of() -&gt; Result&lt;()&gt; {
</a>         let mvcc = setup();
<a href="#h9-12-40" id="h9-12-40" class="d">-        let txn = mvcc.begin_with_mode(Mode::ReadWrite)?;
</a><a href="#h9-12-41" id="h9-12-41" class="d">-        assert_eq!(1, txn.id());
</a><a href="#h9-12-42" id="h9-12-42" class="d">-        assert_eq!(Mode::ReadWrite, txn.mode());
</a><a href="#h9-12-43" id="h9-12-43" class="d">-        txn.commit()?;
</a><a href="#h9-12-44" id="h9-12-44" class="d">-        Ok(())
</a><a href="#h9-12-45" id="h9-12-45" class="d">-    }
</a> 
<a href="#h9-12-47" id="h9-12-47" class="d">-    #[test]
</a><a href="#h9-12-48" id="h9-12-48" class="d">-    fn test_begin_with_mode_snapshot() -&gt; Result&lt;()&gt; {
</a><a href="#h9-12-49" id="h9-12-49" class="d">-        let mvcc = setup();
</a><a href="#h9-12-50" id="h9-12-50" class="i">+        // Start a concurrent transaction that should be invisible.
</a><a href="#h9-12-51" id="h9-12-51" class="i">+        let mut t1 = mvcc.begin()?;
</a><a href="#h9-12-52" id="h9-12-52" class="i">+        t1.set(b&quot;other&quot;, vec![1])?;
</a> 
<a href="#h9-12-54" id="h9-12-54" class="d">-        // Write a couple of versions for a key
</a><a href="#h9-12-55" id="h9-12-55" class="d">-        let mut txn = mvcc.begin_with_mode(Mode::ReadWrite)?;
</a><a href="#h9-12-56" id="h9-12-56" class="d">-        txn.set(b&quot;key&quot;, vec![0x01])?;
</a><a href="#h9-12-57" id="h9-12-57" class="d">-        txn.commit()?;
</a><a href="#h9-12-58" id="h9-12-58" class="d">-        let mut txn = mvcc.begin_with_mode(Mode::ReadWrite)?;
</a><a href="#h9-12-59" id="h9-12-59" class="d">-        txn.set(b&quot;key&quot;, vec![0x02])?;
</a><a href="#h9-12-60" id="h9-12-60" class="d">-        txn.commit()?;
</a><a href="#h9-12-61" id="h9-12-61" class="i">+        // Write a couple of versions for a key. Commit the concurrent one in between.
</a><a href="#h9-12-62" id="h9-12-62" class="i">+        let mut t2 = mvcc.begin()?;
</a><a href="#h9-12-63" id="h9-12-63" class="i">+        t2.set(b&quot;key&quot;, vec![2])?;
</a><a href="#h9-12-64" id="h9-12-64" class="i">+        t2.commit()?;
</a> 
<a href="#h9-12-66" id="h9-12-66" class="d">-        // Check that we can start a snapshot in version 1
</a><a href="#h9-12-67" id="h9-12-67" class="d">-        let txn = mvcc.begin_with_mode(Mode::Snapshot { version: 1 })?;
</a><a href="#h9-12-68" id="h9-12-68" class="d">-        assert_eq!(3, txn.id());
</a><a href="#h9-12-69" id="h9-12-69" class="d">-        assert_eq!(Mode::Snapshot { version: 1 }, txn.mode());
</a><a href="#h9-12-70" id="h9-12-70" class="d">-        assert_eq!(Some(vec![0x01]), txn.get(b&quot;key&quot;)?);
</a><a href="#h9-12-71" id="h9-12-71" class="d">-        txn.commit()?;
</a><a href="#h9-12-72" id="h9-12-72" class="i">+        let mut t3 = mvcc.begin()?;
</a><a href="#h9-12-73" id="h9-12-73" class="i">+        t3.set(b&quot;key&quot;, vec![3])?;
</a><a href="#h9-12-74" id="h9-12-74" class="i">+        t3.commit()?;
</a><a href="#h9-12-75" id="h9-12-75" class="i">+
</a><a href="#h9-12-76" id="h9-12-76" class="i">+        t1.commit()?;
</a> 
<a href="#h9-12-78" id="h9-12-78" class="d">-        // Check that we can start a snapshot in a past snapshot transaction
</a><a href="#h9-12-79" id="h9-12-79" class="d">-        let txn = mvcc.begin_with_mode(Mode::Snapshot { version: 3 })?;
</a><a href="#h9-12-80" id="h9-12-80" class="d">-        assert_eq!(4, txn.id());
</a><a href="#h9-12-81" id="h9-12-81" class="d">-        assert_eq!(Mode::Snapshot { version: 3 }, txn.mode());
</a><a href="#h9-12-82" id="h9-12-82" class="d">-        assert_eq!(Some(vec![0x02]), txn.get(b&quot;key&quot;)?);
</a><a href="#h9-12-83" id="h9-12-83" class="i">+        let mut t4 = mvcc.begin()?;
</a><a href="#h9-12-84" id="h9-12-84" class="i">+        t4.set(b&quot;key&quot;, vec![4])?;
</a><a href="#h9-12-85" id="h9-12-85" class="i">+        t4.commit()?;
</a><a href="#h9-12-86" id="h9-12-86" class="i">+
</a><a href="#h9-12-87" id="h9-12-87" class="i">+        // Check that we can start a snapshot as of version 3. It should see
</a><a href="#h9-12-88" id="h9-12-88" class="i">+        // key=2 and other=None (because it hadn&#39;t committed yet).
</a><a href="#h9-12-89" id="h9-12-89" class="i">+        let txn = mvcc.begin_as_of(3)?;
</a><a href="#h9-12-90" id="h9-12-90" class="i">+        assert_eq!(txn.version(), 3);
</a><a href="#h9-12-91" id="h9-12-91" class="i">+        assert!(txn.read_only());
</a><a href="#h9-12-92" id="h9-12-92" class="i">+        assert_eq!(txn.get(b&quot;key&quot;)?, Some(vec![2]));
</a><a href="#h9-12-93" id="h9-12-93" class="i">+        assert_eq!(txn.get(b&quot;other&quot;)?, None);
</a>         txn.commit()?;
 
<a href="#h9-12-96" id="h9-12-96" class="d">-        // Check that the current transaction ID is valid as a snapshot version
</a><a href="#h9-12-97" id="h9-12-97" class="d">-        let txn = mvcc.begin_with_mode(Mode::Snapshot { version: 5 })?;
</a><a href="#h9-12-98" id="h9-12-98" class="d">-        assert_eq!(5, txn.id());
</a><a href="#h9-12-99" id="h9-12-99" class="d">-        assert_eq!(Mode::Snapshot { version: 5 }, txn.mode());
</a><a href="#h9-12-100" id="h9-12-100" class="i">+        // A snapshot as of version 4 should see key=3 and Other=2.
</a><a href="#h9-12-101" id="h9-12-101" class="i">+        let txn = mvcc.begin_as_of(4)?;
</a><a href="#h9-12-102" id="h9-12-102" class="i">+        assert_eq!(txn.version(), 4);
</a><a href="#h9-12-103" id="h9-12-103" class="i">+        assert!(txn.read_only());
</a><a href="#h9-12-104" id="h9-12-104" class="i">+        assert_eq!(txn.get(b&quot;key&quot;)?, Some(vec![3]));
</a><a href="#h9-12-105" id="h9-12-105" class="i">+        assert_eq!(txn.get(b&quot;other&quot;)?, Some(vec![1]));
</a>         txn.commit()?;
 
         // Check that any future transaction IDs are invalid
         assert_eq!(
<a href="#h9-12-110" id="h9-12-110" class="d">-            mvcc.begin_with_mode(Mode::Snapshot { version: 9 }).err(),
</a><a href="#h9-12-111" id="h9-12-111" class="d">-            Some(Error::Value(&quot;Snapshot not found for version 9&quot;.into()))
</a><a href="#h9-12-112" id="h9-12-112" class="i">+            mvcc.begin_as_of(9).err(),
</a><a href="#h9-12-113" id="h9-12-113" class="i">+            Some(Error::Value(&quot;Version 9 does not exist&quot;.into()))
</a>         );
 
<a href="#h9-12-116" id="h9-12-116" class="d">-        // Check that concurrent transactions are hidden from snapshots of snapshot transactions.
</a><a href="#h9-12-117" id="h9-12-117" class="d">-        // This is because any transaction, including a snapshot transaction, allocates a new
</a><a href="#h9-12-118" id="h9-12-118" class="d">-        // transaction ID, and we need to make sure concurrent transaction at the time the
</a><a href="#h9-12-119" id="h9-12-119" class="d">-        // transaction began are hidden from future snapshot transactions.
</a><a href="#h9-12-120" id="h9-12-120" class="d">-        let mut txn_active = mvcc.begin()?;
</a><a href="#h9-12-121" id="h9-12-121" class="d">-        let txn_snapshot = mvcc.begin_with_mode(Mode::Snapshot { version: 1 })?;
</a><a href="#h9-12-122" id="h9-12-122" class="d">-        assert_eq!(7, txn_active.id());
</a><a href="#h9-12-123" id="h9-12-123" class="d">-        assert_eq!(8, txn_snapshot.id());
</a><a href="#h9-12-124" id="h9-12-124" class="d">-        txn_active.set(b&quot;key&quot;, vec![0x07])?;
</a><a href="#h9-12-125" id="h9-12-125" class="d">-        assert_eq!(Some(vec![0x01]), txn_snapshot.get(b&quot;key&quot;)?);
</a><a href="#h9-12-126" id="h9-12-126" class="d">-        txn_active.commit()?;
</a><a href="#h9-12-127" id="h9-12-127" class="d">-        txn_snapshot.commit()?;
</a><a href="#h9-12-128" id="h9-12-128" class="d">-
</a><a href="#h9-12-129" id="h9-12-129" class="d">-        let txn = mvcc.begin_with_mode(Mode::Snapshot { version: 8 })?;
</a><a href="#h9-12-130" id="h9-12-130" class="d">-        assert_eq!(9, txn.id());
</a><a href="#h9-12-131" id="h9-12-131" class="d">-        assert_eq!(Some(vec![0x02]), txn.get(b&quot;key&quot;)?);
</a><a href="#h9-12-132" id="h9-12-132" class="d">-        txn.commit()?;
</a><a href="#h9-12-133" id="h9-12-133" class="d">-
</a>         Ok(())
     }
 
<a href="#h9-13" id="h9-13" class="h">@@ -644,8 +675,8 @@ pub mod tests {
</a>         let state = t3.state();
         std::mem::drop(t3);
         let tr = mvcc.resume(state.clone())?;
<a href="#h9-13-3" id="h9-13-3" class="d">-        assert_eq!(3, tr.id());
</a><a href="#h9-13-4" id="h9-13-4" class="d">-        assert_eq!(Mode::ReadWrite, tr.mode());
</a><a href="#h9-13-5" id="h9-13-5" class="i">+        assert_eq!(3, tr.version());
</a><a href="#h9-13-6" id="h9-13-6" class="i">+        assert!(!tr.read_only());
</a> 
         assert_eq!(Some(b&quot;t1&quot;.to_vec()), tr.get(b&quot;a&quot;)?);
         assert_eq!(Some(b&quot;t3&quot;.to_vec()), tr.get(b&quot;b&quot;)?);
<a href="#h9-14" id="h9-14" class="h">@@ -664,7 +695,7 @@ pub mod tests {
</a>         // Resuming an inactive transaction should error.
         assert_eq!(
             mvcc.resume(state).err(),
<a href="#h9-14-3" id="h9-14-3" class="d">-            Some(Error::Internal(&quot;No active transaction with ID 3&quot;.into()))
</a><a href="#h9-14-4" id="h9-14-4" class="i">+            Some(Error::Internal(&quot;No active transaction at version 3&quot;.into()))
</a>         );
 
         let t = mvcc.begin()?;
<a href="#h9-15" id="h9-15" class="h">@@ -674,15 +705,15 @@ pub mod tests {
</a>         t.rollback()?;
 
         // It should also be possible to start a snapshot transaction and resume it.
<a href="#h9-15-3" id="h9-15-3" class="d">-        let ts = mvcc.begin_with_mode(Mode::Snapshot { version: 1 })?;
</a><a href="#h9-15-4" id="h9-15-4" class="d">-        assert_eq!(7, ts.id());
</a><a href="#h9-15-5" id="h9-15-5" class="i">+        let ts = mvcc.begin_as_of(2)?;
</a><a href="#h9-15-6" id="h9-15-6" class="i">+        assert_eq!(2, ts.version());
</a>         assert_eq!(Some(b&quot;t1&quot;.to_vec()), ts.get(b&quot;a&quot;)?);
 
         let state = ts.state();
         std::mem::drop(ts);
         let ts = mvcc.resume(state)?;
<a href="#h9-15-12" id="h9-15-12" class="d">-        assert_eq!(7, ts.id());
</a><a href="#h9-15-13" id="h9-15-13" class="d">-        assert_eq!(Mode::Snapshot { version: 1 }, ts.mode());
</a><a href="#h9-15-14" id="h9-15-14" class="i">+        assert_eq!(2, ts.version());
</a><a href="#h9-15-15" id="h9-15-15" class="i">+        assert!(ts.read_only());
</a>         assert_eq!(Some(b&quot;t1&quot;.to_vec()), ts.get(b&quot;a&quot;)?);
         ts.commit()?;
 
<a href="#h9-16" id="h9-16" class="h">@@ -804,7 +835,7 @@ pub mod tests {
</a>         txn.set(b&quot;c&quot;, vec![0x03])?;
         txn.commit()?;
 
<a href="#h9-16-3" id="h9-16-3" class="d">-        let tr = mvcc.begin_with_mode(Mode::Snapshot { version: 2 })?;
</a><a href="#h9-16-4" id="h9-16-4" class="i">+        let tr = mvcc.begin_as_of(3)?;
</a>         assert_eq!(Some(vec![0x01]), tr.get(b&quot;a&quot;)?);
         assert_eq!(Some(vec![0x02]), tr.get(b&quot;b&quot;)?);
         assert_eq!(None, tr.get(b&quot;c&quot;)?);
<a href="#h9-17" id="h9-17" class="h">@@ -1184,7 +1215,7 @@ pub mod tests {
</a>         assert_eq!(m.get_unversioned(b&quot;foo&quot;)?, Some(b&quot;baz&quot;.to_vec()));
 
         // The versioned key should remain unaffected.
<a href="#h9-17-3" id="h9-17-3" class="d">-        let txn = m.begin_with_mode(Mode::ReadOnly)?;
</a><a href="#h9-17-4" id="h9-17-4" class="i">+        let txn = m.begin_read_only()?;
</a>         assert_eq!(txn.get(b&quot;foo&quot;)?, Some(b&quot;bar&quot;.to_vec()));
 
         Ok(())
<b>diff --git a/<a id="h10" href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a> b/<a href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -4,7 +4,7 @@ use super::{assert_row, assert_rows, setup};
</a> 
 use toydb::error::{Error, Result};
 use toydb::raft;
<a href="#h10-0-3" id="h10-0-3" class="d">-use toydb::sql::engine::{Mode, Status};
</a><a href="#h10-0-4" id="h10-0-4" class="i">+use toydb::sql::engine::Status;
</a> use toydb::sql::execution::ResultSet;
 use toydb::sql::schema;
 use toydb::sql::types::{Column, DataType, Value};
<a href="#h10-1" id="h10-1" class="h">@@ -129,7 +129,7 @@ async fn status() -&gt; Result&lt;()&gt; {
</a>                 commit_index: 26,
                 apply_index: 26,
                 storage: &quot;hybrid&quot;.into(),
<a href="#h10-1-3" id="h10-1-3" class="d">-                storage_size: 3739,
</a><a href="#h10-1-4" id="h10-1-4" class="i">+                storage_size: 3462,
</a>             },
             mvcc: mvcc::Status { txns: 1, txns_active: 0, storage: &quot;memory&quot;.into() },
         }
<a href="#h10-2" id="h10-2" class="h">@@ -228,10 +228,11 @@ async fn execute_txn() -&gt; Result&lt;()&gt; {
</a>     assert_eq!(c.txn(), None);
 
     // Committing a change in a txn should work
<a href="#h10-2-3" id="h10-2-3" class="d">-    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { id: 2, mode: Mode::ReadWrite });
</a><a href="#h10-2-4" id="h10-2-4" class="d">-    assert_eq!(c.txn(), Some((2, Mode::ReadWrite)));
</a><a href="#h10-2-5" id="h10-2-5" class="i">+    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 2, read_only: false });
</a><a href="#h10-2-6" id="h10-2-6" class="i">+    assert_eq!(c.txn(), Some((2, false)));
</a>     c.execute(&quot;INSERT INTO genres VALUES (4, &#39;Drama&#39;)&quot;).await?;
<a href="#h10-2-8" id="h10-2-8" class="d">-    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { id: 2 });
</a><a href="#h10-2-9" id="h10-2-9" class="i">+    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { version: 2 });
</a><a href="#h10-2-10" id="h10-2-10" class="i">+    assert_eq!(c.txn(), None);
</a>     assert_row(
         c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;).await?,
         vec![Value::Integer(4), Value::String(&quot;Drama&quot;.into())],
<a href="#h10-3" id="h10-3" class="h">@@ -239,23 +240,23 @@ async fn execute_txn() -&gt; Result&lt;()&gt; {
</a>     assert_eq!(c.txn(), None);
 
     // Rolling back a change in a txn should also work
<a href="#h10-3-3" id="h10-3-3" class="d">-    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { id: 4, mode: Mode::ReadWrite });
</a><a href="#h10-3-4" id="h10-3-4" class="d">-    assert_eq!(c.txn(), Some((4, Mode::ReadWrite)));
</a><a href="#h10-3-5" id="h10-3-5" class="i">+    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 3, read_only: false });
</a><a href="#h10-3-6" id="h10-3-6" class="i">+    assert_eq!(c.txn(), Some((3, false)));
</a>     c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;).await?;
     assert_row(
         c.execute(&quot;SELECT * FROM genres WHERE id = 5&quot;).await?,
         vec![Value::Integer(5), Value::String(&quot;Musical&quot;.into())],
     );
<a href="#h10-3-12" id="h10-3-12" class="d">-    assert_eq!(c.execute(&quot;ROLLBACK&quot;).await?, ResultSet::Rollback { id: 4 });
</a><a href="#h10-3-13" id="h10-3-13" class="i">+    assert_eq!(c.execute(&quot;ROLLBACK&quot;).await?, ResultSet::Rollback { version: 3 });
</a>     assert_rows(c.execute(&quot;SELECT * FROM genres WHERE id = 5&quot;).await?, Vec::new());
     assert_eq!(c.txn(), None);
 
     // Starting a read-only txn should block writes
     assert_eq!(
         c.execute(&quot;BEGIN READ ONLY&quot;).await?,
<a href="#h10-3-20" id="h10-3-20" class="d">-        ResultSet::Begin { id: 6, mode: Mode::ReadOnly }
</a><a href="#h10-3-21" id="h10-3-21" class="i">+        ResultSet::Begin { version: 4, read_only: true }
</a>     );
<a href="#h10-3-23" id="h10-3-23" class="d">-    assert_eq!(c.txn(), Some((6, Mode::ReadOnly)));
</a><a href="#h10-3-24" id="h10-3-24" class="i">+    assert_eq!(c.txn(), Some((4, true)));
</a>     assert_row(
         c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;).await?,
         vec![Value::Integer(4), Value::String(&quot;Drama&quot;.into())],
<a href="#h10-4" id="h10-4" class="h">@@ -265,15 +266,15 @@ async fn execute_txn() -&gt; Result&lt;()&gt; {
</a>         c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;).await?,
         vec![Value::Integer(4), Value::String(&quot;Drama&quot;.into())],
     );
<a href="#h10-4-3" id="h10-4-3" class="d">-    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { id: 6 });
</a><a href="#h10-4-4" id="h10-4-4" class="i">+    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { version: 4 });
</a> 
     // Starting a time-travel txn should work, it shouldn&#39;t see recent changes, and it should
     // block writes
     assert_eq!(
<a href="#h10-4-9" id="h10-4-9" class="d">-        c.execute(&quot;BEGIN READ ONLY AS OF SYSTEM TIME 1&quot;).await?,
</a><a href="#h10-4-10" id="h10-4-10" class="d">-        ResultSet::Begin { id: 7, mode: Mode::Snapshot { version: 1 } }
</a><a href="#h10-4-11" id="h10-4-11" class="i">+        c.execute(&quot;BEGIN READ ONLY AS OF SYSTEM TIME 2&quot;).await?,
</a><a href="#h10-4-12" id="h10-4-12" class="i">+        ResultSet::Begin { version: 2, read_only: true },
</a>     );
<a href="#h10-4-14" id="h10-4-14" class="d">-    assert_eq!(c.txn(), Some((7, Mode::Snapshot { version: 1 })));
</a><a href="#h10-4-15" id="h10-4-15" class="i">+    assert_eq!(c.txn(), Some((2, true)));
</a>     assert_rows(
         c.execute(&quot;SELECT * FROM genres&quot;).await?,
         vec![
<a href="#h10-5" id="h10-5" class="h">@@ -283,18 +284,18 @@ async fn execute_txn() -&gt; Result&lt;()&gt; {
</a>         ],
     );
     assert_eq!(c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;).await, Err(Error::ReadOnly));
<a href="#h10-5-3" id="h10-5-3" class="d">-    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { id: 7 });
</a><a href="#h10-5-4" id="h10-5-4" class="i">+    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { version: 2 });
</a> 
     // A txn should still be usable after an error occurs
<a href="#h10-5-7" id="h10-5-7" class="d">-    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { id: 8, mode: Mode::ReadWrite });
</a><a href="#h10-5-8" id="h10-5-8" class="i">+    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 4, read_only: false });
</a>     c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Horror&#39;)&quot;).await?;
     assert_eq!(
         c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;).await,
         Err(Error::Value(&quot;Primary key 5 already exists for table genres&quot;.into()))
     );
<a href="#h10-5-14" id="h10-5-14" class="d">-    assert_eq!(c.txn(), Some((8, Mode::ReadWrite)));
</a><a href="#h10-5-15" id="h10-5-15" class="i">+    assert_eq!(c.txn(), Some((4, false)));
</a>     c.execute(&quot;INSERT INTO genres VALUES (6, &#39;Western&#39;)&quot;).await?;
<a href="#h10-5-17" id="h10-5-17" class="d">-    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { id: 8 });
</a><a href="#h10-5-18" id="h10-5-18" class="i">+    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { version: 4 });
</a>     assert_rows(
         c.execute(&quot;SELECT * FROM genres&quot;).await?,
         vec![
<a href="#h10-6" id="h10-6" class="h">@@ -317,8 +318,8 @@ async fn execute_txn_concurrent() -&gt; Result&lt;()&gt; {
</a>     let b = Client::new(&quot;127.0.0.1:9605&quot;).await?;
 
     // Concurrent updates should throw a serialization failure on conflict.
<a href="#h10-6-3" id="h10-6-3" class="d">-    assert_eq!(a.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { id: 2, mode: Mode::ReadWrite });
</a><a href="#h10-6-4" id="h10-6-4" class="d">-    assert_eq!(b.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { id: 3, mode: Mode::ReadWrite });
</a><a href="#h10-6-5" id="h10-6-5" class="i">+    assert_eq!(a.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 2, read_only: false });
</a><a href="#h10-6-6" id="h10-6-6" class="i">+    assert_eq!(b.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 3, read_only: false });
</a> 
     assert_row(
         a.execute(&quot;SELECT * FROM genres WHERE id = 1&quot;).await?,
<a href="#h10-7" id="h10-7" class="h">@@ -338,8 +339,8 @@ async fn execute_txn_concurrent() -&gt; Result&lt;()&gt; {
</a>         Err(Error::Serialization)
     );
 
<a href="#h10-7-3" id="h10-7-3" class="d">-    assert_eq!(a.execute(&quot;COMMIT&quot;).await, Ok(ResultSet::Commit { id: 2 }));
</a><a href="#h10-7-4" id="h10-7-4" class="d">-    assert_eq!(b.execute(&quot;ROLLBACK&quot;).await, Ok(ResultSet::Rollback { id: 3 }));
</a><a href="#h10-7-5" id="h10-7-5" class="i">+    assert_eq!(a.execute(&quot;COMMIT&quot;).await, Ok(ResultSet::Commit { version: 2 }));
</a><a href="#h10-7-6" id="h10-7-6" class="i">+    assert_eq!(b.execute(&quot;ROLLBACK&quot;).await, Ok(ResultSet::Rollback { version: 3 }));
</a> 
     assert_row(
         a.execute(&quot;SELECT * FROM genres WHERE id = 1&quot;).await?,
<b>diff --git a/<a id="h11" href="../file/tests/sql/mutation.rs.html">tests/sql/mutation.rs</a> b/<a href="../file/tests/sql/mutation.rs.html">tests/sql/mutation.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -1,6 +1,6 @@
</a> //! Mutation tests, using an in-memory database against golden files in tests/sql/mutation/
 use toydb::error::Result;
<a href="#h11-0-2" id="h11-0-2" class="d">-use toydb::sql::engine::{Engine as _, Mode, Transaction as _};
</a><a href="#h11-0-3" id="h11-0-3" class="i">+use toydb::sql::engine::{Engine as _, Transaction as _};
</a> use toydb::sql::schema::Catalog as _;
 
 use goldenfile::Mint;
<a href="#h11-1" id="h11-1" class="h">@@ -30,7 +30,7 @@ macro_rules! test_mutation {
</a>                 };
 
                 write!(f, &quot;Storage:&quot;)?;
<a href="#h11-1-3" id="h11-1-3" class="d">-                let txn = engine.begin(Mode::ReadWrite)?;
</a><a href="#h11-1-4" id="h11-1-4" class="i">+                let txn = engine.begin()?;
</a>                 for table in txn.scan_tables()? {
                     write!(f, &quot;\n{}\n&quot;, table)?;
                     for row in txn.scan(&amp;table.name, None)? {
<b>diff --git a/<a id="h12" href="../file/tests/sql/query.rs.html">tests/sql/query.rs</a> b/<a href="../file/tests/sql/query.rs.html">tests/sql/query.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -1,7 +1,7 @@
</a> //! Tests for the SQL query engine. Runs SQL queries against an in-memory database,
 //! and compares the results with golden files stored under tests/sql/query/
 use toydb::error::{Error, Result};
<a href="#h12-0-3" id="h12-0-3" class="d">-use toydb::sql::engine::{Engine, Mode, Transaction};
</a><a href="#h12-0-4" id="h12-0-4" class="i">+use toydb::sql::engine::{Engine, Transaction};
</a> use toydb::sql::execution::ResultSet;
 use toydb::sql::parser::Parser;
 use toydb::sql::plan::Plan;
<a href="#h12-1" id="h12-1" class="h">@@ -76,7 +76,7 @@ macro_rules! test_query {
</a> 
             write!(f, &quot;Query: {}\n\n&quot;, $query)?;
 
<a href="#h12-1-3" id="h12-1-3" class="d">-            let mut txn = engine.begin(Mode::ReadWrite)?;
</a><a href="#h12-1-4" id="h12-1-4" class="i">+            let mut txn = engine.begin()?;
</a> 
             // First, just try to generate a plan and execute it
             let result = Parser::new($query).parse()
<b>diff --git a/<a id="h13" href="../file/tests/sql/schema.rs.html">tests/sql/schema.rs</a> b/<a href="../file/tests/sql/schema.rs.html">tests/sql/schema.rs</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -1,6 +1,6 @@
</a> //! Schema-related tests, using an in-memory database against golden files in tests/sql/chema/
 use toydb::error::Result;
<a href="#h13-0-2" id="h13-0-2" class="d">-use toydb::sql::engine::{Engine as _, Mode, Transaction as _};
</a><a href="#h13-0-3" id="h13-0-3" class="i">+use toydb::sql::engine::{Engine as _, Transaction as _};
</a> use toydb::sql::schema::Catalog as _;
 
 use goldenfile::Mint;
<a href="#h13-1" id="h13-1" class="h">@@ -28,7 +28,7 @@ macro_rules! test_schema {
</a>                 };
 
                 write!(f, &quot;Storage:&quot;)?;
<a href="#h13-1-3" id="h13-1-3" class="d">-                let txn = engine.begin(Mode::ReadWrite)?;
</a><a href="#h13-1-4" id="h13-1-4" class="i">+                let txn = engine.begin()?;
</a>                 for table in txn.scan_tables()? {
                     write!(f, &quot;\n{}\n&quot;, table)?;
                     for row in txn.scan(&amp;table.name, None)? {
</pre>
</div>
</body>
</html>
