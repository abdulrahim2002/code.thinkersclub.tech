<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>storage: dedupe `decode_binary` and `parse_key_range` test helpers - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/54badf5b9f23868c5d6cf1380521f711a40e0860.html">54badf5b9f23868c5d6cf1380521f711a40e0860</a>
<b>parent</b> <a href="../commit/235e1f9fbdfa4a9c069450e3be2659d78191f87a.html">235e1f9fbdfa4a9c069450e3be2659d78191f87a</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Wed, 17 Jul 2024 18:41:47 +0200

storage: dedupe `decode_binary` and `parse_key_range` test helpers

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/storage/engine.rs</a></td><td> | </td><td class="num">98</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/storage/mvcc.rs</a></td><td> | </td><td class="num">71</td><td><span class="i">++++++++++++++</span><span class="d">---------------------------------------------------------</span></td></tr>
</table></pre><pre>2 files changed, 62 insertions(+), 107 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/storage/engine.rs.html">src/storage/engine.rs</a> b/<a href="../file/src/storage/engine.rs.html">src/storage/engine.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -92,6 +92,12 @@ pub mod test {
</a>         pub engine: E,
     }
 
<a href="#h0-0-3" id="h0-0-3" class="i">+    impl&lt;E: Engine&gt; Runner&lt;E&gt; {
</a><a href="#h0-0-4" id="h0-0-4" class="i">+        pub fn new(engine: E) -&gt; Self {
</a><a href="#h0-0-5" id="h0-0-5" class="i">+            Self { engine }
</a><a href="#h0-0-6" id="h0-0-6" class="i">+        }
</a><a href="#h0-0-7" id="h0-0-7" class="i">+    }
</a><a href="#h0-0-8" id="h0-0-8" class="i">+
</a>     impl&lt;E: Engine&gt; goldenscript::Runner for Runner&lt;E&gt; {
         fn run(&amp;mut self, command: &amp;goldenscript::Command) -&gt; StdResult&lt;String, Box&lt;dyn StdError&gt;&gt; {
             let mut output = String::new();
<a href="#h0-1" id="h0-1" class="h">@@ -99,7 +105,7 @@ pub mod test {
</a>                 // delete KEY
                 &quot;delete&quot; =&gt; {
                     let mut args = command.consume_args();
<a href="#h0-1-3" id="h0-1-3" class="d">-                    let key = Self::decode_binary(&amp;args.next_pos().ok_or(&quot;key not given&quot;)?.value);
</a><a href="#h0-1-4" id="h0-1-4" class="i">+                    let key = decode_binary(&amp;args.next_pos().ok_or(&quot;key not given&quot;)?.value);
</a>                     args.reject_rest()?;
                     self.engine.delete(&amp;key)?;
                 }
<a href="#h0-2" id="h0-2" class="h">@@ -107,7 +113,7 @@ pub mod test {
</a>                 // get KEY
                 &quot;get&quot; =&gt; {
                     let mut args = command.consume_args();
<a href="#h0-2-3" id="h0-2-3" class="d">-                    let key = Self::decode_binary(&amp;args.next_pos().ok_or(&quot;key not given&quot;)?.value);
</a><a href="#h0-2-4" id="h0-2-4" class="i">+                    let key = decode_binary(&amp;args.next_pos().ok_or(&quot;key not given&quot;)?.value);
</a>                     args.reject_rest()?;
                     let value = self.engine.get(&amp;key)?;
                     writeln!(output, &quot;{}&quot;, format::Raw::key_maybe_value(&amp;key, value.as_deref()))?;
<a href="#h0-3" id="h0-3" class="h">@@ -117,9 +123,8 @@ pub mod test {
</a>                 &quot;scan&quot; =&gt; {
                     let mut args = command.consume_args();
                     let reverse = args.lookup_parse(&quot;reverse&quot;)?.unwrap_or(false);
<a href="#h0-3-3" id="h0-3-3" class="d">-                    let range = Self::parse_key_range(
</a><a href="#h0-3-4" id="h0-3-4" class="d">-                        args.next_pos().map(|a| a.value.as_str()).unwrap_or(&quot;..&quot;),
</a><a href="#h0-3-5" id="h0-3-5" class="d">-                    )?;
</a><a href="#h0-3-6" id="h0-3-6" class="i">+                    let range =
</a><a href="#h0-3-7" id="h0-3-7" class="i">+                        parse_key_range(args.next_pos().map(|a| a.value.as_str()).unwrap_or(&quot;..&quot;))?;
</a>                     args.reject_rest()?;
                     let items: Vec&lt;_&gt; = if reverse {
                         self.engine.scan(range).rev().collect::&lt;Result&lt;_&gt;&gt;()?
<a href="#h0-4" id="h0-4" class="h">@@ -134,8 +139,7 @@ pub mod test {
</a>                 // scan_prefix PREFIX
                 &quot;scan_prefix&quot; =&gt; {
                     let mut args = command.consume_args();
<a href="#h0-4-3" id="h0-4-3" class="d">-                    let prefix =
</a><a href="#h0-4-4" id="h0-4-4" class="d">-                        Self::decode_binary(&amp;args.next_pos().ok_or(&quot;prefix not given&quot;)?.value);
</a><a href="#h0-4-5" id="h0-4-5" class="i">+                    let prefix = decode_binary(&amp;args.next_pos().ok_or(&quot;prefix not given&quot;)?.value);
</a>                     args.reject_rest()?;
                     let mut scan = self.engine.scan_prefix(&amp;prefix);
                     while let Some((key, value)) = scan.next().transpose()? {
<a href="#h0-5" id="h0-5" class="h">@@ -147,8 +151,8 @@ pub mod test {
</a>                 &quot;set&quot; =&gt; {
                     let mut args = command.consume_args();
                     let kv = args.next_key().ok_or(&quot;key=value not given&quot;)?.clone();
<a href="#h0-5-3" id="h0-5-3" class="d">-                    let key = Self::decode_binary(&amp;kv.key.unwrap());
</a><a href="#h0-5-4" id="h0-5-4" class="d">-                    let value = Self::decode_binary(&amp;kv.value);
</a><a href="#h0-5-5" id="h0-5-5" class="i">+                    let key = decode_binary(&amp;kv.key.unwrap());
</a><a href="#h0-5-6" id="h0-5-6" class="i">+                    let value = decode_binary(&amp;kv.value);
</a>                     args.reject_rest()?;
                     self.engine.set(&amp;key, value)?;
                 }
<a href="#h0-6" id="h0-6" class="h">@@ -165,52 +169,46 @@ pub mod test {
</a>         }
     }
 
<a href="#h0-6-3" id="h0-6-3" class="d">-    impl&lt;E: Engine&gt; Runner&lt;E&gt; {
</a><a href="#h0-6-4" id="h0-6-4" class="d">-        pub fn new(engine: E) -&gt; Self {
</a><a href="#h0-6-5" id="h0-6-5" class="d">-            Self { engine }
</a><a href="#h0-6-6" id="h0-6-6" class="d">-        }
</a><a href="#h0-6-7" id="h0-6-7" class="d">-
</a><a href="#h0-6-8" id="h0-6-8" class="d">-        /// Decodes a raw byte vector from a Unicode string. Code points in the
</a><a href="#h0-6-9" id="h0-6-9" class="d">-        /// range U+0080 to U+00FF are converted back to bytes 0x80 to 0xff.
</a><a href="#h0-6-10" id="h0-6-10" class="d">-        /// This allows using e.g. \xff in the input string literal, and getting
</a><a href="#h0-6-11" id="h0-6-11" class="d">-        /// back a 0xff byte in the byte vector. Otherwise, char(0xff) yields
</a><a href="#h0-6-12" id="h0-6-12" class="d">-        /// the UTF-8 bytes 0xc3bf, which is the U+00FF code point as UTF-8.
</a><a href="#h0-6-13" id="h0-6-13" class="d">-        /// These characters are effectively represented as ISO-8859-1 rather
</a><a href="#h0-6-14" id="h0-6-14" class="d">-        /// than UTF-8, but it allows precise use of the entire u8 value range.
</a><a href="#h0-6-15" id="h0-6-15" class="d">-        pub fn decode_binary(s: &amp;str) -&gt; Vec&lt;u8&gt; {
</a><a href="#h0-6-16" id="h0-6-16" class="d">-            let mut buf = [0; 4];
</a><a href="#h0-6-17" id="h0-6-17" class="d">-            let mut bytes = Vec::new();
</a><a href="#h0-6-18" id="h0-6-18" class="d">-            for c in s.chars() {
</a><a href="#h0-6-19" id="h0-6-19" class="d">-                // u32 is the Unicode code point, not the UTF-8 encoding.
</a><a href="#h0-6-20" id="h0-6-20" class="d">-                match c as u32 {
</a><a href="#h0-6-21" id="h0-6-21" class="d">-                    b @ 0x80..=0xff =&gt; bytes.push(b as u8),
</a><a href="#h0-6-22" id="h0-6-22" class="d">-                    _ =&gt; bytes.extend(c.encode_utf8(&amp;mut buf).as_bytes()),
</a><a href="#h0-6-23" id="h0-6-23" class="d">-                }
</a><a href="#h0-6-24" id="h0-6-24" class="i">+    /// Decodes a raw byte vector from a Unicode string. Code points in the
</a><a href="#h0-6-25" id="h0-6-25" class="i">+    /// range U+0080 to U+00FF are converted back to bytes 0x80 to 0xff.
</a><a href="#h0-6-26" id="h0-6-26" class="i">+    /// This allows using e.g. \xff in the input string literal, and getting
</a><a href="#h0-6-27" id="h0-6-27" class="i">+    /// back a 0xff byte in the byte vector. Otherwise, char(0xff) yields
</a><a href="#h0-6-28" id="h0-6-28" class="i">+    /// the UTF-8 bytes 0xc3bf, which is the U+00FF code point as UTF-8.
</a><a href="#h0-6-29" id="h0-6-29" class="i">+    /// These characters are effectively represented as ISO-8859-1 rather
</a><a href="#h0-6-30" id="h0-6-30" class="i">+    /// than UTF-8, but it allows precise use of the entire u8 value range.
</a><a href="#h0-6-31" id="h0-6-31" class="i">+    pub fn decode_binary(s: &amp;str) -&gt; Vec&lt;u8&gt; {
</a><a href="#h0-6-32" id="h0-6-32" class="i">+        let mut buf = [0; 4];
</a><a href="#h0-6-33" id="h0-6-33" class="i">+        let mut bytes = Vec::new();
</a><a href="#h0-6-34" id="h0-6-34" class="i">+        for c in s.chars() {
</a><a href="#h0-6-35" id="h0-6-35" class="i">+            // u32 is the Unicode code point, not the UTF-8 encoding.
</a><a href="#h0-6-36" id="h0-6-36" class="i">+            match c as u32 {
</a><a href="#h0-6-37" id="h0-6-37" class="i">+                b @ 0x80..=0xff =&gt; bytes.push(b as u8),
</a><a href="#h0-6-38" id="h0-6-38" class="i">+                _ =&gt; bytes.extend(c.encode_utf8(&amp;mut buf).as_bytes()),
</a>             }
<a href="#h0-6-40" id="h0-6-40" class="d">-            bytes
</a>         }
<a href="#h0-6-42" id="h0-6-42" class="i">+        bytes
</a><a href="#h0-6-43" id="h0-6-43" class="i">+    }
</a> 
<a href="#h0-6-45" id="h0-6-45" class="d">-        /// Parses an binary key range, using Rust range syntax.
</a><a href="#h0-6-46" id="h0-6-46" class="d">-        fn parse_key_range(
</a><a href="#h0-6-47" id="h0-6-47" class="d">-            s: &amp;str,
</a><a href="#h0-6-48" id="h0-6-48" class="d">-        ) -&gt; StdResult&lt;impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;, Box&lt;dyn StdError&gt;&gt; {
</a><a href="#h0-6-49" id="h0-6-49" class="d">-            use std::ops::Bound;
</a><a href="#h0-6-50" id="h0-6-50" class="d">-            let mut bound = (Bound::&lt;Vec&lt;u8&gt;&gt;::Unbounded, Bound::&lt;Vec&lt;u8&gt;&gt;::Unbounded);
</a><a href="#h0-6-51" id="h0-6-51" class="d">-            let re = Regex::new(r&quot;^(\S+)?\.\.(=)?(\S+)?&quot;).expect(&quot;invalid regex&quot;);
</a><a href="#h0-6-52" id="h0-6-52" class="d">-            let groups = re.captures(s).ok_or_else(|| format!(&quot;invalid range {s}&quot;))?;
</a><a href="#h0-6-53" id="h0-6-53" class="d">-            if let Some(start) = groups.get(1) {
</a><a href="#h0-6-54" id="h0-6-54" class="d">-                bound.0 = Bound::Included(Self::decode_binary(start.as_str()));
</a><a href="#h0-6-55" id="h0-6-55" class="d">-            }
</a><a href="#h0-6-56" id="h0-6-56" class="d">-            if let Some(end) = groups.get(3) {
</a><a href="#h0-6-57" id="h0-6-57" class="d">-                let end = Self::decode_binary(end.as_str());
</a><a href="#h0-6-58" id="h0-6-58" class="d">-                if groups.get(2).is_some() {
</a><a href="#h0-6-59" id="h0-6-59" class="d">-                    bound.1 = Bound::Included(end)
</a><a href="#h0-6-60" id="h0-6-60" class="d">-                } else {
</a><a href="#h0-6-61" id="h0-6-61" class="d">-                    bound.1 = Bound::Excluded(end)
</a><a href="#h0-6-62" id="h0-6-62" class="d">-                }
</a><a href="#h0-6-63" id="h0-6-63" class="i">+    /// Parses an binary key range, using Rust range syntax.
</a><a href="#h0-6-64" id="h0-6-64" class="i">+    pub fn parse_key_range(
</a><a href="#h0-6-65" id="h0-6-65" class="i">+        s: &amp;str,
</a><a href="#h0-6-66" id="h0-6-66" class="i">+    ) -&gt; StdResult&lt;impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;, Box&lt;dyn StdError&gt;&gt; {
</a><a href="#h0-6-67" id="h0-6-67" class="i">+        use std::ops::Bound;
</a><a href="#h0-6-68" id="h0-6-68" class="i">+        let mut bound = (Bound::&lt;Vec&lt;u8&gt;&gt;::Unbounded, Bound::&lt;Vec&lt;u8&gt;&gt;::Unbounded);
</a><a href="#h0-6-69" id="h0-6-69" class="i">+        let re = Regex::new(r&quot;^(\S+)?\.\.(=)?(\S+)?&quot;).expect(&quot;invalid regex&quot;);
</a><a href="#h0-6-70" id="h0-6-70" class="i">+        let groups = re.captures(s).ok_or_else(|| format!(&quot;invalid range {s}&quot;))?;
</a><a href="#h0-6-71" id="h0-6-71" class="i">+        if let Some(start) = groups.get(1) {
</a><a href="#h0-6-72" id="h0-6-72" class="i">+            bound.0 = Bound::Included(decode_binary(start.as_str()));
</a><a href="#h0-6-73" id="h0-6-73" class="i">+        }
</a><a href="#h0-6-74" id="h0-6-74" class="i">+        if let Some(end) = groups.get(3) {
</a><a href="#h0-6-75" id="h0-6-75" class="i">+            let end = decode_binary(end.as_str());
</a><a href="#h0-6-76" id="h0-6-76" class="i">+            if groups.get(2).is_some() {
</a><a href="#h0-6-77" id="h0-6-77" class="i">+                bound.1 = Bound::Included(end)
</a><a href="#h0-6-78" id="h0-6-78" class="i">+            } else {
</a><a href="#h0-6-79" id="h0-6-79" class="i">+                bound.1 = Bound::Excluded(end)
</a>             }
<a href="#h0-6-81" id="h0-6-81" class="d">-            Ok(bound)
</a>         }
<a href="#h0-6-83" id="h0-6-83" class="i">+        Ok(bound)
</a>     }
 
     /// Wraps another engine and emits write events to the given channel.
<b>diff --git a/<a id="h1" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -754,11 +754,11 @@ impl&lt;&#39;a, E: Engine&gt; Iterator for VersionIterator&lt;&#39;a, E&gt; {
</a> pub mod tests {
     use super::*;
     use crate::encoding::format::{self, Formatter as _};
<a href="#h1-0-3" id="h1-0-3" class="d">-    use crate::storage::engine::test::{Emit, Mirror, Operation};
</a><a href="#h1-0-4" id="h1-0-4" class="i">+    use crate::storage::engine::test::{decode_binary, parse_key_range, Emit, Mirror, Operation};
</a>     use crate::storage::{BitCask, Memory};
<a href="#h1-0-6" id="h1-0-6" class="i">+
</a>     use crossbeam::channel::Receiver;
     use itertools::Itertools as _;
<a href="#h1-0-9" id="h1-0-9" class="d">-    use regex::Regex;
</a>     use std::collections::HashMap;
     use std::fmt::Write as _;
     use std::{error::Error, result::Result};
<a href="#h1-1" id="h1-1" class="h">@@ -836,7 +836,7 @@ pub mod tests {
</a>                     let txn = self.get_txn(&amp;command.prefix)?;
                     let mut args = command.consume_args();
                     for arg in args.rest_pos() {
<a href="#h1-1-3" id="h1-1-3" class="d">-                        let key = Self::decode_binary(&amp;arg.value);
</a><a href="#h1-1-4" id="h1-1-4" class="i">+                        let key = decode_binary(&amp;arg.value);
</a>                         txn.delete(&amp;key)?;
                     }
                     args.reject_rest()?;
<a href="#h1-2" id="h1-2" class="h">@@ -859,7 +859,7 @@ pub mod tests {
</a>                     let txn = self.get_txn(&amp;command.prefix)?;
                     let mut args = command.consume_args();
                     for arg in args.rest_pos() {
<a href="#h1-2-3" id="h1-2-3" class="d">-                        let key = Self::decode_binary(&amp;arg.value);
</a><a href="#h1-2-4" id="h1-2-4" class="i">+                        let key = decode_binary(&amp;arg.value);
</a>                         let value = txn.get(&amp;key)?;
                         let fmtkv = format::Raw::key_maybe_value(&amp;key, value.as_deref());
                         writeln!(output, &quot;{fmtkv}&quot;)?;
<a href="#h1-3" id="h1-3" class="h">@@ -872,7 +872,7 @@ pub mod tests {
</a>                     Self::no_txn(command)?;
                     let mut args = command.consume_args();
                     for arg in args.rest_pos() {
<a href="#h1-3-3" id="h1-3-3" class="d">-                        let key = Self::decode_binary(&amp;arg.value);
</a><a href="#h1-3-4" id="h1-3-4" class="i">+                        let key = decode_binary(&amp;arg.value);
</a>                         let value = self.mvcc.get_unversioned(&amp;key)?;
                         let fmtkv = format::Raw::key_maybe_value(&amp;key, value.as_deref());
                         writeln!(output, &quot;{fmtkv}&quot;)?;
<a href="#h1-4" id="h1-4" class="h">@@ -895,8 +895,8 @@ pub mod tests {
</a>                         }
                     }
                     for kv in args.rest_key() {
<a href="#h1-4-3" id="h1-4-3" class="d">-                        let key = Self::decode_binary(kv.key.as_ref().unwrap());
</a><a href="#h1-4-4" id="h1-4-4" class="d">-                        let value = Self::decode_binary(&amp;kv.value);
</a><a href="#h1-4-5" id="h1-4-5" class="i">+                        let key = decode_binary(kv.key.as_ref().unwrap());
</a><a href="#h1-4-6" id="h1-4-6" class="i">+                        let value = decode_binary(&amp;kv.value);
</a>                         if value.is_empty() {
                             txn.delete(&amp;key)?;
                         } else {
<a href="#h1-5" id="h1-5" class="h">@@ -930,9 +930,8 @@ pub mod tests {
</a>                 &quot;scan&quot; =&gt; {
                     let txn = self.get_txn(&amp;command.prefix)?;
                     let mut args = command.consume_args();
<a href="#h1-5-3" id="h1-5-3" class="d">-                    let range = Self::parse_key_range(
</a><a href="#h1-5-4" id="h1-5-4" class="d">-                        args.next_pos().map(|a| a.value.as_str()).unwrap_or(&quot;..&quot;),
</a><a href="#h1-5-5" id="h1-5-5" class="d">-                    )?;
</a><a href="#h1-5-6" id="h1-5-6" class="i">+                    let range =
</a><a href="#h1-5-7" id="h1-5-7" class="i">+                        parse_key_range(args.next_pos().map(|a| a.value.as_str()).unwrap_or(&quot;..&quot;))?;
</a>                     args.reject_rest()?;
 
                     let kvs: Vec&lt;_&gt; = txn.scan(range).collect::&lt;crate::error::Result&lt;_&gt;&gt;()?;
<a href="#h1-6" id="h1-6" class="h">@@ -945,8 +944,7 @@ pub mod tests {
</a>                 &quot;scan_prefix&quot; =&gt; {
                     let txn = self.get_txn(&amp;command.prefix)?;
                     let mut args = command.consume_args();
<a href="#h1-6-3" id="h1-6-3" class="d">-                    let prefix =
</a><a href="#h1-6-4" id="h1-6-4" class="d">-                        Self::decode_binary(&amp;args.next_pos().ok_or(&quot;prefix not given&quot;)?.value);
</a><a href="#h1-6-5" id="h1-6-5" class="i">+                    let prefix = decode_binary(&amp;args.next_pos().ok_or(&quot;prefix not given&quot;)?.value);
</a>                     args.reject_rest()?;
 
                     let kvs: Vec&lt;_&gt; =
<a href="#h1-7" id="h1-7" class="h">@@ -961,8 +959,8 @@ pub mod tests {
</a>                     let txn = self.get_txn(&amp;command.prefix)?;
                     let mut args = command.consume_args();
                     for kv in args.rest_key() {
<a href="#h1-7-3" id="h1-7-3" class="d">-                        let key = Self::decode_binary(kv.key.as_ref().unwrap());
</a><a href="#h1-7-4" id="h1-7-4" class="d">-                        let value = Self::decode_binary(&amp;kv.value);
</a><a href="#h1-7-5" id="h1-7-5" class="i">+                        let key = decode_binary(kv.key.as_ref().unwrap());
</a><a href="#h1-7-6" id="h1-7-6" class="i">+                        let value = decode_binary(&amp;kv.value);
</a>                         txn.set(&amp;key, value)?;
                     }
                     args.reject_rest()?;
<a href="#h1-8" id="h1-8" class="h">@@ -973,8 +971,8 @@ pub mod tests {
</a>                     Self::no_txn(command)?;
                     let mut args = command.consume_args();
                     for kv in args.rest_key() {
<a href="#h1-8-3" id="h1-8-3" class="d">-                        let key = Self::decode_binary(kv.key.as_ref().unwrap());
</a><a href="#h1-8-4" id="h1-8-4" class="d">-                        let value = Self::decode_binary(&amp;kv.value);
</a><a href="#h1-8-5" id="h1-8-5" class="i">+                        let key = decode_binary(kv.key.as_ref().unwrap());
</a><a href="#h1-8-6" id="h1-8-6" class="i">+                        let value = decode_binary(&amp;kv.value);
</a>                         self.mvcc.set_unversioned(&amp;key, value)?;
                     }
                     args.reject_rest()?;
<a href="#h1-9" id="h1-9" class="h">@@ -1054,47 +1052,6 @@ pub mod tests {
</a>             Self { mvcc, op_rx, txns: HashMap::new(), tempdir }
         }
 
<a href="#h1-9-3" id="h1-9-3" class="d">-        /// Decodes a raw byte vector from a Unicode string. Code points in the
</a><a href="#h1-9-4" id="h1-9-4" class="d">-        /// range U+0080 to U+00FF are converted back to bytes 0x80 to 0xff.
</a><a href="#h1-9-5" id="h1-9-5" class="d">-        /// This allows using e.g. \xff in the input string literal, and getting
</a><a href="#h1-9-6" id="h1-9-6" class="d">-        /// back a 0xff byte in the byte vector. Otherwise, char(0xff) yields
</a><a href="#h1-9-7" id="h1-9-7" class="d">-        /// the UTF-8 bytes 0xc3bf, which is the U+00FF code point as UTF-8.
</a><a href="#h1-9-8" id="h1-9-8" class="d">-        /// These characters are effectively represented as ISO-8859-1 rather
</a><a href="#h1-9-9" id="h1-9-9" class="d">-        /// than UTF-8, but it allows precise use of the entire u8 value range.
</a><a href="#h1-9-10" id="h1-9-10" class="d">-        ///
</a><a href="#h1-9-11" id="h1-9-11" class="d">-        /// TODO: share this and the below with engine::test::Runner.
</a><a href="#h1-9-12" id="h1-9-12" class="d">-        pub fn decode_binary(s: &amp;str) -&gt; Vec&lt;u8&gt; {
</a><a href="#h1-9-13" id="h1-9-13" class="d">-            let mut buf = [0; 4];
</a><a href="#h1-9-14" id="h1-9-14" class="d">-            let mut bytes = Vec::new();
</a><a href="#h1-9-15" id="h1-9-15" class="d">-            for c in s.chars() {
</a><a href="#h1-9-16" id="h1-9-16" class="d">-                // u32 is the Unicode code point, not the UTF-8 encoding.
</a><a href="#h1-9-17" id="h1-9-17" class="d">-                match c as u32 {
</a><a href="#h1-9-18" id="h1-9-18" class="d">-                    b @ 0x80..=0xff =&gt; bytes.push(b as u8),
</a><a href="#h1-9-19" id="h1-9-19" class="d">-                    _ =&gt; bytes.extend(c.encode_utf8(&amp;mut buf).as_bytes()),
</a><a href="#h1-9-20" id="h1-9-20" class="d">-                }
</a><a href="#h1-9-21" id="h1-9-21" class="d">-            }
</a><a href="#h1-9-22" id="h1-9-22" class="d">-            bytes
</a><a href="#h1-9-23" id="h1-9-23" class="d">-        }
</a><a href="#h1-9-24" id="h1-9-24" class="d">-
</a><a href="#h1-9-25" id="h1-9-25" class="d">-        /// Parses an binary key range, using Rust range syntax.
</a><a href="#h1-9-26" id="h1-9-26" class="d">-        fn parse_key_range(s: &amp;str) -&gt; Result&lt;impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;, Box&lt;dyn Error&gt;&gt; {
</a><a href="#h1-9-27" id="h1-9-27" class="d">-            let mut bound = (Bound::&lt;Vec&lt;u8&gt;&gt;::Unbounded, Bound::&lt;Vec&lt;u8&gt;&gt;::Unbounded);
</a><a href="#h1-9-28" id="h1-9-28" class="d">-            let re = Regex::new(r&quot;^(\S+)?\.\.(=)?(\S+)?&quot;).expect(&quot;invalid regex&quot;);
</a><a href="#h1-9-29" id="h1-9-29" class="d">-            let groups = re.captures(s).ok_or_else(|| format!(&quot;invalid range {s}&quot;))?;
</a><a href="#h1-9-30" id="h1-9-30" class="d">-            if let Some(start) = groups.get(1) {
</a><a href="#h1-9-31" id="h1-9-31" class="d">-                bound.0 = Bound::Included(Self::decode_binary(start.as_str()));
</a><a href="#h1-9-32" id="h1-9-32" class="d">-            }
</a><a href="#h1-9-33" id="h1-9-33" class="d">-            if let Some(end) = groups.get(3) {
</a><a href="#h1-9-34" id="h1-9-34" class="d">-                let end = Self::decode_binary(end.as_str());
</a><a href="#h1-9-35" id="h1-9-35" class="d">-                if groups.get(2).is_some() {
</a><a href="#h1-9-36" id="h1-9-36" class="d">-                    bound.1 = Bound::Included(end)
</a><a href="#h1-9-37" id="h1-9-37" class="d">-                } else {
</a><a href="#h1-9-38" id="h1-9-38" class="d">-                    bound.1 = Bound::Excluded(end)
</a><a href="#h1-9-39" id="h1-9-39" class="d">-                }
</a><a href="#h1-9-40" id="h1-9-40" class="d">-            }
</a><a href="#h1-9-41" id="h1-9-41" class="d">-            Ok(bound)
</a><a href="#h1-9-42" id="h1-9-42" class="d">-        }
</a><a href="#h1-9-43" id="h1-9-43" class="d">-
</a>         /// Fetches the named transaction from a command prefix.
         fn get_txn(
             &amp;mut self,
</pre>
</div>
</body>
</html>
