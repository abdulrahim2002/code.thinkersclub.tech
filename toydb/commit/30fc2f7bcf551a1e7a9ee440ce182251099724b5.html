<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: clean up planner module - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/30fc2f7bcf551a1e7a9ee440ce182251099724b5.html">30fc2f7bcf551a1e7a9ee440ce182251099724b5</a>
<b>parent</b> <a href="../commit/329b92c76c8d3da5fbb382f10ad5c854abd8631e.html">329b92c76c8d3da5fbb382f10ad5c854abd8631e</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 21 Jul 2024 11:39:26 +0200

sql: clean up planner module

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/execution/execute.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/parser/parser.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/planner/mod.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">+++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/planner/optimizer.rs</a></td><td> | </td><td class="num">107</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/planner/plan.rs</a></td><td> | </td><td class="num">534</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++</span><span class="d">--------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">141</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------</span></td></tr>
</table></pre><pre>7 files changed, 415 insertions(+), 395 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a> b/<a href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -42,7 +42,7 @@ pub fn execute_plan(
</a>         }
 
         Plan::Select(root) =&gt; {
<a href="#h0-0-3" id="h0-0-3" class="d">-            let labels = (0..root.size()).map(|i| root.column_label(i)).collect();
</a><a href="#h0-0-4" id="h0-0-4" class="i">+            let labels = (0..root.columns()).map(|i| root.column_label(i)).collect();
</a>             let iter = execute(root, txn)?;
             ExecutionResult::Select { rows: iter, labels }
         }
<a href="#h0-1" id="h0-1" class="h">@@ -69,7 +69,7 @@ pub fn execute(node: Node, txn: &amp;impl Transaction) -&gt; Result&lt;Rows&gt; {
</a>         }
 
         Node::HashJoin { left, left_column, right, right_column, outer } =&gt; {
<a href="#h0-1-3" id="h0-1-3" class="d">-            let right_size = right.size();
</a><a href="#h0-1-4" id="h0-1-4" class="i">+            let right_size = right.columns();
</a>             let left = execute(*left, txn)?;
             let right = execute(*right, txn)?;
             join::hash(left, left_column, right, right_column, right_size, outer)?
<a href="#h0-2" id="h0-2" class="h">@@ -89,7 +89,7 @@ pub fn execute(node: Node, txn: &amp;impl Transaction) -&gt; Result&lt;Rows&gt; {
</a>         }
 
         Node::NestedLoopJoin { left, right, predicate, outer } =&gt; {
<a href="#h0-2-3" id="h0-2-3" class="d">-            let right_size = right.size();
</a><a href="#h0-2-4" id="h0-2-4" class="i">+            let right_size = right.columns();
</a>             let left = execute(*left, txn)?;
             let right = execute(*right, txn)?;
             join::nested_loop(left, right, right_size, predicate, outer)?
<a href="#h0-3" id="h0-3" class="h">@@ -102,7 +102,7 @@ pub fn execute(node: Node, txn: &amp;impl Transaction) -&gt; Result&lt;Rows&gt; {
</a>             transform::offset(source, offset)
         }
 
<a href="#h0-3-3" id="h0-3-3" class="d">-        Node::Order { source, orders } =&gt; {
</a><a href="#h0-3-4" id="h0-3-4" class="i">+        Node::Order { source, key: orders } =&gt; {
</a>             let source = execute(*source, txn)?;
             transform::order(source, orders)?
         }
<b>diff --git a/<a id="h1" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -41,7 +41,7 @@ pub enum Statement {
</a>         r#where: Option&lt;Expression&gt;,
         group_by: Vec&lt;Expression&gt;,
         having: Option&lt;Expression&gt;,
<a href="#h1-0-3" id="h1-0-3" class="d">-        order_by: Vec&lt;(Expression, Order)&gt;,
</a><a href="#h1-0-4" id="h1-0-4" class="i">+        order_by: Vec&lt;(Expression, Direction)&gt;,
</a>         offset: Option&lt;Expression&gt;,
         limit: Option&lt;Expression&gt;,
     },
<a href="#h1-1" id="h1-1" class="h">@@ -91,7 +91,7 @@ impl JoinType {
</a> 
 /// ORDER BY direction.
 #[derive(Debug)]
<a href="#h1-1-3" id="h1-1-3" class="d">-pub enum Order {
</a><a href="#h1-1-4" id="h1-1-4" class="i">+pub enum Direction {
</a>     Ascending,
     Descending,
 }
<b>diff --git a/<a id="h2" href="../file/src/sql/parser/parser.rs.html">src/sql/parser/parser.rs</a> b/<a href="../file/src/sql/parser/parser.rs.html">src/sql/parser/parser.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -453,7 +453,7 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     }
 
     /// Parses an ORDER BY clause, if present.
<a href="#h2-0-3" id="h2-0-3" class="d">-    fn parse_order_by_clause(&amp;mut self) -&gt; Result&lt;Vec&lt;(ast::Expression, ast::Order)&gt;&gt; {
</a><a href="#h2-0-4" id="h2-0-4" class="i">+    fn parse_order_by_clause(&amp;mut self) -&gt; Result&lt;Vec&lt;(ast::Expression, ast::Direction)&gt;&gt; {
</a>         if !self.next_is(Keyword::Order.into()) {
             return Ok(Vec::new());
         }
<a href="#h2-1" id="h2-1" class="h">@@ -463,11 +463,11 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>             let expr = self.parse_expression()?;
             let order = self
                 .next_if_map(|token| match token {
<a href="#h2-1-3" id="h2-1-3" class="d">-                    Token::Keyword(Keyword::Asc) =&gt; Some(ast::Order::Ascending),
</a><a href="#h2-1-4" id="h2-1-4" class="d">-                    Token::Keyword(Keyword::Desc) =&gt; Some(ast::Order::Descending),
</a><a href="#h2-1-5" id="h2-1-5" class="i">+                    Token::Keyword(Keyword::Asc) =&gt; Some(ast::Direction::Ascending),
</a><a href="#h2-1-6" id="h2-1-6" class="i">+                    Token::Keyword(Keyword::Desc) =&gt; Some(ast::Direction::Descending),
</a>                     _ =&gt; None,
                 })
<a href="#h2-1-9" id="h2-1-9" class="d">-                .unwrap_or(ast::Order::Ascending);
</a><a href="#h2-1-10" id="h2-1-10" class="i">+                .unwrap_or(ast::Direction::Ascending);
</a>             order_by.push((expr, order));
             if !self.next_is(Token::Comma) {
                 break;
<b>diff --git a/<a id="h3" href="../file/src/sql/planner/mod.rs.html">src/sql/planner/mod.rs</a> b/<a href="../file/src/sql/planner/mod.rs.html">src/sql/planner/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,10 +1,12 @@
</a><a href="#h3-0-0" id="h3-0-0" class="i">+//! The planner builds and optimizes an execution plan based on a SQL
</a><a href="#h3-0-1" id="h3-0-1" class="i">+//! statement&#39;s Abstract Syntax Tree (AST) generated by the parser.
</a><a href="#h3-0-2" id="h3-0-2" class="i">+
</a> mod optimizer;
 mod plan;
 mod planner;
 
 pub use plan::{Aggregate, Direction, Node, Plan};
<a href="#h3-0-8" id="h3-0-8" class="i">+pub use planner::{Planner, Scope};
</a> 
 #[cfg(test)]
<a href="#h3-0-11" id="h3-0-11" class="d">-pub(crate) use optimizer::OPTIMIZERS;
</a><a href="#h3-0-12" id="h3-0-12" class="d">-#[cfg(test)]
</a><a href="#h3-0-13" id="h3-0-13" class="d">-pub(crate) use planner::{Planner, Scope};
</a><a href="#h3-0-14" id="h3-0-14" class="i">+pub use optimizer::OPTIMIZERS;
</a><b>diff --git a/<a id="h4" href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a> b/<a href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -4,7 +4,8 @@ use crate::sql::types::{Expression, Label, Value};
</a> 
 use std::collections::HashMap;
 
<a href="#h4-0-3" id="h4-0-3" class="d">-/// A plan optimizer, which takes a root node and recursively transforms it.
</a><a href="#h4-0-4" id="h4-0-4" class="i">+/// A plan optimizer, which recursively transforms a plan node to make plan
</a><a href="#h4-0-5" id="h4-0-5" class="i">+/// execution more efficient where possible.
</a> pub type Optimizer = fn(Node) -&gt; Result&lt;Node&gt;;
 
 /// The set of optimizers, and the order in which they are applied.
<a href="#h4-1" id="h4-1" class="h">@@ -18,12 +19,14 @@ pub static OPTIMIZERS: &amp;[(&amp;str, Optimizer)] = &amp;[
</a> 
 /// Folds constant (sub)expressions by pre-evaluating them, instead of
 /// re-evaluating then for every row during execution.
<a href="#h4-1-3" id="h4-1-3" class="d">-pub(super) fn fold_constants(node: Node) -&gt; Result&lt;Node&gt; {
</a><a href="#h4-1-4" id="h4-1-4" class="i">+pub fn fold_constants(node: Node) -&gt; Result&lt;Node&gt; {
</a>     use Expression::*;
     use Value::*;
 
<a href="#h4-1-8" id="h4-1-8" class="d">-    // Transforms expressions.
</a><a href="#h4-1-9" id="h4-1-9" class="d">-    let transform = |mut expr: Expression| {
</a><a href="#h4-1-10" id="h4-1-10" class="i">+    // Transform expressions. Called after descending, to perform logical
</a><a href="#h4-1-11" id="h4-1-11" class="i">+    // short-circuiting on child expressions that have already been folded, and
</a><a href="#h4-1-12" id="h4-1-12" class="i">+    // to reduce the quadratic cost when an expression contains a column.
</a><a href="#h4-1-13" id="h4-1-13" class="i">+    let xform = |mut expr: Expression| {
</a>         // If the expression is constant, evaluate it.
         //
         // This is a very simple approach, which doesn&#39;t handle more complex
<a href="#h4-2" id="h4-2" class="h">@@ -31,8 +34,8 @@ pub(super) fn fold_constants(node: Node) -&gt; Result&lt;Node&gt; {
</a>         // expression as 1 - 2 + a to evaluate the 1 - 2 branch).
         //
         // TODO: consider doing something better.
<a href="#h4-2-3" id="h4-2-3" class="d">-        if !expr.contains(&amp;|e| matches!(e, Expression::Column(_))) {
</a><a href="#h4-2-4" id="h4-2-4" class="d">-            return expr.evaluate(None).map(Expression::Constant);
</a><a href="#h4-2-5" id="h4-2-5" class="i">+        if !expr.contains(&amp;|expr| matches!(expr, Column(_))) {
</a><a href="#h4-2-6" id="h4-2-6" class="i">+            return expr.evaluate(None).map(Constant);
</a>         }
 
         // If the expression is a logical operator, and one of the sides is
<a href="#h4-3" id="h4-3" class="h">@@ -61,15 +64,13 @@ pub(super) fn fold_constants(node: Node) -&gt; Result&lt;Node&gt; {
</a>         Ok(expr)
     };
 
<a href="#h4-3-3" id="h4-3-3" class="d">-    // Transform expressions after descending, both to perform the logical
</a><a href="#h4-3-4" id="h4-3-4" class="d">-    // short-circuiting on child expressions that have already been folded, and
</a><a href="#h4-3-5" id="h4-3-5" class="d">-    // to reduce the quadratic cost when an expression contains a column.
</a><a href="#h4-3-6" id="h4-3-6" class="d">-    node.transform(&amp;|n| n.transform_expressions(&amp;Ok, &amp;transform), &amp;Ok)
</a><a href="#h4-3-7" id="h4-3-7" class="i">+    node.transform(&amp;|node| node.transform_expressions(&amp;Ok, &amp;xform), &amp;Ok)
</a> }
 
 /// Pushes filter predicates down into child nodes where possible. In
<a href="#h4-3-11" id="h4-3-11" class="d">-/// particular, this can allow filtering during storage scans (below Raft).
</a><a href="#h4-3-12" id="h4-3-12" class="d">-pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a><a href="#h4-3-13" id="h4-3-13" class="i">+/// particular, this can allow filtering during storage scans (below Raft),
</a><a href="#h4-3-14" id="h4-3-14" class="i">+/// instead of reading and transmitting all rows then filtering.
</a><a href="#h4-3-15" id="h4-3-15" class="i">+pub fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>     /// Pushes an expression into a node if possible. Otherwise, returns the the
     /// unpushed expression.
     fn push_into(expr: Expression, target: &amp;mut Node) -&gt; Option&lt;Expression&gt; {
<a href="#h4-4" id="h4-4" class="h">@@ -112,7 +113,7 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         // replace this filter node with the source node, Node.transform() will
         // skip the source node since it now takes the place of the original
         // filter node. Transform the source manually.
<a href="#h4-4-3" id="h4-4-3" class="d">-        transform(*source)
</a><a href="#h4-4-4" id="h4-4-4" class="i">+        xform(*source)
</a>     }
 
     // Pushes down parts of a join predicate into the left or right sources
<a href="#h4-5" id="h4-5" class="h">@@ -130,10 +131,10 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         let (mut push_left, mut push_right, mut predicate) = (Vec::new(), Vec::new(), Vec::new());
         for expr in cnf {
             let (mut ref_left, mut ref_right) = (false, false);
<a href="#h4-5-3" id="h4-5-3" class="d">-            expr.walk(&amp;mut |e| {
</a><a href="#h4-5-4" id="h4-5-4" class="d">-                if let Expression::Column(index) = e {
</a><a href="#h4-5-5" id="h4-5-5" class="d">-                    ref_left = ref_left || *index &lt; left.size();
</a><a href="#h4-5-6" id="h4-5-6" class="d">-                    ref_right = ref_right || *index &gt;= left.size();
</a><a href="#h4-5-7" id="h4-5-7" class="i">+            expr.walk(&amp;mut |expr| {
</a><a href="#h4-5-8" id="h4-5-8" class="i">+                if let Expression::Column(index) = expr {
</a><a href="#h4-5-9" id="h4-5-9" class="i">+                    ref_left = ref_left || *index &lt; left.columns();
</a><a href="#h4-5-10" id="h4-5-10" class="i">+                    ref_right = ref_right || *index &gt;= left.columns();
</a>                 }
                 !(ref_left &amp;&amp; ref_right) // exit once both are referenced
             });
<a href="#h4-6" id="h4-6" class="h">@@ -153,6 +154,7 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         // the constant lookups to the other side, to allow index lookups. This
         // commonly happens when joining a foreign key (which is indexed) on a
         // primary key, and we want to make use of the foreign key index, e.g.:
<a href="#h4-6-3" id="h4-6-3" class="i">+        //
</a>         // SELECT m.name, g.name FROM movies m JOIN genres g ON m.genre_id = g.id AND g.id = 7;
         let left_lookups: HashMap&lt;usize, usize&gt; = push_left // column → push_left index
             .iter()
<a href="#h4-7" id="h4-7" class="h">@@ -168,18 +170,20 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>         for expr in &amp;predicate {
             // Find equijoins.
             let Expression::Equal(lhs, rhs) = expr else { continue };
<a href="#h4-7-3" id="h4-7-3" class="d">-            let Expression::Column(l) = lhs.as_ref() else { continue };
</a><a href="#h4-7-4" id="h4-7-4" class="d">-            let Expression::Column(r) = rhs.as_ref() else { continue };
</a><a href="#h4-7-5" id="h4-7-5" class="i">+            let Expression::Column(mut l) = **lhs else { continue };
</a><a href="#h4-7-6" id="h4-7-6" class="i">+            let Expression::Column(mut r) = **rhs else { continue };
</a> 
             // The lhs may be a reference to the right source; swap them.
<a href="#h4-7-9" id="h4-7-9" class="d">-            let (l, r) = if l &gt; r { (r, l) } else { (l, r) };
</a><a href="#h4-7-10" id="h4-7-10" class="i">+            if l &gt; r {
</a><a href="#h4-7-11" id="h4-7-11" class="i">+                (l, r) = (r, l)
</a><a href="#h4-7-12" id="h4-7-12" class="i">+            }
</a> 
             // Check if either side is a column lookup, and copy it over.
<a href="#h4-7-15" id="h4-7-15" class="d">-            if let Some(expr) = left_lookups.get(l).map(|i| push_left[*i].clone()) {
</a><a href="#h4-7-16" id="h4-7-16" class="d">-                push_right.push(expr.replace_column(*l, *r));
</a><a href="#h4-7-17" id="h4-7-17" class="i">+            if let Some(expr) = left_lookups.get(&amp;l).map(|i| push_left[*i].clone()) {
</a><a href="#h4-7-18" id="h4-7-18" class="i">+                push_right.push(expr.replace_column(l, r));
</a>             }
<a href="#h4-7-20" id="h4-7-20" class="d">-            if let Some(expr) = right_lookups.get(r).map(|i| push_right[*i].clone()) {
</a><a href="#h4-7-21" id="h4-7-21" class="d">-                push_left.push(expr.replace_column(*r, *l));
</a><a href="#h4-7-22" id="h4-7-22" class="i">+            if let Some(expr) = right_lookups.get(&amp;r).map(|i| push_right[*i].clone()) {
</a><a href="#h4-7-23" id="h4-7-23" class="i">+                push_left.push(expr.replace_column(r, l));
</a>             }
         }
 
<a href="#h4-8" id="h4-8" class="h">@@ -193,10 +197,10 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a> 
         if let Some(mut expr) = Expression::and_vec(push_right) {
             // Right columns have indexes in the joined row; shift them left.
<a href="#h4-8-3" id="h4-8-3" class="d">-            expr = expr.shift_column(-(left.size() as isize));
</a><a href="#h4-8-4" id="h4-8-4" class="i">+            expr = expr.shift_column(-(left.columns() as isize));
</a>             if let Some(mut expr) = push_into(expr, &amp;mut right) {
                 // Pushdown failed, undo the column index shift.
<a href="#h4-8-7" id="h4-8-7" class="d">-                expr = expr.shift_column(left.size() as isize);
</a><a href="#h4-8-8" id="h4-8-8" class="i">+                expr = expr.shift_column(left.columns() as isize);
</a>                 predicate.push(expr)
             }
         }
<a href="#h4-9" id="h4-9" class="h">@@ -207,18 +211,16 @@ pub(super) fn push_filters(node: Node) -&gt; Result&lt;Node&gt; {
</a>     }
 
     /// Applies pushdown transformations to a node.
<a href="#h4-9-3" id="h4-9-3" class="d">-    fn transform(mut node: Node) -&gt; Node {
</a><a href="#h4-9-4" id="h4-9-4" class="d">-        node = push_filter(node);
</a><a href="#h4-9-5" id="h4-9-5" class="d">-        node = push_join(node);
</a><a href="#h4-9-6" id="h4-9-6" class="d">-        node
</a><a href="#h4-9-7" id="h4-9-7" class="i">+    fn xform(node: Node) -&gt; Node {
</a><a href="#h4-9-8" id="h4-9-8" class="i">+        push_join(push_filter(node))
</a>     }
 
     // Push down before descending, so we can keep recursively pushing down.
<a href="#h4-9-12" id="h4-9-12" class="d">-    node.transform(&amp;|n| Ok(transform(n)), &amp;Ok)
</a><a href="#h4-9-13" id="h4-9-13" class="i">+    node.transform(&amp;|node| Ok(xform(node)), &amp;Ok)
</a> }
 
 /// Uses an index or primary key lookup for a filter when possible.
<a href="#h4-9-17" id="h4-9-17" class="d">-pub(super) fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a><a href="#h4-9-18" id="h4-9-18" class="i">+pub fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a>     let transform = |mut node| {
         // Only handle scan filters. filter_pushdown() must have pushed filters
         // into scan nodes first.
<a href="#h4-10" id="h4-10" class="h">@@ -229,10 +231,10 @@ pub(super) fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a> 
         // Find the first expression that&#39;s either a primary key or secondary
         // index lookup. We could be more clever here, but this is fine.
<a href="#h4-10-3" id="h4-10-3" class="d">-        let Some((i, column)) = cnf.iter().enumerate().find_map(|(i, e)| {
</a><a href="#h4-10-4" id="h4-10-4" class="d">-            e.is_column_lookup()
</a><a href="#h4-10-5" id="h4-10-5" class="i">+        let Some((i, column)) = cnf.iter().enumerate().find_map(|(i, expr)| {
</a><a href="#h4-10-6" id="h4-10-6" class="i">+            expr.is_column_lookup()
</a>                 .filter(|c| *c == table.primary_key || table.columns[*c].index)
<a href="#h4-10-8" id="h4-10-8" class="d">-                .map(|c| (i, c))
</a><a href="#h4-10-9" id="h4-10-9" class="i">+                .map(|column| (i, column))
</a>         }) else {
             return Node::Scan { table, alias, filter: Some(filter) };
         };
<a href="#h4-11" id="h4-11" class="h">@@ -247,7 +249,7 @@ pub(super) fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a>             node = Node::IndexLookup { table, column, values, alias };
         }
 
<a href="#h4-11-3" id="h4-11-3" class="d">-        // If there&#39;s any remaining CNF expressions add a filter node for them.
</a><a href="#h4-11-4" id="h4-11-4" class="i">+        // If there&#39;s any remaining CNF expressions, add a filter node for them.
</a>         if let Some(predicate) = Expression::and_vec(cnf) {
             node = Node::Filter { source: Box::new(node), predicate };
         }
<a href="#h4-12" id="h4-12" class="h">@@ -258,9 +260,8 @@ pub(super) fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a> }
 
 /// Uses a hash join instead of a nested loop join for single-column equijoins.
<a href="#h4-12-3" id="h4-12-3" class="d">-pub(super) fn join_type(node: Node) -&gt; Result&lt;Node&gt; {
</a><a href="#h4-12-4" id="h4-12-4" class="d">-    let transform = |node| match node {
</a><a href="#h4-12-5" id="h4-12-5" class="d">-        // We could use a single match if we had deref patterns, but alas.
</a><a href="#h4-12-6" id="h4-12-6" class="i">+pub fn join_type(node: Node) -&gt; Result&lt;Node&gt; {
</a><a href="#h4-12-7" id="h4-12-7" class="i">+    let xform = |node| match node {
</a>         Node::NestedLoopJoin {
             left,
             right,
<a href="#h4-13" id="h4-13" class="h">@@ -273,9 +274,9 @@ pub(super) fn join_type(node: Node) -&gt; Result&lt;Node&gt; {
</a>                     (left_column, right_column) = (right_column, left_column);
                 }
                 // The NestedLoopJoin predicate uses column indexes in the
<a href="#h4-13-3" id="h4-13-3" class="d">-                // joined row, while the HashJoin uses column indexes for each
</a><a href="#h4-13-4" id="h4-13-4" class="d">-                // table individually. Adjust the RHS column reference.
</a><a href="#h4-13-5" id="h4-13-5" class="d">-                right_column -= left.size();
</a><a href="#h4-13-6" id="h4-13-6" class="i">+                // joined row, while the HashJoin uses column indexes in each
</a><a href="#h4-13-7" id="h4-13-7" class="i">+                // individual table. Adjust the RHS column reference.
</a><a href="#h4-13-8" id="h4-13-8" class="i">+                right_column -= left.columns();
</a>                 Node::HashJoin { left, left_column, right, right_column, outer }
             }
             (lhs, rhs) =&gt; {
<a href="#h4-14" id="h4-14" class="h">@@ -285,22 +286,22 @@ pub(super) fn join_type(node: Node) -&gt; Result&lt;Node&gt; {
</a>         },
         node =&gt; node,
     };
<a href="#h4-14-3" id="h4-14-3" class="d">-    node.transform(&amp;|n| Ok(transform(n)), &amp;Ok)
</a><a href="#h4-14-4" id="h4-14-4" class="i">+    node.transform(&amp;|node| Ok(xform(node)), &amp;Ok)
</a> }
 
 /// Short-circuits useless nodes and expressions, by removing them and/or
 /// replacing them with Nothing nodes that yield no rows.
<a href="#h4-14-9" id="h4-14-9" class="d">-pub(super) fn short_circuit(node: Node) -&gt; Result&lt;Node&gt; {
</a><a href="#h4-14-10" id="h4-14-10" class="d">-    use Expression::Constant;
</a><a href="#h4-14-11" id="h4-14-11" class="d">-    use Value::{Boolean, Null};
</a><a href="#h4-14-12" id="h4-14-12" class="i">+pub fn short_circuit(node: Node) -&gt; Result&lt;Node&gt; {
</a><a href="#h4-14-13" id="h4-14-13" class="i">+    use Expression::*;
</a><a href="#h4-14-14" id="h4-14-14" class="i">+    use Value::*;
</a> 
     /// Creates a Nothing node with the columns of the original node.
     fn nothing(node: &amp;Node) -&gt; Node {
<a href="#h4-14-18" id="h4-14-18" class="d">-        let columns = (0..node.size()).map(|i| node.column_label(i)).collect();
</a><a href="#h4-14-19" id="h4-14-19" class="i">+        let columns = (0..node.columns()).map(|i| node.column_label(i)).collect();
</a>         Node::Nothing { columns }
     }
 
<a href="#h4-14-23" id="h4-14-23" class="d">-    let transform = |node| match node {
</a><a href="#h4-14-24" id="h4-14-24" class="i">+    let xform = |node| match node {
</a>         // Filter nodes that always yield true are unnecessary: remove them.
         Node::Filter { source, predicate: Constant(Boolean(true)) } =&gt; *source,
 
<a href="#h4-15" id="h4-15" class="h">@@ -324,7 +325,7 @@ pub(super) fn short_circuit(node: Node) -&gt; Result&lt;Node&gt; {
</a>         ref node @ Node::Scan { filter: Some(Constant(Boolean(false) | Null)), .. } =&gt; {
             nothing(node)
         }
<a href="#h4-15-3" id="h4-15-3" class="d">-        Node::Values { rows } if rows.is_empty() =&gt; Node::Nothing { columns: vec![] },
</a><a href="#h4-15-4" id="h4-15-4" class="i">+        ref node @ Node::Values { ref rows } if rows.is_empty() =&gt; nothing(node),
</a> 
         // Short-circuit nodes that pull from a Nothing node.
         //
<a href="#h4-16" id="h4-16" class="h">@@ -345,12 +346,12 @@ pub(super) fn short_circuit(node: Node) -&gt; Result&lt;Node&gt; {
</a> 
         // Remove noop projections that simply pass through the source columns.
         Node::Projection { source, expressions, aliases }
<a href="#h4-16-3" id="h4-16-3" class="d">-            if source.size() == expressions.len()
</a><a href="#h4-16-4" id="h4-16-4" class="d">-                &amp;&amp; aliases.iter().all(|a| a == &amp;Label::None)
</a><a href="#h4-16-5" id="h4-16-5" class="i">+            if source.columns() == expressions.len()
</a><a href="#h4-16-6" id="h4-16-6" class="i">+                &amp;&amp; aliases.iter().all(|alias| *alias == Label::None)
</a>                 &amp;&amp; expressions
                     .iter()
                     .enumerate()
<a href="#h4-16-10" id="h4-16-10" class="d">-                    .all(|(i, e)| matches!(e, Expression::Column(f) if i == *f)) =&gt;
</a><a href="#h4-16-11" id="h4-16-11" class="i">+                    .all(|(i, expr)| matches!(expr, Expression::Column(c) if i == *c)) =&gt;
</a>         {
             *source
         }
<a href="#h4-17" id="h4-17" class="h">@@ -359,5 +360,5 @@ pub(super) fn short_circuit(node: Node) -&gt; Result&lt;Node&gt; {
</a>     };
 
     // Transform after descending, to pull Nothing nodes upwards.
<a href="#h4-17-3" id="h4-17-3" class="d">-    node.transform(&amp;Ok, &amp;|n| Ok(transform(n)))
</a><a href="#h4-17-4" id="h4-17-4" class="i">+    node.transform(&amp;Ok, &amp;|node| Ok(xform(node)))
</a> }
<b>diff --git a/<a id="h5" href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a> b/<a href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -10,9 +10,27 @@ use itertools::Itertools as _;
</a> use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 
<a href="#h5-0-3" id="h5-0-3" class="d">-/// A statement execution plan. Primarily made up of a tree of query plan Nodes,
</a><a href="#h5-0-4" id="h5-0-4" class="d">-/// which process and stream rows, but the root nodes can perform data
</a><a href="#h5-0-5" id="h5-0-5" class="d">-/// modifications or schema changes.
</a><a href="#h5-0-6" id="h5-0-6" class="i">+/// A statement execution plan. The root nodes can perform data modifications or
</a><a href="#h5-0-7" id="h5-0-7" class="i">+/// schema changes, in addition to SELECT queries. Beyond the root, the plan is
</a><a href="#h5-0-8" id="h5-0-8" class="i">+/// made up of a tree of inner plan nodes that stream and process rows via
</a><a href="#h5-0-9" id="h5-0-9" class="i">+/// iterators. Below is an example of an (unoptimized) plan for the given query:
</a><a href="#h5-0-10" id="h5-0-10" class="i">+///
</a><a href="#h5-0-11" id="h5-0-11" class="i">+/// SELECT title, released, genres.name AS genre
</a><a href="#h5-0-12" id="h5-0-12" class="i">+/// FROM movies INNER JOIN genres ON movies.genre_id = genres.id
</a><a href="#h5-0-13" id="h5-0-13" class="i">+/// WHERE released &gt;= 2000 ORDER BY released
</a><a href="#h5-0-14" id="h5-0-14" class="i">+///
</a><a href="#h5-0-15" id="h5-0-15" class="i">+/// Order: movies.released desc
</a><a href="#h5-0-16" id="h5-0-16" class="i">+/// └─ Projection: movies.title, movies.released, genres.name as genre
</a><a href="#h5-0-17" id="h5-0-17" class="i">+///    └─ Filter: movies.released &gt;= 2000
</a><a href="#h5-0-18" id="h5-0-18" class="i">+///       └─ NestedLoopJoin: inner on movies.genre_id = genres.id
</a><a href="#h5-0-19" id="h5-0-19" class="i">+///          ├─ Scan: movies
</a><a href="#h5-0-20" id="h5-0-20" class="i">+///          └─ Scan: genres
</a><a href="#h5-0-21" id="h5-0-21" class="i">+///
</a><a href="#h5-0-22" id="h5-0-22" class="i">+/// Rows flow from the tree leaves to the root. The Scan nodes read and emit
</a><a href="#h5-0-23" id="h5-0-23" class="i">+/// table rows from storage. They are passed to the NestedLoopJoin node which
</a><a href="#h5-0-24" id="h5-0-24" class="i">+/// joins the rows from the two tables, then the Filter node discards old
</a><a href="#h5-0-25" id="h5-0-25" class="i">+/// movies, the Projection node picks out the requested columns, and the Order
</a><a href="#h5-0-26" id="h5-0-26" class="i">+/// node sorts them before emitting the rows to the client.
</a> #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Plan {
     /// A CREATE TABLE plan. Creates a new table with the given schema. Errors
<a href="#h5-1" id="h5-1" class="h">@@ -22,18 +40,18 @@ pub enum Plan {
</a>     /// exist, unless if_exists is true.
     DropTable { table: String, if_exists: bool },
     /// A DELETE plan. Deletes rows in table that match the rows from source.
<a href="#h5-1-3" id="h5-1-3" class="d">-    /// primary_key specifies the primary key column index in source rows.
</a><a href="#h5-1-4" id="h5-1-4" class="i">+    /// primary_key specifies the primary key column index in the source rows.
</a>     Delete { table: String, primary_key: usize, source: Node },
     /// An INSERT plan. Inserts rows from source (typically a Values node) into
     /// table. If column_map is given, it maps table → source column indexes and
<a href="#h5-1-8" id="h5-1-8" class="d">-    /// must have one entry for every column in source. Columns not emitted by
</a><a href="#h5-1-9" id="h5-1-9" class="d">-    /// source will get the column&#39;s default value if any, otherwise error.
</a><a href="#h5-1-10" id="h5-1-10" class="i">+    /// must have one entry for every column in source. Table columns not
</a><a href="#h5-1-11" id="h5-1-11" class="i">+    /// present in source will get the column&#39;s default value if set, or error.
</a>     Insert { table: Table, column_map: Option&lt;HashMap&lt;usize, usize&gt;&gt;, source: Node },
     /// An UPDATE plan. Updates rows in table that match the rows from source,
<a href="#h5-1-14" id="h5-1-14" class="d">-    /// where primary_key specifies the source row column index of primary keys
</a><a href="#h5-1-15" id="h5-1-15" class="d">-    /// to update. The given column/expression pairs specify the row updates to
</a><a href="#h5-1-16" id="h5-1-16" class="d">-    /// be made, and will be evaluated using the old row entry from source. Rows
</a><a href="#h5-1-17" id="h5-1-17" class="d">-    /// in source must be complete, existing rows from the table to update.
</a><a href="#h5-1-18" id="h5-1-18" class="i">+    /// where primary_key specifies the primary key column index in the source
</a><a href="#h5-1-19" id="h5-1-19" class="i">+    /// rows. The given column/expression pairs specify the row updates to make,
</a><a href="#h5-1-20" id="h5-1-20" class="i">+    /// evaluated using the existing source row, which must be a complete row
</a><a href="#h5-1-21" id="h5-1-21" class="i">+    /// from the update table.
</a>     Update { table: Table, primary_key: usize, source: Node, expressions: Vec&lt;(usize, Expression)&gt; },
     /// A SELECT plan. Recursively executes the query plan tree and returns the
     /// resulting rows.
<a href="#h5-2" id="h5-2" class="h">@@ -51,19 +69,18 @@ impl Plan {
</a>         execution::execute_plan(self, txn, txn)
     }
 
<a href="#h5-2-3" id="h5-2-3" class="d">-    /// Optimizes the plan, consuming it.
</a><a href="#h5-2-4" id="h5-2-4" class="i">+    /// Optimizes the plan, consuming it. See OPTIMIZERS for the list of
</a><a href="#h5-2-5" id="h5-2-5" class="i">+    /// optimizers.
</a>     pub fn optimize(self) -&gt; Result&lt;Self&gt; {
<a href="#h5-2-7" id="h5-2-7" class="d">-        let optimize = |mut node| -&gt; Result&lt;Node&gt; {
</a><a href="#h5-2-8" id="h5-2-8" class="d">-            for (_, optimizer) in OPTIMIZERS {
</a><a href="#h5-2-9" id="h5-2-9" class="d">-                node = optimizer(node)?;
</a><a href="#h5-2-10" id="h5-2-10" class="d">-            }
</a><a href="#h5-2-11" id="h5-2-11" class="d">-            Ok(node)
</a><a href="#h5-2-12" id="h5-2-12" class="d">-        };
</a><a href="#h5-2-13" id="h5-2-13" class="i">+        let optimize = |node| OPTIMIZERS.iter().try_fold(node, |node, (_, opt)| opt(node));
</a>         Ok(match self {
<a href="#h5-2-15" id="h5-2-15" class="d">-            Self::CreateTable { .. } | Self::DropTable { .. } | Self::Insert { .. } =&gt; self,
</a><a href="#h5-2-16" id="h5-2-16" class="i">+            Self::CreateTable { .. } | Self::DropTable { .. } =&gt; self,
</a>             Self::Delete { table, primary_key, source } =&gt; {
                 Self::Delete { table, primary_key, source: optimize(source)? }
             }
<a href="#h5-2-20" id="h5-2-20" class="i">+            Self::Insert { table, column_map, source } =&gt; {
</a><a href="#h5-2-21" id="h5-2-21" class="i">+                Self::Insert { table, column_map, source: optimize(source)? }
</a><a href="#h5-2-22" id="h5-2-22" class="i">+            }
</a>             Self::Update { table, primary_key, source, expressions } =&gt; {
                 Self::Update { table, primary_key, source: optimize(source)?, expressions }
             }
<a href="#h5-3" id="h5-3" class="h">@@ -72,15 +89,15 @@ impl Plan {
</a>     }
 }
 
<a href="#h5-3-3" id="h5-3-3" class="d">-/// A query plan node. These return row iterators and can be nested.
</a><a href="#h5-3-4" id="h5-3-4" class="i">+/// A query plan node. Returns a row iterator, and can be nested.
</a> #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Node {
<a href="#h5-3-7" id="h5-3-7" class="d">-    /// Computes aggregate values for the given expressions and group_by buckets
</a><a href="#h5-3-8" id="h5-3-8" class="d">-    /// across all rows in the source node. The group_by columns are emitted first,
</a><a href="#h5-3-9" id="h5-3-9" class="d">-    /// followed by the aggregate columns, in the given order.
</a><a href="#h5-3-10" id="h5-3-10" class="i">+    /// Computes the given aggregate values for the given group_by buckets
</a><a href="#h5-3-11" id="h5-3-11" class="i">+    /// across all rows in the source node. The group_by columns are emitted
</a><a href="#h5-3-12" id="h5-3-12" class="i">+    /// first, followed by the aggregate columns, in the given order.
</a>     Aggregate { source: Box&lt;Node&gt;, group_by: Vec&lt;Expression&gt;, aggregates: Vec&lt;Aggregate&gt; },
<a href="#h5-3-14" id="h5-3-14" class="d">-    /// Filters source rows, by only emitting rows for which the predicate
</a><a href="#h5-3-15" id="h5-3-15" class="d">-    /// evaluates to true.
</a><a href="#h5-3-16" id="h5-3-16" class="i">+    /// Filters source rows, by discarding rows for which the predicate
</a><a href="#h5-3-17" id="h5-3-17" class="i">+    /// evaluates to false.
</a>     Filter { source: Box&lt;Node&gt;, predicate: Expression },
     /// Joins the left and right sources on the given columns by building an
     /// in-memory hashmap of the right source and looking up matches for each
<a href="#h5-4" id="h5-4" class="h">@@ -106,139 +123,66 @@ pub enum Node {
</a>     /// When outer is true (e.g. LEFT JOIN), a left row without a right match is
     /// emitted anyway, with NULLs for the right row.
     NestedLoopJoin { left: Box&lt;Node&gt;, right: Box&lt;Node&gt;, predicate: Option&lt;Expression&gt;, outer: bool },
<a href="#h5-4-3" id="h5-4-3" class="d">-    /// Nothing does not emit anything, but retains the column names of any
</a><a href="#h5-4-4" id="h5-4-4" class="d">-    /// replaced nodes for results and plan expression display.
</a><a href="#h5-4-5" id="h5-4-5" class="i">+    /// Nothing does not emit anything, and is used to short-circuit nodes that
</a><a href="#h5-4-6" id="h5-4-6" class="i">+    /// can&#39;t emit anything during optimization. It retains the column names of
</a><a href="#h5-4-7" id="h5-4-7" class="i">+    /// any replaced nodes for results headers and plan formatting.
</a>     Nothing { columns: Vec&lt;Label&gt; },
     /// Discards the first offset rows from source, emits the rest.
     Offset { source: Box&lt;Node&gt;, offset: usize },
<a href="#h5-4-11" id="h5-4-11" class="d">-    /// Sorts the source rows by the given expression/direction pairs. Buffers
</a><a href="#h5-4-12" id="h5-4-12" class="d">-    /// the entire row set in memory.
</a><a href="#h5-4-13" id="h5-4-13" class="d">-    Order { source: Box&lt;Node&gt;, orders: Vec&lt;(Expression, Direction)&gt; },
</a><a href="#h5-4-14" id="h5-4-14" class="i">+    /// Sorts the source rows by the given sort key. Buffers the entire row set
</a><a href="#h5-4-15" id="h5-4-15" class="i">+    /// in memory.
</a><a href="#h5-4-16" id="h5-4-16" class="i">+    Order { source: Box&lt;Node&gt;, key: Vec&lt;(Expression, Direction)&gt; },
</a>     /// Projects the input rows by evaluating the given expressions. Aliases are
     /// only used when displaying the plan.
     Projection { source: Box&lt;Node&gt;, expressions: Vec&lt;Expression&gt;, aliases: Vec&lt;Label&gt; },
     /// Remaps source columns to the given target column index, or None to drop
<a href="#h5-4-21" id="h5-4-21" class="d">-    /// the column. Unspecified target columns yield Value::Null.
</a><a href="#h5-4-22" id="h5-4-22" class="i">+    /// the column. Unspecified target columns yield Value::Null. The source →
</a><a href="#h5-4-23" id="h5-4-23" class="i">+    /// target mapping ensures a source column can only be mapped to a single
</a><a href="#h5-4-24" id="h5-4-24" class="i">+    /// target column, allowing the value to be moved rather than cloned.
</a>     Remap { source: Box&lt;Node&gt;, targets: Vec&lt;Option&lt;usize&gt;&gt; },
<a href="#h5-4-26" id="h5-4-26" class="d">-    /// A full table scan, with an optional filter pushdown. The schema is used
</a><a href="#h5-4-27" id="h5-4-27" class="d">-    /// during plan optimization. The alias is only used for formatting.
</a><a href="#h5-4-28" id="h5-4-28" class="i">+    /// A full table scan, with an optional pushed-down filter. The schema is
</a><a href="#h5-4-29" id="h5-4-29" class="i">+    /// used during plan optimization. The alias is only used for formatting.
</a>     Scan { table: Table, filter: Option&lt;Expression&gt;, alias: Option&lt;String&gt; },
     /// A constant set of values.
     Values { rows: Vec&lt;Vec&lt;Expression&gt;&gt; },
 }
 
 impl Node {
<a href="#h5-4-36" id="h5-4-36" class="d">-    /// Recursively transforms query nodes depth-first by applying the given
</a><a href="#h5-4-37" id="h5-4-37" class="d">-    /// closures before and after descending.
</a><a href="#h5-4-38" id="h5-4-38" class="d">-    pub fn transform&lt;B, A&gt;(mut self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
</a><a href="#h5-4-39" id="h5-4-39" class="d">-    where
</a><a href="#h5-4-40" id="h5-4-40" class="d">-        B: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h5-4-41" id="h5-4-41" class="d">-        A: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h5-4-42" id="h5-4-42" class="d">-    {
</a><a href="#h5-4-43" id="h5-4-43" class="d">-        // Helper for transforming boxed nodes.
</a><a href="#h5-4-44" id="h5-4-44" class="d">-        let transform = |mut node: Box&lt;Node&gt;| -&gt; Result&lt;Box&lt;Node&gt;&gt; {
</a><a href="#h5-4-45" id="h5-4-45" class="d">-            *node = node.transform(before, after)?;
</a><a href="#h5-4-46" id="h5-4-46" class="d">-            Ok(node)
</a><a href="#h5-4-47" id="h5-4-47" class="d">-        };
</a><a href="#h5-4-48" id="h5-4-48" class="i">+    /// Returns the number of columns emitted by the node.
</a><a href="#h5-4-49" id="h5-4-49" class="i">+    pub fn columns(&amp;self) -&gt; usize {
</a><a href="#h5-4-50" id="h5-4-50" class="i">+        match self {
</a><a href="#h5-4-51" id="h5-4-51" class="i">+            // Source nodes emit all table columns.
</a><a href="#h5-4-52" id="h5-4-52" class="i">+            Self::IndexLookup { table, .. }
</a><a href="#h5-4-53" id="h5-4-53" class="i">+            | Self::KeyLookup { table, .. }
</a><a href="#h5-4-54" id="h5-4-54" class="i">+            | Self::Scan { table, .. } =&gt; table.columns.len(),
</a> 
<a href="#h5-4-56" id="h5-4-56" class="d">-        self = before(self)?;
</a><a href="#h5-4-57" id="h5-4-57" class="d">-        self = match self {
</a><a href="#h5-4-58" id="h5-4-58" class="d">-            Self::Aggregate { source, aggregates, group_by } =&gt; {
</a><a href="#h5-4-59" id="h5-4-59" class="d">-                Self::Aggregate { source: transform(source)?, aggregates, group_by }
</a><a href="#h5-4-60" id="h5-4-60" class="d">-            }
</a><a href="#h5-4-61" id="h5-4-61" class="d">-            Self::Filter { source, predicate } =&gt; {
</a><a href="#h5-4-62" id="h5-4-62" class="d">-                Self::Filter { source: transform(source)?, predicate }
</a><a href="#h5-4-63" id="h5-4-63" class="d">-            }
</a><a href="#h5-4-64" id="h5-4-64" class="d">-            Self::HashJoin { left, left_column, right, right_column, outer } =&gt; Self::HashJoin {
</a><a href="#h5-4-65" id="h5-4-65" class="d">-                left: transform(left)?,
</a><a href="#h5-4-66" id="h5-4-66" class="d">-                left_column,
</a><a href="#h5-4-67" id="h5-4-67" class="d">-                right: transform(right)?,
</a><a href="#h5-4-68" id="h5-4-68" class="d">-                right_column,
</a><a href="#h5-4-69" id="h5-4-69" class="d">-                outer,
</a><a href="#h5-4-70" id="h5-4-70" class="d">-            },
</a><a href="#h5-4-71" id="h5-4-71" class="d">-            Self::Limit { source, limit } =&gt; Self::Limit { source: transform(source)?, limit },
</a><a href="#h5-4-72" id="h5-4-72" class="d">-            Self::NestedLoopJoin { left, right, predicate, outer } =&gt; Self::NestedLoopJoin {
</a><a href="#h5-4-73" id="h5-4-73" class="d">-                left: transform(left)?,
</a><a href="#h5-4-74" id="h5-4-74" class="d">-                right: transform(right)?,
</a><a href="#h5-4-75" id="h5-4-75" class="d">-                predicate,
</a><a href="#h5-4-76" id="h5-4-76" class="d">-                outer,
</a><a href="#h5-4-77" id="h5-4-77" class="d">-            },
</a><a href="#h5-4-78" id="h5-4-78" class="d">-            Self::Offset { source, offset } =&gt; Self::Offset { source: transform(source)?, offset },
</a><a href="#h5-4-79" id="h5-4-79" class="d">-            Self::Order { source, orders } =&gt; Self::Order { source: transform(source)?, orders },
</a><a href="#h5-4-80" id="h5-4-80" class="d">-            Self::Projection { source, expressions, aliases } =&gt; {
</a><a href="#h5-4-81" id="h5-4-81" class="d">-                Self::Projection { source: transform(source)?, expressions, aliases }
</a><a href="#h5-4-82" id="h5-4-82" class="i">+            // Some nodes modify the column set.
</a><a href="#h5-4-83" id="h5-4-83" class="i">+            Self::Aggregate { aggregates, group_by, .. } =&gt; aggregates.len() + group_by.len(),
</a><a href="#h5-4-84" id="h5-4-84" class="i">+            Self::Projection { expressions, .. } =&gt; expressions.len(),
</a><a href="#h5-4-85" id="h5-4-85" class="i">+            Self::Remap { targets, .. } =&gt; {
</a><a href="#h5-4-86" id="h5-4-86" class="i">+                targets.iter().filter_map(|v| *v).map(|i| i + 1).max().unwrap_or(0)
</a>             }
<a href="#h5-4-88" id="h5-4-88" class="d">-            Self::Remap { source, targets } =&gt; Self::Remap { source: transform(source)?, targets },
</a><a href="#h5-4-89" id="h5-4-89" class="d">-
</a><a href="#h5-4-90" id="h5-4-90" class="d">-            node @ (Self::IndexLookup { .. }
</a><a href="#h5-4-91" id="h5-4-91" class="d">-            | Self::KeyLookup { .. }
</a><a href="#h5-4-92" id="h5-4-92" class="d">-            | Self::Nothing { .. }
</a><a href="#h5-4-93" id="h5-4-93" class="d">-            | Self::Scan { .. }
</a><a href="#h5-4-94" id="h5-4-94" class="d">-            | Self::Values { .. }) =&gt; node,
</a><a href="#h5-4-95" id="h5-4-95" class="d">-        };
</a><a href="#h5-4-96" id="h5-4-96" class="d">-        self = after(self)?;
</a><a href="#h5-4-97" id="h5-4-97" class="d">-        Ok(self)
</a><a href="#h5-4-98" id="h5-4-98" class="d">-    }
</a> 
<a href="#h5-4-100" id="h5-4-100" class="d">-    /// Recursively transforms all expressions in a node by calling the given
</a><a href="#h5-4-101" id="h5-4-101" class="d">-    /// closures on them before and after descending.
</a><a href="#h5-4-102" id="h5-4-102" class="d">-    pub fn transform_expressions&lt;B, A&gt;(self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
</a><a href="#h5-4-103" id="h5-4-103" class="d">-    where
</a><a href="#h5-4-104" id="h5-4-104" class="d">-        B: Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h5-4-105" id="h5-4-105" class="d">-        A: Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h5-4-106" id="h5-4-106" class="d">-    {
</a><a href="#h5-4-107" id="h5-4-107" class="d">-        Ok(match self {
</a><a href="#h5-4-108" id="h5-4-108" class="d">-            Self::Filter { source, predicate } =&gt; {
</a><a href="#h5-4-109" id="h5-4-109" class="d">-                Self::Filter { source, predicate: predicate.transform(before, after)? }
</a><a href="#h5-4-110" id="h5-4-110" class="d">-            }
</a><a href="#h5-4-111" id="h5-4-111" class="d">-            Self::Order { source, orders } =&gt; Self::Order {
</a><a href="#h5-4-112" id="h5-4-112" class="d">-                source,
</a><a href="#h5-4-113" id="h5-4-113" class="d">-                orders: orders
</a><a href="#h5-4-114" id="h5-4-114" class="d">-                    .into_iter()
</a><a href="#h5-4-115" id="h5-4-115" class="d">-                    .map(|(e, o)| e.transform(before, after).map(|e| (e, o)))
</a><a href="#h5-4-116" id="h5-4-116" class="d">-                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h5-4-117" id="h5-4-117" class="d">-            },
</a><a href="#h5-4-118" id="h5-4-118" class="d">-            Self::NestedLoopJoin { left, right, predicate: Some(predicate), outer } =&gt; {
</a><a href="#h5-4-119" id="h5-4-119" class="d">-                Self::NestedLoopJoin {
</a><a href="#h5-4-120" id="h5-4-120" class="d">-                    left,
</a><a href="#h5-4-121" id="h5-4-121" class="d">-                    right,
</a><a href="#h5-4-122" id="h5-4-122" class="d">-                    predicate: Some(predicate.transform(before, after)?),
</a><a href="#h5-4-123" id="h5-4-123" class="d">-                    outer,
</a><a href="#h5-4-124" id="h5-4-124" class="d">-                }
</a><a href="#h5-4-125" id="h5-4-125" class="d">-            }
</a><a href="#h5-4-126" id="h5-4-126" class="d">-            Self::Projection { source, expressions, aliases } =&gt; Self::Projection {
</a><a href="#h5-4-127" id="h5-4-127" class="d">-                source,
</a><a href="#h5-4-128" id="h5-4-128" class="d">-                expressions: expressions
</a><a href="#h5-4-129" id="h5-4-129" class="d">-                    .into_iter()
</a><a href="#h5-4-130" id="h5-4-130" class="d">-                    .map(|e| e.transform(before, after))
</a><a href="#h5-4-131" id="h5-4-131" class="d">-                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h5-4-132" id="h5-4-132" class="d">-                aliases,
</a><a href="#h5-4-133" id="h5-4-133" class="d">-            },
</a><a href="#h5-4-134" id="h5-4-134" class="d">-            Self::Scan { table, alias, filter: Some(filter) } =&gt; {
</a><a href="#h5-4-135" id="h5-4-135" class="d">-                Self::Scan { table, alias, filter: Some(filter.transform(before, after)?) }
</a><a href="#h5-4-136" id="h5-4-136" class="i">+            // Join nodes emit the combined columns.
</a><a href="#h5-4-137" id="h5-4-137" class="i">+            Self::HashJoin { left, right, .. } | Self::NestedLoopJoin { left, right, .. } =&gt; {
</a><a href="#h5-4-138" id="h5-4-138" class="i">+                left.columns() + right.columns()
</a>             }
<a href="#h5-4-140" id="h5-4-140" class="d">-            Self::Values { rows } =&gt; Self::Values {
</a><a href="#h5-4-141" id="h5-4-141" class="d">-                rows: rows
</a><a href="#h5-4-142" id="h5-4-142" class="d">-                    .into_iter()
</a><a href="#h5-4-143" id="h5-4-143" class="d">-                    .map(|row| row.into_iter().map(|e| e.transform(before, after)).collect())
</a><a href="#h5-4-144" id="h5-4-144" class="d">-                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h5-4-145" id="h5-4-145" class="d">-            },
</a> 
<a href="#h5-4-147" id="h5-4-147" class="d">-            node @ (Self::Aggregate { .. }
</a><a href="#h5-4-148" id="h5-4-148" class="d">-            | Self::HashJoin { .. }
</a><a href="#h5-4-149" id="h5-4-149" class="d">-            | Self::IndexLookup { .. }
</a><a href="#h5-4-150" id="h5-4-150" class="d">-            | Self::KeyLookup { .. }
</a><a href="#h5-4-151" id="h5-4-151" class="d">-            | Self::Limit { .. }
</a><a href="#h5-4-152" id="h5-4-152" class="d">-            | Self::NestedLoopJoin { predicate: None, .. }
</a><a href="#h5-4-153" id="h5-4-153" class="d">-            | Self::Nothing { .. }
</a><a href="#h5-4-154" id="h5-4-154" class="d">-            | Self::Offset { .. }
</a><a href="#h5-4-155" id="h5-4-155" class="d">-            | Self::Scan { filter: None, .. }
</a><a href="#h5-4-156" id="h5-4-156" class="d">-            | Self::Remap { .. }) =&gt; node,
</a><a href="#h5-4-157" id="h5-4-157" class="d">-        })
</a><a href="#h5-4-158" id="h5-4-158" class="i">+            // Simple nodes just pass through the source columns.
</a><a href="#h5-4-159" id="h5-4-159" class="i">+            Self::Filter { source, .. }
</a><a href="#h5-4-160" id="h5-4-160" class="i">+            | Self::Limit { source, .. }
</a><a href="#h5-4-161" id="h5-4-161" class="i">+            | Self::Offset { source, .. }
</a><a href="#h5-4-162" id="h5-4-162" class="i">+            | Self::Order { source, .. } =&gt; source.columns(),
</a><a href="#h5-4-163" id="h5-4-163" class="i">+
</a><a href="#h5-4-164" id="h5-4-164" class="i">+            // And some are trivial.
</a><a href="#h5-4-165" id="h5-4-165" class="i">+            Self::Nothing { columns } =&gt; columns.len(),
</a><a href="#h5-4-166" id="h5-4-166" class="i">+            Self::Values { rows } =&gt; rows.first().map(|row| row.len()).unwrap_or(0),
</a><a href="#h5-4-167" id="h5-4-167" class="i">+        }
</a>     }
 
<a href="#h5-4-170" id="h5-4-170" class="d">-    /// Returns a label for a column, if any. Only used as query result headers
</a><a href="#h5-4-171" id="h5-4-171" class="d">-    /// and for display purposes, not to look up expression columns (see Scope).
</a><a href="#h5-4-172" id="h5-4-172" class="i">+    /// Returns a label for a column, if any, by tracing the column through the
</a><a href="#h5-4-173" id="h5-4-173" class="i">+    /// plan tree. Only used for query result headers and plan display purposes,
</a><a href="#h5-4-174" id="h5-4-174" class="i">+    /// not to look up expression columns (see Scope).
</a>     pub fn column_label(&amp;self, index: usize) -&gt; Label {
         match self {
             // Source nodes use the table/column name.
<a href="#h5-5" id="h5-5" class="h">@@ -262,6 +206,7 @@ impl Node {
</a>                     // Unaliased expressions don&#39;t have a name.
                     Some(_) | None =&gt; Label::None,
                 },
<a href="#h5-5-3" id="h5-5-3" class="i">+                // Aliased columns use the alias.
</a>                 Some(alias) =&gt; alias.clone(),
             },
             Self::Remap { source, targets } =&gt; targets
<a href="#h5-6" id="h5-6" class="h">@@ -272,10 +217,10 @@ impl Node {
</a> 
             // Joins dispatch to the appropriate source.
             Self::HashJoin { left, right, .. } | Self::NestedLoopJoin { left, right, .. } =&gt; {
<a href="#h5-6-3" id="h5-6-3" class="d">-                if index &lt; left.size() {
</a><a href="#h5-6-4" id="h5-6-4" class="i">+                if index &lt; left.columns() {
</a>                     left.column_label(index)
                 } else {
<a href="#h5-6-7" id="h5-6-7" class="d">-                    right.column_label(index - left.size())
</a><a href="#h5-6-8" id="h5-6-8" class="i">+                    right.column_label(index - left.columns())
</a>                 }
             }
 
<a href="#h5-7" id="h5-7" class="h">@@ -293,35 +238,154 @@ impl Node {
</a>         }
     }
 
<a href="#h5-7-3" id="h5-7-3" class="d">-    /// Returns the size of the node, i.e. the number of columns.
</a><a href="#h5-7-4" id="h5-7-4" class="d">-    pub fn size(&amp;self) -&gt; usize {
</a><a href="#h5-7-5" id="h5-7-5" class="d">-        match self {
</a><a href="#h5-7-6" id="h5-7-6" class="d">-            // Source nodes emit all table columns.
</a><a href="#h5-7-7" id="h5-7-7" class="d">-            Self::IndexLookup { table, .. }
</a><a href="#h5-7-8" id="h5-7-8" class="d">-            | Self::KeyLookup { table, .. }
</a><a href="#h5-7-9" id="h5-7-9" class="d">-            | Self::Scan { table, .. } =&gt; table.columns.len(),
</a><a href="#h5-7-10" id="h5-7-10" class="i">+    /// Recursively transforms query nodes depth-first by applying the given
</a><a href="#h5-7-11" id="h5-7-11" class="i">+    /// closures before and after descending.
</a><a href="#h5-7-12" id="h5-7-12" class="i">+    pub fn transform(
</a><a href="#h5-7-13" id="h5-7-13" class="i">+        mut self,
</a><a href="#h5-7-14" id="h5-7-14" class="i">+        before: &amp;impl Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h5-7-15" id="h5-7-15" class="i">+        after: &amp;impl Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h5-7-16" id="h5-7-16" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a><a href="#h5-7-17" id="h5-7-17" class="i">+        // Helper for transforming boxed nodes.
</a><a href="#h5-7-18" id="h5-7-18" class="i">+        let xform = |mut node: Box&lt;Node&gt;| -&gt; Result&lt;Box&lt;Node&gt;&gt; {
</a><a href="#h5-7-19" id="h5-7-19" class="i">+            *node = node.transform(before, after)?;
</a><a href="#h5-7-20" id="h5-7-20" class="i">+            Ok(node)
</a><a href="#h5-7-21" id="h5-7-21" class="i">+        };
</a> 
<a href="#h5-7-23" id="h5-7-23" class="d">-            // Some nodes modify the column set.
</a><a href="#h5-7-24" id="h5-7-24" class="d">-            Self::Aggregate { aggregates, group_by, .. } =&gt; aggregates.len() + group_by.len(),
</a><a href="#h5-7-25" id="h5-7-25" class="d">-            Self::Projection { expressions, .. } =&gt; expressions.len(),
</a><a href="#h5-7-26" id="h5-7-26" class="d">-            Self::Remap { targets, .. } =&gt; {
</a><a href="#h5-7-27" id="h5-7-27" class="d">-                targets.iter().filter_map(|v| *v).map(|i| i + 1).max().unwrap_or(0)
</a><a href="#h5-7-28" id="h5-7-28" class="i">+        self = before(self)?;
</a><a href="#h5-7-29" id="h5-7-29" class="i">+        self = match self {
</a><a href="#h5-7-30" id="h5-7-30" class="i">+            Self::Aggregate { source, group_by, aggregates } =&gt; {
</a><a href="#h5-7-31" id="h5-7-31" class="i">+                Self::Aggregate { source: xform(source)?, group_by, aggregates }
</a><a href="#h5-7-32" id="h5-7-32" class="i">+            }
</a><a href="#h5-7-33" id="h5-7-33" class="i">+            Self::Filter { source, predicate } =&gt; {
</a><a href="#h5-7-34" id="h5-7-34" class="i">+                Self::Filter { source: xform(source)?, predicate }
</a><a href="#h5-7-35" id="h5-7-35" class="i">+            }
</a><a href="#h5-7-36" id="h5-7-36" class="i">+            Self::HashJoin { left, left_column, right, right_column, outer } =&gt; Self::HashJoin {
</a><a href="#h5-7-37" id="h5-7-37" class="i">+                left: xform(left)?,
</a><a href="#h5-7-38" id="h5-7-38" class="i">+                left_column,
</a><a href="#h5-7-39" id="h5-7-39" class="i">+                right: xform(right)?,
</a><a href="#h5-7-40" id="h5-7-40" class="i">+                right_column,
</a><a href="#h5-7-41" id="h5-7-41" class="i">+                outer,
</a><a href="#h5-7-42" id="h5-7-42" class="i">+            },
</a><a href="#h5-7-43" id="h5-7-43" class="i">+            Self::Limit { source, limit } =&gt; Self::Limit { source: xform(source)?, limit },
</a><a href="#h5-7-44" id="h5-7-44" class="i">+            Self::NestedLoopJoin { left, right, predicate, outer } =&gt; {
</a><a href="#h5-7-45" id="h5-7-45" class="i">+                Self::NestedLoopJoin { left: xform(left)?, right: xform(right)?, predicate, outer }
</a>             }
<a href="#h5-7-47" id="h5-7-47" class="i">+            Self::Offset { source, offset } =&gt; Self::Offset { source: xform(source)?, offset },
</a><a href="#h5-7-48" id="h5-7-48" class="i">+            Self::Order { source, key } =&gt; Self::Order { source: xform(source)?, key },
</a><a href="#h5-7-49" id="h5-7-49" class="i">+            Self::Projection { source, expressions, aliases } =&gt; {
</a><a href="#h5-7-50" id="h5-7-50" class="i">+                Self::Projection { source: xform(source)?, expressions, aliases }
</a><a href="#h5-7-51" id="h5-7-51" class="i">+            }
</a><a href="#h5-7-52" id="h5-7-52" class="i">+            Self::Remap { source, targets } =&gt; Self::Remap { source: xform(source)?, targets },
</a> 
<a href="#h5-7-54" id="h5-7-54" class="d">-            // Join nodes emit the combined columns.
</a><a href="#h5-7-55" id="h5-7-55" class="d">-            Self::HashJoin { left, right, .. } | Self::NestedLoopJoin { left, right, .. } =&gt; {
</a><a href="#h5-7-56" id="h5-7-56" class="d">-                left.size() + right.size()
</a><a href="#h5-7-57" id="h5-7-57" class="i">+            Self::IndexLookup { .. }
</a><a href="#h5-7-58" id="h5-7-58" class="i">+            | Self::KeyLookup { .. }
</a><a href="#h5-7-59" id="h5-7-59" class="i">+            | Self::Nothing { .. }
</a><a href="#h5-7-60" id="h5-7-60" class="i">+            | Self::Scan { .. }
</a><a href="#h5-7-61" id="h5-7-61" class="i">+            | Self::Values { .. } =&gt; self,
</a><a href="#h5-7-62" id="h5-7-62" class="i">+        };
</a><a href="#h5-7-63" id="h5-7-63" class="i">+        self = after(self)?;
</a><a href="#h5-7-64" id="h5-7-64" class="i">+        Ok(self)
</a><a href="#h5-7-65" id="h5-7-65" class="i">+    }
</a><a href="#h5-7-66" id="h5-7-66" class="i">+
</a><a href="#h5-7-67" id="h5-7-67" class="i">+    /// Recursively transforms all node expressions by calling the given
</a><a href="#h5-7-68" id="h5-7-68" class="i">+    /// closures on them before and after descending.
</a><a href="#h5-7-69" id="h5-7-69" class="i">+    pub fn transform_expressions(
</a><a href="#h5-7-70" id="h5-7-70" class="i">+        self,
</a><a href="#h5-7-71" id="h5-7-71" class="i">+        before: &amp;impl Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h5-7-72" id="h5-7-72" class="i">+        after: &amp;impl Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h5-7-73" id="h5-7-73" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a><a href="#h5-7-74" id="h5-7-74" class="i">+        Ok(match self {
</a><a href="#h5-7-75" id="h5-7-75" class="i">+            Self::Filter { source, mut predicate } =&gt; {
</a><a href="#h5-7-76" id="h5-7-76" class="i">+                predicate = predicate.transform(before, after)?;
</a><a href="#h5-7-77" id="h5-7-77" class="i">+                Self::Filter { source, predicate }
</a><a href="#h5-7-78" id="h5-7-78" class="i">+            }
</a><a href="#h5-7-79" id="h5-7-79" class="i">+            Self::NestedLoopJoin { left, right, predicate: Some(predicate), outer } =&gt; {
</a><a href="#h5-7-80" id="h5-7-80" class="i">+                let predicate = Some(predicate.transform(before, after)?);
</a><a href="#h5-7-81" id="h5-7-81" class="i">+                Self::NestedLoopJoin { left, right, predicate, outer }
</a><a href="#h5-7-82" id="h5-7-82" class="i">+            }
</a><a href="#h5-7-83" id="h5-7-83" class="i">+            Self::Order { source, mut key } =&gt; {
</a><a href="#h5-7-84" id="h5-7-84" class="i">+                key = key
</a><a href="#h5-7-85" id="h5-7-85" class="i">+                    .into_iter()
</a><a href="#h5-7-86" id="h5-7-86" class="i">+                    .map(|(expr, dir)| Ok((expr.transform(before, after)?, dir)))
</a><a href="#h5-7-87" id="h5-7-87" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h5-7-88" id="h5-7-88" class="i">+                Self::Order { source, key }
</a><a href="#h5-7-89" id="h5-7-89" class="i">+            }
</a><a href="#h5-7-90" id="h5-7-90" class="i">+            Self::Projection { source, mut expressions, aliases } =&gt; {
</a><a href="#h5-7-91" id="h5-7-91" class="i">+                expressions = expressions
</a><a href="#h5-7-92" id="h5-7-92" class="i">+                    .into_iter()
</a><a href="#h5-7-93" id="h5-7-93" class="i">+                    .map(|expr| expr.transform(before, after))
</a><a href="#h5-7-94" id="h5-7-94" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h5-7-95" id="h5-7-95" class="i">+                Self::Projection { source, expressions, aliases }
</a><a href="#h5-7-96" id="h5-7-96" class="i">+            }
</a><a href="#h5-7-97" id="h5-7-97" class="i">+            Self::Scan { table, alias, filter: Some(filter) } =&gt; {
</a><a href="#h5-7-98" id="h5-7-98" class="i">+                let filter = Some(filter.transform(before, after)?);
</a><a href="#h5-7-99" id="h5-7-99" class="i">+                Self::Scan { table, alias, filter }
</a><a href="#h5-7-100" id="h5-7-100" class="i">+            }
</a><a href="#h5-7-101" id="h5-7-101" class="i">+            Self::Values { mut rows } =&gt; {
</a><a href="#h5-7-102" id="h5-7-102" class="i">+                rows = rows
</a><a href="#h5-7-103" id="h5-7-103" class="i">+                    .into_iter()
</a><a href="#h5-7-104" id="h5-7-104" class="i">+                    .map(|row| row.into_iter().map(|expr| expr.transform(before, after)).collect())
</a><a href="#h5-7-105" id="h5-7-105" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h5-7-106" id="h5-7-106" class="i">+                Self::Values { rows }
</a>             }
 
<a href="#h5-7-109" id="h5-7-109" class="d">-            // Simple nodes just pass through the source columns.
</a><a href="#h5-7-110" id="h5-7-110" class="d">-            Self::Filter { source, .. }
</a><a href="#h5-7-111" id="h5-7-111" class="d">-            | Self::Limit { source, .. }
</a><a href="#h5-7-112" id="h5-7-112" class="d">-            | Self::Offset { source, .. }
</a><a href="#h5-7-113" id="h5-7-113" class="d">-            | Self::Order { source, .. } =&gt; source.size(),
</a><a href="#h5-7-114" id="h5-7-114" class="i">+            Self::Aggregate { .. }
</a><a href="#h5-7-115" id="h5-7-115" class="i">+            | Self::HashJoin { .. }
</a><a href="#h5-7-116" id="h5-7-116" class="i">+            | Self::IndexLookup { .. }
</a><a href="#h5-7-117" id="h5-7-117" class="i">+            | Self::KeyLookup { .. }
</a><a href="#h5-7-118" id="h5-7-118" class="i">+            | Self::Limit { .. }
</a><a href="#h5-7-119" id="h5-7-119" class="i">+            | Self::NestedLoopJoin { predicate: None, .. }
</a><a href="#h5-7-120" id="h5-7-120" class="i">+            | Self::Nothing { .. }
</a><a href="#h5-7-121" id="h5-7-121" class="i">+            | Self::Offset { .. }
</a><a href="#h5-7-122" id="h5-7-122" class="i">+            | Self::Remap { .. }
</a><a href="#h5-7-123" id="h5-7-123" class="i">+            | Self::Scan { filter: None, .. } =&gt; self,
</a><a href="#h5-7-124" id="h5-7-124" class="i">+        })
</a><a href="#h5-7-125" id="h5-7-125" class="i">+    }
</a><a href="#h5-7-126" id="h5-7-126" class="i">+}
</a> 
<a href="#h5-7-128" id="h5-7-128" class="d">-            // And some are trivial.
</a><a href="#h5-7-129" id="h5-7-129" class="d">-            Self::Nothing { columns } =&gt; columns.len(),
</a><a href="#h5-7-130" id="h5-7-130" class="d">-            Self::Values { rows } =&gt; rows.first().map(|row| row.len()).unwrap_or(0),
</a><a href="#h5-7-131" id="h5-7-131" class="i">+/// An aggregate function.
</a><a href="#h5-7-132" id="h5-7-132" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h5-7-133" id="h5-7-133" class="i">+pub enum Aggregate {
</a><a href="#h5-7-134" id="h5-7-134" class="i">+    Average(Expression),
</a><a href="#h5-7-135" id="h5-7-135" class="i">+    Count(Expression),
</a><a href="#h5-7-136" id="h5-7-136" class="i">+    Max(Expression),
</a><a href="#h5-7-137" id="h5-7-137" class="i">+    Min(Expression),
</a><a href="#h5-7-138" id="h5-7-138" class="i">+    Sum(Expression),
</a><a href="#h5-7-139" id="h5-7-139" class="i">+}
</a><a href="#h5-7-140" id="h5-7-140" class="i">+
</a><a href="#h5-7-141" id="h5-7-141" class="i">+impl Aggregate {
</a><a href="#h5-7-142" id="h5-7-142" class="i">+    fn format(&amp;self, node: &amp;Node) -&gt; String {
</a><a href="#h5-7-143" id="h5-7-143" class="i">+        match self {
</a><a href="#h5-7-144" id="h5-7-144" class="i">+            Self::Average(expr) =&gt; format!(&quot;avg({})&quot;, expr.format(node)),
</a><a href="#h5-7-145" id="h5-7-145" class="i">+            Self::Count(expr) =&gt; format!(&quot;count({})&quot;, expr.format(node)),
</a><a href="#h5-7-146" id="h5-7-146" class="i">+            Self::Max(expr) =&gt; format!(&quot;max({})&quot;, expr.format(node)),
</a><a href="#h5-7-147" id="h5-7-147" class="i">+            Self::Min(expr) =&gt; format!(&quot;min({})&quot;, expr.format(node)),
</a><a href="#h5-7-148" id="h5-7-148" class="i">+            Self::Sum(expr) =&gt; format!(&quot;sum({})&quot;, expr.format(node)),
</a><a href="#h5-7-149" id="h5-7-149" class="i">+        }
</a><a href="#h5-7-150" id="h5-7-150" class="i">+    }
</a><a href="#h5-7-151" id="h5-7-151" class="i">+}
</a><a href="#h5-7-152" id="h5-7-152" class="i">+
</a><a href="#h5-7-153" id="h5-7-153" class="i">+/// A sort order direction.
</a><a href="#h5-7-154" id="h5-7-154" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h5-7-155" id="h5-7-155" class="i">+pub enum Direction {
</a><a href="#h5-7-156" id="h5-7-156" class="i">+    Ascending,
</a><a href="#h5-7-157" id="h5-7-157" class="i">+    Descending,
</a><a href="#h5-7-158" id="h5-7-158" class="i">+}
</a><a href="#h5-7-159" id="h5-7-159" class="i">+
</a><a href="#h5-7-160" id="h5-7-160" class="i">+impl std::fmt::Display for Direction {
</a><a href="#h5-7-161" id="h5-7-161" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h5-7-162" id="h5-7-162" class="i">+        match self {
</a><a href="#h5-7-163" id="h5-7-163" class="i">+            Self::Ascending =&gt; f.write_str(&quot;asc&quot;),
</a><a href="#h5-7-164" id="h5-7-164" class="i">+            Self::Descending =&gt; f.write_str(&quot;desc&quot;),
</a><a href="#h5-7-165" id="h5-7-165" class="i">+        }
</a><a href="#h5-7-166" id="h5-7-166" class="i">+    }
</a><a href="#h5-7-167" id="h5-7-167" class="i">+}
</a><a href="#h5-7-168" id="h5-7-168" class="i">+
</a><a href="#h5-7-169" id="h5-7-169" class="i">+impl From&lt;ast::Direction&gt; for Direction {
</a><a href="#h5-7-170" id="h5-7-170" class="i">+    fn from(dir: ast::Direction) -&gt; Self {
</a><a href="#h5-7-171" id="h5-7-171" class="i">+        match dir {
</a><a href="#h5-7-172" id="h5-7-172" class="i">+            ast::Direction::Ascending =&gt; Self::Ascending,
</a><a href="#h5-7-173" id="h5-7-173" class="i">+            ast::Direction::Descending =&gt; Self::Descending,
</a>         }
     }
 }
<a href="#h5-8" id="h5-8" class="h">@@ -334,42 +398,41 @@ impl std::fmt::Display for Plan {
</a>             Self::DropTable { table, .. } =&gt; write!(f, &quot;DropTable: {table}&quot;),
             Self::Delete { table, source, .. } =&gt; {
                 write!(f, &quot;Delete: {table}&quot;)?;
<a href="#h5-8-3" id="h5-8-3" class="d">-                source.format(f, String::new(), false, true)
</a><a href="#h5-8-4" id="h5-8-4" class="i">+                source.format(f, &quot;&quot;, false, true)
</a>             }
             Self::Insert { table, source, .. } =&gt; {
                 write!(f, &quot;Insert: {}&quot;, table.name)?;
<a href="#h5-8-8" id="h5-8-8" class="d">-                source.format(f, String::new(), false, true)
</a><a href="#h5-8-9" id="h5-8-9" class="i">+                source.format(f, &quot;&quot;, false, true)
</a>             }
             Self::Update { table, source, expressions, .. } =&gt; {
                 let expressions = expressions
                     .iter()
<a href="#h5-8-14" id="h5-8-14" class="d">-                    .map(|(i, e)| format!(&quot;{}={}&quot;, table.columns[*i].name, e.format(source)))
</a><a href="#h5-8-15" id="h5-8-15" class="i">+                    .map(|(i, expr)| format!(&quot;{}={}&quot;, table.columns[*i].name, expr.format(source)))
</a>                     .join(&quot;, &quot;);
<a href="#h5-8-17" id="h5-8-17" class="d">-                let table = &amp;table.name;
</a><a href="#h5-8-18" id="h5-8-18" class="d">-                write!(f, &quot;Update: {table} ({expressions})&quot;)?;
</a><a href="#h5-8-19" id="h5-8-19" class="d">-                source.format(f, String::new(), false, true)
</a><a href="#h5-8-20" id="h5-8-20" class="i">+                write!(f, &quot;Update: {} ({expressions})&quot;, table.name)?;
</a><a href="#h5-8-21" id="h5-8-21" class="i">+                source.format(f, &quot;&quot;, false, true)
</a>             }
<a href="#h5-8-23" id="h5-8-23" class="d">-            Self::Select(root) =&gt; root.fmt(f),
</a><a href="#h5-8-24" id="h5-8-24" class="i">+            Self::Select(root) =&gt; root.format(f, &quot;&quot;, true, true),
</a>         }
     }
 }
 
 impl std::fmt::Display for Node {
     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
<a href="#h5-8-31" id="h5-8-31" class="d">-        self.format(f, String::new(), true, true)
</a><a href="#h5-8-32" id="h5-8-32" class="i">+        self.format(f, &quot;&quot;, true, true)
</a>     }
 }
 
 impl Node {
<a href="#h5-8-37" id="h5-8-37" class="d">-    /// Recursively formats the node. Prefix is used for tree branches. root is
</a><a href="#h5-8-38" id="h5-8-38" class="d">-    /// true if this is the root (first) node, and last is used if this is the
</a><a href="#h5-8-39" id="h5-8-39" class="d">-    /// last node in this branch.
</a><a href="#h5-8-40" id="h5-8-40" class="i">+    /// Recursively formats the node. Prefix is used for tree branch lines. root
</a><a href="#h5-8-41" id="h5-8-41" class="i">+    /// is true if this is the root (first) node, and last_child is true if this
</a><a href="#h5-8-42" id="h5-8-42" class="i">+    /// is the last child node of the parent.
</a>     pub fn format(
         &amp;self,
         f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;,
<a href="#h5-8-46" id="h5-8-46" class="d">-        mut prefix: String,
</a><a href="#h5-8-47" id="h5-8-47" class="i">+        prefix: &amp;str,
</a>         root: bool,
<a href="#h5-8-49" id="h5-8-49" class="d">-        last: bool,
</a><a href="#h5-8-50" id="h5-8-50" class="i">+        last_child: bool,
</a>     ) -&gt; std::fmt::Result {
         // If this is not the root node, emit a newline after the previous node.
         // This avoids a spurious newline at the end of the plan.
<a href="#h5-9" id="h5-9" class="h">@@ -379,48 +442,49 @@ impl Node {
</a> 
         // Prefix the node with a tree branch line. Modify the prefix for any
         // child nodes we&#39;ll recurse into.
<a href="#h5-9-3" id="h5-9-3" class="d">-        write!(f, &quot;{prefix}&quot;)?;
</a><a href="#h5-9-4" id="h5-9-4" class="d">-        if !last {
</a><a href="#h5-9-5" id="h5-9-5" class="d">-            write!(f, &quot;├─ &quot;)?;
</a><a href="#h5-9-6" id="h5-9-6" class="d">-            prefix += &quot;│  &quot;
</a><a href="#h5-9-7" id="h5-9-7" class="i">+        let prefix = if !last_child {
</a><a href="#h5-9-8" id="h5-9-8" class="i">+            write!(f, &quot;{prefix}├─ &quot;)?;
</a><a href="#h5-9-9" id="h5-9-9" class="i">+            format!(&quot;{prefix}│  &quot;)
</a>         } else if !root {
<a href="#h5-9-11" id="h5-9-11" class="d">-            write!(f, &quot;└─ &quot;)?;
</a><a href="#h5-9-12" id="h5-9-12" class="d">-            prefix += &quot;   &quot;;
</a><a href="#h5-9-13" id="h5-9-13" class="d">-        }
</a><a href="#h5-9-14" id="h5-9-14" class="i">+            write!(f, &quot;{prefix}└─ &quot;)?;
</a><a href="#h5-9-15" id="h5-9-15" class="i">+            format!(&quot;{prefix}   &quot;)
</a><a href="#h5-9-16" id="h5-9-16" class="i">+        } else {
</a><a href="#h5-9-17" id="h5-9-17" class="i">+            write!(f, &quot;{prefix}&quot;)?;
</a><a href="#h5-9-18" id="h5-9-18" class="i">+            prefix.to_string()
</a><a href="#h5-9-19" id="h5-9-19" class="i">+        };
</a> 
         // Format the node.
         match self {
             Self::Aggregate { source, aggregates, group_by } =&gt; {
                 let aggregates = group_by
                     .iter()
<a href="#h5-9-26" id="h5-9-26" class="d">-                    .map(|group| group.format(source))
</a><a href="#h5-9-27" id="h5-9-27" class="i">+                    .map(|group_by| group_by.format(source))
</a>                     .chain(aggregates.iter().map(|agg| agg.format(source)))
                     .join(&quot;, &quot;);
                 write!(f, &quot;Aggregate: {aggregates}&quot;)?;
<a href="#h5-9-31" id="h5-9-31" class="d">-                source.format(f, prefix, false, true)?;
</a><a href="#h5-9-32" id="h5-9-32" class="i">+                source.format(f, &amp;prefix, false, true)?;
</a>             }
             Self::Filter { source, predicate } =&gt; {
                 write!(f, &quot;Filter: {}&quot;, predicate.format(source))?;
<a href="#h5-9-36" id="h5-9-36" class="d">-                source.format(f, prefix, false, true)?;
</a><a href="#h5-9-37" id="h5-9-37" class="i">+                source.format(f, &amp;prefix, false, true)?;
</a>             }
             Self::HashJoin { left, left_column, right, right_column, outer } =&gt; {
                 let kind = if *outer { &quot;outer&quot; } else { &quot;inner&quot; };
<a href="#h5-9-41" id="h5-9-41" class="d">-                let left_label = match left.column_label(*left_column) {
</a><a href="#h5-9-42" id="h5-9-42" class="i">+                let left_column = match left.column_label(*left_column) {
</a>                     Label::None =&gt; format!(&quot;left #{left_column}&quot;),
                     label =&gt; format!(&quot;{label}&quot;),
                 };
<a href="#h5-9-46" id="h5-9-46" class="d">-                let right_label = match right.column_label(*right_column) {
</a><a href="#h5-9-47" id="h5-9-47" class="i">+                let right_column = match right.column_label(*right_column) {
</a>                     Label::None =&gt; format!(&quot;right #{right_column}&quot;),
                     label =&gt; format!(&quot;{label}&quot;),
                 };
<a href="#h5-9-51" id="h5-9-51" class="d">-                write!(f, &quot;HashJoin: {kind} on {left_label} = {right_label}&quot;)?;
</a><a href="#h5-9-52" id="h5-9-52" class="d">-                left.format(f, prefix.clone(), false, false)?;
</a><a href="#h5-9-53" id="h5-9-53" class="d">-                right.format(f, prefix, false, true)?;
</a><a href="#h5-9-54" id="h5-9-54" class="i">+                write!(f, &quot;HashJoin: {kind} on {left_column} = {right_column}&quot;)?;
</a><a href="#h5-9-55" id="h5-9-55" class="i">+                left.format(f, &amp;prefix, false, false)?;
</a><a href="#h5-9-56" id="h5-9-56" class="i">+                right.format(f, &amp;prefix, false, true)?;
</a>             }
             Self::IndexLookup { table, column, alias, values } =&gt; {
                 let column = &amp;table.columns[*column].name;
<a href="#h5-9-60" id="h5-9-60" class="d">-                let table = &amp;table.name;
</a><a href="#h5-9-61" id="h5-9-61" class="d">-                write!(f, &quot;IndexLookup: {table}.{column}&quot;)?;
</a><a href="#h5-9-62" id="h5-9-62" class="i">+                write!(f, &quot;IndexLookup: {}.{column}&quot;, table.name)?;
</a>                 if let Some(alias) = alias {
                     write!(f, &quot; as {alias}.{column}&quot;)?;
                 }
<a href="#h5-10" id="h5-10" class="h">@@ -443,30 +507,29 @@ impl Node {
</a>             }
             Self::Limit { source, limit } =&gt; {
                 write!(f, &quot;Limit: {limit}&quot;)?;
<a href="#h5-10-3" id="h5-10-3" class="d">-                source.format(f, prefix, false, true)?;
</a><a href="#h5-10-4" id="h5-10-4" class="i">+                source.format(f, &amp;prefix, false, true)?;
</a>             }
             Self::NestedLoopJoin { left, right, predicate, outer, .. } =&gt; {
<a href="#h5-10-7" id="h5-10-7" class="d">-                write!(f, &quot;NestedLoopJoin: {}&quot;, if *outer { &quot;outer&quot; } else { &quot;inner&quot; })?;
</a><a href="#h5-10-8" id="h5-10-8" class="d">-                if let Some(expr) = predicate {
</a><a href="#h5-10-9" id="h5-10-9" class="d">-                    write!(f, &quot; on {}&quot;, expr.format(self))?;
</a><a href="#h5-10-10" id="h5-10-10" class="i">+                let kind = if *outer { &quot;outer&quot; } else { &quot;inner&quot; };
</a><a href="#h5-10-11" id="h5-10-11" class="i">+                write!(f, &quot;NestedLoopJoin: {kind}&quot;)?;
</a><a href="#h5-10-12" id="h5-10-12" class="i">+                if let Some(predicate) = predicate {
</a><a href="#h5-10-13" id="h5-10-13" class="i">+                    write!(f, &quot; on {}&quot;, predicate.format(self))?;
</a>                 }
<a href="#h5-10-15" id="h5-10-15" class="d">-                left.format(f, prefix.clone(), false, false)?;
</a><a href="#h5-10-16" id="h5-10-16" class="d">-                right.format(f, prefix, false, true)?;
</a><a href="#h5-10-17" id="h5-10-17" class="d">-            }
</a><a href="#h5-10-18" id="h5-10-18" class="d">-            Self::Nothing { .. } =&gt; {
</a><a href="#h5-10-19" id="h5-10-19" class="d">-                write!(f, &quot;Nothing&quot;)?;
</a><a href="#h5-10-20" id="h5-10-20" class="i">+                left.format(f, &amp;prefix, false, false)?;
</a><a href="#h5-10-21" id="h5-10-21" class="i">+                right.format(f, &amp;prefix, false, true)?;
</a>             }
<a href="#h5-10-23" id="h5-10-23" class="i">+            Self::Nothing { .. } =&gt; write!(f, &quot;Nothing&quot;)?,
</a>             Self::Offset { source, offset } =&gt; {
                 write!(f, &quot;Offset: {offset}&quot;)?;
<a href="#h5-10-26" id="h5-10-26" class="d">-                source.format(f, prefix, false, true)?;
</a><a href="#h5-10-27" id="h5-10-27" class="i">+                source.format(f, &amp;prefix, false, true)?;
</a>             }
<a href="#h5-10-29" id="h5-10-29" class="d">-            Self::Order { source, orders } =&gt; {
</a><a href="#h5-10-30" id="h5-10-30" class="i">+            Self::Order { source, key: orders } =&gt; {
</a>                 let orders = orders
                     .iter()
                     .map(|(expr, dir)| format!(&quot;{} {dir}&quot;, expr.format(source)))
                     .join(&quot;, &quot;);
                 write!(f, &quot;Order: {orders}&quot;)?;
<a href="#h5-10-36" id="h5-10-36" class="d">-                source.format(f, prefix, false, true)?;
</a><a href="#h5-10-37" id="h5-10-37" class="i">+                source.format(f, &amp;prefix, false, true)?;
</a>             }
             Self::Projection { source, expressions, aliases } =&gt; {
                 let expressions = expressions
<a href="#h5-11" id="h5-11" class="h">@@ -478,17 +541,17 @@ impl Node {
</a>                     })
                     .join(&quot;, &quot;);
                 write!(f, &quot;Projection: {expressions}&quot;)?;
<a href="#h5-11-3" id="h5-11-3" class="d">-                source.format(f, prefix, false, true)?;
</a><a href="#h5-11-4" id="h5-11-4" class="i">+                source.format(f, &amp;prefix, false, true)?;
</a>             }
             Self::Remap { source, targets } =&gt; {
                 let remap = remap_sources(targets)
                     .into_iter()
<a href="#h5-11-9" id="h5-11-9" class="d">-                    .map(|from| {
</a><a href="#h5-11-10" id="h5-11-10" class="d">-                        from.map(|from| match source.column_label(from) {
</a><a href="#h5-11-11" id="h5-11-11" class="i">+                    .map(|from| match from {
</a><a href="#h5-11-12" id="h5-11-12" class="i">+                        Some(from) =&gt; match source.column_label(from) {
</a>                             Label::None =&gt; format!(&quot;#{from}&quot;),
<a href="#h5-11-14" id="h5-11-14" class="d">-                            label =&gt; format!(&quot;{label}&quot;),
</a><a href="#h5-11-15" id="h5-11-15" class="d">-                        })
</a><a href="#h5-11-16" id="h5-11-16" class="d">-                        .unwrap_or(&quot;Null&quot;.to_string())
</a><a href="#h5-11-17" id="h5-11-17" class="i">+                            label =&gt; label.to_string(),
</a><a href="#h5-11-18" id="h5-11-18" class="i">+                        },
</a><a href="#h5-11-19" id="h5-11-19" class="i">+                        None =&gt; &quot;Null&quot;.to_string(),
</a>                     })
                     .join(&quot;, &quot;);
                 write!(f, &quot;Remap: {remap}&quot;)?;
<a href="#h5-12" id="h5-12" class="h">@@ -505,15 +568,15 @@ impl Node {
</a>                 if !dropped.is_empty() {
                     write!(f, &quot; (dropped: {dropped})&quot;)?;
                 }
<a href="#h5-12-3" id="h5-12-3" class="d">-                source.format(f, prefix, false, true)?;
</a><a href="#h5-12-4" id="h5-12-4" class="i">+                source.format(f, &amp;prefix, false, true)?;
</a>             }
             Self::Scan { table, alias, filter } =&gt; {
                 write!(f, &quot;Scan: {}&quot;, table.name)?;
                 if let Some(alias) = alias {
                     write!(f, &quot; as {alias}&quot;)?;
                 }
<a href="#h5-12-11" id="h5-12-11" class="d">-                if let Some(expr) = filter {
</a><a href="#h5-12-12" id="h5-12-12" class="d">-                    write!(f, &quot; ({})&quot;, expr.format(self))?;
</a><a href="#h5-12-13" id="h5-12-13" class="i">+                if let Some(filter) = filter {
</a><a href="#h5-12-14" id="h5-12-14" class="i">+                    write!(f, &quot; ({})&quot;, filter.format(self))?;
</a>                 }
             }
             Self::Values { rows, .. } =&gt; {
<a href="#h5-13" id="h5-13" class="h">@@ -529,53 +592,6 @@ impl Node {
</a>     }
 }
 
<a href="#h5-13-3" id="h5-13-3" class="d">-/// An aggregate function.
</a><a href="#h5-13-4" id="h5-13-4" class="d">-#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h5-13-5" id="h5-13-5" class="d">-pub enum Aggregate {
</a><a href="#h5-13-6" id="h5-13-6" class="d">-    Average(Expression),
</a><a href="#h5-13-7" id="h5-13-7" class="d">-    Count(Expression),
</a><a href="#h5-13-8" id="h5-13-8" class="d">-    Max(Expression),
</a><a href="#h5-13-9" id="h5-13-9" class="d">-    Min(Expression),
</a><a href="#h5-13-10" id="h5-13-10" class="d">-    Sum(Expression),
</a><a href="#h5-13-11" id="h5-13-11" class="d">-}
</a><a href="#h5-13-12" id="h5-13-12" class="d">-
</a><a href="#h5-13-13" id="h5-13-13" class="d">-impl Aggregate {
</a><a href="#h5-13-14" id="h5-13-14" class="d">-    fn format(&amp;self, node: &amp;Node) -&gt; String {
</a><a href="#h5-13-15" id="h5-13-15" class="d">-        match self {
</a><a href="#h5-13-16" id="h5-13-16" class="d">-            Self::Average(expr) =&gt; format!(&quot;avg({})&quot;, expr.format(node)),
</a><a href="#h5-13-17" id="h5-13-17" class="d">-            Self::Count(expr) =&gt; format!(&quot;count({})&quot;, expr.format(node)),
</a><a href="#h5-13-18" id="h5-13-18" class="d">-            Self::Max(expr) =&gt; format!(&quot;max({})&quot;, expr.format(node)),
</a><a href="#h5-13-19" id="h5-13-19" class="d">-            Self::Min(expr) =&gt; format!(&quot;min({})&quot;, expr.format(node)),
</a><a href="#h5-13-20" id="h5-13-20" class="d">-            Self::Sum(expr) =&gt; format!(&quot;sum({})&quot;, expr.format(node)),
</a><a href="#h5-13-21" id="h5-13-21" class="d">-        }
</a><a href="#h5-13-22" id="h5-13-22" class="d">-    }
</a><a href="#h5-13-23" id="h5-13-23" class="d">-}
</a><a href="#h5-13-24" id="h5-13-24" class="d">-
</a><a href="#h5-13-25" id="h5-13-25" class="d">-/// A sort order direction.
</a><a href="#h5-13-26" id="h5-13-26" class="d">-#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h5-13-27" id="h5-13-27" class="d">-pub enum Direction {
</a><a href="#h5-13-28" id="h5-13-28" class="d">-    Ascending,
</a><a href="#h5-13-29" id="h5-13-29" class="d">-    Descending,
</a><a href="#h5-13-30" id="h5-13-30" class="d">-}
</a><a href="#h5-13-31" id="h5-13-31" class="d">-
</a><a href="#h5-13-32" id="h5-13-32" class="d">-impl std::fmt::Display for Direction {
</a><a href="#h5-13-33" id="h5-13-33" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h5-13-34" id="h5-13-34" class="d">-        match self {
</a><a href="#h5-13-35" id="h5-13-35" class="d">-            Self::Ascending =&gt; write!(f, &quot;asc&quot;),
</a><a href="#h5-13-36" id="h5-13-36" class="d">-            Self::Descending =&gt; write!(f, &quot;desc&quot;),
</a><a href="#h5-13-37" id="h5-13-37" class="d">-        }
</a><a href="#h5-13-38" id="h5-13-38" class="d">-    }
</a><a href="#h5-13-39" id="h5-13-39" class="d">-}
</a><a href="#h5-13-40" id="h5-13-40" class="d">-
</a><a href="#h5-13-41" id="h5-13-41" class="d">-impl From&lt;ast::Order&gt; for Direction {
</a><a href="#h5-13-42" id="h5-13-42" class="d">-    fn from(order: ast::Order) -&gt; Self {
</a><a href="#h5-13-43" id="h5-13-43" class="d">-        match order {
</a><a href="#h5-13-44" id="h5-13-44" class="d">-            ast::Order::Ascending =&gt; Self::Ascending,
</a><a href="#h5-13-45" id="h5-13-45" class="d">-            ast::Order::Descending =&gt; Self::Descending,
</a><a href="#h5-13-46" id="h5-13-46" class="d">-        }
</a><a href="#h5-13-47" id="h5-13-47" class="d">-    }
</a><a href="#h5-13-48" id="h5-13-48" class="d">-}
</a><a href="#h5-13-49" id="h5-13-49" class="d">-
</a> /// Inverts a Remap targets vector to a vector of source indexes, with None
 /// for columns that weren&#39;t targeted.
 pub fn remap_sources(targets: &amp;[Option&lt;usize&gt;]) -&gt; Vec&lt;Option&lt;usize&gt;&gt; {
<b>diff --git a/<a id="h6" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,7 +1,6 @@
</a> #![allow(clippy::module_inception)]
 
<a href="#h6-0-2" id="h6-0-2" class="d">-use super::plan::remap_sources;
</a><a href="#h6-0-3" id="h6-0-3" class="d">-use super::{Aggregate, Direction, Node, Plan};
</a><a href="#h6-0-4" id="h6-0-4" class="i">+use super::plan::{remap_sources, Aggregate, Node, Plan};
</a> use crate::errinput;
 use crate::error::Result;
 use crate::sql::engine::Catalog;
<a href="#h6-1" id="h6-1" class="h">@@ -11,8 +10,8 @@ use crate::sql::types::{Column, Expression, Label, Table, Value};
</a> use itertools::Itertools as _;
 use std::collections::{BTreeMap, HashMap, HashSet};
 
<a href="#h6-1-3" id="h6-1-3" class="d">-/// A statement plan builder. Takes a statement AST from the parser and builds
</a><a href="#h6-1-4" id="h6-1-4" class="d">-/// an execution plan for it, using the catalog for schema information.
</a><a href="#h6-1-5" id="h6-1-5" class="i">+/// The planner builds an execution plan from a parsed Abstract Syntax Tree,
</a><a href="#h6-1-6" id="h6-1-6" class="i">+/// using the catalog for schema information.
</a> pub struct Planner&lt;&#39;a, C: Catalog&gt; {
     catalog: &amp;&#39;a C,
 }
<a href="#h6-2" id="h6-2" class="h">@@ -45,6 +44,9 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a> 
     /// Builds a CREATE TABLE plan.
     fn build_create_table(&amp;self, name: String, columns: Vec&lt;ast::Column&gt;) -&gt; Result&lt;Plan&gt; {
<a href="#h6-2-3" id="h6-2-3" class="i">+        // Most schema validation happens during execution via Table.validate().
</a><a href="#h6-2-4" id="h6-2-4" class="i">+        // However, the AST specifies the primary key as a column field, while
</a><a href="#h6-2-5" id="h6-2-5" class="i">+        // the schema stores it as a column index, so we have to map that here.
</a>         let Some(primary_key) = columns.iter().position(|c| c.primary_key) else {
             return errinput!(&quot;no primary key for table {name}&quot;);
         };
<a href="#h6-3" id="h6-3" class="h">@@ -77,7 +79,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     fn build_delete(&amp;self, table: String, r#where: Option&lt;ast::Expression&gt;) -&gt; Result&lt;Plan&gt; {
         let table = self.catalog.must_get_table(&amp;table)?;
         let scope = Scope::from_table(&amp;table)?;
<a href="#h6-3-3" id="h6-3-3" class="d">-        let filter = r#where.map(|e| Self::build_expression(e, &amp;scope)).transpose()?;
</a><a href="#h6-3-4" id="h6-3-4" class="i">+        let filter = r#where.map(|expr| Self::build_expression(expr, &amp;scope)).transpose()?;
</a>         Ok(Plan::Delete {
             table: table.name.clone(),
             primary_key: table.primary_key,
<a href="#h6-4" id="h6-4" class="h">@@ -124,7 +126,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     ) -&gt; Result&lt;Plan&gt; {
         let table = self.catalog.must_get_table(&amp;table)?;
         let scope = Scope::from_table(&amp;table)?;
<a href="#h6-4-3" id="h6-4-3" class="d">-        let filter = r#where.map(|e| Self::build_expression(e, &amp;scope)).transpose()?;
</a><a href="#h6-4-4" id="h6-4-4" class="i">+        let filter = r#where.map(|expr| Self::build_expression(expr, &amp;scope)).transpose()?;
</a>         let mut expressions = Vec::with_capacity(set.len());
         for (column, expr) in set {
             let index = scope.lookup_column(None, &amp;column)?;
<a href="#h6-5" id="h6-5" class="h">@@ -154,7 +156,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         r#where: Option&lt;ast::Expression&gt;,
         group_by: Vec&lt;ast::Expression&gt;,
         having: Option&lt;ast::Expression&gt;,
<a href="#h6-5-3" id="h6-5-3" class="d">-        order_by: Vec&lt;(ast::Expression, ast::Order)&gt;,
</a><a href="#h6-5-4" id="h6-5-4" class="i">+        order_by: Vec&lt;(ast::Expression, ast::Direction)&gt;,
</a>         offset: Option&lt;ast::Expression&gt;,
         limit: Option&lt;ast::Expression&gt;,
     ) -&gt; Result&lt;Plan&gt; {
<a href="#h6-6" id="h6-6" class="h">@@ -162,7 +164,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a> 
         // Build FROM clause.
         let mut node = if !from.is_empty() {
<a href="#h6-6-3" id="h6-6-3" class="d">-            self.build_from_clause(&amp;mut scope, from)?
</a><a href="#h6-6-4" id="h6-6-4" class="i">+            self.build_from_clause(from, &amp;mut scope)?
</a>         } else {
             // For a constant SELECT, emit a single empty row to project with.
             // This allows using aggregate functions and WHERE as normal.
<a href="#h6-7" id="h6-7" class="h">@@ -174,7 +176,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         // BY). For simplicity, expressions only supports scalar values, so we
         // special-case the * tuple here.
         if select.contains(&amp;(ast::Expression::All, None)) {
<a href="#h6-7-3" id="h6-7-3" class="d">-            if node.size() == 0 {
</a><a href="#h6-7-4" id="h6-7-4" class="i">+            if node.columns() == 0 {
</a>                 return errinput!(&quot;SELECT * requires a FROM clause&quot;);
             }
             if select.len() &gt; 1 || !group_by.is_empty() {
<a href="#h6-8" id="h6-8" class="h">@@ -182,7 +184,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                     .into_iter()
                     .flat_map(|(expr, alias)| match expr {
                         ast::Expression::All =&gt; itertools::Either::Left(
<a href="#h6-8-3" id="h6-8-3" class="d">-                            (0..node.size()).map(|i| (node.column_label(i).into(), None)),
</a><a href="#h6-8-4" id="h6-8-4" class="i">+                            (0..node.columns()).map(|i| (node.column_label(i).into(), None)),
</a>                         ),
                         expr =&gt; itertools::Either::Right(std::iter::once((expr, alias))),
                     })
<a href="#h6-9" id="h6-9" class="h">@@ -191,15 +193,15 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         }
 
         // Build WHERE clause.
<a href="#h6-9-3" id="h6-9-3" class="d">-        if let Some(expr) = r#where {
</a><a href="#h6-9-4" id="h6-9-4" class="d">-            let predicate = Self::build_expression(expr, &amp;scope)?;
</a><a href="#h6-9-5" id="h6-9-5" class="i">+        if let Some(r#where) = r#where {
</a><a href="#h6-9-6" id="h6-9-6" class="i">+            let predicate = Self::build_expression(r#where, &amp;scope)?;
</a>             node = Node::Filter { source: Box::new(node), predicate };
<a href="#h6-9-8" id="h6-9-8" class="d">-        };
</a><a href="#h6-9-9" id="h6-9-9" class="i">+        }
</a> 
         // Build aggregate functions and GROUP BY clause.
         let aggregates = Self::collect_aggregates(&amp;select, &amp;having, &amp;order_by);
         if !group_by.is_empty() || !aggregates.is_empty() {
<a href="#h6-9-14" id="h6-9-14" class="d">-            node = self.build_aggregate(&amp;mut scope, node, group_by, aggregates)?;
</a><a href="#h6-9-15" id="h6-9-15" class="i">+            node = self.build_aggregate(node, group_by, aggregates, &amp;mut scope)?;
</a>         }
 
         // Build SELECT clause. We can omit this for a trivial SELECT *.
<a href="#h6-10" id="h6-10" class="h">@@ -216,7 +218,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             }
 
             // Add hidden columns for HAVING and ORDER BY columns not in SELECT.
<a href="#h6-10-3" id="h6-10-3" class="d">-            let hidden = self.build_select_hidden(&amp;scope, &amp;mut child_scope, &amp;having, &amp;order_by);
</a><a href="#h6-10-4" id="h6-10-4" class="i">+            let hidden = self.build_select_hidden(&amp;having, &amp;order_by, &amp;scope, &amp;mut child_scope);
</a>             aliases.extend(std::iter::repeat(Label::None).take(hidden.len()));
             expressions.extend(hidden);
 
<a href="#h6-11" id="h6-11" class="h">@@ -231,32 +233,32 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             }
             let predicate = Self::build_expression(having, &amp;scope)?;
             node = Node::Filter { source: Box::new(node), predicate };
<a href="#h6-11-3" id="h6-11-3" class="d">-        };
</a><a href="#h6-11-4" id="h6-11-4" class="i">+        }
</a> 
         // Build ORDER BY clause.
         if !order_by.is_empty() {
<a href="#h6-11-8" id="h6-11-8" class="d">-            let orders = order_by
</a><a href="#h6-11-9" id="h6-11-9" class="i">+            let key = order_by
</a>                 .into_iter()
<a href="#h6-11-11" id="h6-11-11" class="d">-                .map(|(e, o)| Ok((Self::build_expression(e, &amp;scope)?, Direction::from(o))))
</a><a href="#h6-11-12" id="h6-11-12" class="i">+                .map(|(expr, dir)| Ok((Self::build_expression(expr, &amp;scope)?, dir.into())))
</a>                 .collect::&lt;Result&lt;_&gt;&gt;()?;
<a href="#h6-11-14" id="h6-11-14" class="d">-            node = Node::Order { source: Box::new(node), orders };
</a><a href="#h6-11-15" id="h6-11-15" class="i">+            node = Node::Order { source: Box::new(node), key };
</a>         }
 
         // Build OFFSET clause.
<a href="#h6-11-19" id="h6-11-19" class="d">-        if let Some(expr) = offset {
</a><a href="#h6-11-20" id="h6-11-20" class="d">-            let offset = match Self::evaluate_constant(expr)? {
</a><a href="#h6-11-21" id="h6-11-21" class="d">-                Value::Integer(offset) if offset &gt;= 0 =&gt; Ok(offset as usize),
</a><a href="#h6-11-22" id="h6-11-22" class="d">-                value =&gt; errinput!(&quot;invalid offset {value}&quot;),
</a><a href="#h6-11-23" id="h6-11-23" class="d">-            }?;
</a><a href="#h6-11-24" id="h6-11-24" class="i">+        if let Some(offset) = offset {
</a><a href="#h6-11-25" id="h6-11-25" class="i">+            let offset = match Self::evaluate_constant(offset)? {
</a><a href="#h6-11-26" id="h6-11-26" class="i">+                Value::Integer(offset) if offset &gt;= 0 =&gt; offset as usize,
</a><a href="#h6-11-27" id="h6-11-27" class="i">+                offset =&gt; return errinput!(&quot;invalid offset {offset}&quot;),
</a><a href="#h6-11-28" id="h6-11-28" class="i">+            };
</a>             node = Node::Offset { source: Box::new(node), offset }
         }
 
         // Build LIMIT clause.
<a href="#h6-11-33" id="h6-11-33" class="d">-        if let Some(expr) = limit {
</a><a href="#h6-11-34" id="h6-11-34" class="d">-            let limit = match Self::evaluate_constant(expr)? {
</a><a href="#h6-11-35" id="h6-11-35" class="d">-                Value::Integer(limit) if limit &gt;= 0 =&gt; Ok(limit as usize),
</a><a href="#h6-11-36" id="h6-11-36" class="d">-                value =&gt; errinput!(&quot;invalid limit {value}&quot;),
</a><a href="#h6-11-37" id="h6-11-37" class="d">-            }?;
</a><a href="#h6-11-38" id="h6-11-38" class="i">+        if let Some(limit) = limit {
</a><a href="#h6-11-39" id="h6-11-39" class="i">+            let limit = match Self::evaluate_constant(limit)? {
</a><a href="#h6-11-40" id="h6-11-40" class="i">+                Value::Integer(limit) if limit &gt;= 0 =&gt; limit as usize,
</a><a href="#h6-11-41" id="h6-11-41" class="i">+                limit =&gt; return errinput!(&quot;invalid limit {limit}&quot;),
</a><a href="#h6-11-42" id="h6-11-42" class="i">+            };
</a>             node = Node::Limit { source: Box::new(node), limit }
         }
 
<a href="#h6-12" id="h6-12" class="h">@@ -271,7 +273,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     /// Builds a FROM clause consisting of one or more items. Each item is
     /// either a table or a join of two or more tables. All items are implicitly
     /// joined, e.g. &quot;SELECT * FROM a, b&quot; is an implicit full join of a and b.
<a href="#h6-12-3" id="h6-12-3" class="d">-    fn build_from_clause(&amp;self, scope: &amp;mut Scope, from: Vec&lt;ast::From&gt;) -&gt; Result&lt;Node&gt; {
</a><a href="#h6-12-4" id="h6-12-4" class="i">+    fn build_from_clause(&amp;self, from: Vec&lt;ast::From&gt;, scope: &amp;mut Scope) -&gt; Result&lt;Node&gt; {
</a>         // Build the first FROM item. A FROM clause must have at least one.
         let mut items = from.into_iter();
         let mut node = match items.next() {
<a href="#h6-13" id="h6-13" class="h">@@ -303,21 +305,21 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             // A full table scan.
             ast::From::Table { name, alias } =&gt; {
                 let table = self.catalog.must_get_table(&amp;name)?;
<a href="#h6-13-3" id="h6-13-3" class="d">-                scope.add_table(alias.as_ref().unwrap_or(&amp;name), &amp;table)?;
</a><a href="#h6-13-4" id="h6-13-4" class="i">+                scope.add_table(&amp;table, alias.as_deref())?;
</a>                 Node::Scan { table, alias, filter: None }
             }
 
             // A two-way join. The left or right nodes may be chained joins.
             ast::From::Join { mut left, mut right, r#type, predicate } =&gt; {
                 // Right joins are built as a left join then column swap.
<a href="#h6-13-11" id="h6-13-11" class="d">-                if matches!(r#type, ast::JoinType::Right) {
</a><a href="#h6-13-12" id="h6-13-12" class="i">+                if r#type == ast::JoinType::Right {
</a>                     (left, right) = (right, left)
                 }
 
                 // Build the left and right nodes.
                 let left = Box::new(self.build_from(*left, &amp;mut scope)?);
                 let right = Box::new(self.build_from(*right, &amp;mut scope)?);
<a href="#h6-13-19" id="h6-13-19" class="d">-                let (left_size, right_size) = (left.size(), right.size());
</a><a href="#h6-13-20" id="h6-13-20" class="i">+                let (left_size, right_size) = (left.columns(), right.columns());
</a> 
                 // Build the join node.
                 let predicate = predicate.map(|e| Self::build_expression(e, &amp;scope)).transpose()?;
<a href="#h6-14" id="h6-14" class="h">@@ -325,7 +327,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 let mut node = Node::NestedLoopJoin { left, right, predicate, outer };
 
                 // For right joins, swap the columns.
<a href="#h6-14-3" id="h6-14-3" class="d">-                if matches!(r#type, ast::JoinType::Right) {
</a><a href="#h6-14-4" id="h6-14-4" class="i">+                if r#type == ast::JoinType::Right {
</a>                     let size = left_size + right_size;
                     let targets = (0..size).map(|i| Some((i + right_size) % size)).collect_vec();
                     scope = scope.remap(&amp;targets);
<a href="#h6-15" id="h6-15" class="h">@@ -355,10 +357,10 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     /// division, and HAVING can look up b % 10 to compute the predicate.
     fn build_aggregate(
         &amp;self,
<a href="#h6-15-3" id="h6-15-3" class="d">-        scope: &amp;mut Scope,
</a>         source: Node,
         mut group_by: Vec&lt;ast::Expression&gt;,
         mut aggregates: Vec&lt;ast::Expression&gt;,
<a href="#h6-15-7" id="h6-15-7" class="i">+        scope: &amp;mut Scope,
</a>     ) -&gt; Result&lt;Node&gt; {
         // Construct a child scope with the group_by and aggregate AST
         // expressions, for lookups. Discard duplicate expressions.
<a href="#h6-16" id="h6-16" class="h">@@ -373,7 +375,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             .collect::&lt;Result&lt;_&gt;&gt;()?;
         let aggregates = aggregates
             .into_iter()
<a href="#h6-16-3" id="h6-16-3" class="d">-            .map(|expr| Self::build_aggregate_function(scope, expr))
</a><a href="#h6-16-4" id="h6-16-4" class="i">+            .map(|expr| Self::build_aggregate_function(expr, scope))
</a>             .collect::&lt;Result&lt;_&gt;&gt;()?;
 
         *scope = child_scope;
<a href="#h6-17" id="h6-17" class="h">@@ -381,7 +383,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     }
 
     /// Builds an aggregate function from an AST expression.
<a href="#h6-17-3" id="h6-17-3" class="d">-    fn build_aggregate_function(scope: &amp;Scope, expr: ast::Expression) -&gt; Result&lt;Aggregate&gt; {
</a><a href="#h6-17-4" id="h6-17-4" class="i">+    fn build_aggregate_function(expr: ast::Expression, scope: &amp;Scope) -&gt; Result&lt;Aggregate&gt; {
</a>         let ast::Expression::Function(name, mut args) = expr else {
             panic!(&quot;aggregate expression must be function&quot;);
         };
<a href="#h6-18" id="h6-18" class="h">@@ -392,10 +394,9 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             return errinput!(&quot;aggregate functions can&#39;t be nested&quot;);
         }
         // Special-case COUNT(*) since expressions don&#39;t support tuples.
<a href="#h6-18-3" id="h6-18-3" class="d">-        let expr = if name.as_str() == &quot;count&quot; &amp;&amp; args[0] == ast::Expression::All {
</a><a href="#h6-18-4" id="h6-18-4" class="d">-            Expression::Constant(Value::Boolean(true))
</a><a href="#h6-18-5" id="h6-18-5" class="d">-        } else {
</a><a href="#h6-18-6" id="h6-18-6" class="d">-            Self::build_expression(args.remove(0), scope)?
</a><a href="#h6-18-7" id="h6-18-7" class="i">+        let expr = match (name.as_str(), args.remove(0)) {
</a><a href="#h6-18-8" id="h6-18-8" class="i">+            (&quot;count&quot;, ast::Expression::All) =&gt; Expression::Constant(Value::Boolean(true)),
</a><a href="#h6-18-9" id="h6-18-9" class="i">+            (_, arg) =&gt; Self::build_expression(arg, scope)?,
</a>         };
         Ok(match name.as_str() {
             &quot;avg&quot; =&gt; Aggregate::Average(expr),
<a href="#h6-19" id="h6-19" class="h">@@ -419,14 +420,14 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     fn collect_aggregates(
         select: &amp;[(ast::Expression, Option&lt;String&gt;)],
         having: &amp;Option&lt;ast::Expression&gt;,
<a href="#h6-19-3" id="h6-19-3" class="d">-        order_by: &amp;[(ast::Expression, ast::Order)],
</a><a href="#h6-19-4" id="h6-19-4" class="i">+        order_by: &amp;[(ast::Expression, ast::Direction)],
</a>     ) -&gt; Vec&lt;ast::Expression&gt; {
         let select = select.iter().map(|(expr, _)| expr);
         let having = having.iter();
         let order_by = order_by.iter().map(|(expr, _)| expr);
         let mut aggregates = Vec::new();
         for expr in select.chain(having).chain(order_by) {
<a href="#h6-19-11" id="h6-19-11" class="d">-            expr.collect(&amp;|e| Self::is_aggregate_function(e), &amp;mut aggregates)
</a><a href="#h6-19-12" id="h6-19-12" class="i">+            expr.collect(&amp;|expr| Self::is_aggregate_function(expr), &amp;mut aggregates)
</a>         }
         aggregates
     }
<a href="#h6-20" id="h6-20" class="h">@@ -441,19 +442,20 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     /// isn&#39;t available to the ORDER BY node. We add a hidden &quot;value&quot; column to
     /// the projection to satisfy the ORDER BY.
     ///
<a href="#h6-20-3" id="h6-20-3" class="d">-    /// Hidden columns are stripped before returning the result to the client.
</a><a href="#h6-20-4" id="h6-20-4" class="i">+    /// Hidden columns are tracked in the scope and stripped before the result
</a><a href="#h6-20-5" id="h6-20-5" class="i">+    /// is returned to the client.
</a>     fn build_select_hidden(
         &amp;self,
<a href="#h6-20-8" id="h6-20-8" class="i">+        having: &amp;Option&lt;ast::Expression&gt;,
</a><a href="#h6-20-9" id="h6-20-9" class="i">+        order_by: &amp;[(ast::Expression, ast::Direction)],
</a>         scope: &amp;Scope,
         child_scope: &amp;mut Scope,
<a href="#h6-20-12" id="h6-20-12" class="d">-        having: &amp;Option&lt;ast::Expression&gt;,
</a><a href="#h6-20-13" id="h6-20-13" class="d">-        order_by: &amp;[(ast::Expression, ast::Order)],
</a>     ) -&gt; Vec&lt;Expression&gt; {
         let mut hidden = Vec::new();
         for expr in having.iter().chain(order_by.iter().map(|(expr, _)| expr)) {
             expr.walk(&amp;mut |expr| {
                 // If this is an aggregate or GROUP BY expression that isn&#39;t
<a href="#h6-20-19" id="h6-20-19" class="d">-                // already available in the child scope, pass it through.
</a><a href="#h6-20-20" id="h6-20-20" class="i">+                // already available in the child scope, add a hidden column.
</a>                 if let Some(index) = scope.lookup_aggregate(expr) {
                     if child_scope.lookup_aggregate(expr).is_none() {
                         child_scope.add_passthrough(scope, index, true);
<a href="#h6-21" id="h6-21" class="h">@@ -462,19 +464,19 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                     }
                 }
 
<a href="#h6-21-3" id="h6-21-3" class="d">-                // Look for column references that don&#39;t exist post-projection.
</a><a href="#h6-21-4" id="h6-21-4" class="i">+                // Look for column references that don&#39;t exist post-projection,
</a><a href="#h6-21-5" id="h6-21-5" class="i">+                // but that do exist in the parent, and add hidden columns.
</a>                 let ast::Expression::Column(table, column) = expr else {
                     return true;
                 };
                 if child_scope.lookup_column(table.as_deref(), column).is_ok() {
                     return true;
                 }
<a href="#h6-21-12" id="h6-21-12" class="d">-                // If the parent lookup fails too, ignore the error. It will be
</a><a href="#h6-21-13" id="h6-21-13" class="d">-                // surfaced during expression building.
</a>                 let Ok(index) = scope.lookup_column(table.as_deref(), column) else {
<a href="#h6-21-15" id="h6-21-15" class="i">+                    // If the parent lookup fails too (i.e. unknown column),
</a><a href="#h6-21-16" id="h6-21-16" class="i">+                    // ignore the error. It will be surfaced during building.
</a>                     return true;
                 };
<a href="#h6-21-19" id="h6-21-19" class="d">-                // Add the hidden column to the projection.
</a>                 child_scope.add_passthrough(scope, index, true);
                 hidden.push(Expression::Column(index));
                 true
<a href="#h6-22" id="h6-22" class="h">@@ -483,12 +485,13 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         hidden
     }
 
<a href="#h6-22-3" id="h6-22-3" class="d">-    /// Builds an expression from an AST expression.
</a><a href="#h6-22-4" id="h6-22-4" class="i">+    /// Builds an expression from an AST expression, looking up columns and
</a><a href="#h6-22-5" id="h6-22-5" class="i">+    /// aggregate expressions in the scope.
</a>     pub fn build_expression(expr: ast::Expression, scope: &amp;Scope) -&gt; Result&lt;Expression&gt; {
         use Expression::*;
 
         // Look up aggregate functions or GROUP BY expressions. These were added
<a href="#h6-22-10" id="h6-22-10" class="d">-        // to the parent scope when building the Aggregate node, if any.
</a><a href="#h6-22-11" id="h6-22-11" class="i">+        // to the scope when building the Aggregate node, if any.
</a>         if let Some(index) = scope.lookup_aggregate(&amp;expr) {
             return Ok(Column(index));
         }
<a href="#h6-23" id="h6-23" class="h">@@ -559,7 +562,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         })
     }
 
<a href="#h6-23-3" id="h6-23-3" class="d">-    /// Builds and evaluates a constant AST expression.
</a><a href="#h6-23-4" id="h6-23-4" class="i">+    /// Builds and evaluates a constant AST expression. Errors on column refs.
</a>     fn evaluate_constant(expr: ast::Expression) -&gt; Result&lt;Value&gt; {
         Self::build_expression(expr, &amp;Scope::new())?.evaluate(None)
     }
<a href="#h6-24" id="h6-24" class="h">@@ -614,7 +617,7 @@ impl Scope {
</a>     /// Creates a scope from a table, using the table&#39;s original name.
     fn from_table(table: &amp;Table) -&gt; Result&lt;Self&gt; {
         let mut scope = Self::new();
<a href="#h6-24-3" id="h6-24-3" class="d">-        scope.add_table(&amp;table.name, table)?;
</a><a href="#h6-24-4" id="h6-24-4" class="i">+        scope.add_table(table, None)?;
</a>         Ok(scope)
     }
 
<a href="#h6-25" id="h6-25" class="h">@@ -627,18 +630,20 @@ impl Scope {
</a> 
     /// Adds a table to the scope. The label is either the table&#39;s original name
     /// or an alias, and must be unique. All table columns are added, in order.
<a href="#h6-25-3" id="h6-25-3" class="d">-    fn add_table(&amp;mut self, label: &amp;str, table: &amp;Table) -&gt; Result&lt;()&gt; {
</a><a href="#h6-25-4" id="h6-25-4" class="d">-        if self.tables.contains(label) {
</a><a href="#h6-25-5" id="h6-25-5" class="d">-            return errinput!(&quot;duplicate table name {label}&quot;);
</a><a href="#h6-25-6" id="h6-25-6" class="i">+    fn add_table(&amp;mut self, table: &amp;Table, alias: Option&lt;&amp;str&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h6-25-7" id="h6-25-7" class="i">+        let name = alias.unwrap_or(&amp;table.name);
</a><a href="#h6-25-8" id="h6-25-8" class="i">+        if self.tables.contains(name) {
</a><a href="#h6-25-9" id="h6-25-9" class="i">+            return errinput!(&quot;duplicate table name {name}&quot;);
</a>         }
         for column in &amp;table.columns {
<a href="#h6-25-12" id="h6-25-12" class="d">-            self.add_column(Label::Qualified(label.to_string(), column.name.clone()));
</a><a href="#h6-25-13" id="h6-25-13" class="i">+            self.add_column(Label::Qualified(name.to_string(), column.name.clone()));
</a>         }
<a href="#h6-25-15" id="h6-25-15" class="d">-        self.tables.insert(label.to_string());
</a><a href="#h6-25-16" id="h6-25-16" class="i">+        self.tables.insert(name.to_string());
</a>         Ok(())
     }
 
<a href="#h6-25-20" id="h6-25-20" class="d">-    /// Adds a column and label to the scope. Returns the column index.
</a><a href="#h6-25-21" id="h6-25-21" class="i">+    /// Appends a column with the given label to the scope. Returns the column
</a><a href="#h6-25-22" id="h6-25-22" class="i">+    /// index.
</a>     fn add_column(&amp;mut self, label: Label) -&gt; usize {
         let index = self.columns.len();
         if let Label::Qualified(table, column) = &amp;label {
<a href="#h6-26" id="h6-26" class="h">@@ -681,13 +686,12 @@ impl Scope {
</a> 
     /// Adds an aggregate expression to the scope, returning the new column
     /// index or None if the expression already exists. This is either an
<a href="#h6-26-3" id="h6-26-3" class="d">-    /// aggregate function or a GROUP BY expression. It is used to look up the
</a><a href="#h6-26-4" id="h6-26-4" class="i">+    /// aggregate function or a GROUP BY expression, used to look up the
</a>     /// aggregate output column from e.g. SELECT, HAVING, and ORDER BY.
     fn add_aggregate(&amp;mut self, expr: &amp;ast::Expression, parent: &amp;Scope) -&gt; Option&lt;usize&gt; {
         if self.aggregates.contains_key(expr) {
             return None;
         }
<a href="#h6-26-10" id="h6-26-10" class="d">-
</a>         // If this is a simple column reference (i.e. GROUP BY foo), pass
         // through the column label from the parent scope for lookups.
         let mut label = Label::None;
<a href="#h6-27" id="h6-27" class="h">@@ -697,7 +701,6 @@ impl Scope {
</a>                 label = parent.columns[index].clone();
             }
         }
<a href="#h6-27-3" id="h6-27-3" class="d">-
</a>         let index = self.add_column(label);
         self.aggregates.insert(expr.clone(), index);
         Some(index)
<a href="#h6-28" id="h6-28" class="h">@@ -712,8 +715,7 @@ impl Scope {
</a>     /// Adds a column that passes through a column from the parent scope,
     /// retaining its properties. If hide is true, the column is hidden.
     fn add_passthrough(&amp;mut self, parent: &amp;Scope, parent_index: usize, hide: bool) -&gt; usize {
<a href="#h6-28-3" id="h6-28-3" class="d">-        let label = parent.columns[parent_index].clone();
</a><a href="#h6-28-4" id="h6-28-4" class="d">-        let index = self.add_column(label);
</a><a href="#h6-28-5" id="h6-28-5" class="i">+        let index = self.add_column(parent.columns[parent_index].clone());
</a>         for (expr, i) in &amp;parent.aggregates {
             if *i == parent_index {
                 self.aggregates.entry(expr.clone()).or_insert(index);
<a href="#h6-29" id="h6-29" class="h">@@ -758,16 +760,15 @@ impl Scope {
</a>             if let Some(alias) = alias {
                 label = Label::Unqualified(alias.clone());
             } else if let ast::Expression::Column(table, column) = expr {
<a href="#h6-29-3" id="h6-29-3" class="d">-                // Ignore errors, they will be surfaced by build_expression().
</a><a href="#h6-29-4" id="h6-29-4" class="i">+                // Ignore errors, they will be surfaced in build_expression().
</a>                 if let Ok(index) = self.lookup_column(table.as_deref(), column.as_str()) {
                     label = self.columns[index].clone();
                 }
             }
<a href="#h6-29-9" id="h6-29-9" class="d">-
</a>             let index = child.add_column(label);
<a href="#h6-29-11" id="h6-29-11" class="d">-
</a>             // If this is an aggregate query, then all projected expressions
<a href="#h6-29-13" id="h6-29-13" class="d">-            // must also be aggregates by definition.
</a><a href="#h6-29-14" id="h6-29-14" class="i">+            // must also be aggregates by definition (an aggregate node can only
</a><a href="#h6-29-15" id="h6-29-15" class="i">+            // emit aggregate functions or GROUP BY expressions).
</a>             if !self.aggregates.is_empty() {
                 child.aggregates.entry(expr.clone()).or_insert(index);
             }
</pre>
</div>
</body>
</html>
