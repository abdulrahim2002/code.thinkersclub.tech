<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>raft: use node parameter for election timeout range - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/f0ca91670bf23b05f835cc88d1740d83ae6f94ff.html">f0ca91670bf23b05f835cc88d1740d83ae6f94ff</a>
<b>parent</b> <a href="../commit/3daa98e1ad1ec68b01eed2de70cbb4aa16c33ac7.html">3daa98e1ad1ec68b01eed2de70cbb4aa16c33ac7</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun,  5 May 2024 15:17:44 +0200

raft: use node parameter for election timeout range

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/mod.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">23</td><td><span class="i">+++++++++++</span><span class="d">------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/node/follower.rs</a></td><td> | </td><td class="num">48</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d">-------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/node/leader.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">++++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/node/mod.rs</a></td><td> | </td><td class="num">26</td><td><span class="i">++++++++++++++++</span><span class="d">----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/server.rs</a></td><td> | </td><td class="num">1</td><td><span class="i">+</span><span class="d"></span></td></tr>
</table></pre><pre>6 files changed, 64 insertions(+), 46 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a> b/<a href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -15,6 +15,6 @@ pub const TICK_INTERVAL: std::time::Duration = std::time::Duration::from_millis(
</a> /// The interval between leader heartbeats, in ticks.
 pub const HEARTBEAT_INTERVAL: Ticks = 3;
 
<a href="#h0-0-3" id="h0-0-3" class="d">-/// The election timeout range, in ticks. This is randomized per node in this
</a><a href="#h0-0-4" id="h0-0-4" class="d">-/// interval, to avoid ties.
</a><a href="#h0-0-5" id="h0-0-5" class="d">-const ELECTION_TIMEOUT_RANGE: std::ops::Range&lt;Ticks&gt; = 10..20;
</a><a href="#h0-0-6" id="h0-0-6" class="i">+/// The default election timeout range, in ticks. This is randomized in this
</a><a href="#h0-0-7" id="h0-0-7" class="i">+/// interval, to avoid election ties.
</a><a href="#h0-0-8" id="h0-0-8" class="i">+pub const ELECTION_TIMEOUT_RANGE: std::ops::Range&lt;Ticks&gt; = 10..20;
</a><b>diff --git a/<a id="h1" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,5 +1,5 @@
</a> use super::super::{Envelope, Message};
<a href="#h1-0-1" id="h1-0-1" class="d">-use super::{rand_election_timeout, Follower, Leader, Node, NodeID, RawNode, Role, Term, Ticks};
</a><a href="#h1-0-2" id="h1-0-2" class="i">+use super::{Follower, Leader, Node, NodeID, RawNode, Role, Term, Ticks};
</a> use crate::error::{Error, Result};
 
 use ::log::{debug, info};
<a href="#h1-1" id="h1-1" class="h">@@ -18,12 +18,8 @@ pub struct Candidate {
</a> 
 impl Candidate {
     /// Creates a new candidate role.
<a href="#h1-1-3" id="h1-1-3" class="d">-    pub fn new() -&gt; Self {
</a><a href="#h1-1-4" id="h1-1-4" class="d">-        Self {
</a><a href="#h1-1-5" id="h1-1-5" class="d">-            votes: HashSet::new(),
</a><a href="#h1-1-6" id="h1-1-6" class="d">-            election_duration: 0,
</a><a href="#h1-1-7" id="h1-1-7" class="d">-            election_timeout: rand_election_timeout(),
</a><a href="#h1-1-8" id="h1-1-8" class="d">-        }
</a><a href="#h1-1-9" id="h1-1-9" class="i">+    pub fn new(election_timeout: Ticks) -&gt; Self {
</a><a href="#h1-1-10" id="h1-1-10" class="i">+        Self { votes: HashSet::new(), election_duration: 0, election_timeout }
</a>     }
 }
 
<a href="#h1-2" id="h1-2" class="h">@@ -56,12 +52,13 @@ impl RawNode&lt;Candidate&gt; {
</a>     ) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
         assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
 
<a href="#h1-2-3" id="h1-2-3" class="i">+        let election_timeout = self.gen_election_timeout();
</a>         if let Some(leader) = leader {
             // We lost the election, follow the winner.
             assert_eq!(term, self.term, &quot;Can&#39;t follow leader in different term&quot;);
             info!(&quot;Lost election, following leader {} in term {}&quot;, leader, term);
             let voted_for = Some(self.id); // by definition
<a href="#h1-2-9" id="h1-2-9" class="d">-            Ok(self.into_role(Follower::new(Some(leader), voted_for)))
</a><a href="#h1-2-10" id="h1-2-10" class="i">+            Ok(self.into_role(Follower::new(Some(leader), voted_for, election_timeout)))
</a>         } else {
             // We found a new term, but we don&#39;t necessarily know who the leader
             // is yet. We&#39;ll find out when we step a message from it.
<a href="#h1-3" id="h1-3" class="h">@@ -69,7 +66,7 @@ impl RawNode&lt;Candidate&gt; {
</a>             info!(&quot;Discovered new term {}&quot;, term);
             self.term = term;
             self.log.set_term(term, None)?;
<a href="#h1-3-3" id="h1-3-3" class="d">-            Ok(self.into_role(Follower::new(None, None)))
</a><a href="#h1-3-4" id="h1-3-4" class="i">+            Ok(self.into_role(Follower::new(None, None, election_timeout)))
</a>         }
     }
 
<a href="#h1-4" id="h1-4" class="h">@@ -157,7 +154,7 @@ impl RawNode&lt;Candidate&gt; {
</a>     pub(super) fn campaign(&amp;mut self) -&gt; Result&lt;()&gt; {
         let term = self.term + 1;
         info!(&quot;Starting new election for term {}&quot;, term);
<a href="#h1-4-3" id="h1-4-3" class="d">-        self.role = Candidate::new();
</a><a href="#h1-4-4" id="h1-4-4" class="i">+        self.role = Candidate::new(self.gen_election_timeout());
</a>         self.role.votes.insert(self.id); // vote for ourself
         self.term = term;
         self.log.set_term(term, Some(self.id))?;
<a href="#h1-5" id="h1-5" class="h">@@ -171,11 +168,12 @@ impl RawNode&lt;Candidate&gt; {
</a> #[cfg(test)]
 mod tests {
     use super::super::super::state::tests::TestState;
<a href="#h1-5-3" id="h1-5-3" class="d">-    use super::super::super::{Entry, Log, Request};
</a><a href="#h1-5-4" id="h1-5-4" class="i">+    use super::super::super::{Entry, Log, Request, ELECTION_TIMEOUT_RANGE};
</a>     use super::super::tests::{assert_messages, assert_node};
     use super::*;
     use crate::storage;
     use itertools::Itertools as _;
<a href="#h1-5-9" id="h1-5-9" class="i">+    use rand::Rng as _;
</a> 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;(RawNode&lt;Candidate&gt;, crossbeam::channel::Receiver&lt;Envelope&gt;)&gt; {
<a href="#h1-6" id="h1-6" class="h">@@ -196,7 +194,8 @@ mod tests {
</a>             log,
             state,
             node_tx,
<a href="#h1-6-3" id="h1-6-3" class="d">-            role: Candidate::new(),
</a><a href="#h1-6-4" id="h1-6-4" class="i">+            election_timeout_range: ELECTION_TIMEOUT_RANGE,
</a><a href="#h1-6-5" id="h1-6-5" class="i">+            role: Candidate::new(rand::thread_rng().gen_range(ELECTION_TIMEOUT_RANGE)),
</a>         };
         node.role.votes.insert(1);
         Ok((node, node_rx))
<b>diff --git a/<a id="h2" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,5 +1,5 @@
</a> use super::super::{Envelope, Log, Message, RequestID, State};
<a href="#h2-0-1" id="h2-0-1" class="d">-use super::{rand_election_timeout, Candidate, Node, NodeID, RawNode, Role, Term, Ticks};
</a><a href="#h2-0-2" id="h2-0-2" class="i">+use super::{Candidate, Node, NodeID, RawNode, Role, Term, Ticks};
</a> use crate::error::{Error, Result};
 
 use ::log::{debug, info};
<a href="#h2-1" id="h2-1" class="h">@@ -23,14 +23,8 @@ pub struct Follower {
</a> 
 impl Follower {
     /// Creates a new follower role.
<a href="#h2-1-3" id="h2-1-3" class="d">-    pub fn new(leader: Option&lt;NodeID&gt;, voted_for: Option&lt;NodeID&gt;) -&gt; Self {
</a><a href="#h2-1-4" id="h2-1-4" class="d">-        Self {
</a><a href="#h2-1-5" id="h2-1-5" class="d">-            leader,
</a><a href="#h2-1-6" id="h2-1-6" class="d">-            voted_for,
</a><a href="#h2-1-7" id="h2-1-7" class="d">-            leader_seen: 0,
</a><a href="#h2-1-8" id="h2-1-8" class="d">-            election_timeout: rand_election_timeout(),
</a><a href="#h2-1-9" id="h2-1-9" class="d">-            forwarded: HashSet::new(),
</a><a href="#h2-1-10" id="h2-1-10" class="d">-        }
</a><a href="#h2-1-11" id="h2-1-11" class="i">+    pub fn new(leader: Option&lt;NodeID&gt;, voted_for: Option&lt;NodeID&gt;, election_timeout: Ticks) -&gt; Self {
</a><a href="#h2-1-12" id="h2-1-12" class="i">+        Self { leader, voted_for, leader_seen: 0, election_timeout, forwarded: HashSet::new() }
</a>     }
 }
 
<a href="#h2-2" id="h2-2" class="h">@@ -44,10 +38,13 @@ impl RawNode&lt;Follower&gt; {
</a>         mut log: Log,
         state: Box&lt;dyn State&gt;,
         node_tx: crossbeam::channel::Sender&lt;Envelope&gt;,
<a href="#h2-2-3" id="h2-2-3" class="i">+        election_timeout_range: std::ops::Range&lt;Ticks&gt;,
</a>     ) -&gt; Result&lt;Self&gt; {
         let (term, voted_for) = log.get_term()?;
<a href="#h2-2-6" id="h2-2-6" class="d">-        let role = Follower::new(None, voted_for);
</a><a href="#h2-2-7" id="h2-2-7" class="d">-        Ok(Self { id, peers, term, log, state, node_tx, role })
</a><a href="#h2-2-8" id="h2-2-8" class="i">+        let role = Follower::new(None, voted_for, 0);
</a><a href="#h2-2-9" id="h2-2-9" class="i">+        let mut node = Self { id, peers, term, log, state, node_tx, election_timeout_range, role };
</a><a href="#h2-2-10" id="h2-2-10" class="i">+        node.role.election_timeout = node.gen_election_timeout();
</a><a href="#h2-2-11" id="h2-2-11" class="i">+        Ok(node)
</a>     }
 
     /// Asserts internal invariants.
<a href="#h2-3" id="h2-3" class="h">@@ -81,7 +78,8 @@ impl RawNode&lt;Follower&gt; {
</a>         // Apply any pending log entries, so that we&#39;re caught up if we win.
         self.maybe_apply()?;
 
<a href="#h2-3-3" id="h2-3-3" class="d">-        let mut node = self.into_role(Candidate::new());
</a><a href="#h2-3-4" id="h2-3-4" class="i">+        let election_timeout = self.gen_election_timeout();
</a><a href="#h2-3-5" id="h2-3-5" class="i">+        let mut node = self.into_role(Candidate::new(election_timeout));
</a>         node.campaign()?;
         Ok(node)
     }
<a href="#h2-4" id="h2-4" class="h">@@ -104,7 +102,8 @@ impl RawNode&lt;Follower&gt; {
</a>             assert_eq!(self.role.leader, None, &quot;Already have leader in term&quot;);
             assert_eq!(term, self.term, &quot;Can&#39;t follow leader in different term&quot;);
             info!(&quot;Following leader {} in term {}&quot;, leader, term);
<a href="#h2-4-3" id="h2-4-3" class="d">-            self.role = Follower::new(Some(leader), self.role.voted_for);
</a><a href="#h2-4-4" id="h2-4-4" class="i">+            self.role =
</a><a href="#h2-4-5" id="h2-4-5" class="i">+                Follower::new(Some(leader), self.role.voted_for, self.role.election_timeout);
</a>         } else {
             // We found a new term, but we don&#39;t necessarily know who the leader
             // is yet. We&#39;ll find out when we step a message from it.
<a href="#h2-5" id="h2-5" class="h">@@ -112,7 +111,7 @@ impl RawNode&lt;Follower&gt; {
</a>             info!(&quot;Discovered new term {}&quot;, term);
             self.term = term;
             self.log.set_term(term, None)?;
<a href="#h2-5-3" id="h2-5-3" class="d">-            self.role = Follower::new(None, None);
</a><a href="#h2-5-4" id="h2-5-4" class="i">+            self.role = Follower::new(None, None, self.gen_election_timeout());
</a>         }
         Ok(self)
     }
<a href="#h2-6" id="h2-6" class="h">@@ -278,12 +277,13 @@ impl RawNode&lt;Follower&gt; {
</a> #[cfg(test)]
 pub mod tests {
     use super::super::super::state::tests::TestState;
<a href="#h2-6-3" id="h2-6-3" class="d">-    use super::super::super::{Entry, Log, Request, Response};
</a><a href="#h2-6-4" id="h2-6-4" class="i">+    use super::super::super::{Entry, Log, Request, Response, ELECTION_TIMEOUT_RANGE};
</a>     use super::super::tests::{assert_messages, assert_node};
     use super::*;
     use crate::error::Error;
     use crate::storage;
     use itertools::Itertools as _;
<a href="#h2-6-10" id="h2-6-10" class="i">+    use rand::Rng as _;
</a> 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;(RawNode&lt;Follower&gt;, crossbeam::channel::Receiver&lt;Envelope&gt;)&gt; {
<a href="#h2-7" id="h2-7" class="h">@@ -303,7 +303,12 @@ pub mod tests {
</a>             log,
             state,
             node_tx,
<a href="#h2-7-3" id="h2-7-3" class="d">-            role: Follower::new(Some(2), None),
</a><a href="#h2-7-4" id="h2-7-4" class="i">+            election_timeout_range: ELECTION_TIMEOUT_RANGE,
</a><a href="#h2-7-5" id="h2-7-5" class="i">+            role: Follower::new(
</a><a href="#h2-7-6" id="h2-7-6" class="i">+                Some(2),
</a><a href="#h2-7-7" id="h2-7-7" class="i">+                None,
</a><a href="#h2-7-8" id="h2-7-8" class="i">+                rand::thread_rng().gen_range(ELECTION_TIMEOUT_RANGE),
</a><a href="#h2-7-9" id="h2-7-9" class="i">+            ),
</a>         };
         Ok((node, node_rx))
     }
<a href="#h2-8" id="h2-8" class="h">@@ -402,7 +407,7 @@ pub mod tests {
</a>     // Heartbeat when no current leader makes us follow the leader
     fn step_heartbeat_no_leader() -&gt; Result&lt;()&gt; {
         let (mut follower, mut node_rx) = setup()?;
<a href="#h2-8-3" id="h2-8-3" class="d">-        follower.role = Follower::new(None, None);
</a><a href="#h2-8-4" id="h2-8-4" class="i">+        follower.role = Follower::new(None, None, follower.role.election_timeout);
</a>         let mut node = follower.step(Envelope {
             from: 3,
             to: 1,
<a href="#h2-9" id="h2-9" class="h">@@ -623,7 +628,12 @@ pub mod tests {
</a>             log,
             state: Box::new(TestState::new(0)),
             node_tx,
<a href="#h2-9-3" id="h2-9-3" class="d">-            role: Follower::new(Some(2), None),
</a><a href="#h2-9-4" id="h2-9-4" class="i">+            election_timeout_range: ELECTION_TIMEOUT_RANGE,
</a><a href="#h2-9-5" id="h2-9-5" class="i">+            role: Follower::new(
</a><a href="#h2-9-6" id="h2-9-6" class="i">+                Some(2),
</a><a href="#h2-9-7" id="h2-9-7" class="i">+                None,
</a><a href="#h2-9-8" id="h2-9-8" class="i">+                rand::thread_rng().gen_range(ELECTION_TIMEOUT_RANGE),
</a><a href="#h2-9-9" id="h2-9-9" class="i">+            ),
</a>         };
 
         let mut node = follower.step(Envelope {
<a href="#h2-10" id="h2-10" class="h">@@ -913,7 +923,7 @@ pub mod tests {
</a>     // ClientRequest returns Error::Abort when there is no leader.
     fn step_clientrequest_no_leader() -&gt; Result&lt;()&gt; {
         let (mut follower, mut node_rx) = setup()?;
<a href="#h2-10-3" id="h2-10-3" class="d">-        follower.role = Follower::new(None, None);
</a><a href="#h2-10-4" id="h2-10-4" class="i">+        follower.role = Follower::new(None, None, follower.role.election_timeout);
</a>         let mut node = Node::Follower(follower);
 
         node = node.step(Envelope {
<b>diff --git a/<a id="h3" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -124,7 +124,8 @@ impl RawNode&lt;Leader&gt; {
</a> 
         self.term = term;
         self.log.set_term(term, None)?;
<a href="#h3-0-3" id="h3-0-3" class="d">-        Ok(self.into_role(Follower::new(None, None)))
</a><a href="#h3-0-4" id="h3-0-4" class="i">+        let election_timeout = self.gen_election_timeout();
</a><a href="#h3-0-5" id="h3-0-5" class="i">+        Ok(self.into_role(Follower::new(None, None, election_timeout)))
</a>     }
 
     /// Processes a message.
<a href="#h3-1" id="h3-1" class="h">@@ -406,7 +407,7 @@ impl RawNode&lt;Leader&gt; {
</a> #[cfg(test)]
 mod tests {
     use super::super::super::state::tests::TestState;
<a href="#h3-1-3" id="h3-1-3" class="d">-    use super::super::super::{Entry, Log};
</a><a href="#h3-1-4" id="h3-1-4" class="i">+    use super::super::super::{Entry, Log, ELECTION_TIMEOUT_RANGE};
</a>     use super::super::tests::{assert_messages, assert_node};
     use super::*;
     use crate::storage;
<a href="#h3-2" id="h3-2" class="h">@@ -434,6 +435,7 @@ mod tests {
</a>             role: Leader::new(peers, log.get_last_index().0),
             log,
             state,
<a href="#h3-2-3" id="h3-2-3" class="i">+            election_timeout_range: ELECTION_TIMEOUT_RANGE,
</a>             node_tx,
         };
         Ok((node, node_rx))
<b>diff --git a/<a id="h4" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -2,7 +2,7 @@ mod candidate;
</a> mod follower;
 mod leader;
 
<a href="#h4-0-3" id="h4-0-3" class="d">-use super::{Envelope, Index, Log, Message, State, ELECTION_TIMEOUT_RANGE};
</a><a href="#h4-0-4" id="h4-0-4" class="i">+use super::{Envelope, Index, Log, Message, State};
</a> use crate::error::{Error, Result};
 use candidate::Candidate;
 use follower::Follower;
<a href="#h4-1" id="h4-1" class="h">@@ -22,11 +22,6 @@ pub type Term = u64;
</a> /// A logical clock interval as number of ticks.
 pub type Ticks = u8;
 
<a href="#h4-1-3" id="h4-1-3" class="d">-/// Generates a randomized election timeout.
</a><a href="#h4-1-4" id="h4-1-4" class="d">-fn rand_election_timeout() -&gt; Ticks {
</a><a href="#h4-1-5" id="h4-1-5" class="d">-    rand::thread_rng().gen_range(ELECTION_TIMEOUT_RANGE)
</a><a href="#h4-1-6" id="h4-1-6" class="d">-}
</a><a href="#h4-1-7" id="h4-1-7" class="d">-
</a> /// A Raft node, with a dynamic role. The node is driven synchronously by
 /// processing inbound messages via step() or by advancing time via tick().
 /// These methods consume the current node, and return a new one with a possibly
<a href="#h4-2" id="h4-2" class="h">@@ -50,8 +45,9 @@ impl Node {
</a>         log: Log,
         state: Box&lt;dyn State&gt;,
         node_tx: crossbeam::channel::Sender&lt;Envelope&gt;,
<a href="#h4-2-3" id="h4-2-3" class="i">+        election_timeout_range: std::ops::Range&lt;Ticks&gt;,
</a>     ) -&gt; Result&lt;Self&gt; {
<a href="#h4-2-5" id="h4-2-5" class="d">-        let node = RawNode::new(id, peers, log, state, node_tx)?;
</a><a href="#h4-2-6" id="h4-2-6" class="i">+        let node = RawNode::new(id, peers, log, state, node_tx, election_timeout_range)?;
</a>         if node.peers.is_empty() {
             // If there are no peers, become leader immediately.
             return Ok(node.into_candidate()?.into_leader()?.into());
<a href="#h4-3" id="h4-3" class="h">@@ -129,6 +125,7 @@ pub struct RawNode&lt;R: Role = Follower&gt; {
</a>     log: Log,
     state: Box&lt;dyn State&gt;,
     node_tx: crossbeam::channel::Sender&lt;Envelope&gt;,
<a href="#h4-3-3" id="h4-3-3" class="i">+    election_timeout_range: std::ops::Range&lt;Ticks&gt;,
</a>     role: R,
 }
 
<a href="#h4-4" id="h4-4" class="h">@@ -142,6 +139,7 @@ impl&lt;R: Role&gt; RawNode&lt;R&gt; {
</a>             log: self.log,
             state: self.state,
             node_tx: self.node_tx,
<a href="#h4-4-3" id="h4-4-3" class="i">+            election_timeout_range: self.election_timeout_range,
</a>             role,
         }
     }
<a href="#h4-5" id="h4-5" class="h">@@ -210,6 +208,11 @@ impl&lt;R: Role&gt; RawNode&lt;R&gt; {
</a>         Ok(())
     }
 
<a href="#h4-5-3" id="h4-5-3" class="i">+    /// Generates a randomized election timeout.
</a><a href="#h4-5-4" id="h4-5-4" class="i">+    fn gen_election_timeout(&amp;self) -&gt; Ticks {
</a><a href="#h4-5-5" id="h4-5-5" class="i">+        rand::thread_rng().gen_range(self.election_timeout_range.clone())
</a><a href="#h4-5-6" id="h4-5-6" class="i">+    }
</a><a href="#h4-5-7" id="h4-5-7" class="i">+
</a>     /// Asserts common node invariants.
     fn assert_node(&amp;mut self) -&gt; Result&lt;()&gt; {
         debug_assert_eq!(self.term, self.log.get_term()?.0, &quot;Term does not match log&quot;);
<a href="#h4-6" id="h4-6" class="h">@@ -246,7 +249,7 @@ fn quorum_value&lt;T: Ord + Copy&gt;(mut values: Vec&lt;T&gt;) -&gt; T {
</a> #[cfg(test)]
 mod tests {
     pub use super::super::state::tests::TestState;
<a href="#h4-6-3" id="h4-6-3" class="d">-    use super::super::{Entry, RequestID};
</a><a href="#h4-6-4" id="h4-6-4" class="i">+    use super::super::{Entry, RequestID, ELECTION_TIMEOUT_RANGE};
</a>     use super::*;
     use crate::storage;
     use pretty_assertions::assert_eq;
<a href="#h4-7" id="h4-7" class="h">@@ -433,12 +436,13 @@ mod tests {
</a>     ) -&gt; Result&lt;(RawNode&lt;Follower&gt;, crossbeam::channel::Receiver&lt;Envelope&gt;)&gt; {
         let (node_tx, node_rx) = crossbeam::channel::unbounded();
         let node = RawNode {
<a href="#h4-7-3" id="h4-7-3" class="d">-            role: Follower::new(None, None),
</a><a href="#h4-7-4" id="h4-7-4" class="i">+            role: Follower::new(None, None, rand::thread_rng().gen_range(ELECTION_TIMEOUT_RANGE)),
</a>             id: 1,
             peers: HashSet::from_iter(peers),
             term: 1,
             log: Log::new(storage::Memory::new(), false)?,
             state: Box::new(TestState::new(0)),
<a href="#h4-7-10" id="h4-7-10" class="i">+            election_timeout_range: ELECTION_TIMEOUT_RANGE,
</a>             node_tx,
         };
         Ok((node, node_rx))
<a href="#h4-8" id="h4-8" class="h">@@ -453,6 +457,7 @@ mod tests {
</a>             Log::new(storage::Memory::new(), false)?,
             Box::new(TestState::new(0)),
             node_tx,
<a href="#h4-8-3" id="h4-8-3" class="i">+            ELECTION_TIMEOUT_RANGE,
</a>         )?;
         match node {
             Node::Follower(rolenode) =&gt; {
<a href="#h4-9" id="h4-9" class="h">@@ -474,6 +479,7 @@ mod tests {
</a>             Log::new(storage::Memory::new(), false)?,
             Box::new(TestState::new(0)),
             node_tx,
<a href="#h4-9-3" id="h4-9-3" class="i">+            ELECTION_TIMEOUT_RANGE,
</a>         )?;
         match node {
             Node::Leader(rolenode) =&gt; {
<a href="#h4-10" id="h4-10" class="h">@@ -489,7 +495,7 @@ mod tests {
</a>     #[test]
     fn into_role() -&gt; Result&lt;()&gt; {
         let (node, _) = setup_rolenode()?;
<a href="#h4-10-3" id="h4-10-3" class="d">-        let role = Candidate::new();
</a><a href="#h4-10-4" id="h4-10-4" class="i">+        let role = Candidate::new(node.gen_election_timeout());
</a>         let new = node.into_role(role.clone());
         assert_eq!(new.id, 1);
         assert_eq!(new.term, 1);
<b>diff --git a/<a id="h5" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -57,6 +57,7 @@ impl Server {
</a>                 raft_log,
                 raft_state,
                 node_tx,
<a href="#h5-0-3" id="h5-0-3" class="i">+                raft::ELECTION_TIMEOUT_RANGE,
</a>             )?,
             peers,
             node_rx,
</pre>
</div>
</body>
</html>
