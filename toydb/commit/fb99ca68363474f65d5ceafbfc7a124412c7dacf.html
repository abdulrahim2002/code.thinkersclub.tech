<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Add MVCC Version type alias. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/fb99ca68363474f65d5ceafbfc7a124412c7dacf.html">fb99ca68363474f65d5ceafbfc7a124412c7dacf</a>
<b>parent</b> <a href="../commit/8c02de6830e60a982920dd307c64c7e62199c31e.html">8c02de6830e60a982920dd307c64c7e62199c31e</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue,  5 Sep 2023 22:08:37 +0200

Add MVCC Version type alias.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/storage/mvcc.rs</a></td><td> | </td><td class="num">99</td><td><span class="i">+++++++++++++++++++++++++++</span><span class="d">----------------------------------------------------</span></td></tr>
</table></pre><pre>1 file changed, 34 insertions(+), 65 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -8,20 +8,25 @@ use std::iter::Peekable;
</a> use std::ops::{Bound, RangeBounds};
 use std::sync::{Arc, Mutex, MutexGuard};
 
<a href="#h0-0-3" id="h0-0-3" class="i">+/// An MVCC version represents a logical timestamp. The latest version
</a><a href="#h0-0-4" id="h0-0-4" class="i">+/// is incremented when beginning each read-write transaction.
</a><a href="#h0-0-5" id="h0-0-5" class="i">+type Version = u64;
</a><a href="#h0-0-6" id="h0-0-6" class="i">+
</a> /// MVCC keys, using the KeyCode encoding which preserves the ordering and
 /// grouping of keys. Cow byte slices allow encoding borrowed values and
 /// decoding into owned values.
 #[derive(Debug, Deserialize, Serialize)]
 enum Key&lt;&#39;a&gt; {
<a href="#h0-0-12" id="h0-0-12" class="d">-    /// The next available transaction version.
</a><a href="#h0-0-13" id="h0-0-13" class="d">-    TxnNext,
</a><a href="#h0-0-14" id="h0-0-14" class="i">+    /// The next available version.
</a><a href="#h0-0-15" id="h0-0-15" class="i">+    NextVersion,
</a>     /// Active (uncommitted) transactions by version.
<a href="#h0-0-17" id="h0-0-17" class="d">-    TxnActive(u64),
</a><a href="#h0-0-18" id="h0-0-18" class="d">-    /// Active set snapshots by version.
</a><a href="#h0-0-19" id="h0-0-19" class="d">-    TxnActiveSnapshot(u64),
</a><a href="#h0-0-20" id="h0-0-20" class="i">+    TxnActive(Version),
</a><a href="#h0-0-21" id="h0-0-21" class="i">+    /// A snapshot of the active set at each version. Only written for
</a><a href="#h0-0-22" id="h0-0-22" class="i">+    /// versions where the active set is non-empty (excluding itself).
</a><a href="#h0-0-23" id="h0-0-23" class="i">+    TxnActiveSnapshot(Version),
</a>     /// Update marker for a version and key, used for rollback.
     TxnUpdate(
<a href="#h0-0-26" id="h0-0-26" class="d">-        u64,
</a><a href="#h0-0-27" id="h0-0-27" class="i">+        Version,
</a>         #[serde(with = &quot;serde_bytes&quot;)]
         #[serde(borrow)]
         Cow&lt;&#39;a, [u8]&gt;,
<a href="#h0-1" id="h0-1" class="h">@@ -31,7 +36,7 @@ enum Key&lt;&#39;a&gt; {
</a>         #[serde(with = &quot;serde_bytes&quot;)]
         #[serde(borrow)]
         Cow&lt;&#39;a, [u8]&gt;,
<a href="#h0-1-3" id="h0-1-3" class="d">-        u64,
</a><a href="#h0-1-4" id="h0-1-4" class="i">+        Version,
</a>     ),
     /// Unversioned non-transactional key/value pairs. These exist separately
     /// from versioned keys, i.e. the unversioned key &quot;foo&quot; is entirely
<a href="#h0-2" id="h0-2" class="h">@@ -90,7 +95,7 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a>     }
 
     /// Begins a new read-only transaction as of the given version.
<a href="#h0-2-3" id="h0-2-3" class="d">-    pub fn begin_as_of(&amp;self, version: u64) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a><a href="#h0-2-4" id="h0-2-4" class="i">+    pub fn begin_as_of(&amp;self, version: Version) -&gt; Result&lt;Transaction&lt;E&gt;&gt; {
</a>         Transaction::begin_read_only(self.engine.clone(), Some(version))
     }
 
<a href="#h0-3" id="h0-3" class="h">@@ -118,7 +123,7 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a>         let mut engine = self.engine.lock()?;
         return Ok(Status {
             storage: engine.to_string(),
<a href="#h0-3-3" id="h0-3-3" class="d">-            txns: match engine.get(&amp;Key::TxnNext.encode()?)? {
</a><a href="#h0-3-4" id="h0-3-4" class="i">+            txns: match engine.get(&amp;Key::NextVersion.encode()?)? {
</a>                 Some(ref v) =&gt; bincode::deserialize(v)?,
                 None =&gt; 1,
             } - 1,
<a href="#h0-4" id="h0-4" class="h">@@ -136,13 +141,13 @@ pub struct Transaction&lt;E: Engine&gt; {
</a>     /// The version this transaction is running at. Only one read-write
     /// transaction can run at a given version, since this identifies its
     /// writes.
<a href="#h0-4-3" id="h0-4-3" class="d">-    version: u64,
</a><a href="#h0-4-4" id="h0-4-4" class="i">+    version: Version,
</a>     /// If true, the transaction is read only.
     read_only: bool,
     /// The set of concurrent active (uncommitted) transactions. Their writes
     /// should be invisible to this transaction even if they&#39;re writing at a
     /// lower version, since they&#39;re not committed yet.
<a href="#h0-4-10" id="h0-4-10" class="d">-    active: HashSet&lt;u64&gt;,
</a><a href="#h0-4-11" id="h0-4-11" class="i">+    active: HashSet&lt;Version&gt;,
</a> }
 
 /// A serializable representation of a Transaction&#39;s state. It can be exported
<a href="#h0-5" id="h0-5" class="h">@@ -165,11 +170,11 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         let mut session = engine.lock()?;
 
         // Allocate a new version to write at.
<a href="#h0-5-3" id="h0-5-3" class="d">-        let version = match session.get(&amp;Key::TxnNext.encode()?)? {
</a><a href="#h0-5-4" id="h0-5-4" class="i">+        let version = match session.get(&amp;Key::NextVersion.encode()?)? {
</a>             Some(ref v) =&gt; bincode::deserialize(v)?,
             None =&gt; 1,
         };
<a href="#h0-5-8" id="h0-5-8" class="d">-        session.set(&amp;Key::TxnNext.encode()?, bincode::serialize(&amp;(version + 1))?)?;
</a><a href="#h0-5-9" id="h0-5-9" class="i">+        session.set(&amp;Key::NextVersion.encode()?, bincode::serialize(&amp;(version + 1))?)?;
</a> 
         // Fetch the current set of active transactions, persist it for
         // time-travel queries if non-empty, then add this txn to it.
<a href="#h0-6" id="h0-6" class="h">@@ -187,11 +192,11 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// state as of the beginning of that version (ignoring writes at that
     /// version). In other words, it sees the same state as the read-write
     /// transaction at that version saw when it began.
<a href="#h0-6-3" id="h0-6-3" class="d">-    fn begin_read_only(engine: Arc&lt;Mutex&lt;E&gt;&gt;, as_of: Option&lt;u64&gt;) -&gt; Result&lt;Self&gt; {
</a><a href="#h0-6-4" id="h0-6-4" class="i">+    fn begin_read_only(engine: Arc&lt;Mutex&lt;E&gt;&gt;, as_of: Option&lt;Version&gt;) -&gt; Result&lt;Self&gt; {
</a>         let mut session = engine.lock()?;
 
         // Fetch the latest version.
<a href="#h0-6-8" id="h0-6-8" class="d">-        let mut version = match session.get(&amp;Key::TxnNext.encode()?)? {
</a><a href="#h0-6-9" id="h0-6-9" class="i">+        let mut version = match session.get(&amp;Key::NextVersion.encode()?)? {
</a>             Some(ref v) =&gt; bincode::deserialize(v)?,
             None =&gt; 1,
         };
<a href="#h0-7" id="h0-7" class="h">@@ -228,7 +233,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     }
 
     /// Scans the set of currently active transactions.
<a href="#h0-7-3" id="h0-7-3" class="d">-    fn scan_active(session: &amp;mut MutexGuard&lt;E&gt;) -&gt; Result&lt;HashSet&lt;u64&gt;&gt; {
</a><a href="#h0-7-4" id="h0-7-4" class="i">+    fn scan_active(session: &amp;mut MutexGuard&lt;E&gt;) -&gt; Result&lt;HashSet&lt;Version&gt;&gt; {
</a>         let mut active = HashSet::new();
         // TODO: Add Engine.scan_prefix() trait method.
         let mut scan =
<a href="#h0-8" id="h0-8" class="h">@@ -243,7 +248,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     }
 
     /// Returns the version the transaction is running at.
<a href="#h0-8-3" id="h0-8-3" class="d">-    pub fn version(&amp;self) -&gt; u64 {
</a><a href="#h0-8-4" id="h0-8-4" class="i">+    pub fn version(&amp;self) -&gt; Version {
</a>         self.version
     }
 
<a href="#h0-9" id="h0-9" class="h">@@ -295,7 +300,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     }
 
     /// Checks whether the given version is visible to this transaction.
<a href="#h0-9-3" id="h0-9-3" class="d">-    fn is_visible(&amp;self, version: u64) -&gt; bool {
</a><a href="#h0-9-4" id="h0-9-4" class="i">+    fn is_visible(&amp;self, version: Version) -&gt; bool {
</a>         if self.active.get(&amp;version).is_some() {
             false
         } else if self.read_only {
<a href="#h0-10" id="h0-10" class="h">@@ -335,13 +340,13 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// Scans a key range.
     pub fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;ScanIterator&gt; {
         let start = match range.start_bound() {
<a href="#h0-10-3" id="h0-10-3" class="d">-            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Version(k.into(), std::u64::MAX).encode()?),
</a><a href="#h0-10-4" id="h0-10-4" class="i">+            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Version(k.into(), u64::MAX).encode()?),
</a>             Bound::Included(k) =&gt; Bound::Included(Key::Version(k.into(), 0).encode()?),
             Bound::Unbounded =&gt; Bound::Included(Key::Version(vec![].into(), 0).encode()?),
         };
         let end = match range.end_bound() {
             Bound::Excluded(k) =&gt; Bound::Excluded(Key::Version(k.into(), 0).encode()?),
<a href="#h0-10-10" id="h0-10-10" class="d">-            Bound::Included(k) =&gt; Bound::Included(Key::Version(k.into(), std::u64::MAX).encode()?),
</a><a href="#h0-10-11" id="h0-10-11" class="i">+            Bound::Included(k) =&gt; Bound::Included(Key::Version(k.into(), u64::MAX).encode()?),
</a>             Bound::Unbounded =&gt; Bound::Unbounded,
         };
         // TODO: For now, collect results from the engine to not have to deal with lifetimes.
<a href="#h0-11" id="h0-11" class="h">@@ -391,7 +396,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         let mut scan = session
             .scan(
                 Key::Version(key.into(), min).encode()?
<a href="#h0-11-3" id="h0-11-3" class="d">-                    ..=Key::Version(key.into(), std::u64::MAX).encode()?,
</a><a href="#h0-11-4" id="h0-11-4" class="i">+                    ..=Key::Version(key.into(), u64::MAX).encode()?,
</a>             )
             .rev();
         while let Some((k, _)) = scan.next().transpose()? {
<a href="#h0-12" id="h0-12" class="h">@@ -414,42 +419,6 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     }
 }
 
<a href="#h0-12-3" id="h0-12-3" class="d">-/// An MVCC transaction mode.
</a><a href="#h0-12-4" id="h0-12-4" class="d">-#[derive(Clone, Copy, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h0-12-5" id="h0-12-5" class="d">-pub enum Mode {
</a><a href="#h0-12-6" id="h0-12-6" class="d">-    /// A read-write transaction.
</a><a href="#h0-12-7" id="h0-12-7" class="d">-    ReadWrite,
</a><a href="#h0-12-8" id="h0-12-8" class="d">-    /// A read-only transaction.
</a><a href="#h0-12-9" id="h0-12-9" class="d">-    ReadOnly,
</a><a href="#h0-12-10" id="h0-12-10" class="d">-    /// A read-only transaction running in a snapshot of a given version.
</a><a href="#h0-12-11" id="h0-12-11" class="d">-    ///
</a><a href="#h0-12-12" id="h0-12-12" class="d">-    /// The version must refer to a committed transaction ID. Any changes visible to the original
</a><a href="#h0-12-13" id="h0-12-13" class="d">-    /// transaction will be visible in the snapshot (i.e. transactions that had not committed before
</a><a href="#h0-12-14" id="h0-12-14" class="d">-    /// the snapshot transaction started will not be visible, even though they have a lower version).
</a><a href="#h0-12-15" id="h0-12-15" class="d">-    Snapshot { version: u64 },
</a><a href="#h0-12-16" id="h0-12-16" class="d">-}
</a><a href="#h0-12-17" id="h0-12-17" class="d">-
</a><a href="#h0-12-18" id="h0-12-18" class="d">-impl Mode {
</a><a href="#h0-12-19" id="h0-12-19" class="d">-    /// Checks whether the transaction mode can mutate data.
</a><a href="#h0-12-20" id="h0-12-20" class="d">-    pub fn mutable(&amp;self) -&gt; bool {
</a><a href="#h0-12-21" id="h0-12-21" class="d">-        match self {
</a><a href="#h0-12-22" id="h0-12-22" class="d">-            Self::ReadWrite =&gt; true,
</a><a href="#h0-12-23" id="h0-12-23" class="d">-            Self::ReadOnly =&gt; false,
</a><a href="#h0-12-24" id="h0-12-24" class="d">-            Self::Snapshot { .. } =&gt; false,
</a><a href="#h0-12-25" id="h0-12-25" class="d">-        }
</a><a href="#h0-12-26" id="h0-12-26" class="d">-    }
</a><a href="#h0-12-27" id="h0-12-27" class="d">-
</a><a href="#h0-12-28" id="h0-12-28" class="d">-    /// Checks whether a mode satisfies a mode (i.e. ReadWrite satisfies ReadOnly).
</a><a href="#h0-12-29" id="h0-12-29" class="d">-    pub fn satisfies(&amp;self, other: &amp;Mode) -&gt; bool {
</a><a href="#h0-12-30" id="h0-12-30" class="d">-        match (self, other) {
</a><a href="#h0-12-31" id="h0-12-31" class="d">-            (Mode::ReadWrite, Mode::ReadOnly) =&gt; true,
</a><a href="#h0-12-32" id="h0-12-32" class="d">-            (Mode::Snapshot { .. }, Mode::ReadOnly) =&gt; true,
</a><a href="#h0-12-33" id="h0-12-33" class="d">-            (_, _) if self == other =&gt; true,
</a><a href="#h0-12-34" id="h0-12-34" class="d">-            (_, _) =&gt; false,
</a><a href="#h0-12-35" id="h0-12-35" class="d">-        }
</a><a href="#h0-12-36" id="h0-12-36" class="d">-    }
</a><a href="#h0-12-37" id="h0-12-37" class="d">-}
</a><a href="#h0-12-38" id="h0-12-38" class="d">-
</a> pub type ScanIterator&lt;&#39;a&gt; =
     Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; + Send + &#39;a&gt;;
 
<a href="#h0-13" id="h0-13" class="h">@@ -466,18 +435,18 @@ impl&lt;&#39;a&gt; Scan&lt;&#39;a&gt; {
</a>     /// Creates a new scan.
     fn new(
         mut scan: ScanIterator&lt;&#39;a&gt;,
<a href="#h0-13-3" id="h0-13-3" class="d">-        txn_version: u64,
</a><a href="#h0-13-4" id="h0-13-4" class="i">+        txn_version: Version,
</a>         read_only: bool,
<a href="#h0-13-6" id="h0-13-6" class="d">-        snapshot: HashSet&lt;u64&gt;,
</a><a href="#h0-13-7" id="h0-13-7" class="i">+        active: HashSet&lt;Version&gt;,
</a>     ) -&gt; Self {
         /// Checks whether the given version is visible to this transaction.
         fn is_visible(
<a href="#h0-13-11" id="h0-13-11" class="d">-            txn_version: u64,
</a><a href="#h0-13-12" id="h0-13-12" class="i">+            txn_version: Version,
</a>             read_only: bool,
<a href="#h0-13-14" id="h0-13-14" class="d">-            snapshot: &amp;HashSet&lt;u64&gt;,
</a><a href="#h0-13-15" id="h0-13-15" class="d">-            version: u64,
</a><a href="#h0-13-16" id="h0-13-16" class="i">+            active: &amp;HashSet&lt;Version&gt;,
</a><a href="#h0-13-17" id="h0-13-17" class="i">+            version: Version,
</a>         ) -&gt; bool {
<a href="#h0-13-19" id="h0-13-19" class="d">-            if snapshot.get(&amp;version).is_some() {
</a><a href="#h0-13-20" id="h0-13-20" class="i">+            if active.get(&amp;version).is_some() {
</a>                 false
             } else if read_only {
                 version &lt; txn_version
<a href="#h0-14" id="h0-14" class="h">@@ -494,7 +463,7 @@ impl&lt;&#39;a&gt; Scan&lt;&#39;a&gt; {
</a>         scan = Box::new(scan.filter_map(move |r| {
             r.and_then(|(k, v)| match Key::decode(&amp;k)? {
                 Key::Version(_, version)
<a href="#h0-14-3" id="h0-14-3" class="d">-                    if !is_visible(txn_version, read_only, &amp;snapshot, version) =&gt;
</a><a href="#h0-14-4" id="h0-14-4" class="i">+                    if !is_visible(txn_version, read_only, &amp;active, version) =&gt;
</a>                 {
                     Ok(None)
                 }
<a href="#h0-15" id="h0-15" class="h">@@ -637,7 +606,7 @@ pub mod tests {
</a>         assert_eq!(txn.get(b&quot;other&quot;)?, Some(vec![1]));
         txn.commit()?;
 
<a href="#h0-15-3" id="h0-15-3" class="d">-        // Check that any future transaction IDs are invalid
</a><a href="#h0-15-4" id="h0-15-4" class="i">+        // Check that any future versions are invalid.
</a>         assert_eq!(
             mvcc.begin_as_of(9).err(),
             Some(Error::Value(&quot;Version 9 does not exist&quot;.into()))
</pre>
</div>
</body>
</html>
