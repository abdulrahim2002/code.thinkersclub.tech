<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: simplify nested loop join executor - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/a082d65732cff3f394b03d866ecc92a3bffa19ab.html">a082d65732cff3f394b03d866ecc92a3bffa19ab</a>
<b>parent</b> <a href="../commit/462dd34adc6272f6318b16b00f7bedbe1f4f1aa7.html">462dd34adc6272f6318b16b00f7bedbe1f4f1aa7</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun,  7 Jun 2020 19:03:14 +0200

sql: simplify nested loop join executor

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/execution/join.rs</a></td><td> | </td><td class="num">106</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------</span></td></tr>
</table></pre><pre>1 file changed, 54 insertions(+), 52 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a> b/<a href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -5,8 +5,8 @@ use crate::error::{Error, Result};
</a> 
 use std::collections::HashMap;
 
<a href="#h0-0-3" id="h0-0-3" class="d">-/// A nested loop join executor
</a><a href="#h0-0-4" id="h0-0-4" class="d">-/// FIXME This code is horrible, clean it up at some point
</a><a href="#h0-0-5" id="h0-0-5" class="i">+/// A nested loop join executor, which checks each row in the left source against every row in
</a><a href="#h0-0-6" id="h0-0-6" class="i">+/// the right source using the given predicate.
</a> pub struct NestedLoopJoin&lt;T: Transaction&gt; {
     left: Box&lt;dyn Executor&lt;T&gt;&gt;,
     right: Box&lt;dyn Executor&lt;T&gt;&gt;,
<a href="#h0-1" id="h0-1" class="h">@@ -29,12 +29,16 @@ impl&lt;T: Transaction&gt; Executor&lt;T&gt; for NestedLoopJoin&lt;T&gt; {
</a>     fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
         if let ResultSet::Query { mut columns, rows } = self.left.execute(txn)? {
             if let ResultSet::Query { columns: rcolumns, rows: rrows } = self.right.execute(txn)? {
<a href="#h0-1-3" id="h0-1-3" class="i">+                let right_width = rcolumns.len();
</a>                 columns.extend(rcolumns);
<a href="#h0-1-5" id="h0-1-5" class="i">+                // FIXME Since making the iterators or sources clonable is non-trivial (requiring
</a><a href="#h0-1-6" id="h0-1-6" class="i">+                // either avoiding Rust standard iterators or making sources generic), we simply
</a><a href="#h0-1-7" id="h0-1-7" class="i">+                // fetch the entire right result as a vector.
</a>                 return Ok(ResultSet::Query {
                     rows: Box::new(NestedLoopRows::new(
<a href="#h0-1-10" id="h0-1-10" class="d">-                        columns.len(),
</a>                         rows,
                         rrows.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
<a href="#h0-1-13" id="h0-1-13" class="i">+                        right_width,
</a>                         self.predicate,
                         self.outer,
                     )),
<a href="#h0-2" id="h0-2" class="h">@@ -47,48 +51,70 @@ impl&lt;T: Transaction&gt; Executor&lt;T&gt; for NestedLoopJoin&lt;T&gt; {
</a> }
 
 struct NestedLoopRows {
<a href="#h0-2-3" id="h0-2-3" class="d">-    size: usize,
</a><a href="#h0-2-4" id="h0-2-4" class="d">-    predicate: Option&lt;Expression&gt;,
</a>     left: Rows,
<a href="#h0-2-6" id="h0-2-6" class="d">-    left_cur: Option&lt;Result&lt;Row&gt;&gt;,
</a><a href="#h0-2-7" id="h0-2-7" class="d">-    // FIXME right should be Rows too, but requires impl Clone
</a><a href="#h0-2-8" id="h0-2-8" class="i">+    left_row: Option&lt;Result&lt;Row&gt;&gt;,
</a>     right: Box&lt;dyn Iterator&lt;Item = Row&gt; + Send&gt;,
<a href="#h0-2-10" id="h0-2-10" class="d">-    right_orig: Vec&lt;Row&gt;,
</a><a href="#h0-2-11" id="h0-2-11" class="d">-    right_pad: bool,
</a><a href="#h0-2-12" id="h0-2-12" class="d">-    right_emitted: bool,
</a><a href="#h0-2-13" id="h0-2-13" class="i">+    right_vec: Vec&lt;Row&gt;,
</a><a href="#h0-2-14" id="h0-2-14" class="i">+    right_empty: Vec&lt;Value&gt;,
</a><a href="#h0-2-15" id="h0-2-15" class="i">+    right_hit: bool,
</a><a href="#h0-2-16" id="h0-2-16" class="i">+    predicate: Option&lt;Expression&gt;,
</a><a href="#h0-2-17" id="h0-2-17" class="i">+    outer: bool,
</a> }
 
 impl NestedLoopRows {
     fn new(
<a href="#h0-2-22" id="h0-2-22" class="d">-        size: usize,
</a>         mut left: Rows,
         right: Vec&lt;Row&gt;,
<a href="#h0-2-25" id="h0-2-25" class="i">+        right_width: usize,
</a>         predicate: Option&lt;Expression&gt;,
<a href="#h0-2-27" id="h0-2-27" class="d">-        right_pad: bool,
</a><a href="#h0-2-28" id="h0-2-28" class="i">+        outer: bool,
</a>     ) -&gt; Self {
         Self {
<a href="#h0-2-31" id="h0-2-31" class="d">-            size,
</a><a href="#h0-2-32" id="h0-2-32" class="d">-            predicate,
</a><a href="#h0-2-33" id="h0-2-33" class="d">-            left_cur: left.next(),
</a><a href="#h0-2-34" id="h0-2-34" class="i">+            left_row: left.next(),
</a>             left,
             right: Box::new(right.clone().into_iter()),
<a href="#h0-2-37" id="h0-2-37" class="d">-            right_orig: right,
</a><a href="#h0-2-38" id="h0-2-38" class="d">-            right_pad,
</a><a href="#h0-2-39" id="h0-2-39" class="d">-            right_emitted: false,
</a><a href="#h0-2-40" id="h0-2-40" class="i">+            right_vec: right,
</a><a href="#h0-2-41" id="h0-2-41" class="i">+            right_empty: std::iter::repeat(Value::Null).take(right_width).collect(),
</a><a href="#h0-2-42" id="h0-2-42" class="i">+            right_hit: false,
</a><a href="#h0-2-43" id="h0-2-43" class="i">+            predicate,
</a><a href="#h0-2-44" id="h0-2-44" class="i">+            outer,
</a><a href="#h0-2-45" id="h0-2-45" class="i">+        }
</a><a href="#h0-2-46" id="h0-2-46" class="i">+    }
</a><a href="#h0-2-47" id="h0-2-47" class="i">+
</a><a href="#h0-2-48" id="h0-2-48" class="i">+    // Tries to get the next joined row, with error handling.
</a><a href="#h0-2-49" id="h0-2-49" class="i">+    fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
</a><a href="#h0-2-50" id="h0-2-50" class="i">+        // While there is a valid left row, look for a right-hand match to return.
</a><a href="#h0-2-51" id="h0-2-51" class="i">+        while let Some(Ok(left_row)) = self.left_row.clone() {
</a><a href="#h0-2-52" id="h0-2-52" class="i">+            // If there is a hit in the remaining right rows, return it.
</a><a href="#h0-2-53" id="h0-2-53" class="i">+            if let Some(row) = self.try_next_hit(&amp;left_row)? {
</a><a href="#h0-2-54" id="h0-2-54" class="i">+                self.right_hit = true;
</a><a href="#h0-2-55" id="h0-2-55" class="i">+                return Ok(Some(row));
</a><a href="#h0-2-56" id="h0-2-56" class="i">+            }
</a><a href="#h0-2-57" id="h0-2-57" class="i">+
</a><a href="#h0-2-58" id="h0-2-58" class="i">+            // Otherwise, continue with the next left row and reset the right source.
</a><a href="#h0-2-59" id="h0-2-59" class="i">+            self.left_row = self.left.next();
</a><a href="#h0-2-60" id="h0-2-60" class="i">+            self.right = Box::new(self.right_vec.clone().into_iter());
</a><a href="#h0-2-61" id="h0-2-61" class="i">+
</a><a href="#h0-2-62" id="h0-2-62" class="i">+            // If this is an outer join, when we reach the end of the right items without a hit,
</a><a href="#h0-2-63" id="h0-2-63" class="i">+            // we should return a row with nulls for the right fields.
</a><a href="#h0-2-64" id="h0-2-64" class="i">+            if self.outer &amp;&amp; !self.right_hit {
</a><a href="#h0-2-65" id="h0-2-65" class="i">+                let mut row = left_row;
</a><a href="#h0-2-66" id="h0-2-66" class="i">+                row.extend(self.right_empty.clone());
</a><a href="#h0-2-67" id="h0-2-67" class="i">+                return Ok(Some(row));
</a><a href="#h0-2-68" id="h0-2-68" class="i">+            }
</a><a href="#h0-2-69" id="h0-2-69" class="i">+            self.right_hit = false;
</a>         }
<a href="#h0-2-71" id="h0-2-71" class="i">+        self.left_row.clone().transpose()
</a>     }
 
<a href="#h0-2-74" id="h0-2-74" class="d">-    fn next_right(&amp;mut self) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
</a><a href="#h0-2-75" id="h0-2-75" class="d">-        let left_row = match self.left_cur.clone().transpose()? {
</a><a href="#h0-2-76" id="h0-2-76" class="d">-            Some(r) =&gt; r,
</a><a href="#h0-2-77" id="h0-2-77" class="d">-            None =&gt; return Ok(None),
</a><a href="#h0-2-78" id="h0-2-78" class="d">-        };
</a><a href="#h0-2-79" id="h0-2-79" class="i">+    /// Tries to find the next combined row that matches the predicate in the remaining right rows.
</a><a href="#h0-2-80" id="h0-2-80" class="i">+    fn try_next_hit(&amp;mut self, left_row: &amp;[Value]) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
</a>         while let Some(right_row) = self.right.next() {
<a href="#h0-2-82" id="h0-2-82" class="i">+            let mut row = left_row.to_vec();
</a><a href="#h0-2-83" id="h0-2-83" class="i">+            row.extend(right_row);
</a>             if let Some(predicate) = &amp;self.predicate {
<a href="#h0-2-85" id="h0-2-85" class="d">-                let mut row = left_row.clone();
</a><a href="#h0-2-86" id="h0-2-86" class="d">-                row.extend(right_row.clone());
</a>                 match predicate.evaluate(Some(&amp;row))? {
<a href="#h0-2-88" id="h0-2-88" class="d">-                    Value::Boolean(true) =&gt; return Ok(Some(right_row)),
</a><a href="#h0-2-89" id="h0-2-89" class="i">+                    Value::Boolean(true) =&gt; return Ok(Some(row)),
</a>                     Value::Boolean(false) =&gt; {}
                     Value::Null =&gt; {}
                     value =&gt; {
<a href="#h0-3" id="h0-3" class="h">@@ -99,7 +125,7 @@ impl NestedLoopRows {
</a>                     }
                 }
             } else {
<a href="#h0-3-3" id="h0-3-3" class="d">-                return Ok(Some(right_row));
</a><a href="#h0-3-4" id="h0-3-4" class="i">+                return Ok(Some(row));
</a>             }
         }
         Ok(None)
<a href="#h0-4" id="h0-4" class="h">@@ -110,31 +136,7 @@ impl Iterator for NestedLoopRows {
</a>     type Item = Result&lt;Row&gt;;
 
     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
<a href="#h0-4-3" id="h0-4-3" class="d">-        while let Some(Ok(mut row)) = self.left_cur.clone() {
</a><a href="#h0-4-4" id="h0-4-4" class="d">-            let right_row = match self.next_right().transpose() {
</a><a href="#h0-4-5" id="h0-4-5" class="d">-                Some(Ok(i)) =&gt; {
</a><a href="#h0-4-6" id="h0-4-6" class="d">-                    self.right_emitted = true;
</a><a href="#h0-4-7" id="h0-4-7" class="d">-                    i
</a><a href="#h0-4-8" id="h0-4-8" class="d">-                }
</a><a href="#h0-4-9" id="h0-4-9" class="d">-                Some(Err(e)) =&gt; return Some(Err(e)),
</a><a href="#h0-4-10" id="h0-4-10" class="d">-                None =&gt; {
</a><a href="#h0-4-11" id="h0-4-11" class="d">-                    self.right = Box::new(self.right_orig.clone().into_iter());
</a><a href="#h0-4-12" id="h0-4-12" class="d">-                    if self.right_pad &amp;&amp; !self.right_emitted {
</a><a href="#h0-4-13" id="h0-4-13" class="d">-                        while row.len() &lt; self.size {
</a><a href="#h0-4-14" id="h0-4-14" class="d">-                            row.push(Value::Null)
</a><a href="#h0-4-15" id="h0-4-15" class="d">-                        }
</a><a href="#h0-4-16" id="h0-4-16" class="d">-                        self.left_cur = self.left.next();
</a><a href="#h0-4-17" id="h0-4-17" class="d">-                        return Some(Ok(row));
</a><a href="#h0-4-18" id="h0-4-18" class="d">-                    }
</a><a href="#h0-4-19" id="h0-4-19" class="d">-                    self.right_emitted = false;
</a><a href="#h0-4-20" id="h0-4-20" class="d">-                    self.left_cur = self.left.next();
</a><a href="#h0-4-21" id="h0-4-21" class="d">-                    continue;
</a><a href="#h0-4-22" id="h0-4-22" class="d">-                }
</a><a href="#h0-4-23" id="h0-4-23" class="d">-            };
</a><a href="#h0-4-24" id="h0-4-24" class="d">-            row.extend(right_row);
</a><a href="#h0-4-25" id="h0-4-25" class="d">-            return Some(Ok(row));
</a><a href="#h0-4-26" id="h0-4-26" class="d">-        }
</a><a href="#h0-4-27" id="h0-4-27" class="d">-        self.left_cur.clone()
</a><a href="#h0-4-28" id="h0-4-28" class="i">+        self.try_next().transpose()
</a>     }
 }
 
</pre>
</div>
</body>
</html>
