<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Use std::ops::RangeBounds for Store::scan(). - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/082cfdc1aff9f323b3608cc30a8c2f3509f7fb90.html">082cfdc1aff9f323b3608cc30a8c2f3509f7fb90</a>
<b>parent</b> <a href="../commit/be238123b58ea752dbe59f6335c228898243ca26.html">be238123b58ea752dbe59f6335c228898243ca26</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sat,  2 Sep 2023 13:57:10 +0200

Use std::ops::RangeBounds for Store::scan().

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/storage/kv/bitcask.rs</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/storage/kv/memory.rs</a></td><td> | </td><td class="num">13</td><td><span class="i">+++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/storage/kv/mod.rs</a></td><td> | </td><td class="num">75</td><td><span class="i">++++++++++++</span><span class="d">---------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/storage/kv/mvcc.rs</a></td><td> | </td><td class="num">25</td><td><span class="i">+++++++++</span><span class="d">----------------</span></td></tr>
</table></pre><pre>4 files changed, 35 insertions(+), 96 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/storage/kv/bitcask.rs.html">src/storage/kv/bitcask.rs</a> b/<a href="../file/src/storage/kv/bitcask.rs.html">src/storage/kv/bitcask.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h0-0-0" id="h0-0-0" class="d">-use super::{Range, Scan, Store};
</a><a href="#h0-0-1" id="h0-0-1" class="i">+use super::{Scan, Store};
</a> use crate::error::Result;
 
 use fs4::FileExt;
<a href="#h0-1" id="h0-1" class="h">@@ -112,7 +112,7 @@ impl Store for BitCask {
</a>         }
     }
 
<a href="#h0-1-3" id="h0-1-3" class="d">-    fn scan(&amp;mut self, range: Range) -&gt; Scan {
</a><a href="#h0-1-4" id="h0-1-4" class="i">+    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Scan {
</a>         Box::new(self.keydir.range(range).map(|(key, (value_pos, value_len))| {
             Ok((key.clone(), self.log.read_value(*value_pos, *value_len)?))
         }))
<a href="#h0-2" id="h0-2" class="h">@@ -404,7 +404,7 @@ mod tests {
</a>                 (b&quot;c&quot;.to_vec(), vec![0x03]),
                 (b&quot;d&quot;.to_vec(), vec![0x04]),
             ],
<a href="#h0-2-3" id="h0-2-3" class="d">-            s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h0-2-4" id="h0-2-4" class="i">+            s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a>         );
 
         Ok(())
<a href="#h0-3" id="h0-3" class="h">@@ -430,10 +430,10 @@ mod tests {
</a>         let mut s = BitCask::new(path.clone())?;
         setup_log(&amp;mut s)?;
 
<a href="#h0-3-3" id="h0-3-3" class="d">-        let expect = s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h0-3-4" id="h0-3-4" class="i">+        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a>         drop(s);
         let mut s = BitCask::new(path)?;
<a href="#h0-3-7" id="h0-3-7" class="d">-        assert_eq!(expect, s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h0-3-8" id="h0-3-8" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a> 
         Ok(())
     }
<a href="#h0-4" id="h0-4" class="h">@@ -452,18 +452,18 @@ mod tests {
</a>         // Dump the initial log file.
         let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
         s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-before&quot;)?)?;
<a href="#h0-4-3" id="h0-4-3" class="d">-        let expect = s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h0-4-4" id="h0-4-4" class="i">+        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a> 
         // Compact the log file and assert the new log file contents.
         s.compact()?;
         assert_eq!(path, s.log.path);
<a href="#h0-4-9" id="h0-4-9" class="d">-        assert_eq!(expect, s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h0-4-10" id="h0-4-10" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a>         s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-after&quot;)?)?;
 
         // Reopen the log file and assert that the contents are the same.
         drop(s);
         let mut s = BitCask::new(path)?;
<a href="#h0-4-16" id="h0-4-16" class="d">-        assert_eq!(expect, s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h0-4-17" id="h0-4-17" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a> 
         Ok(())
     }
<a href="#h0-5" id="h0-5" class="h">@@ -572,7 +572,7 @@ mod tests {
</a>             }
 
             let mut s = BitCask::new(truncpath.clone())?;
<a href="#h0-5-3" id="h0-5-3" class="d">-            assert_eq!(expect, s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h0-5-4" id="h0-5-4" class="i">+            assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a>         }
 
         Ok(())
<b>diff --git a/<a id="h1" href="../file/src/storage/kv/memory.rs.html">src/storage/kv/memory.rs</a> b/<a href="../file/src/storage/kv/memory.rs.html">src/storage/kv/memory.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,22 +1,19 @@
</a><a href="#h1-0-0" id="h1-0-0" class="d">-use super::{Range, Scan, Store};
</a><a href="#h1-0-1" id="h1-0-1" class="i">+use super::{Scan, Store};
</a> use crate::error::Result;
 
<a href="#h1-0-4" id="h1-0-4" class="d">-use std::collections::BTreeMap;
</a><a href="#h1-0-5" id="h1-0-5" class="d">-use std::fmt::Display;
</a><a href="#h1-0-6" id="h1-0-6" class="d">-
</a> /// In-memory key-value store using the Rust standard library B-tree implementation.
 pub struct Memory {
<a href="#h1-0-9" id="h1-0-9" class="d">-    data: BTreeMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h1-0-10" id="h1-0-10" class="i">+    data: std::collections::BTreeMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a> }
 
 impl Memory {
     /// Creates a new Memory key-value storage engine.
     pub fn new() -&gt; Self {
<a href="#h1-0-16" id="h1-0-16" class="d">-        Self { data: BTreeMap::new() }
</a><a href="#h1-0-17" id="h1-0-17" class="i">+        Self { data: std::collections::BTreeMap::new() }
</a>     }
 }
 
<a href="#h1-0-21" id="h1-0-21" class="d">-impl Display for Memory {
</a><a href="#h1-0-22" id="h1-0-22" class="i">+impl std::fmt::Display for Memory {
</a>     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
         write!(f, &quot;memory&quot;)
     }
<a href="#h1-1" id="h1-1" class="h">@@ -36,7 +33,7 @@ impl Store for Memory {
</a>         Ok(self.data.get(key).cloned())
     }
 
<a href="#h1-1-3" id="h1-1-3" class="d">-    fn scan(&amp;mut self, range: Range) -&gt; Scan {
</a><a href="#h1-1-4" id="h1-1-4" class="i">+    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Scan {
</a>         Box::new(self.data.range(range).map(|(k, v)| Ok((k.clone(), v.clone()))))
     }
 
<b>diff --git a/<a id="h2" href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a> b/<a href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -8,11 +8,9 @@ pub use memory::Memory;
</a> pub use mvcc::MVCC;
 
 use crate::error::Result;
<a href="#h2-0-3" id="h2-0-3" class="d">-use std::fmt::Display;
</a><a href="#h2-0-4" id="h2-0-4" class="d">-use std::ops::{Bound, RangeBounds};
</a> 
 /// A key/value store.
<a href="#h2-0-7" id="h2-0-7" class="d">-pub trait Store: Display + Send + Sync {
</a><a href="#h2-0-8" id="h2-0-8" class="i">+pub trait Store: std::fmt::Display + Send + Sync {
</a>     /// Deletes a key, or does nothing if it does not exist.
     fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt;;
 
<a href="#h2-1" id="h2-1" class="h">@@ -23,56 +21,12 @@ pub trait Store: Display + Send + Sync {
</a>     fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
 
     /// Iterates over an ordered range of key/value pairs.
<a href="#h2-1-3" id="h2-1-3" class="d">-    fn scan(&amp;mut self, range: Range) -&gt; Scan;
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    fn scan&lt;R: std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;mut self, range: R) -&gt; Scan;
</a> 
     /// Sets a value for a key, replacing the existing value if any.
     fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;
 }
 
<a href="#h2-1-10" id="h2-1-10" class="d">-/// A scan range.
</a><a href="#h2-1-11" id="h2-1-11" class="d">-pub struct Range {
</a><a href="#h2-1-12" id="h2-1-12" class="d">-    start: Bound&lt;Vec&lt;u8&gt;&gt;,
</a><a href="#h2-1-13" id="h2-1-13" class="d">-    end: Bound&lt;Vec&lt;u8&gt;&gt;,
</a><a href="#h2-1-14" id="h2-1-14" class="d">-}
</a><a href="#h2-1-15" id="h2-1-15" class="d">-
</a><a href="#h2-1-16" id="h2-1-16" class="d">-impl Range {
</a><a href="#h2-1-17" id="h2-1-17" class="d">-    /// Creates a new range from the given Rust range. We can&#39;t use the RangeBounds directly in
</a><a href="#h2-1-18" id="h2-1-18" class="d">-    /// scan() since that prevents us from using Store as a trait object. Also, we can&#39;t take
</a><a href="#h2-1-19" id="h2-1-19" class="d">-    /// AsRef&lt;[u8]&gt; or other convenient types, since that won&#39;t work with e.g. .. ranges.
</a><a href="#h2-1-20" id="h2-1-20" class="d">-    pub fn from&lt;R: RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(range: R) -&gt; Self {
</a><a href="#h2-1-21" id="h2-1-21" class="d">-        Self {
</a><a href="#h2-1-22" id="h2-1-22" class="d">-            start: match range.start_bound() {
</a><a href="#h2-1-23" id="h2-1-23" class="d">-                Bound::Included(v) =&gt; Bound::Included(v.to_vec()),
</a><a href="#h2-1-24" id="h2-1-24" class="d">-                Bound::Excluded(v) =&gt; Bound::Excluded(v.to_vec()),
</a><a href="#h2-1-25" id="h2-1-25" class="d">-                Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h2-1-26" id="h2-1-26" class="d">-            },
</a><a href="#h2-1-27" id="h2-1-27" class="d">-            end: match range.end_bound() {
</a><a href="#h2-1-28" id="h2-1-28" class="d">-                Bound::Included(v) =&gt; Bound::Included(v.to_vec()),
</a><a href="#h2-1-29" id="h2-1-29" class="d">-                Bound::Excluded(v) =&gt; Bound::Excluded(v.to_vec()),
</a><a href="#h2-1-30" id="h2-1-30" class="d">-                Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h2-1-31" id="h2-1-31" class="d">-            },
</a><a href="#h2-1-32" id="h2-1-32" class="d">-        }
</a><a href="#h2-1-33" id="h2-1-33" class="d">-    }
</a><a href="#h2-1-34" id="h2-1-34" class="d">-}
</a><a href="#h2-1-35" id="h2-1-35" class="d">-
</a><a href="#h2-1-36" id="h2-1-36" class="d">-impl RangeBounds&lt;Vec&lt;u8&gt;&gt; for Range {
</a><a href="#h2-1-37" id="h2-1-37" class="d">-    fn start_bound(&amp;self) -&gt; Bound&lt;&amp;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-1-38" id="h2-1-38" class="d">-        match &amp;self.start {
</a><a href="#h2-1-39" id="h2-1-39" class="d">-            Bound::Included(v) =&gt; Bound::Included(v),
</a><a href="#h2-1-40" id="h2-1-40" class="d">-            Bound::Excluded(v) =&gt; Bound::Excluded(v),
</a><a href="#h2-1-41" id="h2-1-41" class="d">-            Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h2-1-42" id="h2-1-42" class="d">-        }
</a><a href="#h2-1-43" id="h2-1-43" class="d">-    }
</a><a href="#h2-1-44" id="h2-1-44" class="d">-
</a><a href="#h2-1-45" id="h2-1-45" class="d">-    fn end_bound(&amp;self) -&gt; Bound&lt;&amp;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-1-46" id="h2-1-46" class="d">-        match &amp;self.end {
</a><a href="#h2-1-47" id="h2-1-47" class="d">-            Bound::Included(v) =&gt; Bound::Included(v),
</a><a href="#h2-1-48" id="h2-1-48" class="d">-            Bound::Excluded(v) =&gt; Bound::Excluded(v),
</a><a href="#h2-1-49" id="h2-1-49" class="d">-            Bound::Unbounded =&gt; Bound::Unbounded,
</a><a href="#h2-1-50" id="h2-1-50" class="d">-        }
</a><a href="#h2-1-51" id="h2-1-51" class="d">-    }
</a><a href="#h2-1-52" id="h2-1-52" class="d">-}
</a><a href="#h2-1-53" id="h2-1-53" class="d">-
</a> /// Iterator over a key/value range.
 pub type Scan&lt;&#39;a&gt; = Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; + Send + &#39;a&gt;;
 
<a href="#h2-2" id="h2-2" class="h">@@ -173,8 +127,7 @@ mod tests {
</a>                         (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                         (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
                     ],
<a href="#h2-2-3" id="h2-2-3" class="d">-                    s.scan(Range::from(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()))
</a><a href="#h2-2-4" id="h2-2-4" class="d">-                        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-2-5" id="h2-2-5" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>                 );
                 assert_eq!(
                     vec![
<a href="#h2-3" id="h2-3" class="h">@@ -182,16 +135,13 @@ mod tests {
</a>                         (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                         (b&quot;b&quot;.to_vec(), vec![0x02]),
                     ],
<a href="#h2-3-3" id="h2-3-3" class="d">-                    s.scan(Range::from(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()))
</a><a href="#h2-3-4" id="h2-3-4" class="d">-                        .rev()
</a><a href="#h2-3-5" id="h2-3-5" class="d">-                        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-3-6" id="h2-3-6" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>                 );
 
                 // Inclusive/exclusive ranges
                 assert_eq!(
                     vec![(b&quot;b&quot;.to_vec(), vec![0x02]), (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),],
<a href="#h2-3-12" id="h2-3-12" class="d">-                    s.scan(Range::from(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()))
</a><a href="#h2-3-13" id="h2-3-13" class="d">-                        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-3-14" id="h2-3-14" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>                 );
                 assert_eq!(
                     vec![
<a href="#h2-4" id="h2-4" class="h">@@ -199,18 +149,17 @@ mod tests {
</a>                         (b&quot;ba&quot;.to_vec(), vec![0x02, 0x01]),
                         (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
                     ],
<a href="#h2-4-3" id="h2-4-3" class="d">-                    s.scan(Range::from(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()))
</a><a href="#h2-4-4" id="h2-4-4" class="d">-                        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-4-5" id="h2-4-5" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>                 );
 
                 // Open ranges
                 assert_eq!(
                     vec![(b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]), (b&quot;c&quot;.to_vec(), vec![0x03]),],
<a href="#h2-4-11" id="h2-4-11" class="d">-                    s.scan(Range::from(b&quot;bb&quot;.to_vec()..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-4-12" id="h2-4-12" class="i">+                    s.scan(b&quot;bb&quot;.to_vec()..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>                 );
                 assert_eq!(
                     vec![(b&quot;a&quot;.to_vec(), vec![0x01]), (b&quot;b&quot;.to_vec(), vec![0x02]),],
<a href="#h2-4-16" id="h2-4-16" class="d">-                    s.scan(Range::from(..=b&quot;b&quot;.to_vec())).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-4-17" id="h2-4-17" class="i">+                    s.scan(..=b&quot;b&quot;.to_vec()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>                 );
 
                 // Full range
<a href="#h2-5" id="h2-5" class="h">@@ -222,7 +171,7 @@ mod tests {
</a>                         (b&quot;bb&quot;.to_vec(), vec![0x02, 0x02]),
                         (b&quot;c&quot;.to_vec(), vec![0x03]),
                     ],
<a href="#h2-5-3" id="h2-5-3" class="d">-                    s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h2-5-4" id="h2-5-4" class="i">+                    s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a>                 );
                 Ok(())
             }
<a href="#h2-6" id="h2-6" class="h">@@ -248,16 +197,16 @@ mod tests {
</a>                 }
                 let mut expect = items.clone();
                 expect.sort_by(|a, b| a.0.cmp(&amp;b.0));
<a href="#h2-6-3" id="h2-6-3" class="d">-                assert_eq!(expect, s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h2-6-4" id="h2-6-4" class="i">+                assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a>                 expect.reverse();
<a href="#h2-6-6" id="h2-6-6" class="d">-                assert_eq!(expect, s.scan(Range::from(..)).rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h2-6-7" id="h2-6-7" class="i">+                assert_eq!(expect, s.scan(..).rev().collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a> 
                 // Remove the items
                 for (key, _) in items {
                     s.delete(&amp;key)?;
                     assert_eq!(None, s.get(&amp;key)?);
                 }
<a href="#h2-6-14" id="h2-6-14" class="d">-                assert!(s.scan(Range::from(..)).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a><a href="#h2-6-15" id="h2-6-15" class="i">+                assert!(s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.is_empty());
</a> 
                 Ok(())
             }
<b>diff --git a/<a id="h3" href="../file/src/storage/kv/mvcc.rs.html">src/storage/kv/mvcc.rs</a> b/<a href="../file/src/storage/kv/mvcc.rs.html">src/storage/kv/mvcc.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h3-0-0" id="h3-0-0" class="d">-use super::{encoding, Range, Store};
</a><a href="#h3-0-1" id="h3-0-1" class="i">+use super::{encoding, Store};
</a> use crate::error::{Error, Result};
 
 use serde::{Deserialize, Serialize};
<a href="#h3-1" id="h3-1" class="h">@@ -76,9 +76,7 @@ impl&lt;S: Store&gt; MVCC&lt;S&gt; {
</a>                 None =&gt; 1,
             } - 1,
             txns_active: store
<a href="#h3-1-3" id="h3-1-3" class="d">-                .scan(Range::from(
</a><a href="#h3-1-4" id="h3-1-4" class="d">-                    Key::TxnActive(0).encode()..Key::TxnActive(std::u64::MAX).encode(),
</a><a href="#h3-1-5" id="h3-1-5" class="d">-                ))
</a><a href="#h3-1-6" id="h3-1-6" class="i">+                .scan(Key::TxnActive(0).encode()..Key::TxnActive(std::u64::MAX).encode())
</a>                 .try_fold(0, |count, r| r.map(|_| count + 1))?,
         });
     }
<a href="#h3-2" id="h3-2" class="h">@@ -167,10 +165,10 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>         let mut session = self.store.lock()?;
         if self.mode.mutable() {
             let mut rollback = Vec::new();
<a href="#h3-2-3" id="h3-2-3" class="d">-            let mut scan = session.scan(Range::from(
</a><a href="#h3-2-4" id="h3-2-4" class="i">+            let mut scan = session.scan(
</a>                 Key::TxnUpdate(self.id, vec![].into()).encode()
                     ..Key::TxnUpdate(self.id + 1, vec![].into()).encode(),
<a href="#h3-2-7" id="h3-2-7" class="d">-            ));
</a><a href="#h3-2-8" id="h3-2-8" class="i">+            );
</a>             while let Some((key, _)) = scan.next().transpose()? {
                 match Key::decode(&amp;key)? {
                     Key::TxnUpdate(_, updated_key) =&gt; rollback.push(updated_key.into_owned()),
<a href="#h3-3" id="h3-3" class="h">@@ -195,9 +193,7 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>     pub fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
         let mut session = self.store.lock()?;
         let mut scan = session
<a href="#h3-3-3" id="h3-3-3" class="d">-            .scan(Range::from(
</a><a href="#h3-3-4" id="h3-3-4" class="d">-                Key::Record(key.into(), 0).encode()..=Key::Record(key.into(), self.id).encode(),
</a><a href="#h3-3-5" id="h3-3-5" class="d">-            ))
</a><a href="#h3-3-6" id="h3-3-6" class="i">+            .scan(Key::Record(key.into(), 0).encode()..=Key::Record(key.into(), self.id).encode())
</a>             .rev();
         while let Some((k, v)) = scan.next().transpose()? {
             match Key::decode(&amp;k)? {
<a href="#h3-4" id="h3-4" class="h">@@ -225,9 +221,7 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>             Bound::Unbounded =&gt; Bound::Unbounded,
         };
         // TODO: For now, collect results from the store to not have to deal with lifetimes.
<a href="#h3-4-3" id="h3-4-3" class="d">-        let scan = Box::new(
</a><a href="#h3-4-4" id="h3-4-4" class="d">-            self.store.lock()?.scan(Range::from((start, end))).collect::&lt;Vec&lt;_&gt;&gt;().into_iter(),
</a><a href="#h3-4-5" id="h3-4-5" class="d">-        );
</a><a href="#h3-4-6" id="h3-4-6" class="i">+        let scan = Box::new(self.store.lock()?.scan((start, end)).collect::&lt;Vec&lt;_&gt;&gt;().into_iter());
</a>         Ok(Box::new(Scan::new(scan, self.snapshot.clone())))
     }
 
<a href="#h3-5" id="h3-5" class="h">@@ -271,10 +265,10 @@ impl&lt;S: Store&gt; Transaction&lt;S&gt; {
</a>         // versions that aren&#39;t visible to us.
         let min = self.snapshot.invisible.iter().min().cloned().unwrap_or(self.id + 1);
         let mut scan = session
<a href="#h3-5-3" id="h3-5-3" class="d">-            .scan(Range::from(
</a><a href="#h3-5-4" id="h3-5-4" class="i">+            .scan(
</a>                 Key::Record(key.into(), min).encode()
                     ..=Key::Record(key.into(), std::u64::MAX).encode(),
<a href="#h3-5-7" id="h3-5-7" class="d">-            ))
</a><a href="#h3-5-8" id="h3-5-8" class="i">+            )
</a>             .rev();
         while let Some((k, _)) = scan.next().transpose()? {
             match Key::decode(&amp;k)? {
<a href="#h3-6" id="h3-6" class="h">@@ -346,8 +340,7 @@ impl Snapshot {
</a>     /// Takes a new snapshot, persisting it as `Key::TxnSnapshot(version)`.
     fn take&lt;S: Store&gt;(session: &amp;mut MutexGuard&lt;S&gt;, version: u64) -&gt; Result&lt;Self&gt; {
         let mut snapshot = Self { version, invisible: HashSet::new() };
<a href="#h3-6-3" id="h3-6-3" class="d">-        let mut scan =
</a><a href="#h3-6-4" id="h3-6-4" class="d">-            session.scan(Range::from(Key::TxnActive(0).encode()..Key::TxnActive(version).encode()));
</a><a href="#h3-6-5" id="h3-6-5" class="i">+        let mut scan = session.scan(Key::TxnActive(0).encode()..Key::TxnActive(version).encode());
</a>         while let Some((key, _)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::TxnActive(id) =&gt; snapshot.invisible.insert(id),
</pre>
</div>
</body>
</html>
