<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Remove async for the SQL server/client - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/56c808417171251e6ff0667070fbf42f4a9a0ef8.html">56c808417171251e6ff0667070fbf42f4a9a0ef8</a>
<b>parent</b> <a href="../commit/a1ca9752bade7b0924b484ce288cd043b15877f2.html">a1ca9752bade7b0924b484ce288cd043b15877f2</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun,  7 Apr 2024 21:57:02 +0200

Remove async for the SQL server/client

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">Cargo.lock</a></td><td> | </td><td class="num">92</td><td><span class="i">++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">Cargo.toml</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/bin/toydb.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/bin/toysql.rs</a></td><td> | </td><td class="num">38</td><td><span class="i">++++++++++++++++++</span><span class="d">--------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/bin/workload.rs</a></td><td> | </td><td class="num">342</td><td><span class="i">++++++++++++++++++++++++++++++++</span><span class="d">-----------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/client.rs</a></td><td> | </td><td class="num">95</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/error.rs</a></td><td> | </td><td class="num">30</td><td><span class="i">++++++++++++++++++++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/server.rs</a></td><td> | </td><td class="num">65</td><td><span class="i">+++++++++++++++++++++++++++++++++++</span><span class="d">------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">tests/e2e/client.rs</a></td><td> | </td><td class="num">166</td><td><span class="i">+++++++++++++++++++++++++++++++++++</span><span class="d">--------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">tests/e2e/isolation.rs</a></td><td> | </td><td class="num">143</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">tests/e2e/recovery.rs</a></td><td> | </td><td class="num">44</td><td><span class="i">++++++++++++++++++++++</span><span class="d">----------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">tests/e2e/testcluster.rs</a></td><td> | </td><td class="num">32</td><td><span class="i">+++++++++++++++</span><span class="d">-----------------</span></td></tr>
</table></pre><pre>12 files changed, 499 insertions(+), 552 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/Cargo.lock.html">Cargo.lock</a> b/<a href="../file/Cargo.lock.html">Cargo.lock</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -75,19 +75,6 @@ dependencies = [
</a> ]
 
 [[package]]
<a href="#h0-0-3" id="h0-0-3" class="d">-name = &quot;async-channel&quot;
</a><a href="#h0-0-4" id="h0-0-4" class="d">-version = &quot;2.2.0&quot;
</a><a href="#h0-0-5" id="h0-0-5" class="d">-source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-0-6" id="h0-0-6" class="d">-checksum = &quot;f28243a43d821d11341ab73c80bed182dc015c514b951616cf79bd4af39af0c3&quot;
</a><a href="#h0-0-7" id="h0-0-7" class="d">-dependencies = [
</a><a href="#h0-0-8" id="h0-0-8" class="d">- &quot;concurrent-queue&quot;,
</a><a href="#h0-0-9" id="h0-0-9" class="d">- &quot;event-listener&quot;,
</a><a href="#h0-0-10" id="h0-0-10" class="d">- &quot;event-listener-strategy&quot;,
</a><a href="#h0-0-11" id="h0-0-11" class="d">- &quot;futures-core&quot;,
</a><a href="#h0-0-12" id="h0-0-12" class="d">- &quot;pin-project-lite&quot;,
</a><a href="#h0-0-13" id="h0-0-13" class="d">-]
</a><a href="#h0-0-14" id="h0-0-14" class="d">-
</a><a href="#h0-0-15" id="h0-0-15" class="d">-[[package]]
</a> name = &quot;async-trait&quot;
 version = &quot;0.1.79&quot;
 source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
<a href="#h0-1" id="h0-1" class="h">@@ -305,15 +292,6 @@ source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a> checksum = &quot;acbf1af155f9b9ef647e42cdc158db4b64a1b61f743629225fde6f3e0be2a7c7&quot;
 
 [[package]]
<a href="#h0-1-3" id="h0-1-3" class="d">-name = &quot;concurrent-queue&quot;
</a><a href="#h0-1-4" id="h0-1-4" class="d">-version = &quot;2.4.0&quot;
</a><a href="#h0-1-5" id="h0-1-5" class="d">-source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-1-6" id="h0-1-6" class="d">-checksum = &quot;d16048cd947b08fa32c24458a22f5dc5e835264f689f4f5653210c69fd107363&quot;
</a><a href="#h0-1-7" id="h0-1-7" class="d">-dependencies = [
</a><a href="#h0-1-8" id="h0-1-8" class="d">- &quot;crossbeam-utils&quot;,
</a><a href="#h0-1-9" id="h0-1-9" class="d">-]
</a><a href="#h0-1-10" id="h0-1-10" class="d">-
</a><a href="#h0-1-11" id="h0-1-11" class="d">-[[package]]
</a> name = &quot;config&quot;
 version = &quot;0.14.0&quot;
 source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
<a href="#h0-2" id="h0-2" class="h">@@ -393,6 +371,19 @@ dependencies = [
</a> ]
 
 [[package]]
<a href="#h0-2-3" id="h0-2-3" class="i">+name = &quot;crossbeam&quot;
</a><a href="#h0-2-4" id="h0-2-4" class="i">+version = &quot;0.8.4&quot;
</a><a href="#h0-2-5" id="h0-2-5" class="i">+source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-2-6" id="h0-2-6" class="i">+checksum = &quot;1137cd7e7fc0fb5d3c5a8678be38ec56e819125d8d7907411fe24ccb943faca8&quot;
</a><a href="#h0-2-7" id="h0-2-7" class="i">+dependencies = [
</a><a href="#h0-2-8" id="h0-2-8" class="i">+ &quot;crossbeam-channel&quot;,
</a><a href="#h0-2-9" id="h0-2-9" class="i">+ &quot;crossbeam-deque&quot;,
</a><a href="#h0-2-10" id="h0-2-10" class="i">+ &quot;crossbeam-epoch&quot;,
</a><a href="#h0-2-11" id="h0-2-11" class="i">+ &quot;crossbeam-queue&quot;,
</a><a href="#h0-2-12" id="h0-2-12" class="i">+ &quot;crossbeam-utils&quot;,
</a><a href="#h0-2-13" id="h0-2-13" class="i">+]
</a><a href="#h0-2-14" id="h0-2-14" class="i">+
</a><a href="#h0-2-15" id="h0-2-15" class="i">+[[package]]
</a> name = &quot;crossbeam-channel&quot;
 version = &quot;0.5.12&quot;
 source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
<a href="#h0-3" id="h0-3" class="h">@@ -402,6 +393,34 @@ dependencies = [
</a> ]
 
 [[package]]
<a href="#h0-3-3" id="h0-3-3" class="i">+name = &quot;crossbeam-deque&quot;
</a><a href="#h0-3-4" id="h0-3-4" class="i">+version = &quot;0.8.5&quot;
</a><a href="#h0-3-5" id="h0-3-5" class="i">+source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-3-6" id="h0-3-6" class="i">+checksum = &quot;613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d&quot;
</a><a href="#h0-3-7" id="h0-3-7" class="i">+dependencies = [
</a><a href="#h0-3-8" id="h0-3-8" class="i">+ &quot;crossbeam-epoch&quot;,
</a><a href="#h0-3-9" id="h0-3-9" class="i">+ &quot;crossbeam-utils&quot;,
</a><a href="#h0-3-10" id="h0-3-10" class="i">+]
</a><a href="#h0-3-11" id="h0-3-11" class="i">+
</a><a href="#h0-3-12" id="h0-3-12" class="i">+[[package]]
</a><a href="#h0-3-13" id="h0-3-13" class="i">+name = &quot;crossbeam-epoch&quot;
</a><a href="#h0-3-14" id="h0-3-14" class="i">+version = &quot;0.9.18&quot;
</a><a href="#h0-3-15" id="h0-3-15" class="i">+source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-3-16" id="h0-3-16" class="i">+checksum = &quot;5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e&quot;
</a><a href="#h0-3-17" id="h0-3-17" class="i">+dependencies = [
</a><a href="#h0-3-18" id="h0-3-18" class="i">+ &quot;crossbeam-utils&quot;,
</a><a href="#h0-3-19" id="h0-3-19" class="i">+]
</a><a href="#h0-3-20" id="h0-3-20" class="i">+
</a><a href="#h0-3-21" id="h0-3-21" class="i">+[[package]]
</a><a href="#h0-3-22" id="h0-3-22" class="i">+name = &quot;crossbeam-queue&quot;
</a><a href="#h0-3-23" id="h0-3-23" class="i">+version = &quot;0.3.11&quot;
</a><a href="#h0-3-24" id="h0-3-24" class="i">+source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-3-25" id="h0-3-25" class="i">+checksum = &quot;df0346b5d5e76ac2fe4e327c5fd1118d6be7c51dfb18f9b7922923f287471e35&quot;
</a><a href="#h0-3-26" id="h0-3-26" class="i">+dependencies = [
</a><a href="#h0-3-27" id="h0-3-27" class="i">+ &quot;crossbeam-utils&quot;,
</a><a href="#h0-3-28" id="h0-3-28" class="i">+]
</a><a href="#h0-3-29" id="h0-3-29" class="i">+
</a><a href="#h0-3-30" id="h0-3-30" class="i">+[[package]]
</a> name = &quot;crossbeam-utils&quot;
 version = &quot;0.8.19&quot;
 source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
<a href="#h0-4" id="h0-4" class="h">@@ -566,27 +585,6 @@ dependencies = [
</a> ]
 
 [[package]]
<a href="#h0-4-3" id="h0-4-3" class="d">-name = &quot;event-listener&quot;
</a><a href="#h0-4-4" id="h0-4-4" class="d">-version = &quot;5.3.0&quot;
</a><a href="#h0-4-5" id="h0-4-5" class="d">-source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-4-6" id="h0-4-6" class="d">-checksum = &quot;6d9944b8ca13534cdfb2800775f8dd4902ff3fc75a50101466decadfdf322a24&quot;
</a><a href="#h0-4-7" id="h0-4-7" class="d">-dependencies = [
</a><a href="#h0-4-8" id="h0-4-8" class="d">- &quot;concurrent-queue&quot;,
</a><a href="#h0-4-9" id="h0-4-9" class="d">- &quot;parking&quot;,
</a><a href="#h0-4-10" id="h0-4-10" class="d">- &quot;pin-project-lite&quot;,
</a><a href="#h0-4-11" id="h0-4-11" class="d">-]
</a><a href="#h0-4-12" id="h0-4-12" class="d">-
</a><a href="#h0-4-13" id="h0-4-13" class="d">-[[package]]
</a><a href="#h0-4-14" id="h0-4-14" class="d">-name = &quot;event-listener-strategy&quot;
</a><a href="#h0-4-15" id="h0-4-15" class="d">-version = &quot;0.5.1&quot;
</a><a href="#h0-4-16" id="h0-4-16" class="d">-source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-4-17" id="h0-4-17" class="d">-checksum = &quot;332f51cb23d20b0de8458b86580878211da09bcd4503cb579c225b3d124cabb3&quot;
</a><a href="#h0-4-18" id="h0-4-18" class="d">-dependencies = [
</a><a href="#h0-4-19" id="h0-4-19" class="d">- &quot;event-listener&quot;,
</a><a href="#h0-4-20" id="h0-4-20" class="d">- &quot;pin-project-lite&quot;,
</a><a href="#h0-4-21" id="h0-4-21" class="d">-]
</a><a href="#h0-4-22" id="h0-4-22" class="d">-
</a><a href="#h0-4-23" id="h0-4-23" class="d">-[[package]]
</a> name = &quot;fastrand&quot;
 version = &quot;2.0.2&quot;
 source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
<a href="#h0-5" id="h0-5" class="h">@@ -1055,12 +1053,6 @@ source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a> checksum = &quot;e2355d85b9a3786f481747ced0e0ff2ba35213a1f9bd406ed906554d7af805a1&quot;
 
 [[package]]
<a href="#h0-5-3" id="h0-5-3" class="d">-name = &quot;parking&quot;
</a><a href="#h0-5-4" id="h0-5-4" class="d">-version = &quot;2.2.0&quot;
</a><a href="#h0-5-5" id="h0-5-5" class="d">-source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
</a><a href="#h0-5-6" id="h0-5-6" class="d">-checksum = &quot;bb813b8af86854136c6922af0598d719255ecb2179515e6e7730d468f05c9cae&quot;
</a><a href="#h0-5-7" id="h0-5-7" class="d">-
</a><a href="#h0-5-8" id="h0-5-8" class="d">-[[package]]
</a> name = &quot;parking_lot&quot;
 version = &quot;0.12.1&quot;
 source = &quot;registry+https://github.com/rust-lang/crates.io-index&quot;
<a href="#h0-6" id="h0-6" class="h">@@ -1843,10 +1835,10 @@ dependencies = [
</a> name = &quot;toydb&quot;
 version = &quot;0.1.0&quot;
 dependencies = [
<a href="#h0-6-3" id="h0-6-3" class="d">- &quot;async-channel&quot;,
</a>  &quot;bincode&quot;,
  &quot;clap 4.5.4&quot;,
  &quot;config&quot;,
<a href="#h0-6-7" id="h0-6-7" class="i">+ &quot;crossbeam&quot;,
</a>  &quot;derivative&quot;,
  &quot;escargot&quot;,
  &quot;fs4&quot;,
<b>diff --git a/<a id="h1" href="../file/Cargo.toml.html">Cargo.toml</a> b/<a href="../file/Cargo.toml.html">Cargo.toml</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -10,10 +10,10 @@ default-run = &quot;toydb&quot;
</a> doctest = false
 
 [dependencies]
<a href="#h1-0-3" id="h1-0-3" class="d">-async-channel = &quot;~2.2.0&quot;
</a> bincode = &quot;~1.3.3&quot;
 clap = { version = &quot;~4.5.4&quot;, features = [&quot;cargo&quot;, &quot;derive&quot;] }
 config = &quot;~0.14.0&quot;
<a href="#h1-0-7" id="h1-0-7" class="i">+crossbeam = { version = &quot;0.8.4&quot;, features = [&quot;crossbeam-channel&quot;] }
</a> derivative = &quot;~2.2.0&quot;
 fs4 = &quot;~0.8.1&quot;
 futures = &quot;~0.3.15&quot;
<b>diff --git a/<a id="h2" href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a> b/<a href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -69,7 +69,7 @@ async fn main() -&gt; Result&lt;()&gt; {
</a>     let srv = Server::new(cfg.id, cfg.peers, raft_log, raft_state)?;
 
     let raft_listener = TcpListener::bind(&amp;cfg.listen_raft).await?;
<a href="#h2-0-3" id="h2-0-3" class="d">-    let sql_listener = TcpListener::bind(&amp;cfg.listen_sql).await?;
</a><a href="#h2-0-4" id="h2-0-4" class="i">+    let sql_listener = std::net::TcpListener::bind(&amp;cfg.listen_sql)?;
</a> 
     srv.serve(raft_listener, sql_listener).await
 }
<b>diff --git a/<a id="h3" href="../file/src/bin/toysql.rs.html">src/bin/toysql.rs</a> b/<a href="../file/src/bin/toysql.rs.html">src/bin/toysql.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -14,8 +14,7 @@ use toydb::sql::execution::ResultSet;
</a> use toydb::sql::parser::{Lexer, Token};
 use toydb::Client;
 
<a href="#h3-0-3" id="h3-0-3" class="d">-#[tokio::main]
</a><a href="#h3-0-4" id="h3-0-4" class="d">-async fn main() -&gt; Result&lt;()&gt; {
</a><a href="#h3-0-5" id="h3-0-5" class="i">+fn main() -&gt; Result&lt;()&gt; {
</a>     let opts = clap::command!()
         .name(&quot;toysql&quot;)
         .about(&quot;A ToyDB client.&quot;)
<a href="#h3-1" id="h3-1" class="h">@@ -36,13 +35,12 @@ async fn main() -&gt; Result&lt;()&gt; {
</a>         .get_matches();
 
     let mut toysql =
<a href="#h3-1-3" id="h3-1-3" class="d">-        ToySQL::new(opts.get_one::&lt;String&gt;(&quot;host&quot;).unwrap(), *opts.get_one(&quot;port&quot;).unwrap())
</a><a href="#h3-1-4" id="h3-1-4" class="d">-            .await?;
</a><a href="#h3-1-5" id="h3-1-5" class="i">+        ToySQL::new(opts.get_one::&lt;String&gt;(&quot;host&quot;).unwrap(), *opts.get_one(&quot;port&quot;).unwrap())?;
</a> 
     if let Some(command) = opts.get_one::&lt;&amp;str&gt;(&quot;command&quot;) {
<a href="#h3-1-8" id="h3-1-8" class="d">-        toysql.execute(command).await
</a><a href="#h3-1-9" id="h3-1-9" class="i">+        toysql.execute(command)
</a>     } else {
<a href="#h3-1-11" id="h3-1-11" class="d">-        toysql.run().await
</a><a href="#h3-1-12" id="h3-1-12" class="i">+        toysql.run()
</a>     }
 }
 
<a href="#h3-2" id="h3-2" class="h">@@ -56,9 +54,9 @@ struct ToySQL {
</a> 
 impl ToySQL {
     /// Creates a new ToySQL REPL for the given server host and port
<a href="#h3-2-3" id="h3-2-3" class="d">-    async fn new(host: &amp;str, port: u16) -&gt; Result&lt;Self&gt; {
</a><a href="#h3-2-4" id="h3-2-4" class="i">+    fn new(host: &amp;str, port: u16) -&gt; Result&lt;Self&gt; {
</a>         Ok(Self {
<a href="#h3-2-6" id="h3-2-6" class="d">-            client: Client::new((host, port)).await?,
</a><a href="#h3-2-7" id="h3-2-7" class="i">+            client: Client::new((host, port))?,
</a>             editor: Editor::new()?,
             history_path: std::env::var_os(&quot;HOME&quot;)
                 .map(|home| std::path::Path::new(&amp;home).join(&quot;.toysql.history&quot;)),
<a href="#h3-3" id="h3-3" class="h">@@ -67,18 +65,18 @@ impl ToySQL {
</a>     }
 
     /// Executes a line of input
<a href="#h3-3-3" id="h3-3-3" class="d">-    async fn execute(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; {
</a><a href="#h3-3-4" id="h3-3-4" class="i">+    fn execute(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; {
</a>         if input.starts_with(&#39;!&#39;) {
<a href="#h3-3-6" id="h3-3-6" class="d">-            self.execute_command(input).await
</a><a href="#h3-3-7" id="h3-3-7" class="i">+            self.execute_command(input)
</a>         } else if !input.is_empty() {
<a href="#h3-3-9" id="h3-3-9" class="d">-            self.execute_query(input).await
</a><a href="#h3-3-10" id="h3-3-10" class="i">+            self.execute_query(input)
</a>         } else {
             Ok(())
         }
     }
 
     /// Handles a REPL command (prefixed by !, e.g. !help)
<a href="#h3-3-17" id="h3-3-17" class="d">-    async fn execute_command(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; {
</a><a href="#h3-3-18" id="h3-3-18" class="i">+    fn execute_command(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; {
</a>         let mut input = input.split_ascii_whitespace();
         let command = input.next().ok_or_else(|| Error::Parse(&quot;Expected command.&quot;.to_string()))?;
 
<a href="#h3-4" id="h3-4" class="h">@@ -116,7 +114,7 @@ The following commands are also available:
</a> &quot;#
             ),
             &quot;!status&quot; =&gt; {
<a href="#h3-4-3" id="h3-4-3" class="d">-                let status = self.client.status().await?;
</a><a href="#h3-4-4" id="h3-4-4" class="i">+                let status = self.client.status()?;
</a>                 let mut node_logs = status
                     .raft
                     .last_index
<a href="#h3-5" id="h3-5" class="h">@@ -166,11 +164,11 @@ Storage:   {keys} keys, {logical_size} MB logical, {nodes}x {disk_size} MB disk,
</a>             }
             &quot;!table&quot; =&gt; {
                 let args = getargs(1)?;
<a href="#h3-5-3" id="h3-5-3" class="d">-                println!(&quot;{}&quot;, self.client.get_table(args[0]).await?);
</a><a href="#h3-5-4" id="h3-5-4" class="i">+                println!(&quot;{}&quot;, self.client.get_table(args[0])?);
</a>             }
             &quot;!tables&quot; =&gt; {
                 getargs(0)?;
<a href="#h3-5-8" id="h3-5-8" class="d">-                for table in self.client.list_tables().await? {
</a><a href="#h3-5-9" id="h3-5-9" class="i">+                for table in self.client.list_tables()? {
</a>                     println!(&quot;{}&quot;, table)
                 }
             }
<a href="#h3-6" id="h3-6" class="h">@@ -180,8 +178,8 @@ Storage:   {keys} keys, {logical_size} MB logical, {nodes}x {disk_size} MB disk,
</a>     }
 
     /// Runs a query and displays the results
<a href="#h3-6-3" id="h3-6-3" class="d">-    async fn execute_query(&amp;mut self, query: &amp;str) -&gt; Result&lt;()&gt; {
</a><a href="#h3-6-4" id="h3-6-4" class="d">-        match self.client.execute(query).await? {
</a><a href="#h3-6-5" id="h3-6-5" class="i">+    fn execute_query(&amp;mut self, query: &amp;str) -&gt; Result&lt;()&gt; {
</a><a href="#h3-6-6" id="h3-6-6" class="i">+        match self.client.execute(query)? {
</a>             ResultSet::Begin { version, read_only } =&gt; match read_only {
                 false =&gt; println!(&quot;Began transaction at new version {}&quot;, version),
                 true =&gt; println!(&quot;Began read-only transaction at version {}&quot;, version),
<a href="#h3-7" id="h3-7" class="h">@@ -237,7 +235,7 @@ Storage:   {keys} keys, {logical_size} MB logical, {nodes}x {disk_size} MB disk,
</a>     }
 
     /// Runs the ToySQL REPL
<a href="#h3-7-3" id="h3-7-3" class="d">-    async fn run(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h3-7-4" id="h3-7-4" class="i">+    fn run(&amp;mut self) -&gt; Result&lt;()&gt; {
</a>         if let Some(path) = &amp;self.history_path {
             match self.editor.load_history(path) {
                 Ok(_) =&gt; {}
<a href="#h3-8" id="h3-8" class="h">@@ -252,14 +250,14 @@ Storage:   {keys} keys, {logical_size} MB logical, {nodes}x {disk_size} MB disk,
</a>             rustyline::Cmd::Noop,
         );
 
<a href="#h3-8-3" id="h3-8-3" class="d">-        let status = self.client.status().await?;
</a><a href="#h3-8-4" id="h3-8-4" class="i">+        let status = self.client.status()?;
</a>         println!(
             &quot;Connected to toyDB node \&quot;{}\&quot;. Enter !help for instructions.&quot;,
             status.raft.server
         );
 
         while let Some(input) = self.prompt()? {
<a href="#h3-8-11" id="h3-8-11" class="d">-            match self.execute(&amp;input).await {
</a><a href="#h3-8-12" id="h3-8-12" class="i">+            match self.execute(&amp;input) {
</a>                 Ok(()) =&gt; {}
                 error @ Err(Error::Internal(_)) =&gt; return error,
                 Err(error) =&gt; println!(&quot;Error: {}&quot;, error),
<b>diff --git a/<a id="h4" href="../file/src/bin/workload.rs.html">src/bin/workload.rs</a> b/<a href="../file/src/bin/workload.rs.html">src/bin/workload.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -12,22 +12,21 @@
</a> 
 use clap::Parser;
 use itertools::Itertools;
<a href="#h4-0-3" id="h4-0-3" class="d">-use rand::distributions::Distribution;
</a><a href="#h4-0-4" id="h4-0-4" class="i">+use rand::distributions::Distribution as _;
</a> use rand::rngs::StdRng;
<a href="#h4-0-6" id="h4-0-6" class="d">-use rand::{Rng, SeedableRng};
</a><a href="#h4-0-7" id="h4-0-7" class="i">+use rand::SeedableRng as _;
</a> use std::collections::HashSet;
 use std::io::Write as _;
 use std::time::Duration;
<a href="#h4-0-11" id="h4-0-11" class="d">-use toydb::error::{Error, Result};
</a><a href="#h4-0-12" id="h4-0-12" class="i">+use toydb::error::Result;
</a> use toydb::{Client, ResultSet};
 
<a href="#h4-0-15" id="h4-0-15" class="d">-#[tokio::main]
</a><a href="#h4-0-16" id="h4-0-16" class="d">-async fn main() -&gt; Result&lt;()&gt; {
</a><a href="#h4-0-17" id="h4-0-17" class="i">+fn main() -&gt; Result&lt;()&gt; {
</a>     let Command { runner, subcommand } = Command::parse();
     match subcommand {
<a href="#h4-0-20" id="h4-0-20" class="d">-        Subcommand::Read(read) =&gt; runner.run(read).await,
</a><a href="#h4-0-21" id="h4-0-21" class="d">-        Subcommand::Write(write) =&gt; runner.run(write).await,
</a><a href="#h4-0-22" id="h4-0-22" class="d">-        Subcommand::Bank(bank) =&gt; runner.run(bank).await,
</a><a href="#h4-0-23" id="h4-0-23" class="i">+        Subcommand::Read(read) =&gt; runner.run(read),
</a><a href="#h4-0-24" id="h4-0-24" class="i">+        Subcommand::Write(write) =&gt; runner.run(write),
</a><a href="#h4-0-25" id="h4-0-25" class="i">+        Subcommand::Bank(bank) =&gt; runner.run(bank),
</a>     }
 }
 
<a href="#h4-1" id="h4-1" class="h">@@ -76,9 +75,9 @@ struct Runner {
</a> 
 impl Runner {
     /// Runs the specified workload.
<a href="#h4-1-3" id="h4-1-3" class="d">-    async fn run&lt;W: Workload&gt;(self, workload: W) -&gt; Result&lt;()&gt; {
</a><a href="#h4-1-4" id="h4-1-4" class="i">+    fn run&lt;W: Workload&gt;(self, workload: W) -&gt; Result&lt;()&gt; {
</a>         let mut rng = rand::rngs::StdRng::seed_from_u64(self.seed);
<a href="#h4-1-6" id="h4-1-6" class="d">-        let mut client = Client::new(&amp;self.hosts[0]).await?;
</a><a href="#h4-1-7" id="h4-1-7" class="i">+        let mut client = Client::new(&amp;self.hosts[0])?;
</a> 
         // Set up a histogram recording txn latencies as nanoseconds. The
         // buckets range from 0.001s to 10s.
<a href="#h4-2" id="h4-2" class="h">@@ -89,131 +88,90 @@ impl Runner {
</a>         print!(&quot;Preparing initial dataset... &quot;);
         std::io::stdout().flush()?;
         let start = std::time::Instant::now();
<a href="#h4-2-3" id="h4-2-3" class="d">-        workload.prepare(&amp;mut client, &amp;mut rng).await?;
</a><a href="#h4-2-4" id="h4-2-4" class="i">+        workload.prepare(&amp;mut client, &amp;mut rng)?;
</a>         println!(&quot;done ({:.3}s)&quot;, start.elapsed().as_secs_f64());
 
         // Spawn workers, round robin across hosts.
<a href="#h4-2-8" id="h4-2-8" class="d">-        print!(&quot;Spawning {} workers... &quot;, self.concurrency);
</a><a href="#h4-2-9" id="h4-2-9" class="d">-        std::io::stdout().flush()?;
</a><a href="#h4-2-10" id="h4-2-10" class="d">-        let start = std::time::Instant::now();
</a><a href="#h4-2-11" id="h4-2-11" class="i">+        std::thread::scope(|s| -&gt; Result&lt;()&gt; {
</a><a href="#h4-2-12" id="h4-2-12" class="i">+            print!(&quot;Spawning {} workers... &quot;, self.concurrency);
</a><a href="#h4-2-13" id="h4-2-13" class="i">+            std::io::stdout().flush()?;
</a><a href="#h4-2-14" id="h4-2-14" class="i">+            let start = std::time::Instant::now();
</a><a href="#h4-2-15" id="h4-2-15" class="i">+
</a><a href="#h4-2-16" id="h4-2-16" class="i">+            let (work_tx, work_rx) = crossbeam::channel::bounded(self.concurrency);
</a><a href="#h4-2-17" id="h4-2-17" class="i">+            let (done_tx, done_rx) = crossbeam::channel::bounded::&lt;()&gt;(0);
</a><a href="#h4-2-18" id="h4-2-18" class="i">+
</a><a href="#h4-2-19" id="h4-2-19" class="i">+            for addr in self.hosts.iter().cycle().take(self.concurrency) {
</a><a href="#h4-2-20" id="h4-2-20" class="i">+                let mut client = Client::new(addr)?;
</a><a href="#h4-2-21" id="h4-2-21" class="i">+                let mut recorder = hist.recorder();
</a><a href="#h4-2-22" id="h4-2-22" class="i">+                let work_rx = work_rx.clone();
</a><a href="#h4-2-23" id="h4-2-23" class="i">+                let done_tx = done_tx.clone();
</a><a href="#h4-2-24" id="h4-2-24" class="i">+                s.spawn(move || -&gt; Result&lt;()&gt; {
</a><a href="#h4-2-25" id="h4-2-25" class="i">+                    while let Ok(item) = work_rx.recv() {
</a><a href="#h4-2-26" id="h4-2-26" class="i">+                        let start = std::time::Instant::now();
</a><a href="#h4-2-27" id="h4-2-27" class="i">+                        client.with_retry(|client| W::execute(client, &amp;item))?;
</a><a href="#h4-2-28" id="h4-2-28" class="i">+                        recorder.record(start.elapsed().as_nanos() as u64)?;
</a><a href="#h4-2-29" id="h4-2-29" class="i">+                    }
</a><a href="#h4-2-30" id="h4-2-30" class="i">+                    drop(done_tx); // disconnects done_rx once all workers exit
</a><a href="#h4-2-31" id="h4-2-31" class="i">+                    Ok(())
</a><a href="#h4-2-32" id="h4-2-32" class="i">+                });
</a><a href="#h4-2-33" id="h4-2-33" class="i">+            }
</a><a href="#h4-2-34" id="h4-2-34" class="i">+            drop(done_tx); // drop local copy
</a> 
<a href="#h4-2-36" id="h4-2-36" class="d">-        let mut js = tokio::task::JoinSet::&lt;Result&lt;()&gt;&gt;::new();
</a><a href="#h4-2-37" id="h4-2-37" class="d">-        let (work_tx, work_rx) = async_channel::bounded(self.concurrency);
</a><a href="#h4-2-38" id="h4-2-38" class="d">-
</a><a href="#h4-2-39" id="h4-2-39" class="d">-        for addr in self.hosts.iter().cycle().take(self.concurrency) {
</a><a href="#h4-2-40" id="h4-2-40" class="d">-            let mut client = Client::new(addr).await?;
</a><a href="#h4-2-41" id="h4-2-41" class="d">-            let work_rx = work_rx.clone();
</a><a href="#h4-2-42" id="h4-2-42" class="d">-            let mut recorder = hist.recorder();
</a><a href="#h4-2-43" id="h4-2-43" class="d">-            js.spawn(async move {
</a><a href="#h4-2-44" id="h4-2-44" class="d">-                while let Ok(item) = work_rx.recv().await {
</a><a href="#h4-2-45" id="h4-2-45" class="d">-                    let start = std::time::Instant::now();
</a><a href="#h4-2-46" id="h4-2-46" class="d">-                    Self::execute_with_retry::&lt;W&gt;(&amp;mut client, item).await?;
</a><a href="#h4-2-47" id="h4-2-47" class="d">-                    recorder.record(start.elapsed().as_nanos() as u64)?;
</a><a href="#h4-2-48" id="h4-2-48" class="d">-                }
</a><a href="#h4-2-49" id="h4-2-49" class="d">-                Ok(())
</a><a href="#h4-2-50" id="h4-2-50" class="d">-            });
</a><a href="#h4-2-51" id="h4-2-51" class="d">-        }
</a><a href="#h4-2-52" id="h4-2-52" class="i">+            println!(&quot;done ({:.3}s)&quot;, start.elapsed().as_secs_f64());
</a> 
<a href="#h4-2-54" id="h4-2-54" class="d">-        println!(&quot;done ({:.3}s)&quot;, start.elapsed().as_secs_f64());
</a><a href="#h4-2-55" id="h4-2-55" class="i">+            // Spawn work generator.
</a><a href="#h4-2-56" id="h4-2-56" class="i">+            {
</a><a href="#h4-2-57" id="h4-2-57" class="i">+                println!(&quot;Running workload {}...&quot;, workload);
</a><a href="#h4-2-58" id="h4-2-58" class="i">+                let generator = workload.generate(rng).take(self.count);
</a><a href="#h4-2-59" id="h4-2-59" class="i">+                s.spawn(move || -&gt; Result&lt;()&gt; {
</a><a href="#h4-2-60" id="h4-2-60" class="i">+                    for item in generator {
</a><a href="#h4-2-61" id="h4-2-61" class="i">+                        work_tx.send(item)?;
</a><a href="#h4-2-62" id="h4-2-62" class="i">+                    }
</a><a href="#h4-2-63" id="h4-2-63" class="i">+                    Ok(())
</a><a href="#h4-2-64" id="h4-2-64" class="i">+                });
</a><a href="#h4-2-65" id="h4-2-65" class="i">+            }
</a> 
<a href="#h4-2-67" id="h4-2-67" class="d">-        // Spawn work generator.
</a><a href="#h4-2-68" id="h4-2-68" class="d">-        {
</a><a href="#h4-2-69" id="h4-2-69" class="d">-            println!(&quot;Running workload {}...&quot;, workload);
</a><a href="#h4-2-70" id="h4-2-70" class="d">-            let generator = workload.generate(rng).take(self.count);
</a><a href="#h4-2-71" id="h4-2-71" class="d">-            js.spawn(async move {
</a><a href="#h4-2-72" id="h4-2-72" class="d">-                for item in generator {
</a><a href="#h4-2-73" id="h4-2-73" class="d">-                    work_tx.send(item).await?;
</a><a href="#h4-2-74" id="h4-2-74" class="d">-                }
</a><a href="#h4-2-75" id="h4-2-75" class="d">-                work_tx.close();
</a><a href="#h4-2-76" id="h4-2-76" class="d">-                Ok(())
</a><a href="#h4-2-77" id="h4-2-77" class="d">-            });
</a><a href="#h4-2-78" id="h4-2-78" class="d">-        }
</a><a href="#h4-2-79" id="h4-2-79" class="i">+            // Periodically print stats until all workers are done.
</a><a href="#h4-2-80" id="h4-2-80" class="i">+            let start = std::time::Instant::now();
</a><a href="#h4-2-81" id="h4-2-81" class="i">+            let ticker = crossbeam::channel::tick(Duration::from_secs(1));
</a> 
<a href="#h4-2-83" id="h4-2-83" class="d">-        // Wait for workers to complete, and periodically print stats.
</a><a href="#h4-2-84" id="h4-2-84" class="d">-        let start = std::time::Instant::now();
</a><a href="#h4-2-85" id="h4-2-85" class="d">-        let mut ticker = tokio::time::interval(Duration::from_secs(1));
</a><a href="#h4-2-86" id="h4-2-86" class="d">-        ticker.tick().await; // skip first tick
</a><a href="#h4-2-87" id="h4-2-87" class="i">+            println!();
</a><a href="#h4-2-88" id="h4-2-88" class="i">+            println!(&quot;Time   Progress     Txns      Rate       p50       p90       p99      pMax&quot;);
</a> 
<a href="#h4-2-90" id="h4-2-90" class="d">-        println!();
</a><a href="#h4-2-91" id="h4-2-91" class="d">-        println!(&quot;Time   Progress     Txns      Rate       p50       p90       p99      pMax&quot;);
</a><a href="#h4-2-92" id="h4-2-92" class="d">-
</a><a href="#h4-2-93" id="h4-2-93" class="d">-        let mut print_stats = || {
</a><a href="#h4-2-94" id="h4-2-94" class="d">-            let duration = start.elapsed().as_secs_f64();
</a><a href="#h4-2-95" id="h4-2-95" class="d">-            hist.refresh_timeout(Duration::from_secs(1));
</a><a href="#h4-2-96" id="h4-2-96" class="d">-            println!(
</a><a href="#h4-2-97" id="h4-2-97" class="d">-                &quot;{:&lt;8} {:&gt;5.1}%  {:&gt;7}  {:&gt;6.0}/s  {:&gt;6.1}ms  {:&gt;6.1}ms  {:&gt;6.1}ms  {:&gt;6.1}ms&quot;,
</a><a href="#h4-2-98" id="h4-2-98" class="d">-                format!(&quot;{:.1}s&quot;, duration),
</a><a href="#h4-2-99" id="h4-2-99" class="d">-                hist.len() as f64 / self.count as f64 * 100.0,
</a><a href="#h4-2-100" id="h4-2-100" class="d">-                hist.len(),
</a><a href="#h4-2-101" id="h4-2-101" class="d">-                hist.len() as f64 / duration,
</a><a href="#h4-2-102" id="h4-2-102" class="d">-                Duration::from_nanos(hist.value_at_quantile(0.5)).as_secs_f64() * 1000.0,
</a><a href="#h4-2-103" id="h4-2-103" class="d">-                Duration::from_nanos(hist.value_at_quantile(0.9)).as_secs_f64() * 1000.0,
</a><a href="#h4-2-104" id="h4-2-104" class="d">-                Duration::from_nanos(hist.value_at_quantile(0.99)).as_secs_f64() * 1000.0,
</a><a href="#h4-2-105" id="h4-2-105" class="d">-                Duration::from_nanos(hist.max()).as_secs_f64() * 1000.0,
</a><a href="#h4-2-106" id="h4-2-106" class="d">-            );
</a><a href="#h4-2-107" id="h4-2-107" class="d">-        };
</a><a href="#h4-2-108" id="h4-2-108" class="d">-
</a><a href="#h4-2-109" id="h4-2-109" class="d">-        loop {
</a><a href="#h4-2-110" id="h4-2-110" class="d">-            tokio::select! {
</a><a href="#h4-2-111" id="h4-2-111" class="d">-                // Print stats every second.
</a><a href="#h4-2-112" id="h4-2-112" class="d">-                _ = ticker.tick() =&gt; print_stats(),
</a><a href="#h4-2-113" id="h4-2-113" class="d">-
</a><a href="#h4-2-114" id="h4-2-114" class="d">-                // Check if tasks are done.
</a><a href="#h4-2-115" id="h4-2-115" class="d">-                result = js.join_next() =&gt; match result {
</a><a href="#h4-2-116" id="h4-2-116" class="d">-                    Some(result) =&gt; result??,
</a><a href="#h4-2-117" id="h4-2-117" class="d">-                    None =&gt; break,
</a><a href="#h4-2-118" id="h4-2-118" class="d">-                },
</a><a href="#h4-2-119" id="h4-2-119" class="i">+            while let Err(crossbeam::channel::TryRecvError::Empty) = done_rx.try_recv() {
</a><a href="#h4-2-120" id="h4-2-120" class="i">+                crossbeam::select! {
</a><a href="#h4-2-121" id="h4-2-121" class="i">+                    recv(ticker) -&gt; _ =&gt; {},
</a><a href="#h4-2-122" id="h4-2-122" class="i">+                    recv(done_rx) -&gt; _ =&gt; {},
</a><a href="#h4-2-123" id="h4-2-123" class="i">+                }
</a><a href="#h4-2-124" id="h4-2-124" class="i">+
</a><a href="#h4-2-125" id="h4-2-125" class="i">+                let duration = start.elapsed().as_secs_f64();
</a><a href="#h4-2-126" id="h4-2-126" class="i">+                hist.refresh_timeout(Duration::from_secs(1));
</a><a href="#h4-2-127" id="h4-2-127" class="i">+
</a><a href="#h4-2-128" id="h4-2-128" class="i">+                println!(
</a><a href="#h4-2-129" id="h4-2-129" class="i">+                    &quot;{:&lt;8} {:&gt;5.1}%  {:&gt;7}  {:&gt;6.0}/s  {:&gt;6.1}ms  {:&gt;6.1}ms  {:&gt;6.1}ms  {:&gt;6.1}ms&quot;,
</a><a href="#h4-2-130" id="h4-2-130" class="i">+                    format!(&quot;{:.1}s&quot;, duration),
</a><a href="#h4-2-131" id="h4-2-131" class="i">+                    hist.len() as f64 / self.count as f64 * 100.0,
</a><a href="#h4-2-132" id="h4-2-132" class="i">+                    hist.len(),
</a><a href="#h4-2-133" id="h4-2-133" class="i">+                    hist.len() as f64 / duration,
</a><a href="#h4-2-134" id="h4-2-134" class="i">+                    Duration::from_nanos(hist.value_at_quantile(0.5)).as_secs_f64() * 1000.0,
</a><a href="#h4-2-135" id="h4-2-135" class="i">+                    Duration::from_nanos(hist.value_at_quantile(0.9)).as_secs_f64() * 1000.0,
</a><a href="#h4-2-136" id="h4-2-136" class="i">+                    Duration::from_nanos(hist.value_at_quantile(0.99)).as_secs_f64() * 1000.0,
</a><a href="#h4-2-137" id="h4-2-137" class="i">+                    Duration::from_nanos(hist.max()).as_secs_f64() * 1000.0,
</a><a href="#h4-2-138" id="h4-2-138" class="i">+                );
</a>             }
<a href="#h4-2-140" id="h4-2-140" class="d">-        }
</a><a href="#h4-2-141" id="h4-2-141" class="d">-        print_stats();
</a><a href="#h4-2-142" id="h4-2-142" class="d">-        println!();
</a><a href="#h4-2-143" id="h4-2-143" class="i">+            Ok(())
</a><a href="#h4-2-144" id="h4-2-144" class="i">+        })?;
</a> 
         // Verify the final dataset.
<a href="#h4-2-147" id="h4-2-147" class="i">+        println!();
</a>         print!(&quot;Verifying dataset... &quot;);
         std::io::stdout().flush()?;
         let start = std::time::Instant::now();
<a href="#h4-2-151" id="h4-2-151" class="d">-        workload.verify(&amp;mut client, self.count).await?;
</a><a href="#h4-2-152" id="h4-2-152" class="i">+        workload.verify(&amp;mut client, self.count)?;
</a>         println!(&quot;done ({:.3}s)&quot;, start.elapsed().as_secs_f64());
 
         Ok(())
     }
<a href="#h4-2-157" id="h4-2-157" class="d">-
</a><a href="#h4-2-158" id="h4-2-158" class="d">-    /// Executes a workload item, automatically retrying serialization errors.
</a><a href="#h4-2-159" id="h4-2-159" class="d">-    /// Due to async trait/lifetime hassles, this is on the runner rather than
</a><a href="#h4-2-160" id="h4-2-160" class="d">-    /// the client or workload trait.
</a><a href="#h4-2-161" id="h4-2-161" class="d">-    ///
</a><a href="#h4-2-162" id="h4-2-162" class="d">-    /// TODO: move this to a Client.with_txn() helper once async is removed.
</a><a href="#h4-2-163" id="h4-2-163" class="d">-    async fn execute_with_retry&lt;W: Workload&gt;(client: &amp;mut Client, item: W::Item) -&gt; Result&lt;()&gt; {
</a><a href="#h4-2-164" id="h4-2-164" class="d">-        const MAX_RETRIES: u32 = 10;
</a><a href="#h4-2-165" id="h4-2-165" class="d">-        const MIN_WAIT: u64 = 10;
</a><a href="#h4-2-166" id="h4-2-166" class="d">-        const MAX_WAIT: u64 = 2_000;
</a><a href="#h4-2-167" id="h4-2-167" class="d">-
</a><a href="#h4-2-168" id="h4-2-168" class="d">-        let mut retries: u32 = 0;
</a><a href="#h4-2-169" id="h4-2-169" class="d">-        loop {
</a><a href="#h4-2-170" id="h4-2-170" class="d">-            match W::execute(client, &amp;item).await {
</a><a href="#h4-2-171" id="h4-2-171" class="d">-                Ok(()) =&gt; return Ok(()),
</a><a href="#h4-2-172" id="h4-2-172" class="d">-                Err(Error::Serialization | Error::Abort) if retries &lt; MAX_RETRIES =&gt; {
</a><a href="#h4-2-173" id="h4-2-173" class="d">-                    if client.txn().is_some() {
</a><a href="#h4-2-174" id="h4-2-174" class="d">-                        client.execute(&quot;ROLLBACK&quot;).await?;
</a><a href="#h4-2-175" id="h4-2-175" class="d">-                    }
</a><a href="#h4-2-176" id="h4-2-176" class="d">-
</a><a href="#h4-2-177" id="h4-2-177" class="d">-                    // Use exponential backoff starting at MIN_WAIT doubling up
</a><a href="#h4-2-178" id="h4-2-178" class="d">-                    // to MAX_WAIT, but randomize the wait time in this interval
</a><a href="#h4-2-179" id="h4-2-179" class="d">-                    // to reduce the chance of collisions.
</a><a href="#h4-2-180" id="h4-2-180" class="d">-                    let mut wait = std::cmp::min(MIN_WAIT * 2_u64.pow(retries), MAX_WAIT);
</a><a href="#h4-2-181" id="h4-2-181" class="d">-                    wait = rand::thread_rng().gen_range(MIN_WAIT..=wait);
</a><a href="#h4-2-182" id="h4-2-182" class="d">-                    tokio::time::sleep(std::time::Duration::from_millis(wait)).await;
</a><a href="#h4-2-183" id="h4-2-183" class="d">-                    retries += 1;
</a><a href="#h4-2-184" id="h4-2-184" class="d">-                }
</a><a href="#h4-2-185" id="h4-2-185" class="d">-                Err(e) =&gt; {
</a><a href="#h4-2-186" id="h4-2-186" class="d">-                    if client.txn().is_some() {
</a><a href="#h4-2-187" id="h4-2-187" class="d">-                        client.execute(&quot;ROLLBACK&quot;).await.ok(); // ignore rollback error
</a><a href="#h4-2-188" id="h4-2-188" class="d">-                    }
</a><a href="#h4-2-189" id="h4-2-189" class="d">-                    return Err(e);
</a><a href="#h4-2-190" id="h4-2-190" class="d">-                }
</a><a href="#h4-2-191" id="h4-2-191" class="d">-            }
</a><a href="#h4-2-192" id="h4-2-192" class="d">-        }
</a><a href="#h4-2-193" id="h4-2-193" class="d">-    }
</a> }
 
 /// A workload.
<a href="#h4-3" id="h4-3" class="h">@@ -222,20 +180,17 @@ trait Workload: std::fmt::Display + &#39;static {
</a>     type Item: Send;
 
     /// Prepares the workload by creating initial tables and data.
<a href="#h4-3-3" id="h4-3-3" class="d">-    async fn prepare(&amp;self, client: &amp;mut Client, rng: &amp;mut StdRng) -&gt; Result&lt;()&gt;;
</a><a href="#h4-3-4" id="h4-3-4" class="i">+    fn prepare(&amp;self, client: &amp;mut Client, rng: &amp;mut StdRng) -&gt; Result&lt;()&gt;;
</a> 
     /// Generates work items as an iterator.
     fn generate(&amp;self, rng: StdRng) -&gt; impl Iterator&lt;Item = Self::Item&gt; + Send + &#39;static;
 
     /// Executes a single work item. This will automatically be retried on
     /// certain errors, and must use a transaction where appropriate.
<a href="#h4-3-11" id="h4-3-11" class="d">-    fn execute(
</a><a href="#h4-3-12" id="h4-3-12" class="d">-        client: &amp;mut Client,
</a><a href="#h4-3-13" id="h4-3-13" class="d">-        item: &amp;Self::Item,
</a><a href="#h4-3-14" id="h4-3-14" class="d">-    ) -&gt; impl std::future::Future&lt;Output = Result&lt;()&gt;&gt; + Send;
</a><a href="#h4-3-15" id="h4-3-15" class="i">+    fn execute(client: &amp;mut Client, item: &amp;Self::Item) -&gt; Result&lt;()&gt;;
</a> 
     /// Verifies the dataset after the workload has completed.
<a href="#h4-3-18" id="h4-3-18" class="d">-    async fn verify(&amp;self, _client: &amp;mut Client, _txns: usize) -&gt; Result&lt;()&gt; {
</a><a href="#h4-3-19" id="h4-3-19" class="i">+    fn verify(&amp;self, _client: &amp;mut Client, _txns: usize) -&gt; Result&lt;()&gt; {
</a>         Ok(())
     }
 }
<a href="#h4-4" id="h4-4" class="h">@@ -268,12 +223,10 @@ impl std::fmt::Display for Read {
</a> impl Workload for Read {
     type Item = HashSet&lt;u64&gt;;
 
<a href="#h4-4-3" id="h4-4-3" class="d">-    async fn prepare(&amp;self, client: &amp;mut Client, rng: &amp;mut StdRng) -&gt; Result&lt;()&gt; {
</a><a href="#h4-4-4" id="h4-4-4" class="d">-        client.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h4-4-5" id="h4-4-5" class="d">-        client.execute(r#&quot;DROP TABLE IF EXISTS &quot;read&quot;&quot;#).await?;
</a><a href="#h4-4-6" id="h4-4-6" class="d">-        client
</a><a href="#h4-4-7" id="h4-4-7" class="d">-            .execute(r#&quot;CREATE TABLE &quot;read&quot; (id INT PRIMARY KEY, value STRING NOT NULL)&quot;#)
</a><a href="#h4-4-8" id="h4-4-8" class="d">-            .await?;
</a><a href="#h4-4-9" id="h4-4-9" class="i">+    fn prepare(&amp;self, client: &amp;mut Client, rng: &amp;mut StdRng) -&gt; Result&lt;()&gt; {
</a><a href="#h4-4-10" id="h4-4-10" class="i">+        client.execute(&quot;BEGIN&quot;)?;
</a><a href="#h4-4-11" id="h4-4-11" class="i">+        client.execute(r#&quot;DROP TABLE IF EXISTS &quot;read&quot;&quot;#)?;
</a><a href="#h4-4-12" id="h4-4-12" class="i">+        client.execute(r#&quot;CREATE TABLE &quot;read&quot; (id INT PRIMARY KEY, value STRING NOT NULL)&quot;#)?;
</a> 
         let chars = &amp;mut rand::distributions::Alphanumeric.sample_iter(rng).map(|b| b as char);
         let rows = (1..=self.rows).map(|id| (id, chars.take(self.size).collect::&lt;String&gt;()));
<a href="#h4-5" id="h4-5" class="h">@@ -285,9 +238,9 @@ impl Workload for Read {
</a>             )
         });
         for query in queries {
<a href="#h4-5-3" id="h4-5-3" class="d">-            client.execute(&amp;query).await?;
</a><a href="#h4-5-4" id="h4-5-4" class="i">+            client.execute(&amp;query)?;
</a>         }
<a href="#h4-5-6" id="h4-5-6" class="d">-        client.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h4-5-7" id="h4-5-7" class="i">+        client.execute(&quot;COMMIT&quot;)?;
</a>         Ok(())
     }
 
<a href="#h4-6" id="h4-6" class="h">@@ -299,20 +252,19 @@ impl Workload for Read {
</a>         }
     }
 
<a href="#h4-6-3" id="h4-6-3" class="d">-    async fn execute(client: &amp;mut Client, item: &amp;Self::Item) -&gt; Result&lt;()&gt; {
</a><a href="#h4-6-4" id="h4-6-4" class="i">+    fn execute(client: &amp;mut Client, item: &amp;Self::Item) -&gt; Result&lt;()&gt; {
</a>         let batch_size = item.len();
         let query = format!(
             r#&quot;SELECT * FROM &quot;read&quot; WHERE {}&quot;#,
             item.iter().map(|id| format!(&quot;id = {}&quot;, id)).join(&quot; OR &quot;)
         );
<a href="#h4-6-10" id="h4-6-10" class="d">-        let rows = client.execute(&amp;query).await?.into_rows()?;
</a><a href="#h4-6-11" id="h4-6-11" class="i">+        let rows = client.execute(&amp;query)?.into_rows()?;
</a>         assert_eq!(rows.count(), batch_size, &quot;Unexpected row count&quot;);
         Ok(())
     }
 
<a href="#h4-6-16" id="h4-6-16" class="d">-    async fn verify(&amp;self, client: &amp;mut Client, _: usize) -&gt; Result&lt;()&gt; {
</a><a href="#h4-6-17" id="h4-6-17" class="d">-        let count =
</a><a href="#h4-6-18" id="h4-6-18" class="d">-            client.execute(r#&quot;SELECT COUNT(*) FROM &quot;read&quot;&quot;#).await?.into_value()?.integer()?;
</a><a href="#h4-6-19" id="h4-6-19" class="i">+    fn verify(&amp;self, client: &amp;mut Client, _: usize) -&gt; Result&lt;()&gt; {
</a><a href="#h4-6-20" id="h4-6-20" class="i">+        let count = client.execute(r#&quot;SELECT COUNT(*) FROM &quot;read&quot;&quot;#)?.into_value()?.integer()?;
</a>         assert_eq!(count as u64, self.rows, &quot;Unexpected row count&quot;);
         Ok(())
     }
<a href="#h4-7" id="h4-7" class="h">@@ -365,13 +317,11 @@ impl std::fmt::Display for Write {
</a> impl Workload for Write {
     type Item = Vec&lt;(u64, String)&gt;;
 
<a href="#h4-7-3" id="h4-7-3" class="d">-    async fn prepare(&amp;self, client: &amp;mut Client, _: &amp;mut StdRng) -&gt; Result&lt;()&gt; {
</a><a href="#h4-7-4" id="h4-7-4" class="d">-        client.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h4-7-5" id="h4-7-5" class="d">-        client.execute(r#&quot;DROP TABLE IF EXISTS &quot;write&quot;&quot;#).await?;
</a><a href="#h4-7-6" id="h4-7-6" class="d">-        client
</a><a href="#h4-7-7" id="h4-7-7" class="d">-            .execute(r#&quot;CREATE TABLE &quot;write&quot; (id INT PRIMARY KEY, value STRING NOT NULL)&quot;#)
</a><a href="#h4-7-8" id="h4-7-8" class="d">-            .await?;
</a><a href="#h4-7-9" id="h4-7-9" class="d">-        client.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h4-7-10" id="h4-7-10" class="i">+    fn prepare(&amp;self, client: &amp;mut Client, _: &amp;mut StdRng) -&gt; Result&lt;()&gt; {
</a><a href="#h4-7-11" id="h4-7-11" class="i">+        client.execute(&quot;BEGIN&quot;)?;
</a><a href="#h4-7-12" id="h4-7-12" class="i">+        client.execute(r#&quot;DROP TABLE IF EXISTS &quot;write&quot;&quot;#)?;
</a><a href="#h4-7-13" id="h4-7-13" class="i">+        client.execute(r#&quot;CREATE TABLE &quot;write&quot; (id INT PRIMARY KEY, value STRING NOT NULL)&quot;#)?;
</a><a href="#h4-7-14" id="h4-7-14" class="i">+        client.execute(&quot;COMMIT&quot;)?;
</a>         Ok(())
     }
 
<a href="#h4-8" id="h4-8" class="h">@@ -379,13 +329,13 @@ impl Workload for Write {
</a>         WriteGenerator { next_id: 1, size: self.size, batch: self.batch, rng }
     }
 
<a href="#h4-8-3" id="h4-8-3" class="d">-    async fn execute(client: &amp;mut Client, item: &amp;Self::Item) -&gt; Result&lt;()&gt; {
</a><a href="#h4-8-4" id="h4-8-4" class="i">+    fn execute(client: &amp;mut Client, item: &amp;Self::Item) -&gt; Result&lt;()&gt; {
</a>         let batch_size = item.len();
         let query = format!(
             r#&quot;INSERT INTO &quot;write&quot; (id, value) VALUES {}&quot;#,
             item.iter().map(|(id, value)| format!(&quot;({}, &#39;{}&#39;)&quot;, id, value)).join(&quot;, &quot;)
         );
<a href="#h4-8-10" id="h4-8-10" class="d">-        if let ResultSet::Create { count } = client.execute(&amp;query).await? {
</a><a href="#h4-8-11" id="h4-8-11" class="i">+        if let ResultSet::Create { count } = client.execute(&amp;query)? {
</a>             assert_eq!(count as usize, batch_size, &quot;Unexpected row count&quot;);
         } else {
             panic!(&quot;Unexpected result&quot;)
<a href="#h4-9" id="h4-9" class="h">@@ -393,9 +343,8 @@ impl Workload for Write {
</a>         Ok(())
     }
 
<a href="#h4-9-3" id="h4-9-3" class="d">-    async fn verify(&amp;self, client: &amp;mut Client, txns: usize) -&gt; Result&lt;()&gt; {
</a><a href="#h4-9-4" id="h4-9-4" class="d">-        let count =
</a><a href="#h4-9-5" id="h4-9-5" class="d">-            client.execute(r#&quot;SELECT COUNT(*) FROM &quot;write&quot;&quot;#).await?.into_value()?.integer()?;
</a><a href="#h4-9-6" id="h4-9-6" class="i">+    fn verify(&amp;self, client: &amp;mut Client, txns: usize) -&gt; Result&lt;()&gt; {
</a><a href="#h4-9-7" id="h4-9-7" class="i">+        let count = client.execute(r#&quot;SELECT COUNT(*) FROM &quot;write&quot;&quot;#)?.into_value()?.integer()?;
</a>         assert_eq!(count as usize, txns * self.batch, &quot;Unexpected row count&quot;);
         Ok(())
     }
<a href="#h4-10" id="h4-10" class="h">@@ -460,47 +409,39 @@ impl std::fmt::Display for Bank {
</a> impl Workload for Bank {
     type Item = (u64, u64, u64); // from,to,amount
 
<a href="#h4-10-3" id="h4-10-3" class="d">-    async fn prepare(&amp;self, client: &amp;mut Client, rng: &amp;mut StdRng) -&gt; Result&lt;()&gt; {
</a><a href="#h4-10-4" id="h4-10-4" class="i">+    fn prepare(&amp;self, client: &amp;mut Client, rng: &amp;mut StdRng) -&gt; Result&lt;()&gt; {
</a>         let petnames = petname::Petnames::default();
<a href="#h4-10-6" id="h4-10-6" class="d">-        client.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h4-10-7" id="h4-10-7" class="d">-        client.execute(&quot;DROP TABLE IF EXISTS account&quot;).await?;
</a><a href="#h4-10-8" id="h4-10-8" class="d">-        client.execute(&quot;DROP TABLE IF EXISTS customer&quot;).await?;
</a><a href="#h4-10-9" id="h4-10-9" class="d">-        client
</a><a href="#h4-10-10" id="h4-10-10" class="d">-            .execute(
</a><a href="#h4-10-11" id="h4-10-11" class="d">-                &quot;CREATE TABLE customer (
</a><a href="#h4-10-12" id="h4-10-12" class="i">+        client.execute(&quot;BEGIN&quot;)?;
</a><a href="#h4-10-13" id="h4-10-13" class="i">+        client.execute(&quot;DROP TABLE IF EXISTS account&quot;)?;
</a><a href="#h4-10-14" id="h4-10-14" class="i">+        client.execute(&quot;DROP TABLE IF EXISTS customer&quot;)?;
</a><a href="#h4-10-15" id="h4-10-15" class="i">+        client.execute(
</a><a href="#h4-10-16" id="h4-10-16" class="i">+            &quot;CREATE TABLE customer (
</a>                     id INTEGER PRIMARY KEY,
                     name STRING NOT NULL
                 )&quot;,
<a href="#h4-10-20" id="h4-10-20" class="d">-            )
</a><a href="#h4-10-21" id="h4-10-21" class="d">-            .await?;
</a><a href="#h4-10-22" id="h4-10-22" class="d">-        client
</a><a href="#h4-10-23" id="h4-10-23" class="d">-            .execute(
</a><a href="#h4-10-24" id="h4-10-24" class="d">-                &quot;CREATE TABLE account (
</a><a href="#h4-10-25" id="h4-10-25" class="i">+        )?;
</a><a href="#h4-10-26" id="h4-10-26" class="i">+        client.execute(
</a><a href="#h4-10-27" id="h4-10-27" class="i">+            &quot;CREATE TABLE account (
</a>                     id INTEGER PRIMARY KEY,
                     customer_id INTEGER NOT NULL INDEX REFERENCES customer,
                     balance INTEGER NOT NULL
                 )&quot;,
<a href="#h4-10-32" id="h4-10-32" class="d">-            )
</a><a href="#h4-10-33" id="h4-10-33" class="d">-            .await?;
</a><a href="#h4-10-34" id="h4-10-34" class="d">-        client
</a><a href="#h4-10-35" id="h4-10-35" class="d">-            .execute(&amp;format!(
</a><a href="#h4-10-36" id="h4-10-36" class="d">-                &quot;INSERT INTO customer VALUES {}&quot;,
</a><a href="#h4-10-37" id="h4-10-37" class="d">-                (1..=self.customers)
</a><a href="#h4-10-38" id="h4-10-38" class="d">-                    .zip(petnames.iter(rng, 3, &quot; &quot;))
</a><a href="#h4-10-39" id="h4-10-39" class="d">-                    .map(|(id, name)| format!(&quot;({}, &#39;{}&#39;)&quot;, id, name))
</a><a href="#h4-10-40" id="h4-10-40" class="d">-                    .join(&quot;, &quot;)
</a><a href="#h4-10-41" id="h4-10-41" class="d">-            ))
</a><a href="#h4-10-42" id="h4-10-42" class="d">-            .await?;
</a><a href="#h4-10-43" id="h4-10-43" class="d">-        client
</a><a href="#h4-10-44" id="h4-10-44" class="d">-            .execute(&amp;format!(
</a><a href="#h4-10-45" id="h4-10-45" class="d">-                &quot;INSERT INTO account VALUES {}&quot;,
</a><a href="#h4-10-46" id="h4-10-46" class="d">-                (1..=self.customers)
</a><a href="#h4-10-47" id="h4-10-47" class="d">-                    .flat_map(|c| (1..=self.accounts).map(move |a| (c, (c-1)*self.accounts + a)))
</a><a href="#h4-10-48" id="h4-10-48" class="d">-                    .map(|(c, a)| (format!(&quot;({}, {}, {})&quot;, a, c, self.balance)))
</a><a href="#h4-10-49" id="h4-10-49" class="d">-                    .join(&quot;, &quot;)
</a><a href="#h4-10-50" id="h4-10-50" class="d">-            ))
</a><a href="#h4-10-51" id="h4-10-51" class="d">-            .await?;
</a><a href="#h4-10-52" id="h4-10-52" class="d">-        client.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h4-10-53" id="h4-10-53" class="i">+        )?;
</a><a href="#h4-10-54" id="h4-10-54" class="i">+        client.execute(&amp;format!(
</a><a href="#h4-10-55" id="h4-10-55" class="i">+            &quot;INSERT INTO customer VALUES {}&quot;,
</a><a href="#h4-10-56" id="h4-10-56" class="i">+            (1..=self.customers)
</a><a href="#h4-10-57" id="h4-10-57" class="i">+                .zip(petnames.iter(rng, 3, &quot; &quot;))
</a><a href="#h4-10-58" id="h4-10-58" class="i">+                .map(|(id, name)| format!(&quot;({}, &#39;{}&#39;)&quot;, id, name))
</a><a href="#h4-10-59" id="h4-10-59" class="i">+                .join(&quot;, &quot;)
</a><a href="#h4-10-60" id="h4-10-60" class="i">+        ))?;
</a><a href="#h4-10-61" id="h4-10-61" class="i">+        client.execute(&amp;format!(
</a><a href="#h4-10-62" id="h4-10-62" class="i">+            &quot;INSERT INTO account VALUES {}&quot;,
</a><a href="#h4-10-63" id="h4-10-63" class="i">+            (1..=self.customers)
</a><a href="#h4-10-64" id="h4-10-64" class="i">+                .flat_map(|c| (1..=self.accounts).map(move |a| (c, (c - 1) * self.accounts + a)))
</a><a href="#h4-10-65" id="h4-10-65" class="i">+                .map(|(c, a)| (format!(&quot;({}, {}, {})&quot;, a, c, self.balance)))
</a><a href="#h4-10-66" id="h4-10-66" class="i">+                .join(&quot;, &quot;)
</a><a href="#h4-10-67" id="h4-10-67" class="i">+        ))?;
</a><a href="#h4-10-68" id="h4-10-68" class="i">+        client.execute(&quot;COMMIT&quot;)?;
</a>         Ok(())
     }
 
<a href="#h4-11" id="h4-11" class="h">@@ -516,10 +457,10 @@ impl Workload for Bank {
</a>             .filter(|(from, to, _)| from != to)
     }
 
<a href="#h4-11-3" id="h4-11-3" class="d">-    async fn execute(client: &amp;mut Client, item: &amp;Self::Item) -&gt; Result&lt;()&gt; {
</a><a href="#h4-11-4" id="h4-11-4" class="i">+    fn execute(client: &amp;mut Client, item: &amp;Self::Item) -&gt; Result&lt;()&gt; {
</a>         let (from, to, mut amount) = item;
 
<a href="#h4-11-7" id="h4-11-7" class="d">-        client.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h4-11-8" id="h4-11-8" class="i">+        client.execute(&quot;BEGIN&quot;)?;
</a> 
         let mut row = client
             .execute(&amp;format!(
<a href="#h4-12" id="h4-12" class="h">@@ -529,8 +470,7 @@ impl Workload for Bank {
</a>                         ORDER BY a.balance DESC
                         LIMIT 1&quot;,
                 from
<a href="#h4-12-3" id="h4-12-3" class="d">-            ))
</a><a href="#h4-12-4" id="h4-12-4" class="d">-            .await?
</a><a href="#h4-12-5" id="h4-12-5" class="i">+            ))?
</a>             .into_row()?;
         let from_balance = row.pop().unwrap().integer()?;
         let from_account = row.pop().unwrap().integer()?;
<a href="#h4-13" id="h4-13" class="h">@@ -544,36 +484,30 @@ impl Workload for Bank {
</a>                         ORDER BY a.balance ASC
                         LIMIT 1&quot;,
                 to
<a href="#h4-13-3" id="h4-13-3" class="d">-            ))
</a><a href="#h4-13-4" id="h4-13-4" class="d">-            .await?
</a><a href="#h4-13-5" id="h4-13-5" class="i">+            ))?
</a>             .into_value()?
             .integer()?;
 
<a href="#h4-13-9" id="h4-13-9" class="d">-        client
</a><a href="#h4-13-10" id="h4-13-10" class="d">-            .execute(&amp;format!(
</a><a href="#h4-13-11" id="h4-13-11" class="d">-                &quot;UPDATE account SET balance = balance - {} WHERE id = {}&quot;,
</a><a href="#h4-13-12" id="h4-13-12" class="d">-                amount, from_account,
</a><a href="#h4-13-13" id="h4-13-13" class="d">-            ))
</a><a href="#h4-13-14" id="h4-13-14" class="d">-            .await?;
</a><a href="#h4-13-15" id="h4-13-15" class="d">-        client
</a><a href="#h4-13-16" id="h4-13-16" class="d">-            .execute(&amp;format!(
</a><a href="#h4-13-17" id="h4-13-17" class="d">-                &quot;UPDATE account SET balance = balance + {} WHERE id = {}&quot;,
</a><a href="#h4-13-18" id="h4-13-18" class="d">-                amount, to_account,
</a><a href="#h4-13-19" id="h4-13-19" class="d">-            ))
</a><a href="#h4-13-20" id="h4-13-20" class="d">-            .await?;
</a><a href="#h4-13-21" id="h4-13-21" class="i">+        client.execute(&amp;format!(
</a><a href="#h4-13-22" id="h4-13-22" class="i">+            &quot;UPDATE account SET balance = balance - {} WHERE id = {}&quot;,
</a><a href="#h4-13-23" id="h4-13-23" class="i">+            amount, from_account,
</a><a href="#h4-13-24" id="h4-13-24" class="i">+        ))?;
</a><a href="#h4-13-25" id="h4-13-25" class="i">+        client.execute(&amp;format!(
</a><a href="#h4-13-26" id="h4-13-26" class="i">+            &quot;UPDATE account SET balance = balance + {} WHERE id = {}&quot;,
</a><a href="#h4-13-27" id="h4-13-27" class="i">+            amount, to_account,
</a><a href="#h4-13-28" id="h4-13-28" class="i">+        ))?;
</a> 
<a href="#h4-13-30" id="h4-13-30" class="d">-        client.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h4-13-31" id="h4-13-31" class="i">+        client.execute(&quot;COMMIT&quot;)?;
</a> 
         Ok(())
     }
 
<a href="#h4-13-36" id="h4-13-36" class="d">-    async fn verify(&amp;self, client: &amp;mut Client, _: usize) -&gt; Result&lt;()&gt; {
</a><a href="#h4-13-37" id="h4-13-37" class="i">+    fn verify(&amp;self, client: &amp;mut Client, _: usize) -&gt; Result&lt;()&gt; {
</a>         let balance =
<a href="#h4-13-39" id="h4-13-39" class="d">-            client.execute(&quot;SELECT SUM(balance) FROM account&quot;).await?.into_value()?.integer()?;
</a><a href="#h4-13-40" id="h4-13-40" class="i">+            client.execute(&quot;SELECT SUM(balance) FROM account&quot;)?.into_value()?.integer()?;
</a>         assert_eq!(balance as u64, self.customers * self.accounts * self.balance);
         let negative = client
<a href="#h4-13-43" id="h4-13-43" class="d">-            .execute(&quot;SELECT COUNT(*) FROM account WHERE balance &lt; 0&quot;)
</a><a href="#h4-13-44" id="h4-13-44" class="d">-            .await?
</a><a href="#h4-13-45" id="h4-13-45" class="i">+            .execute(&quot;SELECT COUNT(*) FROM account WHERE balance &lt; 0&quot;)?
</a>             .into_value()?
             .integer()?;
         assert_eq!(negative, 0);
<b>diff --git a/<a id="h5" href="../file/src/client.rs.html">src/client.rs</a> b/<a href="../file/src/client.rs.html">src/client.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,59 +1,41 @@
</a><a href="#h5-0-0" id="h5-0-0" class="i">+use crate::encoding::bincode;
</a> use crate::error::{Error, Result};
 use crate::server::{Request, Response};
 use crate::sql::engine::Status;
 use crate::sql::execution::ResultSet;
 use crate::sql::schema::Table;
 
<a href="#h5-0-7" id="h5-0-7" class="d">-use futures::sink::SinkExt as _;
</a><a href="#h5-0-8" id="h5-0-8" class="d">-use futures::stream::TryStreamExt as _;
</a><a href="#h5-0-9" id="h5-0-9" class="d">-use tokio::net::{TcpStream, ToSocketAddrs};
</a><a href="#h5-0-10" id="h5-0-10" class="d">-use tokio_util::codec::{Framed, LengthDelimitedCodec};
</a><a href="#h5-0-11" id="h5-0-11" class="d">-
</a><a href="#h5-0-12" id="h5-0-12" class="d">-type Connection = tokio_serde::Framed&lt;
</a><a href="#h5-0-13" id="h5-0-13" class="d">-    Framed&lt;TcpStream, LengthDelimitedCodec&gt;,
</a><a href="#h5-0-14" id="h5-0-14" class="d">-    Result&lt;Response&gt;,
</a><a href="#h5-0-15" id="h5-0-15" class="d">-    Request,
</a><a href="#h5-0-16" id="h5-0-16" class="d">-    tokio_serde::formats::Bincode&lt;Result&lt;Response&gt;, Request&gt;,
</a><a href="#h5-0-17" id="h5-0-17" class="d">-&gt;;
</a><a href="#h5-0-18" id="h5-0-18" class="i">+use rand::Rng;
</a> 
 /// A toyDB client
 pub struct Client {
<a href="#h5-0-22" id="h5-0-22" class="d">-    conn: Connection,
</a><a href="#h5-0-23" id="h5-0-23" class="i">+    conn: std::net::TcpStream,
</a>     txn: Option&lt;(u64, bool)&gt;,
 }
 
 impl Client {
     /// Creates a new client
<a href="#h5-0-29" id="h5-0-29" class="d">-    pub async fn new&lt;A: ToSocketAddrs&gt;(addr: A) -&gt; Result&lt;Self&gt; {
</a><a href="#h5-0-30" id="h5-0-30" class="d">-        Ok(Self {
</a><a href="#h5-0-31" id="h5-0-31" class="d">-            conn: tokio_serde::Framed::new(
</a><a href="#h5-0-32" id="h5-0-32" class="d">-                Framed::new(TcpStream::connect(addr).await?, LengthDelimitedCodec::new()),
</a><a href="#h5-0-33" id="h5-0-33" class="d">-                tokio_serde::formats::Bincode::default(),
</a><a href="#h5-0-34" id="h5-0-34" class="d">-            ),
</a><a href="#h5-0-35" id="h5-0-35" class="d">-            txn: None,
</a><a href="#h5-0-36" id="h5-0-36" class="d">-        })
</a><a href="#h5-0-37" id="h5-0-37" class="i">+    pub fn new(addr: impl std::net::ToSocketAddrs) -&gt; Result&lt;Self&gt; {
</a><a href="#h5-0-38" id="h5-0-38" class="i">+        Ok(Self { conn: std::net::TcpStream::connect(addr)?, txn: None })
</a>     }
 
     /// Call a server method
<a href="#h5-0-42" id="h5-0-42" class="d">-    async fn call(&amp;mut self, request: Request) -&gt; Result&lt;Response&gt; {
</a><a href="#h5-0-43" id="h5-0-43" class="d">-        self.conn.send(request).await?;
</a><a href="#h5-0-44" id="h5-0-44" class="d">-        match self.conn.try_next().await? {
</a><a href="#h5-0-45" id="h5-0-45" class="d">-            Some(result) =&gt; result,
</a><a href="#h5-0-46" id="h5-0-46" class="d">-            None =&gt; Err(Error::Internal(&quot;Server disconnected&quot;.into())),
</a><a href="#h5-0-47" id="h5-0-47" class="d">-        }
</a><a href="#h5-0-48" id="h5-0-48" class="i">+    fn call(&amp;mut self, request: Request) -&gt; Result&lt;Response&gt; {
</a><a href="#h5-0-49" id="h5-0-49" class="i">+        bincode::serialize_into(&amp;mut self.conn, &amp;request)?;
</a><a href="#h5-0-50" id="h5-0-50" class="i">+        bincode::deserialize_from(&amp;mut self.conn)?
</a>     }
 
     /// Executes a query
<a href="#h5-0-54" id="h5-0-54" class="d">-    pub async fn execute(&amp;mut self, query: &amp;str) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h5-0-55" id="h5-0-55" class="d">-        let mut resultset = match self.call(Request::Execute(query.into())).await? {
</a><a href="#h5-0-56" id="h5-0-56" class="i">+    pub fn execute(&amp;mut self, query: &amp;str) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h5-0-57" id="h5-0-57" class="i">+        let mut resultset = match self.call(Request::Execute(query.into()))? {
</a>             Response::Execute(rs) =&gt; rs,
             resp =&gt; return Err(Error::Internal(format!(&quot;Unexpected response {:?}&quot;, resp))),
         };
         if let ResultSet::Query { columns, .. } = resultset {
             // FIXME We buffer rows for now to avoid lifetime hassles
             let mut rows = Vec::new();
<a href="#h5-0-64" id="h5-0-64" class="d">-            while let Some(result) = self.conn.try_next().await? {
</a><a href="#h5-0-65" id="h5-0-65" class="d">-                match result? {
</a><a href="#h5-0-66" id="h5-0-66" class="i">+            loop {
</a><a href="#h5-0-67" id="h5-0-67" class="i">+                match bincode::deserialize_from::&lt;_, Result&lt;_&gt;&gt;(&amp;mut self.conn)?? {
</a>                     Response::Row(Some(row)) =&gt; rows.push(row),
                     Response::Row(None) =&gt; break,
                     response =&gt; {
<a href="#h5-1" id="h5-1" class="h">@@ -73,24 +55,24 @@ impl Client {
</a>     }
 
     /// Fetches the table schema as SQL
<a href="#h5-1-3" id="h5-1-3" class="d">-    pub async fn get_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;Table&gt; {
</a><a href="#h5-1-4" id="h5-1-4" class="d">-        match self.call(Request::GetTable(table.into())).await? {
</a><a href="#h5-1-5" id="h5-1-5" class="i">+    pub fn get_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;Table&gt; {
</a><a href="#h5-1-6" id="h5-1-6" class="i">+        match self.call(Request::GetTable(table.into()))? {
</a>             Response::GetTable(t) =&gt; Ok(t),
             resp =&gt; Err(Error::Value(format!(&quot;Unexpected response: {:?}&quot;, resp))),
         }
     }
 
     /// Lists database tables
<a href="#h5-1-13" id="h5-1-13" class="d">-    pub async fn list_tables(&amp;mut self) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
</a><a href="#h5-1-14" id="h5-1-14" class="d">-        match self.call(Request::ListTables).await? {
</a><a href="#h5-1-15" id="h5-1-15" class="i">+    pub fn list_tables(&amp;mut self) -&gt; Result&lt;Vec&lt;String&gt;&gt; {
</a><a href="#h5-1-16" id="h5-1-16" class="i">+        match self.call(Request::ListTables)? {
</a>             Response::ListTables(t) =&gt; Ok(t),
             resp =&gt; Err(Error::Value(format!(&quot;Unexpected response: {:?}&quot;, resp))),
         }
     }
 
     /// Checks server status
<a href="#h5-1-23" id="h5-1-23" class="d">-    pub async fn status(&amp;mut self) -&gt; Result&lt;Status&gt; {
</a><a href="#h5-1-24" id="h5-1-24" class="d">-        match self.call(Request::Status).await? {
</a><a href="#h5-1-25" id="h5-1-25" class="i">+    pub fn status(&amp;mut self) -&gt; Result&lt;Status&gt; {
</a><a href="#h5-1-26" id="h5-1-26" class="i">+        match self.call(Request::Status)? {
</a>             Response::Status(s) =&gt; Ok(s),
             resp =&gt; Err(Error::Value(format!(&quot;Unexpected response: {:?}&quot;, resp))),
         }
<a href="#h5-2" id="h5-2" class="h">@@ -100,4 +82,45 @@ impl Client {
</a>     pub fn txn(&amp;self) -&gt; Option&lt;(u64, bool)&gt; {
         self.txn
     }
<a href="#h5-2-3" id="h5-2-3" class="i">+
</a><a href="#h5-2-4" id="h5-2-4" class="i">+    /// Runs the given closure, automatically retrying serialization and abort
</a><a href="#h5-2-5" id="h5-2-5" class="i">+    /// errors. If a transaction is open following an error, it is automatically
</a><a href="#h5-2-6" id="h5-2-6" class="i">+    /// rolled back. It is the caller&#39;s responsibility to use a transaction
</a><a href="#h5-2-7" id="h5-2-7" class="i">+    /// in the closure where appropriate (i.e. when it is not idempotent).
</a><a href="#h5-2-8" id="h5-2-8" class="i">+    ///
</a><a href="#h5-2-9" id="h5-2-9" class="i">+    /// TODO: test this.
</a><a href="#h5-2-10" id="h5-2-10" class="i">+    pub fn with_retry&lt;F, T&gt;(&amp;mut self, mut f: F) -&gt; Result&lt;T&gt;
</a><a href="#h5-2-11" id="h5-2-11" class="i">+    where
</a><a href="#h5-2-12" id="h5-2-12" class="i">+        F: FnMut(&amp;mut Client) -&gt; Result&lt;T&gt;,
</a><a href="#h5-2-13" id="h5-2-13" class="i">+    {
</a><a href="#h5-2-14" id="h5-2-14" class="i">+        const MAX_RETRIES: u32 = 10;
</a><a href="#h5-2-15" id="h5-2-15" class="i">+        const MIN_WAIT: u64 = 10;
</a><a href="#h5-2-16" id="h5-2-16" class="i">+        const MAX_WAIT: u64 = 2_000;
</a><a href="#h5-2-17" id="h5-2-17" class="i">+
</a><a href="#h5-2-18" id="h5-2-18" class="i">+        let mut retries: u32 = 0;
</a><a href="#h5-2-19" id="h5-2-19" class="i">+        loop {
</a><a href="#h5-2-20" id="h5-2-20" class="i">+            match f(self) {
</a><a href="#h5-2-21" id="h5-2-21" class="i">+                Ok(r) =&gt; return Ok(r),
</a><a href="#h5-2-22" id="h5-2-22" class="i">+                Err(Error::Serialization | Error::Abort) if retries &lt; MAX_RETRIES =&gt; {
</a><a href="#h5-2-23" id="h5-2-23" class="i">+                    if self.txn().is_some() {
</a><a href="#h5-2-24" id="h5-2-24" class="i">+                        self.execute(&quot;ROLLBACK&quot;)?;
</a><a href="#h5-2-25" id="h5-2-25" class="i">+                    }
</a><a href="#h5-2-26" id="h5-2-26" class="i">+
</a><a href="#h5-2-27" id="h5-2-27" class="i">+                    // Use exponential backoff starting at MIN_WAIT doubling up
</a><a href="#h5-2-28" id="h5-2-28" class="i">+                    // to MAX_WAIT, but randomize the wait time in this interval
</a><a href="#h5-2-29" id="h5-2-29" class="i">+                    // to reduce the chance of collisions.
</a><a href="#h5-2-30" id="h5-2-30" class="i">+                    let mut wait = std::cmp::min(MIN_WAIT * 2_u64.pow(retries), MAX_WAIT);
</a><a href="#h5-2-31" id="h5-2-31" class="i">+                    wait = rand::thread_rng().gen_range(MIN_WAIT..=wait);
</a><a href="#h5-2-32" id="h5-2-32" class="i">+                    std::thread::sleep(std::time::Duration::from_millis(wait));
</a><a href="#h5-2-33" id="h5-2-33" class="i">+                    retries += 1;
</a><a href="#h5-2-34" id="h5-2-34" class="i">+                }
</a><a href="#h5-2-35" id="h5-2-35" class="i">+                Err(e) =&gt; {
</a><a href="#h5-2-36" id="h5-2-36" class="i">+                    if self.txn().is_some() {
</a><a href="#h5-2-37" id="h5-2-37" class="i">+                        self.execute(&quot;ROLLBACK&quot;).ok(); // ignore rollback error
</a><a href="#h5-2-38" id="h5-2-38" class="i">+                    }
</a><a href="#h5-2-39" id="h5-2-39" class="i">+                    return Err(e);
</a><a href="#h5-2-40" id="h5-2-40" class="i">+                }
</a><a href="#h5-2-41" id="h5-2-41" class="i">+            }
</a><a href="#h5-2-42" id="h5-2-42" class="i">+        }
</a><a href="#h5-2-43" id="h5-2-43" class="i">+    }
</a> }
<b>diff --git a/<a id="h6" href="../file/src/error.rs.html">src/error.rs</a> b/<a href="../file/src/error.rs.html">src/error.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -43,12 +43,6 @@ impl serde::de::Error for Error {
</a>     }
 }
 
<a href="#h6-0-3" id="h6-0-3" class="d">-impl&lt;T&gt; From&lt;async_channel::SendError&lt;T&gt;&gt; for Error {
</a><a href="#h6-0-4" id="h6-0-4" class="d">-    fn from(err: async_channel::SendError&lt;T&gt;) -&gt; Self {
</a><a href="#h6-0-5" id="h6-0-5" class="d">-        Error::Internal(err.to_string())
</a><a href="#h6-0-6" id="h6-0-6" class="d">-    }
</a><a href="#h6-0-7" id="h6-0-7" class="d">-}
</a><a href="#h6-0-8" id="h6-0-8" class="d">-
</a> impl From&lt;Box&lt;bincode::ErrorKind&gt;&gt; for Error {
     fn from(err: Box&lt;bincode::ErrorKind&gt;) -&gt; Self {
         Error::Internal(err.to_string())
<a href="#h6-1" id="h6-1" class="h">@@ -61,6 +55,30 @@ impl From&lt;config::ConfigError&gt; for Error {
</a>     }
 }
 
<a href="#h6-1-3" id="h6-1-3" class="i">+impl From&lt;crossbeam::channel::RecvError&gt; for Error {
</a><a href="#h6-1-4" id="h6-1-4" class="i">+    fn from(err: crossbeam::channel::RecvError) -&gt; Self {
</a><a href="#h6-1-5" id="h6-1-5" class="i">+        Error::Internal(err.to_string())
</a><a href="#h6-1-6" id="h6-1-6" class="i">+    }
</a><a href="#h6-1-7" id="h6-1-7" class="i">+}
</a><a href="#h6-1-8" id="h6-1-8" class="i">+
</a><a href="#h6-1-9" id="h6-1-9" class="i">+impl&lt;T&gt; From&lt;crossbeam::channel::SendError&lt;T&gt;&gt; for Error {
</a><a href="#h6-1-10" id="h6-1-10" class="i">+    fn from(err: crossbeam::channel::SendError&lt;T&gt;) -&gt; Self {
</a><a href="#h6-1-11" id="h6-1-11" class="i">+        Error::Internal(err.to_string())
</a><a href="#h6-1-12" id="h6-1-12" class="i">+    }
</a><a href="#h6-1-13" id="h6-1-13" class="i">+}
</a><a href="#h6-1-14" id="h6-1-14" class="i">+
</a><a href="#h6-1-15" id="h6-1-15" class="i">+impl From&lt;crossbeam::channel::TryRecvError&gt; for Error {
</a><a href="#h6-1-16" id="h6-1-16" class="i">+    fn from(err: crossbeam::channel::TryRecvError) -&gt; Self {
</a><a href="#h6-1-17" id="h6-1-17" class="i">+        Error::Internal(err.to_string())
</a><a href="#h6-1-18" id="h6-1-18" class="i">+    }
</a><a href="#h6-1-19" id="h6-1-19" class="i">+}
</a><a href="#h6-1-20" id="h6-1-20" class="i">+
</a><a href="#h6-1-21" id="h6-1-21" class="i">+impl&lt;T&gt; From&lt;crossbeam::channel::TrySendError&lt;T&gt;&gt; for Error {
</a><a href="#h6-1-22" id="h6-1-22" class="i">+    fn from(err: crossbeam::channel::TrySendError&lt;T&gt;) -&gt; Self {
</a><a href="#h6-1-23" id="h6-1-23" class="i">+        Error::Internal(err.to_string())
</a><a href="#h6-1-24" id="h6-1-24" class="i">+    }
</a><a href="#h6-1-25" id="h6-1-25" class="i">+}
</a><a href="#h6-1-26" id="h6-1-26" class="i">+
</a> impl From&lt;hdrhistogram::CreationError&gt; for Error {
     fn from(err: hdrhistogram::CreationError) -&gt; Self {
         Error::Internal(err.to_string())
<b>diff --git a/<a id="h7" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -1,3 +1,4 @@
</a><a href="#h7-0-0" id="h7-0-0" class="i">+use crate::encoding::bincode;
</a> use crate::error::Result;
 use crate::raft;
 use crate::sql;
<a href="#h7-1" id="h7-1" class="h">@@ -7,14 +8,10 @@ use crate::sql::schema::{Catalog as _, Table};
</a> use crate::sql::types::Row;
 
 use ::log::{debug, error, info};
<a href="#h7-1-3" id="h7-1-3" class="d">-use futures::sink::SinkExt as _;
</a> use serde_derive::{Deserialize, Serialize};
 use std::collections::HashMap;
<a href="#h7-1-6" id="h7-1-6" class="d">-use tokio::net::{TcpListener, TcpStream};
</a><a href="#h7-1-7" id="h7-1-7" class="i">+use tokio::net::TcpListener;
</a> use tokio::sync::mpsc;
<a href="#h7-1-9" id="h7-1-9" class="d">-use tokio_stream::wrappers::TcpListenerStream;
</a><a href="#h7-1-10" id="h7-1-10" class="d">-use tokio_stream::StreamExt as _;
</a><a href="#h7-1-11" id="h7-1-11" class="d">-use tokio_util::codec::{Framed, LengthDelimitedCodec};
</a> 
 /// A toyDB server.
 pub struct Server {
<a href="#h7-2" id="h7-2" class="h">@@ -33,7 +30,11 @@ impl Server {
</a>     }
 
     /// Serves Raft and SQL requests until the returned future is dropped. Consumes the server.
<a href="#h7-2-3" id="h7-2-3" class="d">-    pub async fn serve(self, raft_listener: TcpListener, sql_listener: TcpListener) -&gt; Result&lt;()&gt; {
</a><a href="#h7-2-4" id="h7-2-4" class="i">+    pub async fn serve(
</a><a href="#h7-2-5" id="h7-2-5" class="i">+        self,
</a><a href="#h7-2-6" id="h7-2-6" class="i">+        raft_listener: TcpListener,
</a><a href="#h7-2-7" id="h7-2-7" class="i">+        sql_listener: std::net::TcpListener,
</a><a href="#h7-2-8" id="h7-2-8" class="i">+    ) -&gt; Result&lt;()&gt; {
</a>         info!(
             &quot;Listening on {} (SQL) and {} (Raft)&quot;,
             sql_listener.local_addr()?,
<a href="#h7-3" id="h7-3" class="h">@@ -42,28 +43,32 @@ impl Server {
</a> 
         let (raft_tx, raft_rx) = mpsc::unbounded_channel();
 
<a href="#h7-3-3" id="h7-3-3" class="d">-        tokio::try_join!(
</a><a href="#h7-3-4" id="h7-3-4" class="d">-            self.raft.serve(raft_listener, raft_rx),
</a><a href="#h7-3-5" id="h7-3-5" class="d">-            Self::serve_sql(sql_listener, raft_tx),
</a><a href="#h7-3-6" id="h7-3-6" class="d">-        )?;
</a><a href="#h7-3-7" id="h7-3-7" class="i">+        tokio::task::spawn_blocking(move || Self::serve_sql(sql_listener, raft_tx));
</a><a href="#h7-3-8" id="h7-3-8" class="i">+
</a><a href="#h7-3-9" id="h7-3-9" class="i">+        tokio::try_join!(self.raft.serve(raft_listener, raft_rx))?;
</a>         Ok(())
     }
 
     /// Serves SQL clients.
<a href="#h7-3-14" id="h7-3-14" class="d">-    async fn serve_sql(listener: TcpListener, raft_tx: raft::ClientSender) -&gt; Result&lt;()&gt; {
</a><a href="#h7-3-15" id="h7-3-15" class="d">-        let mut listener = TcpListenerStream::new(listener);
</a><a href="#h7-3-16" id="h7-3-16" class="d">-        while let Some(socket) = listener.try_next().await? {
</a><a href="#h7-3-17" id="h7-3-17" class="d">-            let peer = socket.peer_addr()?;
</a><a href="#h7-3-18" id="h7-3-18" class="d">-            let session = Session::new(sql::engine::Raft::new(raft_tx.clone()));
</a><a href="#h7-3-19" id="h7-3-19" class="d">-            tokio::spawn(async move {
</a><a href="#h7-3-20" id="h7-3-20" class="i">+    fn serve_sql(listener: std::net::TcpListener, raft_tx: raft::ClientSender) {
</a><a href="#h7-3-21" id="h7-3-21" class="i">+        std::thread::scope(|s| loop {
</a><a href="#h7-3-22" id="h7-3-22" class="i">+            let (socket, peer) = match listener.accept() {
</a><a href="#h7-3-23" id="h7-3-23" class="i">+                Ok(r) =&gt; r,
</a><a href="#h7-3-24" id="h7-3-24" class="i">+                Err(err) =&gt; {
</a><a href="#h7-3-25" id="h7-3-25" class="i">+                    error!(&quot;Connection failed: {}&quot;, err);
</a><a href="#h7-3-26" id="h7-3-26" class="i">+                    continue;
</a><a href="#h7-3-27" id="h7-3-27" class="i">+                }
</a><a href="#h7-3-28" id="h7-3-28" class="i">+            };
</a><a href="#h7-3-29" id="h7-3-29" class="i">+            let raft_tx = raft_tx.clone();
</a><a href="#h7-3-30" id="h7-3-30" class="i">+            s.spawn(move || {
</a><a href="#h7-3-31" id="h7-3-31" class="i">+                let session = Session::new(sql::engine::Raft::new(raft_tx));
</a>                 info!(&quot;Client {} connected&quot;, peer);
<a href="#h7-3-33" id="h7-3-33" class="d">-                match session.handle(socket).await {
</a><a href="#h7-3-34" id="h7-3-34" class="i">+                match session.handle(socket) {
</a>                     Ok(()) =&gt; info!(&quot;Client {} disconnected&quot;, peer),
                     Err(err) =&gt; error!(&quot;Client {} error: {}&quot;, peer, err),
                 }
             });
<a href="#h7-3-39" id="h7-3-39" class="d">-        }
</a><a href="#h7-3-40" id="h7-3-40" class="d">-        Ok(())
</a><a href="#h7-3-41" id="h7-3-41" class="i">+        })
</a>     }
 }
 
<a href="#h7-4" id="h7-4" class="h">@@ -99,18 +104,15 @@ impl Session {
</a>     }
 
     /// Handles a client connection.
<a href="#h7-4-3" id="h7-4-3" class="d">-    async fn handle(mut self, socket: TcpStream) -&gt; Result&lt;()&gt; {
</a><a href="#h7-4-4" id="h7-4-4" class="d">-        let mut stream = tokio_serde::Framed::new(
</a><a href="#h7-4-5" id="h7-4-5" class="d">-            Framed::new(socket, LengthDelimitedCodec::new()),
</a><a href="#h7-4-6" id="h7-4-6" class="d">-            tokio_serde::formats::Bincode::default(),
</a><a href="#h7-4-7" id="h7-4-7" class="d">-        );
</a><a href="#h7-4-8" id="h7-4-8" class="d">-        while let Some(request) = stream.try_next().await? {
</a><a href="#h7-4-9" id="h7-4-9" class="d">-            let mut response = tokio::task::block_in_place(|| self.request(request));
</a><a href="#h7-4-10" id="h7-4-10" class="i">+    fn handle(mut self, mut socket: std::net::TcpStream) -&gt; Result&lt;()&gt; {
</a><a href="#h7-4-11" id="h7-4-11" class="i">+        while let Some(request) = bincode::maybe_deserialize_from(&amp;mut socket)? {
</a><a href="#h7-4-12" id="h7-4-12" class="i">+            let mut response = self.request(request);
</a>             let mut rows: Box&lt;dyn Iterator&lt;Item = Result&lt;Response&gt;&gt; + Send&gt; =
                 Box::new(std::iter::empty());
             if let Ok(Response::Execute(ResultSet::Query { rows: ref mut resultrows, .. })) =
                 &amp;mut response
             {
<a href="#h7-4-18" id="h7-4-18" class="i">+                // TODO: don&#39;t stream results, for simplicity.
</a>                 rows = Box::new(
                     std::mem::replace(resultrows, Box::new(std::iter::empty()))
                         .map(|result| result.map(|row| Response::Row(Some(row))))
<a href="#h7-5" id="h7-5" class="h">@@ -126,12 +128,15 @@ impl Session {
</a>                         .fuse(),
                 );
             }
<a href="#h7-5-3" id="h7-5-3" class="d">-            stream.send(response).await?;
</a><a href="#h7-5-4" id="h7-5-4" class="d">-            stream.send_all(&amp;mut tokio_stream::iter(rows.map(Ok))).await?;
</a><a href="#h7-5-5" id="h7-5-5" class="i">+
</a><a href="#h7-5-6" id="h7-5-6" class="i">+            bincode::serialize_into(&amp;mut socket, &amp;response)?;
</a><a href="#h7-5-7" id="h7-5-7" class="i">+
</a><a href="#h7-5-8" id="h7-5-8" class="i">+            for row in rows {
</a><a href="#h7-5-9" id="h7-5-9" class="i">+                bincode::serialize_into(&amp;mut socket, &amp;row)?;
</a><a href="#h7-5-10" id="h7-5-10" class="i">+            }
</a>         }
         Ok(())
     }
<a href="#h7-5-14" id="h7-5-14" class="d">-
</a>     /// Executes a request.
     pub fn request(&amp;mut self, request: Request) -&gt; Result&lt;Response&gt; {
         debug!(&quot;Processing request {:?}&quot;, request);
<a href="#h7-6" id="h7-6" class="h">@@ -152,6 +157,6 @@ impl Session {
</a> 
 impl Drop for Session {
     fn drop(&amp;mut self) {
<a href="#h7-6-3" id="h7-6-3" class="d">-        tokio::task::block_in_place(|| self.sql.execute(&quot;ROLLBACK&quot;).ok());
</a><a href="#h7-6-4" id="h7-6-4" class="i">+        self.sql.execute(&quot;ROLLBACK&quot;).ok();
</a>     }
 }
<b>diff --git a/<a id="h8" href="../file/tests/e2e/client.rs.html">tests/e2e/client.rs</a> b/<a href="../file/tests/e2e/client.rs.html">tests/e2e/client.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -12,18 +12,15 @@ use toydb::storage::{engine, mvcc};
</a> use pretty_assertions::assert_eq;
 use serial_test::serial;
 
<a href="#h8-0-3" id="h8-0-3" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h8-0-4" id="h8-0-4" class="i">+#[test]
</a> #[serial]
<a href="#h8-0-6" id="h8-0-6" class="d">-async fn get_table() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-7" id="h8-0-7" class="d">-    let tc = TestCluster::run_with(5, dataset::MOVIES).await?;
</a><a href="#h8-0-8" id="h8-0-8" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h8-0-9" id="h8-0-9" class="i">+fn get_table() -&gt; Result&lt;()&gt; {
</a><a href="#h8-0-10" id="h8-0-10" class="i">+    let tc = TestCluster::run_with(5, dataset::MOVIES)?;
</a><a href="#h8-0-11" id="h8-0-11" class="i">+    let mut c = tc.connect_any()?;
</a> 
<a href="#h8-0-13" id="h8-0-13" class="i">+    assert_eq!(c.get_table(&quot;unknown&quot;), Err(Error::Value(&quot;Table unknown does not exist&quot;.into())));
</a>     assert_eq!(
<a href="#h8-0-15" id="h8-0-15" class="d">-        c.get_table(&quot;unknown&quot;).await,
</a><a href="#h8-0-16" id="h8-0-16" class="d">-        Err(Error::Value(&quot;Table unknown does not exist&quot;.into()))
</a><a href="#h8-0-17" id="h8-0-17" class="d">-    );
</a><a href="#h8-0-18" id="h8-0-18" class="d">-    assert_eq!(
</a><a href="#h8-0-19" id="h8-0-19" class="d">-        c.get_table(&quot;movies&quot;).await?,
</a><a href="#h8-0-20" id="h8-0-20" class="i">+        c.get_table(&quot;movies&quot;)?,
</a>         schema::Table {
             name: &quot;movies&quot;.into(),
             columns: vec![
<a href="#h8-1" id="h8-1" class="h">@@ -103,24 +100,24 @@ async fn get_table() -&gt; Result&lt;()&gt; {
</a>     Ok(())
 }
 
<a href="#h8-1-3" id="h8-1-3" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h8-1-4" id="h8-1-4" class="i">+#[test]
</a> #[serial]
<a href="#h8-1-6" id="h8-1-6" class="d">-async fn list_tables() -&gt; Result&lt;()&gt; {
</a><a href="#h8-1-7" id="h8-1-7" class="d">-    let tc = TestCluster::run_with(5, dataset::MOVIES).await?;
</a><a href="#h8-1-8" id="h8-1-8" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h8-1-9" id="h8-1-9" class="i">+fn list_tables() -&gt; Result&lt;()&gt; {
</a><a href="#h8-1-10" id="h8-1-10" class="i">+    let tc = TestCluster::run_with(5, dataset::MOVIES)?;
</a><a href="#h8-1-11" id="h8-1-11" class="i">+    let mut c = tc.connect_any()?;
</a> 
<a href="#h8-1-13" id="h8-1-13" class="d">-    assert_eq!(c.list_tables().await?, vec![&quot;countries&quot;, &quot;genres&quot;, &quot;movies&quot;, &quot;studios&quot;]);
</a><a href="#h8-1-14" id="h8-1-14" class="i">+    assert_eq!(c.list_tables()?, vec![&quot;countries&quot;, &quot;genres&quot;, &quot;movies&quot;, &quot;studios&quot;]);
</a>     Ok(())
 }
 
<a href="#h8-1-18" id="h8-1-18" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h8-1-19" id="h8-1-19" class="i">+#[test]
</a> #[serial]
<a href="#h8-1-21" id="h8-1-21" class="d">-async fn status() -&gt; Result&lt;()&gt; {
</a><a href="#h8-1-22" id="h8-1-22" class="d">-    let tc = TestCluster::run_with(1, dataset::MOVIES).await?;
</a><a href="#h8-1-23" id="h8-1-23" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h8-1-24" id="h8-1-24" class="i">+fn status() -&gt; Result&lt;()&gt; {
</a><a href="#h8-1-25" id="h8-1-25" class="i">+    let tc = TestCluster::run_with(1, dataset::MOVIES)?;
</a><a href="#h8-1-26" id="h8-1-26" class="i">+    let mut c = tc.connect_any()?;
</a> 
     assert_eq!(
<a href="#h8-1-29" id="h8-1-29" class="d">-        c.status().await?,
</a><a href="#h8-1-30" id="h8-1-30" class="i">+        c.status()?,
</a>         Status {
             raft: raft::Status {
                 server: 1,
<a href="#h8-2" id="h8-2" class="h">@@ -155,14 +152,14 @@ async fn status() -&gt; Result&lt;()&gt; {
</a>     Ok(())
 }
 
<a href="#h8-2-3" id="h8-2-3" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h8-2-4" id="h8-2-4" class="i">+#[test]
</a> #[serial]
<a href="#h8-2-6" id="h8-2-6" class="d">-async fn execute() -&gt; Result&lt;()&gt; {
</a><a href="#h8-2-7" id="h8-2-7" class="d">-    let tc = TestCluster::run_with(5, dataset::MOVIES).await?;
</a><a href="#h8-2-8" id="h8-2-8" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h8-2-9" id="h8-2-9" class="i">+fn execute() -&gt; Result&lt;()&gt; {
</a><a href="#h8-2-10" id="h8-2-10" class="i">+    let tc = TestCluster::run_with(5, dataset::MOVIES)?;
</a><a href="#h8-2-11" id="h8-2-11" class="i">+    let mut c = tc.connect_any()?;
</a> 
     // SELECT
<a href="#h8-2-14" id="h8-2-14" class="d">-    let result = c.execute(&quot;SELECT * FROM genres&quot;).await?;
</a><a href="#h8-2-15" id="h8-2-15" class="i">+    let result = c.execute(&quot;SELECT * FROM genres&quot;)?;
</a>     assert_eq!(
         result,
         ResultSet::Query {
<a href="#h8-3" id="h8-3" class="h">@@ -179,7 +176,7 @@ async fn execute() -&gt; Result&lt;()&gt; {
</a>         ],
     );
 
<a href="#h8-3-3" id="h8-3-3" class="d">-    let result = c.execute(&quot;SELECT * FROM genres WHERE FALSE&quot;).await?;
</a><a href="#h8-3-4" id="h8-3-4" class="i">+    let result = c.execute(&quot;SELECT * FROM genres WHERE FALSE&quot;)?;
</a>     assert_eq!(
         result,
         ResultSet::Query {
<a href="#h8-4" id="h8-4" class="h">@@ -189,135 +186,123 @@ async fn execute() -&gt; Result&lt;()&gt; {
</a>     );
     assert_rows(result, Vec::new());
 
<a href="#h8-4-3" id="h8-4-3" class="d">-    assert_eq!(
</a><a href="#h8-4-4" id="h8-4-4" class="d">-        c.execute(&quot;SELECT * FROM x&quot;).await,
</a><a href="#h8-4-5" id="h8-4-5" class="d">-        Err(Error::Value(&quot;Table x does not exist&quot;.into()))
</a><a href="#h8-4-6" id="h8-4-6" class="d">-    );
</a><a href="#h8-4-7" id="h8-4-7" class="i">+    assert_eq!(c.execute(&quot;SELECT * FROM x&quot;), Err(Error::Value(&quot;Table x does not exist&quot;.into())));
</a> 
     // INSERT
     assert_eq!(
<a href="#h8-4-11" id="h8-4-11" class="d">-        c.execute(&quot;INSERT INTO genres VALUES (1, &#39;Western&#39;)&quot;).await,
</a><a href="#h8-4-12" id="h8-4-12" class="i">+        c.execute(&quot;INSERT INTO genres VALUES (1, &#39;Western&#39;)&quot;),
</a>         Err(Error::Value(&quot;Primary key 1 already exists for table genres&quot;.into())),
     );
     assert_eq!(
<a href="#h8-4-16" id="h8-4-16" class="d">-        c.execute(&quot;INSERT INTO genres VALUES (9, &#39;Western&#39;)&quot;).await,
</a><a href="#h8-4-17" id="h8-4-17" class="i">+        c.execute(&quot;INSERT INTO genres VALUES (9, &#39;Western&#39;)&quot;),
</a>         Ok(ResultSet::Create { count: 1 }),
     );
     assert_eq!(
<a href="#h8-4-21" id="h8-4-21" class="d">-        c.execute(&quot;INSERT INTO x VALUES (9, &#39;Western&#39;)&quot;).await,
</a><a href="#h8-4-22" id="h8-4-22" class="i">+        c.execute(&quot;INSERT INTO x VALUES (9, &#39;Western&#39;)&quot;),
</a>         Err(Error::Value(&quot;Table x does not exist&quot;.into()))
     );
 
     // UPDATE
     assert_eq!(
<a href="#h8-4-28" id="h8-4-28" class="d">-        c.execute(&quot;UPDATE genres SET name = &#39;Horror&#39; WHERE FALSE&quot;).await,
</a><a href="#h8-4-29" id="h8-4-29" class="i">+        c.execute(&quot;UPDATE genres SET name = &#39;Horror&#39; WHERE FALSE&quot;),
</a>         Ok(ResultSet::Update { count: 0 }),
     );
     assert_eq!(
<a href="#h8-4-33" id="h8-4-33" class="d">-        c.execute(&quot;UPDATE genres SET name = &#39;Horror&#39; WHERE id = 9&quot;).await,
</a><a href="#h8-4-34" id="h8-4-34" class="i">+        c.execute(&quot;UPDATE genres SET name = &#39;Horror&#39; WHERE id = 9&quot;),
</a>         Ok(ResultSet::Update { count: 1 }),
     );
     assert_eq!(
<a href="#h8-4-38" id="h8-4-38" class="d">-        c.execute(&quot;UPDATE genres SET id = 1 WHERE id = 9&quot;).await,
</a><a href="#h8-4-39" id="h8-4-39" class="i">+        c.execute(&quot;UPDATE genres SET id = 1 WHERE id = 9&quot;),
</a>         Err(Error::Value(&quot;Primary key 1 already exists for table genres&quot;.into()))
     );
 
     // DELETE
<a href="#h8-4-44" id="h8-4-44" class="i">+    assert_eq!(c.execute(&quot;DELETE FROM genres WHERE FALSE&quot;), Ok(ResultSet::Delete { count: 0 }),);
</a><a href="#h8-4-45" id="h8-4-45" class="i">+    assert_eq!(c.execute(&quot;DELETE FROM genres WHERE id = 9&quot;), Ok(ResultSet::Delete { count: 1 }),);
</a>     assert_eq!(
<a href="#h8-4-47" id="h8-4-47" class="d">-        c.execute(&quot;DELETE FROM genres WHERE FALSE&quot;).await,
</a><a href="#h8-4-48" id="h8-4-48" class="d">-        Ok(ResultSet::Delete { count: 0 }),
</a><a href="#h8-4-49" id="h8-4-49" class="d">-    );
</a><a href="#h8-4-50" id="h8-4-50" class="d">-    assert_eq!(
</a><a href="#h8-4-51" id="h8-4-51" class="d">-        c.execute(&quot;DELETE FROM genres WHERE id = 9&quot;).await,
</a><a href="#h8-4-52" id="h8-4-52" class="d">-        Ok(ResultSet::Delete { count: 1 }),
</a><a href="#h8-4-53" id="h8-4-53" class="d">-    );
</a><a href="#h8-4-54" id="h8-4-54" class="d">-    assert_eq!(
</a><a href="#h8-4-55" id="h8-4-55" class="d">-        c.execute(&quot;DELETE FROM genres WHERE x = 1&quot;).await,
</a><a href="#h8-4-56" id="h8-4-56" class="i">+        c.execute(&quot;DELETE FROM genres WHERE x = 1&quot;),
</a>         Err(Error::Value(&quot;Unknown field x&quot;.into()))
     );
 
     Ok(())
 }
 
<a href="#h8-4-63" id="h8-4-63" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h8-4-64" id="h8-4-64" class="i">+#[test]
</a> #[serial]
<a href="#h8-4-66" id="h8-4-66" class="d">-async fn execute_txn() -&gt; Result&lt;()&gt; {
</a><a href="#h8-4-67" id="h8-4-67" class="d">-    let tc = TestCluster::run_with(5, dataset::MOVIES).await?;
</a><a href="#h8-4-68" id="h8-4-68" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h8-4-69" id="h8-4-69" class="i">+fn execute_txn() -&gt; Result&lt;()&gt; {
</a><a href="#h8-4-70" id="h8-4-70" class="i">+    let tc = TestCluster::run_with(5, dataset::MOVIES)?;
</a><a href="#h8-4-71" id="h8-4-71" class="i">+    let mut c = tc.connect_any()?;
</a> 
     assert_eq!(c.txn(), None);
 
     // Committing a change in a txn should work
<a href="#h8-4-76" id="h8-4-76" class="d">-    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 2, read_only: false });
</a><a href="#h8-4-77" id="h8-4-77" class="i">+    assert_eq!(c.execute(&quot;BEGIN&quot;)?, ResultSet::Begin { version: 2, read_only: false });
</a>     assert_eq!(c.txn(), Some((2, false)));
<a href="#h8-4-79" id="h8-4-79" class="d">-    c.execute(&quot;INSERT INTO genres VALUES (4, &#39;Drama&#39;)&quot;).await?;
</a><a href="#h8-4-80" id="h8-4-80" class="d">-    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { version: 2 });
</a><a href="#h8-4-81" id="h8-4-81" class="i">+    c.execute(&quot;INSERT INTO genres VALUES (4, &#39;Drama&#39;)&quot;)?;
</a><a href="#h8-4-82" id="h8-4-82" class="i">+    assert_eq!(c.execute(&quot;COMMIT&quot;)?, ResultSet::Commit { version: 2 });
</a>     assert_eq!(c.txn(), None);
     assert_row(
<a href="#h8-4-85" id="h8-4-85" class="d">-        c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;).await?,
</a><a href="#h8-4-86" id="h8-4-86" class="i">+        c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;)?,
</a>         vec![Value::Integer(4), Value::String(&quot;Drama&quot;.into())],
     );
     assert_eq!(c.txn(), None);
 
     // Rolling back a change in a txn should also work
<a href="#h8-4-92" id="h8-4-92" class="d">-    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 3, read_only: false });
</a><a href="#h8-4-93" id="h8-4-93" class="i">+    assert_eq!(c.execute(&quot;BEGIN&quot;)?, ResultSet::Begin { version: 3, read_only: false });
</a>     assert_eq!(c.txn(), Some((3, false)));
<a href="#h8-4-95" id="h8-4-95" class="d">-    c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;).await?;
</a><a href="#h8-4-96" id="h8-4-96" class="i">+    c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;)?;
</a>     assert_row(
<a href="#h8-4-98" id="h8-4-98" class="d">-        c.execute(&quot;SELECT * FROM genres WHERE id = 5&quot;).await?,
</a><a href="#h8-4-99" id="h8-4-99" class="i">+        c.execute(&quot;SELECT * FROM genres WHERE id = 5&quot;)?,
</a>         vec![Value::Integer(5), Value::String(&quot;Musical&quot;.into())],
     );
<a href="#h8-4-102" id="h8-4-102" class="d">-    assert_eq!(c.execute(&quot;ROLLBACK&quot;).await?, ResultSet::Rollback { version: 3 });
</a><a href="#h8-4-103" id="h8-4-103" class="d">-    assert_rows(c.execute(&quot;SELECT * FROM genres WHERE id = 5&quot;).await?, Vec::new());
</a><a href="#h8-4-104" id="h8-4-104" class="i">+    assert_eq!(c.execute(&quot;ROLLBACK&quot;)?, ResultSet::Rollback { version: 3 });
</a><a href="#h8-4-105" id="h8-4-105" class="i">+    assert_rows(c.execute(&quot;SELECT * FROM genres WHERE id = 5&quot;)?, Vec::new());
</a>     assert_eq!(c.txn(), None);
 
     // Starting a read-only txn should block writes
<a href="#h8-4-109" id="h8-4-109" class="d">-    assert_eq!(
</a><a href="#h8-4-110" id="h8-4-110" class="d">-        c.execute(&quot;BEGIN READ ONLY&quot;).await?,
</a><a href="#h8-4-111" id="h8-4-111" class="d">-        ResultSet::Begin { version: 4, read_only: true }
</a><a href="#h8-4-112" id="h8-4-112" class="d">-    );
</a><a href="#h8-4-113" id="h8-4-113" class="i">+    assert_eq!(c.execute(&quot;BEGIN READ ONLY&quot;)?, ResultSet::Begin { version: 4, read_only: true });
</a>     assert_eq!(c.txn(), Some((4, true)));
     assert_row(
<a href="#h8-4-116" id="h8-4-116" class="d">-        c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;).await?,
</a><a href="#h8-4-117" id="h8-4-117" class="i">+        c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;)?,
</a>         vec![Value::Integer(4), Value::String(&quot;Drama&quot;.into())],
     );
<a href="#h8-4-120" id="h8-4-120" class="d">-    assert_eq!(c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;).await, Err(Error::ReadOnly));
</a><a href="#h8-4-121" id="h8-4-121" class="i">+    assert_eq!(c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;), Err(Error::ReadOnly));
</a>     assert_row(
<a href="#h8-4-123" id="h8-4-123" class="d">-        c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;).await?,
</a><a href="#h8-4-124" id="h8-4-124" class="i">+        c.execute(&quot;SELECT * FROM genres WHERE id = 4&quot;)?,
</a>         vec![Value::Integer(4), Value::String(&quot;Drama&quot;.into())],
     );
<a href="#h8-4-127" id="h8-4-127" class="d">-    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { version: 4 });
</a><a href="#h8-4-128" id="h8-4-128" class="i">+    assert_eq!(c.execute(&quot;COMMIT&quot;)?, ResultSet::Commit { version: 4 });
</a> 
     // Starting a time-travel txn should work, it shouldn&#39;t see recent changes, and it should
     // block writes
     assert_eq!(
<a href="#h8-4-133" id="h8-4-133" class="d">-        c.execute(&quot;BEGIN READ ONLY AS OF SYSTEM TIME 2&quot;).await?,
</a><a href="#h8-4-134" id="h8-4-134" class="i">+        c.execute(&quot;BEGIN READ ONLY AS OF SYSTEM TIME 2&quot;)?,
</a>         ResultSet::Begin { version: 2, read_only: true },
     );
     assert_eq!(c.txn(), Some((2, true)));
     assert_rows(
<a href="#h8-4-139" id="h8-4-139" class="d">-        c.execute(&quot;SELECT * FROM genres&quot;).await?,
</a><a href="#h8-4-140" id="h8-4-140" class="i">+        c.execute(&quot;SELECT * FROM genres&quot;)?,
</a>         vec![
             vec![Value::Integer(1), Value::String(&quot;Science Fiction&quot;.into())],
             vec![Value::Integer(2), Value::String(&quot;Action&quot;.into())],
             vec![Value::Integer(3), Value::String(&quot;Comedy&quot;.into())],
         ],
     );
<a href="#h8-4-147" id="h8-4-147" class="d">-    assert_eq!(c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;).await, Err(Error::ReadOnly));
</a><a href="#h8-4-148" id="h8-4-148" class="d">-    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { version: 2 });
</a><a href="#h8-4-149" id="h8-4-149" class="i">+    assert_eq!(c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;), Err(Error::ReadOnly));
</a><a href="#h8-4-150" id="h8-4-150" class="i">+    assert_eq!(c.execute(&quot;COMMIT&quot;)?, ResultSet::Commit { version: 2 });
</a> 
     // A txn should still be usable after an error occurs
<a href="#h8-4-153" id="h8-4-153" class="d">-    assert_eq!(c.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 4, read_only: false });
</a><a href="#h8-4-154" id="h8-4-154" class="d">-    c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Horror&#39;)&quot;).await?;
</a><a href="#h8-4-155" id="h8-4-155" class="i">+    assert_eq!(c.execute(&quot;BEGIN&quot;)?, ResultSet::Begin { version: 4, read_only: false });
</a><a href="#h8-4-156" id="h8-4-156" class="i">+    c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Horror&#39;)&quot;)?;
</a>     assert_eq!(
<a href="#h8-4-158" id="h8-4-158" class="d">-        c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;).await,
</a><a href="#h8-4-159" id="h8-4-159" class="i">+        c.execute(&quot;INSERT INTO genres VALUES (5, &#39;Musical&#39;)&quot;),
</a>         Err(Error::Value(&quot;Primary key 5 already exists for table genres&quot;.into()))
     );
     assert_eq!(c.txn(), Some((4, false)));
<a href="#h8-4-163" id="h8-4-163" class="d">-    c.execute(&quot;INSERT INTO genres VALUES (6, &#39;Western&#39;)&quot;).await?;
</a><a href="#h8-4-164" id="h8-4-164" class="d">-    assert_eq!(c.execute(&quot;COMMIT&quot;).await?, ResultSet::Commit { version: 4 });
</a><a href="#h8-4-165" id="h8-4-165" class="i">+    c.execute(&quot;INSERT INTO genres VALUES (6, &#39;Western&#39;)&quot;)?;
</a><a href="#h8-4-166" id="h8-4-166" class="i">+    assert_eq!(c.execute(&quot;COMMIT&quot;)?, ResultSet::Commit { version: 4 });
</a>     assert_rows(
<a href="#h8-4-168" id="h8-4-168" class="d">-        c.execute(&quot;SELECT * FROM genres&quot;).await?,
</a><a href="#h8-4-169" id="h8-4-169" class="i">+        c.execute(&quot;SELECT * FROM genres&quot;)?,
</a>         vec![
             vec![Value::Integer(1), Value::String(&quot;Science Fiction&quot;.into())],
             vec![Value::Integer(2), Value::String(&quot;Action&quot;.into())],
<a href="#h8-5" id="h8-5" class="h">@@ -331,40 +316,37 @@ async fn execute_txn() -&gt; Result&lt;()&gt; {
</a>     Ok(())
 }
 
<a href="#h8-5-3" id="h8-5-3" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h8-5-4" id="h8-5-4" class="i">+#[test]
</a> #[serial]
<a href="#h8-5-6" id="h8-5-6" class="d">-async fn execute_txn_concurrent() -&gt; Result&lt;()&gt; {
</a><a href="#h8-5-7" id="h8-5-7" class="d">-    let tc = TestCluster::run_with(5, dataset::MOVIES).await?;
</a><a href="#h8-5-8" id="h8-5-8" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h8-5-9" id="h8-5-9" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h8-5-10" id="h8-5-10" class="i">+fn execute_txn_concurrent() -&gt; Result&lt;()&gt; {
</a><a href="#h8-5-11" id="h8-5-11" class="i">+    let tc = TestCluster::run_with(5, dataset::MOVIES)?;
</a><a href="#h8-5-12" id="h8-5-12" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h8-5-13" id="h8-5-13" class="i">+    let mut b = tc.connect_any()?;
</a> 
     // Concurrent updates should throw a serialization failure on conflict.
<a href="#h8-5-16" id="h8-5-16" class="d">-    assert_eq!(a.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 2, read_only: false });
</a><a href="#h8-5-17" id="h8-5-17" class="d">-    assert_eq!(b.execute(&quot;BEGIN&quot;).await?, ResultSet::Begin { version: 3, read_only: false });
</a><a href="#h8-5-18" id="h8-5-18" class="i">+    assert_eq!(a.execute(&quot;BEGIN&quot;)?, ResultSet::Begin { version: 2, read_only: false });
</a><a href="#h8-5-19" id="h8-5-19" class="i">+    assert_eq!(b.execute(&quot;BEGIN&quot;)?, ResultSet::Begin { version: 3, read_only: false });
</a> 
     assert_row(
<a href="#h8-5-22" id="h8-5-22" class="d">-        a.execute(&quot;SELECT * FROM genres WHERE id = 1&quot;).await?,
</a><a href="#h8-5-23" id="h8-5-23" class="i">+        a.execute(&quot;SELECT * FROM genres WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;Science Fiction&quot;.into())],
     );
     assert_row(
<a href="#h8-5-27" id="h8-5-27" class="d">-        b.execute(&quot;SELECT * FROM genres WHERE id = 1&quot;).await?,
</a><a href="#h8-5-28" id="h8-5-28" class="i">+        b.execute(&quot;SELECT * FROM genres WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;Science Fiction&quot;.into())],
     );
 
     assert_eq!(
<a href="#h8-5-33" id="h8-5-33" class="d">-        a.execute(&quot;UPDATE genres SET name = &#39;x&#39; WHERE id = 1&quot;).await,
</a><a href="#h8-5-34" id="h8-5-34" class="i">+        a.execute(&quot;UPDATE genres SET name = &#39;x&#39; WHERE id = 1&quot;),
</a>         Ok(ResultSet::Update { count: 1 })
     );
<a href="#h8-5-37" id="h8-5-37" class="d">-    assert_eq!(
</a><a href="#h8-5-38" id="h8-5-38" class="d">-        b.execute(&quot;UPDATE genres SET name = &#39;y&#39; WHERE id = 1&quot;).await,
</a><a href="#h8-5-39" id="h8-5-39" class="d">-        Err(Error::Serialization)
</a><a href="#h8-5-40" id="h8-5-40" class="d">-    );
</a><a href="#h8-5-41" id="h8-5-41" class="i">+    assert_eq!(b.execute(&quot;UPDATE genres SET name = &#39;y&#39; WHERE id = 1&quot;), Err(Error::Serialization));
</a> 
<a href="#h8-5-43" id="h8-5-43" class="d">-    assert_eq!(a.execute(&quot;COMMIT&quot;).await, Ok(ResultSet::Commit { version: 2 }));
</a><a href="#h8-5-44" id="h8-5-44" class="d">-    assert_eq!(b.execute(&quot;ROLLBACK&quot;).await, Ok(ResultSet::Rollback { version: 3 }));
</a><a href="#h8-5-45" id="h8-5-45" class="i">+    assert_eq!(a.execute(&quot;COMMIT&quot;), Ok(ResultSet::Commit { version: 2 }));
</a><a href="#h8-5-46" id="h8-5-46" class="i">+    assert_eq!(b.execute(&quot;ROLLBACK&quot;), Ok(ResultSet::Rollback { version: 3 }));
</a> 
     assert_row(
<a href="#h8-5-49" id="h8-5-49" class="d">-        a.execute(&quot;SELECT * FROM genres WHERE id = 1&quot;).await?,
</a><a href="#h8-5-50" id="h8-5-50" class="i">+        a.execute(&quot;SELECT * FROM genres WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;x&quot;.into())],
     );
 
<b>diff --git a/<a id="h9" href="../file/tests/e2e/isolation.rs.html">tests/e2e/isolation.rs</a> b/<a href="../file/tests/e2e/isolation.rs.html">tests/e2e/isolation.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -4,152 +4,149 @@ use serial_test::serial;
</a> use toydb::error::{Error, Result};
 use toydb::sql::types::Value;
 
<a href="#h9-0-3" id="h9-0-3" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h9-0-4" id="h9-0-4" class="i">+#[test]
</a> #[serial]
 // A dirty write is when b overwrites an uncommitted value written by a.
<a href="#h9-0-7" id="h9-0-7" class="d">-async fn dirty_write() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-8" id="h9-0-8" class="d">-    let tc = TestCluster::run_with(5, dataset::TEST_TABLE).await?;
</a><a href="#h9-0-9" id="h9-0-9" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h9-0-10" id="h9-0-10" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h9-0-11" id="h9-0-11" class="i">+fn dirty_write() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-12" id="h9-0-12" class="i">+    let tc = TestCluster::run_with(5, dataset::TEST_TABLE)?;
</a><a href="#h9-0-13" id="h9-0-13" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h9-0-14" id="h9-0-14" class="i">+    let mut b = tc.connect_any()?;
</a> 
<a href="#h9-0-16" id="h9-0-16" class="d">-    a.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-17" id="h9-0-17" class="d">-    a.execute(&quot;INSERT INTO test VALUES (1, &#39;a&#39;)&quot;).await?;
</a><a href="#h9-0-18" id="h9-0-18" class="i">+    a.execute(&quot;BEGIN&quot;)?;
</a><a href="#h9-0-19" id="h9-0-19" class="i">+    a.execute(&quot;INSERT INTO test VALUES (1, &#39;a&#39;)&quot;)?;
</a> 
<a href="#h9-0-21" id="h9-0-21" class="d">-    assert_eq!(b.execute(&quot;INSERT INTO test VALUES (1, &#39;b&#39;)&quot;).await, Err(Error::Serialization));
</a><a href="#h9-0-22" id="h9-0-22" class="i">+    assert_eq!(b.execute(&quot;INSERT INTO test VALUES (1, &#39;b&#39;)&quot;), Err(Error::Serialization));
</a> 
<a href="#h9-0-24" id="h9-0-24" class="d">-    a.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h9-0-25" id="h9-0-25" class="i">+    a.execute(&quot;COMMIT&quot;)?;
</a>     assert_row(
<a href="#h9-0-27" id="h9-0-27" class="d">-        a.execute(&quot;SELECT * FROM test WHERE id = 1&quot;).await?,
</a><a href="#h9-0-28" id="h9-0-28" class="i">+        a.execute(&quot;SELECT * FROM test WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;a&quot;.into())],
     );
 
     Ok(())
 }
 
<a href="#h9-0-35" id="h9-0-35" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h9-0-36" id="h9-0-36" class="i">+#[test]
</a> #[serial]
 // A dirty read is when b can read an uncommitted value set by a.
<a href="#h9-0-39" id="h9-0-39" class="d">-async fn anomaly_dirty_read() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-40" id="h9-0-40" class="d">-    let tc = TestCluster::run_with(5, dataset::TEST_TABLE).await?;
</a><a href="#h9-0-41" id="h9-0-41" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h9-0-42" id="h9-0-42" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h9-0-43" id="h9-0-43" class="i">+fn anomaly_dirty_read() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-44" id="h9-0-44" class="i">+    let tc = TestCluster::run_with(5, dataset::TEST_TABLE)?;
</a><a href="#h9-0-45" id="h9-0-45" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h9-0-46" id="h9-0-46" class="i">+    let mut b = tc.connect_any()?;
</a> 
<a href="#h9-0-48" id="h9-0-48" class="d">-    a.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-49" id="h9-0-49" class="d">-    a.execute(&quot;INSERT INTO test VALUES (1, &#39;a&#39;)&quot;).await?;
</a><a href="#h9-0-50" id="h9-0-50" class="i">+    a.execute(&quot;BEGIN&quot;)?;
</a><a href="#h9-0-51" id="h9-0-51" class="i">+    a.execute(&quot;INSERT INTO test VALUES (1, &#39;a&#39;)&quot;)?;
</a> 
<a href="#h9-0-53" id="h9-0-53" class="d">-    assert_rows(b.execute(&quot;SELECT * FROM test&quot;).await?, vec![]);
</a><a href="#h9-0-54" id="h9-0-54" class="i">+    assert_rows(b.execute(&quot;SELECT * FROM test&quot;)?, vec![]);
</a> 
     Ok(())
 }
 
<a href="#h9-0-59" id="h9-0-59" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h9-0-60" id="h9-0-60" class="i">+#[test]
</a> #[serial]
 // A lost update is when a and b both read a value and update it, where b&#39;s update replaces a.
<a href="#h9-0-63" id="h9-0-63" class="d">-async fn anomaly_lost_update() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-64" id="h9-0-64" class="d">-    let tc = TestCluster::run_with(5, dataset::TEST_TABLE).await?;
</a><a href="#h9-0-65" id="h9-0-65" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h9-0-66" id="h9-0-66" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h9-0-67" id="h9-0-67" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h9-0-68" id="h9-0-68" class="i">+fn anomaly_lost_update() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-69" id="h9-0-69" class="i">+    let tc = TestCluster::run_with(5, dataset::TEST_TABLE)?;
</a><a href="#h9-0-70" id="h9-0-70" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h9-0-71" id="h9-0-71" class="i">+    let mut b = tc.connect_any()?;
</a><a href="#h9-0-72" id="h9-0-72" class="i">+    let mut c = tc.connect_any()?;
</a> 
<a href="#h9-0-74" id="h9-0-74" class="d">-    c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;)&quot;).await?;
</a><a href="#h9-0-75" id="h9-0-75" class="i">+    c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;)&quot;)?;
</a> 
<a href="#h9-0-77" id="h9-0-77" class="d">-    a.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-78" id="h9-0-78" class="d">-    b.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-79" id="h9-0-79" class="i">+    a.execute(&quot;BEGIN&quot;)?;
</a><a href="#h9-0-80" id="h9-0-80" class="i">+    b.execute(&quot;BEGIN&quot;)?;
</a> 
<a href="#h9-0-82" id="h9-0-82" class="d">-    a.execute(&quot;UPDATE test SET value = &#39;a&#39; WHERE id = 1&quot;).await?;
</a><a href="#h9-0-83" id="h9-0-83" class="d">-    assert_eq!(
</a><a href="#h9-0-84" id="h9-0-84" class="d">-        b.execute(&quot;UPDATE test SET value = &#39;b&#39; WHERE id = 1&quot;).await,
</a><a href="#h9-0-85" id="h9-0-85" class="d">-        Err(Error::Serialization)
</a><a href="#h9-0-86" id="h9-0-86" class="d">-    );
</a><a href="#h9-0-87" id="h9-0-87" class="d">-    a.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h9-0-88" id="h9-0-88" class="i">+    a.execute(&quot;UPDATE test SET value = &#39;a&#39; WHERE id = 1&quot;)?;
</a><a href="#h9-0-89" id="h9-0-89" class="i">+    assert_eq!(b.execute(&quot;UPDATE test SET value = &#39;b&#39; WHERE id = 1&quot;), Err(Error::Serialization));
</a><a href="#h9-0-90" id="h9-0-90" class="i">+    a.execute(&quot;COMMIT&quot;)?;
</a> 
     assert_row(
<a href="#h9-0-93" id="h9-0-93" class="d">-        c.execute(&quot;SELECT * FROM test WHERE id = 1&quot;).await?,
</a><a href="#h9-0-94" id="h9-0-94" class="i">+        c.execute(&quot;SELECT * FROM test WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;a&quot;.into())],
     );
 
     Ok(())
 }
 
<a href="#h9-0-101" id="h9-0-101" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h9-0-102" id="h9-0-102" class="i">+#[test]
</a> #[serial]
 // A fuzzy (or unrepeatable) read is when b sees a value change after a updates it.
<a href="#h9-0-105" id="h9-0-105" class="d">-async fn anomaly_fuzzy_read() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-106" id="h9-0-106" class="d">-    let tc = TestCluster::run_with(5, dataset::TEST_TABLE).await?;
</a><a href="#h9-0-107" id="h9-0-107" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h9-0-108" id="h9-0-108" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h9-0-109" id="h9-0-109" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h9-0-110" id="h9-0-110" class="i">+fn anomaly_fuzzy_read() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-111" id="h9-0-111" class="i">+    let tc = TestCluster::run_with(5, dataset::TEST_TABLE)?;
</a><a href="#h9-0-112" id="h9-0-112" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h9-0-113" id="h9-0-113" class="i">+    let mut b = tc.connect_any()?;
</a><a href="#h9-0-114" id="h9-0-114" class="i">+    let mut c = tc.connect_any()?;
</a> 
<a href="#h9-0-116" id="h9-0-116" class="d">-    c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;)&quot;).await?;
</a><a href="#h9-0-117" id="h9-0-117" class="i">+    c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;)&quot;)?;
</a> 
<a href="#h9-0-119" id="h9-0-119" class="d">-    a.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-120" id="h9-0-120" class="d">-    b.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-121" id="h9-0-121" class="i">+    a.execute(&quot;BEGIN&quot;)?;
</a><a href="#h9-0-122" id="h9-0-122" class="i">+    b.execute(&quot;BEGIN&quot;)?;
</a> 
     assert_row(
<a href="#h9-0-125" id="h9-0-125" class="d">-        b.execute(&quot;SELECT * FROM test WHERE id = 1&quot;).await?,
</a><a href="#h9-0-126" id="h9-0-126" class="i">+        b.execute(&quot;SELECT * FROM test WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;c&quot;.into())],
     );
<a href="#h9-0-129" id="h9-0-129" class="d">-    a.execute(&quot;UPDATE test SET value = &#39;a&#39; WHERE id = 1&quot;).await?;
</a><a href="#h9-0-130" id="h9-0-130" class="d">-    a.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h9-0-131" id="h9-0-131" class="i">+    a.execute(&quot;UPDATE test SET value = &#39;a&#39; WHERE id = 1&quot;)?;
</a><a href="#h9-0-132" id="h9-0-132" class="i">+    a.execute(&quot;COMMIT&quot;)?;
</a>     assert_row(
<a href="#h9-0-134" id="h9-0-134" class="d">-        b.execute(&quot;SELECT * FROM test WHERE id = 1&quot;).await?,
</a><a href="#h9-0-135" id="h9-0-135" class="i">+        b.execute(&quot;SELECT * FROM test WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;c&quot;.into())],
     );
 
     Ok(())
 }
 
<a href="#h9-0-142" id="h9-0-142" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h9-0-143" id="h9-0-143" class="i">+#[test]
</a> #[serial]
 // Read skew is when a reads 1 and 2, but b modifies 2 in between the reads.
<a href="#h9-0-146" id="h9-0-146" class="d">-async fn anomaly_read_skew() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-147" id="h9-0-147" class="d">-    let tc = TestCluster::run_with(5, dataset::TEST_TABLE).await?;
</a><a href="#h9-0-148" id="h9-0-148" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h9-0-149" id="h9-0-149" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h9-0-150" id="h9-0-150" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h9-0-151" id="h9-0-151" class="i">+fn anomaly_read_skew() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-152" id="h9-0-152" class="i">+    let tc = TestCluster::run_with(5, dataset::TEST_TABLE)?;
</a><a href="#h9-0-153" id="h9-0-153" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h9-0-154" id="h9-0-154" class="i">+    let mut b = tc.connect_any()?;
</a><a href="#h9-0-155" id="h9-0-155" class="i">+    let mut c = tc.connect_any()?;
</a> 
<a href="#h9-0-157" id="h9-0-157" class="d">-    c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;), (2, &#39;c&#39;)&quot;).await?;
</a><a href="#h9-0-158" id="h9-0-158" class="i">+    c.execute(&quot;INSERT INTO test VALUES (1, &#39;c&#39;), (2, &#39;c&#39;)&quot;)?;
</a> 
<a href="#h9-0-160" id="h9-0-160" class="d">-    a.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-161" id="h9-0-161" class="d">-    b.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-162" id="h9-0-162" class="i">+    a.execute(&quot;BEGIN&quot;)?;
</a><a href="#h9-0-163" id="h9-0-163" class="i">+    b.execute(&quot;BEGIN&quot;)?;
</a> 
     assert_row(
<a href="#h9-0-166" id="h9-0-166" class="d">-        a.execute(&quot;SELECT * FROM test WHERE id = 1&quot;).await?,
</a><a href="#h9-0-167" id="h9-0-167" class="i">+        a.execute(&quot;SELECT * FROM test WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;c&quot;.into())],
     );
<a href="#h9-0-170" id="h9-0-170" class="d">-    b.execute(&quot;UPDATE test SET value = &#39;b&#39; WHERE id = 2&quot;).await?;
</a><a href="#h9-0-171" id="h9-0-171" class="d">-    b.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h9-0-172" id="h9-0-172" class="i">+    b.execute(&quot;UPDATE test SET value = &#39;b&#39; WHERE id = 2&quot;)?;
</a><a href="#h9-0-173" id="h9-0-173" class="i">+    b.execute(&quot;COMMIT&quot;)?;
</a>     assert_row(
<a href="#h9-0-175" id="h9-0-175" class="d">-        a.execute(&quot;SELECT * FROM test WHERE id = 2&quot;).await?,
</a><a href="#h9-0-176" id="h9-0-176" class="i">+        a.execute(&quot;SELECT * FROM test WHERE id = 2&quot;)?,
</a>         vec![Value::Integer(2), Value::String(&quot;c&quot;.into())],
     );
 
     Ok(())
 }
 
<a href="#h9-0-183" id="h9-0-183" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h9-0-184" id="h9-0-184" class="i">+#[test]
</a> #[serial]
 // A phantom read is when a reads entries matching some predicate, but a modification by
 // b changes the entries that match the predicate such that a later read by a returns them.
<a href="#h9-0-188" id="h9-0-188" class="d">-async fn anomaly_phantom_read() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-189" id="h9-0-189" class="d">-    let tc = TestCluster::run_with(5, dataset::TEST_TABLE).await?;
</a><a href="#h9-0-190" id="h9-0-190" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h9-0-191" id="h9-0-191" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h9-0-192" id="h9-0-192" class="d">-    let mut c = tc.connect_any().await?;
</a><a href="#h9-0-193" id="h9-0-193" class="i">+fn anomaly_phantom_read() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-194" id="h9-0-194" class="i">+    let tc = TestCluster::run_with(5, dataset::TEST_TABLE)?;
</a><a href="#h9-0-195" id="h9-0-195" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h9-0-196" id="h9-0-196" class="i">+    let mut b = tc.connect_any()?;
</a><a href="#h9-0-197" id="h9-0-197" class="i">+    let mut c = tc.connect_any()?;
</a> 
<a href="#h9-0-199" id="h9-0-199" class="d">-    c.execute(&quot;INSERT INTO test VALUES (1, &#39;true&#39;), (2, &#39;false&#39;)&quot;).await?;
</a><a href="#h9-0-200" id="h9-0-200" class="i">+    c.execute(&quot;INSERT INTO test VALUES (1, &#39;true&#39;), (2, &#39;false&#39;)&quot;)?;
</a> 
<a href="#h9-0-202" id="h9-0-202" class="d">-    a.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-203" id="h9-0-203" class="d">-    b.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h9-0-204" id="h9-0-204" class="i">+    a.execute(&quot;BEGIN&quot;)?;
</a><a href="#h9-0-205" id="h9-0-205" class="i">+    b.execute(&quot;BEGIN&quot;)?;
</a> 
     assert_rows(
<a href="#h9-0-208" id="h9-0-208" class="d">-        a.execute(&quot;SELECT * FROM test WHERE value = &#39;true&#39;&quot;).await?,
</a><a href="#h9-0-209" id="h9-0-209" class="i">+        a.execute(&quot;SELECT * FROM test WHERE value = &#39;true&#39;&quot;)?,
</a>         vec![vec![Value::Integer(1), Value::String(&quot;true&quot;.into())]],
     );
<a href="#h9-0-212" id="h9-0-212" class="d">-    b.execute(&quot;UPDATE test SET value = &#39;true&#39; WHERE id = 2&quot;).await?;
</a><a href="#h9-0-213" id="h9-0-213" class="d">-    b.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h9-0-214" id="h9-0-214" class="i">+    b.execute(&quot;UPDATE test SET value = &#39;true&#39; WHERE id = 2&quot;)?;
</a><a href="#h9-0-215" id="h9-0-215" class="i">+    b.execute(&quot;COMMIT&quot;)?;
</a>     assert_rows(
<a href="#h9-0-217" id="h9-0-217" class="d">-        a.execute(&quot;SELECT * FROM test WHERE value = &#39;true&#39;&quot;).await?,
</a><a href="#h9-0-218" id="h9-0-218" class="i">+        a.execute(&quot;SELECT * FROM test WHERE value = &#39;true&#39;&quot;)?,
</a>         vec![vec![Value::Integer(1), Value::String(&quot;true&quot;.into())]],
     );
 
<b>diff --git a/<a id="h10" href="../file/tests/e2e/recovery.rs.html">tests/e2e/recovery.rs</a> b/<a href="../file/tests/e2e/recovery.rs.html">tests/e2e/recovery.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -4,47 +4,47 @@ use serial_test::serial;
</a> use toydb::error::{Error, Result};
 use toydb::sql::types::Value;
 
<a href="#h10-0-3" id="h10-0-3" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h10-0-4" id="h10-0-4" class="i">+#[test]
</a> #[serial]
 // A client disconnect or termination should roll back its transaction.
<a href="#h10-0-7" id="h10-0-7" class="d">-async fn client_disconnect_rollback() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-8" id="h10-0-8" class="d">-    let tc = TestCluster::run_with(5, dataset::TEST_TABLE).await?;
</a><a href="#h10-0-9" id="h10-0-9" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h10-0-10" id="h10-0-10" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h10-0-11" id="h10-0-11" class="i">+fn client_disconnect_rollback() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-12" id="h10-0-12" class="i">+    let tc = TestCluster::run_with(5, dataset::TEST_TABLE)?;
</a><a href="#h10-0-13" id="h10-0-13" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h10-0-14" id="h10-0-14" class="i">+    let mut b = tc.connect_any()?;
</a> 
<a href="#h10-0-16" id="h10-0-16" class="d">-    a.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h10-0-17" id="h10-0-17" class="d">-    a.execute(&quot;INSERT INTO test VALUES (1, &#39;a&#39;)&quot;).await?;
</a><a href="#h10-0-18" id="h10-0-18" class="i">+    a.execute(&quot;BEGIN&quot;)?;
</a><a href="#h10-0-19" id="h10-0-19" class="i">+    a.execute(&quot;INSERT INTO test VALUES (1, &#39;a&#39;)&quot;)?;
</a>     std::mem::drop(a);
 
     // This would fail with a serialization error if the txn is not rolled back.
<a href="#h10-0-23" id="h10-0-23" class="d">-    b.execute(&quot;INSERT INTO test VALUES (1, &#39;b&#39;)&quot;).await?;
</a><a href="#h10-0-24" id="h10-0-24" class="i">+    b.execute(&quot;INSERT INTO test VALUES (1, &#39;b&#39;)&quot;)?;
</a>     assert_row(
<a href="#h10-0-26" id="h10-0-26" class="d">-        b.execute(&quot;SELECT * FROM test WHERE id = 1&quot;).await?,
</a><a href="#h10-0-27" id="h10-0-27" class="i">+        b.execute(&quot;SELECT * FROM test WHERE id = 1&quot;)?,
</a>         vec![Value::Integer(1), Value::String(&quot;b&quot;.into())],
     );
 
     Ok(())
 }
 
<a href="#h10-0-34" id="h10-0-34" class="d">-#[tokio::test(flavor = &quot;multi_thread&quot;, worker_threads = 2)]
</a><a href="#h10-0-35" id="h10-0-35" class="i">+#[test]
</a> #[serial]
<a href="#h10-0-37" id="h10-0-37" class="d">-async fn client_commit_error() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-38" id="h10-0-38" class="d">-    let tc = TestCluster::run_with(5, dataset::TEST_TABLE).await?;
</a><a href="#h10-0-39" id="h10-0-39" class="d">-    let mut a = tc.connect_any().await?;
</a><a href="#h10-0-40" id="h10-0-40" class="d">-    let mut b = tc.connect_any().await?;
</a><a href="#h10-0-41" id="h10-0-41" class="i">+fn client_commit_error() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-42" id="h10-0-42" class="i">+    let tc = TestCluster::run_with(5, dataset::TEST_TABLE)?;
</a><a href="#h10-0-43" id="h10-0-43" class="i">+    let mut a = tc.connect_any()?;
</a><a href="#h10-0-44" id="h10-0-44" class="i">+    let mut b = tc.connect_any()?;
</a> 
<a href="#h10-0-46" id="h10-0-46" class="d">-    a.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h10-0-47" id="h10-0-47" class="d">-    a.execute(&quot;INSERT INTO test VALUES (1, &#39;a&#39;)&quot;).await?;
</a><a href="#h10-0-48" id="h10-0-48" class="i">+    a.execute(&quot;BEGIN&quot;)?;
</a><a href="#h10-0-49" id="h10-0-49" class="i">+    a.execute(&quot;INSERT INTO test VALUES (1, &#39;a&#39;)&quot;)?;
</a> 
     // When B gets a serialization error, it should still be in the txn and able to roll it back.
<a href="#h10-0-52" id="h10-0-52" class="d">-    b.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h10-0-53" id="h10-0-53" class="d">-    b.execute(&quot;INSERT INTO test VALUES (2, &#39;b&#39;)&quot;).await?;
</a><a href="#h10-0-54" id="h10-0-54" class="d">-    assert_eq!(b.execute(&quot;INSERT INTO test VALUES (1, &#39;b&#39;)&quot;).await, Err(Error::Serialization));
</a><a href="#h10-0-55" id="h10-0-55" class="d">-    b.execute(&quot;ROLLBACK&quot;).await?;
</a><a href="#h10-0-56" id="h10-0-56" class="i">+    b.execute(&quot;BEGIN&quot;)?;
</a><a href="#h10-0-57" id="h10-0-57" class="i">+    b.execute(&quot;INSERT INTO test VALUES (2, &#39;b&#39;)&quot;)?;
</a><a href="#h10-0-58" id="h10-0-58" class="i">+    assert_eq!(b.execute(&quot;INSERT INTO test VALUES (1, &#39;b&#39;)&quot;), Err(Error::Serialization));
</a><a href="#h10-0-59" id="h10-0-59" class="i">+    b.execute(&quot;ROLLBACK&quot;)?;
</a> 
     // Once rolled back, A should be able to write ID 2 and commit.
<a href="#h10-0-62" id="h10-0-62" class="d">-    a.execute(&quot;INSERT INTO test VALUES (2, &#39;a&#39;)&quot;).await?;
</a><a href="#h10-0-63" id="h10-0-63" class="d">-    a.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h10-0-64" id="h10-0-64" class="i">+    a.execute(&quot;INSERT INTO test VALUES (2, &#39;a&#39;)&quot;)?;
</a><a href="#h10-0-65" id="h10-0-65" class="i">+    a.execute(&quot;COMMIT&quot;)?;
</a> 
     Ok(())
 }
<b>diff --git a/<a id="h11" href="../file/tests/e2e/testcluster.rs.html">tests/e2e/testcluster.rs</a> b/<a href="../file/tests/e2e/testcluster.rs.html">tests/e2e/testcluster.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -31,22 +31,22 @@ impl TestCluster {
</a>     }
 
     /// Creates a new test cluster and starts it.
<a href="#h11-0-3" id="h11-0-3" class="d">-    pub async fn run(nodes: u8) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-0-4" id="h11-0-4" class="i">+    pub fn run(nodes: u8) -&gt; Result&lt;Self&gt; {
</a>         let mut tc = Self::new(nodes)?;
<a href="#h11-0-6" id="h11-0-6" class="d">-        tc.start().await?;
</a><a href="#h11-0-7" id="h11-0-7" class="i">+        tc.start()?;
</a>         Ok(tc)
     }
 
     /// Creates a new test cluster, starts it, and imports an initial dataset.
<a href="#h11-0-12" id="h11-0-12" class="d">-    pub async fn run_with(nodes: u8, init: &amp;str) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-0-13" id="h11-0-13" class="d">-        let tc = Self::run(nodes).await?;
</a><a href="#h11-0-14" id="h11-0-14" class="i">+    pub fn run_with(nodes: u8, init: &amp;str) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-0-15" id="h11-0-15" class="i">+        let tc = Self::run(nodes)?;
</a> 
<a href="#h11-0-17" id="h11-0-17" class="d">-        let mut c = tc.connect_any().await?;
</a><a href="#h11-0-18" id="h11-0-18" class="d">-        c.execute(&quot;BEGIN&quot;).await?;
</a><a href="#h11-0-19" id="h11-0-19" class="i">+        let mut c = tc.connect_any()?;
</a><a href="#h11-0-20" id="h11-0-20" class="i">+        c.execute(&quot;BEGIN&quot;)?;
</a>         for stmt in init.split(&#39;;&#39;) {
<a href="#h11-0-22" id="h11-0-22" class="d">-            c.execute(stmt).await?;
</a><a href="#h11-0-23" id="h11-0-23" class="i">+            c.execute(stmt)?;
</a>         }
<a href="#h11-0-25" id="h11-0-25" class="d">-        c.execute(&quot;COMMIT&quot;).await?;
</a><a href="#h11-0-26" id="h11-0-26" class="i">+        c.execute(&quot;COMMIT&quot;)?;
</a> 
         Ok(tc)
     }
<a href="#h11-1" id="h11-1" class="h">@@ -105,9 +105,7 @@ impl TestCluster {
</a>     }
 
     /// Starts the test cluster. It keeps running until the cluster is dropped.
<a href="#h11-1-3" id="h11-1-3" class="d">-    ///
</a><a href="#h11-1-4" id="h11-1-4" class="d">-    /// TODO: this only uses async because Client is still async. Remove it.
</a><a href="#h11-1-5" id="h11-1-5" class="d">-    pub async fn start(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h11-1-6" id="h11-1-6" class="i">+    pub fn start(&amp;mut self) -&gt; Result&lt;()&gt; {
</a>         // Build the binary.
         let build = escargot::CargoBuild::new().bin(&quot;toydb&quot;).run().expect(&quot;Failed to build binary&quot;);
 
<a href="#h11-2" id="h11-2" class="h">@@ -140,12 +138,12 @@ impl TestCluster {
</a> 
         let deadline = std::time::Instant::now().checked_add(TIMEOUT).unwrap();
         for id in self.ids() {
<a href="#h11-2-3" id="h11-2-3" class="d">-            while let Err(e) = async { self.connect(id).await?.status().await }.await {
</a><a href="#h11-2-4" id="h11-2-4" class="i">+            while let Err(e) = self.connect(id).and_then(|mut c| c.status()) {
</a>                 self.assert_alive();
                 if std::time::Instant::now() &gt;= deadline {
                     return Err(e);
                 }
<a href="#h11-2-9" id="h11-2-9" class="d">-                tokio::time::sleep(COOLDOWN).await;
</a><a href="#h11-2-10" id="h11-2-10" class="i">+                std::thread::sleep(COOLDOWN);
</a>             }
         }
 
<a href="#h11-3" id="h11-3" class="h">@@ -153,14 +151,14 @@ impl TestCluster {
</a>     }
 
     /// Connects to the given cluster node.
<a href="#h11-3-3" id="h11-3-3" class="d">-    pub async fn connect(&amp;self, id: NodeID) -&gt; Result&lt;Client&gt; {
</a><a href="#h11-3-4" id="h11-3-4" class="i">+    pub fn connect(&amp;self, id: NodeID) -&gt; Result&lt;Client&gt; {
</a>         self.assert_id(id);
<a href="#h11-3-6" id="h11-3-6" class="d">-        Client::new(self.node_address_sql(id)).await
</a><a href="#h11-3-7" id="h11-3-7" class="i">+        Client::new(self.node_address_sql(id))
</a>     }
 
     /// Connects to a random cluster node.
<a href="#h11-3-11" id="h11-3-11" class="d">-    pub async fn connect_any(&amp;self) -&gt; Result&lt;Client&gt; {
</a><a href="#h11-3-12" id="h11-3-12" class="d">-        self.connect(rand::thread_rng().gen_range(1..=self.nodes)).await
</a><a href="#h11-3-13" id="h11-3-13" class="i">+    pub fn connect_any(&amp;self) -&gt; Result&lt;Client&gt; {
</a><a href="#h11-3-14" id="h11-3-14" class="i">+        self.connect(rand::thread_rng().gen_range(1..=self.nodes))
</a>     }
 }
 
</pre>
</div>
</body>
</html>
