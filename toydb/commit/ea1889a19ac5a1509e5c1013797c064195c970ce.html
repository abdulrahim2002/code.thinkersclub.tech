<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: clean up execution module - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/ea1889a19ac5a1509e5c1013797c064195c970ce.html">ea1889a19ac5a1509e5c1013797c064195c970ce</a>
<b>parent</b> <a href="../commit/5747a71845581db1919e53c90f283943f005b6df.html">5747a71845581db1919e53c90f283943f005b6df</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 21 Jul 2024 18:23:26 +0200

sql: clean up execution module

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/execution/aggregate.rs</a></td><td> | </td><td class="num">62</td><td><span class="i">+++++++++++++++++++++++</span><span class="d">---------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/execution/execute.rs</a></td><td> | </td><td class="num">29</td><td><span class="i">++++++++++++++++++++++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/execution/join.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">++++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/execution/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/execution/source.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/execution/transform.rs</a></td><td> | </td><td class="num">46</td><td><span class="i">++++++++++++++++++++</span><span class="d">--------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/execution/write.rs</a></td><td> | </td><td class="num">34</td><td><span class="i">++++++++++++++++</span><span class="d">------------------</span></td></tr>
</table></pre><pre>7 files changed, 98 insertions(+), 104 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/execution/aggregate.rs.html">src/sql/execution/aggregate.rs</a> b/<a href="../file/src/sql/execution/aggregate.rs.html">src/sql/execution/aggregate.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -6,13 +6,14 @@ use itertools::Itertools as _;
</a> use std::collections::BTreeMap;
 
 /// Aggregates row values from the source according to the aggregates, using the
<a href="#h0-0-3" id="h0-0-3" class="d">-/// group_by expressions as buckets.
</a><a href="#h0-0-4" id="h0-0-4" class="d">-pub(super) fn aggregate(
</a><a href="#h0-0-5" id="h0-0-5" class="i">+/// group_by expressions as buckets. Emits rows with group_by buckets then
</a><a href="#h0-0-6" id="h0-0-6" class="i">+/// aggregates in the given order.
</a><a href="#h0-0-7" id="h0-0-7" class="i">+pub fn aggregate(
</a>     mut source: Rows,
     group_by: Vec&lt;Expression&gt;,
     aggregates: Vec&lt;Aggregate&gt;,
 ) -&gt; Result&lt;Rows&gt; {
<a href="#h0-0-12" id="h0-0-12" class="d">-    let mut aggregator = Aggregator::new(aggregates, group_by);
</a><a href="#h0-0-13" id="h0-0-13" class="i">+    let mut aggregator = Aggregator::new(group_by, aggregates);
</a>     while let Some(row) = source.next().transpose()? {
         aggregator.add(row)?;
     }
<a href="#h0-1" id="h0-1" class="h">@@ -23,39 +24,38 @@ pub(super) fn aggregate(
</a> struct Aggregator {
     /// Bucketed accumulators (by group_by values).
     buckets: BTreeMap&lt;Vec&lt;Value&gt;, Vec&lt;Accumulator&gt;&gt;,
<a href="#h0-1-3" id="h0-1-3" class="d">-    /// The set of empty accumulators.
</a><a href="#h0-1-4" id="h0-1-4" class="i">+    /// The set of empty accumulators. Used to create new buckets.
</a>     empty: Vec&lt;Accumulator&gt;,
<a href="#h0-1-6" id="h0-1-6" class="d">-    /// Expressions to accumulate. Indexes map to accumulators.
</a><a href="#h0-1-7" id="h0-1-7" class="d">-    exprs: Vec&lt;Expression&gt;,
</a>     /// Group by expressions. Indexes map to bucket values.
     group_by: Vec&lt;Expression&gt;,
<a href="#h0-1-10" id="h0-1-10" class="i">+    /// Expressions to accumulate. Indexes map to accumulators.
</a><a href="#h0-1-11" id="h0-1-11" class="i">+    expressions: Vec&lt;Expression&gt;,
</a> }
 
 impl Aggregator {
<a href="#h0-1-15" id="h0-1-15" class="d">-    /// Creates a new aggregator for the given aggregates and GROUP BY buckets.
</a><a href="#h0-1-16" id="h0-1-16" class="d">-    fn new(aggregates: Vec&lt;Aggregate&gt;, group_by: Vec&lt;Expression&gt;) -&gt; Self {
</a><a href="#h0-1-17" id="h0-1-17" class="i">+    /// Creates a new aggregator for the given GROUP BY buckets and aggregates.
</a><a href="#h0-1-18" id="h0-1-18" class="i">+    fn new(group_by: Vec&lt;Expression&gt;, aggregates: Vec&lt;Aggregate&gt;) -&gt; Self {
</a>         use Aggregate::*;
         let accumulators = aggregates.iter().map(Accumulator::new).collect();
<a href="#h0-1-21" id="h0-1-21" class="d">-        let exprs = aggregates
</a><a href="#h0-1-22" id="h0-1-22" class="i">+        let expressions = aggregates
</a>             .into_iter()
             .map(|aggregate| match aggregate {
                 Average(expr) | Count(expr) | Max(expr) | Min(expr) | Sum(expr) =&gt; expr,
             })
             .collect();
<a href="#h0-1-28" id="h0-1-28" class="d">-        Self { buckets: BTreeMap::new(), empty: accumulators, group_by, exprs }
</a><a href="#h0-1-29" id="h0-1-29" class="i">+        Self { buckets: BTreeMap::new(), empty: accumulators, group_by, expressions }
</a>     }
 
     /// Adds a row to the aggregator.
     fn add(&amp;mut self, row: Row) -&gt; Result&lt;()&gt; {
         // Compute the bucket value.
         let bucket: Vec&lt;Value&gt; =
<a href="#h0-1-36" id="h0-1-36" class="d">-            self.group_by.iter().map(|expr| expr.evaluate(Some(&amp;row))).collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h0-1-37" id="h0-1-37" class="i">+            self.group_by.iter().map(|expr| expr.evaluate(Some(&amp;row))).try_collect()?;
</a> 
         // Compute and accumulate the input values.
         let accumulators = self.buckets.entry(bucket).or_insert_with(|| self.empty.clone());
<a href="#h0-1-41" id="h0-1-41" class="d">-        for (accumulator, expr) in accumulators.iter_mut().zip(&amp;self.exprs) {
</a><a href="#h0-1-42" id="h0-1-42" class="d">-            let value = expr.evaluate(Some(&amp;row))?;
</a><a href="#h0-1-43" id="h0-1-43" class="d">-            accumulator.add(value)?;
</a><a href="#h0-1-44" id="h0-1-44" class="i">+        for (accumulator, expr) in accumulators.iter_mut().zip(&amp;self.expressions) {
</a><a href="#h0-1-45" id="h0-1-45" class="i">+            accumulator.add(expr.evaluate(Some(&amp;row))?)?;
</a>         }
         Ok(())
     }
<a href="#h0-2" id="h0-2" class="h">@@ -108,35 +108,19 @@ impl Accumulator {
</a> 
     /// Adds a value to the accumulator.
     fn add(&amp;mut self, value: Value) -&gt; Result&lt;()&gt; {
<a href="#h0-2-3" id="h0-2-3" class="d">-        use std::cmp::Ordering;
</a><a href="#h0-2-4" id="h0-2-4" class="d">-
</a><a href="#h0-2-5" id="h0-2-5" class="d">-        // NULL values are ignored in aggregates.
</a><a href="#h0-2-6" id="h0-2-6" class="i">+        // Aggregates ignore NULL values.
</a>         if value == Value::Null {
             return Ok(());
         }
<a href="#h0-2-10" id="h0-2-10" class="d">-
</a>         match self {
<a href="#h0-2-12" id="h0-2-12" class="d">-            Self::Average { sum, count } =&gt; {
</a><a href="#h0-2-13" id="h0-2-13" class="d">-                *sum = sum.checked_add(&amp;value)?;
</a><a href="#h0-2-14" id="h0-2-14" class="d">-                *count += 1;
</a><a href="#h0-2-15" id="h0-2-15" class="d">-            }
</a><a href="#h0-2-16" id="h0-2-16" class="d">-
</a><a href="#h0-2-17" id="h0-2-17" class="d">-            Self::Count(c) =&gt; *c += 1,
</a><a href="#h0-2-18" id="h0-2-18" class="d">-
</a><a href="#h0-2-19" id="h0-2-19" class="i">+            Self::Average { sum, count } =&gt; (*sum, *count) = (sum.checked_add(&amp;value)?, *count + 1),
</a><a href="#h0-2-20" id="h0-2-20" class="i">+            Self::Count(count) =&gt; *count += 1,
</a>             Self::Max(max @ None) =&gt; *max = Some(value),
<a href="#h0-2-22" id="h0-2-22" class="d">-            Self::Max(Some(max)) =&gt; {
</a><a href="#h0-2-23" id="h0-2-23" class="d">-                if value.cmp(max) == Ordering::Greater {
</a><a href="#h0-2-24" id="h0-2-24" class="d">-                    *max = value
</a><a href="#h0-2-25" id="h0-2-25" class="d">-                }
</a><a href="#h0-2-26" id="h0-2-26" class="d">-            }
</a><a href="#h0-2-27" id="h0-2-27" class="d">-
</a><a href="#h0-2-28" id="h0-2-28" class="i">+            Self::Max(Some(max)) if value &gt; *max =&gt; *max = value,
</a><a href="#h0-2-29" id="h0-2-29" class="i">+            Self::Max(Some(_)) =&gt; {}
</a>             Self::Min(min @ None) =&gt; *min = Some(value),
<a href="#h0-2-31" id="h0-2-31" class="d">-            Self::Min(Some(min)) =&gt; {
</a><a href="#h0-2-32" id="h0-2-32" class="d">-                if value.cmp(min) == Ordering::Less {
</a><a href="#h0-2-33" id="h0-2-33" class="d">-                    *min = value
</a><a href="#h0-2-34" id="h0-2-34" class="d">-                }
</a><a href="#h0-2-35" id="h0-2-35" class="d">-            }
</a><a href="#h0-2-36" id="h0-2-36" class="d">-
</a><a href="#h0-2-37" id="h0-2-37" class="i">+            Self::Min(Some(min)) if value &lt; *min =&gt; *min = value,
</a><a href="#h0-2-38" id="h0-2-38" class="i">+            Self::Min(Some(_)) =&gt; {}
</a>             Self::Sum(sum @ None) =&gt; *sum = Some(Value::Integer(0).checked_add(&amp;value)?),
             Self::Sum(Some(sum)) =&gt; *sum = sum.checked_add(&amp;value)?,
         }
<a href="#h0-3" id="h0-3" class="h">@@ -148,9 +132,9 @@ impl Accumulator {
</a>         Ok(match self {
             Self::Average { count: 0, sum: _ } =&gt; Value::Null,
             Self::Average { count, sum } =&gt; sum.checked_div(&amp;Value::Integer(count))?,
<a href="#h0-3-3" id="h0-3-3" class="d">-            Self::Count(c) =&gt; c.into(),
</a><a href="#h0-3-4" id="h0-3-4" class="i">+            Self::Count(count) =&gt; count.into(),
</a><a href="#h0-3-5" id="h0-3-5" class="i">+            Self::Max(Some(value)) | Self::Min(Some(value)) | Self::Sum(Some(value)) =&gt; value,
</a>             Self::Max(None) | Self::Min(None) | Self::Sum(None) =&gt; Value::Null,
<a href="#h0-3-7" id="h0-3-7" class="d">-            Self::Max(Some(v)) | Self::Min(Some(v)) | Self::Sum(Some(v)) =&gt; v,
</a>         })
     }
 }
<b>diff --git a/<a id="h1" href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a> b/<a href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,8 +1,4 @@
</a><a href="#h1-0-0" id="h1-0-0" class="d">-use super::aggregate;
</a><a href="#h1-0-1" id="h1-0-1" class="d">-use super::join;
</a><a href="#h1-0-2" id="h1-0-2" class="d">-use super::source;
</a><a href="#h1-0-3" id="h1-0-3" class="d">-use super::transform;
</a><a href="#h1-0-4" id="h1-0-4" class="d">-use super::write;
</a><a href="#h1-0-5" id="h1-0-5" class="i">+use super::{aggregate, join, source, transform, write};
</a> use crate::error::Result;
 use crate::sql::engine::{Catalog, Transaction};
 use crate::sql::planner::{Node, Plan};
<a href="#h1-1" id="h1-1" class="h">@@ -56,6 +52,29 @@ pub fn execute_plan(
</a> }
 
 /// Recursively executes a query plan node, returning a row iterator.
<a href="#h1-1-3" id="h1-1-3" class="i">+///
</a><a href="#h1-1-4" id="h1-1-4" class="i">+/// Rows stream through the plan node tree from the branches to the root. Nodes
</a><a href="#h1-1-5" id="h1-1-5" class="i">+/// recursively pull input rows upwards from their child node(s), process them,
</a><a href="#h1-1-6" id="h1-1-6" class="i">+/// and hand the resulting rows off to their parent node.
</a><a href="#h1-1-7" id="h1-1-7" class="i">+///
</a><a href="#h1-1-8" id="h1-1-8" class="i">+/// Below is an example of an (unoptimized) query plan:
</a><a href="#h1-1-9" id="h1-1-9" class="i">+///
</a><a href="#h1-1-10" id="h1-1-10" class="i">+/// SELECT title, released, genres.name AS genre
</a><a href="#h1-1-11" id="h1-1-11" class="i">+/// FROM movies INNER JOIN genres ON movies.genre_id = genres.id
</a><a href="#h1-1-12" id="h1-1-12" class="i">+/// WHERE released &gt;= 2000 ORDER BY released
</a><a href="#h1-1-13" id="h1-1-13" class="i">+///
</a><a href="#h1-1-14" id="h1-1-14" class="i">+/// Order: movies.released desc
</a><a href="#h1-1-15" id="h1-1-15" class="i">+/// └─ Projection: movies.title, movies.released, genres.name as genre
</a><a href="#h1-1-16" id="h1-1-16" class="i">+///    └─ Filter: movies.released &gt;= 2000
</a><a href="#h1-1-17" id="h1-1-17" class="i">+///       └─ NestedLoopJoin: inner on movies.genre_id = genres.id
</a><a href="#h1-1-18" id="h1-1-18" class="i">+///          ├─ Scan: movies
</a><a href="#h1-1-19" id="h1-1-19" class="i">+///          └─ Scan: genres
</a><a href="#h1-1-20" id="h1-1-20" class="i">+///
</a><a href="#h1-1-21" id="h1-1-21" class="i">+/// Rows flow from the tree leaves to the root. The Scan nodes read and emit
</a><a href="#h1-1-22" id="h1-1-22" class="i">+/// table rows from storage. They are passed to the NestedLoopJoin node which
</a><a href="#h1-1-23" id="h1-1-23" class="i">+/// joins the rows from the two tables, then the Filter node discards old
</a><a href="#h1-1-24" id="h1-1-24" class="i">+/// movies, the Projection node picks out the requested columns, and the Order
</a><a href="#h1-1-25" id="h1-1-25" class="i">+/// node sorts them before emitting the rows to the client.
</a> pub fn execute(node: Node, txn: &amp;impl Transaction) -&gt; Result&lt;Rows&gt; {
     Ok(match node {
         Node::Aggregate { source, group_by, aggregates } =&gt; {
<b>diff --git a/<a id="h2" href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a> b/<a href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h2-0-0" id="h2-0-0" class="d">-use crate::errdata;
</a><a href="#h2-0-1" id="h2-0-1" class="i">+use crate::errinput;
</a> use crate::error::Result;
 use crate::sql::types::{Expression, Row, Rows, Value};
 
<a href="#h2-1" id="h2-1" class="h">@@ -11,7 +11,7 @@ use std::iter::Peekable;
</a> /// there are no matches in the right source for a row in the left source, a
 /// joined row with NULL values for the right source is returned (typically used
 /// for a LEFT JOIN).
<a href="#h2-1-3" id="h2-1-3" class="d">-pub(super) fn nested_loop(
</a><a href="#h2-1-4" id="h2-1-4" class="i">+pub fn nested_loop(
</a>     left: Rows,
     right: Rows,
     right_size: usize,
<a href="#h2-2" id="h2-2" class="h">@@ -57,7 +57,7 @@ impl NestedLoopIterator {
</a>         Ok(Self { left, right, right_init, right_size, right_match: false, predicate, outer })
     }
 
<a href="#h2-2-3" id="h2-2-3" class="d">-    // Returns the next joined row, if any, with error handling.
</a><a href="#h2-2-4" id="h2-2-4" class="i">+    // Returns the next joined row, if any.
</a>     fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
         // While there is a valid left row, look for a right-hand match to return.
         while let Some(Ok(left_row)) = self.left.peek() {
<a href="#h2-3" id="h2-3" class="h">@@ -70,7 +70,7 @@ impl NestedLoopIterator {
</a>                     Some(predicate) =&gt; match predicate.evaluate(Some(&amp;row))? {
                         Value::Boolean(true) =&gt; true,
                         Value::Boolean(false) | Value::Null =&gt; false,
<a href="#h2-3-3" id="h2-3-3" class="d">-                        v =&gt; return errdata!(&quot;join predicate returned {v}, expected boolean&quot;),
</a><a href="#h2-3-4" id="h2-3-4" class="i">+                        v =&gt; return errinput!(&quot;join predicate returned {v}, expected boolean&quot;),
</a>                     },
                     None =&gt; true,
                 };
<a href="#h2-4" id="h2-4" class="h">@@ -118,7 +118,7 @@ impl Iterator for NestedLoopIterator {
</a> /// matching rows in the hash table. If outer is true, and there is no match
 /// in the right source for a row in the left source, a row with NULL values
 /// for the right source is emitted instead.
<a href="#h2-4-3" id="h2-4-3" class="d">-pub(super) fn hash(
</a><a href="#h2-4-4" id="h2-4-4" class="i">+pub fn hash(
</a>     left: Rows,
     left_column: usize,
     right: Rows,
<a href="#h2-5" id="h2-5" class="h">@@ -141,7 +141,7 @@ pub(super) fn hash(
</a>     let empty = std::iter::repeat(Value::Null).take(right_size);
 
     // Set up the join iterator.
<a href="#h2-5-3" id="h2-5-3" class="d">-    Ok(Box::new(left.flat_map(move |result| -&gt; Rows {
</a><a href="#h2-5-4" id="h2-5-4" class="i">+    let join = left.flat_map(move |result| -&gt; Rows {
</a>         // Pass through errors.
         let Ok(row) = result else {
             return Box::new(std::iter::once(result));
<a href="#h2-6" id="h2-6" class="h">@@ -159,5 +159,6 @@ pub(super) fn hash(
</a>             }
             None =&gt; Box::new(std::iter::empty()),
         }
<a href="#h2-6-3" id="h2-6-3" class="d">-    })))
</a><a href="#h2-6-4" id="h2-6-4" class="i">+    });
</a><a href="#h2-6-5" id="h2-6-5" class="i">+    Ok(Box::new(join))
</a> }
<b>diff --git a/<a id="h3" href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a> b/<a href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,3 +1,5 @@
</a><a href="#h3-0-0" id="h3-0-0" class="i">+//! Executes a `Plan` against a `sql::engine::Engine`.
</a><a href="#h3-0-1" id="h3-0-1" class="i">+
</a> mod aggregate;
 mod execute;
 mod join;
<b>diff --git a/<a id="h4" href="../file/src/sql/execution/source.rs.html">src/sql/execution/source.rs</a> b/<a href="../file/src/sql/execution/source.rs.html">src/sql/execution/source.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -3,21 +3,17 @@ use crate::sql::engine::Transaction;
</a> use crate::sql::types::{Expression, Rows, Table, Value};
 
 /// A table scan source.
<a href="#h4-0-3" id="h4-0-3" class="d">-pub(super) fn scan(
</a><a href="#h4-0-4" id="h4-0-4" class="d">-    txn: &amp;impl Transaction,
</a><a href="#h4-0-5" id="h4-0-5" class="d">-    table: Table,
</a><a href="#h4-0-6" id="h4-0-6" class="d">-    filter: Option&lt;Expression&gt;,
</a><a href="#h4-0-7" id="h4-0-7" class="d">-) -&gt; Result&lt;Rows&gt; {
</a><a href="#h4-0-8" id="h4-0-8" class="i">+pub fn scan(txn: &amp;impl Transaction, table: Table, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Rows&gt; {
</a>     Ok(Box::new(txn.scan(&amp;table.name, filter)?))
 }
 
 /// A primary key lookup source.
<a href="#h4-0-13" id="h4-0-13" class="d">-pub(super) fn lookup_key(txn: &amp;impl Transaction, table: String, keys: Vec&lt;Value&gt;) -&gt; Result&lt;Rows&gt; {
</a><a href="#h4-0-14" id="h4-0-14" class="i">+pub fn lookup_key(txn: &amp;impl Transaction, table: String, keys: Vec&lt;Value&gt;) -&gt; Result&lt;Rows&gt; {
</a>     Ok(Box::new(txn.get(&amp;table, &amp;keys)?.into_iter().map(Ok)))
 }
 
 /// An index lookup source.
<a href="#h4-0-19" id="h4-0-19" class="d">-pub(super) fn lookup_index(
</a><a href="#h4-0-20" id="h4-0-20" class="i">+pub fn lookup_index(
</a>     txn: &amp;impl Transaction,
     table: String,
     column: String,
<a href="#h4-1" id="h4-1" class="h">@@ -28,11 +24,11 @@ pub(super) fn lookup_index(
</a> }
 
 /// Returns nothing. Used to short-circuit nodes that can&#39;t produce any rows.
<a href="#h4-1-3" id="h4-1-3" class="d">-pub(super) fn nothing() -&gt; Rows {
</a><a href="#h4-1-4" id="h4-1-4" class="i">+pub fn nothing() -&gt; Rows {
</a>     Box::new(std::iter::empty())
 }
 
 /// Emits predefined constant values.
<a href="#h4-1-9" id="h4-1-9" class="d">-pub(super) fn values(rows: Vec&lt;Vec&lt;Expression&gt;&gt;) -&gt; Rows {
</a><a href="#h4-1-10" id="h4-1-10" class="i">+pub fn values(rows: Vec&lt;Vec&lt;Expression&gt;&gt;) -&gt; Rows {
</a>     Box::new(rows.into_iter().map(|row| row.into_iter().map(|expr| expr.evaluate(None)).collect()))
 }
<b>diff --git a/<a id="h5" href="../file/src/sql/execution/transform.rs.html">src/sql/execution/transform.rs</a> b/<a href="../file/src/sql/execution/transform.rs.html">src/sql/execution/transform.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,17 +1,16 @@
</a><a href="#h5-0-0" id="h5-0-0" class="d">-use itertools::izip;
</a><a href="#h5-0-1" id="h5-0-1" class="d">-
</a> use crate::errinput;
 use crate::error::Result;
 use crate::sql::planner::Direction;
 use crate::sql::types::{Expression, Rows, Value};
 
<a href="#h5-0-7" id="h5-0-7" class="i">+use itertools::{izip, Itertools as _};
</a><a href="#h5-0-8" id="h5-0-8" class="i">+
</a> /// Filters the input rows (i.e. WHERE).
<a href="#h5-0-10" id="h5-0-10" class="d">-pub(super) fn filter(source: Rows, predicate: Expression) -&gt; Rows {
</a><a href="#h5-0-11" id="h5-0-11" class="i">+pub fn filter(source: Rows, predicate: Expression) -&gt; Rows {
</a>     Box::new(source.filter_map(move |r| {
         r.and_then(|row| match predicate.evaluate(Some(&amp;row))? {
             Value::Boolean(true) =&gt; Ok(Some(row)),
<a href="#h5-0-15" id="h5-0-15" class="d">-            Value::Boolean(false) =&gt; Ok(None),
</a><a href="#h5-0-16" id="h5-0-16" class="d">-            Value::Null =&gt; Ok(None),
</a><a href="#h5-0-17" id="h5-0-17" class="i">+            Value::Boolean(false) | Value::Null =&gt; Ok(None),
</a>             value =&gt; errinput!(&quot;filter returned {value}, expected boolean&quot;,),
         })
         .transpose()
<a href="#h5-1" id="h5-1" class="h">@@ -19,28 +18,25 @@ pub(super) fn filter(source: Rows, predicate: Expression) -&gt; Rows {
</a> }
 
 /// Limits the result to the given number of rows (i.e. LIMIT).
<a href="#h5-1-3" id="h5-1-3" class="d">-pub(super) fn limit(source: Rows, limit: usize) -&gt; Rows {
</a><a href="#h5-1-4" id="h5-1-4" class="i">+pub fn limit(source: Rows, limit: usize) -&gt; Rows {
</a>     Box::new(source.take(limit))
 }
 
 /// Skips the given number of rows (i.e. OFFSET).
<a href="#h5-1-9" id="h5-1-9" class="d">-pub(super) fn offset(source: Rows, offset: usize) -&gt; Rows {
</a><a href="#h5-1-10" id="h5-1-10" class="i">+pub fn offset(source: Rows, offset: usize) -&gt; Rows {
</a>     Box::new(source.skip(offset))
 }
 
 /// Sorts the rows (i.e. ORDER BY).
<a href="#h5-1-15" id="h5-1-15" class="d">-pub(super) fn order(source: Rows, order: Vec&lt;(Expression, Direction)&gt;) -&gt; Result&lt;Rows&gt; {
</a><a href="#h5-1-16" id="h5-1-16" class="i">+pub fn order(source: Rows, order: Vec&lt;(Expression, Direction)&gt;) -&gt; Result&lt;Rows&gt; {
</a>     // We can&#39;t use sort_by_cached_key(), since expression evaluation is
     // fallible, and since we may have to vary the sort direction of each
     // expression. Precompute the sort values instead, and map them based on
     // the row index.
<a href="#h5-1-21" id="h5-1-21" class="d">-    let mut irows: Vec&lt;_&gt; =
</a><a href="#h5-1-22" id="h5-1-22" class="d">-        source.enumerate().map(|(i, r)| r.map(|row| (i, row))).collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h5-1-23" id="h5-1-23" class="d">-
</a><a href="#h5-1-24" id="h5-1-24" class="i">+    let mut irows: Vec&lt;_&gt; = source.enumerate().map(|(i, r)| r.map(|row| (i, row))).try_collect()?;
</a>     let mut sort_values = Vec::with_capacity(irows.len());
     for (_, row) in &amp;irows {
<a href="#h5-1-27" id="h5-1-27" class="d">-        let values: Vec&lt;_&gt; =
</a><a href="#h5-1-28" id="h5-1-28" class="d">-            order.iter().map(|(e, _)| e.evaluate(Some(row))).collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h5-1-29" id="h5-1-29" class="i">+        let values: Vec&lt;_&gt; = order.iter().map(|(e, _)| e.evaluate(Some(row))).try_collect()?;
</a>         sort_values.push(values)
     }
 
<a href="#h5-2" id="h5-2" class="h">@@ -60,24 +56,22 @@ pub(super) fn order(source: Rows, order: Vec&lt;(Expression, Direction)&gt;) -&gt; Result
</a> }
 
 /// Projects the rows using the given expressions (i.e. SELECT).
<a href="#h5-2-3" id="h5-2-3" class="d">-pub(super) fn project(source: Rows, expressions: Vec&lt;Expression&gt;) -&gt; Rows {
</a><a href="#h5-2-4" id="h5-2-4" class="d">-    Box::new(source.map(move |r| {
</a><a href="#h5-2-5" id="h5-2-5" class="d">-        r.and_then(|row| expressions.iter().map(|e| e.evaluate(Some(&amp;row))).collect())
</a><a href="#h5-2-6" id="h5-2-6" class="i">+pub fn project(source: Rows, expressions: Vec&lt;Expression&gt;) -&gt; Rows {
</a><a href="#h5-2-7" id="h5-2-7" class="i">+    Box::new(source.map(move |result| {
</a><a href="#h5-2-8" id="h5-2-8" class="i">+        result.and_then(|row| expressions.iter().map(|e| e.evaluate(Some(&amp;row))).collect())
</a>     }))
 }
 
 /// Remaps source columns to target column indexes, or drops them if None.
<a href="#h5-2-13" id="h5-2-13" class="d">-pub(super) fn remap(source: Rows, targets: Vec&lt;Option&lt;usize&gt;&gt;) -&gt; Rows {
</a><a href="#h5-2-14" id="h5-2-14" class="i">+pub fn remap(source: Rows, targets: Vec&lt;Option&lt;usize&gt;&gt;) -&gt; Rows {
</a>     let size = targets.iter().filter_map(|v| *v).map(|i| i + 1).max().unwrap_or(0);
<a href="#h5-2-16" id="h5-2-16" class="d">-    Box::new(source.map(move |r| {
</a><a href="#h5-2-17" id="h5-2-17" class="d">-        r.map(|row| {
</a><a href="#h5-2-18" id="h5-2-18" class="d">-            let mut out = vec![Value::Null; size];
</a><a href="#h5-2-19" id="h5-2-19" class="d">-            for (value, target) in row.into_iter().zip(&amp;targets) {
</a><a href="#h5-2-20" id="h5-2-20" class="d">-                if let Some(index) = target {
</a><a href="#h5-2-21" id="h5-2-21" class="d">-                    out[*index] = value;
</a><a href="#h5-2-22" id="h5-2-22" class="d">-                }
</a><a href="#h5-2-23" id="h5-2-23" class="i">+    Box::new(source.map_ok(move |row| {
</a><a href="#h5-2-24" id="h5-2-24" class="i">+        let mut out = vec![Value::Null; size];
</a><a href="#h5-2-25" id="h5-2-25" class="i">+        for (value, target) in row.into_iter().zip(&amp;targets) {
</a><a href="#h5-2-26" id="h5-2-26" class="i">+            if let Some(index) = target {
</a><a href="#h5-2-27" id="h5-2-27" class="i">+                out[*index] = value;
</a>             }
<a href="#h5-2-29" id="h5-2-29" class="d">-            out
</a><a href="#h5-2-30" id="h5-2-30" class="d">-        })
</a><a href="#h5-2-31" id="h5-2-31" class="i">+        }
</a><a href="#h5-2-32" id="h5-2-32" class="i">+        out
</a>     }))
 }
<b>diff --git a/<a id="h6" href="../file/src/sql/execution/write.rs.html">src/sql/execution/write.rs</a> b/<a href="../file/src/sql/execution/write.rs.html">src/sql/execution/write.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,21 +1,21 @@
</a> use crate::errinput;
 use crate::error::Result;
 use crate::sql::engine::Transaction;
<a href="#h6-0-3" id="h6-0-3" class="d">-use crate::sql::types::{Expression, Rows, Table};
</a><a href="#h6-0-4" id="h6-0-4" class="i">+use crate::sql::types::{Expression, Rows, Table, Value};
</a> 
<a href="#h6-0-6" id="h6-0-6" class="i">+use itertools::Itertools as _;
</a> use std::collections::{BTreeMap, HashMap};
 
 /// Deletes rows, taking primary keys from the source (i.e. DELETE) using the
 /// primary_key column index. Returns the number of rows deleted.
<a href="#h6-0-11" id="h6-0-11" class="d">-pub(super) fn delete(
</a><a href="#h6-0-12" id="h6-0-12" class="i">+pub fn delete(
</a>     txn: &amp;impl Transaction,
     table: String,
     primary_key: usize,
     source: Rows,
 ) -&gt; Result&lt;u64&gt; {
<a href="#h6-0-18" id="h6-0-18" class="d">-    let ids = source
</a><a href="#h6-0-19" id="h6-0-19" class="d">-        .map(|r| r.map(|row| row.into_iter().nth(primary_key).expect(&quot;short row&quot;)))
</a><a href="#h6-0-20" id="h6-0-20" class="d">-        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h6-0-21" id="h6-0-21" class="i">+    let ids: Vec&lt;Value&gt; =
</a><a href="#h6-0-22" id="h6-0-22" class="i">+        source.map_ok(|row| row.into_iter().nth(primary_key).expect(&quot;short row&quot;)).try_collect()?;
</a>     let count = ids.len() as u64;
     txn.delete(&amp;table, &amp;ids)?;
     Ok(count)
<a href="#h6-1" id="h6-1" class="h">@@ -27,7 +27,7 @@ pub(super) fn delete(
</a> /// columns in source. Otherwise, every column in source is the corresponding
 /// column in table, but the source may not have all columns in table (there may
 /// be a missing tail).
<a href="#h6-1-3" id="h6-1-3" class="d">-pub(super) fn insert(
</a><a href="#h6-1-4" id="h6-1-4" class="i">+pub fn insert(
</a>     txn: &amp;impl Transaction,
     table: Table,
     column_map: Option&lt;HashMap&lt;usize, usize&gt;&gt;,
<a href="#h6-2" id="h6-2" class="h">@@ -40,7 +40,6 @@ pub(super) fn insert(
</a>             rows.push(values);
             continue;
         }
<a href="#h6-2-3" id="h6-2-3" class="d">-
</a>         if values.len() &gt; table.columns.len() {
             return errinput!(&quot;too many values for table {}&quot;, table.name);
         }
<a href="#h6-3" id="h6-3" class="h">@@ -50,16 +49,15 @@ pub(super) fn insert(
</a>             }
         }
 
<a href="#h6-3-3" id="h6-3-3" class="d">-        // Fill in the row with default values for missing columns, and map
</a><a href="#h6-3-4" id="h6-3-4" class="d">-        // source columns to table columns.
</a><a href="#h6-3-5" id="h6-3-5" class="i">+        // Map source columns to table columns, and fill in default values.
</a>         let mut row = Vec::with_capacity(table.columns.len());
<a href="#h6-3-7" id="h6-3-7" class="d">-        for (cidx, column) in table.columns.iter().enumerate() {
</a><a href="#h6-3-8" id="h6-3-8" class="d">-            if column_map.is_none() &amp;&amp; cidx &lt; values.len() {
</a><a href="#h6-3-9" id="h6-3-9" class="i">+        for (i, column) in table.columns.iter().enumerate() {
</a><a href="#h6-3-10" id="h6-3-10" class="i">+            if column_map.is_none() &amp;&amp; i &lt; values.len() {
</a>                 // Pass through the source column to the table column.
<a href="#h6-3-12" id="h6-3-12" class="d">-                row.push(values[cidx].clone())
</a><a href="#h6-3-13" id="h6-3-13" class="d">-            } else if let Some(vidx) = column_map.as_ref().and_then(|c| c.get(&amp;cidx)).copied() {
</a><a href="#h6-3-14" id="h6-3-14" class="i">+                row.push(values[i].clone())
</a><a href="#h6-3-15" id="h6-3-15" class="i">+            } else if let Some(vi) = column_map.as_ref().and_then(|c| c.get(&amp;i)).copied() {
</a>                 // Map the source column to the table column.
<a href="#h6-3-17" id="h6-3-17" class="d">-                row.push(values[vidx].clone())
</a><a href="#h6-3-18" id="h6-3-18" class="i">+                row.push(values[vi].clone())
</a>             } else if let Some(default) = &amp;column.default {
                 // Column not given in source, use the default.
                 row.push(default.clone())
<a href="#h6-4" id="h6-4" class="h">@@ -76,7 +74,7 @@ pub(super) fn insert(
</a> 
 /// Updates rows passed in from the source (i.e. UPDATE). Returns the number of
 /// rows updated.
<a href="#h6-4-3" id="h6-4-3" class="d">-pub(super) fn update(
</a><a href="#h6-4-4" id="h6-4-4" class="i">+pub fn update(
</a>     txn: &amp;impl Transaction,
     table: String,
     primary_key: usize,
<a href="#h6-5" id="h6-5" class="h">@@ -85,12 +83,12 @@ pub(super) fn update(
</a> ) -&gt; Result&lt;u64&gt; {
     let mut updates = BTreeMap::new();
     while let Some(row) = source.next().transpose()? {
<a href="#h6-5-3" id="h6-5-3" class="d">-        let mut new = row.clone();
</a><a href="#h6-5-4" id="h6-5-4" class="i">+        let mut update = row.clone();
</a>         for (column, expr) in &amp;expressions {
<a href="#h6-5-6" id="h6-5-6" class="d">-            new[*column] = expr.evaluate(Some(&amp;row))?;
</a><a href="#h6-5-7" id="h6-5-7" class="i">+            update[*column] = expr.evaluate(Some(&amp;row))?;
</a>         }
         let id = row.into_iter().nth(primary_key).expect(&quot;short row&quot;);
<a href="#h6-5-10" id="h6-5-10" class="d">-        updates.insert(id, new);
</a><a href="#h6-5-11" id="h6-5-11" class="i">+        updates.insert(id, update);
</a>     }
     let count = updates.len() as u64;
     txn.update(&amp;table, updates)?;
</pre>
</div>
</body>
</html>
