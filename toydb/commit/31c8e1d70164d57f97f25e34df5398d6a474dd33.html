<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>storage: clean up test code - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/31c8e1d70164d57f97f25e34df5398d6a474dd33.html">31c8e1d70164d57f97f25e34df5398d6a474dd33</a>
<b>parent</b> <a href="../commit/d28fbec4c6a2843ff0a852c181fc8a602bbe2ed7.html">d28fbec4c6a2843ff0a852c181fc8a602bbe2ed7</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Mon, 22 Jul 2024 15:58:40 +0200

storage: clean up test code

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/storage/bitcask.rs</a></td><td> | </td><td class="num">5</td><td><span class="i">+++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/storage/engine.rs</a></td><td> | </td><td class="num">10</td><td><span class="i">++++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/storage/memory.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/storage/mod.rs</a></td><td> | </td><td class="num">3</td><td><span class="i">+++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/storage/mvcc.rs</a></td><td> | </td><td class="num">68</td><td><span class="i">+++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------</span></td></tr>
</table></pre><pre>5 files changed, 45 insertions(+), 43 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/storage/bitcask.rs.html">src/storage/bitcask.rs</a> b/<a href="../file/src/storage/bitcask.rs.html">src/storage/bitcask.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -360,14 +360,15 @@ impl Log {
</a>     }
 }
 
<a href="#h0-0-3" id="h0-0-3" class="i">+/// Most storage tests are Goldenscripts under src/storage/testscripts.
</a> #[cfg(test)]
 mod tests {
     use super::super::engine::test::Runner;
     use super::*;
     use crate::encoding::format::{self, Formatter as _};
<a href="#h0-0-9" id="h0-0-9" class="d">-    use std::error::Error as StdError;
</a><a href="#h0-0-10" id="h0-0-10" class="i">+
</a>     use std::fmt::Write as _;
<a href="#h0-0-12" id="h0-0-12" class="d">-    use std::result::Result as StdResult;
</a><a href="#h0-0-13" id="h0-0-13" class="i">+    use std::{error::Error as StdError, result::Result as StdResult};
</a>     use test_case::test_case;
     use test_each_file::test_each_path;
 
<b>diff --git a/<a id="h1" href="../file/src/storage/engine.rs.html">src/storage/engine.rs</a> b/<a href="../file/src/storage/engine.rs.html">src/storage/engine.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -88,12 +88,12 @@ impl Status {
</a> pub mod test {
     use super::*;
     use crate::encoding::format::{self, Formatter as _};
<a href="#h1-0-3" id="h1-0-3" class="i">+
</a>     use crossbeam::channel::Sender;
     use itertools::Itertools as _;
     use regex::Regex;
<a href="#h1-0-7" id="h1-0-7" class="d">-    use std::error::Error as StdError;
</a>     use std::fmt::Write as _;
<a href="#h1-0-9" id="h1-0-9" class="d">-    use std::result::Result as StdResult;
</a><a href="#h1-0-10" id="h1-0-10" class="i">+    use std::{error::Error as StdError, result::Result as StdResult};
</a> 
     /// Goldenscript runner for engines. All engines use a common set of
     /// goldenscripts in src/storage/testscripts/engine, as well as their own
<a href="#h1-1" id="h1-1" class="h">@@ -142,7 +142,8 @@ pub mod test {
</a>                         self.engine.scan(range).try_collect()?
                     };
                     for (key, value) in items {
<a href="#h1-1-3" id="h1-1-3" class="d">-                        writeln!(output, &quot;{}&quot;, format::Raw::key_value(&amp;key, &amp;value))?;
</a><a href="#h1-1-4" id="h1-1-4" class="i">+                        let fmtkv = format::Raw::key_value(&amp;key, &amp;value);
</a><a href="#h1-1-5" id="h1-1-5" class="i">+                        writeln!(output, &quot;{fmtkv}&quot;)?;
</a>                     }
                 }
 
<a href="#h1-2" id="h1-2" class="h">@@ -153,7 +154,8 @@ pub mod test {
</a>                     args.reject_rest()?;
                     let mut scan = self.engine.scan_prefix(&amp;prefix);
                     while let Some((key, value)) = scan.next().transpose()? {
<a href="#h1-2-3" id="h1-2-3" class="d">-                        writeln!(output, &quot;{}&quot;, format::Raw::key_value(&amp;key, &amp;value))?;
</a><a href="#h1-2-4" id="h1-2-4" class="i">+                        let fmtkv = format::Raw::key_value(&amp;key, &amp;value);
</a><a href="#h1-2-5" id="h1-2-5" class="i">+                        writeln!(output, &quot;{fmtkv}&quot;)?;
</a>                     }
                 }
 
<b>diff --git a/<a id="h2" href="../file/src/storage/memory.rs.html">src/storage/memory.rs</a> b/<a href="../file/src/storage/memory.rs.html">src/storage/memory.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -83,10 +83,12 @@ impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a>     }
 }
 
<a href="#h2-0-3" id="h2-0-3" class="i">+/// Most storage tests are Goldenscripts under src/storage/testscripts.
</a> #[cfg(test)]
 mod tests {
     use super::super::engine::test::Runner;
     use super::*;
<a href="#h2-0-8" id="h2-0-8" class="i">+
</a>     use test_each_file::test_each_path;
 
     // Run common goldenscript tests in src/storage/testscripts/engine.
<b>diff --git a/<a id="h3" href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a> b/<a href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,3 +1,6 @@
</a><a href="#h3-0-0" id="h3-0-0" class="i">+//! Key/value storage engines, including an MVCC transaction layer. For
</a><a href="#h3-0-1" id="h3-0-1" class="i">+//! details, see the `engine`, `bitcask`, and `mvcc` module documentation.
</a><a href="#h3-0-2" id="h3-0-2" class="i">+
</a> mod bitcask;
 pub mod engine;
 mod memory;
<b>diff --git a/<a id="h4" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -742,6 +742,7 @@ impl&lt;&#39;a, I: engine::ScanIterator&gt; Iterator for VersionIterator&lt;&#39;a, I&gt; {
</a>     }
 }
 
<a href="#h4-0-3" id="h4-0-3" class="i">+/// Most storage tests are Goldenscripts under src/storage/testscripts.
</a> #[cfg(test)]
 pub mod tests {
     use super::*;
<a href="#h4-1" id="h4-1" class="h">@@ -826,6 +827,8 @@ pub mod tests {
</a>     impl goldenscript::Runner for MVCCRunner {
         fn run(&amp;mut self, command: &amp;goldenscript::Command) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
             let mut output = String::new();
<a href="#h4-1-3" id="h4-1-3" class="i">+            let mut tags = command.tags.clone();
</a><a href="#h4-1-4" id="h4-1-4" class="i">+
</a>             match command.name.as_str() {
                 // txn: begin [readonly] [as_of=VERSION]
                 &quot;begin&quot; =&gt; {
<a href="#h4-2" id="h4-2" class="h">@@ -961,7 +964,7 @@ pub mod tests {
</a>                         parse_key_range(args.next_pos().map(|a| a.value.as_str()).unwrap_or(&quot;..&quot;))?;
                     args.reject_rest()?;
 
<a href="#h4-2-3" id="h4-2-3" class="d">-                    let kvs: Vec&lt;_&gt; = txn.scan(range).collect::&lt;crate::error::Result&lt;_&gt;&gt;()?;
</a><a href="#h4-2-4" id="h4-2-4" class="i">+                    let kvs: Vec&lt;_&gt; = txn.scan(range).try_collect()?;
</a>                     for (key, value) in kvs {
                         writeln!(output, &quot;{}&quot;, format::Raw::key_value(&amp;key, &amp;value))?;
                     }
<a href="#h4-3" id="h4-3" class="h">@@ -974,8 +977,7 @@ pub mod tests {
</a>                     let prefix = decode_binary(&amp;args.next_pos().ok_or(&quot;prefix not given&quot;)?.value);
                     args.reject_rest()?;
 
<a href="#h4-3-3" id="h4-3-3" class="d">-                    let kvs: Vec&lt;_&gt; =
</a><a href="#h4-3-4" id="h4-3-4" class="d">-                        txn.scan_prefix(&amp;prefix).collect::&lt;crate::error::Result&lt;_&gt;&gt;()?;
</a><a href="#h4-3-5" id="h4-3-5" class="i">+                    let kvs: Vec&lt;_&gt; = txn.scan_prefix(&amp;prefix).try_collect()?;
</a>                     for (key, value) in kvs {
                         writeln!(output, &quot;{}&quot;, format::Raw::key_value(&amp;key, &amp;value))?;
                     }
<a href="#h4-4" id="h4-4" class="h">@@ -1020,49 +1022,41 @@ pub mod tests {
</a>                 }
 
                 // status
<a href="#h4-4-3" id="h4-4-3" class="d">-                &quot;status&quot; =&gt; {
</a><a href="#h4-4-4" id="h4-4-4" class="d">-                    let status = self.mvcc.status()?;
</a><a href="#h4-4-5" id="h4-4-5" class="d">-                    writeln!(output, &quot;{status:#?}&quot;)?;
</a><a href="#h4-4-6" id="h4-4-6" class="d">-                }
</a><a href="#h4-4-7" id="h4-4-7" class="i">+                &quot;status&quot; =&gt; writeln!(output, &quot;{:#?}&quot;, self.mvcc.status()?)?,
</a> 
                 name =&gt; return Err(format!(&quot;invalid command {name}&quot;).into()),
             }
<a href="#h4-4-11" id="h4-4-11" class="d">-            Ok(output)
</a><a href="#h4-4-12" id="h4-4-12" class="d">-        }
</a> 
<a href="#h4-4-14" id="h4-4-14" class="d">-        /// If requested via [ops] tag, output engine operations for the command.
</a><a href="#h4-4-15" id="h4-4-15" class="d">-        fn end_command(
</a><a href="#h4-4-16" id="h4-4-16" class="d">-            &amp;mut self,
</a><a href="#h4-4-17" id="h4-4-17" class="d">-            command: &amp;goldenscript::Command,
</a><a href="#h4-4-18" id="h4-4-18" class="d">-        ) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
</a><a href="#h4-4-19" id="h4-4-19" class="d">-            // Parse tags.
</a><a href="#h4-4-20" id="h4-4-20" class="d">-            let mut show_ops = false;
</a><a href="#h4-4-21" id="h4-4-21" class="d">-            for tag in &amp;command.tags {
</a><a href="#h4-4-22" id="h4-4-22" class="d">-                match tag.as_str() {
</a><a href="#h4-4-23" id="h4-4-23" class="d">-                    &quot;ops&quot; =&gt; show_ops = true,
</a><a href="#h4-4-24" id="h4-4-24" class="d">-                    tag =&gt; return Err(format!(&quot;invalid tag {tag}&quot;).into()),
</a><a href="#h4-4-25" id="h4-4-25" class="i">+            // If requested, output engine operations.
</a><a href="#h4-4-26" id="h4-4-26" class="i">+            if tags.remove(&quot;ops&quot;) {
</a><a href="#h4-4-27" id="h4-4-27" class="i">+                while let Ok(op) = self.op_rx.try_recv() {
</a><a href="#h4-4-28" id="h4-4-28" class="i">+                    match op {
</a><a href="#h4-4-29" id="h4-4-29" class="i">+                        Operation::Delete { key } =&gt; {
</a><a href="#h4-4-30" id="h4-4-30" class="i">+                            let fmtkey = format::MVCC::&lt;format::Raw&gt;::key(&amp;key);
</a><a href="#h4-4-31" id="h4-4-31" class="i">+                            let rawkey = format::Raw::key(&amp;key);
</a><a href="#h4-4-32" id="h4-4-32" class="i">+                            writeln!(output, &quot;engine delete {fmtkey} [{rawkey}]&quot;)?
</a><a href="#h4-4-33" id="h4-4-33" class="i">+                        }
</a><a href="#h4-4-34" id="h4-4-34" class="i">+                        Operation::Flush =&gt; writeln!(output, &quot;engine flush&quot;)?,
</a><a href="#h4-4-35" id="h4-4-35" class="i">+                        Operation::Set { key, value } =&gt; {
</a><a href="#h4-4-36" id="h4-4-36" class="i">+                            let fmtkv = format::MVCC::&lt;format::Raw&gt;::key_value(&amp;key, &amp;value);
</a><a href="#h4-4-37" id="h4-4-37" class="i">+                            let rawkv = format::Raw::key_value(&amp;key, &amp;value);
</a><a href="#h4-4-38" id="h4-4-38" class="i">+                            writeln!(output, &quot;engine set {fmtkv} [{rawkv}]&quot;)?
</a><a href="#h4-4-39" id="h4-4-39" class="i">+                        }
</a><a href="#h4-4-40" id="h4-4-40" class="i">+                    }
</a>                 }
             }
 
<a href="#h4-4-44" id="h4-4-44" class="d">-            // Process engine operations, either output or drain.
</a><a href="#h4-4-45" id="h4-4-45" class="d">-            let mut output = String::new();
</a><a href="#h4-4-46" id="h4-4-46" class="d">-            while let Ok(op) = self.op_rx.try_recv() {
</a><a href="#h4-4-47" id="h4-4-47" class="d">-                match op {
</a><a href="#h4-4-48" id="h4-4-48" class="d">-                    _ if !show_ops =&gt; {}
</a><a href="#h4-4-49" id="h4-4-49" class="d">-                    Operation::Delete { key } =&gt; {
</a><a href="#h4-4-50" id="h4-4-50" class="d">-                        let fmtkey = format::MVCC::&lt;format::Raw&gt;::key(&amp;key);
</a><a href="#h4-4-51" id="h4-4-51" class="d">-                        let rawkey = format::Raw::key(&amp;key);
</a><a href="#h4-4-52" id="h4-4-52" class="d">-                        writeln!(output, &quot;engine delete {fmtkey} [{rawkey}]&quot;)?
</a><a href="#h4-4-53" id="h4-4-53" class="d">-                    }
</a><a href="#h4-4-54" id="h4-4-54" class="d">-                    Operation::Flush =&gt; writeln!(output, &quot;engine flush&quot;)?,
</a><a href="#h4-4-55" id="h4-4-55" class="d">-                    Operation::Set { key, value } =&gt; {
</a><a href="#h4-4-56" id="h4-4-56" class="d">-                        let fmtkv = format::MVCC::&lt;format::Raw&gt;::key_value(&amp;key, &amp;value);
</a><a href="#h4-4-57" id="h4-4-57" class="d">-                        let rawkv = format::Raw::key_value(&amp;key, &amp;value);
</a><a href="#h4-4-58" id="h4-4-58" class="d">-                        writeln!(output, &quot;engine set {fmtkv} [{rawkv}]&quot;)?
</a><a href="#h4-4-59" id="h4-4-59" class="d">-                    }
</a><a href="#h4-4-60" id="h4-4-60" class="d">-                }
</a><a href="#h4-4-61" id="h4-4-61" class="i">+            if let Some(tag) = tags.iter().next() {
</a><a href="#h4-4-62" id="h4-4-62" class="i">+                return Err(format!(&quot;unknown tag {tag}&quot;).into());
</a>             }
<a href="#h4-4-64" id="h4-4-64" class="i">+
</a>             Ok(output)
         }
<a href="#h4-4-67" id="h4-4-67" class="i">+
</a><a href="#h4-4-68" id="h4-4-68" class="i">+        // Drain unhandled engine operations.
</a><a href="#h4-4-69" id="h4-4-69" class="i">+        fn end_command(&amp;mut self, _: &amp;goldenscript::Command) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
</a><a href="#h4-4-70" id="h4-4-70" class="i">+            while self.op_rx.try_recv().is_ok() {}
</a><a href="#h4-4-71" id="h4-4-71" class="i">+            Ok(String::new())
</a><a href="#h4-4-72" id="h4-4-72" class="i">+        }
</a>     }
 }
</pre>
</div>
</body>
</html>
