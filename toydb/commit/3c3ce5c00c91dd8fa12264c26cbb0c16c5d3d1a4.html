<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>encoding: make `serialize()` panic on failure - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/3c3ce5c00c91dd8fa12264c26cbb0c16c5d3d1a4.html">3c3ce5c00c91dd8fa12264c26cbb0c16c5d3d1a4</a>
<b>parent</b> <a href="../commit/b9964724358ad32a8a71c35699a6cace00c513d9.html">b9964724358ad32a8a71c35699a6cace00c513d9</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun,  9 Jun 2024 13:30:15 +0200

encoding: make `serialize()` panic on failure

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/encoding/bincode.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">++++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/encoding/keycode.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">+++++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/encoding/mod.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/log.rs</a></td><td> | </td><td class="num">44</td><td><span class="i">++++++++++++++++++++++</span><span class="d">----------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/node.rs</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/raft/state.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">+++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">26</td><td><span class="i">+++++++++++++</span><span class="d">-------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">+++++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/storage/mvcc.rs</a></td><td> | </td><td class="num">65</td><td><span class="i">++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------</span></td></tr>
</table></pre><pre>9 files changed, 103 insertions(+), 96 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/encoding/bincode.rs.html">src/encoding/bincode.rs</a> b/<a href="../file/src/encoding/bincode.rs.html">src/encoding/bincode.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -47,8 +47,10 @@ pub fn maybe_deserialize_from&lt;R: std::io::Read, T: serde::de::DeserializeOwned&gt;(
</a> }
 
 /// Serializes a value using Bincode.
<a href="#h0-0-3" id="h0-0-3" class="d">-pub fn serialize&lt;T: serde::Serialize&gt;(value: &amp;T) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h0-0-4" id="h0-0-4" class="d">-    Ok(bincode().serialize(value)?)
</a><a href="#h0-0-5" id="h0-0-5" class="i">+pub fn serialize&lt;T: serde::Serialize&gt;(value: &amp;T) -&gt; Vec&lt;u8&gt; {
</a><a href="#h0-0-6" id="h0-0-6" class="i">+    // Panic on serialization failures, as this is typically an issue with the
</a><a href="#h0-0-7" id="h0-0-7" class="i">+    // provided data structure.
</a><a href="#h0-0-8" id="h0-0-8" class="i">+    bincode().serialize(value).expect(&quot;bincode serialization failed&quot;)
</a> }
 
 /// Serializes a value to a writer using Bincode.
<b>diff --git a/<a id="h1" href="../file/src/encoding/keycode.rs.html">src/encoding/keycode.rs</a> b/<a href="../file/src/encoding/keycode.rs.html">src/encoding/keycode.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -51,10 +51,12 @@ use crate::errdata;
</a> use crate::error::{Error, Result};
 
 // Serializes a key to a binary KeyCode representation.
<a href="#h1-0-3" id="h1-0-3" class="d">-pub fn serialize&lt;T: serde::Serialize&gt;(key: &amp;T) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h1-0-4" id="h1-0-4" class="i">+pub fn serialize&lt;T: serde::Serialize&gt;(key: &amp;T) -&gt; Vec&lt;u8&gt; {
</a>     let mut serializer = Serializer { output: Vec::new() };
<a href="#h1-0-6" id="h1-0-6" class="d">-    key.serialize(&amp;mut serializer)?;
</a><a href="#h1-0-7" id="h1-0-7" class="d">-    Ok(serializer.output)
</a><a href="#h1-0-8" id="h1-0-8" class="i">+    // Panic on serialization failures, as this is typically an issue with the
</a><a href="#h1-0-9" id="h1-0-9" class="i">+    // provided data structure.
</a><a href="#h1-0-10" id="h1-0-10" class="i">+    key.serialize(&amp;mut serializer).expect(&quot;keycode serialization failed&quot;);
</a><a href="#h1-0-11" id="h1-0-11" class="i">+    serializer.output
</a> }
 
 // Deserializes a key from a binary KeyCode representation.
<a href="#h1-1" id="h1-1" class="h">@@ -609,7 +611,7 @@ mod tests {
</a>             fn $name() -&gt; Result&lt;()&gt; {
                 let mut input = $input;
                 let expect = $expect;
<a href="#h1-1-3" id="h1-1-3" class="d">-                let output = serialize(&amp;input)?;
</a><a href="#h1-1-4" id="h1-1-4" class="i">+                let output = serialize(&amp;input);
</a>                 assert_eq!(hex::encode(&amp;output), expect, &quot;encode failed&quot;);
 
                 let expect = input;
<a href="#h1-2" id="h1-2" class="h">@@ -647,7 +649,7 @@ mod tests {
</a>             #[should_panic]
             fn [&lt; $name _serialize_error &gt;]() {
                 let input = $input;
<a href="#h1-2-3" id="h1-2-3" class="d">-                serialize(&amp;input).unwrap();
</a><a href="#h1-2-4" id="h1-2-4" class="i">+                serialize(&amp;input);
</a>             }
         )*
         }
<b>diff --git a/<a id="h2" href="../file/src/encoding/mod.rs.html">src/encoding/mod.rs</a> b/<a href="../file/src/encoding/mod.rs.html">src/encoding/mod.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -20,7 +20,7 @@ pub trait Key&lt;&#39;de&gt;: Serialize + Deserialize&lt;&#39;de&gt; {
</a>     }
 
     /// Encodes a key to a byte vector using Keycode.
<a href="#h2-0-3" id="h2-0-3" class="d">-    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-0-4" id="h2-0-4" class="i">+    fn encode(&amp;self) -&gt; Vec&lt;u8&gt; {
</a>         keycode::serialize(self)
     }
 }
<a href="#h2-1" id="h2-1" class="h">@@ -46,7 +46,7 @@ pub trait Value: Serialize + DeserializeOwned {
</a>     }
 
     /// Encodes a value to a byte vector using Bincode.
<a href="#h2-1-3" id="h2-1-3" class="d">-    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    fn encode(&amp;self) -&gt; Vec&lt;u8&gt; {
</a>         bincode::serialize(self)
     }
 
<b>diff --git a/<a id="h3" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -114,12 +114,12 @@ impl Log {
</a>     /// Initializes a log using the given storage engine.
     pub fn new(mut engine: impl storage::Engine + &#39;static) -&gt; Result&lt;Self&gt; {
         let (term, vote) = engine
<a href="#h3-0-3" id="h3-0-3" class="d">-            .get(&amp;Key::TermVote.encode()?)?
</a><a href="#h3-0-4" id="h3-0-4" class="i">+            .get(&amp;Key::TermVote.encode())?
</a>             .map(|v| bincode::deserialize(&amp;v))
             .transpose()?
             .unwrap_or((0, None));
         let (last_index, last_term) = engine
<a href="#h3-0-9" id="h3-0-9" class="d">-            .scan_prefix(&amp;KeyPrefix::Entry.encode()?)
</a><a href="#h3-0-10" id="h3-0-10" class="i">+            .scan_prefix(&amp;KeyPrefix::Entry.encode())
</a>             .last()
             .transpose()?
             .map(|(_, v)| Entry::decode(&amp;v))
<a href="#h3-1" id="h3-1" class="h">@@ -127,7 +127,7 @@ impl Log {
</a>             .map(|e| (e.index, e.term))
             .unwrap_or((0, 0));
         let (commit_index, commit_term) = engine
<a href="#h3-1-3" id="h3-1-3" class="d">-            .get(&amp;Key::CommitIndex.encode()?)?
</a><a href="#h3-1-4" id="h3-1-4" class="i">+            .get(&amp;Key::CommitIndex.encode())?
</a>             .map(|v| bincode::deserialize(&amp;v))
             .transpose()?
             .unwrap_or((0, 0));
<a href="#h3-2" id="h3-2" class="h">@@ -160,7 +160,7 @@ impl Log {
</a>         if term == self.term &amp;&amp; vote == self.vote {
             return Ok(());
         }
<a href="#h3-2-3" id="h3-2-3" class="d">-        self.engine.set(&amp;Key::TermVote.encode()?, bincode::serialize(&amp;(term, vote))?)?;
</a><a href="#h3-2-4" id="h3-2-4" class="i">+        self.engine.set(&amp;Key::TermVote.encode(), bincode::serialize(&amp;(term, vote)))?;
</a>         self.engine.flush()?;
         self.term = term;
         self.vote = vote;
<a href="#h3-3" id="h3-3" class="h">@@ -175,7 +175,7 @@ impl Log {
</a>         // We could omit the index in the encoded value, since it&#39;s also stored
         // in the key, but we keep it simple.
         let entry = Entry { index: self.last_index + 1, term: self.term, command };
<a href="#h3-3-3" id="h3-3-3" class="d">-        self.engine.set(&amp;Key::Entry(entry.index).encode()?, entry.encode()?)?;
</a><a href="#h3-3-4" id="h3-3-4" class="i">+        self.engine.set(&amp;Key::Entry(entry.index).encode(), entry.encode())?;
</a>         self.engine.flush()?;
         self.last_index = entry.index;
         self.last_term = entry.term;
<a href="#h3-4" id="h3-4" class="h">@@ -193,7 +193,7 @@ impl Log {
</a>             Some(e) =&gt; e.term,
             None =&gt; panic!(&quot;commit index {index} does not exist&quot;),
         };
<a href="#h3-4-3" id="h3-4-3" class="d">-        self.engine.set(&amp;Key::CommitIndex.encode()?, bincode::serialize(&amp;(index, term))?)?;
</a><a href="#h3-4-4" id="h3-4-4" class="i">+        self.engine.set(&amp;Key::CommitIndex.encode(), bincode::serialize(&amp;(index, term)))?;
</a>         // NB: the commit index doesn&#39;t need to be fsynced, since the entries
         // are fsynced and the commit index can be recovered from a log quorum.
         self.commit_index = index;
<a href="#h3-5" id="h3-5" class="h">@@ -203,7 +203,7 @@ impl Log {
</a> 
     /// Fetches an entry at an index, or None if it does not exist.
     pub fn get(&amp;mut self, index: Index) -&gt; Result&lt;Option&lt;Entry&gt;&gt; {
<a href="#h3-5-3" id="h3-5-3" class="d">-        self.engine.get(&amp;Key::Entry(index).encode()?)?.map(|v| Entry::decode(&amp;v)).transpose()
</a><a href="#h3-5-4" id="h3-5-4" class="i">+        self.engine.get(&amp;Key::Entry(index).encode())?.map(|v| Entry::decode(&amp;v)).transpose()
</a>     }
 
     /// Checks if the log contains an entry with the given index and term.
<a href="#h3-6" id="h3-6" class="h">@@ -220,29 +220,29 @@ impl Log {
</a>     }
 
     /// Returns an iterator over log entries in the given index range.
<a href="#h3-6-3" id="h3-6-3" class="d">-    pub fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Index&gt;) -&gt; Result&lt;Iterator&gt; {
</a><a href="#h3-6-4" id="h3-6-4" class="i">+    pub fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Index&gt;) -&gt; Iterator {
</a>         use std::ops::Bound;
         let from = match range.start_bound() {
<a href="#h3-6-7" id="h3-6-7" class="d">-            Bound::Excluded(&amp;index) =&gt; Bound::Excluded(Key::Entry(index).encode()?),
</a><a href="#h3-6-8" id="h3-6-8" class="d">-            Bound::Included(&amp;index) =&gt; Bound::Included(Key::Entry(index).encode()?),
</a><a href="#h3-6-9" id="h3-6-9" class="d">-            Bound::Unbounded =&gt; Bound::Included(Key::Entry(0).encode()?),
</a><a href="#h3-6-10" id="h3-6-10" class="i">+            Bound::Excluded(&amp;index) =&gt; Bound::Excluded(Key::Entry(index).encode()),
</a><a href="#h3-6-11" id="h3-6-11" class="i">+            Bound::Included(&amp;index) =&gt; Bound::Included(Key::Entry(index).encode()),
</a><a href="#h3-6-12" id="h3-6-12" class="i">+            Bound::Unbounded =&gt; Bound::Included(Key::Entry(0).encode()),
</a>         };
         let to = match range.end_bound() {
<a href="#h3-6-15" id="h3-6-15" class="d">-            Bound::Excluded(&amp;index) =&gt; Bound::Excluded(Key::Entry(index).encode()?),
</a><a href="#h3-6-16" id="h3-6-16" class="d">-            Bound::Included(&amp;index) =&gt; Bound::Included(Key::Entry(index).encode()?),
</a><a href="#h3-6-17" id="h3-6-17" class="d">-            Bound::Unbounded =&gt; Bound::Included(Key::Entry(Index::MAX).encode()?),
</a><a href="#h3-6-18" id="h3-6-18" class="i">+            Bound::Excluded(&amp;index) =&gt; Bound::Excluded(Key::Entry(index).encode()),
</a><a href="#h3-6-19" id="h3-6-19" class="i">+            Bound::Included(&amp;index) =&gt; Bound::Included(Key::Entry(index).encode()),
</a><a href="#h3-6-20" id="h3-6-20" class="i">+            Bound::Unbounded =&gt; Bound::Included(Key::Entry(Index::MAX).encode()),
</a>         };
<a href="#h3-6-22" id="h3-6-22" class="d">-        Ok(Iterator::new(self.engine.scan_dyn((from, to))))
</a><a href="#h3-6-23" id="h3-6-23" class="i">+        Iterator::new(self.engine.scan_dyn((from, to)))
</a>     }
 
     /// Returns an iterator over entries that are ready to apply, starting after
     /// the current applied index up to the commit index.
<a href="#h3-6-28" id="h3-6-28" class="d">-    pub fn scan_apply(&amp;mut self, applied_index: Index) -&gt; Result&lt;Iterator&gt; {
</a><a href="#h3-6-29" id="h3-6-29" class="i">+    pub fn scan_apply(&amp;mut self, applied_index: Index) -&gt; Iterator {
</a>         // NB: we don&#39;t assert that commit_index &gt;= applied_index, because the
         // local commit index is not flushed to durable storage -- if lost on
         // restart, it can be recovered from a quorum of logs.
         if applied_index &gt;= self.commit_index {
<a href="#h3-6-34" id="h3-6-34" class="d">-            return Ok(Iterator::new(Box::new(std::iter::empty())));
</a><a href="#h3-6-35" id="h3-6-35" class="i">+            return Iterator::new(Box::new(std::iter::empty()));
</a>         }
         self.scan(applied_index + 1..=self.commit_index)
     }
<a href="#h3-7" id="h3-7" class="h">@@ -285,7 +285,7 @@ impl Log {
</a> 
         // Skip entries that are already in the log.
         let mut entries = entries.as_slice();
<a href="#h3-7-3" id="h3-7-3" class="d">-        let mut scan = self.scan(first.index..=last.index)?;
</a><a href="#h3-7-4" id="h3-7-4" class="i">+        let mut scan = self.scan(first.index..=last.index);
</a>         while let Some(entry) = scan.next().transpose()? {
             // [0] is ok, because the scan has the same size as entries.
             assert!(entry.index == entries[0].index, &quot;index mismatch at {entry:?}&quot;);
<a href="#h3-8" id="h3-8" class="h">@@ -308,10 +308,10 @@ impl Log {
</a>         assert!(first.index &gt; self.commit_index, &quot;spliced entries below commit index&quot;);
 
         for entry in entries {
<a href="#h3-8-3" id="h3-8-3" class="d">-            self.engine.set(&amp;Key::Entry(entry.index).encode()?, entry.encode()?)?;
</a><a href="#h3-8-4" id="h3-8-4" class="i">+            self.engine.set(&amp;Key::Entry(entry.index).encode(), entry.encode())?;
</a>         }
         for index in last.index + 1..=self.last_index {
<a href="#h3-8-7" id="h3-8-7" class="d">-            self.engine.delete(&amp;Key::Entry(index).encode()?)?;
</a><a href="#h3-8-8" id="h3-8-8" class="i">+            self.engine.delete(&amp;Key::Entry(index).encode())?;
</a>         }
         self.engine.flush()?;
 
<a href="#h3-9" id="h3-9" class="h">@@ -467,7 +467,7 @@ mod tests {
</a>                         args.next_pos().map_or(&quot;..&quot;, |a| a.value.as_str()),
                     )?;
                     args.reject_rest()?;
<a href="#h3-9-3" id="h3-9-3" class="d">-                    let mut scan = self.log.scan(range)?;
</a><a href="#h3-9-4" id="h3-9-4" class="i">+                    let mut scan = self.log.scan(range);
</a>                     while let Some(entry) = scan.next().transpose()? {
                         output.push_str(&amp;format!(&quot;{}\n&quot;, Self::format_entry(&amp;entry)));
                     }
<a href="#h3-10" id="h3-10" class="h">@@ -479,7 +479,7 @@ mod tests {
</a>                     let applied_index =
                         args.next_pos().ok_or(&quot;applied index not given&quot;)?.parse()?;
                     args.reject_rest()?;
<a href="#h3-10-3" id="h3-10-3" class="d">-                    let mut scan = self.log.scan_apply(applied_index)?;
</a><a href="#h3-10-4" id="h3-10-4" class="i">+                    let mut scan = self.log.scan_apply(applied_index);
</a>                     while let Some(entry) = scan.next().transpose()? {
                         output.push_str(&amp;format!(&quot;{}\n&quot;, Self::format_entry(&amp;entry)));
                     }
<b>diff --git a/<a id="h4" href="../file/src/raft/node.rs.html">src/raft/node.rs</a> b/<a href="../file/src/raft/node.rs.html">src/raft/node.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -633,7 +633,7 @@ impl RawNode&lt;Follower&gt; {
</a> 
     /// Applies any pending log entries.
     fn maybe_apply(&amp;mut self) -&gt; Result&lt;()&gt; {
<a href="#h4-0-3" id="h4-0-3" class="d">-        let mut iter = self.log.scan_apply(self.state.get_applied_index())?;
</a><a href="#h4-0-4" id="h4-0-4" class="i">+        let mut iter = self.log.scan_apply(self.state.get_applied_index());
</a>         while let Some(entry) = iter.next().transpose()? {
             debug!(&quot;Applying {entry:?}&quot;);
             // Throw away the result, since there is no client waiting for it.
<a href="#h4-1" id="h4-1" class="h">@@ -1042,7 +1042,7 @@ impl RawNode&lt;Leader&gt; {
</a> 
         // Apply entries and respond to client writers.
         let term = self.term();
<a href="#h4-1-3" id="h4-1-3" class="d">-        let mut iter = self.log.scan_apply(self.state.get_applied_index())?;
</a><a href="#h4-1-4" id="h4-1-4" class="i">+        let mut iter = self.log.scan_apply(self.state.get_applied_index());
</a>         while let Some(entry) = iter.next().transpose()? {
             debug!(&quot;Applying {entry:?}&quot;);
             let write = self.role.writes.remove(&amp;entry.index);
<a href="#h4-2" id="h4-2" class="h">@@ -1146,7 +1146,7 @@ impl RawNode&lt;Leader&gt; {
</a> 
         let entries = if !probe {
             self.log
<a href="#h4-2-3" id="h4-2-3" class="d">-                .scan(progress.next_index..)?
</a><a href="#h4-2-4" id="h4-2-4" class="i">+                .scan(progress.next_index..)
</a>                 .take(self.opts.max_append_entries)
                 .collect::&lt;Result&lt;_&gt;&gt;()?
         } else {
<a href="#h4-3" id="h4-3" class="h">@@ -1309,7 +1309,7 @@ mod tests {
</a>                     let id = args.next_pos().ok_or(&quot;must specify node ID&quot;)?.parse()?;
                     let key = args.next_pos().ok_or(&quot;must specify key&quot;)?.value.clone();
                     args.reject_rest()?;
<a href="#h4-3-3" id="h4-3-3" class="d">-                    let request = Request::Read(KVCommand::Get { key }.encode()?);
</a><a href="#h4-3-4" id="h4-3-4" class="i">+                    let request = Request::Read(KVCommand::Get { key }.encode());
</a>                     self.request(id, request, &amp;mut output)?;
                 }
 
<a href="#h4-4" id="h4-4" class="h">@@ -1357,7 +1357,7 @@ mod tests {
</a>                     let kv = args.next_key().ok_or(&quot;must specify key/value pair&quot;)?.clone();
                     let (key, value) = (kv.key.unwrap(), kv.value);
                     args.reject_rest()?;
<a href="#h4-4-3" id="h4-4-3" class="d">-                    let request = Request::Write(KVCommand::Put { key, value }.encode()?);
</a><a href="#h4-4-4" id="h4-4-4" class="i">+                    let request = Request::Write(KVCommand::Put { key, value }.encode());
</a>                     self.request(id, request, &amp;mut output)?;
                 }
 
<a href="#h4-5" id="h4-5" class="h">@@ -1575,7 +1575,7 @@ mod tests {
</a>                     &quot;{nodefmt} last={last_index}@{last_term} commit={commit_index}@{commit_term}\n&quot;,
                 ));
 
<a href="#h4-5-3" id="h4-5-3" class="d">-                let mut scan = log.scan(..)?;
</a><a href="#h4-5-4" id="h4-5-4" class="i">+                let mut scan = log.scan(..);
</a>                 while let Some(entry) = scan.next().transpose()? {
                     output.push_str(&amp;format!(&quot;{nodefmt} entry {}\n&quot;, &amp;Self::format_entry(&amp;entry)));
                 }
<a href="#h4-6" id="h4-6" class="h">@@ -1710,7 +1710,7 @@ mod tests {
</a>                 let nodefmt = Self::format_node(node);
                 output.push_str(&amp;format!(&quot;{nodefmt} applied={applied_index}\n&quot;));
 
<a href="#h4-6-3" id="h4-6-3" class="d">-                let raw = state.read(KVCommand::Scan.encode()?)?;
</a><a href="#h4-6-4" id="h4-6-4" class="i">+                let raw = state.read(KVCommand::Scan.encode())?;
</a>                 let kvs: Vec&lt;(String, String)&gt; = bincode::deserialize(&amp;raw)?;
                 for (key, value) in kvs {
                     output.push_str(&amp;format!(&quot;{nodefmt} state {key}={value}\n&quot;));
<a href="#h4-7" id="h4-7" class="h">@@ -1759,7 +1759,7 @@ mod tests {
</a>             let old_noderole = Self::format_node_role(&amp;node);
             let log = Self::borrow_log_mut(&amp;mut node);
             let old_commit_index = log.get_commit_index().0;
<a href="#h4-7-3" id="h4-7-3" class="d">-            let entries = log.scan(..)?.collect::&lt;crate::error::Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h4-7-4" id="h4-7-4" class="i">+            let entries = log.scan(..).collect::&lt;crate::error::Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a> 
             // Apply the transition.
             node = f(node)?;
<a href="#h4-8" id="h4-8" class="h">@@ -1769,7 +1769,7 @@ mod tests {
</a> 
             let log = Self::borrow_log_mut(&amp;mut node);
             let (commit_index, commit_term) = log.get_commit_index();
<a href="#h4-8-3" id="h4-8-3" class="d">-            let mut appended = log.scan(..)?.collect::&lt;crate::error::Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h4-8-4" id="h4-8-4" class="i">+            let mut appended = log.scan(..).collect::&lt;crate::error::Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a>             match appended.iter().zip(entries.iter()).position(|(a, e)| a.term != e.term) {
                 Some(i) =&gt; appended = appended[i..].to_vec(),
                 None =&gt; appended = appended[entries.len()..].to_vec(),
<b>diff --git a/<a id="h5" href="../file/src/raft/state.rs.html">src/raft/state.rs</a> b/<a href="../file/src/raft/state.rs.html">src/raft/state.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -110,7 +110,7 @@ pub mod test {
</a>             let response = match command {
                 Some(KVCommand::Put { key, value }) =&gt; {
                     self.data.insert(key, value);
<a href="#h5-0-3" id="h5-0-3" class="d">-                    KVResponse::Put(entry.index).encode()?
</a><a href="#h5-0-4" id="h5-0-4" class="i">+                    KVResponse::Put(entry.index).encode()
</a>                 }
                 Some(c @ (KVCommand::Get { .. } | KVCommand::Scan)) =&gt; {
                     panic!(&quot;{c} submitted as write command&quot;)
<a href="#h5-1" id="h5-1" class="h">@@ -123,8 +123,10 @@ pub mod test {
</a> 
         fn read(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
             match KVCommand::decode(&amp;command)? {
<a href="#h5-1-3" id="h5-1-3" class="d">-                KVCommand::Get { key } =&gt; KVResponse::Get(self.data.get(&amp;key).cloned()).encode(),
</a><a href="#h5-1-4" id="h5-1-4" class="d">-                KVCommand::Scan =&gt; KVResponse::Scan(self.data.clone()).encode(),
</a><a href="#h5-1-5" id="h5-1-5" class="i">+                KVCommand::Get { key } =&gt; {
</a><a href="#h5-1-6" id="h5-1-6" class="i">+                    Ok(KVResponse::Get(self.data.get(&amp;key).cloned()).encode())
</a><a href="#h5-1-7" id="h5-1-7" class="i">+                }
</a><a href="#h5-1-8" id="h5-1-8" class="i">+                KVCommand::Scan =&gt; Ok(KVResponse::Scan(self.data.clone()).encode()),
</a>                 c @ KVCommand::Put { .. } =&gt; panic!(&quot;{c} submitted as read command&quot;),
             }
         }
<b>diff --git a/<a id="h6" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -85,7 +85,7 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>     fn index_load(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
         Ok(self
             .txn
<a href="#h6-0-3" id="h6-0-3" class="d">-            .get(&amp;Key::Index(table.into(), column.into(), value.into()).encode()?)?
</a><a href="#h6-0-4" id="h6-0-4" class="i">+            .get(&amp;Key::Index(table.into(), column.into(), value.into()).encode())?
</a>             .map(|v| HashSet::&lt;Value&gt;::decode(&amp;v))
             .transpose()?
             .unwrap_or_default())
<a href="#h6-1" id="h6-1" class="h">@@ -99,11 +99,11 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>         value: &amp;Value,
         index: HashSet&lt;Value&gt;,
     ) -&gt; Result&lt;()&gt; {
<a href="#h6-1-3" id="h6-1-3" class="d">-        let key = Key::Index(table.into(), column.into(), value.into()).encode()?;
</a><a href="#h6-1-4" id="h6-1-4" class="i">+        let key = Key::Index(table.into(), column.into(), value.into()).encode();
</a>         if index.is_empty() {
             self.txn.delete(&amp;key)
         } else {
<a href="#h6-1-8" id="h6-1-8" class="d">-            self.txn.set(&amp;key, index.encode()?)
</a><a href="#h6-1-9" id="h6-1-9" class="i">+            self.txn.set(&amp;key, index.encode())
</a>         }
     }
 }
<a href="#h6-2" id="h6-2" class="h">@@ -132,7 +132,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         if self.read(&amp;table.name, &amp;id)?.is_some() {
             return errinput!(&quot;primary key {id} already exists for table {}&quot;, table.name);
         }
<a href="#h6-2-3" id="h6-2-3" class="d">-        self.txn.set(&amp;Key::Row((&amp;table.name).into(), (&amp;id).into()).encode()?, row.encode()?)?;
</a><a href="#h6-2-4" id="h6-2-4" class="i">+        self.txn.set(&amp;Key::Row((&amp;table.name).into(), (&amp;id).into()).encode(), row.encode())?;
</a> 
         // Update indexes
         for (i, column) in table.columns.iter().enumerate().filter(|(_, c)| c.index) {
<a href="#h6-3" id="h6-3" class="h">@@ -174,12 +174,12 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>                 }
             }
         }
<a href="#h6-3-3" id="h6-3-3" class="d">-        self.txn.delete(&amp;Key::Row(table.name.into(), id.into()).encode()?)
</a><a href="#h6-3-4" id="h6-3-4" class="i">+        self.txn.delete(&amp;Key::Row(table.name.into(), id.into()).encode())
</a>     }
 
     fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
         self.txn
<a href="#h6-3-9" id="h6-3-9" class="d">-            .get(&amp;Key::Row(table.into(), id.into()).encode()?)?
</a><a href="#h6-3-10" id="h6-3-10" class="i">+            .get(&amp;Key::Row(table.into(), id.into()).encode())?
</a>             .map(|v| Row::decode(&amp;v))
             .transpose()
     }
<a href="#h6-4" id="h6-4" class="h">@@ -195,7 +195,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         let table = self.must_read_table(table)?;
         Ok(Box::new(
             self.txn
<a href="#h6-4-3" id="h6-4-3" class="d">-                .scan_prefix(&amp;KeyPrefix::Row((&amp;table.name).into()).encode()?)?
</a><a href="#h6-4-4" id="h6-4-4" class="i">+                .scan_prefix(&amp;KeyPrefix::Row((&amp;table.name).into()).encode())?
</a>                 .iter()
                 .map(|r| r.and_then(|(_, v)| Row::decode(&amp;v)))
                 .filter_map(move |r| match r {
<a href="#h6-5" id="h6-5" class="h">@@ -224,7 +224,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         Ok(Box::new(
             self.txn
                 .scan_prefix(
<a href="#h6-5-3" id="h6-5-3" class="d">-                    &amp;KeyPrefix::Index((&amp;table.name).into(), (&amp;column.name).into()).encode()?,
</a><a href="#h6-5-4" id="h6-5-4" class="i">+                    &amp;KeyPrefix::Index((&amp;table.name).into(), (&amp;column.name).into()).encode(),
</a>                 )?
                 .iter()
                 .map(|r| -&gt; Result&lt;(Value, HashSet&lt;Value&gt;)&gt; {
<a href="#h6-6" id="h6-6" class="h">@@ -268,7 +268,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         }
 
         table.validate_row(&amp;row, self)?;
<a href="#h6-6-3" id="h6-6-3" class="d">-        self.txn.set(&amp;Key::Row(table.name.into(), id.into()).encode()?, row.encode()?)
</a><a href="#h6-6-4" id="h6-6-4" class="i">+        self.txn.set(&amp;Key::Row(table.name.into(), id.into()).encode(), row.encode())
</a>     }
 }
 
<a href="#h6-7" id="h6-7" class="h">@@ -278,7 +278,7 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>             return errinput!(&quot;table {} already exists&quot;, table.name);
         }
         table.validate(self)?;
<a href="#h6-7-3" id="h6-7-3" class="d">-        self.txn.set(&amp;Key::Table((&amp;table.name).into()).encode()?, table.encode()?)
</a><a href="#h6-7-4" id="h6-7-4" class="i">+        self.txn.set(&amp;Key::Table((&amp;table.name).into()).encode(), table.encode())
</a>     }
 
     fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;()&gt; {
<a href="#h6-8" id="h6-8" class="h">@@ -290,17 +290,17 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>         while let Some(row) = scan.next().transpose()? {
             self.delete(&amp;table.name, &amp;table.get_row_key(&amp;row)?)?
         }
<a href="#h6-8-3" id="h6-8-3" class="d">-        self.txn.delete(&amp;Key::Table(table.name.into()).encode()?)
</a><a href="#h6-8-4" id="h6-8-4" class="i">+        self.txn.delete(&amp;Key::Table(table.name.into()).encode())
</a>     }
 
     fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;&gt; {
<a href="#h6-8-8" id="h6-8-8" class="d">-        self.txn.get(&amp;Key::Table(table.into()).encode()?)?.map(|v| Table::decode(&amp;v)).transpose()
</a><a href="#h6-8-9" id="h6-8-9" class="i">+        self.txn.get(&amp;Key::Table(table.into()).encode())?.map(|v| Table::decode(&amp;v)).transpose()
</a>     }
 
     fn scan_tables(&amp;self) -&gt; Result&lt;Tables&gt; {
         Ok(Box::new(
             self.txn
<a href="#h6-8-15" id="h6-8-15" class="d">-                .scan_prefix(&amp;KeyPrefix::Table.encode()?)?
</a><a href="#h6-8-16" id="h6-8-16" class="i">+                .scan_prefix(&amp;KeyPrefix::Table.encode())?
</a>                 .iter()
                 .map(|r| r.and_then(|(_, v)| Table::decode(&amp;v)))
                 .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
<b>diff --git a/<a id="h7" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -94,7 +94,7 @@ impl Client {
</a>     /// Mutates the Raft state machine, deserializing the response into the
     /// return type.
     fn mutate&lt;V: DeserializeOwned&gt;(&amp;self, mutation: Mutation) -&gt; Result&lt;V&gt; {
<a href="#h7-0-3" id="h7-0-3" class="d">-        match self.execute(raft::Request::Write(mutation.encode()?))? {
</a><a href="#h7-0-4" id="h7-0-4" class="i">+        match self.execute(raft::Request::Write(mutation.encode()))? {
</a>             raft::Response::Write(response) =&gt; Ok(bincode::deserialize(&amp;response)?),
             resp =&gt; errdata!(&quot;unexpected Raft mutation response {resp:?}&quot;),
         }
<a href="#h7-1" id="h7-1" class="h">@@ -103,7 +103,7 @@ impl Client {
</a>     /// Queries the Raft state machine, deserializing the response into the
     /// return type.
     fn query&lt;V: DeserializeOwned&gt;(&amp;self, query: Query) -&gt; Result&lt;V&gt; {
<a href="#h7-1-3" id="h7-1-3" class="d">-        match self.execute(raft::Request::Read(query.encode()?))? {
</a><a href="#h7-1-4" id="h7-1-4" class="i">+        match self.execute(raft::Request::Read(query.encode()))? {
</a>             raft::Response::Read(response) =&gt; Ok(bincode::deserialize(&amp;response)?),
             resp =&gt; errdata!(&quot;unexpected Raft query response {resp:?}&quot;),
         }
<a href="#h7-2" id="h7-2" class="h">@@ -310,7 +310,7 @@ impl&lt;E: storage::Engine&gt; State&lt;E&gt; {
</a> 
     /// Mutates the state machine.
     fn mutate(&amp;mut self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
<a href="#h7-2-3" id="h7-2-3" class="d">-        match mutation {
</a><a href="#h7-2-4" id="h7-2-4" class="i">+        let response = match mutation {
</a>             Mutation::Begin =&gt; self.engine.begin()?.state().encode(),
             Mutation::Commit(txn) =&gt; bincode::serialize(&amp;self.engine.resume(txn)?.commit()?),
             Mutation::Rollback(txn) =&gt; bincode::serialize(&amp;self.engine.resume(txn)?.rollback()?),
<a href="#h7-3" id="h7-3" class="h">@@ -331,7 +331,8 @@ impl&lt;E: storage::Engine&gt; State&lt;E&gt; {
</a>             Mutation::DeleteTable { txn, table } =&gt; {
                 bincode::serialize(&amp;self.engine.resume(txn)?.delete_table(&amp;table)?)
             }
<a href="#h7-3-3" id="h7-3-3" class="d">-        }
</a><a href="#h7-3-4" id="h7-3-4" class="i">+        };
</a><a href="#h7-3-5" id="h7-3-5" class="i">+        Ok(response)
</a>     }
 }
 
<a href="#h7-4" id="h7-4" class="h">@@ -354,12 +355,12 @@ impl&lt;E: storage::Engine&gt; raft::State for State&lt;E&gt; {
</a>             None =&gt; Ok(Vec::new()),
         };
         self.applied_index = entry.index;
<a href="#h7-4-3" id="h7-4-3" class="d">-        self.engine.set_metadata(b&quot;applied_index&quot;, bincode::serialize(&amp;entry.index)?)?;
</a><a href="#h7-4-4" id="h7-4-4" class="i">+        self.engine.set_metadata(b&quot;applied_index&quot;, bincode::serialize(&amp;entry.index))?;
</a>         result
     }
 
     fn read(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
<a href="#h7-4-9" id="h7-4-9" class="d">-        match Query::decode(&amp;command)? {
</a><a href="#h7-4-10" id="h7-4-10" class="i">+        let response = match Query::decode(&amp;command)? {
</a>             Query::BeginReadOnly { as_of } =&gt; {
                 let txn = if let Some(version) = as_of {
                     self.engine.begin_as_of(version)?
<a href="#h7-5" id="h7-5" class="h">@@ -390,6 +391,7 @@ impl&lt;E: storage::Engine&gt; raft::State for State&lt;E&gt; {
</a>             Query::ScanTables { txn } =&gt; {
                 self.engine.resume(txn)?.scan_tables()?.collect::&lt;Vec&lt;_&gt;&gt;().encode()
             }
<a href="#h7-5-3" id="h7-5-3" class="d">-        }
</a><a href="#h7-5-4" id="h7-5-4" class="i">+        };
</a><a href="#h7-5-5" id="h7-5-5" class="i">+        Ok(response)
</a>     }
 }
<b>diff --git a/<a id="h8" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -261,22 +261,22 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a> 
     /// Fetches the value of an unversioned key.
     pub fn get_unversioned(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
<a href="#h8-0-3" id="h8-0-3" class="d">-        self.engine.lock()?.get(&amp;Key::Unversioned(key.into()).encode()?)
</a><a href="#h8-0-4" id="h8-0-4" class="i">+        self.engine.lock()?.get(&amp;Key::Unversioned(key.into()).encode())
</a>     }
 
     /// Sets the value of an unversioned key.
     pub fn set_unversioned(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
<a href="#h8-0-9" id="h8-0-9" class="d">-        self.engine.lock()?.set(&amp;Key::Unversioned(key.into()).encode()?, value)
</a><a href="#h8-0-10" id="h8-0-10" class="i">+        self.engine.lock()?.set(&amp;Key::Unversioned(key.into()).encode(), value)
</a>     }
 
     /// Returns the status of the MVCC and storage engines.
     pub fn status(&amp;self) -&gt; Result&lt;Status&gt; {
         let mut engine = self.engine.lock()?;
<a href="#h8-0-16" id="h8-0-16" class="d">-        let versions = match engine.get(&amp;Key::NextVersion.encode()?)? {
</a><a href="#h8-0-17" id="h8-0-17" class="i">+        let versions = match engine.get(&amp;Key::NextVersion.encode())? {
</a>             Some(ref v) =&gt; Version::decode(v)? - 1,
             None =&gt; 0,
         };
<a href="#h8-0-21" id="h8-0-21" class="d">-        let active_txns = engine.scan_prefix(&amp;KeyPrefix::TxnActive.encode()?).count() as u64;
</a><a href="#h8-0-22" id="h8-0-22" class="i">+        let active_txns = engine.scan_prefix(&amp;KeyPrefix::TxnActive.encode()).count() as u64;
</a>         Ok(Status { versions, active_txns, storage: engine.status()? })
     }
 }
<a href="#h8-1" id="h8-1" class="h">@@ -363,19 +363,19 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         let mut session = engine.lock()?;
 
         // Allocate a new version to write at.
<a href="#h8-1-3" id="h8-1-3" class="d">-        let version = match session.get(&amp;Key::NextVersion.encode()?)? {
</a><a href="#h8-1-4" id="h8-1-4" class="i">+        let version = match session.get(&amp;Key::NextVersion.encode())? {
</a>             Some(ref v) =&gt; Version::decode(v)?,
             None =&gt; 1,
         };
<a href="#h8-1-8" id="h8-1-8" class="d">-        session.set(&amp;Key::NextVersion.encode()?, (version + 1).encode()?)?;
</a><a href="#h8-1-9" id="h8-1-9" class="i">+        session.set(&amp;Key::NextVersion.encode(), (version + 1).encode())?;
</a> 
         // Fetch the current set of active transactions, persist it for
         // time-travel queries if non-empty, then add this txn to it.
         let active = Self::scan_active(&amp;mut session)?;
         if !active.is_empty() {
<a href="#h8-1-15" id="h8-1-15" class="d">-            session.set(&amp;Key::TxnActiveSnapshot(version).encode()?, active.encode()?)?
</a><a href="#h8-1-16" id="h8-1-16" class="i">+            session.set(&amp;Key::TxnActiveSnapshot(version).encode(), active.encode())?
</a>         }
<a href="#h8-1-18" id="h8-1-18" class="d">-        session.set(&amp;Key::TxnActive(version).encode()?, vec![])?;
</a><a href="#h8-1-19" id="h8-1-19" class="i">+        session.set(&amp;Key::TxnActive(version).encode(), vec![])?;
</a>         drop(session);
 
         Ok(Self { engine, st: TransactionState { version, read_only: false, active } })
<a href="#h8-2" id="h8-2" class="h">@@ -389,7 +389,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         let mut session = engine.lock()?;
 
         // Fetch the latest version.
<a href="#h8-2-3" id="h8-2-3" class="d">-        let mut version = match session.get(&amp;Key::NextVersion.encode()?)? {
</a><a href="#h8-2-4" id="h8-2-4" class="i">+        let mut version = match session.get(&amp;Key::NextVersion.encode())? {
</a>             Some(ref v) =&gt; Version::decode(v)?,
             None =&gt; 1,
         };
<a href="#h8-3" id="h8-3" class="h">@@ -403,7 +403,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>                 return errinput!(&quot;version {as_of} does not exist&quot;);
             }
             version = as_of;
<a href="#h8-3-3" id="h8-3-3" class="d">-            if let Some(value) = session.get(&amp;Key::TxnActiveSnapshot(version).encode()?)? {
</a><a href="#h8-3-4" id="h8-3-4" class="i">+            if let Some(value) = session.get(&amp;Key::TxnActiveSnapshot(version).encode())? {
</a>                 active = HashSet::&lt;Version&gt;::decode(&amp;value)?;
             }
         } else {
<a href="#h8-4" id="h8-4" class="h">@@ -419,7 +419,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     fn resume(engine: Arc&lt;Mutex&lt;E&gt;&gt;, s: TransactionState) -&gt; Result&lt;Self&gt; {
         // For read-write transactions, verify that the transaction is still
         // active before making further writes.
<a href="#h8-4-3" id="h8-4-3" class="d">-        if !s.read_only &amp;&amp; engine.lock()?.get(&amp;Key::TxnActive(s.version).encode()?)?.is_none() {
</a><a href="#h8-4-4" id="h8-4-4" class="i">+        if !s.read_only &amp;&amp; engine.lock()?.get(&amp;Key::TxnActive(s.version).encode())?.is_none() {
</a>             return errinput!(&quot;no active transaction at version {}&quot;, s.version);
         }
         Ok(Self { engine, st: s })
<a href="#h8-5" id="h8-5" class="h">@@ -428,7 +428,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// Fetches the set of currently active transactions.
     fn scan_active(session: &amp;mut MutexGuard&lt;E&gt;) -&gt; Result&lt;HashSet&lt;Version&gt;&gt; {
         let mut active = HashSet::new();
<a href="#h8-5-3" id="h8-5-3" class="d">-        let mut scan = session.scan_prefix(&amp;KeyPrefix::TxnActive.encode()?);
</a><a href="#h8-5-4" id="h8-5-4" class="i">+        let mut scan = session.scan_prefix(&amp;KeyPrefix::TxnActive.encode());
</a>         while let Some((key, _)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::TxnActive(version) =&gt; active.insert(version),
<a href="#h8-6" id="h8-6" class="h">@@ -466,13 +466,13 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         }
         let mut session = self.engine.lock()?;
         let remove = session
<a href="#h8-6-3" id="h8-6-3" class="d">-            .scan_prefix(&amp;KeyPrefix::TxnWrite(self.st.version).encode()?)
</a><a href="#h8-6-4" id="h8-6-4" class="i">+            .scan_prefix(&amp;KeyPrefix::TxnWrite(self.st.version).encode())
</a>             .map(|r| r.map(|(k, _)| k))
             .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
         for key in remove {
             session.delete(&amp;key)?
         }
<a href="#h8-6-10" id="h8-6-10" class="d">-        session.delete(&amp;Key::TxnActive(self.st.version).encode()?)
</a><a href="#h8-6-11" id="h8-6-11" class="i">+        session.delete(&amp;Key::TxnActive(self.st.version).encode())
</a>     }
 
     /// Rolls back the transaction, by undoing all written versions and removing
<a href="#h8-7" id="h8-7" class="h">@@ -484,11 +484,11 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         }
         let mut session = self.engine.lock()?;
         let mut rollback = Vec::new();
<a href="#h8-7-3" id="h8-7-3" class="d">-        let mut scan = session.scan_prefix(&amp;KeyPrefix::TxnWrite(self.st.version).encode()?);
</a><a href="#h8-7-4" id="h8-7-4" class="i">+        let mut scan = session.scan_prefix(&amp;KeyPrefix::TxnWrite(self.st.version).encode());
</a>         while let Some((key, _)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::TxnWrite(_, key) =&gt; {
<a href="#h8-7-8" id="h8-7-8" class="d">-                    rollback.push(Key::Version(key, self.st.version).encode()?) // the version
</a><a href="#h8-7-9" id="h8-7-9" class="i">+                    rollback.push(Key::Version(key, self.st.version).encode()) // the version
</a>                 }
                 key =&gt; return errdata!(&quot;expected TxnWrite, got {key:?}&quot;),
             };
<a href="#h8-8" id="h8-8" class="h">@@ -498,7 +498,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         for key in rollback.into_iter() {
             session.delete(&amp;key)?;
         }
<a href="#h8-8-3" id="h8-8-3" class="d">-        session.delete(&amp;Key::TxnActive(self.st.version).encode()?) // remove from active set
</a><a href="#h8-8-4" id="h8-8-4" class="i">+        session.delete(&amp;Key::TxnActive(self.st.version).encode()) // remove from active set
</a>     }
 
     /// Deletes a key.
<a href="#h8-9" id="h8-9" class="h">@@ -529,8 +529,8 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>             key.into(),
             self.st.active.iter().min().copied().unwrap_or(self.st.version + 1),
         )
<a href="#h8-9-3" id="h8-9-3" class="d">-        .encode()?;
</a><a href="#h8-9-4" id="h8-9-4" class="d">-        let to = Key::Version(key.into(), u64::MAX).encode()?;
</a><a href="#h8-9-5" id="h8-9-5" class="i">+        .encode();
</a><a href="#h8-9-6" id="h8-9-6" class="i">+        let to = Key::Version(key.into(), u64::MAX).encode();
</a>         if let Some((key, _)) = session.scan(from..=to).last().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::Version(_, version) =&gt; {
<a href="#h8-10" id="h8-10" class="h">@@ -546,16 +546,15 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         //
         // NB: TxnWrite contains the provided user key, not the encoded engine
         // key, since we can construct the engine key using the version.
<a href="#h8-10-3" id="h8-10-3" class="d">-        session.set(&amp;Key::TxnWrite(self.st.version, key.into()).encode()?, vec![])?;
</a><a href="#h8-10-4" id="h8-10-4" class="d">-        session
</a><a href="#h8-10-5" id="h8-10-5" class="d">-            .set(&amp;Key::Version(key.into(), self.st.version).encode()?, bincode::serialize(&amp;value)?)
</a><a href="#h8-10-6" id="h8-10-6" class="i">+        session.set(&amp;Key::TxnWrite(self.st.version, key.into()).encode(), vec![])?;
</a><a href="#h8-10-7" id="h8-10-7" class="i">+        session.set(&amp;Key::Version(key.into(), self.st.version).encode(), bincode::serialize(&amp;value))
</a>     }
 
     /// Fetches a key&#39;s value, or None if it does not exist.
     pub fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
         let mut session = self.engine.lock()?;
<a href="#h8-10-13" id="h8-10-13" class="d">-        let from = Key::Version(key.into(), 0).encode()?;
</a><a href="#h8-10-14" id="h8-10-14" class="d">-        let to = Key::Version(key.into(), self.st.version).encode()?;
</a><a href="#h8-10-15" id="h8-10-15" class="i">+        let from = Key::Version(key.into(), 0).encode();
</a><a href="#h8-10-16" id="h8-10-16" class="i">+        let to = Key::Version(key.into(), self.st.version).encode();
</a>         let mut scan = session.scan(from..=to).rev();
         while let Some((key, value)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
<a href="#h8-11" id="h8-11" class="h">@@ -574,14 +573,14 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// transaction&#39;s version.
     pub fn scan&lt;R: RangeBounds&lt;Vec&lt;u8&gt;&gt;&gt;(&amp;self, range: R) -&gt; Result&lt;Scan&lt;E&gt;&gt; {
         let start = match range.start_bound() {
<a href="#h8-11-3" id="h8-11-3" class="d">-            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Version(k.into(), u64::MAX).encode()?),
</a><a href="#h8-11-4" id="h8-11-4" class="d">-            Bound::Included(k) =&gt; Bound::Included(Key::Version(k.into(), 0).encode()?),
</a><a href="#h8-11-5" id="h8-11-5" class="d">-            Bound::Unbounded =&gt; Bound::Included(Key::Version(vec![].into(), 0).encode()?),
</a><a href="#h8-11-6" id="h8-11-6" class="i">+            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Version(k.into(), u64::MAX).encode()),
</a><a href="#h8-11-7" id="h8-11-7" class="i">+            Bound::Included(k) =&gt; Bound::Included(Key::Version(k.into(), 0).encode()),
</a><a href="#h8-11-8" id="h8-11-8" class="i">+            Bound::Unbounded =&gt; Bound::Included(Key::Version(vec![].into(), 0).encode()),
</a>         };
         let end = match range.end_bound() {
<a href="#h8-11-11" id="h8-11-11" class="d">-            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Version(k.into(), 0).encode()?),
</a><a href="#h8-11-12" id="h8-11-12" class="d">-            Bound::Included(k) =&gt; Bound::Included(Key::Version(k.into(), u64::MAX).encode()?),
</a><a href="#h8-11-13" id="h8-11-13" class="d">-            Bound::Unbounded =&gt; Bound::Excluded(KeyPrefix::Unversioned.encode()?),
</a><a href="#h8-11-14" id="h8-11-14" class="i">+            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Version(k.into(), 0).encode()),
</a><a href="#h8-11-15" id="h8-11-15" class="i">+            Bound::Included(k) =&gt; Bound::Included(Key::Version(k.into(), u64::MAX).encode()),
</a><a href="#h8-11-16" id="h8-11-16" class="i">+            Bound::Unbounded =&gt; Bound::Excluded(KeyPrefix::Unversioned.encode()),
</a>         };
         Ok(Scan::new(self.engine.lock()?, self.state(), start, end))
     }
<a href="#h8-12" id="h8-12" class="h">@@ -591,7 +590,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         // Normally, KeyPrefix::Version will only match all versions of the
         // exact given key. We want all keys maching the prefix, so we chop off
         // the KeyCode byte slice terminator 0x0000 at the end.
<a href="#h8-12-3" id="h8-12-3" class="d">-        let mut prefix = KeyPrefix::Version(prefix.into()).encode()?;
</a><a href="#h8-12-4" id="h8-12-4" class="i">+        let mut prefix = KeyPrefix::Version(prefix.into()).encode();
</a>         prefix.truncate(prefix.len() - 2);
         Ok(Scan::new_prefix(self.engine.lock()?, self.state(), prefix))
     }
<a href="#h8-13" id="h8-13" class="h">@@ -1137,8 +1136,8 @@ pub mod tests {
</a>         ];
 
         for (prefix, key) in cases {
<a href="#h8-13-3" id="h8-13-3" class="d">-            let prefix = prefix.encode()?;
</a><a href="#h8-13-4" id="h8-13-4" class="d">-            let key = key.encode()?;
</a><a href="#h8-13-5" id="h8-13-5" class="i">+            let prefix = prefix.encode();
</a><a href="#h8-13-6" id="h8-13-6" class="i">+            let key = key.encode();
</a>             assert_eq!(prefix, key[..prefix.len()])
         }
         Ok(())
</pre>
</div>
</body>
</html>
