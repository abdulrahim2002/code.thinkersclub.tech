<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: rename plan module to planner - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/cdb202da40e5c14d7ac8268a4f464e568d4ee171.html">cdb202da40e5c14d7ac8268a4f464e568d4ee171</a>
<b>parent</b> <a href="../commit/59cb4b38d51f0fe85a1907cacc22e7bbd79a02fd.html">59cb4b38d51f0fe85a1907cacc22e7bbd79a02fd</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Thu, 20 Jun 2024 15:09:10 +0200

sql: rename plan module to planner

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/engine/session.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/execution/aggregate.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/execution/execute.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/execution/transform.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="D">D</td><td><a href="#h5">src/sql/plan/plan.rs</a></td><td> | </td><td class="num">446</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h6">src/sql/plan/planner.rs</a></td><td> | </td><td class="num">812</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="R">R</td><td><a href="#h7">src/sql/plan/mod.rs -&gt; src/sql/planner/mod.rs</a></td><td> | </td><td class="num">0</td><td><span class="i"></span><span class="d"></span></td></tr>
<tr><td class="R">R</td><td><a href="#h8">src/sql/plan/optimizer.rs -&gt; src/sql/planner/optimizer.rs</a></td><td> | </td><td class="num">0</td><td><span class="i"></span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h9">src/sql/planner/plan.rs</a></td><td> | </td><td class="num">444</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h10">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">814</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">tests/sql/query.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
</table></pre><pre>12 files changed, 1264 insertions(+), 1264 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/engine/session.rs.html">src/sql/engine/session.rs</a> b/<a href="../file/src/sql/engine/session.rs.html">src/sql/engine/session.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -3,7 +3,7 @@ use super::{Engine, Transaction as _};
</a> use crate::error::{Error, Result};
 use crate::sql::execution::ExecutionResult;
 use crate::sql::parser::{ast, Parser};
<a href="#h0-0-3" id="h0-0-3" class="d">-use crate::sql::plan::Plan;
</a><a href="#h0-0-4" id="h0-0-4" class="i">+use crate::sql::planner::Plan;
</a> use crate::sql::types::{Row, Rows, Value};
 use crate::storage::mvcc;
 use crate::{errdata, errinput};
<b>diff --git a/<a id="h1" href="../file/src/sql/execution/aggregate.rs.html">src/sql/execution/aggregate.rs</a> b/<a href="../file/src/sql/execution/aggregate.rs.html">src/sql/execution/aggregate.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,6 +1,6 @@
</a> use super::QueryIterator;
 use crate::error::Result;
<a href="#h1-0-2" id="h1-0-2" class="d">-use crate::sql::plan::Aggregate;
</a><a href="#h1-0-3" id="h1-0-3" class="i">+use crate::sql::planner::Aggregate;
</a> use crate::sql::types::Value;
 
 use std::cmp::Ordering;
<b>diff --git a/<a id="h2" href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a> b/<a href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -6,7 +6,7 @@ use super::transform;
</a> use super::write;
 use crate::error::Result;
 use crate::sql::engine::{Catalog, Transaction};
<a href="#h2-0-3" id="h2-0-3" class="d">-use crate::sql::plan::{Node, Plan};
</a><a href="#h2-0-4" id="h2-0-4" class="i">+use crate::sql::planner::{Node, Plan};
</a> use crate::sql::types::{Row, Rows};
 
 /// Executes a plan, returning an execution result.
<b>diff --git a/<a id="h3" href="../file/src/sql/execution/transform.rs.html">src/sql/execution/transform.rs</a> b/<a href="../file/src/sql/execution/transform.rs.html">src/sql/execution/transform.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -3,7 +3,7 @@ use itertools::izip;
</a> use super::QueryIterator;
 use crate::errinput;
 use crate::error::Result;
<a href="#h3-0-3" id="h3-0-3" class="d">-use crate::sql::plan::Direction;
</a><a href="#h3-0-4" id="h3-0-4" class="i">+use crate::sql::planner::Direction;
</a> use crate::sql::types::{Expression, Value};
 
 /// Filters the input rows (i.e. WHERE).
<b>diff --git a/<a id="h4" href="../file/src/sql/mod.rs.html">src/sql/mod.rs</a> b/<a href="../file/src/sql/mod.rs.html">src/sql/mod.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -1,5 +1,5 @@
</a> pub mod engine;
 pub mod execution;
 pub mod parser;
<a href="#h4-0-3" id="h4-0-3" class="d">-pub mod plan;
</a><a href="#h4-0-4" id="h4-0-4" class="i">+pub mod planner;
</a> pub mod types;
<b>diff --git a/<a id="h5" href="../file/src/sql/plan/plan.rs.html">src/sql/plan/plan.rs</a> b/<a href="../file/src/sql/plan/plan.rs.html">src/sql/plan/plan.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,446 +0,0 @@
</a><a href="#h5-0-0" id="h5-0-0" class="d">-#![allow(clippy::module_inception)]
</a><a href="#h5-0-1" id="h5-0-1" class="d">-
</a><a href="#h5-0-2" id="h5-0-2" class="d">-use super::optimizer::{self, Optimizer as _};
</a><a href="#h5-0-3" id="h5-0-3" class="d">-use super::planner::Planner;
</a><a href="#h5-0-4" id="h5-0-4" class="d">-use crate::error::Result;
</a><a href="#h5-0-5" id="h5-0-5" class="d">-use crate::sql::engine::{Catalog, Transaction};
</a><a href="#h5-0-6" id="h5-0-6" class="d">-use crate::sql::execution::{self, ExecutionResult};
</a><a href="#h5-0-7" id="h5-0-7" class="d">-use crate::sql::parser::ast;
</a><a href="#h5-0-8" id="h5-0-8" class="d">-use crate::sql::types::{Expression, Table, Value};
</a><a href="#h5-0-9" id="h5-0-9" class="d">-
</a><a href="#h5-0-10" id="h5-0-10" class="d">-use serde::{Deserialize, Serialize};
</a><a href="#h5-0-11" id="h5-0-11" class="d">-
</a><a href="#h5-0-12" id="h5-0-12" class="d">-/// A statement execution plan. These are mostly made up of nested query plan
</a><a href="#h5-0-13" id="h5-0-13" class="d">-/// Nodes, which stream rows, but the root nodes can also perform data
</a><a href="#h5-0-14" id="h5-0-14" class="d">-/// modifications or schema changes.
</a><a href="#h5-0-15" id="h5-0-15" class="d">-#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h5-0-16" id="h5-0-16" class="d">-pub enum Plan {
</a><a href="#h5-0-17" id="h5-0-17" class="d">-    /// A CREATE TABLE plan.
</a><a href="#h5-0-18" id="h5-0-18" class="d">-    CreateTable { schema: Table },
</a><a href="#h5-0-19" id="h5-0-19" class="d">-    /// A DROP TABLE plan.
</a><a href="#h5-0-20" id="h5-0-20" class="d">-    DropTable { table: String, if_exists: bool },
</a><a href="#h5-0-21" id="h5-0-21" class="d">-    /// A DELETE plan.
</a><a href="#h5-0-22" id="h5-0-22" class="d">-    Delete { table: String, key_index: usize, source: Node },
</a><a href="#h5-0-23" id="h5-0-23" class="d">-    /// An INSERT plan.
</a><a href="#h5-0-24" id="h5-0-24" class="d">-    /// TODO: consider using a source which generates expression rows.
</a><a href="#h5-0-25" id="h5-0-25" class="d">-    Insert { table: Table, columns: Vec&lt;String&gt;, expressions: Vec&lt;Vec&lt;Expression&gt;&gt; },
</a><a href="#h5-0-26" id="h5-0-26" class="d">-    /// An UPDATE plan.
</a><a href="#h5-0-27" id="h5-0-27" class="d">-    Update {
</a><a href="#h5-0-28" id="h5-0-28" class="d">-        table: String,
</a><a href="#h5-0-29" id="h5-0-29" class="d">-        key_index: usize,
</a><a href="#h5-0-30" id="h5-0-30" class="d">-        source: Node,
</a><a href="#h5-0-31" id="h5-0-31" class="d">-        expressions: Vec&lt;(usize, Option&lt;String&gt;, Expression)&gt;,
</a><a href="#h5-0-32" id="h5-0-32" class="d">-    },
</a><a href="#h5-0-33" id="h5-0-33" class="d">-    /// A SELECT plan.
</a><a href="#h5-0-34" id="h5-0-34" class="d">-    Select(Node),
</a><a href="#h5-0-35" id="h5-0-35" class="d">-}
</a><a href="#h5-0-36" id="h5-0-36" class="d">-
</a><a href="#h5-0-37" id="h5-0-37" class="d">-impl Plan {
</a><a href="#h5-0-38" id="h5-0-38" class="d">-    /// Builds a plan from an AST statement.
</a><a href="#h5-0-39" id="h5-0-39" class="d">-    pub fn build(statement: ast::Statement, catalog: &amp;impl Catalog) -&gt; Result&lt;Self&gt; {
</a><a href="#h5-0-40" id="h5-0-40" class="d">-        Planner::new(catalog).build(statement)
</a><a href="#h5-0-41" id="h5-0-41" class="d">-    }
</a><a href="#h5-0-42" id="h5-0-42" class="d">-
</a><a href="#h5-0-43" id="h5-0-43" class="d">-    /// Executes the plan, consuming it.
</a><a href="#h5-0-44" id="h5-0-44" class="d">-    pub fn execute(self, txn: &amp;(impl Transaction + Catalog)) -&gt; Result&lt;ExecutionResult&gt; {
</a><a href="#h5-0-45" id="h5-0-45" class="d">-        execution::execute_plan(self, txn, txn)
</a><a href="#h5-0-46" id="h5-0-46" class="d">-    }
</a><a href="#h5-0-47" id="h5-0-47" class="d">-
</a><a href="#h5-0-48" id="h5-0-48" class="d">-    /// Optimizes the plan, consuming it.
</a><a href="#h5-0-49" id="h5-0-49" class="d">-    pub fn optimize(self) -&gt; Result&lt;Self&gt; {
</a><a href="#h5-0-50" id="h5-0-50" class="d">-        let optimize = |mut node| -&gt; Result&lt;Node&gt; {
</a><a href="#h5-0-51" id="h5-0-51" class="d">-            node = optimizer::ConstantFolder.optimize(node)?;
</a><a href="#h5-0-52" id="h5-0-52" class="d">-            node = optimizer::FilterPushdown.optimize(node)?;
</a><a href="#h5-0-53" id="h5-0-53" class="d">-            node = optimizer::IndexLookup.optimize(node)?;
</a><a href="#h5-0-54" id="h5-0-54" class="d">-            node = optimizer::NoopCleaner.optimize(node)?;
</a><a href="#h5-0-55" id="h5-0-55" class="d">-            node = optimizer::JoinType.optimize(node)?;
</a><a href="#h5-0-56" id="h5-0-56" class="d">-            Ok(node)
</a><a href="#h5-0-57" id="h5-0-57" class="d">-        };
</a><a href="#h5-0-58" id="h5-0-58" class="d">-        Ok(match self {
</a><a href="#h5-0-59" id="h5-0-59" class="d">-            Self::CreateTable { .. } | Self::DropTable { .. } | Self::Insert { .. } =&gt; self,
</a><a href="#h5-0-60" id="h5-0-60" class="d">-            Self::Delete { table, key_index, source } =&gt; {
</a><a href="#h5-0-61" id="h5-0-61" class="d">-                Self::Delete { table, key_index, source: optimize(source)? }
</a><a href="#h5-0-62" id="h5-0-62" class="d">-            }
</a><a href="#h5-0-63" id="h5-0-63" class="d">-            Self::Update { table, key_index, source, expressions } =&gt; {
</a><a href="#h5-0-64" id="h5-0-64" class="d">-                Self::Update { table, key_index, source: optimize(source)?, expressions }
</a><a href="#h5-0-65" id="h5-0-65" class="d">-            }
</a><a href="#h5-0-66" id="h5-0-66" class="d">-            Self::Select(root) =&gt; Self::Select(optimize(root)?),
</a><a href="#h5-0-67" id="h5-0-67" class="d">-        })
</a><a href="#h5-0-68" id="h5-0-68" class="d">-    }
</a><a href="#h5-0-69" id="h5-0-69" class="d">-}
</a><a href="#h5-0-70" id="h5-0-70" class="d">-
</a><a href="#h5-0-71" id="h5-0-71" class="d">-// TODO: this needs testing and cleaning up.
</a><a href="#h5-0-72" id="h5-0-72" class="d">-impl std::fmt::Display for Plan {
</a><a href="#h5-0-73" id="h5-0-73" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h5-0-74" id="h5-0-74" class="d">-        match self {
</a><a href="#h5-0-75" id="h5-0-75" class="d">-            Self::CreateTable { schema } =&gt; write!(f, &quot;CreateTable: {}&quot;, schema.name),
</a><a href="#h5-0-76" id="h5-0-76" class="d">-            Self::DropTable { table, if_exists: _ } =&gt; write!(f, &quot;DropTable: {table}&quot;),
</a><a href="#h5-0-77" id="h5-0-77" class="d">-            Self::Delete { table, key_index: _, source } =&gt; {
</a><a href="#h5-0-78" id="h5-0-78" class="d">-                write!(
</a><a href="#h5-0-79" id="h5-0-79" class="d">-                    f,
</a><a href="#h5-0-80" id="h5-0-80" class="d">-                    &quot;Delete: {table}\n{}&quot;,
</a><a href="#h5-0-81" id="h5-0-81" class="d">-                    source.format(String::new(), false, true).trim_end()
</a><a href="#h5-0-82" id="h5-0-82" class="d">-                )
</a><a href="#h5-0-83" id="h5-0-83" class="d">-            }
</a><a href="#h5-0-84" id="h5-0-84" class="d">-            Self::Insert { table, columns: _, expressions } =&gt; {
</a><a href="#h5-0-85" id="h5-0-85" class="d">-                write!(f, &quot;Insert: {} ({} rows)&quot;, table.name, expressions.len())
</a><a href="#h5-0-86" id="h5-0-86" class="d">-            }
</a><a href="#h5-0-87" id="h5-0-87" class="d">-            Self::Select(root) =&gt; root.fmt(f),
</a><a href="#h5-0-88" id="h5-0-88" class="d">-            Self::Update { table, key_index: _, source, expressions } =&gt; {
</a><a href="#h5-0-89" id="h5-0-89" class="d">-                write!(
</a><a href="#h5-0-90" id="h5-0-90" class="d">-                    f,
</a><a href="#h5-0-91" id="h5-0-91" class="d">-                    &quot;Update: {table} ({})\n{}&quot;,
</a><a href="#h5-0-92" id="h5-0-92" class="d">-                    expressions
</a><a href="#h5-0-93" id="h5-0-93" class="d">-                        .iter()
</a><a href="#h5-0-94" id="h5-0-94" class="d">-                        .map(|(i, l, e)| format!(
</a><a href="#h5-0-95" id="h5-0-95" class="d">-                            &quot;{}={}&quot;,
</a><a href="#h5-0-96" id="h5-0-96" class="d">-                            l.clone().unwrap_or_else(|| format!(&quot;#{}&quot;, i)),
</a><a href="#h5-0-97" id="h5-0-97" class="d">-                            e
</a><a href="#h5-0-98" id="h5-0-98" class="d">-                        ))
</a><a href="#h5-0-99" id="h5-0-99" class="d">-                        .collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h5-0-100" id="h5-0-100" class="d">-                        .join(&quot;,&quot;),
</a><a href="#h5-0-101" id="h5-0-101" class="d">-                    source.format(String::new(), false, true).trim_end()
</a><a href="#h5-0-102" id="h5-0-102" class="d">-                )
</a><a href="#h5-0-103" id="h5-0-103" class="d">-            }
</a><a href="#h5-0-104" id="h5-0-104" class="d">-        }
</a><a href="#h5-0-105" id="h5-0-105" class="d">-    }
</a><a href="#h5-0-106" id="h5-0-106" class="d">-}
</a><a href="#h5-0-107" id="h5-0-107" class="d">-
</a><a href="#h5-0-108" id="h5-0-108" class="d">-/// A query plan node. These return row iterators and can be nested.
</a><a href="#h5-0-109" id="h5-0-109" class="d">-#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h5-0-110" id="h5-0-110" class="d">-pub enum Node {
</a><a href="#h5-0-111" id="h5-0-111" class="d">-    Aggregation {
</a><a href="#h5-0-112" id="h5-0-112" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h5-0-113" id="h5-0-113" class="d">-        aggregates: Vec&lt;Aggregate&gt;,
</a><a href="#h5-0-114" id="h5-0-114" class="d">-    },
</a><a href="#h5-0-115" id="h5-0-115" class="d">-    Filter {
</a><a href="#h5-0-116" id="h5-0-116" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h5-0-117" id="h5-0-117" class="d">-        predicate: Expression,
</a><a href="#h5-0-118" id="h5-0-118" class="d">-    },
</a><a href="#h5-0-119" id="h5-0-119" class="d">-    HashJoin {
</a><a href="#h5-0-120" id="h5-0-120" class="d">-        left: Box&lt;Node&gt;,
</a><a href="#h5-0-121" id="h5-0-121" class="d">-        left_field: (usize, Option&lt;(Option&lt;String&gt;, String)&gt;),
</a><a href="#h5-0-122" id="h5-0-122" class="d">-        right: Box&lt;Node&gt;,
</a><a href="#h5-0-123" id="h5-0-123" class="d">-        right_field: (usize, Option&lt;(Option&lt;String&gt;, String)&gt;),
</a><a href="#h5-0-124" id="h5-0-124" class="d">-        outer: bool,
</a><a href="#h5-0-125" id="h5-0-125" class="d">-    },
</a><a href="#h5-0-126" id="h5-0-126" class="d">-    IndexLookup {
</a><a href="#h5-0-127" id="h5-0-127" class="d">-        table: Table,
</a><a href="#h5-0-128" id="h5-0-128" class="d">-        alias: Option&lt;String&gt;,
</a><a href="#h5-0-129" id="h5-0-129" class="d">-        column: String,
</a><a href="#h5-0-130" id="h5-0-130" class="d">-        values: Vec&lt;Value&gt;,
</a><a href="#h5-0-131" id="h5-0-131" class="d">-    },
</a><a href="#h5-0-132" id="h5-0-132" class="d">-    KeyLookup {
</a><a href="#h5-0-133" id="h5-0-133" class="d">-        table: Table,
</a><a href="#h5-0-134" id="h5-0-134" class="d">-        alias: Option&lt;String&gt;,
</a><a href="#h5-0-135" id="h5-0-135" class="d">-        keys: Vec&lt;Value&gt;,
</a><a href="#h5-0-136" id="h5-0-136" class="d">-    },
</a><a href="#h5-0-137" id="h5-0-137" class="d">-    Limit {
</a><a href="#h5-0-138" id="h5-0-138" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h5-0-139" id="h5-0-139" class="d">-        limit: u64,
</a><a href="#h5-0-140" id="h5-0-140" class="d">-    },
</a><a href="#h5-0-141" id="h5-0-141" class="d">-    NestedLoopJoin {
</a><a href="#h5-0-142" id="h5-0-142" class="d">-        left: Box&lt;Node&gt;,
</a><a href="#h5-0-143" id="h5-0-143" class="d">-        left_size: usize,
</a><a href="#h5-0-144" id="h5-0-144" class="d">-        right: Box&lt;Node&gt;,
</a><a href="#h5-0-145" id="h5-0-145" class="d">-        predicate: Option&lt;Expression&gt;,
</a><a href="#h5-0-146" id="h5-0-146" class="d">-        outer: bool,
</a><a href="#h5-0-147" id="h5-0-147" class="d">-    },
</a><a href="#h5-0-148" id="h5-0-148" class="d">-    Nothing,
</a><a href="#h5-0-149" id="h5-0-149" class="d">-    Offset {
</a><a href="#h5-0-150" id="h5-0-150" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h5-0-151" id="h5-0-151" class="d">-        offset: u64,
</a><a href="#h5-0-152" id="h5-0-152" class="d">-    },
</a><a href="#h5-0-153" id="h5-0-153" class="d">-    Order {
</a><a href="#h5-0-154" id="h5-0-154" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h5-0-155" id="h5-0-155" class="d">-        orders: Vec&lt;(Expression, Direction)&gt;,
</a><a href="#h5-0-156" id="h5-0-156" class="d">-    },
</a><a href="#h5-0-157" id="h5-0-157" class="d">-    Projection {
</a><a href="#h5-0-158" id="h5-0-158" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h5-0-159" id="h5-0-159" class="d">-        expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h5-0-160" id="h5-0-160" class="d">-    },
</a><a href="#h5-0-161" id="h5-0-161" class="d">-    Scan {
</a><a href="#h5-0-162" id="h5-0-162" class="d">-        table: Table,
</a><a href="#h5-0-163" id="h5-0-163" class="d">-        alias: Option&lt;String&gt;,
</a><a href="#h5-0-164" id="h5-0-164" class="d">-        filter: Option&lt;Expression&gt;,
</a><a href="#h5-0-165" id="h5-0-165" class="d">-    },
</a><a href="#h5-0-166" id="h5-0-166" class="d">-}
</a><a href="#h5-0-167" id="h5-0-167" class="d">-
</a><a href="#h5-0-168" id="h5-0-168" class="d">-impl Node {
</a><a href="#h5-0-169" id="h5-0-169" class="d">-    /// Recursively transforms query nodes by applying the given closures before
</a><a href="#h5-0-170" id="h5-0-170" class="d">-    /// and after descending.
</a><a href="#h5-0-171" id="h5-0-171" class="d">-    pub fn transform&lt;B, A&gt;(mut self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
</a><a href="#h5-0-172" id="h5-0-172" class="d">-    where
</a><a href="#h5-0-173" id="h5-0-173" class="d">-        B: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h5-0-174" id="h5-0-174" class="d">-        A: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h5-0-175" id="h5-0-175" class="d">-    {
</a><a href="#h5-0-176" id="h5-0-176" class="d">-        self = before(self)?;
</a><a href="#h5-0-177" id="h5-0-177" class="d">-        self = match self {
</a><a href="#h5-0-178" id="h5-0-178" class="d">-            node @ Self::IndexLookup { .. }
</a><a href="#h5-0-179" id="h5-0-179" class="d">-            | node @ Self::KeyLookup { .. }
</a><a href="#h5-0-180" id="h5-0-180" class="d">-            | node @ Self::Nothing
</a><a href="#h5-0-181" id="h5-0-181" class="d">-            | node @ Self::Scan { .. } =&gt; node,
</a><a href="#h5-0-182" id="h5-0-182" class="d">-
</a><a href="#h5-0-183" id="h5-0-183" class="d">-            Self::Aggregation { source, aggregates } =&gt; {
</a><a href="#h5-0-184" id="h5-0-184" class="d">-                Self::Aggregation { source: source.transform(before, after)?.into(), aggregates }
</a><a href="#h5-0-185" id="h5-0-185" class="d">-            }
</a><a href="#h5-0-186" id="h5-0-186" class="d">-            Self::Filter { source, predicate } =&gt; {
</a><a href="#h5-0-187" id="h5-0-187" class="d">-                Self::Filter { source: source.transform(before, after)?.into(), predicate }
</a><a href="#h5-0-188" id="h5-0-188" class="d">-            }
</a><a href="#h5-0-189" id="h5-0-189" class="d">-            Self::HashJoin { left, left_field, right, right_field, outer } =&gt; Self::HashJoin {
</a><a href="#h5-0-190" id="h5-0-190" class="d">-                left: left.transform(before, after)?.into(),
</a><a href="#h5-0-191" id="h5-0-191" class="d">-                left_field,
</a><a href="#h5-0-192" id="h5-0-192" class="d">-                right: right.transform(before, after)?.into(),
</a><a href="#h5-0-193" id="h5-0-193" class="d">-                right_field,
</a><a href="#h5-0-194" id="h5-0-194" class="d">-                outer,
</a><a href="#h5-0-195" id="h5-0-195" class="d">-            },
</a><a href="#h5-0-196" id="h5-0-196" class="d">-            Self::Limit { source, limit } =&gt; {
</a><a href="#h5-0-197" id="h5-0-197" class="d">-                Self::Limit { source: source.transform(before, after)?.into(), limit }
</a><a href="#h5-0-198" id="h5-0-198" class="d">-            }
</a><a href="#h5-0-199" id="h5-0-199" class="d">-            Self::NestedLoopJoin { left, left_size, right, predicate, outer } =&gt; {
</a><a href="#h5-0-200" id="h5-0-200" class="d">-                Self::NestedLoopJoin {
</a><a href="#h5-0-201" id="h5-0-201" class="d">-                    left: left.transform(before, after)?.into(),
</a><a href="#h5-0-202" id="h5-0-202" class="d">-                    left_size,
</a><a href="#h5-0-203" id="h5-0-203" class="d">-                    right: right.transform(before, after)?.into(),
</a><a href="#h5-0-204" id="h5-0-204" class="d">-                    predicate,
</a><a href="#h5-0-205" id="h5-0-205" class="d">-                    outer,
</a><a href="#h5-0-206" id="h5-0-206" class="d">-                }
</a><a href="#h5-0-207" id="h5-0-207" class="d">-            }
</a><a href="#h5-0-208" id="h5-0-208" class="d">-            Self::Offset { source, offset } =&gt; {
</a><a href="#h5-0-209" id="h5-0-209" class="d">-                Self::Offset { source: source.transform(before, after)?.into(), offset }
</a><a href="#h5-0-210" id="h5-0-210" class="d">-            }
</a><a href="#h5-0-211" id="h5-0-211" class="d">-            Self::Order { source, orders } =&gt; {
</a><a href="#h5-0-212" id="h5-0-212" class="d">-                Self::Order { source: source.transform(before, after)?.into(), orders }
</a><a href="#h5-0-213" id="h5-0-213" class="d">-            }
</a><a href="#h5-0-214" id="h5-0-214" class="d">-            Self::Projection { source, expressions } =&gt; {
</a><a href="#h5-0-215" id="h5-0-215" class="d">-                Self::Projection { source: source.transform(before, after)?.into(), expressions }
</a><a href="#h5-0-216" id="h5-0-216" class="d">-            }
</a><a href="#h5-0-217" id="h5-0-217" class="d">-        };
</a><a href="#h5-0-218" id="h5-0-218" class="d">-        after(self)
</a><a href="#h5-0-219" id="h5-0-219" class="d">-    }
</a><a href="#h5-0-220" id="h5-0-220" class="d">-
</a><a href="#h5-0-221" id="h5-0-221" class="d">-    /// Recursively transforms all expressions in a node by calling the given closures
</a><a href="#h5-0-222" id="h5-0-222" class="d">-    /// on them before and after descending.
</a><a href="#h5-0-223" id="h5-0-223" class="d">-    pub fn transform_expressions&lt;B, A&gt;(self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
</a><a href="#h5-0-224" id="h5-0-224" class="d">-    where
</a><a href="#h5-0-225" id="h5-0-225" class="d">-        B: Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h5-0-226" id="h5-0-226" class="d">-        A: Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h5-0-227" id="h5-0-227" class="d">-    {
</a><a href="#h5-0-228" id="h5-0-228" class="d">-        Ok(match self {
</a><a href="#h5-0-229" id="h5-0-229" class="d">-            node @ Self::Aggregation { .. }
</a><a href="#h5-0-230" id="h5-0-230" class="d">-            | node @ Self::HashJoin { .. }
</a><a href="#h5-0-231" id="h5-0-231" class="d">-            | node @ Self::IndexLookup { .. }
</a><a href="#h5-0-232" id="h5-0-232" class="d">-            | node @ Self::KeyLookup { .. }
</a><a href="#h5-0-233" id="h5-0-233" class="d">-            | node @ Self::Limit { .. }
</a><a href="#h5-0-234" id="h5-0-234" class="d">-            | node @ Self::NestedLoopJoin { predicate: None, .. }
</a><a href="#h5-0-235" id="h5-0-235" class="d">-            | node @ Self::Nothing
</a><a href="#h5-0-236" id="h5-0-236" class="d">-            | node @ Self::Offset { .. }
</a><a href="#h5-0-237" id="h5-0-237" class="d">-            | node @ Self::Scan { filter: None, .. } =&gt; node,
</a><a href="#h5-0-238" id="h5-0-238" class="d">-
</a><a href="#h5-0-239" id="h5-0-239" class="d">-            Self::Filter { source, predicate } =&gt; {
</a><a href="#h5-0-240" id="h5-0-240" class="d">-                Self::Filter { source, predicate: predicate.transform(before, after)? }
</a><a href="#h5-0-241" id="h5-0-241" class="d">-            }
</a><a href="#h5-0-242" id="h5-0-242" class="d">-            Self::Order { source, orders } =&gt; Self::Order {
</a><a href="#h5-0-243" id="h5-0-243" class="d">-                source,
</a><a href="#h5-0-244" id="h5-0-244" class="d">-                orders: orders
</a><a href="#h5-0-245" id="h5-0-245" class="d">-                    .into_iter()
</a><a href="#h5-0-246" id="h5-0-246" class="d">-                    .map(|(e, o)| e.transform(before, after).map(|e| (e, o)))
</a><a href="#h5-0-247" id="h5-0-247" class="d">-                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h5-0-248" id="h5-0-248" class="d">-            },
</a><a href="#h5-0-249" id="h5-0-249" class="d">-            Self::NestedLoopJoin { left, left_size, right, predicate: Some(predicate), outer } =&gt; {
</a><a href="#h5-0-250" id="h5-0-250" class="d">-                Self::NestedLoopJoin {
</a><a href="#h5-0-251" id="h5-0-251" class="d">-                    left,
</a><a href="#h5-0-252" id="h5-0-252" class="d">-                    left_size,
</a><a href="#h5-0-253" id="h5-0-253" class="d">-                    right,
</a><a href="#h5-0-254" id="h5-0-254" class="d">-                    predicate: Some(predicate.transform(before, after)?),
</a><a href="#h5-0-255" id="h5-0-255" class="d">-                    outer,
</a><a href="#h5-0-256" id="h5-0-256" class="d">-                }
</a><a href="#h5-0-257" id="h5-0-257" class="d">-            }
</a><a href="#h5-0-258" id="h5-0-258" class="d">-            Self::Projection { source, expressions } =&gt; Self::Projection {
</a><a href="#h5-0-259" id="h5-0-259" class="d">-                source,
</a><a href="#h5-0-260" id="h5-0-260" class="d">-                expressions: expressions
</a><a href="#h5-0-261" id="h5-0-261" class="d">-                    .into_iter()
</a><a href="#h5-0-262" id="h5-0-262" class="d">-                    .map(|(e, l)| Ok((e.transform(before, after)?, l)))
</a><a href="#h5-0-263" id="h5-0-263" class="d">-                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h5-0-264" id="h5-0-264" class="d">-            },
</a><a href="#h5-0-265" id="h5-0-265" class="d">-            Self::Scan { table, alias, filter: Some(filter) } =&gt; {
</a><a href="#h5-0-266" id="h5-0-266" class="d">-                Self::Scan { table, alias, filter: Some(filter.transform(before, after)?) }
</a><a href="#h5-0-267" id="h5-0-267" class="d">-            }
</a><a href="#h5-0-268" id="h5-0-268" class="d">-        })
</a><a href="#h5-0-269" id="h5-0-269" class="d">-    }
</a><a href="#h5-0-270" id="h5-0-270" class="d">-
</a><a href="#h5-0-271" id="h5-0-271" class="d">-    // Displays the node, where prefix gives the node prefix.
</a><a href="#h5-0-272" id="h5-0-272" class="d">-    pub fn format(&amp;self, mut indent: String, root: bool, last: bool) -&gt; String {
</a><a href="#h5-0-273" id="h5-0-273" class="d">-        // TODO: indent should be &amp;str or int.
</a><a href="#h5-0-274" id="h5-0-274" class="d">-        let mut s = indent.clone();
</a><a href="#h5-0-275" id="h5-0-275" class="d">-        if !last {
</a><a href="#h5-0-276" id="h5-0-276" class="d">-            s += &quot;├─ &quot;;
</a><a href="#h5-0-277" id="h5-0-277" class="d">-            indent += &quot;│  &quot;
</a><a href="#h5-0-278" id="h5-0-278" class="d">-        } else if !root {
</a><a href="#h5-0-279" id="h5-0-279" class="d">-            s += &quot;└─ &quot;;
</a><a href="#h5-0-280" id="h5-0-280" class="d">-            indent += &quot;   &quot;;
</a><a href="#h5-0-281" id="h5-0-281" class="d">-        }
</a><a href="#h5-0-282" id="h5-0-282" class="d">-        match self {
</a><a href="#h5-0-283" id="h5-0-283" class="d">-            Self::Aggregation { source, aggregates } =&gt; {
</a><a href="#h5-0-284" id="h5-0-284" class="d">-                s += &amp;format!(
</a><a href="#h5-0-285" id="h5-0-285" class="d">-                    &quot;Aggregation: {}\n&quot;,
</a><a href="#h5-0-286" id="h5-0-286" class="d">-                    aggregates.iter().map(|a| a.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h5-0-287" id="h5-0-287" class="d">-                );
</a><a href="#h5-0-288" id="h5-0-288" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h5-0-289" id="h5-0-289" class="d">-            }
</a><a href="#h5-0-290" id="h5-0-290" class="d">-            Self::Filter { source, predicate } =&gt; {
</a><a href="#h5-0-291" id="h5-0-291" class="d">-                s += &amp;format!(&quot;Filter: {}\n&quot;, predicate);
</a><a href="#h5-0-292" id="h5-0-292" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h5-0-293" id="h5-0-293" class="d">-            }
</a><a href="#h5-0-294" id="h5-0-294" class="d">-            Self::HashJoin { left, left_field, right, right_field, outer } =&gt; {
</a><a href="#h5-0-295" id="h5-0-295" class="d">-                s += &amp;format!(
</a><a href="#h5-0-296" id="h5-0-296" class="d">-                    &quot;HashJoin: {} on {} = {}\n&quot;,
</a><a href="#h5-0-297" id="h5-0-297" class="d">-                    if *outer { &quot;outer&quot; } else { &quot;inner&quot; },
</a><a href="#h5-0-298" id="h5-0-298" class="d">-                    match left_field {
</a><a href="#h5-0-299" id="h5-0-299" class="d">-                        (_, Some((Some(t), n))) =&gt; format!(&quot;{}.{}&quot;, t, n),
</a><a href="#h5-0-300" id="h5-0-300" class="d">-                        (_, Some((None, n))) =&gt; n.clone(),
</a><a href="#h5-0-301" id="h5-0-301" class="d">-                        (i, None) =&gt; format!(&quot;left #{}&quot;, i),
</a><a href="#h5-0-302" id="h5-0-302" class="d">-                    },
</a><a href="#h5-0-303" id="h5-0-303" class="d">-                    match right_field {
</a><a href="#h5-0-304" id="h5-0-304" class="d">-                        (_, Some((Some(t), n))) =&gt; format!(&quot;{}.{}&quot;, t, n),
</a><a href="#h5-0-305" id="h5-0-305" class="d">-                        (_, Some((None, n))) =&gt; n.clone(),
</a><a href="#h5-0-306" id="h5-0-306" class="d">-                        (i, None) =&gt; format!(&quot;right #{}&quot;, i),
</a><a href="#h5-0-307" id="h5-0-307" class="d">-                    },
</a><a href="#h5-0-308" id="h5-0-308" class="d">-                );
</a><a href="#h5-0-309" id="h5-0-309" class="d">-                s += &amp;left.format(indent.clone(), false, false);
</a><a href="#h5-0-310" id="h5-0-310" class="d">-                s += &amp;right.format(indent, false, true);
</a><a href="#h5-0-311" id="h5-0-311" class="d">-            }
</a><a href="#h5-0-312" id="h5-0-312" class="d">-            Self::IndexLookup { table, column, alias, values } =&gt; {
</a><a href="#h5-0-313" id="h5-0-313" class="d">-                s += &amp;format!(&quot;IndexLookup: {}&quot;, table.name);
</a><a href="#h5-0-314" id="h5-0-314" class="d">-                if let Some(alias) = alias {
</a><a href="#h5-0-315" id="h5-0-315" class="d">-                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h5-0-316" id="h5-0-316" class="d">-                }
</a><a href="#h5-0-317" id="h5-0-317" class="d">-                s += &amp;format!(&quot; column {}&quot;, column);
</a><a href="#h5-0-318" id="h5-0-318" class="d">-                if !values.is_empty() &amp;&amp; values.len() &lt; 10 {
</a><a href="#h5-0-319" id="h5-0-319" class="d">-                    s += &amp;format!(
</a><a href="#h5-0-320" id="h5-0-320" class="d">-                        &quot; ({})&quot;,
</a><a href="#h5-0-321" id="h5-0-321" class="d">-                        values.iter().map(|k| k.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h5-0-322" id="h5-0-322" class="d">-                    );
</a><a href="#h5-0-323" id="h5-0-323" class="d">-                } else {
</a><a href="#h5-0-324" id="h5-0-324" class="d">-                    s += &amp;format!(&quot; ({} values)&quot;, values.len());
</a><a href="#h5-0-325" id="h5-0-325" class="d">-                }
</a><a href="#h5-0-326" id="h5-0-326" class="d">-                s += &quot;\n&quot;;
</a><a href="#h5-0-327" id="h5-0-327" class="d">-            }
</a><a href="#h5-0-328" id="h5-0-328" class="d">-            Self::KeyLookup { table, alias, keys } =&gt; {
</a><a href="#h5-0-329" id="h5-0-329" class="d">-                s += &amp;format!(&quot;KeyLookup: {}&quot;, table.name);
</a><a href="#h5-0-330" id="h5-0-330" class="d">-                if let Some(alias) = alias {
</a><a href="#h5-0-331" id="h5-0-331" class="d">-                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h5-0-332" id="h5-0-332" class="d">-                }
</a><a href="#h5-0-333" id="h5-0-333" class="d">-                if !keys.is_empty() &amp;&amp; keys.len() &lt; 10 {
</a><a href="#h5-0-334" id="h5-0-334" class="d">-                    s += &amp;format!(
</a><a href="#h5-0-335" id="h5-0-335" class="d">-                        &quot; ({})&quot;,
</a><a href="#h5-0-336" id="h5-0-336" class="d">-                        keys.iter().map(|k| k.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h5-0-337" id="h5-0-337" class="d">-                    );
</a><a href="#h5-0-338" id="h5-0-338" class="d">-                } else {
</a><a href="#h5-0-339" id="h5-0-339" class="d">-                    s += &amp;format!(&quot; ({} keys)&quot;, keys.len());
</a><a href="#h5-0-340" id="h5-0-340" class="d">-                }
</a><a href="#h5-0-341" id="h5-0-341" class="d">-                s += &quot;\n&quot;;
</a><a href="#h5-0-342" id="h5-0-342" class="d">-            }
</a><a href="#h5-0-343" id="h5-0-343" class="d">-            Self::Limit { source, limit } =&gt; {
</a><a href="#h5-0-344" id="h5-0-344" class="d">-                s += &amp;format!(&quot;Limit: {}\n&quot;, limit);
</a><a href="#h5-0-345" id="h5-0-345" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h5-0-346" id="h5-0-346" class="d">-            }
</a><a href="#h5-0-347" id="h5-0-347" class="d">-            Self::NestedLoopJoin { left, left_size: _, right, predicate, outer } =&gt; {
</a><a href="#h5-0-348" id="h5-0-348" class="d">-                s += &amp;format!(&quot;NestedLoopJoin: {}&quot;, if *outer { &quot;outer&quot; } else { &quot;inner&quot; });
</a><a href="#h5-0-349" id="h5-0-349" class="d">-                if let Some(expr) = predicate {
</a><a href="#h5-0-350" id="h5-0-350" class="d">-                    s += &amp;format!(&quot; on {}&quot;, expr);
</a><a href="#h5-0-351" id="h5-0-351" class="d">-                }
</a><a href="#h5-0-352" id="h5-0-352" class="d">-                s += &quot;\n&quot;;
</a><a href="#h5-0-353" id="h5-0-353" class="d">-                s += &amp;left.format(indent.clone(), false, false);
</a><a href="#h5-0-354" id="h5-0-354" class="d">-                s += &amp;right.format(indent, false, true);
</a><a href="#h5-0-355" id="h5-0-355" class="d">-            }
</a><a href="#h5-0-356" id="h5-0-356" class="d">-            Self::Nothing {} =&gt; {
</a><a href="#h5-0-357" id="h5-0-357" class="d">-                s += &quot;Nothing\n&quot;;
</a><a href="#h5-0-358" id="h5-0-358" class="d">-            }
</a><a href="#h5-0-359" id="h5-0-359" class="d">-            Self::Offset { source, offset } =&gt; {
</a><a href="#h5-0-360" id="h5-0-360" class="d">-                s += &amp;format!(&quot;Offset: {}\n&quot;, offset);
</a><a href="#h5-0-361" id="h5-0-361" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h5-0-362" id="h5-0-362" class="d">-            }
</a><a href="#h5-0-363" id="h5-0-363" class="d">-            Self::Order { source, orders } =&gt; {
</a><a href="#h5-0-364" id="h5-0-364" class="d">-                s += &amp;format!(
</a><a href="#h5-0-365" id="h5-0-365" class="d">-                    &quot;Order: {}\n&quot;,
</a><a href="#h5-0-366" id="h5-0-366" class="d">-                    orders
</a><a href="#h5-0-367" id="h5-0-367" class="d">-                        .iter()
</a><a href="#h5-0-368" id="h5-0-368" class="d">-                        .map(|(expr, dir)| format!(&quot;{} {}&quot;, expr, dir))
</a><a href="#h5-0-369" id="h5-0-369" class="d">-                        .collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h5-0-370" id="h5-0-370" class="d">-                        .join(&quot;, &quot;)
</a><a href="#h5-0-371" id="h5-0-371" class="d">-                );
</a><a href="#h5-0-372" id="h5-0-372" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h5-0-373" id="h5-0-373" class="d">-            }
</a><a href="#h5-0-374" id="h5-0-374" class="d">-            Self::Projection { source, expressions } =&gt; {
</a><a href="#h5-0-375" id="h5-0-375" class="d">-                s += &amp;format!(
</a><a href="#h5-0-376" id="h5-0-376" class="d">-                    &quot;Projection: {}\n&quot;,
</a><a href="#h5-0-377" id="h5-0-377" class="d">-                    expressions
</a><a href="#h5-0-378" id="h5-0-378" class="d">-                        .iter()
</a><a href="#h5-0-379" id="h5-0-379" class="d">-                        .map(|(expr, _)| expr.to_string())
</a><a href="#h5-0-380" id="h5-0-380" class="d">-                        .collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h5-0-381" id="h5-0-381" class="d">-                        .join(&quot;, &quot;)
</a><a href="#h5-0-382" id="h5-0-382" class="d">-                );
</a><a href="#h5-0-383" id="h5-0-383" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h5-0-384" id="h5-0-384" class="d">-            }
</a><a href="#h5-0-385" id="h5-0-385" class="d">-            Self::Scan { table, alias, filter } =&gt; {
</a><a href="#h5-0-386" id="h5-0-386" class="d">-                s += &amp;format!(&quot;Scan: {}&quot;, table.name);
</a><a href="#h5-0-387" id="h5-0-387" class="d">-                if let Some(alias) = alias {
</a><a href="#h5-0-388" id="h5-0-388" class="d">-                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h5-0-389" id="h5-0-389" class="d">-                }
</a><a href="#h5-0-390" id="h5-0-390" class="d">-                if let Some(expr) = filter {
</a><a href="#h5-0-391" id="h5-0-391" class="d">-                    s += &amp;format!(&quot; ({})&quot;, expr);
</a><a href="#h5-0-392" id="h5-0-392" class="d">-                }
</a><a href="#h5-0-393" id="h5-0-393" class="d">-                s += &quot;\n&quot;;
</a><a href="#h5-0-394" id="h5-0-394" class="d">-            }
</a><a href="#h5-0-395" id="h5-0-395" class="d">-        };
</a><a href="#h5-0-396" id="h5-0-396" class="d">-        if root {
</a><a href="#h5-0-397" id="h5-0-397" class="d">-            s = s.trim_end().to_string()
</a><a href="#h5-0-398" id="h5-0-398" class="d">-        }
</a><a href="#h5-0-399" id="h5-0-399" class="d">-        s
</a><a href="#h5-0-400" id="h5-0-400" class="d">-    }
</a><a href="#h5-0-401" id="h5-0-401" class="d">-}
</a><a href="#h5-0-402" id="h5-0-402" class="d">-
</a><a href="#h5-0-403" id="h5-0-403" class="d">-impl std::fmt::Display for Node {
</a><a href="#h5-0-404" id="h5-0-404" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h5-0-405" id="h5-0-405" class="d">-        write!(f, &quot;{}&quot;, self.format(&quot;&quot;.to_string(), true, true))
</a><a href="#h5-0-406" id="h5-0-406" class="d">-    }
</a><a href="#h5-0-407" id="h5-0-407" class="d">-}
</a><a href="#h5-0-408" id="h5-0-408" class="d">-
</a><a href="#h5-0-409" id="h5-0-409" class="d">-/// An aggregate operation
</a><a href="#h5-0-410" id="h5-0-410" class="d">-#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h5-0-411" id="h5-0-411" class="d">-pub enum Aggregate {
</a><a href="#h5-0-412" id="h5-0-412" class="d">-    Average,
</a><a href="#h5-0-413" id="h5-0-413" class="d">-    Count,
</a><a href="#h5-0-414" id="h5-0-414" class="d">-    Max,
</a><a href="#h5-0-415" id="h5-0-415" class="d">-    Min,
</a><a href="#h5-0-416" id="h5-0-416" class="d">-    Sum,
</a><a href="#h5-0-417" id="h5-0-417" class="d">-}
</a><a href="#h5-0-418" id="h5-0-418" class="d">-
</a><a href="#h5-0-419" id="h5-0-419" class="d">-impl std::fmt::Display for Aggregate {
</a><a href="#h5-0-420" id="h5-0-420" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h5-0-421" id="h5-0-421" class="d">-        match self {
</a><a href="#h5-0-422" id="h5-0-422" class="d">-            Self::Average =&gt; write!(f, &quot;average&quot;),
</a><a href="#h5-0-423" id="h5-0-423" class="d">-            Self::Count =&gt; write!(f, &quot;count&quot;),
</a><a href="#h5-0-424" id="h5-0-424" class="d">-            Self::Max =&gt; write!(f, &quot;maximum&quot;),
</a><a href="#h5-0-425" id="h5-0-425" class="d">-            Self::Min =&gt; write!(f, &quot;minimum&quot;),
</a><a href="#h5-0-426" id="h5-0-426" class="d">-            Self::Sum =&gt; write!(f, &quot;sum&quot;),
</a><a href="#h5-0-427" id="h5-0-427" class="d">-        }
</a><a href="#h5-0-428" id="h5-0-428" class="d">-    }
</a><a href="#h5-0-429" id="h5-0-429" class="d">-}
</a><a href="#h5-0-430" id="h5-0-430" class="d">-
</a><a href="#h5-0-431" id="h5-0-431" class="d">-/// A sort order direction.
</a><a href="#h5-0-432" id="h5-0-432" class="d">-#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h5-0-433" id="h5-0-433" class="d">-pub enum Direction {
</a><a href="#h5-0-434" id="h5-0-434" class="d">-    Ascending,
</a><a href="#h5-0-435" id="h5-0-435" class="d">-    Descending,
</a><a href="#h5-0-436" id="h5-0-436" class="d">-}
</a><a href="#h5-0-437" id="h5-0-437" class="d">-
</a><a href="#h5-0-438" id="h5-0-438" class="d">-impl std::fmt::Display for Direction {
</a><a href="#h5-0-439" id="h5-0-439" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h5-0-440" id="h5-0-440" class="d">-        match self {
</a><a href="#h5-0-441" id="h5-0-441" class="d">-            Self::Ascending =&gt; write!(f, &quot;asc&quot;),
</a><a href="#h5-0-442" id="h5-0-442" class="d">-            Self::Descending =&gt; write!(f, &quot;desc&quot;),
</a><a href="#h5-0-443" id="h5-0-443" class="d">-        }
</a><a href="#h5-0-444" id="h5-0-444" class="d">-    }
</a><a href="#h5-0-445" id="h5-0-445" class="d">-}
</a><b>diff --git a/<a id="h6" href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a> b/<a href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,812 +0,0 @@
</a><a href="#h6-0-0" id="h6-0-0" class="d">-use super::super::parser::ast;
</a><a href="#h6-0-1" id="h6-0-1" class="d">-use super::{plan::Node, plan::Plan, Aggregate, Direction};
</a><a href="#h6-0-2" id="h6-0-2" class="d">-use crate::errinput;
</a><a href="#h6-0-3" id="h6-0-3" class="d">-use crate::error::Result;
</a><a href="#h6-0-4" id="h6-0-4" class="d">-use crate::sql::engine::Catalog;
</a><a href="#h6-0-5" id="h6-0-5" class="d">-use crate::sql::types::{Column, Expression, Table, Value};
</a><a href="#h6-0-6" id="h6-0-6" class="d">-
</a><a href="#h6-0-7" id="h6-0-7" class="d">-use std::collections::{HashMap, HashSet};
</a><a href="#h6-0-8" id="h6-0-8" class="d">-use std::mem::replace;
</a><a href="#h6-0-9" id="h6-0-9" class="d">-
</a><a href="#h6-0-10" id="h6-0-10" class="d">-/// A query plan builder.
</a><a href="#h6-0-11" id="h6-0-11" class="d">-pub struct Planner&lt;&#39;a, C: Catalog&gt; {
</a><a href="#h6-0-12" id="h6-0-12" class="d">-    catalog: &amp;&#39;a C,
</a><a href="#h6-0-13" id="h6-0-13" class="d">-}
</a><a href="#h6-0-14" id="h6-0-14" class="d">-
</a><a href="#h6-0-15" id="h6-0-15" class="d">-impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a><a href="#h6-0-16" id="h6-0-16" class="d">-    /// Creates a new planner.
</a><a href="#h6-0-17" id="h6-0-17" class="d">-    pub fn new(catalog: &amp;&#39;a C) -&gt; Self {
</a><a href="#h6-0-18" id="h6-0-18" class="d">-        Self { catalog }
</a><a href="#h6-0-19" id="h6-0-19" class="d">-    }
</a><a href="#h6-0-20" id="h6-0-20" class="d">-
</a><a href="#h6-0-21" id="h6-0-21" class="d">-    /// Builds a plan for an AST statement.
</a><a href="#h6-0-22" id="h6-0-22" class="d">-    pub fn build(&amp;mut self, statement: ast::Statement) -&gt; Result&lt;Plan&gt; {
</a><a href="#h6-0-23" id="h6-0-23" class="d">-        self.build_statement(statement)
</a><a href="#h6-0-24" id="h6-0-24" class="d">-    }
</a><a href="#h6-0-25" id="h6-0-25" class="d">-
</a><a href="#h6-0-26" id="h6-0-26" class="d">-    /// Builds a plan for a statement.
</a><a href="#h6-0-27" id="h6-0-27" class="d">-    fn build_statement(&amp;self, statement: ast::Statement) -&gt; Result&lt;Plan&gt; {
</a><a href="#h6-0-28" id="h6-0-28" class="d">-        Ok(match statement {
</a><a href="#h6-0-29" id="h6-0-29" class="d">-            // Transaction control and explain statements should have been handled by session.
</a><a href="#h6-0-30" id="h6-0-30" class="d">-            ast::Statement::Begin { .. } | ast::Statement::Commit | ast::Statement::Rollback =&gt; {
</a><a href="#h6-0-31" id="h6-0-31" class="d">-                panic!(&quot;unexpected transaction statement {statement:?}&quot;)
</a><a href="#h6-0-32" id="h6-0-32" class="d">-            }
</a><a href="#h6-0-33" id="h6-0-33" class="d">-
</a><a href="#h6-0-34" id="h6-0-34" class="d">-            ast::Statement::Explain(_) =&gt; panic!(&quot;unexpected explain statement&quot;),
</a><a href="#h6-0-35" id="h6-0-35" class="d">-
</a><a href="#h6-0-36" id="h6-0-36" class="d">-            // DDL statements (schema changes).
</a><a href="#h6-0-37" id="h6-0-37" class="d">-            ast::Statement::CreateTable { name, columns } =&gt; {
</a><a href="#h6-0-38" id="h6-0-38" class="d">-                let Some(primary_key) = columns.iter().position(|c| c.primary_key) else {
</a><a href="#h6-0-39" id="h6-0-39" class="d">-                    return errinput!(&quot;no primary key for table {name}&quot;);
</a><a href="#h6-0-40" id="h6-0-40" class="d">-                };
</a><a href="#h6-0-41" id="h6-0-41" class="d">-                if columns.iter().filter(|c| c.primary_key).count() &gt; 1 {
</a><a href="#h6-0-42" id="h6-0-42" class="d">-                    return errinput!(&quot;multiple primary keys for table {name}&quot;);
</a><a href="#h6-0-43" id="h6-0-43" class="d">-                }
</a><a href="#h6-0-44" id="h6-0-44" class="d">-                let columns = columns
</a><a href="#h6-0-45" id="h6-0-45" class="d">-                    .into_iter()
</a><a href="#h6-0-46" id="h6-0-46" class="d">-                    .map(|c| {
</a><a href="#h6-0-47" id="h6-0-47" class="d">-                        let nullable = c.nullable.unwrap_or(!c.primary_key);
</a><a href="#h6-0-48" id="h6-0-48" class="d">-                        Ok(Column {
</a><a href="#h6-0-49" id="h6-0-49" class="d">-                            name: c.name,
</a><a href="#h6-0-50" id="h6-0-50" class="d">-                            datatype: c.datatype,
</a><a href="#h6-0-51" id="h6-0-51" class="d">-                            nullable,
</a><a href="#h6-0-52" id="h6-0-52" class="d">-                            default: match c.default {
</a><a href="#h6-0-53" id="h6-0-53" class="d">-                                Some(expr) =&gt; Some(self.evaluate_constant(expr)?),
</a><a href="#h6-0-54" id="h6-0-54" class="d">-                                None if nullable =&gt; Some(Value::Null),
</a><a href="#h6-0-55" id="h6-0-55" class="d">-                                None =&gt; None,
</a><a href="#h6-0-56" id="h6-0-56" class="d">-                            },
</a><a href="#h6-0-57" id="h6-0-57" class="d">-                            unique: c.unique || c.primary_key,
</a><a href="#h6-0-58" id="h6-0-58" class="d">-                            index: (c.index || c.unique || c.references.is_some())
</a><a href="#h6-0-59" id="h6-0-59" class="d">-                                &amp;&amp; !c.primary_key,
</a><a href="#h6-0-60" id="h6-0-60" class="d">-                            references: c.references,
</a><a href="#h6-0-61" id="h6-0-61" class="d">-                        })
</a><a href="#h6-0-62" id="h6-0-62" class="d">-                    })
</a><a href="#h6-0-63" id="h6-0-63" class="d">-                    .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h6-0-64" id="h6-0-64" class="d">-                Plan::CreateTable { schema: Table { name, primary_key, columns } }
</a><a href="#h6-0-65" id="h6-0-65" class="d">-            }
</a><a href="#h6-0-66" id="h6-0-66" class="d">-
</a><a href="#h6-0-67" id="h6-0-67" class="d">-            ast::Statement::DropTable { name, if_exists } =&gt; {
</a><a href="#h6-0-68" id="h6-0-68" class="d">-                Plan::DropTable { table: name, if_exists }
</a><a href="#h6-0-69" id="h6-0-69" class="d">-            }
</a><a href="#h6-0-70" id="h6-0-70" class="d">-
</a><a href="#h6-0-71" id="h6-0-71" class="d">-            // DML statements (mutations).
</a><a href="#h6-0-72" id="h6-0-72" class="d">-            ast::Statement::Delete { table, r#where } =&gt; {
</a><a href="#h6-0-73" id="h6-0-73" class="d">-                let table = self.catalog.must_get_table(&amp;table)?;
</a><a href="#h6-0-74" id="h6-0-74" class="d">-                let scope = &amp;mut Scope::from_table(table.clone())?;
</a><a href="#h6-0-75" id="h6-0-75" class="d">-                Plan::Delete {
</a><a href="#h6-0-76" id="h6-0-76" class="d">-                    table: table.name.clone(),
</a><a href="#h6-0-77" id="h6-0-77" class="d">-                    key_index: table.primary_key,
</a><a href="#h6-0-78" id="h6-0-78" class="d">-                    source: Node::Scan {
</a><a href="#h6-0-79" id="h6-0-79" class="d">-                        table,
</a><a href="#h6-0-80" id="h6-0-80" class="d">-                        alias: None,
</a><a href="#h6-0-81" id="h6-0-81" class="d">-                        filter: r#where.map(|e| self.build_expression(scope, e)).transpose()?,
</a><a href="#h6-0-82" id="h6-0-82" class="d">-                    },
</a><a href="#h6-0-83" id="h6-0-83" class="d">-                }
</a><a href="#h6-0-84" id="h6-0-84" class="d">-            }
</a><a href="#h6-0-85" id="h6-0-85" class="d">-
</a><a href="#h6-0-86" id="h6-0-86" class="d">-            ast::Statement::Insert { table, columns, values } =&gt; {
</a><a href="#h6-0-87" id="h6-0-87" class="d">-                let table = self.catalog.must_get_table(&amp;table)?;
</a><a href="#h6-0-88" id="h6-0-88" class="d">-                Plan::Insert {
</a><a href="#h6-0-89" id="h6-0-89" class="d">-                    table,
</a><a href="#h6-0-90" id="h6-0-90" class="d">-                    columns: columns.unwrap_or_default(),
</a><a href="#h6-0-91" id="h6-0-91" class="d">-                    expressions: values
</a><a href="#h6-0-92" id="h6-0-92" class="d">-                        .into_iter()
</a><a href="#h6-0-93" id="h6-0-93" class="d">-                        .map(|exprs| {
</a><a href="#h6-0-94" id="h6-0-94" class="d">-                            exprs
</a><a href="#h6-0-95" id="h6-0-95" class="d">-                                .into_iter()
</a><a href="#h6-0-96" id="h6-0-96" class="d">-                                .map(|expr| self.build_expression(&amp;mut Scope::constant(), expr))
</a><a href="#h6-0-97" id="h6-0-97" class="d">-                                .collect::&lt;Result&lt;_&gt;&gt;()
</a><a href="#h6-0-98" id="h6-0-98" class="d">-                        })
</a><a href="#h6-0-99" id="h6-0-99" class="d">-                        .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h6-0-100" id="h6-0-100" class="d">-                }
</a><a href="#h6-0-101" id="h6-0-101" class="d">-            }
</a><a href="#h6-0-102" id="h6-0-102" class="d">-
</a><a href="#h6-0-103" id="h6-0-103" class="d">-            ast::Statement::Update { table, set, r#where } =&gt; {
</a><a href="#h6-0-104" id="h6-0-104" class="d">-                let table = self.catalog.must_get_table(&amp;table)?;
</a><a href="#h6-0-105" id="h6-0-105" class="d">-                let scope = &amp;mut Scope::from_table(table.clone())?;
</a><a href="#h6-0-106" id="h6-0-106" class="d">-                Plan::Update {
</a><a href="#h6-0-107" id="h6-0-107" class="d">-                    table: table.name.clone(),
</a><a href="#h6-0-108" id="h6-0-108" class="d">-                    key_index: table.primary_key,
</a><a href="#h6-0-109" id="h6-0-109" class="d">-                    source: Node::Scan {
</a><a href="#h6-0-110" id="h6-0-110" class="d">-                        table,
</a><a href="#h6-0-111" id="h6-0-111" class="d">-                        alias: None,
</a><a href="#h6-0-112" id="h6-0-112" class="d">-                        filter: r#where.map(|e| self.build_expression(scope, e)).transpose()?,
</a><a href="#h6-0-113" id="h6-0-113" class="d">-                    },
</a><a href="#h6-0-114" id="h6-0-114" class="d">-                    expressions: set
</a><a href="#h6-0-115" id="h6-0-115" class="d">-                        .into_iter()
</a><a href="#h6-0-116" id="h6-0-116" class="d">-                        .map(|(c, e)| {
</a><a href="#h6-0-117" id="h6-0-117" class="d">-                            Ok((
</a><a href="#h6-0-118" id="h6-0-118" class="d">-                                scope.resolve(None, &amp;c)?,
</a><a href="#h6-0-119" id="h6-0-119" class="d">-                                Some(c),
</a><a href="#h6-0-120" id="h6-0-120" class="d">-                                self.build_expression(scope, e)?,
</a><a href="#h6-0-121" id="h6-0-121" class="d">-                            ))
</a><a href="#h6-0-122" id="h6-0-122" class="d">-                        })
</a><a href="#h6-0-123" id="h6-0-123" class="d">-                        .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h6-0-124" id="h6-0-124" class="d">-                }
</a><a href="#h6-0-125" id="h6-0-125" class="d">-            }
</a><a href="#h6-0-126" id="h6-0-126" class="d">-
</a><a href="#h6-0-127" id="h6-0-127" class="d">-            // Queries.
</a><a href="#h6-0-128" id="h6-0-128" class="d">-            ast::Statement::Select {
</a><a href="#h6-0-129" id="h6-0-129" class="d">-                mut select,
</a><a href="#h6-0-130" id="h6-0-130" class="d">-                from,
</a><a href="#h6-0-131" id="h6-0-131" class="d">-                r#where,
</a><a href="#h6-0-132" id="h6-0-132" class="d">-                group_by,
</a><a href="#h6-0-133" id="h6-0-133" class="d">-                mut having,
</a><a href="#h6-0-134" id="h6-0-134" class="d">-                mut order,
</a><a href="#h6-0-135" id="h6-0-135" class="d">-                offset,
</a><a href="#h6-0-136" id="h6-0-136" class="d">-                limit,
</a><a href="#h6-0-137" id="h6-0-137" class="d">-            } =&gt; {
</a><a href="#h6-0-138" id="h6-0-138" class="d">-                let scope = &amp;mut Scope::new();
</a><a href="#h6-0-139" id="h6-0-139" class="d">-
</a><a href="#h6-0-140" id="h6-0-140" class="d">-                // Build FROM clause.
</a><a href="#h6-0-141" id="h6-0-141" class="d">-                let mut node = if !from.is_empty() {
</a><a href="#h6-0-142" id="h6-0-142" class="d">-                    self.build_from_clause(scope, from)?
</a><a href="#h6-0-143" id="h6-0-143" class="d">-                } else if select.is_empty() {
</a><a href="#h6-0-144" id="h6-0-144" class="d">-                    return errinput!(&quot;can&#39;t select * without a table&quot;);
</a><a href="#h6-0-145" id="h6-0-145" class="d">-                } else {
</a><a href="#h6-0-146" id="h6-0-146" class="d">-                    Node::Nothing
</a><a href="#h6-0-147" id="h6-0-147" class="d">-                };
</a><a href="#h6-0-148" id="h6-0-148" class="d">-
</a><a href="#h6-0-149" id="h6-0-149" class="d">-                // Build WHERE clause.
</a><a href="#h6-0-150" id="h6-0-150" class="d">-                if let Some(expr) = r#where {
</a><a href="#h6-0-151" id="h6-0-151" class="d">-                    node = Node::Filter {
</a><a href="#h6-0-152" id="h6-0-152" class="d">-                        source: Box::new(node),
</a><a href="#h6-0-153" id="h6-0-153" class="d">-                        predicate: self.build_expression(scope, expr)?,
</a><a href="#h6-0-154" id="h6-0-154" class="d">-                    };
</a><a href="#h6-0-155" id="h6-0-155" class="d">-                };
</a><a href="#h6-0-156" id="h6-0-156" class="d">-
</a><a href="#h6-0-157" id="h6-0-157" class="d">-                // Build SELECT clause.
</a><a href="#h6-0-158" id="h6-0-158" class="d">-                let mut hidden = 0;
</a><a href="#h6-0-159" id="h6-0-159" class="d">-                if !select.is_empty() {
</a><a href="#h6-0-160" id="h6-0-160" class="d">-                    // Inject hidden SELECT columns for fields and aggregates used in ORDER BY and
</a><a href="#h6-0-161" id="h6-0-161" class="d">-                    // HAVING expressions but not present in existing SELECT output. These will be
</a><a href="#h6-0-162" id="h6-0-162" class="d">-                    // removed again by a later projection.
</a><a href="#h6-0-163" id="h6-0-163" class="d">-                    if let Some(ref mut expr) = having {
</a><a href="#h6-0-164" id="h6-0-164" class="d">-                        hidden += self.inject_hidden(expr, &amp;mut select)?;
</a><a href="#h6-0-165" id="h6-0-165" class="d">-                    }
</a><a href="#h6-0-166" id="h6-0-166" class="d">-                    for (expr, _) in order.iter_mut() {
</a><a href="#h6-0-167" id="h6-0-167" class="d">-                        hidden += self.inject_hidden(expr, &amp;mut select)?;
</a><a href="#h6-0-168" id="h6-0-168" class="d">-                    }
</a><a href="#h6-0-169" id="h6-0-169" class="d">-
</a><a href="#h6-0-170" id="h6-0-170" class="d">-                    // Extract any aggregate functions and GROUP BY expressions, replacing them with
</a><a href="#h6-0-171" id="h6-0-171" class="d">-                    // Column placeholders. Aggregations are handled by evaluating group expressions
</a><a href="#h6-0-172" id="h6-0-172" class="d">-                    // and aggregate function arguments in a pre-projection, passing the results
</a><a href="#h6-0-173" id="h6-0-173" class="d">-                    // to an aggregation node, and then evaluating the final SELECT expressions
</a><a href="#h6-0-174" id="h6-0-174" class="d">-                    // in the post-projection. For example:
</a><a href="#h6-0-175" id="h6-0-175" class="d">-                    //
</a><a href="#h6-0-176" id="h6-0-176" class="d">-                    // SELECT (MAX(rating * 100) - MIN(rating * 100)) / 100
</a><a href="#h6-0-177" id="h6-0-177" class="d">-                    // FROM movies
</a><a href="#h6-0-178" id="h6-0-178" class="d">-                    // GROUP BY released - 2000
</a><a href="#h6-0-179" id="h6-0-179" class="d">-                    //
</a><a href="#h6-0-180" id="h6-0-180" class="d">-                    // Results in the following nodes:
</a><a href="#h6-0-181" id="h6-0-181" class="d">-                    //
</a><a href="#h6-0-182" id="h6-0-182" class="d">-                    // - Projection: rating * 100, rating * 100, released - 2000
</a><a href="#h6-0-183" id="h6-0-183" class="d">-                    // - Aggregation: max(#0), min(#1) group by #2
</a><a href="#h6-0-184" id="h6-0-184" class="d">-                    // - Projection: (#0 - #1) / 100
</a><a href="#h6-0-185" id="h6-0-185" class="d">-                    let aggregates = self.extract_aggregates(&amp;mut select)?;
</a><a href="#h6-0-186" id="h6-0-186" class="d">-                    let groups = self.extract_groups(&amp;mut select, group_by, aggregates.len())?;
</a><a href="#h6-0-187" id="h6-0-187" class="d">-                    if !aggregates.is_empty() || !groups.is_empty() {
</a><a href="#h6-0-188" id="h6-0-188" class="d">-                        node = self.build_aggregation(scope, node, groups, aggregates)?;
</a><a href="#h6-0-189" id="h6-0-189" class="d">-                    }
</a><a href="#h6-0-190" id="h6-0-190" class="d">-
</a><a href="#h6-0-191" id="h6-0-191" class="d">-                    // Build the remaining non-aggregate projection.
</a><a href="#h6-0-192" id="h6-0-192" class="d">-                    let expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt; = select
</a><a href="#h6-0-193" id="h6-0-193" class="d">-                        .into_iter()
</a><a href="#h6-0-194" id="h6-0-194" class="d">-                        .map(|(e, l)| Ok((self.build_expression(scope, e)?, l)))
</a><a href="#h6-0-195" id="h6-0-195" class="d">-                        .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h6-0-196" id="h6-0-196" class="d">-                    scope.project(&amp;expressions)?;
</a><a href="#h6-0-197" id="h6-0-197" class="d">-                    node = Node::Projection { source: Box::new(node), expressions };
</a><a href="#h6-0-198" id="h6-0-198" class="d">-                };
</a><a href="#h6-0-199" id="h6-0-199" class="d">-
</a><a href="#h6-0-200" id="h6-0-200" class="d">-                // Build HAVING clause.
</a><a href="#h6-0-201" id="h6-0-201" class="d">-                if let Some(expr) = having {
</a><a href="#h6-0-202" id="h6-0-202" class="d">-                    node = Node::Filter {
</a><a href="#h6-0-203" id="h6-0-203" class="d">-                        source: Box::new(node),
</a><a href="#h6-0-204" id="h6-0-204" class="d">-                        predicate: self.build_expression(scope, expr)?,
</a><a href="#h6-0-205" id="h6-0-205" class="d">-                    };
</a><a href="#h6-0-206" id="h6-0-206" class="d">-                };
</a><a href="#h6-0-207" id="h6-0-207" class="d">-
</a><a href="#h6-0-208" id="h6-0-208" class="d">-                // Build ORDER clause.
</a><a href="#h6-0-209" id="h6-0-209" class="d">-                if !order.is_empty() {
</a><a href="#h6-0-210" id="h6-0-210" class="d">-                    node = Node::Order {
</a><a href="#h6-0-211" id="h6-0-211" class="d">-                        source: Box::new(node),
</a><a href="#h6-0-212" id="h6-0-212" class="d">-                        orders: order
</a><a href="#h6-0-213" id="h6-0-213" class="d">-                            .into_iter()
</a><a href="#h6-0-214" id="h6-0-214" class="d">-                            .map(|(e, o)| {
</a><a href="#h6-0-215" id="h6-0-215" class="d">-                                Ok((
</a><a href="#h6-0-216" id="h6-0-216" class="d">-                                    self.build_expression(scope, e)?,
</a><a href="#h6-0-217" id="h6-0-217" class="d">-                                    match o {
</a><a href="#h6-0-218" id="h6-0-218" class="d">-                                        ast::Order::Ascending =&gt; Direction::Ascending,
</a><a href="#h6-0-219" id="h6-0-219" class="d">-                                        ast::Order::Descending =&gt; Direction::Descending,
</a><a href="#h6-0-220" id="h6-0-220" class="d">-                                    },
</a><a href="#h6-0-221" id="h6-0-221" class="d">-                                ))
</a><a href="#h6-0-222" id="h6-0-222" class="d">-                            })
</a><a href="#h6-0-223" id="h6-0-223" class="d">-                            .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h6-0-224" id="h6-0-224" class="d">-                    };
</a><a href="#h6-0-225" id="h6-0-225" class="d">-                }
</a><a href="#h6-0-226" id="h6-0-226" class="d">-
</a><a href="#h6-0-227" id="h6-0-227" class="d">-                // Build OFFSET clause.
</a><a href="#h6-0-228" id="h6-0-228" class="d">-                if let Some(expr) = offset {
</a><a href="#h6-0-229" id="h6-0-229" class="d">-                    node = Node::Offset {
</a><a href="#h6-0-230" id="h6-0-230" class="d">-                        source: Box::new(node),
</a><a href="#h6-0-231" id="h6-0-231" class="d">-                        offset: match self.evaluate_constant(expr)? {
</a><a href="#h6-0-232" id="h6-0-232" class="d">-                            Value::Integer(i) if i &gt;= 0 =&gt; Ok(i as u64),
</a><a href="#h6-0-233" id="h6-0-233" class="d">-                            v =&gt; errinput!(&quot;invalid offset {v}&quot;),
</a><a href="#h6-0-234" id="h6-0-234" class="d">-                        }?,
</a><a href="#h6-0-235" id="h6-0-235" class="d">-                    }
</a><a href="#h6-0-236" id="h6-0-236" class="d">-                }
</a><a href="#h6-0-237" id="h6-0-237" class="d">-
</a><a href="#h6-0-238" id="h6-0-238" class="d">-                // Build LIMIT clause.
</a><a href="#h6-0-239" id="h6-0-239" class="d">-                if let Some(expr) = limit {
</a><a href="#h6-0-240" id="h6-0-240" class="d">-                    node = Node::Limit {
</a><a href="#h6-0-241" id="h6-0-241" class="d">-                        source: Box::new(node),
</a><a href="#h6-0-242" id="h6-0-242" class="d">-                        limit: match self.evaluate_constant(expr)? {
</a><a href="#h6-0-243" id="h6-0-243" class="d">-                            Value::Integer(i) if i &gt;= 0 =&gt; Ok(i as u64),
</a><a href="#h6-0-244" id="h6-0-244" class="d">-                            v =&gt; errinput!(&quot;invalid limit {v}&quot;),
</a><a href="#h6-0-245" id="h6-0-245" class="d">-                        }?,
</a><a href="#h6-0-246" id="h6-0-246" class="d">-                    }
</a><a href="#h6-0-247" id="h6-0-247" class="d">-                }
</a><a href="#h6-0-248" id="h6-0-248" class="d">-
</a><a href="#h6-0-249" id="h6-0-249" class="d">-                // Remove any hidden columns.
</a><a href="#h6-0-250" id="h6-0-250" class="d">-                if hidden &gt; 0 {
</a><a href="#h6-0-251" id="h6-0-251" class="d">-                    node = Node::Projection {
</a><a href="#h6-0-252" id="h6-0-252" class="d">-                        source: Box::new(node),
</a><a href="#h6-0-253" id="h6-0-253" class="d">-                        expressions: (0..(scope.len() - hidden))
</a><a href="#h6-0-254" id="h6-0-254" class="d">-                            .map(|i| (Expression::Field(i, None), None))
</a><a href="#h6-0-255" id="h6-0-255" class="d">-                            .collect(),
</a><a href="#h6-0-256" id="h6-0-256" class="d">-                    }
</a><a href="#h6-0-257" id="h6-0-257" class="d">-                }
</a><a href="#h6-0-258" id="h6-0-258" class="d">-
</a><a href="#h6-0-259" id="h6-0-259" class="d">-                Plan::Select(node)
</a><a href="#h6-0-260" id="h6-0-260" class="d">-            }
</a><a href="#h6-0-261" id="h6-0-261" class="d">-        })
</a><a href="#h6-0-262" id="h6-0-262" class="d">-    }
</a><a href="#h6-0-263" id="h6-0-263" class="d">-
</a><a href="#h6-0-264" id="h6-0-264" class="d">-    /// Builds a FROM clause consisting of several items. Each item is either a single table or a
</a><a href="#h6-0-265" id="h6-0-265" class="d">-    /// join of an arbitrary number of tables. All of the items are joined, since e.g. &#39;SELECT * FROM
</a><a href="#h6-0-266" id="h6-0-266" class="d">-    /// a, b&#39; is an implicit join of a and b.
</a><a href="#h6-0-267" id="h6-0-267" class="d">-    fn build_from_clause(&amp;self, scope: &amp;mut Scope, from: Vec&lt;ast::FromItem&gt;) -&gt; Result&lt;Node&gt; {
</a><a href="#h6-0-268" id="h6-0-268" class="d">-        let base_scope = scope.clone();
</a><a href="#h6-0-269" id="h6-0-269" class="d">-        let mut items = from.into_iter();
</a><a href="#h6-0-270" id="h6-0-270" class="d">-        let mut node = match items.next() {
</a><a href="#h6-0-271" id="h6-0-271" class="d">-            Some(item) =&gt; self.build_from_item(scope, item)?,
</a><a href="#h6-0-272" id="h6-0-272" class="d">-            None =&gt; return errinput!(&quot;no from items given&quot;),
</a><a href="#h6-0-273" id="h6-0-273" class="d">-        };
</a><a href="#h6-0-274" id="h6-0-274" class="d">-        for item in items {
</a><a href="#h6-0-275" id="h6-0-275" class="d">-            let mut right_scope = base_scope.clone();
</a><a href="#h6-0-276" id="h6-0-276" class="d">-            let right = self.build_from_item(&amp;mut right_scope, item)?;
</a><a href="#h6-0-277" id="h6-0-277" class="d">-            node = Node::NestedLoopJoin {
</a><a href="#h6-0-278" id="h6-0-278" class="d">-                left: Box::new(node),
</a><a href="#h6-0-279" id="h6-0-279" class="d">-                left_size: scope.len(),
</a><a href="#h6-0-280" id="h6-0-280" class="d">-                right: Box::new(right),
</a><a href="#h6-0-281" id="h6-0-281" class="d">-                predicate: None,
</a><a href="#h6-0-282" id="h6-0-282" class="d">-                outer: false,
</a><a href="#h6-0-283" id="h6-0-283" class="d">-            };
</a><a href="#h6-0-284" id="h6-0-284" class="d">-            scope.merge(right_scope)?;
</a><a href="#h6-0-285" id="h6-0-285" class="d">-        }
</a><a href="#h6-0-286" id="h6-0-286" class="d">-        Ok(node)
</a><a href="#h6-0-287" id="h6-0-287" class="d">-    }
</a><a href="#h6-0-288" id="h6-0-288" class="d">-
</a><a href="#h6-0-289" id="h6-0-289" class="d">-    /// Builds FROM items, which can either be a single table or a chained join of multiple tables,
</a><a href="#h6-0-290" id="h6-0-290" class="d">-    /// e.g. &#39;SELECT * FROM a LEFT JOIN b ON b.a_id = a.id&#39;. Any tables will be stored in
</a><a href="#h6-0-291" id="h6-0-291" class="d">-    /// self.tables keyed by their query name (i.e. alias if given, otherwise name). The table can
</a><a href="#h6-0-292" id="h6-0-292" class="d">-    /// only be referenced by the query name (so if alias is given, cannot reference by name).
</a><a href="#h6-0-293" id="h6-0-293" class="d">-    fn build_from_item(&amp;self, scope: &amp;mut Scope, item: ast::FromItem) -&gt; Result&lt;Node&gt; {
</a><a href="#h6-0-294" id="h6-0-294" class="d">-        Ok(match item {
</a><a href="#h6-0-295" id="h6-0-295" class="d">-            ast::FromItem::Table { name, alias } =&gt; {
</a><a href="#h6-0-296" id="h6-0-296" class="d">-                let table = self.catalog.must_get_table(&amp;name)?;
</a><a href="#h6-0-297" id="h6-0-297" class="d">-                scope.add_table(alias.clone().unwrap_or_else(|| name.clone()), table.clone())?;
</a><a href="#h6-0-298" id="h6-0-298" class="d">-                Node::Scan { table, alias, filter: None }
</a><a href="#h6-0-299" id="h6-0-299" class="d">-            }
</a><a href="#h6-0-300" id="h6-0-300" class="d">-
</a><a href="#h6-0-301" id="h6-0-301" class="d">-            ast::FromItem::Join { left, right, r#type, predicate } =&gt; {
</a><a href="#h6-0-302" id="h6-0-302" class="d">-                // Right outer joins are built as a left outer join with an additional projection
</a><a href="#h6-0-303" id="h6-0-303" class="d">-                // to swap the resulting columns.
</a><a href="#h6-0-304" id="h6-0-304" class="d">-                let (left, right) = match r#type {
</a><a href="#h6-0-305" id="h6-0-305" class="d">-                    ast::JoinType::Right =&gt; (right, left),
</a><a href="#h6-0-306" id="h6-0-306" class="d">-                    _ =&gt; (left, right),
</a><a href="#h6-0-307" id="h6-0-307" class="d">-                };
</a><a href="#h6-0-308" id="h6-0-308" class="d">-                let left = Box::new(self.build_from_item(scope, *left)?);
</a><a href="#h6-0-309" id="h6-0-309" class="d">-                let left_size = scope.len();
</a><a href="#h6-0-310" id="h6-0-310" class="d">-                let right = Box::new(self.build_from_item(scope, *right)?);
</a><a href="#h6-0-311" id="h6-0-311" class="d">-                let predicate = predicate.map(|e| self.build_expression(scope, e)).transpose()?;
</a><a href="#h6-0-312" id="h6-0-312" class="d">-                let outer = match r#type {
</a><a href="#h6-0-313" id="h6-0-313" class="d">-                    ast::JoinType::Cross | ast::JoinType::Inner =&gt; false,
</a><a href="#h6-0-314" id="h6-0-314" class="d">-                    ast::JoinType::Left | ast::JoinType::Right =&gt; true,
</a><a href="#h6-0-315" id="h6-0-315" class="d">-                };
</a><a href="#h6-0-316" id="h6-0-316" class="d">-                let mut node = Node::NestedLoopJoin { left, left_size, right, predicate, outer };
</a><a href="#h6-0-317" id="h6-0-317" class="d">-                if matches!(r#type, ast::JoinType::Right) {
</a><a href="#h6-0-318" id="h6-0-318" class="d">-                    let expressions = (left_size..scope.len())
</a><a href="#h6-0-319" id="h6-0-319" class="d">-                        .chain(0..left_size)
</a><a href="#h6-0-320" id="h6-0-320" class="d">-                        .map(|i| Ok((Expression::Field(i, scope.get_label(i)?), None)))
</a><a href="#h6-0-321" id="h6-0-321" class="d">-                        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h6-0-322" id="h6-0-322" class="d">-                    scope.project(&amp;expressions)?;
</a><a href="#h6-0-323" id="h6-0-323" class="d">-                    node = Node::Projection { source: Box::new(node), expressions }
</a><a href="#h6-0-324" id="h6-0-324" class="d">-                }
</a><a href="#h6-0-325" id="h6-0-325" class="d">-                node
</a><a href="#h6-0-326" id="h6-0-326" class="d">-            }
</a><a href="#h6-0-327" id="h6-0-327" class="d">-        })
</a><a href="#h6-0-328" id="h6-0-328" class="d">-    }
</a><a href="#h6-0-329" id="h6-0-329" class="d">-
</a><a href="#h6-0-330" id="h6-0-330" class="d">-    /// Builds an aggregation node. All aggregate parameters and GROUP BY expressions are evaluated
</a><a href="#h6-0-331" id="h6-0-331" class="d">-    /// in a pre-projection, whose results are fed into an Aggregate node. This node computes the
</a><a href="#h6-0-332" id="h6-0-332" class="d">-    /// aggregates for the given groups, passing the group values through directly.
</a><a href="#h6-0-333" id="h6-0-333" class="d">-    fn build_aggregation(
</a><a href="#h6-0-334" id="h6-0-334" class="d">-        &amp;self,
</a><a href="#h6-0-335" id="h6-0-335" class="d">-        scope: &amp;mut Scope,
</a><a href="#h6-0-336" id="h6-0-336" class="d">-        source: Node,
</a><a href="#h6-0-337" id="h6-0-337" class="d">-        groups: Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h6-0-338" id="h6-0-338" class="d">-        aggregations: Vec&lt;(Aggregate, ast::Expression)&gt;,
</a><a href="#h6-0-339" id="h6-0-339" class="d">-    ) -&gt; Result&lt;Node&gt; {
</a><a href="#h6-0-340" id="h6-0-340" class="d">-        let mut aggregates = Vec::new();
</a><a href="#h6-0-341" id="h6-0-341" class="d">-        let mut expressions = Vec::new();
</a><a href="#h6-0-342" id="h6-0-342" class="d">-        for (aggregate, expr) in aggregations {
</a><a href="#h6-0-343" id="h6-0-343" class="d">-            aggregates.push(aggregate);
</a><a href="#h6-0-344" id="h6-0-344" class="d">-            expressions.push((self.build_expression(scope, expr)?, None));
</a><a href="#h6-0-345" id="h6-0-345" class="d">-        }
</a><a href="#h6-0-346" id="h6-0-346" class="d">-        for (expr, label) in groups {
</a><a href="#h6-0-347" id="h6-0-347" class="d">-            expressions.push((self.build_expression(scope, expr)?, label));
</a><a href="#h6-0-348" id="h6-0-348" class="d">-        }
</a><a href="#h6-0-349" id="h6-0-349" class="d">-        scope.project(
</a><a href="#h6-0-350" id="h6-0-350" class="d">-            &amp;expressions
</a><a href="#h6-0-351" id="h6-0-351" class="d">-                .iter()
</a><a href="#h6-0-352" id="h6-0-352" class="d">-                .cloned()
</a><a href="#h6-0-353" id="h6-0-353" class="d">-                .enumerate()
</a><a href="#h6-0-354" id="h6-0-354" class="d">-                .map(|(i, (e, l))| {
</a><a href="#h6-0-355" id="h6-0-355" class="d">-                    if i &lt; aggregates.len() {
</a><a href="#h6-0-356" id="h6-0-356" class="d">-                        // We pass null values here since we don&#39;t want field references to hit
</a><a href="#h6-0-357" id="h6-0-357" class="d">-                        // the fields in scope before the aggregation.
</a><a href="#h6-0-358" id="h6-0-358" class="d">-                        (Expression::Constant(Value::Null), None)
</a><a href="#h6-0-359" id="h6-0-359" class="d">-                    } else {
</a><a href="#h6-0-360" id="h6-0-360" class="d">-                        (e, l)
</a><a href="#h6-0-361" id="h6-0-361" class="d">-                    }
</a><a href="#h6-0-362" id="h6-0-362" class="d">-                })
</a><a href="#h6-0-363" id="h6-0-363" class="d">-                .collect::&lt;Vec&lt;_&gt;&gt;(),
</a><a href="#h6-0-364" id="h6-0-364" class="d">-        )?;
</a><a href="#h6-0-365" id="h6-0-365" class="d">-        let node = Node::Aggregation {
</a><a href="#h6-0-366" id="h6-0-366" class="d">-            source: Box::new(Node::Projection { source: Box::new(source), expressions }),
</a><a href="#h6-0-367" id="h6-0-367" class="d">-            aggregates,
</a><a href="#h6-0-368" id="h6-0-368" class="d">-        };
</a><a href="#h6-0-369" id="h6-0-369" class="d">-        Ok(node)
</a><a href="#h6-0-370" id="h6-0-370" class="d">-    }
</a><a href="#h6-0-371" id="h6-0-371" class="d">-
</a><a href="#h6-0-372" id="h6-0-372" class="d">-    /// Extracts aggregate functions from an AST expression tree. This finds the aggregate
</a><a href="#h6-0-373" id="h6-0-373" class="d">-    /// function calls, replaces them with ast::Expression::Column(i), maps the aggregate functions
</a><a href="#h6-0-374" id="h6-0-374" class="d">-    /// to aggregates, and returns them along with their argument expressions.
</a><a href="#h6-0-375" id="h6-0-375" class="d">-    fn extract_aggregates(
</a><a href="#h6-0-376" id="h6-0-376" class="d">-        &amp;self,
</a><a href="#h6-0-377" id="h6-0-377" class="d">-        exprs: &amp;mut [(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h6-0-378" id="h6-0-378" class="d">-    ) -&gt; Result&lt;Vec&lt;(Aggregate, ast::Expression)&gt;&gt; {
</a><a href="#h6-0-379" id="h6-0-379" class="d">-        let mut aggregates = Vec::new();
</a><a href="#h6-0-380" id="h6-0-380" class="d">-        for (expr, _) in exprs {
</a><a href="#h6-0-381" id="h6-0-381" class="d">-            expr.transform_mut(
</a><a href="#h6-0-382" id="h6-0-382" class="d">-                &amp;mut |mut e| match &amp;mut e {
</a><a href="#h6-0-383" id="h6-0-383" class="d">-                    ast::Expression::Function(f, args) if args.len() == 1 =&gt; {
</a><a href="#h6-0-384" id="h6-0-384" class="d">-                        if let Some(aggregate) = self.aggregate_from_name(f) {
</a><a href="#h6-0-385" id="h6-0-385" class="d">-                            aggregates.push((aggregate, args.remove(0)));
</a><a href="#h6-0-386" id="h6-0-386" class="d">-                            Ok(ast::Expression::Column(aggregates.len() - 1))
</a><a href="#h6-0-387" id="h6-0-387" class="d">-                        } else {
</a><a href="#h6-0-388" id="h6-0-388" class="d">-                            Ok(e)
</a><a href="#h6-0-389" id="h6-0-389" class="d">-                        }
</a><a href="#h6-0-390" id="h6-0-390" class="d">-                    }
</a><a href="#h6-0-391" id="h6-0-391" class="d">-                    _ =&gt; Ok(e),
</a><a href="#h6-0-392" id="h6-0-392" class="d">-                },
</a><a href="#h6-0-393" id="h6-0-393" class="d">-                &amp;mut Ok,
</a><a href="#h6-0-394" id="h6-0-394" class="d">-            )?;
</a><a href="#h6-0-395" id="h6-0-395" class="d">-        }
</a><a href="#h6-0-396" id="h6-0-396" class="d">-        for (_, expr) in &amp;aggregates {
</a><a href="#h6-0-397" id="h6-0-397" class="d">-            if self.is_aggregate(expr) {
</a><a href="#h6-0-398" id="h6-0-398" class="d">-                return errinput!(&quot;aggregate functions can&#39;t be nested&quot;);
</a><a href="#h6-0-399" id="h6-0-399" class="d">-            }
</a><a href="#h6-0-400" id="h6-0-400" class="d">-        }
</a><a href="#h6-0-401" id="h6-0-401" class="d">-        Ok(aggregates)
</a><a href="#h6-0-402" id="h6-0-402" class="d">-    }
</a><a href="#h6-0-403" id="h6-0-403" class="d">-
</a><a href="#h6-0-404" id="h6-0-404" class="d">-    /// Extracts group by expressions, and replaces them with column references with the given
</a><a href="#h6-0-405" id="h6-0-405" class="d">-    /// offset. These can be either an arbitray expression, a reference to a SELECT column, or the
</a><a href="#h6-0-406" id="h6-0-406" class="d">-    /// same expression as a SELECT column. The following are all valid:
</a><a href="#h6-0-407" id="h6-0-407" class="d">-    ///
</a><a href="#h6-0-408" id="h6-0-408" class="d">-    /// SELECT released / 100 AS century, COUNT(*) FROM movies GROUP BY century
</a><a href="#h6-0-409" id="h6-0-409" class="d">-    /// SELECT released / 100, COUNT(*) FROM movies GROUP BY released / 100
</a><a href="#h6-0-410" id="h6-0-410" class="d">-    /// SELECT COUNT(*) FROM movies GROUP BY released / 100
</a><a href="#h6-0-411" id="h6-0-411" class="d">-    fn extract_groups(
</a><a href="#h6-0-412" id="h6-0-412" class="d">-        &amp;self,
</a><a href="#h6-0-413" id="h6-0-413" class="d">-        exprs: &amp;mut [(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h6-0-414" id="h6-0-414" class="d">-        group_by: Vec&lt;ast::Expression&gt;,
</a><a href="#h6-0-415" id="h6-0-415" class="d">-        offset: usize,
</a><a href="#h6-0-416" id="h6-0-416" class="d">-    ) -&gt; Result&lt;Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;&gt; {
</a><a href="#h6-0-417" id="h6-0-417" class="d">-        let mut groups = Vec::new();
</a><a href="#h6-0-418" id="h6-0-418" class="d">-        for g in group_by {
</a><a href="#h6-0-419" id="h6-0-419" class="d">-            // Look for references to SELECT columns with AS labels
</a><a href="#h6-0-420" id="h6-0-420" class="d">-            if let ast::Expression::Field(None, label) = &amp;g {
</a><a href="#h6-0-421" id="h6-0-421" class="d">-                if let Some(i) = exprs.iter().position(|(_, l)| l.as_deref() == Some(label)) {
</a><a href="#h6-0-422" id="h6-0-422" class="d">-                    groups.push((
</a><a href="#h6-0-423" id="h6-0-423" class="d">-                        replace(&amp;mut exprs[i].0, ast::Expression::Column(offset + groups.len())),
</a><a href="#h6-0-424" id="h6-0-424" class="d">-                        exprs[i].1.clone(),
</a><a href="#h6-0-425" id="h6-0-425" class="d">-                    ));
</a><a href="#h6-0-426" id="h6-0-426" class="d">-                    continue;
</a><a href="#h6-0-427" id="h6-0-427" class="d">-                }
</a><a href="#h6-0-428" id="h6-0-428" class="d">-            }
</a><a href="#h6-0-429" id="h6-0-429" class="d">-            // Look for expressions exactly equal to the group expression
</a><a href="#h6-0-430" id="h6-0-430" class="d">-            if let Some(i) = exprs.iter().position(|(e, _)| e == &amp;g) {
</a><a href="#h6-0-431" id="h6-0-431" class="d">-                groups.push((
</a><a href="#h6-0-432" id="h6-0-432" class="d">-                    replace(&amp;mut exprs[i].0, ast::Expression::Column(offset + groups.len())),
</a><a href="#h6-0-433" id="h6-0-433" class="d">-                    exprs[i].1.clone(),
</a><a href="#h6-0-434" id="h6-0-434" class="d">-                ));
</a><a href="#h6-0-435" id="h6-0-435" class="d">-                continue;
</a><a href="#h6-0-436" id="h6-0-436" class="d">-            }
</a><a href="#h6-0-437" id="h6-0-437" class="d">-            // Otherwise, just use the group expression directly
</a><a href="#h6-0-438" id="h6-0-438" class="d">-            groups.push((g, None))
</a><a href="#h6-0-439" id="h6-0-439" class="d">-        }
</a><a href="#h6-0-440" id="h6-0-440" class="d">-        // Make sure no group expressions contain Column references, which would be placed here
</a><a href="#h6-0-441" id="h6-0-441" class="d">-        // during extract_aggregates().
</a><a href="#h6-0-442" id="h6-0-442" class="d">-        for (expr, _) in &amp;groups {
</a><a href="#h6-0-443" id="h6-0-443" class="d">-            if self.is_aggregate(expr) {
</a><a href="#h6-0-444" id="h6-0-444" class="d">-                return errinput!(&quot;group expression cannot contain aggregates&quot;);
</a><a href="#h6-0-445" id="h6-0-445" class="d">-            }
</a><a href="#h6-0-446" id="h6-0-446" class="d">-        }
</a><a href="#h6-0-447" id="h6-0-447" class="d">-        Ok(groups)
</a><a href="#h6-0-448" id="h6-0-448" class="d">-    }
</a><a href="#h6-0-449" id="h6-0-449" class="d">-
</a><a href="#h6-0-450" id="h6-0-450" class="d">-    /// Injects hidden expressions into SELECT expressions. This is used for ORDER BY and HAVING, in
</a><a href="#h6-0-451" id="h6-0-451" class="d">-    /// order to apply these to fields or aggregates that are not present in the SELECT output, e.g.
</a><a href="#h6-0-452" id="h6-0-452" class="d">-    /// to order on a column that is not selected. This is done by replacing the relevant parts of
</a><a href="#h6-0-453" id="h6-0-453" class="d">-    /// the given expression with Column references to either existing columns or new, hidden
</a><a href="#h6-0-454" id="h6-0-454" class="d">-    /// columns in the select expressions. Returns the number of hidden columns added.
</a><a href="#h6-0-455" id="h6-0-455" class="d">-    fn inject_hidden(
</a><a href="#h6-0-456" id="h6-0-456" class="d">-        &amp;self,
</a><a href="#h6-0-457" id="h6-0-457" class="d">-        expr: &amp;mut ast::Expression,
</a><a href="#h6-0-458" id="h6-0-458" class="d">-        select: &amp;mut Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h6-0-459" id="h6-0-459" class="d">-    ) -&gt; Result&lt;usize&gt; {
</a><a href="#h6-0-460" id="h6-0-460" class="d">-        // Replace any identical expressions or label references with column references.
</a><a href="#h6-0-461" id="h6-0-461" class="d">-        for (i, (sexpr, label)) in select.iter().enumerate() {
</a><a href="#h6-0-462" id="h6-0-462" class="d">-            if expr == sexpr {
</a><a href="#h6-0-463" id="h6-0-463" class="d">-                *expr = ast::Expression::Column(i);
</a><a href="#h6-0-464" id="h6-0-464" class="d">-                continue;
</a><a href="#h6-0-465" id="h6-0-465" class="d">-            }
</a><a href="#h6-0-466" id="h6-0-466" class="d">-            if let Some(label) = label {
</a><a href="#h6-0-467" id="h6-0-467" class="d">-                expr.transform_mut(
</a><a href="#h6-0-468" id="h6-0-468" class="d">-                    &amp;mut |e| match e {
</a><a href="#h6-0-469" id="h6-0-469" class="d">-                        ast::Expression::Field(None, ref l) if l == label =&gt; {
</a><a href="#h6-0-470" id="h6-0-470" class="d">-                            Ok(ast::Expression::Column(i))
</a><a href="#h6-0-471" id="h6-0-471" class="d">-                        }
</a><a href="#h6-0-472" id="h6-0-472" class="d">-                        e =&gt; Ok(e),
</a><a href="#h6-0-473" id="h6-0-473" class="d">-                    },
</a><a href="#h6-0-474" id="h6-0-474" class="d">-                    &amp;mut Ok,
</a><a href="#h6-0-475" id="h6-0-475" class="d">-                )?;
</a><a href="#h6-0-476" id="h6-0-476" class="d">-            }
</a><a href="#h6-0-477" id="h6-0-477" class="d">-        }
</a><a href="#h6-0-478" id="h6-0-478" class="d">-        // Any remaining aggregate functions and field references must be extracted as hidden
</a><a href="#h6-0-479" id="h6-0-479" class="d">-        // columns.
</a><a href="#h6-0-480" id="h6-0-480" class="d">-        let mut hidden = 0;
</a><a href="#h6-0-481" id="h6-0-481" class="d">-        expr.transform_mut(
</a><a href="#h6-0-482" id="h6-0-482" class="d">-            &amp;mut |e| match &amp;e {
</a><a href="#h6-0-483" id="h6-0-483" class="d">-                ast::Expression::Function(f, a) if self.aggregate_from_name(f).is_some() =&gt; {
</a><a href="#h6-0-484" id="h6-0-484" class="d">-                    if let ast::Expression::Column(c) = a[0] {
</a><a href="#h6-0-485" id="h6-0-485" class="d">-                        if self.is_aggregate(&amp;select[c].0) {
</a><a href="#h6-0-486" id="h6-0-486" class="d">-                            return errinput!(&quot;aggregate function cannot reference aggregate&quot;);
</a><a href="#h6-0-487" id="h6-0-487" class="d">-                        }
</a><a href="#h6-0-488" id="h6-0-488" class="d">-                    }
</a><a href="#h6-0-489" id="h6-0-489" class="d">-                    select.push((e, None));
</a><a href="#h6-0-490" id="h6-0-490" class="d">-                    hidden += 1;
</a><a href="#h6-0-491" id="h6-0-491" class="d">-                    Ok(ast::Expression::Column(select.len() - 1))
</a><a href="#h6-0-492" id="h6-0-492" class="d">-                }
</a><a href="#h6-0-493" id="h6-0-493" class="d">-                ast::Expression::Field(_, _) =&gt; {
</a><a href="#h6-0-494" id="h6-0-494" class="d">-                    select.push((e, None));
</a><a href="#h6-0-495" id="h6-0-495" class="d">-                    hidden += 1;
</a><a href="#h6-0-496" id="h6-0-496" class="d">-                    Ok(ast::Expression::Column(select.len() - 1))
</a><a href="#h6-0-497" id="h6-0-497" class="d">-                }
</a><a href="#h6-0-498" id="h6-0-498" class="d">-                _ =&gt; Ok(e),
</a><a href="#h6-0-499" id="h6-0-499" class="d">-            },
</a><a href="#h6-0-500" id="h6-0-500" class="d">-            &amp;mut Ok,
</a><a href="#h6-0-501" id="h6-0-501" class="d">-        )?;
</a><a href="#h6-0-502" id="h6-0-502" class="d">-        Ok(hidden)
</a><a href="#h6-0-503" id="h6-0-503" class="d">-    }
</a><a href="#h6-0-504" id="h6-0-504" class="d">-
</a><a href="#h6-0-505" id="h6-0-505" class="d">-    /// Returns the aggregate corresponding to the given aggregate function name.
</a><a href="#h6-0-506" id="h6-0-506" class="d">-    fn aggregate_from_name(&amp;self, name: &amp;str) -&gt; Option&lt;Aggregate&gt; {
</a><a href="#h6-0-507" id="h6-0-507" class="d">-        match name {
</a><a href="#h6-0-508" id="h6-0-508" class="d">-            &quot;avg&quot; =&gt; Some(Aggregate::Average),
</a><a href="#h6-0-509" id="h6-0-509" class="d">-            &quot;count&quot; =&gt; Some(Aggregate::Count),
</a><a href="#h6-0-510" id="h6-0-510" class="d">-            &quot;max&quot; =&gt; Some(Aggregate::Max),
</a><a href="#h6-0-511" id="h6-0-511" class="d">-            &quot;min&quot; =&gt; Some(Aggregate::Min),
</a><a href="#h6-0-512" id="h6-0-512" class="d">-            &quot;sum&quot; =&gt; Some(Aggregate::Sum),
</a><a href="#h6-0-513" id="h6-0-513" class="d">-            _ =&gt; None,
</a><a href="#h6-0-514" id="h6-0-514" class="d">-        }
</a><a href="#h6-0-515" id="h6-0-515" class="d">-    }
</a><a href="#h6-0-516" id="h6-0-516" class="d">-
</a><a href="#h6-0-517" id="h6-0-517" class="d">-    /// Checks whether a given expression is an aggregate expression.
</a><a href="#h6-0-518" id="h6-0-518" class="d">-    fn is_aggregate(&amp;self, expr: &amp;ast::Expression) -&gt; bool {
</a><a href="#h6-0-519" id="h6-0-519" class="d">-        expr.contains(&amp;|e| match e {
</a><a href="#h6-0-520" id="h6-0-520" class="d">-            ast::Expression::Function(f, _) =&gt; self.aggregate_from_name(f).is_some(),
</a><a href="#h6-0-521" id="h6-0-521" class="d">-            _ =&gt; false,
</a><a href="#h6-0-522" id="h6-0-522" class="d">-        })
</a><a href="#h6-0-523" id="h6-0-523" class="d">-    }
</a><a href="#h6-0-524" id="h6-0-524" class="d">-
</a><a href="#h6-0-525" id="h6-0-525" class="d">-    /// Builds an expression from an AST expression
</a><a href="#h6-0-526" id="h6-0-526" class="d">-    #[allow(clippy::only_used_in_recursion)]
</a><a href="#h6-0-527" id="h6-0-527" class="d">-    fn build_expression(&amp;self, scope: &amp;mut Scope, expr: ast::Expression) -&gt; Result&lt;Expression&gt; {
</a><a href="#h6-0-528" id="h6-0-528" class="d">-        use Expression::*;
</a><a href="#h6-0-529" id="h6-0-529" class="d">-        Ok(match expr {
</a><a href="#h6-0-530" id="h6-0-530" class="d">-            ast::Expression::Literal(l) =&gt; Constant(match l {
</a><a href="#h6-0-531" id="h6-0-531" class="d">-                ast::Literal::Null =&gt; Value::Null,
</a><a href="#h6-0-532" id="h6-0-532" class="d">-                ast::Literal::Boolean(b) =&gt; Value::Boolean(b),
</a><a href="#h6-0-533" id="h6-0-533" class="d">-                ast::Literal::Integer(i) =&gt; Value::Integer(i),
</a><a href="#h6-0-534" id="h6-0-534" class="d">-                ast::Literal::Float(f) =&gt; Value::Float(f),
</a><a href="#h6-0-535" id="h6-0-535" class="d">-                ast::Literal::String(s) =&gt; Value::String(s),
</a><a href="#h6-0-536" id="h6-0-536" class="d">-            }),
</a><a href="#h6-0-537" id="h6-0-537" class="d">-            ast::Expression::Column(i) =&gt; Field(i, scope.get_label(i)?),
</a><a href="#h6-0-538" id="h6-0-538" class="d">-            ast::Expression::Field(table, name) =&gt; {
</a><a href="#h6-0-539" id="h6-0-539" class="d">-                Field(scope.resolve(table.as_deref(), &amp;name)?, Some((table, name)))
</a><a href="#h6-0-540" id="h6-0-540" class="d">-            }
</a><a href="#h6-0-541" id="h6-0-541" class="d">-            ast::Expression::Function(name, _) =&gt; return errinput!(&quot;unknown function {name}&quot;),
</a><a href="#h6-0-542" id="h6-0-542" class="d">-            ast::Expression::Operation(op) =&gt; match op {
</a><a href="#h6-0-543" id="h6-0-543" class="d">-                // Logical operators
</a><a href="#h6-0-544" id="h6-0-544" class="d">-                ast::Operation::And(lhs, rhs) =&gt; And(
</a><a href="#h6-0-545" id="h6-0-545" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-546" id="h6-0-546" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-547" id="h6-0-547" class="d">-                ),
</a><a href="#h6-0-548" id="h6-0-548" class="d">-                ast::Operation::Not(expr) =&gt; Not(self.build_expression(scope, *expr)?.into()),
</a><a href="#h6-0-549" id="h6-0-549" class="d">-                ast::Operation::Or(lhs, rhs) =&gt; Or(
</a><a href="#h6-0-550" id="h6-0-550" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-551" id="h6-0-551" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-552" id="h6-0-552" class="d">-                ),
</a><a href="#h6-0-553" id="h6-0-553" class="d">-
</a><a href="#h6-0-554" id="h6-0-554" class="d">-                // Comparison operators
</a><a href="#h6-0-555" id="h6-0-555" class="d">-                ast::Operation::Equal(lhs, rhs) =&gt; Equal(
</a><a href="#h6-0-556" id="h6-0-556" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-557" id="h6-0-557" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-558" id="h6-0-558" class="d">-                ),
</a><a href="#h6-0-559" id="h6-0-559" class="d">-                ast::Operation::GreaterThan(lhs, rhs) =&gt; GreaterThan(
</a><a href="#h6-0-560" id="h6-0-560" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-561" id="h6-0-561" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-562" id="h6-0-562" class="d">-                ),
</a><a href="#h6-0-563" id="h6-0-563" class="d">-                ast::Operation::GreaterThanOrEqual(lhs, rhs) =&gt; Or(
</a><a href="#h6-0-564" id="h6-0-564" class="d">-                    GreaterThan(
</a><a href="#h6-0-565" id="h6-0-565" class="d">-                        self.build_expression(scope, *lhs.clone())?.into(),
</a><a href="#h6-0-566" id="h6-0-566" class="d">-                        self.build_expression(scope, *rhs.clone())?.into(),
</a><a href="#h6-0-567" id="h6-0-567" class="d">-                    )
</a><a href="#h6-0-568" id="h6-0-568" class="d">-                    .into(),
</a><a href="#h6-0-569" id="h6-0-569" class="d">-                    Equal(
</a><a href="#h6-0-570" id="h6-0-570" class="d">-                        self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-571" id="h6-0-571" class="d">-                        self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-572" id="h6-0-572" class="d">-                    )
</a><a href="#h6-0-573" id="h6-0-573" class="d">-                    .into(),
</a><a href="#h6-0-574" id="h6-0-574" class="d">-                ),
</a><a href="#h6-0-575" id="h6-0-575" class="d">-                ast::Operation::IsNull(expr) =&gt; IsNull(self.build_expression(scope, *expr)?.into()),
</a><a href="#h6-0-576" id="h6-0-576" class="d">-                ast::Operation::LessThan(lhs, rhs) =&gt; LessThan(
</a><a href="#h6-0-577" id="h6-0-577" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-578" id="h6-0-578" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-579" id="h6-0-579" class="d">-                ),
</a><a href="#h6-0-580" id="h6-0-580" class="d">-                ast::Operation::LessThanOrEqual(lhs, rhs) =&gt; Or(
</a><a href="#h6-0-581" id="h6-0-581" class="d">-                    LessThan(
</a><a href="#h6-0-582" id="h6-0-582" class="d">-                        self.build_expression(scope, *lhs.clone())?.into(),
</a><a href="#h6-0-583" id="h6-0-583" class="d">-                        self.build_expression(scope, *rhs.clone())?.into(),
</a><a href="#h6-0-584" id="h6-0-584" class="d">-                    )
</a><a href="#h6-0-585" id="h6-0-585" class="d">-                    .into(),
</a><a href="#h6-0-586" id="h6-0-586" class="d">-                    Equal(
</a><a href="#h6-0-587" id="h6-0-587" class="d">-                        self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-588" id="h6-0-588" class="d">-                        self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-589" id="h6-0-589" class="d">-                    )
</a><a href="#h6-0-590" id="h6-0-590" class="d">-                    .into(),
</a><a href="#h6-0-591" id="h6-0-591" class="d">-                ),
</a><a href="#h6-0-592" id="h6-0-592" class="d">-                ast::Operation::Like(lhs, rhs) =&gt; Like(
</a><a href="#h6-0-593" id="h6-0-593" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-594" id="h6-0-594" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-595" id="h6-0-595" class="d">-                ),
</a><a href="#h6-0-596" id="h6-0-596" class="d">-                ast::Operation::NotEqual(lhs, rhs) =&gt; Not(Equal(
</a><a href="#h6-0-597" id="h6-0-597" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-598" id="h6-0-598" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-599" id="h6-0-599" class="d">-                )
</a><a href="#h6-0-600" id="h6-0-600" class="d">-                .into()),
</a><a href="#h6-0-601" id="h6-0-601" class="d">-
</a><a href="#h6-0-602" id="h6-0-602" class="d">-                // Mathematical operators
</a><a href="#h6-0-603" id="h6-0-603" class="d">-                ast::Operation::Assert(expr) =&gt; Assert(self.build_expression(scope, *expr)?.into()),
</a><a href="#h6-0-604" id="h6-0-604" class="d">-                ast::Operation::Add(lhs, rhs) =&gt; Add(
</a><a href="#h6-0-605" id="h6-0-605" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-606" id="h6-0-606" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-607" id="h6-0-607" class="d">-                ),
</a><a href="#h6-0-608" id="h6-0-608" class="d">-                ast::Operation::Divide(lhs, rhs) =&gt; Divide(
</a><a href="#h6-0-609" id="h6-0-609" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-610" id="h6-0-610" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-611" id="h6-0-611" class="d">-                ),
</a><a href="#h6-0-612" id="h6-0-612" class="d">-                ast::Operation::Exponentiate(lhs, rhs) =&gt; Exponentiate(
</a><a href="#h6-0-613" id="h6-0-613" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-614" id="h6-0-614" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-615" id="h6-0-615" class="d">-                ),
</a><a href="#h6-0-616" id="h6-0-616" class="d">-                ast::Operation::Factorial(expr) =&gt; {
</a><a href="#h6-0-617" id="h6-0-617" class="d">-                    Factorial(self.build_expression(scope, *expr)?.into())
</a><a href="#h6-0-618" id="h6-0-618" class="d">-                }
</a><a href="#h6-0-619" id="h6-0-619" class="d">-                ast::Operation::Modulo(lhs, rhs) =&gt; Modulo(
</a><a href="#h6-0-620" id="h6-0-620" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-621" id="h6-0-621" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-622" id="h6-0-622" class="d">-                ),
</a><a href="#h6-0-623" id="h6-0-623" class="d">-                ast::Operation::Multiply(lhs, rhs) =&gt; Multiply(
</a><a href="#h6-0-624" id="h6-0-624" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-625" id="h6-0-625" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-626" id="h6-0-626" class="d">-                ),
</a><a href="#h6-0-627" id="h6-0-627" class="d">-                ast::Operation::Negate(expr) =&gt; Negate(self.build_expression(scope, *expr)?.into()),
</a><a href="#h6-0-628" id="h6-0-628" class="d">-                ast::Operation::Subtract(lhs, rhs) =&gt; Subtract(
</a><a href="#h6-0-629" id="h6-0-629" class="d">-                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h6-0-630" id="h6-0-630" class="d">-                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h6-0-631" id="h6-0-631" class="d">-                ),
</a><a href="#h6-0-632" id="h6-0-632" class="d">-            },
</a><a href="#h6-0-633" id="h6-0-633" class="d">-        })
</a><a href="#h6-0-634" id="h6-0-634" class="d">-    }
</a><a href="#h6-0-635" id="h6-0-635" class="d">-
</a><a href="#h6-0-636" id="h6-0-636" class="d">-    /// Builds and evaluates a constant AST expression.
</a><a href="#h6-0-637" id="h6-0-637" class="d">-    fn evaluate_constant(&amp;self, expr: ast::Expression) -&gt; Result&lt;Value&gt; {
</a><a href="#h6-0-638" id="h6-0-638" class="d">-        self.build_expression(&amp;mut Scope::constant(), expr)?.evaluate(None)
</a><a href="#h6-0-639" id="h6-0-639" class="d">-    }
</a><a href="#h6-0-640" id="h6-0-640" class="d">-}
</a><a href="#h6-0-641" id="h6-0-641" class="d">-
</a><a href="#h6-0-642" id="h6-0-642" class="d">-/// Manages names available to expressions and executors, and maps them onto columns/fields.
</a><a href="#h6-0-643" id="h6-0-643" class="d">-#[derive(Clone, Debug)]
</a><a href="#h6-0-644" id="h6-0-644" class="d">-pub struct Scope {
</a><a href="#h6-0-645" id="h6-0-645" class="d">-    // If true, the scope is constant and cannot contain any variables.
</a><a href="#h6-0-646" id="h6-0-646" class="d">-    constant: bool,
</a><a href="#h6-0-647" id="h6-0-647" class="d">-    // Currently visible tables, by query name (i.e. alias or actual name).
</a><a href="#h6-0-648" id="h6-0-648" class="d">-    tables: HashMap&lt;String, Table&gt;,
</a><a href="#h6-0-649" id="h6-0-649" class="d">-    // Column labels, if any (qualified by table name when available)
</a><a href="#h6-0-650" id="h6-0-650" class="d">-    columns: Vec&lt;(Option&lt;String&gt;, Option&lt;String&gt;)&gt;,
</a><a href="#h6-0-651" id="h6-0-651" class="d">-    // Qualified names to column indexes.
</a><a href="#h6-0-652" id="h6-0-652" class="d">-    qualified: HashMap&lt;(String, String), usize&gt;,
</a><a href="#h6-0-653" id="h6-0-653" class="d">-    // Unqualified names to column indexes, if unique.
</a><a href="#h6-0-654" id="h6-0-654" class="d">-    unqualified: HashMap&lt;String, usize&gt;,
</a><a href="#h6-0-655" id="h6-0-655" class="d">-    // Unqialified ambiguous names.
</a><a href="#h6-0-656" id="h6-0-656" class="d">-    ambiguous: HashSet&lt;String&gt;,
</a><a href="#h6-0-657" id="h6-0-657" class="d">-}
</a><a href="#h6-0-658" id="h6-0-658" class="d">-
</a><a href="#h6-0-659" id="h6-0-659" class="d">-impl Scope {
</a><a href="#h6-0-660" id="h6-0-660" class="d">-    /// Creates a new, empty scope.
</a><a href="#h6-0-661" id="h6-0-661" class="d">-    fn new() -&gt; Self {
</a><a href="#h6-0-662" id="h6-0-662" class="d">-        Self {
</a><a href="#h6-0-663" id="h6-0-663" class="d">-            constant: false,
</a><a href="#h6-0-664" id="h6-0-664" class="d">-            tables: HashMap::new(),
</a><a href="#h6-0-665" id="h6-0-665" class="d">-            columns: Vec::new(),
</a><a href="#h6-0-666" id="h6-0-666" class="d">-            qualified: HashMap::new(),
</a><a href="#h6-0-667" id="h6-0-667" class="d">-            unqualified: HashMap::new(),
</a><a href="#h6-0-668" id="h6-0-668" class="d">-            ambiguous: HashSet::new(),
</a><a href="#h6-0-669" id="h6-0-669" class="d">-        }
</a><a href="#h6-0-670" id="h6-0-670" class="d">-    }
</a><a href="#h6-0-671" id="h6-0-671" class="d">-
</a><a href="#h6-0-672" id="h6-0-672" class="d">-    /// Creates a constant scope.
</a><a href="#h6-0-673" id="h6-0-673" class="d">-    fn constant() -&gt; Self {
</a><a href="#h6-0-674" id="h6-0-674" class="d">-        let mut scope = Self::new();
</a><a href="#h6-0-675" id="h6-0-675" class="d">-        scope.constant = true;
</a><a href="#h6-0-676" id="h6-0-676" class="d">-        scope
</a><a href="#h6-0-677" id="h6-0-677" class="d">-    }
</a><a href="#h6-0-678" id="h6-0-678" class="d">-
</a><a href="#h6-0-679" id="h6-0-679" class="d">-    /// Creates a scope from a table.
</a><a href="#h6-0-680" id="h6-0-680" class="d">-    fn from_table(table: Table) -&gt; Result&lt;Self&gt; {
</a><a href="#h6-0-681" id="h6-0-681" class="d">-        let mut scope = Self::new();
</a><a href="#h6-0-682" id="h6-0-682" class="d">-        scope.add_table(table.name.clone(), table)?;
</a><a href="#h6-0-683" id="h6-0-683" class="d">-        Ok(scope)
</a><a href="#h6-0-684" id="h6-0-684" class="d">-    }
</a><a href="#h6-0-685" id="h6-0-685" class="d">-
</a><a href="#h6-0-686" id="h6-0-686" class="d">-    /// Adds a column to the scope.
</a><a href="#h6-0-687" id="h6-0-687" class="d">-    #[allow(clippy::map_entry)]
</a><a href="#h6-0-688" id="h6-0-688" class="d">-    fn add_column(&amp;mut self, table: Option&lt;String&gt;, label: Option&lt;String&gt;) {
</a><a href="#h6-0-689" id="h6-0-689" class="d">-        if let Some(l) = label.clone() {
</a><a href="#h6-0-690" id="h6-0-690" class="d">-            if let Some(t) = table.clone() {
</a><a href="#h6-0-691" id="h6-0-691" class="d">-                self.qualified.insert((t, l.clone()), self.columns.len());
</a><a href="#h6-0-692" id="h6-0-692" class="d">-            }
</a><a href="#h6-0-693" id="h6-0-693" class="d">-            if !self.ambiguous.contains(&amp;l) {
</a><a href="#h6-0-694" id="h6-0-694" class="d">-                if !self.unqualified.contains_key(&amp;l) {
</a><a href="#h6-0-695" id="h6-0-695" class="d">-                    self.unqualified.insert(l, self.columns.len());
</a><a href="#h6-0-696" id="h6-0-696" class="d">-                } else {
</a><a href="#h6-0-697" id="h6-0-697" class="d">-                    self.unqualified.remove(&amp;l);
</a><a href="#h6-0-698" id="h6-0-698" class="d">-                    self.ambiguous.insert(l);
</a><a href="#h6-0-699" id="h6-0-699" class="d">-                }
</a><a href="#h6-0-700" id="h6-0-700" class="d">-            }
</a><a href="#h6-0-701" id="h6-0-701" class="d">-        }
</a><a href="#h6-0-702" id="h6-0-702" class="d">-        self.columns.push((table, label));
</a><a href="#h6-0-703" id="h6-0-703" class="d">-    }
</a><a href="#h6-0-704" id="h6-0-704" class="d">-
</a><a href="#h6-0-705" id="h6-0-705" class="d">-    /// Adds a table to the scope.
</a><a href="#h6-0-706" id="h6-0-706" class="d">-    fn add_table(&amp;mut self, label: String, table: Table) -&gt; Result&lt;()&gt; {
</a><a href="#h6-0-707" id="h6-0-707" class="d">-        if self.constant {
</a><a href="#h6-0-708" id="h6-0-708" class="d">-            panic!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h6-0-709" id="h6-0-709" class="d">-        }
</a><a href="#h6-0-710" id="h6-0-710" class="d">-        if self.tables.contains_key(&amp;label) {
</a><a href="#h6-0-711" id="h6-0-711" class="d">-            return errinput!(&quot;duplicate table name {label}&quot;);
</a><a href="#h6-0-712" id="h6-0-712" class="d">-        }
</a><a href="#h6-0-713" id="h6-0-713" class="d">-        for column in &amp;table.columns {
</a><a href="#h6-0-714" id="h6-0-714" class="d">-            self.add_column(Some(label.clone()), Some(column.name.clone()));
</a><a href="#h6-0-715" id="h6-0-715" class="d">-        }
</a><a href="#h6-0-716" id="h6-0-716" class="d">-        self.tables.insert(label, table);
</a><a href="#h6-0-717" id="h6-0-717" class="d">-        Ok(())
</a><a href="#h6-0-718" id="h6-0-718" class="d">-    }
</a><a href="#h6-0-719" id="h6-0-719" class="d">-
</a><a href="#h6-0-720" id="h6-0-720" class="d">-    /// Fetches a column from the scope by index.
</a><a href="#h6-0-721" id="h6-0-721" class="d">-    fn get_column(&amp;self, index: usize) -&gt; Result&lt;(Option&lt;String&gt;, Option&lt;String&gt;)&gt; {
</a><a href="#h6-0-722" id="h6-0-722" class="d">-        if self.constant {
</a><a href="#h6-0-723" id="h6-0-723" class="d">-            return errinput!(&quot;expression must be constant, found column {index}&quot;);
</a><a href="#h6-0-724" id="h6-0-724" class="d">-        }
</a><a href="#h6-0-725" id="h6-0-725" class="d">-        self.columns.get(index).cloned().ok_or(errinput!(&quot;column index {index} not found&quot;))
</a><a href="#h6-0-726" id="h6-0-726" class="d">-    }
</a><a href="#h6-0-727" id="h6-0-727" class="d">-
</a><a href="#h6-0-728" id="h6-0-728" class="d">-    /// Fetches a column label by index, if any.
</a><a href="#h6-0-729" id="h6-0-729" class="d">-    fn get_label(&amp;self, index: usize) -&gt; Result&lt;Option&lt;(Option&lt;String&gt;, String)&gt;&gt; {
</a><a href="#h6-0-730" id="h6-0-730" class="d">-        Ok(match self.get_column(index)? {
</a><a href="#h6-0-731" id="h6-0-731" class="d">-            (table, Some(name)) =&gt; Some((table, name)),
</a><a href="#h6-0-732" id="h6-0-732" class="d">-            _ =&gt; None,
</a><a href="#h6-0-733" id="h6-0-733" class="d">-        })
</a><a href="#h6-0-734" id="h6-0-734" class="d">-    }
</a><a href="#h6-0-735" id="h6-0-735" class="d">-
</a><a href="#h6-0-736" id="h6-0-736" class="d">-    /// Merges two scopes, by appending the given scope to self.
</a><a href="#h6-0-737" id="h6-0-737" class="d">-    fn merge(&amp;mut self, scope: Scope) -&gt; Result&lt;()&gt; {
</a><a href="#h6-0-738" id="h6-0-738" class="d">-        if self.constant {
</a><a href="#h6-0-739" id="h6-0-739" class="d">-            panic!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h6-0-740" id="h6-0-740" class="d">-        }
</a><a href="#h6-0-741" id="h6-0-741" class="d">-        for (label, table) in scope.tables {
</a><a href="#h6-0-742" id="h6-0-742" class="d">-            if self.tables.contains_key(&amp;label) {
</a><a href="#h6-0-743" id="h6-0-743" class="d">-                return errinput!(&quot;duplicate table name {label}&quot;);
</a><a href="#h6-0-744" id="h6-0-744" class="d">-            }
</a><a href="#h6-0-745" id="h6-0-745" class="d">-            self.tables.insert(label, table);
</a><a href="#h6-0-746" id="h6-0-746" class="d">-        }
</a><a href="#h6-0-747" id="h6-0-747" class="d">-        for (table, label) in scope.columns {
</a><a href="#h6-0-748" id="h6-0-748" class="d">-            self.add_column(table, label);
</a><a href="#h6-0-749" id="h6-0-749" class="d">-        }
</a><a href="#h6-0-750" id="h6-0-750" class="d">-        Ok(())
</a><a href="#h6-0-751" id="h6-0-751" class="d">-    }
</a><a href="#h6-0-752" id="h6-0-752" class="d">-
</a><a href="#h6-0-753" id="h6-0-753" class="d">-    /// Resolves a name, optionally qualified by a table name.
</a><a href="#h6-0-754" id="h6-0-754" class="d">-    fn resolve(&amp;self, table: Option&lt;&amp;str&gt;, name: &amp;str) -&gt; Result&lt;usize&gt; {
</a><a href="#h6-0-755" id="h6-0-755" class="d">-        if self.constant {
</a><a href="#h6-0-756" id="h6-0-756" class="d">-            return errinput!(
</a><a href="#h6-0-757" id="h6-0-757" class="d">-                &quot;expression must be constant, found field {}&quot;,
</a><a href="#h6-0-758" id="h6-0-758" class="d">-                if let Some(table) = table { format!(&quot;{}.{}&quot;, table, name) } else { name.into() }
</a><a href="#h6-0-759" id="h6-0-759" class="d">-            );
</a><a href="#h6-0-760" id="h6-0-760" class="d">-        }
</a><a href="#h6-0-761" id="h6-0-761" class="d">-        if let Some(table) = table {
</a><a href="#h6-0-762" id="h6-0-762" class="d">-            if !self.tables.contains_key(table) {
</a><a href="#h6-0-763" id="h6-0-763" class="d">-                return errinput!(&quot;unknown table {table}&quot;);
</a><a href="#h6-0-764" id="h6-0-764" class="d">-            }
</a><a href="#h6-0-765" id="h6-0-765" class="d">-            self.qualified
</a><a href="#h6-0-766" id="h6-0-766" class="d">-                .get(&amp;(table.into(), name.into()))
</a><a href="#h6-0-767" id="h6-0-767" class="d">-                .copied()
</a><a href="#h6-0-768" id="h6-0-768" class="d">-                .ok_or(errinput!(&quot;Unknown field {table}.{name}&quot;))
</a><a href="#h6-0-769" id="h6-0-769" class="d">-        } else if self.ambiguous.contains(name) {
</a><a href="#h6-0-770" id="h6-0-770" class="d">-            errinput!(&quot;ambiguous field {name}&quot;)
</a><a href="#h6-0-771" id="h6-0-771" class="d">-        } else {
</a><a href="#h6-0-772" id="h6-0-772" class="d">-            self.unqualified.get(name).copied().ok_or(errinput!(&quot;unknown field {name}&quot;))
</a><a href="#h6-0-773" id="h6-0-773" class="d">-        }
</a><a href="#h6-0-774" id="h6-0-774" class="d">-    }
</a><a href="#h6-0-775" id="h6-0-775" class="d">-
</a><a href="#h6-0-776" id="h6-0-776" class="d">-    /// Number of columns in the current scope.
</a><a href="#h6-0-777" id="h6-0-777" class="d">-    fn len(&amp;self) -&gt; usize {
</a><a href="#h6-0-778" id="h6-0-778" class="d">-        self.columns.len()
</a><a href="#h6-0-779" id="h6-0-779" class="d">-    }
</a><a href="#h6-0-780" id="h6-0-780" class="d">-
</a><a href="#h6-0-781" id="h6-0-781" class="d">-    /// Projects the scope. This takes a set of expressions and labels in the current scope,
</a><a href="#h6-0-782" id="h6-0-782" class="d">-    /// and returns a new scope for the projection.
</a><a href="#h6-0-783" id="h6-0-783" class="d">-    fn project(&amp;mut self, projection: &amp;[(Expression, Option&lt;String&gt;)]) -&gt; Result&lt;()&gt; {
</a><a href="#h6-0-784" id="h6-0-784" class="d">-        if self.constant {
</a><a href="#h6-0-785" id="h6-0-785" class="d">-            panic!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h6-0-786" id="h6-0-786" class="d">-        }
</a><a href="#h6-0-787" id="h6-0-787" class="d">-        let mut new = Self::new();
</a><a href="#h6-0-788" id="h6-0-788" class="d">-        new.tables = self.tables.clone();
</a><a href="#h6-0-789" id="h6-0-789" class="d">-        for (expr, label) in projection {
</a><a href="#h6-0-790" id="h6-0-790" class="d">-            match (expr, label) {
</a><a href="#h6-0-791" id="h6-0-791" class="d">-                (_, Some(label)) =&gt; new.add_column(None, Some(label.clone())),
</a><a href="#h6-0-792" id="h6-0-792" class="d">-                (Expression::Field(_, Some((Some(table), name))), _) =&gt; {
</a><a href="#h6-0-793" id="h6-0-793" class="d">-                    new.add_column(Some(table.clone()), Some(name.clone()))
</a><a href="#h6-0-794" id="h6-0-794" class="d">-                }
</a><a href="#h6-0-795" id="h6-0-795" class="d">-                (Expression::Field(_, Some((None, name))), _) =&gt; {
</a><a href="#h6-0-796" id="h6-0-796" class="d">-                    if let Some(i) = self.unqualified.get(name) {
</a><a href="#h6-0-797" id="h6-0-797" class="d">-                        let (table, name) = self.columns[*i].clone();
</a><a href="#h6-0-798" id="h6-0-798" class="d">-                        new.add_column(table, name);
</a><a href="#h6-0-799" id="h6-0-799" class="d">-                    }
</a><a href="#h6-0-800" id="h6-0-800" class="d">-                }
</a><a href="#h6-0-801" id="h6-0-801" class="d">-                (Expression::Field(i, None), _) =&gt; {
</a><a href="#h6-0-802" id="h6-0-802" class="d">-                    let (table, label) = self.columns.get(*i).cloned().unwrap_or((None, None));
</a><a href="#h6-0-803" id="h6-0-803" class="d">-                    new.add_column(table, label)
</a><a href="#h6-0-804" id="h6-0-804" class="d">-                }
</a><a href="#h6-0-805" id="h6-0-805" class="d">-                _ =&gt; new.add_column(None, None),
</a><a href="#h6-0-806" id="h6-0-806" class="d">-            }
</a><a href="#h6-0-807" id="h6-0-807" class="d">-        }
</a><a href="#h6-0-808" id="h6-0-808" class="d">-        *self = new;
</a><a href="#h6-0-809" id="h6-0-809" class="d">-        Ok(())
</a><a href="#h6-0-810" id="h6-0-810" class="d">-    }
</a><a href="#h6-0-811" id="h6-0-811" class="d">-}
</a><b>diff --git a/<a id="h7" href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a> b/<a href="../file/src/sql/planner/mod.rs.html">src/sql/planner/mod.rs</a></b>
<b>diff --git a/<a id="h8" href="../file/src/sql/plan/optimizer.rs.html">src/sql/plan/optimizer.rs</a> b/<a href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a></b>
<b>diff --git a/<a id="h9" href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a> b/<a href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -0,0 +1,444 @@
</a><a href="#h9-0-0" id="h9-0-0" class="i">+use super::optimizer::{self, Optimizer as _};
</a><a href="#h9-0-1" id="h9-0-1" class="i">+use super::planner::Planner;
</a><a href="#h9-0-2" id="h9-0-2" class="i">+use crate::error::Result;
</a><a href="#h9-0-3" id="h9-0-3" class="i">+use crate::sql::engine::{Catalog, Transaction};
</a><a href="#h9-0-4" id="h9-0-4" class="i">+use crate::sql::execution::{self, ExecutionResult};
</a><a href="#h9-0-5" id="h9-0-5" class="i">+use crate::sql::parser::ast;
</a><a href="#h9-0-6" id="h9-0-6" class="i">+use crate::sql::types::{Expression, Table, Value};
</a><a href="#h9-0-7" id="h9-0-7" class="i">+
</a><a href="#h9-0-8" id="h9-0-8" class="i">+use serde::{Deserialize, Serialize};
</a><a href="#h9-0-9" id="h9-0-9" class="i">+
</a><a href="#h9-0-10" id="h9-0-10" class="i">+/// A statement execution plan. These are mostly made up of nested query plan
</a><a href="#h9-0-11" id="h9-0-11" class="i">+/// Nodes, which stream rows, but the root nodes can also perform data
</a><a href="#h9-0-12" id="h9-0-12" class="i">+/// modifications or schema changes.
</a><a href="#h9-0-13" id="h9-0-13" class="i">+#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h9-0-14" id="h9-0-14" class="i">+pub enum Plan {
</a><a href="#h9-0-15" id="h9-0-15" class="i">+    /// A CREATE TABLE plan.
</a><a href="#h9-0-16" id="h9-0-16" class="i">+    CreateTable { schema: Table },
</a><a href="#h9-0-17" id="h9-0-17" class="i">+    /// A DROP TABLE plan.
</a><a href="#h9-0-18" id="h9-0-18" class="i">+    DropTable { table: String, if_exists: bool },
</a><a href="#h9-0-19" id="h9-0-19" class="i">+    /// A DELETE plan.
</a><a href="#h9-0-20" id="h9-0-20" class="i">+    Delete { table: String, key_index: usize, source: Node },
</a><a href="#h9-0-21" id="h9-0-21" class="i">+    /// An INSERT plan.
</a><a href="#h9-0-22" id="h9-0-22" class="i">+    /// TODO: consider using a source which generates expression rows.
</a><a href="#h9-0-23" id="h9-0-23" class="i">+    Insert { table: Table, columns: Vec&lt;String&gt;, expressions: Vec&lt;Vec&lt;Expression&gt;&gt; },
</a><a href="#h9-0-24" id="h9-0-24" class="i">+    /// An UPDATE plan.
</a><a href="#h9-0-25" id="h9-0-25" class="i">+    Update {
</a><a href="#h9-0-26" id="h9-0-26" class="i">+        table: String,
</a><a href="#h9-0-27" id="h9-0-27" class="i">+        key_index: usize,
</a><a href="#h9-0-28" id="h9-0-28" class="i">+        source: Node,
</a><a href="#h9-0-29" id="h9-0-29" class="i">+        expressions: Vec&lt;(usize, Option&lt;String&gt;, Expression)&gt;,
</a><a href="#h9-0-30" id="h9-0-30" class="i">+    },
</a><a href="#h9-0-31" id="h9-0-31" class="i">+    /// A SELECT plan.
</a><a href="#h9-0-32" id="h9-0-32" class="i">+    Select(Node),
</a><a href="#h9-0-33" id="h9-0-33" class="i">+}
</a><a href="#h9-0-34" id="h9-0-34" class="i">+
</a><a href="#h9-0-35" id="h9-0-35" class="i">+impl Plan {
</a><a href="#h9-0-36" id="h9-0-36" class="i">+    /// Builds a plan from an AST statement.
</a><a href="#h9-0-37" id="h9-0-37" class="i">+    pub fn build(statement: ast::Statement, catalog: &amp;impl Catalog) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-0-38" id="h9-0-38" class="i">+        Planner::new(catalog).build(statement)
</a><a href="#h9-0-39" id="h9-0-39" class="i">+    }
</a><a href="#h9-0-40" id="h9-0-40" class="i">+
</a><a href="#h9-0-41" id="h9-0-41" class="i">+    /// Executes the plan, consuming it.
</a><a href="#h9-0-42" id="h9-0-42" class="i">+    pub fn execute(self, txn: &amp;(impl Transaction + Catalog)) -&gt; Result&lt;ExecutionResult&gt; {
</a><a href="#h9-0-43" id="h9-0-43" class="i">+        execution::execute_plan(self, txn, txn)
</a><a href="#h9-0-44" id="h9-0-44" class="i">+    }
</a><a href="#h9-0-45" id="h9-0-45" class="i">+
</a><a href="#h9-0-46" id="h9-0-46" class="i">+    /// Optimizes the plan, consuming it.
</a><a href="#h9-0-47" id="h9-0-47" class="i">+    pub fn optimize(self) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-0-48" id="h9-0-48" class="i">+        let optimize = |mut node| -&gt; Result&lt;Node&gt; {
</a><a href="#h9-0-49" id="h9-0-49" class="i">+            node = optimizer::ConstantFolder.optimize(node)?;
</a><a href="#h9-0-50" id="h9-0-50" class="i">+            node = optimizer::FilterPushdown.optimize(node)?;
</a><a href="#h9-0-51" id="h9-0-51" class="i">+            node = optimizer::IndexLookup.optimize(node)?;
</a><a href="#h9-0-52" id="h9-0-52" class="i">+            node = optimizer::NoopCleaner.optimize(node)?;
</a><a href="#h9-0-53" id="h9-0-53" class="i">+            node = optimizer::JoinType.optimize(node)?;
</a><a href="#h9-0-54" id="h9-0-54" class="i">+            Ok(node)
</a><a href="#h9-0-55" id="h9-0-55" class="i">+        };
</a><a href="#h9-0-56" id="h9-0-56" class="i">+        Ok(match self {
</a><a href="#h9-0-57" id="h9-0-57" class="i">+            Self::CreateTable { .. } | Self::DropTable { .. } | Self::Insert { .. } =&gt; self,
</a><a href="#h9-0-58" id="h9-0-58" class="i">+            Self::Delete { table, key_index, source } =&gt; {
</a><a href="#h9-0-59" id="h9-0-59" class="i">+                Self::Delete { table, key_index, source: optimize(source)? }
</a><a href="#h9-0-60" id="h9-0-60" class="i">+            }
</a><a href="#h9-0-61" id="h9-0-61" class="i">+            Self::Update { table, key_index, source, expressions } =&gt; {
</a><a href="#h9-0-62" id="h9-0-62" class="i">+                Self::Update { table, key_index, source: optimize(source)?, expressions }
</a><a href="#h9-0-63" id="h9-0-63" class="i">+            }
</a><a href="#h9-0-64" id="h9-0-64" class="i">+            Self::Select(root) =&gt; Self::Select(optimize(root)?),
</a><a href="#h9-0-65" id="h9-0-65" class="i">+        })
</a><a href="#h9-0-66" id="h9-0-66" class="i">+    }
</a><a href="#h9-0-67" id="h9-0-67" class="i">+}
</a><a href="#h9-0-68" id="h9-0-68" class="i">+
</a><a href="#h9-0-69" id="h9-0-69" class="i">+// TODO: this needs testing and cleaning up.
</a><a href="#h9-0-70" id="h9-0-70" class="i">+impl std::fmt::Display for Plan {
</a><a href="#h9-0-71" id="h9-0-71" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h9-0-72" id="h9-0-72" class="i">+        match self {
</a><a href="#h9-0-73" id="h9-0-73" class="i">+            Self::CreateTable { schema } =&gt; write!(f, &quot;CreateTable: {}&quot;, schema.name),
</a><a href="#h9-0-74" id="h9-0-74" class="i">+            Self::DropTable { table, if_exists: _ } =&gt; write!(f, &quot;DropTable: {table}&quot;),
</a><a href="#h9-0-75" id="h9-0-75" class="i">+            Self::Delete { table, key_index: _, source } =&gt; {
</a><a href="#h9-0-76" id="h9-0-76" class="i">+                write!(
</a><a href="#h9-0-77" id="h9-0-77" class="i">+                    f,
</a><a href="#h9-0-78" id="h9-0-78" class="i">+                    &quot;Delete: {table}\n{}&quot;,
</a><a href="#h9-0-79" id="h9-0-79" class="i">+                    source.format(String::new(), false, true).trim_end()
</a><a href="#h9-0-80" id="h9-0-80" class="i">+                )
</a><a href="#h9-0-81" id="h9-0-81" class="i">+            }
</a><a href="#h9-0-82" id="h9-0-82" class="i">+            Self::Insert { table, columns: _, expressions } =&gt; {
</a><a href="#h9-0-83" id="h9-0-83" class="i">+                write!(f, &quot;Insert: {} ({} rows)&quot;, table.name, expressions.len())
</a><a href="#h9-0-84" id="h9-0-84" class="i">+            }
</a><a href="#h9-0-85" id="h9-0-85" class="i">+            Self::Select(root) =&gt; root.fmt(f),
</a><a href="#h9-0-86" id="h9-0-86" class="i">+            Self::Update { table, key_index: _, source, expressions } =&gt; {
</a><a href="#h9-0-87" id="h9-0-87" class="i">+                write!(
</a><a href="#h9-0-88" id="h9-0-88" class="i">+                    f,
</a><a href="#h9-0-89" id="h9-0-89" class="i">+                    &quot;Update: {table} ({})\n{}&quot;,
</a><a href="#h9-0-90" id="h9-0-90" class="i">+                    expressions
</a><a href="#h9-0-91" id="h9-0-91" class="i">+                        .iter()
</a><a href="#h9-0-92" id="h9-0-92" class="i">+                        .map(|(i, l, e)| format!(
</a><a href="#h9-0-93" id="h9-0-93" class="i">+                            &quot;{}={}&quot;,
</a><a href="#h9-0-94" id="h9-0-94" class="i">+                            l.clone().unwrap_or_else(|| format!(&quot;#{}&quot;, i)),
</a><a href="#h9-0-95" id="h9-0-95" class="i">+                            e
</a><a href="#h9-0-96" id="h9-0-96" class="i">+                        ))
</a><a href="#h9-0-97" id="h9-0-97" class="i">+                        .collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h9-0-98" id="h9-0-98" class="i">+                        .join(&quot;,&quot;),
</a><a href="#h9-0-99" id="h9-0-99" class="i">+                    source.format(String::new(), false, true).trim_end()
</a><a href="#h9-0-100" id="h9-0-100" class="i">+                )
</a><a href="#h9-0-101" id="h9-0-101" class="i">+            }
</a><a href="#h9-0-102" id="h9-0-102" class="i">+        }
</a><a href="#h9-0-103" id="h9-0-103" class="i">+    }
</a><a href="#h9-0-104" id="h9-0-104" class="i">+}
</a><a href="#h9-0-105" id="h9-0-105" class="i">+
</a><a href="#h9-0-106" id="h9-0-106" class="i">+/// A query plan node. These return row iterators and can be nested.
</a><a href="#h9-0-107" id="h9-0-107" class="i">+#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h9-0-108" id="h9-0-108" class="i">+pub enum Node {
</a><a href="#h9-0-109" id="h9-0-109" class="i">+    Aggregation {
</a><a href="#h9-0-110" id="h9-0-110" class="i">+        source: Box&lt;Node&gt;,
</a><a href="#h9-0-111" id="h9-0-111" class="i">+        aggregates: Vec&lt;Aggregate&gt;,
</a><a href="#h9-0-112" id="h9-0-112" class="i">+    },
</a><a href="#h9-0-113" id="h9-0-113" class="i">+    Filter {
</a><a href="#h9-0-114" id="h9-0-114" class="i">+        source: Box&lt;Node&gt;,
</a><a href="#h9-0-115" id="h9-0-115" class="i">+        predicate: Expression,
</a><a href="#h9-0-116" id="h9-0-116" class="i">+    },
</a><a href="#h9-0-117" id="h9-0-117" class="i">+    HashJoin {
</a><a href="#h9-0-118" id="h9-0-118" class="i">+        left: Box&lt;Node&gt;,
</a><a href="#h9-0-119" id="h9-0-119" class="i">+        left_field: (usize, Option&lt;(Option&lt;String&gt;, String)&gt;),
</a><a href="#h9-0-120" id="h9-0-120" class="i">+        right: Box&lt;Node&gt;,
</a><a href="#h9-0-121" id="h9-0-121" class="i">+        right_field: (usize, Option&lt;(Option&lt;String&gt;, String)&gt;),
</a><a href="#h9-0-122" id="h9-0-122" class="i">+        outer: bool,
</a><a href="#h9-0-123" id="h9-0-123" class="i">+    },
</a><a href="#h9-0-124" id="h9-0-124" class="i">+    IndexLookup {
</a><a href="#h9-0-125" id="h9-0-125" class="i">+        table: Table,
</a><a href="#h9-0-126" id="h9-0-126" class="i">+        alias: Option&lt;String&gt;,
</a><a href="#h9-0-127" id="h9-0-127" class="i">+        column: String,
</a><a href="#h9-0-128" id="h9-0-128" class="i">+        values: Vec&lt;Value&gt;,
</a><a href="#h9-0-129" id="h9-0-129" class="i">+    },
</a><a href="#h9-0-130" id="h9-0-130" class="i">+    KeyLookup {
</a><a href="#h9-0-131" id="h9-0-131" class="i">+        table: Table,
</a><a href="#h9-0-132" id="h9-0-132" class="i">+        alias: Option&lt;String&gt;,
</a><a href="#h9-0-133" id="h9-0-133" class="i">+        keys: Vec&lt;Value&gt;,
</a><a href="#h9-0-134" id="h9-0-134" class="i">+    },
</a><a href="#h9-0-135" id="h9-0-135" class="i">+    Limit {
</a><a href="#h9-0-136" id="h9-0-136" class="i">+        source: Box&lt;Node&gt;,
</a><a href="#h9-0-137" id="h9-0-137" class="i">+        limit: u64,
</a><a href="#h9-0-138" id="h9-0-138" class="i">+    },
</a><a href="#h9-0-139" id="h9-0-139" class="i">+    NestedLoopJoin {
</a><a href="#h9-0-140" id="h9-0-140" class="i">+        left: Box&lt;Node&gt;,
</a><a href="#h9-0-141" id="h9-0-141" class="i">+        left_size: usize,
</a><a href="#h9-0-142" id="h9-0-142" class="i">+        right: Box&lt;Node&gt;,
</a><a href="#h9-0-143" id="h9-0-143" class="i">+        predicate: Option&lt;Expression&gt;,
</a><a href="#h9-0-144" id="h9-0-144" class="i">+        outer: bool,
</a><a href="#h9-0-145" id="h9-0-145" class="i">+    },
</a><a href="#h9-0-146" id="h9-0-146" class="i">+    Nothing,
</a><a href="#h9-0-147" id="h9-0-147" class="i">+    Offset {
</a><a href="#h9-0-148" id="h9-0-148" class="i">+        source: Box&lt;Node&gt;,
</a><a href="#h9-0-149" id="h9-0-149" class="i">+        offset: u64,
</a><a href="#h9-0-150" id="h9-0-150" class="i">+    },
</a><a href="#h9-0-151" id="h9-0-151" class="i">+    Order {
</a><a href="#h9-0-152" id="h9-0-152" class="i">+        source: Box&lt;Node&gt;,
</a><a href="#h9-0-153" id="h9-0-153" class="i">+        orders: Vec&lt;(Expression, Direction)&gt;,
</a><a href="#h9-0-154" id="h9-0-154" class="i">+    },
</a><a href="#h9-0-155" id="h9-0-155" class="i">+    Projection {
</a><a href="#h9-0-156" id="h9-0-156" class="i">+        source: Box&lt;Node&gt;,
</a><a href="#h9-0-157" id="h9-0-157" class="i">+        expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h9-0-158" id="h9-0-158" class="i">+    },
</a><a href="#h9-0-159" id="h9-0-159" class="i">+    Scan {
</a><a href="#h9-0-160" id="h9-0-160" class="i">+        table: Table,
</a><a href="#h9-0-161" id="h9-0-161" class="i">+        alias: Option&lt;String&gt;,
</a><a href="#h9-0-162" id="h9-0-162" class="i">+        filter: Option&lt;Expression&gt;,
</a><a href="#h9-0-163" id="h9-0-163" class="i">+    },
</a><a href="#h9-0-164" id="h9-0-164" class="i">+}
</a><a href="#h9-0-165" id="h9-0-165" class="i">+
</a><a href="#h9-0-166" id="h9-0-166" class="i">+impl Node {
</a><a href="#h9-0-167" id="h9-0-167" class="i">+    /// Recursively transforms query nodes by applying the given closures before
</a><a href="#h9-0-168" id="h9-0-168" class="i">+    /// and after descending.
</a><a href="#h9-0-169" id="h9-0-169" class="i">+    pub fn transform&lt;B, A&gt;(mut self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
</a><a href="#h9-0-170" id="h9-0-170" class="i">+    where
</a><a href="#h9-0-171" id="h9-0-171" class="i">+        B: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h9-0-172" id="h9-0-172" class="i">+        A: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h9-0-173" id="h9-0-173" class="i">+    {
</a><a href="#h9-0-174" id="h9-0-174" class="i">+        self = before(self)?;
</a><a href="#h9-0-175" id="h9-0-175" class="i">+        self = match self {
</a><a href="#h9-0-176" id="h9-0-176" class="i">+            node @ Self::IndexLookup { .. }
</a><a href="#h9-0-177" id="h9-0-177" class="i">+            | node @ Self::KeyLookup { .. }
</a><a href="#h9-0-178" id="h9-0-178" class="i">+            | node @ Self::Nothing
</a><a href="#h9-0-179" id="h9-0-179" class="i">+            | node @ Self::Scan { .. } =&gt; node,
</a><a href="#h9-0-180" id="h9-0-180" class="i">+
</a><a href="#h9-0-181" id="h9-0-181" class="i">+            Self::Aggregation { source, aggregates } =&gt; {
</a><a href="#h9-0-182" id="h9-0-182" class="i">+                Self::Aggregation { source: source.transform(before, after)?.into(), aggregates }
</a><a href="#h9-0-183" id="h9-0-183" class="i">+            }
</a><a href="#h9-0-184" id="h9-0-184" class="i">+            Self::Filter { source, predicate } =&gt; {
</a><a href="#h9-0-185" id="h9-0-185" class="i">+                Self::Filter { source: source.transform(before, after)?.into(), predicate }
</a><a href="#h9-0-186" id="h9-0-186" class="i">+            }
</a><a href="#h9-0-187" id="h9-0-187" class="i">+            Self::HashJoin { left, left_field, right, right_field, outer } =&gt; Self::HashJoin {
</a><a href="#h9-0-188" id="h9-0-188" class="i">+                left: left.transform(before, after)?.into(),
</a><a href="#h9-0-189" id="h9-0-189" class="i">+                left_field,
</a><a href="#h9-0-190" id="h9-0-190" class="i">+                right: right.transform(before, after)?.into(),
</a><a href="#h9-0-191" id="h9-0-191" class="i">+                right_field,
</a><a href="#h9-0-192" id="h9-0-192" class="i">+                outer,
</a><a href="#h9-0-193" id="h9-0-193" class="i">+            },
</a><a href="#h9-0-194" id="h9-0-194" class="i">+            Self::Limit { source, limit } =&gt; {
</a><a href="#h9-0-195" id="h9-0-195" class="i">+                Self::Limit { source: source.transform(before, after)?.into(), limit }
</a><a href="#h9-0-196" id="h9-0-196" class="i">+            }
</a><a href="#h9-0-197" id="h9-0-197" class="i">+            Self::NestedLoopJoin { left, left_size, right, predicate, outer } =&gt; {
</a><a href="#h9-0-198" id="h9-0-198" class="i">+                Self::NestedLoopJoin {
</a><a href="#h9-0-199" id="h9-0-199" class="i">+                    left: left.transform(before, after)?.into(),
</a><a href="#h9-0-200" id="h9-0-200" class="i">+                    left_size,
</a><a href="#h9-0-201" id="h9-0-201" class="i">+                    right: right.transform(before, after)?.into(),
</a><a href="#h9-0-202" id="h9-0-202" class="i">+                    predicate,
</a><a href="#h9-0-203" id="h9-0-203" class="i">+                    outer,
</a><a href="#h9-0-204" id="h9-0-204" class="i">+                }
</a><a href="#h9-0-205" id="h9-0-205" class="i">+            }
</a><a href="#h9-0-206" id="h9-0-206" class="i">+            Self::Offset { source, offset } =&gt; {
</a><a href="#h9-0-207" id="h9-0-207" class="i">+                Self::Offset { source: source.transform(before, after)?.into(), offset }
</a><a href="#h9-0-208" id="h9-0-208" class="i">+            }
</a><a href="#h9-0-209" id="h9-0-209" class="i">+            Self::Order { source, orders } =&gt; {
</a><a href="#h9-0-210" id="h9-0-210" class="i">+                Self::Order { source: source.transform(before, after)?.into(), orders }
</a><a href="#h9-0-211" id="h9-0-211" class="i">+            }
</a><a href="#h9-0-212" id="h9-0-212" class="i">+            Self::Projection { source, expressions } =&gt; {
</a><a href="#h9-0-213" id="h9-0-213" class="i">+                Self::Projection { source: source.transform(before, after)?.into(), expressions }
</a><a href="#h9-0-214" id="h9-0-214" class="i">+            }
</a><a href="#h9-0-215" id="h9-0-215" class="i">+        };
</a><a href="#h9-0-216" id="h9-0-216" class="i">+        after(self)
</a><a href="#h9-0-217" id="h9-0-217" class="i">+    }
</a><a href="#h9-0-218" id="h9-0-218" class="i">+
</a><a href="#h9-0-219" id="h9-0-219" class="i">+    /// Recursively transforms all expressions in a node by calling the given closures
</a><a href="#h9-0-220" id="h9-0-220" class="i">+    /// on them before and after descending.
</a><a href="#h9-0-221" id="h9-0-221" class="i">+    pub fn transform_expressions&lt;B, A&gt;(self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
</a><a href="#h9-0-222" id="h9-0-222" class="i">+    where
</a><a href="#h9-0-223" id="h9-0-223" class="i">+        B: Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h9-0-224" id="h9-0-224" class="i">+        A: Fn(Expression) -&gt; Result&lt;Expression&gt;,
</a><a href="#h9-0-225" id="h9-0-225" class="i">+    {
</a><a href="#h9-0-226" id="h9-0-226" class="i">+        Ok(match self {
</a><a href="#h9-0-227" id="h9-0-227" class="i">+            node @ Self::Aggregation { .. }
</a><a href="#h9-0-228" id="h9-0-228" class="i">+            | node @ Self::HashJoin { .. }
</a><a href="#h9-0-229" id="h9-0-229" class="i">+            | node @ Self::IndexLookup { .. }
</a><a href="#h9-0-230" id="h9-0-230" class="i">+            | node @ Self::KeyLookup { .. }
</a><a href="#h9-0-231" id="h9-0-231" class="i">+            | node @ Self::Limit { .. }
</a><a href="#h9-0-232" id="h9-0-232" class="i">+            | node @ Self::NestedLoopJoin { predicate: None, .. }
</a><a href="#h9-0-233" id="h9-0-233" class="i">+            | node @ Self::Nothing
</a><a href="#h9-0-234" id="h9-0-234" class="i">+            | node @ Self::Offset { .. }
</a><a href="#h9-0-235" id="h9-0-235" class="i">+            | node @ Self::Scan { filter: None, .. } =&gt; node,
</a><a href="#h9-0-236" id="h9-0-236" class="i">+
</a><a href="#h9-0-237" id="h9-0-237" class="i">+            Self::Filter { source, predicate } =&gt; {
</a><a href="#h9-0-238" id="h9-0-238" class="i">+                Self::Filter { source, predicate: predicate.transform(before, after)? }
</a><a href="#h9-0-239" id="h9-0-239" class="i">+            }
</a><a href="#h9-0-240" id="h9-0-240" class="i">+            Self::Order { source, orders } =&gt; Self::Order {
</a><a href="#h9-0-241" id="h9-0-241" class="i">+                source,
</a><a href="#h9-0-242" id="h9-0-242" class="i">+                orders: orders
</a><a href="#h9-0-243" id="h9-0-243" class="i">+                    .into_iter()
</a><a href="#h9-0-244" id="h9-0-244" class="i">+                    .map(|(e, o)| e.transform(before, after).map(|e| (e, o)))
</a><a href="#h9-0-245" id="h9-0-245" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h9-0-246" id="h9-0-246" class="i">+            },
</a><a href="#h9-0-247" id="h9-0-247" class="i">+            Self::NestedLoopJoin { left, left_size, right, predicate: Some(predicate), outer } =&gt; {
</a><a href="#h9-0-248" id="h9-0-248" class="i">+                Self::NestedLoopJoin {
</a><a href="#h9-0-249" id="h9-0-249" class="i">+                    left,
</a><a href="#h9-0-250" id="h9-0-250" class="i">+                    left_size,
</a><a href="#h9-0-251" id="h9-0-251" class="i">+                    right,
</a><a href="#h9-0-252" id="h9-0-252" class="i">+                    predicate: Some(predicate.transform(before, after)?),
</a><a href="#h9-0-253" id="h9-0-253" class="i">+                    outer,
</a><a href="#h9-0-254" id="h9-0-254" class="i">+                }
</a><a href="#h9-0-255" id="h9-0-255" class="i">+            }
</a><a href="#h9-0-256" id="h9-0-256" class="i">+            Self::Projection { source, expressions } =&gt; Self::Projection {
</a><a href="#h9-0-257" id="h9-0-257" class="i">+                source,
</a><a href="#h9-0-258" id="h9-0-258" class="i">+                expressions: expressions
</a><a href="#h9-0-259" id="h9-0-259" class="i">+                    .into_iter()
</a><a href="#h9-0-260" id="h9-0-260" class="i">+                    .map(|(e, l)| Ok((e.transform(before, after)?, l)))
</a><a href="#h9-0-261" id="h9-0-261" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h9-0-262" id="h9-0-262" class="i">+            },
</a><a href="#h9-0-263" id="h9-0-263" class="i">+            Self::Scan { table, alias, filter: Some(filter) } =&gt; {
</a><a href="#h9-0-264" id="h9-0-264" class="i">+                Self::Scan { table, alias, filter: Some(filter.transform(before, after)?) }
</a><a href="#h9-0-265" id="h9-0-265" class="i">+            }
</a><a href="#h9-0-266" id="h9-0-266" class="i">+        })
</a><a href="#h9-0-267" id="h9-0-267" class="i">+    }
</a><a href="#h9-0-268" id="h9-0-268" class="i">+
</a><a href="#h9-0-269" id="h9-0-269" class="i">+    // Displays the node, where prefix gives the node prefix.
</a><a href="#h9-0-270" id="h9-0-270" class="i">+    pub fn format(&amp;self, mut indent: String, root: bool, last: bool) -&gt; String {
</a><a href="#h9-0-271" id="h9-0-271" class="i">+        // TODO: indent should be &amp;str or int.
</a><a href="#h9-0-272" id="h9-0-272" class="i">+        let mut s = indent.clone();
</a><a href="#h9-0-273" id="h9-0-273" class="i">+        if !last {
</a><a href="#h9-0-274" id="h9-0-274" class="i">+            s += &quot;├─ &quot;;
</a><a href="#h9-0-275" id="h9-0-275" class="i">+            indent += &quot;│  &quot;
</a><a href="#h9-0-276" id="h9-0-276" class="i">+        } else if !root {
</a><a href="#h9-0-277" id="h9-0-277" class="i">+            s += &quot;└─ &quot;;
</a><a href="#h9-0-278" id="h9-0-278" class="i">+            indent += &quot;   &quot;;
</a><a href="#h9-0-279" id="h9-0-279" class="i">+        }
</a><a href="#h9-0-280" id="h9-0-280" class="i">+        match self {
</a><a href="#h9-0-281" id="h9-0-281" class="i">+            Self::Aggregation { source, aggregates } =&gt; {
</a><a href="#h9-0-282" id="h9-0-282" class="i">+                s += &amp;format!(
</a><a href="#h9-0-283" id="h9-0-283" class="i">+                    &quot;Aggregation: {}\n&quot;,
</a><a href="#h9-0-284" id="h9-0-284" class="i">+                    aggregates.iter().map(|a| a.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h9-0-285" id="h9-0-285" class="i">+                );
</a><a href="#h9-0-286" id="h9-0-286" class="i">+                s += &amp;source.format(indent, false, true);
</a><a href="#h9-0-287" id="h9-0-287" class="i">+            }
</a><a href="#h9-0-288" id="h9-0-288" class="i">+            Self::Filter { source, predicate } =&gt; {
</a><a href="#h9-0-289" id="h9-0-289" class="i">+                s += &amp;format!(&quot;Filter: {}\n&quot;, predicate);
</a><a href="#h9-0-290" id="h9-0-290" class="i">+                s += &amp;source.format(indent, false, true);
</a><a href="#h9-0-291" id="h9-0-291" class="i">+            }
</a><a href="#h9-0-292" id="h9-0-292" class="i">+            Self::HashJoin { left, left_field, right, right_field, outer } =&gt; {
</a><a href="#h9-0-293" id="h9-0-293" class="i">+                s += &amp;format!(
</a><a href="#h9-0-294" id="h9-0-294" class="i">+                    &quot;HashJoin: {} on {} = {}\n&quot;,
</a><a href="#h9-0-295" id="h9-0-295" class="i">+                    if *outer { &quot;outer&quot; } else { &quot;inner&quot; },
</a><a href="#h9-0-296" id="h9-0-296" class="i">+                    match left_field {
</a><a href="#h9-0-297" id="h9-0-297" class="i">+                        (_, Some((Some(t), n))) =&gt; format!(&quot;{}.{}&quot;, t, n),
</a><a href="#h9-0-298" id="h9-0-298" class="i">+                        (_, Some((None, n))) =&gt; n.clone(),
</a><a href="#h9-0-299" id="h9-0-299" class="i">+                        (i, None) =&gt; format!(&quot;left #{}&quot;, i),
</a><a href="#h9-0-300" id="h9-0-300" class="i">+                    },
</a><a href="#h9-0-301" id="h9-0-301" class="i">+                    match right_field {
</a><a href="#h9-0-302" id="h9-0-302" class="i">+                        (_, Some((Some(t), n))) =&gt; format!(&quot;{}.{}&quot;, t, n),
</a><a href="#h9-0-303" id="h9-0-303" class="i">+                        (_, Some((None, n))) =&gt; n.clone(),
</a><a href="#h9-0-304" id="h9-0-304" class="i">+                        (i, None) =&gt; format!(&quot;right #{}&quot;, i),
</a><a href="#h9-0-305" id="h9-0-305" class="i">+                    },
</a><a href="#h9-0-306" id="h9-0-306" class="i">+                );
</a><a href="#h9-0-307" id="h9-0-307" class="i">+                s += &amp;left.format(indent.clone(), false, false);
</a><a href="#h9-0-308" id="h9-0-308" class="i">+                s += &amp;right.format(indent, false, true);
</a><a href="#h9-0-309" id="h9-0-309" class="i">+            }
</a><a href="#h9-0-310" id="h9-0-310" class="i">+            Self::IndexLookup { table, column, alias, values } =&gt; {
</a><a href="#h9-0-311" id="h9-0-311" class="i">+                s += &amp;format!(&quot;IndexLookup: {}&quot;, table.name);
</a><a href="#h9-0-312" id="h9-0-312" class="i">+                if let Some(alias) = alias {
</a><a href="#h9-0-313" id="h9-0-313" class="i">+                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h9-0-314" id="h9-0-314" class="i">+                }
</a><a href="#h9-0-315" id="h9-0-315" class="i">+                s += &amp;format!(&quot; column {}&quot;, column);
</a><a href="#h9-0-316" id="h9-0-316" class="i">+                if !values.is_empty() &amp;&amp; values.len() &lt; 10 {
</a><a href="#h9-0-317" id="h9-0-317" class="i">+                    s += &amp;format!(
</a><a href="#h9-0-318" id="h9-0-318" class="i">+                        &quot; ({})&quot;,
</a><a href="#h9-0-319" id="h9-0-319" class="i">+                        values.iter().map(|k| k.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h9-0-320" id="h9-0-320" class="i">+                    );
</a><a href="#h9-0-321" id="h9-0-321" class="i">+                } else {
</a><a href="#h9-0-322" id="h9-0-322" class="i">+                    s += &amp;format!(&quot; ({} values)&quot;, values.len());
</a><a href="#h9-0-323" id="h9-0-323" class="i">+                }
</a><a href="#h9-0-324" id="h9-0-324" class="i">+                s += &quot;\n&quot;;
</a><a href="#h9-0-325" id="h9-0-325" class="i">+            }
</a><a href="#h9-0-326" id="h9-0-326" class="i">+            Self::KeyLookup { table, alias, keys } =&gt; {
</a><a href="#h9-0-327" id="h9-0-327" class="i">+                s += &amp;format!(&quot;KeyLookup: {}&quot;, table.name);
</a><a href="#h9-0-328" id="h9-0-328" class="i">+                if let Some(alias) = alias {
</a><a href="#h9-0-329" id="h9-0-329" class="i">+                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h9-0-330" id="h9-0-330" class="i">+                }
</a><a href="#h9-0-331" id="h9-0-331" class="i">+                if !keys.is_empty() &amp;&amp; keys.len() &lt; 10 {
</a><a href="#h9-0-332" id="h9-0-332" class="i">+                    s += &amp;format!(
</a><a href="#h9-0-333" id="h9-0-333" class="i">+                        &quot; ({})&quot;,
</a><a href="#h9-0-334" id="h9-0-334" class="i">+                        keys.iter().map(|k| k.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h9-0-335" id="h9-0-335" class="i">+                    );
</a><a href="#h9-0-336" id="h9-0-336" class="i">+                } else {
</a><a href="#h9-0-337" id="h9-0-337" class="i">+                    s += &amp;format!(&quot; ({} keys)&quot;, keys.len());
</a><a href="#h9-0-338" id="h9-0-338" class="i">+                }
</a><a href="#h9-0-339" id="h9-0-339" class="i">+                s += &quot;\n&quot;;
</a><a href="#h9-0-340" id="h9-0-340" class="i">+            }
</a><a href="#h9-0-341" id="h9-0-341" class="i">+            Self::Limit { source, limit } =&gt; {
</a><a href="#h9-0-342" id="h9-0-342" class="i">+                s += &amp;format!(&quot;Limit: {}\n&quot;, limit);
</a><a href="#h9-0-343" id="h9-0-343" class="i">+                s += &amp;source.format(indent, false, true);
</a><a href="#h9-0-344" id="h9-0-344" class="i">+            }
</a><a href="#h9-0-345" id="h9-0-345" class="i">+            Self::NestedLoopJoin { left, left_size: _, right, predicate, outer } =&gt; {
</a><a href="#h9-0-346" id="h9-0-346" class="i">+                s += &amp;format!(&quot;NestedLoopJoin: {}&quot;, if *outer { &quot;outer&quot; } else { &quot;inner&quot; });
</a><a href="#h9-0-347" id="h9-0-347" class="i">+                if let Some(expr) = predicate {
</a><a href="#h9-0-348" id="h9-0-348" class="i">+                    s += &amp;format!(&quot; on {}&quot;, expr);
</a><a href="#h9-0-349" id="h9-0-349" class="i">+                }
</a><a href="#h9-0-350" id="h9-0-350" class="i">+                s += &quot;\n&quot;;
</a><a href="#h9-0-351" id="h9-0-351" class="i">+                s += &amp;left.format(indent.clone(), false, false);
</a><a href="#h9-0-352" id="h9-0-352" class="i">+                s += &amp;right.format(indent, false, true);
</a><a href="#h9-0-353" id="h9-0-353" class="i">+            }
</a><a href="#h9-0-354" id="h9-0-354" class="i">+            Self::Nothing {} =&gt; {
</a><a href="#h9-0-355" id="h9-0-355" class="i">+                s += &quot;Nothing\n&quot;;
</a><a href="#h9-0-356" id="h9-0-356" class="i">+            }
</a><a href="#h9-0-357" id="h9-0-357" class="i">+            Self::Offset { source, offset } =&gt; {
</a><a href="#h9-0-358" id="h9-0-358" class="i">+                s += &amp;format!(&quot;Offset: {}\n&quot;, offset);
</a><a href="#h9-0-359" id="h9-0-359" class="i">+                s += &amp;source.format(indent, false, true);
</a><a href="#h9-0-360" id="h9-0-360" class="i">+            }
</a><a href="#h9-0-361" id="h9-0-361" class="i">+            Self::Order { source, orders } =&gt; {
</a><a href="#h9-0-362" id="h9-0-362" class="i">+                s += &amp;format!(
</a><a href="#h9-0-363" id="h9-0-363" class="i">+                    &quot;Order: {}\n&quot;,
</a><a href="#h9-0-364" id="h9-0-364" class="i">+                    orders
</a><a href="#h9-0-365" id="h9-0-365" class="i">+                        .iter()
</a><a href="#h9-0-366" id="h9-0-366" class="i">+                        .map(|(expr, dir)| format!(&quot;{} {}&quot;, expr, dir))
</a><a href="#h9-0-367" id="h9-0-367" class="i">+                        .collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h9-0-368" id="h9-0-368" class="i">+                        .join(&quot;, &quot;)
</a><a href="#h9-0-369" id="h9-0-369" class="i">+                );
</a><a href="#h9-0-370" id="h9-0-370" class="i">+                s += &amp;source.format(indent, false, true);
</a><a href="#h9-0-371" id="h9-0-371" class="i">+            }
</a><a href="#h9-0-372" id="h9-0-372" class="i">+            Self::Projection { source, expressions } =&gt; {
</a><a href="#h9-0-373" id="h9-0-373" class="i">+                s += &amp;format!(
</a><a href="#h9-0-374" id="h9-0-374" class="i">+                    &quot;Projection: {}\n&quot;,
</a><a href="#h9-0-375" id="h9-0-375" class="i">+                    expressions
</a><a href="#h9-0-376" id="h9-0-376" class="i">+                        .iter()
</a><a href="#h9-0-377" id="h9-0-377" class="i">+                        .map(|(expr, _)| expr.to_string())
</a><a href="#h9-0-378" id="h9-0-378" class="i">+                        .collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h9-0-379" id="h9-0-379" class="i">+                        .join(&quot;, &quot;)
</a><a href="#h9-0-380" id="h9-0-380" class="i">+                );
</a><a href="#h9-0-381" id="h9-0-381" class="i">+                s += &amp;source.format(indent, false, true);
</a><a href="#h9-0-382" id="h9-0-382" class="i">+            }
</a><a href="#h9-0-383" id="h9-0-383" class="i">+            Self::Scan { table, alias, filter } =&gt; {
</a><a href="#h9-0-384" id="h9-0-384" class="i">+                s += &amp;format!(&quot;Scan: {}&quot;, table.name);
</a><a href="#h9-0-385" id="h9-0-385" class="i">+                if let Some(alias) = alias {
</a><a href="#h9-0-386" id="h9-0-386" class="i">+                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h9-0-387" id="h9-0-387" class="i">+                }
</a><a href="#h9-0-388" id="h9-0-388" class="i">+                if let Some(expr) = filter {
</a><a href="#h9-0-389" id="h9-0-389" class="i">+                    s += &amp;format!(&quot; ({})&quot;, expr);
</a><a href="#h9-0-390" id="h9-0-390" class="i">+                }
</a><a href="#h9-0-391" id="h9-0-391" class="i">+                s += &quot;\n&quot;;
</a><a href="#h9-0-392" id="h9-0-392" class="i">+            }
</a><a href="#h9-0-393" id="h9-0-393" class="i">+        };
</a><a href="#h9-0-394" id="h9-0-394" class="i">+        if root {
</a><a href="#h9-0-395" id="h9-0-395" class="i">+            s = s.trim_end().to_string()
</a><a href="#h9-0-396" id="h9-0-396" class="i">+        }
</a><a href="#h9-0-397" id="h9-0-397" class="i">+        s
</a><a href="#h9-0-398" id="h9-0-398" class="i">+    }
</a><a href="#h9-0-399" id="h9-0-399" class="i">+}
</a><a href="#h9-0-400" id="h9-0-400" class="i">+
</a><a href="#h9-0-401" id="h9-0-401" class="i">+impl std::fmt::Display for Node {
</a><a href="#h9-0-402" id="h9-0-402" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h9-0-403" id="h9-0-403" class="i">+        write!(f, &quot;{}&quot;, self.format(&quot;&quot;.to_string(), true, true))
</a><a href="#h9-0-404" id="h9-0-404" class="i">+    }
</a><a href="#h9-0-405" id="h9-0-405" class="i">+}
</a><a href="#h9-0-406" id="h9-0-406" class="i">+
</a><a href="#h9-0-407" id="h9-0-407" class="i">+/// An aggregate operation
</a><a href="#h9-0-408" id="h9-0-408" class="i">+#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h9-0-409" id="h9-0-409" class="i">+pub enum Aggregate {
</a><a href="#h9-0-410" id="h9-0-410" class="i">+    Average,
</a><a href="#h9-0-411" id="h9-0-411" class="i">+    Count,
</a><a href="#h9-0-412" id="h9-0-412" class="i">+    Max,
</a><a href="#h9-0-413" id="h9-0-413" class="i">+    Min,
</a><a href="#h9-0-414" id="h9-0-414" class="i">+    Sum,
</a><a href="#h9-0-415" id="h9-0-415" class="i">+}
</a><a href="#h9-0-416" id="h9-0-416" class="i">+
</a><a href="#h9-0-417" id="h9-0-417" class="i">+impl std::fmt::Display for Aggregate {
</a><a href="#h9-0-418" id="h9-0-418" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h9-0-419" id="h9-0-419" class="i">+        match self {
</a><a href="#h9-0-420" id="h9-0-420" class="i">+            Self::Average =&gt; write!(f, &quot;average&quot;),
</a><a href="#h9-0-421" id="h9-0-421" class="i">+            Self::Count =&gt; write!(f, &quot;count&quot;),
</a><a href="#h9-0-422" id="h9-0-422" class="i">+            Self::Max =&gt; write!(f, &quot;maximum&quot;),
</a><a href="#h9-0-423" id="h9-0-423" class="i">+            Self::Min =&gt; write!(f, &quot;minimum&quot;),
</a><a href="#h9-0-424" id="h9-0-424" class="i">+            Self::Sum =&gt; write!(f, &quot;sum&quot;),
</a><a href="#h9-0-425" id="h9-0-425" class="i">+        }
</a><a href="#h9-0-426" id="h9-0-426" class="i">+    }
</a><a href="#h9-0-427" id="h9-0-427" class="i">+}
</a><a href="#h9-0-428" id="h9-0-428" class="i">+
</a><a href="#h9-0-429" id="h9-0-429" class="i">+/// A sort order direction.
</a><a href="#h9-0-430" id="h9-0-430" class="i">+#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h9-0-431" id="h9-0-431" class="i">+pub enum Direction {
</a><a href="#h9-0-432" id="h9-0-432" class="i">+    Ascending,
</a><a href="#h9-0-433" id="h9-0-433" class="i">+    Descending,
</a><a href="#h9-0-434" id="h9-0-434" class="i">+}
</a><a href="#h9-0-435" id="h9-0-435" class="i">+
</a><a href="#h9-0-436" id="h9-0-436" class="i">+impl std::fmt::Display for Direction {
</a><a href="#h9-0-437" id="h9-0-437" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h9-0-438" id="h9-0-438" class="i">+        match self {
</a><a href="#h9-0-439" id="h9-0-439" class="i">+            Self::Ascending =&gt; write!(f, &quot;asc&quot;),
</a><a href="#h9-0-440" id="h9-0-440" class="i">+            Self::Descending =&gt; write!(f, &quot;desc&quot;),
</a><a href="#h9-0-441" id="h9-0-441" class="i">+        }
</a><a href="#h9-0-442" id="h9-0-442" class="i">+    }
</a><a href="#h9-0-443" id="h9-0-443" class="i">+}
</a><b>diff --git a/<a id="h10" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -0,0 +1,814 @@
</a><a href="#h10-0-0" id="h10-0-0" class="i">+#![allow(clippy::module_inception)]
</a><a href="#h10-0-1" id="h10-0-1" class="i">+
</a><a href="#h10-0-2" id="h10-0-2" class="i">+use super::super::parser::ast;
</a><a href="#h10-0-3" id="h10-0-3" class="i">+use super::{plan::Node, plan::Plan, Aggregate, Direction};
</a><a href="#h10-0-4" id="h10-0-4" class="i">+use crate::errinput;
</a><a href="#h10-0-5" id="h10-0-5" class="i">+use crate::error::Result;
</a><a href="#h10-0-6" id="h10-0-6" class="i">+use crate::sql::engine::Catalog;
</a><a href="#h10-0-7" id="h10-0-7" class="i">+use crate::sql::types::{Column, Expression, Table, Value};
</a><a href="#h10-0-8" id="h10-0-8" class="i">+
</a><a href="#h10-0-9" id="h10-0-9" class="i">+use std::collections::{HashMap, HashSet};
</a><a href="#h10-0-10" id="h10-0-10" class="i">+use std::mem::replace;
</a><a href="#h10-0-11" id="h10-0-11" class="i">+
</a><a href="#h10-0-12" id="h10-0-12" class="i">+/// A query plan builder.
</a><a href="#h10-0-13" id="h10-0-13" class="i">+pub struct Planner&lt;&#39;a, C: Catalog&gt; {
</a><a href="#h10-0-14" id="h10-0-14" class="i">+    catalog: &amp;&#39;a C,
</a><a href="#h10-0-15" id="h10-0-15" class="i">+}
</a><a href="#h10-0-16" id="h10-0-16" class="i">+
</a><a href="#h10-0-17" id="h10-0-17" class="i">+impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a><a href="#h10-0-18" id="h10-0-18" class="i">+    /// Creates a new planner.
</a><a href="#h10-0-19" id="h10-0-19" class="i">+    pub fn new(catalog: &amp;&#39;a C) -&gt; Self {
</a><a href="#h10-0-20" id="h10-0-20" class="i">+        Self { catalog }
</a><a href="#h10-0-21" id="h10-0-21" class="i">+    }
</a><a href="#h10-0-22" id="h10-0-22" class="i">+
</a><a href="#h10-0-23" id="h10-0-23" class="i">+    /// Builds a plan for an AST statement.
</a><a href="#h10-0-24" id="h10-0-24" class="i">+    pub fn build(&amp;mut self, statement: ast::Statement) -&gt; Result&lt;Plan&gt; {
</a><a href="#h10-0-25" id="h10-0-25" class="i">+        self.build_statement(statement)
</a><a href="#h10-0-26" id="h10-0-26" class="i">+    }
</a><a href="#h10-0-27" id="h10-0-27" class="i">+
</a><a href="#h10-0-28" id="h10-0-28" class="i">+    /// Builds a plan for a statement.
</a><a href="#h10-0-29" id="h10-0-29" class="i">+    fn build_statement(&amp;self, statement: ast::Statement) -&gt; Result&lt;Plan&gt; {
</a><a href="#h10-0-30" id="h10-0-30" class="i">+        Ok(match statement {
</a><a href="#h10-0-31" id="h10-0-31" class="i">+            // Transaction control and explain statements should have been handled by session.
</a><a href="#h10-0-32" id="h10-0-32" class="i">+            ast::Statement::Begin { .. } | ast::Statement::Commit | ast::Statement::Rollback =&gt; {
</a><a href="#h10-0-33" id="h10-0-33" class="i">+                panic!(&quot;unexpected transaction statement {statement:?}&quot;)
</a><a href="#h10-0-34" id="h10-0-34" class="i">+            }
</a><a href="#h10-0-35" id="h10-0-35" class="i">+
</a><a href="#h10-0-36" id="h10-0-36" class="i">+            ast::Statement::Explain(_) =&gt; panic!(&quot;unexpected explain statement&quot;),
</a><a href="#h10-0-37" id="h10-0-37" class="i">+
</a><a href="#h10-0-38" id="h10-0-38" class="i">+            // DDL statements (schema changes).
</a><a href="#h10-0-39" id="h10-0-39" class="i">+            ast::Statement::CreateTable { name, columns } =&gt; {
</a><a href="#h10-0-40" id="h10-0-40" class="i">+                let Some(primary_key) = columns.iter().position(|c| c.primary_key) else {
</a><a href="#h10-0-41" id="h10-0-41" class="i">+                    return errinput!(&quot;no primary key for table {name}&quot;);
</a><a href="#h10-0-42" id="h10-0-42" class="i">+                };
</a><a href="#h10-0-43" id="h10-0-43" class="i">+                if columns.iter().filter(|c| c.primary_key).count() &gt; 1 {
</a><a href="#h10-0-44" id="h10-0-44" class="i">+                    return errinput!(&quot;multiple primary keys for table {name}&quot;);
</a><a href="#h10-0-45" id="h10-0-45" class="i">+                }
</a><a href="#h10-0-46" id="h10-0-46" class="i">+                let columns = columns
</a><a href="#h10-0-47" id="h10-0-47" class="i">+                    .into_iter()
</a><a href="#h10-0-48" id="h10-0-48" class="i">+                    .map(|c| {
</a><a href="#h10-0-49" id="h10-0-49" class="i">+                        let nullable = c.nullable.unwrap_or(!c.primary_key);
</a><a href="#h10-0-50" id="h10-0-50" class="i">+                        Ok(Column {
</a><a href="#h10-0-51" id="h10-0-51" class="i">+                            name: c.name,
</a><a href="#h10-0-52" id="h10-0-52" class="i">+                            datatype: c.datatype,
</a><a href="#h10-0-53" id="h10-0-53" class="i">+                            nullable,
</a><a href="#h10-0-54" id="h10-0-54" class="i">+                            default: match c.default {
</a><a href="#h10-0-55" id="h10-0-55" class="i">+                                Some(expr) =&gt; Some(self.evaluate_constant(expr)?),
</a><a href="#h10-0-56" id="h10-0-56" class="i">+                                None if nullable =&gt; Some(Value::Null),
</a><a href="#h10-0-57" id="h10-0-57" class="i">+                                None =&gt; None,
</a><a href="#h10-0-58" id="h10-0-58" class="i">+                            },
</a><a href="#h10-0-59" id="h10-0-59" class="i">+                            unique: c.unique || c.primary_key,
</a><a href="#h10-0-60" id="h10-0-60" class="i">+                            index: (c.index || c.unique || c.references.is_some())
</a><a href="#h10-0-61" id="h10-0-61" class="i">+                                &amp;&amp; !c.primary_key,
</a><a href="#h10-0-62" id="h10-0-62" class="i">+                            references: c.references,
</a><a href="#h10-0-63" id="h10-0-63" class="i">+                        })
</a><a href="#h10-0-64" id="h10-0-64" class="i">+                    })
</a><a href="#h10-0-65" id="h10-0-65" class="i">+                    .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h10-0-66" id="h10-0-66" class="i">+                Plan::CreateTable { schema: Table { name, primary_key, columns } }
</a><a href="#h10-0-67" id="h10-0-67" class="i">+            }
</a><a href="#h10-0-68" id="h10-0-68" class="i">+
</a><a href="#h10-0-69" id="h10-0-69" class="i">+            ast::Statement::DropTable { name, if_exists } =&gt; {
</a><a href="#h10-0-70" id="h10-0-70" class="i">+                Plan::DropTable { table: name, if_exists }
</a><a href="#h10-0-71" id="h10-0-71" class="i">+            }
</a><a href="#h10-0-72" id="h10-0-72" class="i">+
</a><a href="#h10-0-73" id="h10-0-73" class="i">+            // DML statements (mutations).
</a><a href="#h10-0-74" id="h10-0-74" class="i">+            ast::Statement::Delete { table, r#where } =&gt; {
</a><a href="#h10-0-75" id="h10-0-75" class="i">+                let table = self.catalog.must_get_table(&amp;table)?;
</a><a href="#h10-0-76" id="h10-0-76" class="i">+                let scope = &amp;mut Scope::from_table(table.clone())?;
</a><a href="#h10-0-77" id="h10-0-77" class="i">+                Plan::Delete {
</a><a href="#h10-0-78" id="h10-0-78" class="i">+                    table: table.name.clone(),
</a><a href="#h10-0-79" id="h10-0-79" class="i">+                    key_index: table.primary_key,
</a><a href="#h10-0-80" id="h10-0-80" class="i">+                    source: Node::Scan {
</a><a href="#h10-0-81" id="h10-0-81" class="i">+                        table,
</a><a href="#h10-0-82" id="h10-0-82" class="i">+                        alias: None,
</a><a href="#h10-0-83" id="h10-0-83" class="i">+                        filter: r#where.map(|e| self.build_expression(scope, e)).transpose()?,
</a><a href="#h10-0-84" id="h10-0-84" class="i">+                    },
</a><a href="#h10-0-85" id="h10-0-85" class="i">+                }
</a><a href="#h10-0-86" id="h10-0-86" class="i">+            }
</a><a href="#h10-0-87" id="h10-0-87" class="i">+
</a><a href="#h10-0-88" id="h10-0-88" class="i">+            ast::Statement::Insert { table, columns, values } =&gt; {
</a><a href="#h10-0-89" id="h10-0-89" class="i">+                let table = self.catalog.must_get_table(&amp;table)?;
</a><a href="#h10-0-90" id="h10-0-90" class="i">+                Plan::Insert {
</a><a href="#h10-0-91" id="h10-0-91" class="i">+                    table,
</a><a href="#h10-0-92" id="h10-0-92" class="i">+                    columns: columns.unwrap_or_default(),
</a><a href="#h10-0-93" id="h10-0-93" class="i">+                    expressions: values
</a><a href="#h10-0-94" id="h10-0-94" class="i">+                        .into_iter()
</a><a href="#h10-0-95" id="h10-0-95" class="i">+                        .map(|exprs| {
</a><a href="#h10-0-96" id="h10-0-96" class="i">+                            exprs
</a><a href="#h10-0-97" id="h10-0-97" class="i">+                                .into_iter()
</a><a href="#h10-0-98" id="h10-0-98" class="i">+                                .map(|expr| self.build_expression(&amp;mut Scope::constant(), expr))
</a><a href="#h10-0-99" id="h10-0-99" class="i">+                                .collect::&lt;Result&lt;_&gt;&gt;()
</a><a href="#h10-0-100" id="h10-0-100" class="i">+                        })
</a><a href="#h10-0-101" id="h10-0-101" class="i">+                        .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h10-0-102" id="h10-0-102" class="i">+                }
</a><a href="#h10-0-103" id="h10-0-103" class="i">+            }
</a><a href="#h10-0-104" id="h10-0-104" class="i">+
</a><a href="#h10-0-105" id="h10-0-105" class="i">+            ast::Statement::Update { table, set, r#where } =&gt; {
</a><a href="#h10-0-106" id="h10-0-106" class="i">+                let table = self.catalog.must_get_table(&amp;table)?;
</a><a href="#h10-0-107" id="h10-0-107" class="i">+                let scope = &amp;mut Scope::from_table(table.clone())?;
</a><a href="#h10-0-108" id="h10-0-108" class="i">+                Plan::Update {
</a><a href="#h10-0-109" id="h10-0-109" class="i">+                    table: table.name.clone(),
</a><a href="#h10-0-110" id="h10-0-110" class="i">+                    key_index: table.primary_key,
</a><a href="#h10-0-111" id="h10-0-111" class="i">+                    source: Node::Scan {
</a><a href="#h10-0-112" id="h10-0-112" class="i">+                        table,
</a><a href="#h10-0-113" id="h10-0-113" class="i">+                        alias: None,
</a><a href="#h10-0-114" id="h10-0-114" class="i">+                        filter: r#where.map(|e| self.build_expression(scope, e)).transpose()?,
</a><a href="#h10-0-115" id="h10-0-115" class="i">+                    },
</a><a href="#h10-0-116" id="h10-0-116" class="i">+                    expressions: set
</a><a href="#h10-0-117" id="h10-0-117" class="i">+                        .into_iter()
</a><a href="#h10-0-118" id="h10-0-118" class="i">+                        .map(|(c, e)| {
</a><a href="#h10-0-119" id="h10-0-119" class="i">+                            Ok((
</a><a href="#h10-0-120" id="h10-0-120" class="i">+                                scope.resolve(None, &amp;c)?,
</a><a href="#h10-0-121" id="h10-0-121" class="i">+                                Some(c),
</a><a href="#h10-0-122" id="h10-0-122" class="i">+                                self.build_expression(scope, e)?,
</a><a href="#h10-0-123" id="h10-0-123" class="i">+                            ))
</a><a href="#h10-0-124" id="h10-0-124" class="i">+                        })
</a><a href="#h10-0-125" id="h10-0-125" class="i">+                        .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h10-0-126" id="h10-0-126" class="i">+                }
</a><a href="#h10-0-127" id="h10-0-127" class="i">+            }
</a><a href="#h10-0-128" id="h10-0-128" class="i">+
</a><a href="#h10-0-129" id="h10-0-129" class="i">+            // Queries.
</a><a href="#h10-0-130" id="h10-0-130" class="i">+            ast::Statement::Select {
</a><a href="#h10-0-131" id="h10-0-131" class="i">+                mut select,
</a><a href="#h10-0-132" id="h10-0-132" class="i">+                from,
</a><a href="#h10-0-133" id="h10-0-133" class="i">+                r#where,
</a><a href="#h10-0-134" id="h10-0-134" class="i">+                group_by,
</a><a href="#h10-0-135" id="h10-0-135" class="i">+                mut having,
</a><a href="#h10-0-136" id="h10-0-136" class="i">+                mut order,
</a><a href="#h10-0-137" id="h10-0-137" class="i">+                offset,
</a><a href="#h10-0-138" id="h10-0-138" class="i">+                limit,
</a><a href="#h10-0-139" id="h10-0-139" class="i">+            } =&gt; {
</a><a href="#h10-0-140" id="h10-0-140" class="i">+                let scope = &amp;mut Scope::new();
</a><a href="#h10-0-141" id="h10-0-141" class="i">+
</a><a href="#h10-0-142" id="h10-0-142" class="i">+                // Build FROM clause.
</a><a href="#h10-0-143" id="h10-0-143" class="i">+                let mut node = if !from.is_empty() {
</a><a href="#h10-0-144" id="h10-0-144" class="i">+                    self.build_from_clause(scope, from)?
</a><a href="#h10-0-145" id="h10-0-145" class="i">+                } else if select.is_empty() {
</a><a href="#h10-0-146" id="h10-0-146" class="i">+                    return errinput!(&quot;can&#39;t select * without a table&quot;);
</a><a href="#h10-0-147" id="h10-0-147" class="i">+                } else {
</a><a href="#h10-0-148" id="h10-0-148" class="i">+                    Node::Nothing
</a><a href="#h10-0-149" id="h10-0-149" class="i">+                };
</a><a href="#h10-0-150" id="h10-0-150" class="i">+
</a><a href="#h10-0-151" id="h10-0-151" class="i">+                // Build WHERE clause.
</a><a href="#h10-0-152" id="h10-0-152" class="i">+                if let Some(expr) = r#where {
</a><a href="#h10-0-153" id="h10-0-153" class="i">+                    node = Node::Filter {
</a><a href="#h10-0-154" id="h10-0-154" class="i">+                        source: Box::new(node),
</a><a href="#h10-0-155" id="h10-0-155" class="i">+                        predicate: self.build_expression(scope, expr)?,
</a><a href="#h10-0-156" id="h10-0-156" class="i">+                    };
</a><a href="#h10-0-157" id="h10-0-157" class="i">+                };
</a><a href="#h10-0-158" id="h10-0-158" class="i">+
</a><a href="#h10-0-159" id="h10-0-159" class="i">+                // Build SELECT clause.
</a><a href="#h10-0-160" id="h10-0-160" class="i">+                let mut hidden = 0;
</a><a href="#h10-0-161" id="h10-0-161" class="i">+                if !select.is_empty() {
</a><a href="#h10-0-162" id="h10-0-162" class="i">+                    // Inject hidden SELECT columns for fields and aggregates used in ORDER BY and
</a><a href="#h10-0-163" id="h10-0-163" class="i">+                    // HAVING expressions but not present in existing SELECT output. These will be
</a><a href="#h10-0-164" id="h10-0-164" class="i">+                    // removed again by a later projection.
</a><a href="#h10-0-165" id="h10-0-165" class="i">+                    if let Some(ref mut expr) = having {
</a><a href="#h10-0-166" id="h10-0-166" class="i">+                        hidden += self.inject_hidden(expr, &amp;mut select)?;
</a><a href="#h10-0-167" id="h10-0-167" class="i">+                    }
</a><a href="#h10-0-168" id="h10-0-168" class="i">+                    for (expr, _) in order.iter_mut() {
</a><a href="#h10-0-169" id="h10-0-169" class="i">+                        hidden += self.inject_hidden(expr, &amp;mut select)?;
</a><a href="#h10-0-170" id="h10-0-170" class="i">+                    }
</a><a href="#h10-0-171" id="h10-0-171" class="i">+
</a><a href="#h10-0-172" id="h10-0-172" class="i">+                    // Extract any aggregate functions and GROUP BY expressions, replacing them with
</a><a href="#h10-0-173" id="h10-0-173" class="i">+                    // Column placeholders. Aggregations are handled by evaluating group expressions
</a><a href="#h10-0-174" id="h10-0-174" class="i">+                    // and aggregate function arguments in a pre-projection, passing the results
</a><a href="#h10-0-175" id="h10-0-175" class="i">+                    // to an aggregation node, and then evaluating the final SELECT expressions
</a><a href="#h10-0-176" id="h10-0-176" class="i">+                    // in the post-projection. For example:
</a><a href="#h10-0-177" id="h10-0-177" class="i">+                    //
</a><a href="#h10-0-178" id="h10-0-178" class="i">+                    // SELECT (MAX(rating * 100) - MIN(rating * 100)) / 100
</a><a href="#h10-0-179" id="h10-0-179" class="i">+                    // FROM movies
</a><a href="#h10-0-180" id="h10-0-180" class="i">+                    // GROUP BY released - 2000
</a><a href="#h10-0-181" id="h10-0-181" class="i">+                    //
</a><a href="#h10-0-182" id="h10-0-182" class="i">+                    // Results in the following nodes:
</a><a href="#h10-0-183" id="h10-0-183" class="i">+                    //
</a><a href="#h10-0-184" id="h10-0-184" class="i">+                    // - Projection: rating * 100, rating * 100, released - 2000
</a><a href="#h10-0-185" id="h10-0-185" class="i">+                    // - Aggregation: max(#0), min(#1) group by #2
</a><a href="#h10-0-186" id="h10-0-186" class="i">+                    // - Projection: (#0 - #1) / 100
</a><a href="#h10-0-187" id="h10-0-187" class="i">+                    let aggregates = self.extract_aggregates(&amp;mut select)?;
</a><a href="#h10-0-188" id="h10-0-188" class="i">+                    let groups = self.extract_groups(&amp;mut select, group_by, aggregates.len())?;
</a><a href="#h10-0-189" id="h10-0-189" class="i">+                    if !aggregates.is_empty() || !groups.is_empty() {
</a><a href="#h10-0-190" id="h10-0-190" class="i">+                        node = self.build_aggregation(scope, node, groups, aggregates)?;
</a><a href="#h10-0-191" id="h10-0-191" class="i">+                    }
</a><a href="#h10-0-192" id="h10-0-192" class="i">+
</a><a href="#h10-0-193" id="h10-0-193" class="i">+                    // Build the remaining non-aggregate projection.
</a><a href="#h10-0-194" id="h10-0-194" class="i">+                    let expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt; = select
</a><a href="#h10-0-195" id="h10-0-195" class="i">+                        .into_iter()
</a><a href="#h10-0-196" id="h10-0-196" class="i">+                        .map(|(e, l)| Ok((self.build_expression(scope, e)?, l)))
</a><a href="#h10-0-197" id="h10-0-197" class="i">+                        .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h10-0-198" id="h10-0-198" class="i">+                    scope.project(&amp;expressions)?;
</a><a href="#h10-0-199" id="h10-0-199" class="i">+                    node = Node::Projection { source: Box::new(node), expressions };
</a><a href="#h10-0-200" id="h10-0-200" class="i">+                };
</a><a href="#h10-0-201" id="h10-0-201" class="i">+
</a><a href="#h10-0-202" id="h10-0-202" class="i">+                // Build HAVING clause.
</a><a href="#h10-0-203" id="h10-0-203" class="i">+                if let Some(expr) = having {
</a><a href="#h10-0-204" id="h10-0-204" class="i">+                    node = Node::Filter {
</a><a href="#h10-0-205" id="h10-0-205" class="i">+                        source: Box::new(node),
</a><a href="#h10-0-206" id="h10-0-206" class="i">+                        predicate: self.build_expression(scope, expr)?,
</a><a href="#h10-0-207" id="h10-0-207" class="i">+                    };
</a><a href="#h10-0-208" id="h10-0-208" class="i">+                };
</a><a href="#h10-0-209" id="h10-0-209" class="i">+
</a><a href="#h10-0-210" id="h10-0-210" class="i">+                // Build ORDER clause.
</a><a href="#h10-0-211" id="h10-0-211" class="i">+                if !order.is_empty() {
</a><a href="#h10-0-212" id="h10-0-212" class="i">+                    node = Node::Order {
</a><a href="#h10-0-213" id="h10-0-213" class="i">+                        source: Box::new(node),
</a><a href="#h10-0-214" id="h10-0-214" class="i">+                        orders: order
</a><a href="#h10-0-215" id="h10-0-215" class="i">+                            .into_iter()
</a><a href="#h10-0-216" id="h10-0-216" class="i">+                            .map(|(e, o)| {
</a><a href="#h10-0-217" id="h10-0-217" class="i">+                                Ok((
</a><a href="#h10-0-218" id="h10-0-218" class="i">+                                    self.build_expression(scope, e)?,
</a><a href="#h10-0-219" id="h10-0-219" class="i">+                                    match o {
</a><a href="#h10-0-220" id="h10-0-220" class="i">+                                        ast::Order::Ascending =&gt; Direction::Ascending,
</a><a href="#h10-0-221" id="h10-0-221" class="i">+                                        ast::Order::Descending =&gt; Direction::Descending,
</a><a href="#h10-0-222" id="h10-0-222" class="i">+                                    },
</a><a href="#h10-0-223" id="h10-0-223" class="i">+                                ))
</a><a href="#h10-0-224" id="h10-0-224" class="i">+                            })
</a><a href="#h10-0-225" id="h10-0-225" class="i">+                            .collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h10-0-226" id="h10-0-226" class="i">+                    };
</a><a href="#h10-0-227" id="h10-0-227" class="i">+                }
</a><a href="#h10-0-228" id="h10-0-228" class="i">+
</a><a href="#h10-0-229" id="h10-0-229" class="i">+                // Build OFFSET clause.
</a><a href="#h10-0-230" id="h10-0-230" class="i">+                if let Some(expr) = offset {
</a><a href="#h10-0-231" id="h10-0-231" class="i">+                    node = Node::Offset {
</a><a href="#h10-0-232" id="h10-0-232" class="i">+                        source: Box::new(node),
</a><a href="#h10-0-233" id="h10-0-233" class="i">+                        offset: match self.evaluate_constant(expr)? {
</a><a href="#h10-0-234" id="h10-0-234" class="i">+                            Value::Integer(i) if i &gt;= 0 =&gt; Ok(i as u64),
</a><a href="#h10-0-235" id="h10-0-235" class="i">+                            v =&gt; errinput!(&quot;invalid offset {v}&quot;),
</a><a href="#h10-0-236" id="h10-0-236" class="i">+                        }?,
</a><a href="#h10-0-237" id="h10-0-237" class="i">+                    }
</a><a href="#h10-0-238" id="h10-0-238" class="i">+                }
</a><a href="#h10-0-239" id="h10-0-239" class="i">+
</a><a href="#h10-0-240" id="h10-0-240" class="i">+                // Build LIMIT clause.
</a><a href="#h10-0-241" id="h10-0-241" class="i">+                if let Some(expr) = limit {
</a><a href="#h10-0-242" id="h10-0-242" class="i">+                    node = Node::Limit {
</a><a href="#h10-0-243" id="h10-0-243" class="i">+                        source: Box::new(node),
</a><a href="#h10-0-244" id="h10-0-244" class="i">+                        limit: match self.evaluate_constant(expr)? {
</a><a href="#h10-0-245" id="h10-0-245" class="i">+                            Value::Integer(i) if i &gt;= 0 =&gt; Ok(i as u64),
</a><a href="#h10-0-246" id="h10-0-246" class="i">+                            v =&gt; errinput!(&quot;invalid limit {v}&quot;),
</a><a href="#h10-0-247" id="h10-0-247" class="i">+                        }?,
</a><a href="#h10-0-248" id="h10-0-248" class="i">+                    }
</a><a href="#h10-0-249" id="h10-0-249" class="i">+                }
</a><a href="#h10-0-250" id="h10-0-250" class="i">+
</a><a href="#h10-0-251" id="h10-0-251" class="i">+                // Remove any hidden columns.
</a><a href="#h10-0-252" id="h10-0-252" class="i">+                if hidden &gt; 0 {
</a><a href="#h10-0-253" id="h10-0-253" class="i">+                    node = Node::Projection {
</a><a href="#h10-0-254" id="h10-0-254" class="i">+                        source: Box::new(node),
</a><a href="#h10-0-255" id="h10-0-255" class="i">+                        expressions: (0..(scope.len() - hidden))
</a><a href="#h10-0-256" id="h10-0-256" class="i">+                            .map(|i| (Expression::Field(i, None), None))
</a><a href="#h10-0-257" id="h10-0-257" class="i">+                            .collect(),
</a><a href="#h10-0-258" id="h10-0-258" class="i">+                    }
</a><a href="#h10-0-259" id="h10-0-259" class="i">+                }
</a><a href="#h10-0-260" id="h10-0-260" class="i">+
</a><a href="#h10-0-261" id="h10-0-261" class="i">+                Plan::Select(node)
</a><a href="#h10-0-262" id="h10-0-262" class="i">+            }
</a><a href="#h10-0-263" id="h10-0-263" class="i">+        })
</a><a href="#h10-0-264" id="h10-0-264" class="i">+    }
</a><a href="#h10-0-265" id="h10-0-265" class="i">+
</a><a href="#h10-0-266" id="h10-0-266" class="i">+    /// Builds a FROM clause consisting of several items. Each item is either a single table or a
</a><a href="#h10-0-267" id="h10-0-267" class="i">+    /// join of an arbitrary number of tables. All of the items are joined, since e.g. &#39;SELECT * FROM
</a><a href="#h10-0-268" id="h10-0-268" class="i">+    /// a, b&#39; is an implicit join of a and b.
</a><a href="#h10-0-269" id="h10-0-269" class="i">+    fn build_from_clause(&amp;self, scope: &amp;mut Scope, from: Vec&lt;ast::FromItem&gt;) -&gt; Result&lt;Node&gt; {
</a><a href="#h10-0-270" id="h10-0-270" class="i">+        let base_scope = scope.clone();
</a><a href="#h10-0-271" id="h10-0-271" class="i">+        let mut items = from.into_iter();
</a><a href="#h10-0-272" id="h10-0-272" class="i">+        let mut node = match items.next() {
</a><a href="#h10-0-273" id="h10-0-273" class="i">+            Some(item) =&gt; self.build_from_item(scope, item)?,
</a><a href="#h10-0-274" id="h10-0-274" class="i">+            None =&gt; return errinput!(&quot;no from items given&quot;),
</a><a href="#h10-0-275" id="h10-0-275" class="i">+        };
</a><a href="#h10-0-276" id="h10-0-276" class="i">+        for item in items {
</a><a href="#h10-0-277" id="h10-0-277" class="i">+            let mut right_scope = base_scope.clone();
</a><a href="#h10-0-278" id="h10-0-278" class="i">+            let right = self.build_from_item(&amp;mut right_scope, item)?;
</a><a href="#h10-0-279" id="h10-0-279" class="i">+            node = Node::NestedLoopJoin {
</a><a href="#h10-0-280" id="h10-0-280" class="i">+                left: Box::new(node),
</a><a href="#h10-0-281" id="h10-0-281" class="i">+                left_size: scope.len(),
</a><a href="#h10-0-282" id="h10-0-282" class="i">+                right: Box::new(right),
</a><a href="#h10-0-283" id="h10-0-283" class="i">+                predicate: None,
</a><a href="#h10-0-284" id="h10-0-284" class="i">+                outer: false,
</a><a href="#h10-0-285" id="h10-0-285" class="i">+            };
</a><a href="#h10-0-286" id="h10-0-286" class="i">+            scope.merge(right_scope)?;
</a><a href="#h10-0-287" id="h10-0-287" class="i">+        }
</a><a href="#h10-0-288" id="h10-0-288" class="i">+        Ok(node)
</a><a href="#h10-0-289" id="h10-0-289" class="i">+    }
</a><a href="#h10-0-290" id="h10-0-290" class="i">+
</a><a href="#h10-0-291" id="h10-0-291" class="i">+    /// Builds FROM items, which can either be a single table or a chained join of multiple tables,
</a><a href="#h10-0-292" id="h10-0-292" class="i">+    /// e.g. &#39;SELECT * FROM a LEFT JOIN b ON b.a_id = a.id&#39;. Any tables will be stored in
</a><a href="#h10-0-293" id="h10-0-293" class="i">+    /// self.tables keyed by their query name (i.e. alias if given, otherwise name). The table can
</a><a href="#h10-0-294" id="h10-0-294" class="i">+    /// only be referenced by the query name (so if alias is given, cannot reference by name).
</a><a href="#h10-0-295" id="h10-0-295" class="i">+    fn build_from_item(&amp;self, scope: &amp;mut Scope, item: ast::FromItem) -&gt; Result&lt;Node&gt; {
</a><a href="#h10-0-296" id="h10-0-296" class="i">+        Ok(match item {
</a><a href="#h10-0-297" id="h10-0-297" class="i">+            ast::FromItem::Table { name, alias } =&gt; {
</a><a href="#h10-0-298" id="h10-0-298" class="i">+                let table = self.catalog.must_get_table(&amp;name)?;
</a><a href="#h10-0-299" id="h10-0-299" class="i">+                scope.add_table(alias.clone().unwrap_or_else(|| name.clone()), table.clone())?;
</a><a href="#h10-0-300" id="h10-0-300" class="i">+                Node::Scan { table, alias, filter: None }
</a><a href="#h10-0-301" id="h10-0-301" class="i">+            }
</a><a href="#h10-0-302" id="h10-0-302" class="i">+
</a><a href="#h10-0-303" id="h10-0-303" class="i">+            ast::FromItem::Join { left, right, r#type, predicate } =&gt; {
</a><a href="#h10-0-304" id="h10-0-304" class="i">+                // Right outer joins are built as a left outer join with an additional projection
</a><a href="#h10-0-305" id="h10-0-305" class="i">+                // to swap the resulting columns.
</a><a href="#h10-0-306" id="h10-0-306" class="i">+                let (left, right) = match r#type {
</a><a href="#h10-0-307" id="h10-0-307" class="i">+                    ast::JoinType::Right =&gt; (right, left),
</a><a href="#h10-0-308" id="h10-0-308" class="i">+                    _ =&gt; (left, right),
</a><a href="#h10-0-309" id="h10-0-309" class="i">+                };
</a><a href="#h10-0-310" id="h10-0-310" class="i">+                let left = Box::new(self.build_from_item(scope, *left)?);
</a><a href="#h10-0-311" id="h10-0-311" class="i">+                let left_size = scope.len();
</a><a href="#h10-0-312" id="h10-0-312" class="i">+                let right = Box::new(self.build_from_item(scope, *right)?);
</a><a href="#h10-0-313" id="h10-0-313" class="i">+                let predicate = predicate.map(|e| self.build_expression(scope, e)).transpose()?;
</a><a href="#h10-0-314" id="h10-0-314" class="i">+                let outer = match r#type {
</a><a href="#h10-0-315" id="h10-0-315" class="i">+                    ast::JoinType::Cross | ast::JoinType::Inner =&gt; false,
</a><a href="#h10-0-316" id="h10-0-316" class="i">+                    ast::JoinType::Left | ast::JoinType::Right =&gt; true,
</a><a href="#h10-0-317" id="h10-0-317" class="i">+                };
</a><a href="#h10-0-318" id="h10-0-318" class="i">+                let mut node = Node::NestedLoopJoin { left, left_size, right, predicate, outer };
</a><a href="#h10-0-319" id="h10-0-319" class="i">+                if matches!(r#type, ast::JoinType::Right) {
</a><a href="#h10-0-320" id="h10-0-320" class="i">+                    let expressions = (left_size..scope.len())
</a><a href="#h10-0-321" id="h10-0-321" class="i">+                        .chain(0..left_size)
</a><a href="#h10-0-322" id="h10-0-322" class="i">+                        .map(|i| Ok((Expression::Field(i, scope.get_label(i)?), None)))
</a><a href="#h10-0-323" id="h10-0-323" class="i">+                        .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h10-0-324" id="h10-0-324" class="i">+                    scope.project(&amp;expressions)?;
</a><a href="#h10-0-325" id="h10-0-325" class="i">+                    node = Node::Projection { source: Box::new(node), expressions }
</a><a href="#h10-0-326" id="h10-0-326" class="i">+                }
</a><a href="#h10-0-327" id="h10-0-327" class="i">+                node
</a><a href="#h10-0-328" id="h10-0-328" class="i">+            }
</a><a href="#h10-0-329" id="h10-0-329" class="i">+        })
</a><a href="#h10-0-330" id="h10-0-330" class="i">+    }
</a><a href="#h10-0-331" id="h10-0-331" class="i">+
</a><a href="#h10-0-332" id="h10-0-332" class="i">+    /// Builds an aggregation node. All aggregate parameters and GROUP BY expressions are evaluated
</a><a href="#h10-0-333" id="h10-0-333" class="i">+    /// in a pre-projection, whose results are fed into an Aggregate node. This node computes the
</a><a href="#h10-0-334" id="h10-0-334" class="i">+    /// aggregates for the given groups, passing the group values through directly.
</a><a href="#h10-0-335" id="h10-0-335" class="i">+    fn build_aggregation(
</a><a href="#h10-0-336" id="h10-0-336" class="i">+        &amp;self,
</a><a href="#h10-0-337" id="h10-0-337" class="i">+        scope: &amp;mut Scope,
</a><a href="#h10-0-338" id="h10-0-338" class="i">+        source: Node,
</a><a href="#h10-0-339" id="h10-0-339" class="i">+        groups: Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h10-0-340" id="h10-0-340" class="i">+        aggregations: Vec&lt;(Aggregate, ast::Expression)&gt;,
</a><a href="#h10-0-341" id="h10-0-341" class="i">+    ) -&gt; Result&lt;Node&gt; {
</a><a href="#h10-0-342" id="h10-0-342" class="i">+        let mut aggregates = Vec::new();
</a><a href="#h10-0-343" id="h10-0-343" class="i">+        let mut expressions = Vec::new();
</a><a href="#h10-0-344" id="h10-0-344" class="i">+        for (aggregate, expr) in aggregations {
</a><a href="#h10-0-345" id="h10-0-345" class="i">+            aggregates.push(aggregate);
</a><a href="#h10-0-346" id="h10-0-346" class="i">+            expressions.push((self.build_expression(scope, expr)?, None));
</a><a href="#h10-0-347" id="h10-0-347" class="i">+        }
</a><a href="#h10-0-348" id="h10-0-348" class="i">+        for (expr, label) in groups {
</a><a href="#h10-0-349" id="h10-0-349" class="i">+            expressions.push((self.build_expression(scope, expr)?, label));
</a><a href="#h10-0-350" id="h10-0-350" class="i">+        }
</a><a href="#h10-0-351" id="h10-0-351" class="i">+        scope.project(
</a><a href="#h10-0-352" id="h10-0-352" class="i">+            &amp;expressions
</a><a href="#h10-0-353" id="h10-0-353" class="i">+                .iter()
</a><a href="#h10-0-354" id="h10-0-354" class="i">+                .cloned()
</a><a href="#h10-0-355" id="h10-0-355" class="i">+                .enumerate()
</a><a href="#h10-0-356" id="h10-0-356" class="i">+                .map(|(i, (e, l))| {
</a><a href="#h10-0-357" id="h10-0-357" class="i">+                    if i &lt; aggregates.len() {
</a><a href="#h10-0-358" id="h10-0-358" class="i">+                        // We pass null values here since we don&#39;t want field references to hit
</a><a href="#h10-0-359" id="h10-0-359" class="i">+                        // the fields in scope before the aggregation.
</a><a href="#h10-0-360" id="h10-0-360" class="i">+                        (Expression::Constant(Value::Null), None)
</a><a href="#h10-0-361" id="h10-0-361" class="i">+                    } else {
</a><a href="#h10-0-362" id="h10-0-362" class="i">+                        (e, l)
</a><a href="#h10-0-363" id="h10-0-363" class="i">+                    }
</a><a href="#h10-0-364" id="h10-0-364" class="i">+                })
</a><a href="#h10-0-365" id="h10-0-365" class="i">+                .collect::&lt;Vec&lt;_&gt;&gt;(),
</a><a href="#h10-0-366" id="h10-0-366" class="i">+        )?;
</a><a href="#h10-0-367" id="h10-0-367" class="i">+        let node = Node::Aggregation {
</a><a href="#h10-0-368" id="h10-0-368" class="i">+            source: Box::new(Node::Projection { source: Box::new(source), expressions }),
</a><a href="#h10-0-369" id="h10-0-369" class="i">+            aggregates,
</a><a href="#h10-0-370" id="h10-0-370" class="i">+        };
</a><a href="#h10-0-371" id="h10-0-371" class="i">+        Ok(node)
</a><a href="#h10-0-372" id="h10-0-372" class="i">+    }
</a><a href="#h10-0-373" id="h10-0-373" class="i">+
</a><a href="#h10-0-374" id="h10-0-374" class="i">+    /// Extracts aggregate functions from an AST expression tree. This finds the aggregate
</a><a href="#h10-0-375" id="h10-0-375" class="i">+    /// function calls, replaces them with ast::Expression::Column(i), maps the aggregate functions
</a><a href="#h10-0-376" id="h10-0-376" class="i">+    /// to aggregates, and returns them along with their argument expressions.
</a><a href="#h10-0-377" id="h10-0-377" class="i">+    fn extract_aggregates(
</a><a href="#h10-0-378" id="h10-0-378" class="i">+        &amp;self,
</a><a href="#h10-0-379" id="h10-0-379" class="i">+        exprs: &amp;mut [(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h10-0-380" id="h10-0-380" class="i">+    ) -&gt; Result&lt;Vec&lt;(Aggregate, ast::Expression)&gt;&gt; {
</a><a href="#h10-0-381" id="h10-0-381" class="i">+        let mut aggregates = Vec::new();
</a><a href="#h10-0-382" id="h10-0-382" class="i">+        for (expr, _) in exprs {
</a><a href="#h10-0-383" id="h10-0-383" class="i">+            expr.transform_mut(
</a><a href="#h10-0-384" id="h10-0-384" class="i">+                &amp;mut |mut e| match &amp;mut e {
</a><a href="#h10-0-385" id="h10-0-385" class="i">+                    ast::Expression::Function(f, args) if args.len() == 1 =&gt; {
</a><a href="#h10-0-386" id="h10-0-386" class="i">+                        if let Some(aggregate) = self.aggregate_from_name(f) {
</a><a href="#h10-0-387" id="h10-0-387" class="i">+                            aggregates.push((aggregate, args.remove(0)));
</a><a href="#h10-0-388" id="h10-0-388" class="i">+                            Ok(ast::Expression::Column(aggregates.len() - 1))
</a><a href="#h10-0-389" id="h10-0-389" class="i">+                        } else {
</a><a href="#h10-0-390" id="h10-0-390" class="i">+                            Ok(e)
</a><a href="#h10-0-391" id="h10-0-391" class="i">+                        }
</a><a href="#h10-0-392" id="h10-0-392" class="i">+                    }
</a><a href="#h10-0-393" id="h10-0-393" class="i">+                    _ =&gt; Ok(e),
</a><a href="#h10-0-394" id="h10-0-394" class="i">+                },
</a><a href="#h10-0-395" id="h10-0-395" class="i">+                &amp;mut Ok,
</a><a href="#h10-0-396" id="h10-0-396" class="i">+            )?;
</a><a href="#h10-0-397" id="h10-0-397" class="i">+        }
</a><a href="#h10-0-398" id="h10-0-398" class="i">+        for (_, expr) in &amp;aggregates {
</a><a href="#h10-0-399" id="h10-0-399" class="i">+            if self.is_aggregate(expr) {
</a><a href="#h10-0-400" id="h10-0-400" class="i">+                return errinput!(&quot;aggregate functions can&#39;t be nested&quot;);
</a><a href="#h10-0-401" id="h10-0-401" class="i">+            }
</a><a href="#h10-0-402" id="h10-0-402" class="i">+        }
</a><a href="#h10-0-403" id="h10-0-403" class="i">+        Ok(aggregates)
</a><a href="#h10-0-404" id="h10-0-404" class="i">+    }
</a><a href="#h10-0-405" id="h10-0-405" class="i">+
</a><a href="#h10-0-406" id="h10-0-406" class="i">+    /// Extracts group by expressions, and replaces them with column references with the given
</a><a href="#h10-0-407" id="h10-0-407" class="i">+    /// offset. These can be either an arbitray expression, a reference to a SELECT column, or the
</a><a href="#h10-0-408" id="h10-0-408" class="i">+    /// same expression as a SELECT column. The following are all valid:
</a><a href="#h10-0-409" id="h10-0-409" class="i">+    ///
</a><a href="#h10-0-410" id="h10-0-410" class="i">+    /// SELECT released / 100 AS century, COUNT(*) FROM movies GROUP BY century
</a><a href="#h10-0-411" id="h10-0-411" class="i">+    /// SELECT released / 100, COUNT(*) FROM movies GROUP BY released / 100
</a><a href="#h10-0-412" id="h10-0-412" class="i">+    /// SELECT COUNT(*) FROM movies GROUP BY released / 100
</a><a href="#h10-0-413" id="h10-0-413" class="i">+    fn extract_groups(
</a><a href="#h10-0-414" id="h10-0-414" class="i">+        &amp;self,
</a><a href="#h10-0-415" id="h10-0-415" class="i">+        exprs: &amp;mut [(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h10-0-416" id="h10-0-416" class="i">+        group_by: Vec&lt;ast::Expression&gt;,
</a><a href="#h10-0-417" id="h10-0-417" class="i">+        offset: usize,
</a><a href="#h10-0-418" id="h10-0-418" class="i">+    ) -&gt; Result&lt;Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;&gt; {
</a><a href="#h10-0-419" id="h10-0-419" class="i">+        let mut groups = Vec::new();
</a><a href="#h10-0-420" id="h10-0-420" class="i">+        for g in group_by {
</a><a href="#h10-0-421" id="h10-0-421" class="i">+            // Look for references to SELECT columns with AS labels
</a><a href="#h10-0-422" id="h10-0-422" class="i">+            if let ast::Expression::Field(None, label) = &amp;g {
</a><a href="#h10-0-423" id="h10-0-423" class="i">+                if let Some(i) = exprs.iter().position(|(_, l)| l.as_deref() == Some(label)) {
</a><a href="#h10-0-424" id="h10-0-424" class="i">+                    groups.push((
</a><a href="#h10-0-425" id="h10-0-425" class="i">+                        replace(&amp;mut exprs[i].0, ast::Expression::Column(offset + groups.len())),
</a><a href="#h10-0-426" id="h10-0-426" class="i">+                        exprs[i].1.clone(),
</a><a href="#h10-0-427" id="h10-0-427" class="i">+                    ));
</a><a href="#h10-0-428" id="h10-0-428" class="i">+                    continue;
</a><a href="#h10-0-429" id="h10-0-429" class="i">+                }
</a><a href="#h10-0-430" id="h10-0-430" class="i">+            }
</a><a href="#h10-0-431" id="h10-0-431" class="i">+            // Look for expressions exactly equal to the group expression
</a><a href="#h10-0-432" id="h10-0-432" class="i">+            if let Some(i) = exprs.iter().position(|(e, _)| e == &amp;g) {
</a><a href="#h10-0-433" id="h10-0-433" class="i">+                groups.push((
</a><a href="#h10-0-434" id="h10-0-434" class="i">+                    replace(&amp;mut exprs[i].0, ast::Expression::Column(offset + groups.len())),
</a><a href="#h10-0-435" id="h10-0-435" class="i">+                    exprs[i].1.clone(),
</a><a href="#h10-0-436" id="h10-0-436" class="i">+                ));
</a><a href="#h10-0-437" id="h10-0-437" class="i">+                continue;
</a><a href="#h10-0-438" id="h10-0-438" class="i">+            }
</a><a href="#h10-0-439" id="h10-0-439" class="i">+            // Otherwise, just use the group expression directly
</a><a href="#h10-0-440" id="h10-0-440" class="i">+            groups.push((g, None))
</a><a href="#h10-0-441" id="h10-0-441" class="i">+        }
</a><a href="#h10-0-442" id="h10-0-442" class="i">+        // Make sure no group expressions contain Column references, which would be placed here
</a><a href="#h10-0-443" id="h10-0-443" class="i">+        // during extract_aggregates().
</a><a href="#h10-0-444" id="h10-0-444" class="i">+        for (expr, _) in &amp;groups {
</a><a href="#h10-0-445" id="h10-0-445" class="i">+            if self.is_aggregate(expr) {
</a><a href="#h10-0-446" id="h10-0-446" class="i">+                return errinput!(&quot;group expression cannot contain aggregates&quot;);
</a><a href="#h10-0-447" id="h10-0-447" class="i">+            }
</a><a href="#h10-0-448" id="h10-0-448" class="i">+        }
</a><a href="#h10-0-449" id="h10-0-449" class="i">+        Ok(groups)
</a><a href="#h10-0-450" id="h10-0-450" class="i">+    }
</a><a href="#h10-0-451" id="h10-0-451" class="i">+
</a><a href="#h10-0-452" id="h10-0-452" class="i">+    /// Injects hidden expressions into SELECT expressions. This is used for ORDER BY and HAVING, in
</a><a href="#h10-0-453" id="h10-0-453" class="i">+    /// order to apply these to fields or aggregates that are not present in the SELECT output, e.g.
</a><a href="#h10-0-454" id="h10-0-454" class="i">+    /// to order on a column that is not selected. This is done by replacing the relevant parts of
</a><a href="#h10-0-455" id="h10-0-455" class="i">+    /// the given expression with Column references to either existing columns or new, hidden
</a><a href="#h10-0-456" id="h10-0-456" class="i">+    /// columns in the select expressions. Returns the number of hidden columns added.
</a><a href="#h10-0-457" id="h10-0-457" class="i">+    fn inject_hidden(
</a><a href="#h10-0-458" id="h10-0-458" class="i">+        &amp;self,
</a><a href="#h10-0-459" id="h10-0-459" class="i">+        expr: &amp;mut ast::Expression,
</a><a href="#h10-0-460" id="h10-0-460" class="i">+        select: &amp;mut Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h10-0-461" id="h10-0-461" class="i">+    ) -&gt; Result&lt;usize&gt; {
</a><a href="#h10-0-462" id="h10-0-462" class="i">+        // Replace any identical expressions or label references with column references.
</a><a href="#h10-0-463" id="h10-0-463" class="i">+        for (i, (sexpr, label)) in select.iter().enumerate() {
</a><a href="#h10-0-464" id="h10-0-464" class="i">+            if expr == sexpr {
</a><a href="#h10-0-465" id="h10-0-465" class="i">+                *expr = ast::Expression::Column(i);
</a><a href="#h10-0-466" id="h10-0-466" class="i">+                continue;
</a><a href="#h10-0-467" id="h10-0-467" class="i">+            }
</a><a href="#h10-0-468" id="h10-0-468" class="i">+            if let Some(label) = label {
</a><a href="#h10-0-469" id="h10-0-469" class="i">+                expr.transform_mut(
</a><a href="#h10-0-470" id="h10-0-470" class="i">+                    &amp;mut |e| match e {
</a><a href="#h10-0-471" id="h10-0-471" class="i">+                        ast::Expression::Field(None, ref l) if l == label =&gt; {
</a><a href="#h10-0-472" id="h10-0-472" class="i">+                            Ok(ast::Expression::Column(i))
</a><a href="#h10-0-473" id="h10-0-473" class="i">+                        }
</a><a href="#h10-0-474" id="h10-0-474" class="i">+                        e =&gt; Ok(e),
</a><a href="#h10-0-475" id="h10-0-475" class="i">+                    },
</a><a href="#h10-0-476" id="h10-0-476" class="i">+                    &amp;mut Ok,
</a><a href="#h10-0-477" id="h10-0-477" class="i">+                )?;
</a><a href="#h10-0-478" id="h10-0-478" class="i">+            }
</a><a href="#h10-0-479" id="h10-0-479" class="i">+        }
</a><a href="#h10-0-480" id="h10-0-480" class="i">+        // Any remaining aggregate functions and field references must be extracted as hidden
</a><a href="#h10-0-481" id="h10-0-481" class="i">+        // columns.
</a><a href="#h10-0-482" id="h10-0-482" class="i">+        let mut hidden = 0;
</a><a href="#h10-0-483" id="h10-0-483" class="i">+        expr.transform_mut(
</a><a href="#h10-0-484" id="h10-0-484" class="i">+            &amp;mut |e| match &amp;e {
</a><a href="#h10-0-485" id="h10-0-485" class="i">+                ast::Expression::Function(f, a) if self.aggregate_from_name(f).is_some() =&gt; {
</a><a href="#h10-0-486" id="h10-0-486" class="i">+                    if let ast::Expression::Column(c) = a[0] {
</a><a href="#h10-0-487" id="h10-0-487" class="i">+                        if self.is_aggregate(&amp;select[c].0) {
</a><a href="#h10-0-488" id="h10-0-488" class="i">+                            return errinput!(&quot;aggregate function cannot reference aggregate&quot;);
</a><a href="#h10-0-489" id="h10-0-489" class="i">+                        }
</a><a href="#h10-0-490" id="h10-0-490" class="i">+                    }
</a><a href="#h10-0-491" id="h10-0-491" class="i">+                    select.push((e, None));
</a><a href="#h10-0-492" id="h10-0-492" class="i">+                    hidden += 1;
</a><a href="#h10-0-493" id="h10-0-493" class="i">+                    Ok(ast::Expression::Column(select.len() - 1))
</a><a href="#h10-0-494" id="h10-0-494" class="i">+                }
</a><a href="#h10-0-495" id="h10-0-495" class="i">+                ast::Expression::Field(_, _) =&gt; {
</a><a href="#h10-0-496" id="h10-0-496" class="i">+                    select.push((e, None));
</a><a href="#h10-0-497" id="h10-0-497" class="i">+                    hidden += 1;
</a><a href="#h10-0-498" id="h10-0-498" class="i">+                    Ok(ast::Expression::Column(select.len() - 1))
</a><a href="#h10-0-499" id="h10-0-499" class="i">+                }
</a><a href="#h10-0-500" id="h10-0-500" class="i">+                _ =&gt; Ok(e),
</a><a href="#h10-0-501" id="h10-0-501" class="i">+            },
</a><a href="#h10-0-502" id="h10-0-502" class="i">+            &amp;mut Ok,
</a><a href="#h10-0-503" id="h10-0-503" class="i">+        )?;
</a><a href="#h10-0-504" id="h10-0-504" class="i">+        Ok(hidden)
</a><a href="#h10-0-505" id="h10-0-505" class="i">+    }
</a><a href="#h10-0-506" id="h10-0-506" class="i">+
</a><a href="#h10-0-507" id="h10-0-507" class="i">+    /// Returns the aggregate corresponding to the given aggregate function name.
</a><a href="#h10-0-508" id="h10-0-508" class="i">+    fn aggregate_from_name(&amp;self, name: &amp;str) -&gt; Option&lt;Aggregate&gt; {
</a><a href="#h10-0-509" id="h10-0-509" class="i">+        match name {
</a><a href="#h10-0-510" id="h10-0-510" class="i">+            &quot;avg&quot; =&gt; Some(Aggregate::Average),
</a><a href="#h10-0-511" id="h10-0-511" class="i">+            &quot;count&quot; =&gt; Some(Aggregate::Count),
</a><a href="#h10-0-512" id="h10-0-512" class="i">+            &quot;max&quot; =&gt; Some(Aggregate::Max),
</a><a href="#h10-0-513" id="h10-0-513" class="i">+            &quot;min&quot; =&gt; Some(Aggregate::Min),
</a><a href="#h10-0-514" id="h10-0-514" class="i">+            &quot;sum&quot; =&gt; Some(Aggregate::Sum),
</a><a href="#h10-0-515" id="h10-0-515" class="i">+            _ =&gt; None,
</a><a href="#h10-0-516" id="h10-0-516" class="i">+        }
</a><a href="#h10-0-517" id="h10-0-517" class="i">+    }
</a><a href="#h10-0-518" id="h10-0-518" class="i">+
</a><a href="#h10-0-519" id="h10-0-519" class="i">+    /// Checks whether a given expression is an aggregate expression.
</a><a href="#h10-0-520" id="h10-0-520" class="i">+    fn is_aggregate(&amp;self, expr: &amp;ast::Expression) -&gt; bool {
</a><a href="#h10-0-521" id="h10-0-521" class="i">+        expr.contains(&amp;|e| match e {
</a><a href="#h10-0-522" id="h10-0-522" class="i">+            ast::Expression::Function(f, _) =&gt; self.aggregate_from_name(f).is_some(),
</a><a href="#h10-0-523" id="h10-0-523" class="i">+            _ =&gt; false,
</a><a href="#h10-0-524" id="h10-0-524" class="i">+        })
</a><a href="#h10-0-525" id="h10-0-525" class="i">+    }
</a><a href="#h10-0-526" id="h10-0-526" class="i">+
</a><a href="#h10-0-527" id="h10-0-527" class="i">+    /// Builds an expression from an AST expression
</a><a href="#h10-0-528" id="h10-0-528" class="i">+    #[allow(clippy::only_used_in_recursion)]
</a><a href="#h10-0-529" id="h10-0-529" class="i">+    fn build_expression(&amp;self, scope: &amp;mut Scope, expr: ast::Expression) -&gt; Result&lt;Expression&gt; {
</a><a href="#h10-0-530" id="h10-0-530" class="i">+        use Expression::*;
</a><a href="#h10-0-531" id="h10-0-531" class="i">+        Ok(match expr {
</a><a href="#h10-0-532" id="h10-0-532" class="i">+            ast::Expression::Literal(l) =&gt; Constant(match l {
</a><a href="#h10-0-533" id="h10-0-533" class="i">+                ast::Literal::Null =&gt; Value::Null,
</a><a href="#h10-0-534" id="h10-0-534" class="i">+                ast::Literal::Boolean(b) =&gt; Value::Boolean(b),
</a><a href="#h10-0-535" id="h10-0-535" class="i">+                ast::Literal::Integer(i) =&gt; Value::Integer(i),
</a><a href="#h10-0-536" id="h10-0-536" class="i">+                ast::Literal::Float(f) =&gt; Value::Float(f),
</a><a href="#h10-0-537" id="h10-0-537" class="i">+                ast::Literal::String(s) =&gt; Value::String(s),
</a><a href="#h10-0-538" id="h10-0-538" class="i">+            }),
</a><a href="#h10-0-539" id="h10-0-539" class="i">+            ast::Expression::Column(i) =&gt; Field(i, scope.get_label(i)?),
</a><a href="#h10-0-540" id="h10-0-540" class="i">+            ast::Expression::Field(table, name) =&gt; {
</a><a href="#h10-0-541" id="h10-0-541" class="i">+                Field(scope.resolve(table.as_deref(), &amp;name)?, Some((table, name)))
</a><a href="#h10-0-542" id="h10-0-542" class="i">+            }
</a><a href="#h10-0-543" id="h10-0-543" class="i">+            ast::Expression::Function(name, _) =&gt; return errinput!(&quot;unknown function {name}&quot;),
</a><a href="#h10-0-544" id="h10-0-544" class="i">+            ast::Expression::Operation(op) =&gt; match op {
</a><a href="#h10-0-545" id="h10-0-545" class="i">+                // Logical operators
</a><a href="#h10-0-546" id="h10-0-546" class="i">+                ast::Operation::And(lhs, rhs) =&gt; And(
</a><a href="#h10-0-547" id="h10-0-547" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-548" id="h10-0-548" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-549" id="h10-0-549" class="i">+                ),
</a><a href="#h10-0-550" id="h10-0-550" class="i">+                ast::Operation::Not(expr) =&gt; Not(self.build_expression(scope, *expr)?.into()),
</a><a href="#h10-0-551" id="h10-0-551" class="i">+                ast::Operation::Or(lhs, rhs) =&gt; Or(
</a><a href="#h10-0-552" id="h10-0-552" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-553" id="h10-0-553" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-554" id="h10-0-554" class="i">+                ),
</a><a href="#h10-0-555" id="h10-0-555" class="i">+
</a><a href="#h10-0-556" id="h10-0-556" class="i">+                // Comparison operators
</a><a href="#h10-0-557" id="h10-0-557" class="i">+                ast::Operation::Equal(lhs, rhs) =&gt; Equal(
</a><a href="#h10-0-558" id="h10-0-558" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-559" id="h10-0-559" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-560" id="h10-0-560" class="i">+                ),
</a><a href="#h10-0-561" id="h10-0-561" class="i">+                ast::Operation::GreaterThan(lhs, rhs) =&gt; GreaterThan(
</a><a href="#h10-0-562" id="h10-0-562" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-563" id="h10-0-563" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-564" id="h10-0-564" class="i">+                ),
</a><a href="#h10-0-565" id="h10-0-565" class="i">+                ast::Operation::GreaterThanOrEqual(lhs, rhs) =&gt; Or(
</a><a href="#h10-0-566" id="h10-0-566" class="i">+                    GreaterThan(
</a><a href="#h10-0-567" id="h10-0-567" class="i">+                        self.build_expression(scope, *lhs.clone())?.into(),
</a><a href="#h10-0-568" id="h10-0-568" class="i">+                        self.build_expression(scope, *rhs.clone())?.into(),
</a><a href="#h10-0-569" id="h10-0-569" class="i">+                    )
</a><a href="#h10-0-570" id="h10-0-570" class="i">+                    .into(),
</a><a href="#h10-0-571" id="h10-0-571" class="i">+                    Equal(
</a><a href="#h10-0-572" id="h10-0-572" class="i">+                        self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-573" id="h10-0-573" class="i">+                        self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-574" id="h10-0-574" class="i">+                    )
</a><a href="#h10-0-575" id="h10-0-575" class="i">+                    .into(),
</a><a href="#h10-0-576" id="h10-0-576" class="i">+                ),
</a><a href="#h10-0-577" id="h10-0-577" class="i">+                ast::Operation::IsNull(expr) =&gt; IsNull(self.build_expression(scope, *expr)?.into()),
</a><a href="#h10-0-578" id="h10-0-578" class="i">+                ast::Operation::LessThan(lhs, rhs) =&gt; LessThan(
</a><a href="#h10-0-579" id="h10-0-579" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-580" id="h10-0-580" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-581" id="h10-0-581" class="i">+                ),
</a><a href="#h10-0-582" id="h10-0-582" class="i">+                ast::Operation::LessThanOrEqual(lhs, rhs) =&gt; Or(
</a><a href="#h10-0-583" id="h10-0-583" class="i">+                    LessThan(
</a><a href="#h10-0-584" id="h10-0-584" class="i">+                        self.build_expression(scope, *lhs.clone())?.into(),
</a><a href="#h10-0-585" id="h10-0-585" class="i">+                        self.build_expression(scope, *rhs.clone())?.into(),
</a><a href="#h10-0-586" id="h10-0-586" class="i">+                    )
</a><a href="#h10-0-587" id="h10-0-587" class="i">+                    .into(),
</a><a href="#h10-0-588" id="h10-0-588" class="i">+                    Equal(
</a><a href="#h10-0-589" id="h10-0-589" class="i">+                        self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-590" id="h10-0-590" class="i">+                        self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-591" id="h10-0-591" class="i">+                    )
</a><a href="#h10-0-592" id="h10-0-592" class="i">+                    .into(),
</a><a href="#h10-0-593" id="h10-0-593" class="i">+                ),
</a><a href="#h10-0-594" id="h10-0-594" class="i">+                ast::Operation::Like(lhs, rhs) =&gt; Like(
</a><a href="#h10-0-595" id="h10-0-595" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-596" id="h10-0-596" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-597" id="h10-0-597" class="i">+                ),
</a><a href="#h10-0-598" id="h10-0-598" class="i">+                ast::Operation::NotEqual(lhs, rhs) =&gt; Not(Equal(
</a><a href="#h10-0-599" id="h10-0-599" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-600" id="h10-0-600" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-601" id="h10-0-601" class="i">+                )
</a><a href="#h10-0-602" id="h10-0-602" class="i">+                .into()),
</a><a href="#h10-0-603" id="h10-0-603" class="i">+
</a><a href="#h10-0-604" id="h10-0-604" class="i">+                // Mathematical operators
</a><a href="#h10-0-605" id="h10-0-605" class="i">+                ast::Operation::Assert(expr) =&gt; Assert(self.build_expression(scope, *expr)?.into()),
</a><a href="#h10-0-606" id="h10-0-606" class="i">+                ast::Operation::Add(lhs, rhs) =&gt; Add(
</a><a href="#h10-0-607" id="h10-0-607" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-608" id="h10-0-608" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-609" id="h10-0-609" class="i">+                ),
</a><a href="#h10-0-610" id="h10-0-610" class="i">+                ast::Operation::Divide(lhs, rhs) =&gt; Divide(
</a><a href="#h10-0-611" id="h10-0-611" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-612" id="h10-0-612" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-613" id="h10-0-613" class="i">+                ),
</a><a href="#h10-0-614" id="h10-0-614" class="i">+                ast::Operation::Exponentiate(lhs, rhs) =&gt; Exponentiate(
</a><a href="#h10-0-615" id="h10-0-615" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-616" id="h10-0-616" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-617" id="h10-0-617" class="i">+                ),
</a><a href="#h10-0-618" id="h10-0-618" class="i">+                ast::Operation::Factorial(expr) =&gt; {
</a><a href="#h10-0-619" id="h10-0-619" class="i">+                    Factorial(self.build_expression(scope, *expr)?.into())
</a><a href="#h10-0-620" id="h10-0-620" class="i">+                }
</a><a href="#h10-0-621" id="h10-0-621" class="i">+                ast::Operation::Modulo(lhs, rhs) =&gt; Modulo(
</a><a href="#h10-0-622" id="h10-0-622" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-623" id="h10-0-623" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-624" id="h10-0-624" class="i">+                ),
</a><a href="#h10-0-625" id="h10-0-625" class="i">+                ast::Operation::Multiply(lhs, rhs) =&gt; Multiply(
</a><a href="#h10-0-626" id="h10-0-626" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-627" id="h10-0-627" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-628" id="h10-0-628" class="i">+                ),
</a><a href="#h10-0-629" id="h10-0-629" class="i">+                ast::Operation::Negate(expr) =&gt; Negate(self.build_expression(scope, *expr)?.into()),
</a><a href="#h10-0-630" id="h10-0-630" class="i">+                ast::Operation::Subtract(lhs, rhs) =&gt; Subtract(
</a><a href="#h10-0-631" id="h10-0-631" class="i">+                    self.build_expression(scope, *lhs)?.into(),
</a><a href="#h10-0-632" id="h10-0-632" class="i">+                    self.build_expression(scope, *rhs)?.into(),
</a><a href="#h10-0-633" id="h10-0-633" class="i">+                ),
</a><a href="#h10-0-634" id="h10-0-634" class="i">+            },
</a><a href="#h10-0-635" id="h10-0-635" class="i">+        })
</a><a href="#h10-0-636" id="h10-0-636" class="i">+    }
</a><a href="#h10-0-637" id="h10-0-637" class="i">+
</a><a href="#h10-0-638" id="h10-0-638" class="i">+    /// Builds and evaluates a constant AST expression.
</a><a href="#h10-0-639" id="h10-0-639" class="i">+    fn evaluate_constant(&amp;self, expr: ast::Expression) -&gt; Result&lt;Value&gt; {
</a><a href="#h10-0-640" id="h10-0-640" class="i">+        self.build_expression(&amp;mut Scope::constant(), expr)?.evaluate(None)
</a><a href="#h10-0-641" id="h10-0-641" class="i">+    }
</a><a href="#h10-0-642" id="h10-0-642" class="i">+}
</a><a href="#h10-0-643" id="h10-0-643" class="i">+
</a><a href="#h10-0-644" id="h10-0-644" class="i">+/// Manages names available to expressions and executors, and maps them onto columns/fields.
</a><a href="#h10-0-645" id="h10-0-645" class="i">+#[derive(Clone, Debug)]
</a><a href="#h10-0-646" id="h10-0-646" class="i">+pub struct Scope {
</a><a href="#h10-0-647" id="h10-0-647" class="i">+    // If true, the scope is constant and cannot contain any variables.
</a><a href="#h10-0-648" id="h10-0-648" class="i">+    constant: bool,
</a><a href="#h10-0-649" id="h10-0-649" class="i">+    // Currently visible tables, by query name (i.e. alias or actual name).
</a><a href="#h10-0-650" id="h10-0-650" class="i">+    tables: HashMap&lt;String, Table&gt;,
</a><a href="#h10-0-651" id="h10-0-651" class="i">+    // Column labels, if any (qualified by table name when available)
</a><a href="#h10-0-652" id="h10-0-652" class="i">+    columns: Vec&lt;(Option&lt;String&gt;, Option&lt;String&gt;)&gt;,
</a><a href="#h10-0-653" id="h10-0-653" class="i">+    // Qualified names to column indexes.
</a><a href="#h10-0-654" id="h10-0-654" class="i">+    qualified: HashMap&lt;(String, String), usize&gt;,
</a><a href="#h10-0-655" id="h10-0-655" class="i">+    // Unqualified names to column indexes, if unique.
</a><a href="#h10-0-656" id="h10-0-656" class="i">+    unqualified: HashMap&lt;String, usize&gt;,
</a><a href="#h10-0-657" id="h10-0-657" class="i">+    // Unqialified ambiguous names.
</a><a href="#h10-0-658" id="h10-0-658" class="i">+    ambiguous: HashSet&lt;String&gt;,
</a><a href="#h10-0-659" id="h10-0-659" class="i">+}
</a><a href="#h10-0-660" id="h10-0-660" class="i">+
</a><a href="#h10-0-661" id="h10-0-661" class="i">+impl Scope {
</a><a href="#h10-0-662" id="h10-0-662" class="i">+    /// Creates a new, empty scope.
</a><a href="#h10-0-663" id="h10-0-663" class="i">+    fn new() -&gt; Self {
</a><a href="#h10-0-664" id="h10-0-664" class="i">+        Self {
</a><a href="#h10-0-665" id="h10-0-665" class="i">+            constant: false,
</a><a href="#h10-0-666" id="h10-0-666" class="i">+            tables: HashMap::new(),
</a><a href="#h10-0-667" id="h10-0-667" class="i">+            columns: Vec::new(),
</a><a href="#h10-0-668" id="h10-0-668" class="i">+            qualified: HashMap::new(),
</a><a href="#h10-0-669" id="h10-0-669" class="i">+            unqualified: HashMap::new(),
</a><a href="#h10-0-670" id="h10-0-670" class="i">+            ambiguous: HashSet::new(),
</a><a href="#h10-0-671" id="h10-0-671" class="i">+        }
</a><a href="#h10-0-672" id="h10-0-672" class="i">+    }
</a><a href="#h10-0-673" id="h10-0-673" class="i">+
</a><a href="#h10-0-674" id="h10-0-674" class="i">+    /// Creates a constant scope.
</a><a href="#h10-0-675" id="h10-0-675" class="i">+    fn constant() -&gt; Self {
</a><a href="#h10-0-676" id="h10-0-676" class="i">+        let mut scope = Self::new();
</a><a href="#h10-0-677" id="h10-0-677" class="i">+        scope.constant = true;
</a><a href="#h10-0-678" id="h10-0-678" class="i">+        scope
</a><a href="#h10-0-679" id="h10-0-679" class="i">+    }
</a><a href="#h10-0-680" id="h10-0-680" class="i">+
</a><a href="#h10-0-681" id="h10-0-681" class="i">+    /// Creates a scope from a table.
</a><a href="#h10-0-682" id="h10-0-682" class="i">+    fn from_table(table: Table) -&gt; Result&lt;Self&gt; {
</a><a href="#h10-0-683" id="h10-0-683" class="i">+        let mut scope = Self::new();
</a><a href="#h10-0-684" id="h10-0-684" class="i">+        scope.add_table(table.name.clone(), table)?;
</a><a href="#h10-0-685" id="h10-0-685" class="i">+        Ok(scope)
</a><a href="#h10-0-686" id="h10-0-686" class="i">+    }
</a><a href="#h10-0-687" id="h10-0-687" class="i">+
</a><a href="#h10-0-688" id="h10-0-688" class="i">+    /// Adds a column to the scope.
</a><a href="#h10-0-689" id="h10-0-689" class="i">+    #[allow(clippy::map_entry)]
</a><a href="#h10-0-690" id="h10-0-690" class="i">+    fn add_column(&amp;mut self, table: Option&lt;String&gt;, label: Option&lt;String&gt;) {
</a><a href="#h10-0-691" id="h10-0-691" class="i">+        if let Some(l) = label.clone() {
</a><a href="#h10-0-692" id="h10-0-692" class="i">+            if let Some(t) = table.clone() {
</a><a href="#h10-0-693" id="h10-0-693" class="i">+                self.qualified.insert((t, l.clone()), self.columns.len());
</a><a href="#h10-0-694" id="h10-0-694" class="i">+            }
</a><a href="#h10-0-695" id="h10-0-695" class="i">+            if !self.ambiguous.contains(&amp;l) {
</a><a href="#h10-0-696" id="h10-0-696" class="i">+                if !self.unqualified.contains_key(&amp;l) {
</a><a href="#h10-0-697" id="h10-0-697" class="i">+                    self.unqualified.insert(l, self.columns.len());
</a><a href="#h10-0-698" id="h10-0-698" class="i">+                } else {
</a><a href="#h10-0-699" id="h10-0-699" class="i">+                    self.unqualified.remove(&amp;l);
</a><a href="#h10-0-700" id="h10-0-700" class="i">+                    self.ambiguous.insert(l);
</a><a href="#h10-0-701" id="h10-0-701" class="i">+                }
</a><a href="#h10-0-702" id="h10-0-702" class="i">+            }
</a><a href="#h10-0-703" id="h10-0-703" class="i">+        }
</a><a href="#h10-0-704" id="h10-0-704" class="i">+        self.columns.push((table, label));
</a><a href="#h10-0-705" id="h10-0-705" class="i">+    }
</a><a href="#h10-0-706" id="h10-0-706" class="i">+
</a><a href="#h10-0-707" id="h10-0-707" class="i">+    /// Adds a table to the scope.
</a><a href="#h10-0-708" id="h10-0-708" class="i">+    fn add_table(&amp;mut self, label: String, table: Table) -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-709" id="h10-0-709" class="i">+        if self.constant {
</a><a href="#h10-0-710" id="h10-0-710" class="i">+            panic!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h10-0-711" id="h10-0-711" class="i">+        }
</a><a href="#h10-0-712" id="h10-0-712" class="i">+        if self.tables.contains_key(&amp;label) {
</a><a href="#h10-0-713" id="h10-0-713" class="i">+            return errinput!(&quot;duplicate table name {label}&quot;);
</a><a href="#h10-0-714" id="h10-0-714" class="i">+        }
</a><a href="#h10-0-715" id="h10-0-715" class="i">+        for column in &amp;table.columns {
</a><a href="#h10-0-716" id="h10-0-716" class="i">+            self.add_column(Some(label.clone()), Some(column.name.clone()));
</a><a href="#h10-0-717" id="h10-0-717" class="i">+        }
</a><a href="#h10-0-718" id="h10-0-718" class="i">+        self.tables.insert(label, table);
</a><a href="#h10-0-719" id="h10-0-719" class="i">+        Ok(())
</a><a href="#h10-0-720" id="h10-0-720" class="i">+    }
</a><a href="#h10-0-721" id="h10-0-721" class="i">+
</a><a href="#h10-0-722" id="h10-0-722" class="i">+    /// Fetches a column from the scope by index.
</a><a href="#h10-0-723" id="h10-0-723" class="i">+    fn get_column(&amp;self, index: usize) -&gt; Result&lt;(Option&lt;String&gt;, Option&lt;String&gt;)&gt; {
</a><a href="#h10-0-724" id="h10-0-724" class="i">+        if self.constant {
</a><a href="#h10-0-725" id="h10-0-725" class="i">+            return errinput!(&quot;expression must be constant, found column {index}&quot;);
</a><a href="#h10-0-726" id="h10-0-726" class="i">+        }
</a><a href="#h10-0-727" id="h10-0-727" class="i">+        self.columns.get(index).cloned().ok_or(errinput!(&quot;column index {index} not found&quot;))
</a><a href="#h10-0-728" id="h10-0-728" class="i">+    }
</a><a href="#h10-0-729" id="h10-0-729" class="i">+
</a><a href="#h10-0-730" id="h10-0-730" class="i">+    /// Fetches a column label by index, if any.
</a><a href="#h10-0-731" id="h10-0-731" class="i">+    fn get_label(&amp;self, index: usize) -&gt; Result&lt;Option&lt;(Option&lt;String&gt;, String)&gt;&gt; {
</a><a href="#h10-0-732" id="h10-0-732" class="i">+        Ok(match self.get_column(index)? {
</a><a href="#h10-0-733" id="h10-0-733" class="i">+            (table, Some(name)) =&gt; Some((table, name)),
</a><a href="#h10-0-734" id="h10-0-734" class="i">+            _ =&gt; None,
</a><a href="#h10-0-735" id="h10-0-735" class="i">+        })
</a><a href="#h10-0-736" id="h10-0-736" class="i">+    }
</a><a href="#h10-0-737" id="h10-0-737" class="i">+
</a><a href="#h10-0-738" id="h10-0-738" class="i">+    /// Merges two scopes, by appending the given scope to self.
</a><a href="#h10-0-739" id="h10-0-739" class="i">+    fn merge(&amp;mut self, scope: Scope) -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-740" id="h10-0-740" class="i">+        if self.constant {
</a><a href="#h10-0-741" id="h10-0-741" class="i">+            panic!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h10-0-742" id="h10-0-742" class="i">+        }
</a><a href="#h10-0-743" id="h10-0-743" class="i">+        for (label, table) in scope.tables {
</a><a href="#h10-0-744" id="h10-0-744" class="i">+            if self.tables.contains_key(&amp;label) {
</a><a href="#h10-0-745" id="h10-0-745" class="i">+                return errinput!(&quot;duplicate table name {label}&quot;);
</a><a href="#h10-0-746" id="h10-0-746" class="i">+            }
</a><a href="#h10-0-747" id="h10-0-747" class="i">+            self.tables.insert(label, table);
</a><a href="#h10-0-748" id="h10-0-748" class="i">+        }
</a><a href="#h10-0-749" id="h10-0-749" class="i">+        for (table, label) in scope.columns {
</a><a href="#h10-0-750" id="h10-0-750" class="i">+            self.add_column(table, label);
</a><a href="#h10-0-751" id="h10-0-751" class="i">+        }
</a><a href="#h10-0-752" id="h10-0-752" class="i">+        Ok(())
</a><a href="#h10-0-753" id="h10-0-753" class="i">+    }
</a><a href="#h10-0-754" id="h10-0-754" class="i">+
</a><a href="#h10-0-755" id="h10-0-755" class="i">+    /// Resolves a name, optionally qualified by a table name.
</a><a href="#h10-0-756" id="h10-0-756" class="i">+    fn resolve(&amp;self, table: Option&lt;&amp;str&gt;, name: &amp;str) -&gt; Result&lt;usize&gt; {
</a><a href="#h10-0-757" id="h10-0-757" class="i">+        if self.constant {
</a><a href="#h10-0-758" id="h10-0-758" class="i">+            return errinput!(
</a><a href="#h10-0-759" id="h10-0-759" class="i">+                &quot;expression must be constant, found field {}&quot;,
</a><a href="#h10-0-760" id="h10-0-760" class="i">+                if let Some(table) = table { format!(&quot;{}.{}&quot;, table, name) } else { name.into() }
</a><a href="#h10-0-761" id="h10-0-761" class="i">+            );
</a><a href="#h10-0-762" id="h10-0-762" class="i">+        }
</a><a href="#h10-0-763" id="h10-0-763" class="i">+        if let Some(table) = table {
</a><a href="#h10-0-764" id="h10-0-764" class="i">+            if !self.tables.contains_key(table) {
</a><a href="#h10-0-765" id="h10-0-765" class="i">+                return errinput!(&quot;unknown table {table}&quot;);
</a><a href="#h10-0-766" id="h10-0-766" class="i">+            }
</a><a href="#h10-0-767" id="h10-0-767" class="i">+            self.qualified
</a><a href="#h10-0-768" id="h10-0-768" class="i">+                .get(&amp;(table.into(), name.into()))
</a><a href="#h10-0-769" id="h10-0-769" class="i">+                .copied()
</a><a href="#h10-0-770" id="h10-0-770" class="i">+                .ok_or(errinput!(&quot;Unknown field {table}.{name}&quot;))
</a><a href="#h10-0-771" id="h10-0-771" class="i">+        } else if self.ambiguous.contains(name) {
</a><a href="#h10-0-772" id="h10-0-772" class="i">+            errinput!(&quot;ambiguous field {name}&quot;)
</a><a href="#h10-0-773" id="h10-0-773" class="i">+        } else {
</a><a href="#h10-0-774" id="h10-0-774" class="i">+            self.unqualified.get(name).copied().ok_or(errinput!(&quot;unknown field {name}&quot;))
</a><a href="#h10-0-775" id="h10-0-775" class="i">+        }
</a><a href="#h10-0-776" id="h10-0-776" class="i">+    }
</a><a href="#h10-0-777" id="h10-0-777" class="i">+
</a><a href="#h10-0-778" id="h10-0-778" class="i">+    /// Number of columns in the current scope.
</a><a href="#h10-0-779" id="h10-0-779" class="i">+    fn len(&amp;self) -&gt; usize {
</a><a href="#h10-0-780" id="h10-0-780" class="i">+        self.columns.len()
</a><a href="#h10-0-781" id="h10-0-781" class="i">+    }
</a><a href="#h10-0-782" id="h10-0-782" class="i">+
</a><a href="#h10-0-783" id="h10-0-783" class="i">+    /// Projects the scope. This takes a set of expressions and labels in the current scope,
</a><a href="#h10-0-784" id="h10-0-784" class="i">+    /// and returns a new scope for the projection.
</a><a href="#h10-0-785" id="h10-0-785" class="i">+    fn project(&amp;mut self, projection: &amp;[(Expression, Option&lt;String&gt;)]) -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-786" id="h10-0-786" class="i">+        if self.constant {
</a><a href="#h10-0-787" id="h10-0-787" class="i">+            panic!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h10-0-788" id="h10-0-788" class="i">+        }
</a><a href="#h10-0-789" id="h10-0-789" class="i">+        let mut new = Self::new();
</a><a href="#h10-0-790" id="h10-0-790" class="i">+        new.tables = self.tables.clone();
</a><a href="#h10-0-791" id="h10-0-791" class="i">+        for (expr, label) in projection {
</a><a href="#h10-0-792" id="h10-0-792" class="i">+            match (expr, label) {
</a><a href="#h10-0-793" id="h10-0-793" class="i">+                (_, Some(label)) =&gt; new.add_column(None, Some(label.clone())),
</a><a href="#h10-0-794" id="h10-0-794" class="i">+                (Expression::Field(_, Some((Some(table), name))), _) =&gt; {
</a><a href="#h10-0-795" id="h10-0-795" class="i">+                    new.add_column(Some(table.clone()), Some(name.clone()))
</a><a href="#h10-0-796" id="h10-0-796" class="i">+                }
</a><a href="#h10-0-797" id="h10-0-797" class="i">+                (Expression::Field(_, Some((None, name))), _) =&gt; {
</a><a href="#h10-0-798" id="h10-0-798" class="i">+                    if let Some(i) = self.unqualified.get(name) {
</a><a href="#h10-0-799" id="h10-0-799" class="i">+                        let (table, name) = self.columns[*i].clone();
</a><a href="#h10-0-800" id="h10-0-800" class="i">+                        new.add_column(table, name);
</a><a href="#h10-0-801" id="h10-0-801" class="i">+                    }
</a><a href="#h10-0-802" id="h10-0-802" class="i">+                }
</a><a href="#h10-0-803" id="h10-0-803" class="i">+                (Expression::Field(i, None), _) =&gt; {
</a><a href="#h10-0-804" id="h10-0-804" class="i">+                    let (table, label) = self.columns.get(*i).cloned().unwrap_or((None, None));
</a><a href="#h10-0-805" id="h10-0-805" class="i">+                    new.add_column(table, label)
</a><a href="#h10-0-806" id="h10-0-806" class="i">+                }
</a><a href="#h10-0-807" id="h10-0-807" class="i">+                _ =&gt; new.add_column(None, None),
</a><a href="#h10-0-808" id="h10-0-808" class="i">+            }
</a><a href="#h10-0-809" id="h10-0-809" class="i">+        }
</a><a href="#h10-0-810" id="h10-0-810" class="i">+        *self = new;
</a><a href="#h10-0-811" id="h10-0-811" class="i">+        Ok(())
</a><a href="#h10-0-812" id="h10-0-812" class="i">+    }
</a><a href="#h10-0-813" id="h10-0-813" class="i">+}
</a><b>diff --git a/<a id="h11" href="../file/tests/sql/query.rs.html">tests/sql/query.rs</a> b/<a href="../file/tests/sql/query.rs.html">tests/sql/query.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -4,7 +4,7 @@ use toydb::errdata;
</a> use toydb::error::Result;
 use toydb::sql::engine::{Engine, StatementResult, Transaction};
 use toydb::sql::parser::Parser;
<a href="#h11-0-3" id="h11-0-3" class="d">-use toydb::sql::plan::Plan;
</a><a href="#h11-0-4" id="h11-0-4" class="i">+use toydb::sql::planner::Plan;
</a> 
 use goldenfile::Mint;
 use std::io::Write;
</pre>
</div>
</body>
</html>
