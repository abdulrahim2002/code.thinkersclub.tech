<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tweak Raft state transitions - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/a0849a97dee91af7336634db88bf74ef3d747786.html">a0849a97dee91af7336634db88bf74ef3d747786</a>
<b>parent</b> <a href="../commit/64e3ef8c6d779e5da42447940f91dc23f5e0df21.html">64e3ef8c6d779e5da42447940f91dc23f5e0df21</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun,  7 Jan 2024 13:14:13 +0100

Tweak Raft state transitions

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">28</td><td><span class="i">++++++++++++++++</span><span class="d">------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/raft/node/follower.rs</a></td><td> | </td><td class="num">27</td><td><span class="i">++++++++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/node/leader.rs</a></td><td> | </td><td class="num">11</td><td><span class="i">++++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/node/mod.rs</a></td><td> | </td><td class="num">24</td><td><span class="i">+++++++++++++++++</span><span class="d">-------</span></td></tr>
</table></pre><pre>4 files changed, 55 insertions(+), 35 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -46,10 +46,14 @@ impl RawNode&lt;Candidate&gt; {
</a>         Ok(())
     }
 
<a href="#h0-0-3" id="h0-0-3" class="d">-    /// Transforms the node into a follower. We either lost the election
</a><a href="#h0-0-4" id="h0-0-4" class="d">-    /// and follow the winner, or we discovered a new term in which case
</a><a href="#h0-0-5" id="h0-0-5" class="d">-    /// we step into it as a leaderless follower.
</a><a href="#h0-0-6" id="h0-0-6" class="d">-    fn become_follower(mut self, term: Term, leader: Option&lt;NodeID&gt;) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
</a><a href="#h0-0-7" id="h0-0-7" class="i">+    /// Transitions the candidate to a follower. We either lost the election and
</a><a href="#h0-0-8" id="h0-0-8" class="i">+    /// follow the winner, or we discovered a new term in which case we step
</a><a href="#h0-0-9" id="h0-0-9" class="i">+    /// into it as a leaderless follower.
</a><a href="#h0-0-10" id="h0-0-10" class="i">+    pub(super) fn into_follower(
</a><a href="#h0-0-11" id="h0-0-11" class="i">+        mut self,
</a><a href="#h0-0-12" id="h0-0-12" class="i">+        term: Term,
</a><a href="#h0-0-13" id="h0-0-13" class="i">+        leader: Option&lt;NodeID&gt;,
</a><a href="#h0-0-14" id="h0-0-14" class="i">+    ) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
</a>         assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
 
         if let Some(leader) = leader {
<a href="#h0-1" id="h0-1" class="h">@@ -57,7 +61,7 @@ impl RawNode&lt;Candidate&gt; {
</a>             assert_eq!(term, self.term, &quot;Can&#39;t follow leader in different term&quot;);
             info!(&quot;Lost election, following leader {} in term {}&quot;, leader, term);
             let voted_for = Some(self.id); // by definition
<a href="#h0-1-3" id="h0-1-3" class="d">-            Ok(self.become_role(Follower::new(Some(leader), voted_for)))
</a><a href="#h0-1-4" id="h0-1-4" class="i">+            Ok(self.into_role(Follower::new(Some(leader), voted_for)))
</a>         } else {
             // We found a new term, but we don&#39;t necessarily know who the leader
             // is yet. We&#39;ll find out when we step a message from it.
<a href="#h0-2" id="h0-2" class="h">@@ -65,16 +69,16 @@ impl RawNode&lt;Candidate&gt; {
</a>             info!(&quot;Discovered new term {}&quot;, term);
             self.term = term;
             self.log.set_term(term, None)?;
<a href="#h0-2-3" id="h0-2-3" class="d">-            Ok(self.become_role(Follower::new(None, None)))
</a><a href="#h0-2-4" id="h0-2-4" class="i">+            Ok(self.into_role(Follower::new(None, None)))
</a>         }
     }
 
<a href="#h0-2-8" id="h0-2-8" class="d">-    /// Transition to leader role.
</a><a href="#h0-2-9" id="h0-2-9" class="d">-    pub(super) fn become_leader(self) -&gt; Result&lt;RawNode&lt;Leader&gt;&gt; {
</a><a href="#h0-2-10" id="h0-2-10" class="i">+    /// Transitions the candidate to a leader. We won the election.
</a><a href="#h0-2-11" id="h0-2-11" class="i">+    pub(super) fn into_leader(self) -&gt; Result&lt;RawNode&lt;Leader&gt;&gt; {
</a>         info!(&quot;Won election for term {}, becoming leader&quot;, self.term);
         let peers = self.peers.clone();
         let (last_index, _) = self.log.get_last_index();
<a href="#h0-2-15" id="h0-2-15" class="d">-        let mut node = self.become_role(Leader::new(peers, last_index));
</a><a href="#h0-2-16" id="h0-2-16" class="i">+        let mut node = self.into_role(Leader::new(peers, last_index));
</a>         node.heartbeat()?;
 
         // Propose an empty command when assuming leadership, to disambiguate
<a href="#h0-3" id="h0-3" class="h">@@ -98,7 +102,7 @@ impl RawNode&lt;Candidate&gt; {
</a>         // follower in it and step the message. If the message is a Heartbeat or
         // AppendEntries from the leader, stepping it will follow the leader.
         if msg.term &gt; self.term {
<a href="#h0-3-3" id="h0-3-3" class="d">-            return self.become_follower(msg.term, None)?.step(msg);
</a><a href="#h0-3-4" id="h0-3-4" class="i">+            return self.into_follower(msg.term, None)?.step(msg);
</a>         }
 
         match msg.event {
<a href="#h0-4" id="h0-4" class="h">@@ -110,14 +114,14 @@ impl RawNode&lt;Candidate&gt; {
</a>             Event::GrantVote =&gt; {
                 self.role.votes.insert(msg.from.unwrap());
                 if self.role.votes.len() as u64 &gt;= self.quorum() {
<a href="#h0-4-3" id="h0-4-3" class="d">-                    return Ok(self.become_leader()?.into());
</a><a href="#h0-4-4" id="h0-4-4" class="i">+                    return Ok(self.into_leader()?.into());
</a>                 }
             }
 
             // If we receive a heartbeat or entries in this term, we lost the
             // election and have a new leader. Follow it and step the message.
             Event::Heartbeat { .. } | Event::AppendEntries { .. } =&gt; {
<a href="#h0-4-11" id="h0-4-11" class="d">-                return self.become_follower(msg.term, Some(msg.from.unwrap()))?.step(msg);
</a><a href="#h0-4-12" id="h0-4-12" class="i">+                return self.into_follower(msg.term, Some(msg.from.unwrap()))?.step(msg);
</a>             }
 
             // Abort any inbound client requests while candidate.
<b>diff --git a/<a id="h1" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -73,20 +73,25 @@ impl RawNode&lt;Follower&gt; {
</a>         Ok(())
     }
 
<a href="#h1-0-3" id="h1-0-3" class="d">-    /// Transforms the node into a candidate, by campaigning for leadership in a
</a><a href="#h1-0-4" id="h1-0-4" class="d">-    /// new term.
</a><a href="#h1-0-5" id="h1-0-5" class="d">-    pub(super) fn become_candidate(mut self) -&gt; Result&lt;RawNode&lt;Candidate&gt;&gt; {
</a><a href="#h1-0-6" id="h1-0-6" class="i">+    /// Transitions the follower into a candidate, by campaigning for
</a><a href="#h1-0-7" id="h1-0-7" class="i">+    /// leadership in a new term.
</a><a href="#h1-0-8" id="h1-0-8" class="i">+    pub(super) fn into_candidate(mut self) -&gt; Result&lt;RawNode&lt;Candidate&gt;&gt; {
</a>         // Abort any forwarded requests. These must be retried with new leader.
         self.abort_forwarded()?;
 
<a href="#h1-0-12" id="h1-0-12" class="d">-        let mut node = self.become_role(Candidate::new());
</a><a href="#h1-0-13" id="h1-0-13" class="i">+        let mut node = self.into_role(Candidate::new());
</a>         node.campaign()?;
         Ok(node)
     }
 
<a href="#h1-0-18" id="h1-0-18" class="d">-    /// Transforms the node into a follower, either a leaderless follower in a
</a><a href="#h1-0-19" id="h1-0-19" class="d">-    /// new term or following a leader in the current term.
</a><a href="#h1-0-20" id="h1-0-20" class="d">-    fn become_follower(mut self, leader: Option&lt;NodeID&gt;, term: Term) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
</a><a href="#h1-0-21" id="h1-0-21" class="i">+    /// Transitions the candidate into a follower, either a leaderless follower
</a><a href="#h1-0-22" id="h1-0-22" class="i">+    /// in a new term (e.g. if someone holds a new election) or following a
</a><a href="#h1-0-23" id="h1-0-23" class="i">+    /// leader in the current term once someone wins the election.
</a><a href="#h1-0-24" id="h1-0-24" class="i">+    pub(super) fn into_follower(
</a><a href="#h1-0-25" id="h1-0-25" class="i">+        mut self,
</a><a href="#h1-0-26" id="h1-0-26" class="i">+        leader: Option&lt;NodeID&gt;,
</a><a href="#h1-0-27" id="h1-0-27" class="i">+        term: Term,
</a><a href="#h1-0-28" id="h1-0-28" class="i">+    ) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
</a>         assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
 
         // Abort any forwarded requests. These must be retried with new leader.
<a href="#h1-1" id="h1-1" class="h">@@ -125,7 +130,7 @@ impl RawNode&lt;Follower&gt; {
</a>         // follower in it and step the message. If the message is a Heartbeat or
         // AppendEntries from the leader, stepping it will follow the leader.
         if msg.term &gt; self.term {
<a href="#h1-1-3" id="h1-1-3" class="d">-            return self.become_follower(None, msg.term)?.step(msg);
</a><a href="#h1-1-4" id="h1-1-4" class="i">+            return self.into_follower(None, msg.term)?.step(msg);
</a>         }
 
         // Record when we last saw a message from the leader (if any).
<a href="#h1-2" id="h1-2" class="h">@@ -142,7 +147,7 @@ impl RawNode&lt;Follower&gt; {
</a>                 let from = msg.from.unwrap();
                 match self.role.leader {
                     Some(leader) =&gt; assert_eq!(from, leader, &quot;Multiple leaders in term&quot;),
<a href="#h1-2-3" id="h1-2-3" class="d">-                    None =&gt; self = self.become_follower(Some(from), msg.term)?,
</a><a href="#h1-2-4" id="h1-2-4" class="i">+                    None =&gt; self = self.into_follower(Some(from), msg.term)?,
</a>                 }
 
                 // Advance commit index and apply entries if possible.
<a href="#h1-3" id="h1-3" class="h">@@ -165,7 +170,7 @@ impl RawNode&lt;Follower&gt; {
</a>                 let from = msg.from.unwrap();
                 match self.role.leader {
                     Some(leader) =&gt; assert_eq!(from, leader, &quot;Multiple leaders in term&quot;),
<a href="#h1-3-3" id="h1-3-3" class="d">-                    None =&gt; self = self.become_follower(Some(from), msg.term)?,
</a><a href="#h1-3-4" id="h1-3-4" class="i">+                    None =&gt; self = self.into_follower(Some(from), msg.term)?,
</a>                 }
 
                 // Append the entries, if possible.
<a href="#h1-4" id="h1-4" class="h">@@ -250,7 +255,7 @@ impl RawNode&lt;Follower&gt; {
</a> 
         self.role.leader_seen += 1;
         if self.role.leader_seen &gt;= self.role.election_timeout {
<a href="#h1-4-3" id="h1-4-3" class="d">-            return Ok(self.become_candidate()?.into());
</a><a href="#h1-4-4" id="h1-4-4" class="i">+            return Ok(self.into_candidate()?.into());
</a>         }
         Ok(self.into())
     }
<b>diff --git a/<a id="h2" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -45,9 +45,10 @@ impl RawNode&lt;Leader&gt; {
</a>         Ok(())
     }
 
<a href="#h2-0-3" id="h2-0-3" class="d">-    /// Transforms the leader into a follower. This can only happen if we find a
</a><a href="#h2-0-4" id="h2-0-4" class="d">-    /// new term, so we become a leaderless follower.
</a><a href="#h2-0-5" id="h2-0-5" class="d">-    fn become_follower(mut self, term: Term) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
</a><a href="#h2-0-6" id="h2-0-6" class="i">+    /// Transitions the leader into a follower. This can only happen if we
</a><a href="#h2-0-7" id="h2-0-7" class="i">+    /// discover a new term, so we become a leaderless follower. Subsequently
</a><a href="#h2-0-8" id="h2-0-8" class="i">+    /// stepping the received message may discover the leader, if there is one.
</a><a href="#h2-0-9" id="h2-0-9" class="i">+    pub(super) fn into_follower(mut self, term: Term) -&gt; Result&lt;RawNode&lt;Follower&gt;&gt; {
</a>         assert!(term &gt;= self.term, &quot;Term regression {} -&gt; {}&quot;, self.term, term);
         assert!(term &gt; self.term, &quot;Can only become follower in later term&quot;);
 
<a href="#h2-1" id="h2-1" class="h">@@ -55,7 +56,7 @@ impl RawNode&lt;Leader&gt; {
</a>         self.term = term;
         self.log.set_term(term, None)?;
         self.state_tx.send(Instruction::Abort)?;
<a href="#h2-1-3" id="h2-1-3" class="d">-        Ok(self.become_role(Follower::new(None, None)))
</a><a href="#h2-1-4" id="h2-1-4" class="i">+        Ok(self.into_role(Follower::new(None, None)))
</a>     }
 
     /// Processes a message.
<a href="#h2-2" id="h2-2" class="h">@@ -73,7 +74,7 @@ impl RawNode&lt;Leader&gt; {
</a>         // follower in it and step the message. If the message is a Heartbeat or
         // AppendEntries from the leader, stepping it will follow the leader.
         if msg.term &gt; self.term {
<a href="#h2-2-3" id="h2-2-3" class="d">-            return self.become_follower(msg.term)?.step(msg);
</a><a href="#h2-2-4" id="h2-2-4" class="i">+            return self.into_follower(msg.term)?.step(msg);
</a>         }
 
         match msg.event {
<b>diff --git a/<a id="h3" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -48,7 +48,14 @@ pub struct Status {
</a>     pub storage_size: u64,
 }
 
<a href="#h3-0-3" id="h3-0-3" class="d">-/// The local Raft node state machine.
</a><a href="#h3-0-4" id="h3-0-4" class="i">+/// A Raft node, with a dynamic role. The node is driven synchronously by
</a><a href="#h3-0-5" id="h3-0-5" class="i">+/// processing inbound messages via step() or by advancing time via tick().
</a><a href="#h3-0-6" id="h3-0-6" class="i">+/// These methods consume the current node, and return a new one with a possibly
</a><a href="#h3-0-7" id="h3-0-7" class="i">+/// different role. Outbound messages are sent via the given node_tx channel.
</a><a href="#h3-0-8" id="h3-0-8" class="i">+///
</a><a href="#h3-0-9" id="h3-0-9" class="i">+/// This enum wraps the RawNode&lt;Role&gt; types, which implement the actual
</a><a href="#h3-0-10" id="h3-0-10" class="i">+/// node logic. It exists for ergonomic use across role transitions, i.e
</a><a href="#h3-0-11" id="h3-0-11" class="i">+/// node = node.step()?.
</a> pub enum Node {
     Candidate(RawNode&lt;Candidate&gt;),
     Follower(RawNode&lt;Follower&gt;),
<a href="#h3-1" id="h3-1" class="h">@@ -73,7 +80,7 @@ impl Node {
</a>         let node = RawNode::new(id, peers, log, node_tx, state_tx)?;
         if node.peers.is_empty() {
             // If there are no peers, become leader immediately.
<a href="#h3-1-3" id="h3-1-3" class="d">-            return Ok(node.become_candidate()?.become_leader()?.into());
</a><a href="#h3-1-4" id="h3-1-4" class="i">+            return Ok(node.into_candidate()?.into_leader()?.into());
</a>         }
         Ok(node.into())
     }
<a href="#h3-2" id="h3-2" class="h">@@ -128,7 +135,10 @@ impl From&lt;RawNode&lt;Leader&gt;&gt; for Node {
</a> /// A Raft role: leader, follower, or candidate.
 pub trait Role: Clone + std::fmt::Debug + PartialEq {}
 
<a href="#h3-2-3" id="h3-2-3" class="d">-// A Raft node with role R
</a><a href="#h3-2-4" id="h3-2-4" class="i">+/// A Raft node with the concrete role R.
</a><a href="#h3-2-5" id="h3-2-5" class="i">+///
</a><a href="#h3-2-6" id="h3-2-6" class="i">+/// This implements the typestate pattern, where individual node states (roles)
</a><a href="#h3-2-7" id="h3-2-7" class="i">+/// are encoded as RawNode&lt;Role&gt;. See: http://cliffle.com/blog/rust-typestate/
</a> pub struct RawNode&lt;R: Role = Follower&gt; {
     id: NodeID,
     peers: HashSet&lt;NodeID&gt;,
<a href="#h3-3" id="h3-3" class="h">@@ -140,8 +150,8 @@ pub struct RawNode&lt;R: Role = Follower&gt; {
</a> }
 
 impl&lt;R: Role&gt; RawNode&lt;R&gt; {
<a href="#h3-3-3" id="h3-3-3" class="d">-    /// Transforms the node into another role.
</a><a href="#h3-3-4" id="h3-3-4" class="d">-    fn become_role&lt;T: Role&gt;(self, role: T) -&gt; RawNode&lt;T&gt; {
</a><a href="#h3-3-5" id="h3-3-5" class="i">+    /// Helper for role transitions.
</a><a href="#h3-3-6" id="h3-3-6" class="i">+    fn into_role&lt;T: Role&gt;(self, role: T) -&gt; RawNode&lt;T&gt; {
</a>         RawNode {
             id: self.id,
             peers: self.peers,
<a href="#h3-4" id="h3-4" class="h">@@ -481,10 +491,10 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h3-4-3" id="h3-4-3" class="d">-    fn become_role() -&gt; Result&lt;()&gt; {
</a><a href="#h3-4-4" id="h3-4-4" class="i">+    fn into_role() -&gt; Result&lt;()&gt; {
</a>         let (node, _) = setup_rolenode()?;
         let role = Candidate::new();
<a href="#h3-4-7" id="h3-4-7" class="d">-        let new = node.become_role(role.clone());
</a><a href="#h3-4-8" id="h3-4-8" class="i">+        let new = node.into_role(role.clone());
</a>         assert_eq!(new.id, 1);
         assert_eq!(new.term, 1);
         assert_eq!(new.peers, HashSet::from([2, 3]));
</pre>
</div>
</body>
</html>
