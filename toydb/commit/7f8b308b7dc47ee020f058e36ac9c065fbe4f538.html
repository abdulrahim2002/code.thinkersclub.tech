<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Use KeyCode for MVCC and SQL keys. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/7f8b308b7dc47ee020f058e36ac9c065fbe4f538.html">7f8b308b7dc47ee020f058e36ac9c065fbe4f538</a>
<b>parent</b> <a href="../commit/1cd89d1cc502b1dc7443e0b4059570cd88af63cf.html">1cd89d1cc502b1dc7443e0b4059570cd88af63cf</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Mon,  4 Sep 2023 00:53:45 +0200

Use KeyCode for MVCC and SQL keys.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">docs/architecture.md</a></td><td> | </td><td class="num">29</td><td><span class="i">++++++++++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">113</td><td><span class="i">+++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h2">src/storage/encoding.rs</a></td><td> | </td><td class="num">504</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/storage/mod.rs</a></td><td> | </td><td class="num">1</td><td><span class="i"></span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/storage/mvcc.rs</a></td><td> | </td><td class="num">151</td><td><span class="i">++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------------</span></td></tr>
</table></pre><pre>5 files changed, 134 insertions(+), 664 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/docs/architecture.md.html">docs/architecture.md</a> b/<a href="../file/docs/architecture.md.html">docs/architecture.md</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -127,20 +127,27 @@ SQL table scans) and has a couple of important implications:
</a> 
 * Keys should use an order-preserving byte encoding, to allow range scans.
 
<a href="#h0-0-3" id="h0-0-3" class="d">-The store itself does not care what keys contain, but the module offers an order-preserving key
</a><a href="#h0-0-4" id="h0-0-4" class="d">-encoding for use by higher layers. These storage layers often use composite keys made up of
</a><a href="#h0-0-5" id="h0-0-5" class="d">-several possibly variable-length values (e.g. an index key consists of table, column, and
</a><a href="#h0-0-6" id="h0-0-6" class="d">-value), and the natural ordering of each segment must be preserved, a property satisfied by this
</a><a href="#h0-0-7" id="h0-0-7" class="d">-encoding:
</a><a href="#h0-0-8" id="h0-0-8" class="i">+The engine itself does not care what keys contain, but the storage module offers
</a><a href="#h0-0-9" id="h0-0-9" class="i">+an order-preserving key encoding called [KeyCode](https://github.com/erikgrinaker/toydb/blob/master/src/storage/keycode.rs)
</a><a href="#h0-0-10" id="h0-0-10" class="i">+for use by higher layers. These storage layers often use composite keys made up
</a><a href="#h0-0-11" id="h0-0-11" class="i">+of several possibly variable-length values (e.g. an index key consists of table,
</a><a href="#h0-0-12" id="h0-0-12" class="i">+column, and value), and the natural ordering of each segment must be preserved,
</a><a href="#h0-0-13" id="h0-0-13" class="i">+a property satisfied by this encoding:
</a> 
 * `bool`: `0x00` for `false`, `0x01` for `true`.
<a href="#h0-0-16" id="h0-0-16" class="d">-* `Vec&lt;u8&gt;`: terminated with `0x0000`, `0x00` escaped as `0x00ff`.
</a><a href="#h0-0-17" id="h0-0-17" class="i">+* `u64`: big-endian binary representation.
</a><a href="#h0-0-18" id="h0-0-18" class="i">+* `i64`: big-endian binary representation, with sign bit flipped.
</a><a href="#h0-0-19" id="h0-0-19" class="i">+* `f64`: big-endian binary representation, with sign bit flipped, and rest if negative.
</a><a href="#h0-0-20" id="h0-0-20" class="i">+* `Vec&lt;u8&gt;`: `0x00` is escaped as `0x00ff`, terminated with `0x0000`.
</a> * `String`:  like `Vec&lt;u8&gt;`.
<a href="#h0-0-22" id="h0-0-22" class="d">-* `u64`: Big-endian binary encoding.
</a><a href="#h0-0-23" id="h0-0-23" class="d">-* `i64`: Big-endian binary encoding, sign bit flipped.
</a><a href="#h0-0-24" id="h0-0-24" class="d">-* `f64`: Big-endian binary encoding, sign bit flipped if `+`, all flipped if `-`.
</a><a href="#h0-0-25" id="h0-0-25" class="d">-* `sql::Value`: As above, with type prefix `0x00`=`Null`, `0x01`=`Boolean`, `0x02`=`Float`,
</a><a href="#h0-0-26" id="h0-0-26" class="d">-  `0x03`=`Integer`, `0x04`=`String`
</a><a href="#h0-0-27" id="h0-0-27" class="i">+
</a><a href="#h0-0-28" id="h0-0-28" class="i">+Additionally, several container types are supported:
</a><a href="#h0-0-29" id="h0-0-29" class="i">+
</a><a href="#h0-0-30" id="h0-0-30" class="i">+* Tuple: concatenation of elements, with no surrounding structure.
</a><a href="#h0-0-31" id="h0-0-31" class="i">+* Array: like tuple.
</a><a href="#h0-0-32" id="h0-0-32" class="i">+* Vec: like tuple.
</a><a href="#h0-0-33" id="h0-0-33" class="i">+* Enum: the variant&#39;s enum index as a single `u8` byte, then contents.
</a><a href="#h0-0-34" id="h0-0-34" class="i">+* Value: like enum.
</a> 
 The default key/value engine is
 [`storage::engine::BitCask`](https://github.com/erikgrinaker/toydb/blob/master/src/storage/kv/bitcask.rs),
<b>diff --git a/<a id="h1" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -2,7 +2,7 @@ use super::super::schema::{Catalog, Table, Tables};
</a> use super::super::types::{Expression, Row, Value};
 use super::Transaction as _;
 use crate::error::{Error, Result};
<a href="#h1-0-3" id="h1-0-3" class="d">-use crate::storage;
</a><a href="#h1-0-4" id="h1-0-4" class="i">+use crate::storage::{self, keycode};
</a> 
 use serde::{Deserialize, Serialize};
 use std::borrow::Cow;
<a href="#h1-1" id="h1-1" class="h">@@ -76,7 +76,7 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>     fn index_load(&amp;self, table: &amp;str, column: &amp;str, value: &amp;Value) -&gt; Result&lt;HashSet&lt;Value&gt;&gt; {
         Ok(self
             .txn
<a href="#h1-1-3" id="h1-1-3" class="d">-            .get(&amp;Key::Index(table.into(), column.into(), Some(value.into())).encode())?
</a><a href="#h1-1-4" id="h1-1-4" class="i">+            .get(&amp;Key::Index(table.into(), column.into(), value.into()).encode()?)?
</a>             .map(|v| deserialize(&amp;v))
             .transpose()?
             .unwrap_or_default())
<a href="#h1-2" id="h1-2" class="h">@@ -90,7 +90,7 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>         value: &amp;Value,
         index: HashSet&lt;Value&gt;,
     ) -&gt; Result&lt;()&gt; {
<a href="#h1-2-3" id="h1-2-3" class="d">-        let key = Key::Index(table.into(), column.into(), Some(value.into())).encode();
</a><a href="#h1-2-4" id="h1-2-4" class="i">+        let key = Key::Index(table.into(), column.into(), value.into()).encode()?;
</a>         if index.is_empty() {
             self.txn.delete(&amp;key)
         } else {
<a href="#h1-3" id="h1-3" class="h">@@ -126,10 +126,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>                 id, table.name
             )));
         }
<a href="#h1-3-3" id="h1-3-3" class="d">-        self.txn.set(
</a><a href="#h1-3-4" id="h1-3-4" class="d">-            &amp;Key::Row(Cow::Borrowed(&amp;table.name), Some(Cow::Borrowed(&amp;id))).encode(),
</a><a href="#h1-3-5" id="h1-3-5" class="d">-            serialize(&amp;row)?,
</a><a href="#h1-3-6" id="h1-3-6" class="d">-        )?;
</a><a href="#h1-3-7" id="h1-3-7" class="i">+        self.txn.set(&amp;Key::Row((&amp;table.name).into(), (&amp;id).into()).encode()?, serialize(&amp;row)?)?;
</a> 
         // Update indexes
         for (i, column) in table.columns.iter().enumerate().filter(|(_, c)| c.index) {
<a href="#h1-4" id="h1-4" class="h">@@ -171,12 +168,12 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>                 }
             }
         }
<a href="#h1-4-3" id="h1-4-3" class="d">-        self.txn.delete(&amp;Key::Row(table.name.into(), Some(id.into())).encode())
</a><a href="#h1-4-4" id="h1-4-4" class="i">+        self.txn.delete(&amp;Key::Row(table.name.into(), id.into()).encode()?)
</a>     }
 
     fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
         self.txn
<a href="#h1-4-9" id="h1-4-9" class="d">-            .get(&amp;Key::Row(table.into(), Some(id.into())).encode())?
</a><a href="#h1-4-10" id="h1-4-10" class="i">+            .get(&amp;Key::Row(table.into(), id.into()).encode()?)?
</a>             .map(|v| deserialize(&amp;v))
             .transpose()
     }
<a href="#h1-5" id="h1-5" class="h">@@ -192,7 +189,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         let table = self.must_read_table(table)?;
         Ok(Box::new(
             self.txn
<a href="#h1-5-3" id="h1-5-3" class="d">-                .scan_prefix(&amp;Key::Row((&amp;table.name).into(), None).encode())?
</a><a href="#h1-5-4" id="h1-5-4" class="i">+                .scan_prefix(&amp;KeyPrefix::Row((&amp;table.name).into()).encode()?)?
</a>                 .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)))
                 .filter_map(move |r| match r {
                     Ok(row) =&gt; match &amp;filter {
<a href="#h1-6" id="h1-6" class="h">@@ -223,12 +220,12 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         Ok(Box::new(
             self.txn
                 .scan_prefix(
<a href="#h1-6-3" id="h1-6-3" class="d">-                    &amp;Key::Index((&amp;table.name).into(), (&amp;column.name).into(), None).encode(),
</a><a href="#h1-6-4" id="h1-6-4" class="i">+                    &amp;KeyPrefix::Index((&amp;table.name).into(), (&amp;column.name).into()).encode()?,
</a>                 )?
                 .map(|r| -&gt; Result&lt;(Value, HashSet&lt;Value&gt;)&gt; {
                     let (k, v) = r?;
                     let value = match Key::decode(&amp;k)? {
<a href="#h1-6-9" id="h1-6-9" class="d">-                        Key::Index(_, _, Some(pk)) =&gt; pk.into_owned(),
</a><a href="#h1-6-10" id="h1-6-10" class="i">+                        Key::Index(_, _, pk) =&gt; pk.into_owned(),
</a>                         _ =&gt; return Err(Error::Internal(&quot;Invalid index key&quot;.into())),
                     };
                     Ok((value, deserialize(&amp;v)?))
<a href="#h1-7" id="h1-7" class="h">@@ -266,7 +263,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         }
 
         table.validate_row(&amp;row, self)?;
<a href="#h1-7-3" id="h1-7-3" class="d">-        self.txn.set(&amp;Key::Row(table.name.into(), Some(id.into())).encode(), serialize(&amp;row)?)
</a><a href="#h1-7-4" id="h1-7-4" class="i">+        self.txn.set(&amp;Key::Row(table.name.into(), id.into()).encode()?, serialize(&amp;row)?)
</a>     }
 }
 
<a href="#h1-8" id="h1-8" class="h">@@ -276,7 +273,7 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>             return Err(Error::Value(format!(&quot;Table {} already exists&quot;, table.name)));
         }
         table.validate(self)?;
<a href="#h1-8-3" id="h1-8-3" class="d">-        self.txn.set(&amp;Key::Table(Some((&amp;table.name).into())).encode(), serialize(&amp;table)?)
</a><a href="#h1-8-4" id="h1-8-4" class="i">+        self.txn.set(&amp;Key::Table((&amp;table.name).into()).encode()?, serialize(&amp;table)?)
</a>     }
 
     fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;()&gt; {
<a href="#h1-9" id="h1-9" class="h">@@ -291,17 +288,17 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>         while let Some(row) = scan.next().transpose()? {
             self.delete(&amp;table.name, &amp;table.get_row_key(&amp;row)?)?
         }
<a href="#h1-9-3" id="h1-9-3" class="d">-        self.txn.delete(&amp;Key::Table(Some(table.name.into())).encode())
</a><a href="#h1-9-4" id="h1-9-4" class="i">+        self.txn.delete(&amp;Key::Table(table.name.into()).encode()?)
</a>     }
 
     fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;&gt; {
<a href="#h1-9-8" id="h1-9-8" class="d">-        self.txn.get(&amp;Key::Table(Some(table.into())).encode())?.map(|v| deserialize(&amp;v)).transpose()
</a><a href="#h1-9-9" id="h1-9-9" class="i">+        self.txn.get(&amp;Key::Table(table.into()).encode()?)?.map(|v| deserialize(&amp;v)).transpose()
</a>     }
 
     fn scan_tables(&amp;self) -&gt; Result&lt;Tables&gt; {
         Ok(Box::new(
             self.txn
<a href="#h1-9-15" id="h1-9-15" class="d">-                .scan_prefix(&amp;Key::Table(None).encode())?
</a><a href="#h1-9-16" id="h1-9-16" class="i">+                .scan_prefix(&amp;KeyPrefix::Table.encode()?)?
</a>                 .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)))
                 .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
                 .into_iter(),
<a href="#h1-10" id="h1-10" class="h">@@ -309,60 +306,44 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>     }
 }
 
<a href="#h1-10-3" id="h1-10-3" class="d">-/// Encodes SQL keys, using an order-preserving encoding - see kv::encoding for details. Options can
</a><a href="#h1-10-4" id="h1-10-4" class="d">-/// be None to get a keyspace prefix. We use table and column names directly as identifiers, to
</a><a href="#h1-10-5" id="h1-10-5" class="d">-/// avoid additional indirection and associated overhead. It is not possible to change names, so
</a><a href="#h1-10-6" id="h1-10-6" class="d">-/// this is ok. Uses Cows since we want to borrow when encoding but return owned when decoding.
</a><a href="#h1-10-7" id="h1-10-7" class="i">+/// SQL keys, using the KeyCode order-preserving encoding. Uses table and column
</a><a href="#h1-10-8" id="h1-10-8" class="i">+/// names directly as identifiers, to avoid additional indirection. It is not
</a><a href="#h1-10-9" id="h1-10-9" class="i">+/// possible to change names, so this is ok. Cow strings allow encoding borrowed
</a><a href="#h1-10-10" id="h1-10-10" class="i">+/// values and decoding into owned values.
</a><a href="#h1-10-11" id="h1-10-11" class="i">+#[derive(Debug, Deserialize, Serialize)]
</a> enum Key&lt;&#39;a&gt; {
<a href="#h1-10-13" id="h1-10-13" class="d">-    /// A table schema key for the given table name
</a><a href="#h1-10-14" id="h1-10-14" class="d">-    Table(Option&lt;Cow&lt;&#39;a, str&gt;&gt;),
</a><a href="#h1-10-15" id="h1-10-15" class="d">-    /// A key for an index entry
</a><a href="#h1-10-16" id="h1-10-16" class="d">-    Index(Cow&lt;&#39;a, str&gt;, Cow&lt;&#39;a, str&gt;, Option&lt;Cow&lt;&#39;a, Value&gt;&gt;),
</a><a href="#h1-10-17" id="h1-10-17" class="d">-    /// A key for a row identified by table name and row primary key
</a><a href="#h1-10-18" id="h1-10-18" class="d">-    Row(Cow&lt;&#39;a, str&gt;, Option&lt;Cow&lt;&#39;a, Value&gt;&gt;),
</a><a href="#h1-10-19" id="h1-10-19" class="i">+    /// A table schema by table name.
</a><a href="#h1-10-20" id="h1-10-20" class="i">+    Table(Cow&lt;&#39;a, str&gt;),
</a><a href="#h1-10-21" id="h1-10-21" class="i">+    /// An index entry, by table name, index name, and index value.
</a><a href="#h1-10-22" id="h1-10-22" class="i">+    Index(Cow&lt;&#39;a, str&gt;, Cow&lt;&#39;a, str&gt;, Cow&lt;&#39;a, Value&gt;),
</a><a href="#h1-10-23" id="h1-10-23" class="i">+    /// A table row, by table name and primary key value.
</a><a href="#h1-10-24" id="h1-10-24" class="i">+    Row(Cow&lt;&#39;a, str&gt;, Cow&lt;&#39;a, Value&gt;),
</a> }
 
 impl&lt;&#39;a&gt; Key&lt;&#39;a&gt; {
<a href="#h1-10-28" id="h1-10-28" class="d">-    /// Encodes the key as a byte vector
</a><a href="#h1-10-29" id="h1-10-29" class="d">-    fn encode(self) -&gt; Vec&lt;u8&gt; {
</a><a href="#h1-10-30" id="h1-10-30" class="d">-        use storage::encoding::*;
</a><a href="#h1-10-31" id="h1-10-31" class="d">-        match self {
</a><a href="#h1-10-32" id="h1-10-32" class="d">-            Self::Table(None) =&gt; vec![0x01],
</a><a href="#h1-10-33" id="h1-10-33" class="d">-            Self::Table(Some(name)) =&gt; [&amp;[0x01][..], &amp;encode_string(&amp;name)].concat(),
</a><a href="#h1-10-34" id="h1-10-34" class="d">-            Self::Index(table, column, None) =&gt; {
</a><a href="#h1-10-35" id="h1-10-35" class="d">-                [&amp;[0x02][..], &amp;encode_string(&amp;table), &amp;encode_string(&amp;column)].concat()
</a><a href="#h1-10-36" id="h1-10-36" class="d">-            }
</a><a href="#h1-10-37" id="h1-10-37" class="d">-            Self::Index(table, column, Some(value)) =&gt; [
</a><a href="#h1-10-38" id="h1-10-38" class="d">-                &amp;[0x02][..],
</a><a href="#h1-10-39" id="h1-10-39" class="d">-                &amp;encode_string(&amp;table),
</a><a href="#h1-10-40" id="h1-10-40" class="d">-                &amp;encode_string(&amp;column),
</a><a href="#h1-10-41" id="h1-10-41" class="d">-                &amp;encode_value(&amp;value),
</a><a href="#h1-10-42" id="h1-10-42" class="d">-            ]
</a><a href="#h1-10-43" id="h1-10-43" class="d">-            .concat(),
</a><a href="#h1-10-44" id="h1-10-44" class="d">-            Self::Row(table, None) =&gt; [&amp;[0x03][..], &amp;encode_string(&amp;table)].concat(),
</a><a href="#h1-10-45" id="h1-10-45" class="d">-            Self::Row(table, Some(pk)) =&gt; {
</a><a href="#h1-10-46" id="h1-10-46" class="d">-                [&amp;[0x03][..], &amp;encode_string(&amp;table), &amp;encode_value(&amp;pk)].concat()
</a><a href="#h1-10-47" id="h1-10-47" class="d">-            }
</a><a href="#h1-10-48" id="h1-10-48" class="d">-        }
</a><a href="#h1-10-49" id="h1-10-49" class="i">+    fn encode(self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h1-10-50" id="h1-10-50" class="i">+        keycode::serialize(&amp;self)
</a>     }
 
<a href="#h1-10-53" id="h1-10-53" class="d">-    /// Decodes a key from a byte vector
</a><a href="#h1-10-54" id="h1-10-54" class="d">-    fn decode(mut bytes: &amp;[u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h1-10-55" id="h1-10-55" class="d">-        use storage::encoding::*;
</a><a href="#h1-10-56" id="h1-10-56" class="d">-        let bytes = &amp;mut bytes;
</a><a href="#h1-10-57" id="h1-10-57" class="d">-        let key = match take_byte(bytes)? {
</a><a href="#h1-10-58" id="h1-10-58" class="d">-            0x01 =&gt; Self::Table(Some(take_string(bytes)?.into())),
</a><a href="#h1-10-59" id="h1-10-59" class="d">-            0x02 =&gt; Self::Index(
</a><a href="#h1-10-60" id="h1-10-60" class="d">-                take_string(bytes)?.into(),
</a><a href="#h1-10-61" id="h1-10-61" class="d">-                take_string(bytes)?.into(),
</a><a href="#h1-10-62" id="h1-10-62" class="d">-                Some(take_value(bytes)?.into()),
</a><a href="#h1-10-63" id="h1-10-63" class="d">-            ),
</a><a href="#h1-10-64" id="h1-10-64" class="d">-            0x03 =&gt; Self::Row(take_string(bytes)?.into(), Some(take_value(bytes)?.into())),
</a><a href="#h1-10-65" id="h1-10-65" class="d">-            b =&gt; return Err(Error::Internal(format!(&quot;Unknown SQL key prefix {:x?}&quot;, b))),
</a><a href="#h1-10-66" id="h1-10-66" class="d">-        };
</a><a href="#h1-10-67" id="h1-10-67" class="d">-        if !bytes.is_empty() {
</a><a href="#h1-10-68" id="h1-10-68" class="d">-            return Err(Error::Internal(&quot;Unexpected data remaining at end of key&quot;.into()));
</a><a href="#h1-10-69" id="h1-10-69" class="d">-        }
</a><a href="#h1-10-70" id="h1-10-70" class="d">-        Ok(key)
</a><a href="#h1-10-71" id="h1-10-71" class="i">+    fn decode(bytes: &amp;[u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h1-10-72" id="h1-10-72" class="i">+        keycode::deserialize(bytes)
</a><a href="#h1-10-73" id="h1-10-73" class="i">+    }
</a><a href="#h1-10-74" id="h1-10-74" class="i">+}
</a><a href="#h1-10-75" id="h1-10-75" class="i">+
</a><a href="#h1-10-76" id="h1-10-76" class="i">+/// Key prefixes, allowing prefix scans of specific parts of the keyspace. These
</a><a href="#h1-10-77" id="h1-10-77" class="i">+/// must match the keys -- in particular, the enum variant indexes must match.
</a><a href="#h1-10-78" id="h1-10-78" class="i">+#[derive(Debug, Deserialize, Serialize)]
</a><a href="#h1-10-79" id="h1-10-79" class="i">+enum KeyPrefix&lt;&#39;a&gt; {
</a><a href="#h1-10-80" id="h1-10-80" class="i">+    /// All table schemas.
</a><a href="#h1-10-81" id="h1-10-81" class="i">+    Table,
</a><a href="#h1-10-82" id="h1-10-82" class="i">+    /// An entire table index, by table and index name.
</a><a href="#h1-10-83" id="h1-10-83" class="i">+    Index(Cow&lt;&#39;a, str&gt;, Cow&lt;&#39;a, str&gt;),
</a><a href="#h1-10-84" id="h1-10-84" class="i">+    /// An entire table&#39;s rows, by table name.
</a><a href="#h1-10-85" id="h1-10-85" class="i">+    Row(Cow&lt;&#39;a, str&gt;),
</a><a href="#h1-10-86" id="h1-10-86" class="i">+}
</a><a href="#h1-10-87" id="h1-10-87" class="i">+
</a><a href="#h1-10-88" id="h1-10-88" class="i">+impl&lt;&#39;a&gt; KeyPrefix&lt;&#39;a&gt; {
</a><a href="#h1-10-89" id="h1-10-89" class="i">+    fn encode(self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h1-10-90" id="h1-10-90" class="i">+        keycode::serialize(&amp;self)
</a>     }
 }
<b>diff --git a/<a id="h2" href="../file/src/storage/encoding.rs.html">src/storage/encoding.rs</a> b/<a href="../file/src/storage/encoding.rs.html">src/storage/encoding.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,504 +0,0 @@
</a><a href="#h2-0-0" id="h2-0-0" class="d">-//! Order-preserving encodings for use in keys.
</a><a href="#h2-0-1" id="h2-0-1" class="d">-//!
</a><a href="#h2-0-2" id="h2-0-2" class="d">-//! bool:    0x00 for false, 0x01 for true.
</a><a href="#h2-0-3" id="h2-0-3" class="d">-//! Vec&lt;u8&gt;: 0x00 is escaped with 0x00 0xff, terminated with 0x00 0x00.
</a><a href="#h2-0-4" id="h2-0-4" class="d">-//! String:  Like Vec&lt;u8&gt;.
</a><a href="#h2-0-5" id="h2-0-5" class="d">-//! u64:     Big-endian binary representation.
</a><a href="#h2-0-6" id="h2-0-6" class="d">-//! i64:     Big-endian binary representation, with sign bit flipped.
</a><a href="#h2-0-7" id="h2-0-7" class="d">-//! f64:     Big-endian binary representation, with sign bit flipped if +, all flipped if -.
</a><a href="#h2-0-8" id="h2-0-8" class="d">-//! Value:   Like above, with type prefix 0x00=Null 0x01=Boolean 0x02=Float 0x03=Integer 0x04=String
</a><a href="#h2-0-9" id="h2-0-9" class="d">-
</a><a href="#h2-0-10" id="h2-0-10" class="d">-use crate::error::{Error, Result};
</a><a href="#h2-0-11" id="h2-0-11" class="d">-use crate::sql::types::Value;
</a><a href="#h2-0-12" id="h2-0-12" class="d">-
</a><a href="#h2-0-13" id="h2-0-13" class="d">-use std::convert::TryInto;
</a><a href="#h2-0-14" id="h2-0-14" class="d">-
</a><a href="#h2-0-15" id="h2-0-15" class="d">-/// Encodes a boolean, using 0x00 for false and 0x01 for true.
</a><a href="#h2-0-16" id="h2-0-16" class="d">-pub fn encode_boolean(bool: bool) -&gt; u8 {
</a><a href="#h2-0-17" id="h2-0-17" class="d">-    if bool {
</a><a href="#h2-0-18" id="h2-0-18" class="d">-        0x01
</a><a href="#h2-0-19" id="h2-0-19" class="d">-    } else {
</a><a href="#h2-0-20" id="h2-0-20" class="d">-        0x00
</a><a href="#h2-0-21" id="h2-0-21" class="d">-    }
</a><a href="#h2-0-22" id="h2-0-22" class="d">-}
</a><a href="#h2-0-23" id="h2-0-23" class="d">-
</a><a href="#h2-0-24" id="h2-0-24" class="d">-/// Decodes a boolean. See encode_boolean() for format.
</a><a href="#h2-0-25" id="h2-0-25" class="d">-pub fn decode_boolean(byte: u8) -&gt; Result&lt;bool&gt; {
</a><a href="#h2-0-26" id="h2-0-26" class="d">-    match byte {
</a><a href="#h2-0-27" id="h2-0-27" class="d">-        0x00 =&gt; Ok(false),
</a><a href="#h2-0-28" id="h2-0-28" class="d">-        0x01 =&gt; Ok(true),
</a><a href="#h2-0-29" id="h2-0-29" class="d">-        b =&gt; Err(Error::Internal(format!(&quot;Invalid boolean value {:?}&quot;, b))),
</a><a href="#h2-0-30" id="h2-0-30" class="d">-    }
</a><a href="#h2-0-31" id="h2-0-31" class="d">-}
</a><a href="#h2-0-32" id="h2-0-32" class="d">-
</a><a href="#h2-0-33" id="h2-0-33" class="d">-/// Decodes a boolean from a slice and shrinks the slice.
</a><a href="#h2-0-34" id="h2-0-34" class="d">-pub fn take_boolean(bytes: &amp;mut &amp;[u8]) -&gt; Result&lt;bool&gt; {
</a><a href="#h2-0-35" id="h2-0-35" class="d">-    take_byte(bytes).and_then(decode_boolean)
</a><a href="#h2-0-36" id="h2-0-36" class="d">-}
</a><a href="#h2-0-37" id="h2-0-37" class="d">-
</a><a href="#h2-0-38" id="h2-0-38" class="d">-/// Encodes a byte vector. 0x00 is escaped as 0x00 0xff, and 0x00 0x00 is used as a terminator.
</a><a href="#h2-0-39" id="h2-0-39" class="d">-/// See: https://activesphere.com/blog/2018/08/17/order-preserving-serialization
</a><a href="#h2-0-40" id="h2-0-40" class="d">-pub fn encode_bytes(bytes: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
</a><a href="#h2-0-41" id="h2-0-41" class="d">-    // flat_map() obscures Iterator.size_hint(), so we explicitly allocate.
</a><a href="#h2-0-42" id="h2-0-42" class="d">-    // See also: https://github.com/rust-lang/rust/issues/45840
</a><a href="#h2-0-43" id="h2-0-43" class="d">-    let mut encoded = Vec::with_capacity(bytes.len() + 2);
</a><a href="#h2-0-44" id="h2-0-44" class="d">-    encoded.extend(
</a><a href="#h2-0-45" id="h2-0-45" class="d">-        bytes
</a><a href="#h2-0-46" id="h2-0-46" class="d">-            .iter()
</a><a href="#h2-0-47" id="h2-0-47" class="d">-            .flat_map(|b| match b {
</a><a href="#h2-0-48" id="h2-0-48" class="d">-                0x00 =&gt; vec![0x00, 0xff],
</a><a href="#h2-0-49" id="h2-0-49" class="d">-                b =&gt; vec![*b],
</a><a href="#h2-0-50" id="h2-0-50" class="d">-            })
</a><a href="#h2-0-51" id="h2-0-51" class="d">-            .chain(vec![0x00, 0x00]),
</a><a href="#h2-0-52" id="h2-0-52" class="d">-    );
</a><a href="#h2-0-53" id="h2-0-53" class="d">-    encoded
</a><a href="#h2-0-54" id="h2-0-54" class="d">-}
</a><a href="#h2-0-55" id="h2-0-55" class="d">-
</a><a href="#h2-0-56" id="h2-0-56" class="d">-/// Takes a single byte from a slice and shortens it, without any escaping.
</a><a href="#h2-0-57" id="h2-0-57" class="d">-pub fn take_byte(bytes: &amp;mut &amp;[u8]) -&gt; Result&lt;u8&gt; {
</a><a href="#h2-0-58" id="h2-0-58" class="d">-    if bytes.is_empty() {
</a><a href="#h2-0-59" id="h2-0-59" class="d">-        return Err(Error::Internal(&quot;Unexpected end of bytes&quot;.into()));
</a><a href="#h2-0-60" id="h2-0-60" class="d">-    }
</a><a href="#h2-0-61" id="h2-0-61" class="d">-    let b = bytes[0];
</a><a href="#h2-0-62" id="h2-0-62" class="d">-    *bytes = &amp;bytes[1..];
</a><a href="#h2-0-63" id="h2-0-63" class="d">-    Ok(b)
</a><a href="#h2-0-64" id="h2-0-64" class="d">-}
</a><a href="#h2-0-65" id="h2-0-65" class="d">-
</a><a href="#h2-0-66" id="h2-0-66" class="d">-/// Decodes a byte vector from a slice and shortens the slice. See encode_bytes() for format.
</a><a href="#h2-0-67" id="h2-0-67" class="d">-pub fn take_bytes(bytes: &amp;mut &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-0-68" id="h2-0-68" class="d">-    // Since we&#39;re generally decoding keys, and these are short, we begin allocating at half of
</a><a href="#h2-0-69" id="h2-0-69" class="d">-    // the byte size.
</a><a href="#h2-0-70" id="h2-0-70" class="d">-    let mut decoded = Vec::with_capacity(bytes.len() / 2);
</a><a href="#h2-0-71" id="h2-0-71" class="d">-    let mut iter = bytes.iter().enumerate();
</a><a href="#h2-0-72" id="h2-0-72" class="d">-    let taken = loop {
</a><a href="#h2-0-73" id="h2-0-73" class="d">-        match iter.next().map(|(_, b)| b) {
</a><a href="#h2-0-74" id="h2-0-74" class="d">-            Some(0x00) =&gt; match iter.next() {
</a><a href="#h2-0-75" id="h2-0-75" class="d">-                Some((i, 0x00)) =&gt; break i + 1,        // 0x00 0x00 is terminator
</a><a href="#h2-0-76" id="h2-0-76" class="d">-                Some((_, 0xff)) =&gt; decoded.push(0x00), // 0x00 0xff is escape sequence for 0x00
</a><a href="#h2-0-77" id="h2-0-77" class="d">-                Some((_, b)) =&gt; return Err(Error::Value(format!(&quot;Invalid byte escape {:?}&quot;, b))),
</a><a href="#h2-0-78" id="h2-0-78" class="d">-                None =&gt; return Err(Error::Value(&quot;Unexpected end of bytes&quot;.into())),
</a><a href="#h2-0-79" id="h2-0-79" class="d">-            },
</a><a href="#h2-0-80" id="h2-0-80" class="d">-            Some(b) =&gt; decoded.push(*b),
</a><a href="#h2-0-81" id="h2-0-81" class="d">-            None =&gt; return Err(Error::Value(&quot;Unexpected end of bytes&quot;.into())),
</a><a href="#h2-0-82" id="h2-0-82" class="d">-        }
</a><a href="#h2-0-83" id="h2-0-83" class="d">-    };
</a><a href="#h2-0-84" id="h2-0-84" class="d">-    *bytes = &amp;bytes[taken..];
</a><a href="#h2-0-85" id="h2-0-85" class="d">-    Ok(decoded)
</a><a href="#h2-0-86" id="h2-0-86" class="d">-}
</a><a href="#h2-0-87" id="h2-0-87" class="d">-
</a><a href="#h2-0-88" id="h2-0-88" class="d">-/// Encodes an f64. Uses big-endian form, and flip sign bit to 1 if 0, otherwise flip all bits.
</a><a href="#h2-0-89" id="h2-0-89" class="d">-/// This preserves the natural numerical ordering, with NaN at the end.
</a><a href="#h2-0-90" id="h2-0-90" class="d">-pub fn encode_f64(n: f64) -&gt; [u8; 8] {
</a><a href="#h2-0-91" id="h2-0-91" class="d">-    let mut bytes = n.to_be_bytes();
</a><a href="#h2-0-92" id="h2-0-92" class="d">-    if bytes[0] &gt;&gt; 7 &amp; 1 == 0 {
</a><a href="#h2-0-93" id="h2-0-93" class="d">-        bytes[0] ^= 1 &lt;&lt; 7;
</a><a href="#h2-0-94" id="h2-0-94" class="d">-    } else {
</a><a href="#h2-0-95" id="h2-0-95" class="d">-        bytes.iter_mut().for_each(|b| *b = !*b);
</a><a href="#h2-0-96" id="h2-0-96" class="d">-    }
</a><a href="#h2-0-97" id="h2-0-97" class="d">-    bytes
</a><a href="#h2-0-98" id="h2-0-98" class="d">-}
</a><a href="#h2-0-99" id="h2-0-99" class="d">-
</a><a href="#h2-0-100" id="h2-0-100" class="d">-/// Decodes an f64. See encode_f64() for format.
</a><a href="#h2-0-101" id="h2-0-101" class="d">-pub fn decode_f64(mut bytes: [u8; 8]) -&gt; f64 {
</a><a href="#h2-0-102" id="h2-0-102" class="d">-    if bytes[0] &gt;&gt; 7 &amp; 1 == 1 {
</a><a href="#h2-0-103" id="h2-0-103" class="d">-        bytes[0] ^= 1 &lt;&lt; 7;
</a><a href="#h2-0-104" id="h2-0-104" class="d">-    } else {
</a><a href="#h2-0-105" id="h2-0-105" class="d">-        bytes.iter_mut().for_each(|b| *b = !*b);
</a><a href="#h2-0-106" id="h2-0-106" class="d">-    }
</a><a href="#h2-0-107" id="h2-0-107" class="d">-    f64::from_be_bytes(bytes)
</a><a href="#h2-0-108" id="h2-0-108" class="d">-}
</a><a href="#h2-0-109" id="h2-0-109" class="d">-
</a><a href="#h2-0-110" id="h2-0-110" class="d">-/// Decodes an f64 from a slice and shrinks the slice.
</a><a href="#h2-0-111" id="h2-0-111" class="d">-pub fn take_f64(bytes: &amp;mut &amp;[u8]) -&gt; Result&lt;f64&gt; {
</a><a href="#h2-0-112" id="h2-0-112" class="d">-    if bytes.len() &lt; 8 {
</a><a href="#h2-0-113" id="h2-0-113" class="d">-        return Err(Error::Internal(format!(&quot;Unable to decode f64 from {} bytes&quot;, bytes.len())));
</a><a href="#h2-0-114" id="h2-0-114" class="d">-    }
</a><a href="#h2-0-115" id="h2-0-115" class="d">-    let n = decode_f64(bytes[0..8].try_into()?);
</a><a href="#h2-0-116" id="h2-0-116" class="d">-    *bytes = &amp;bytes[8..];
</a><a href="#h2-0-117" id="h2-0-117" class="d">-    Ok(n)
</a><a href="#h2-0-118" id="h2-0-118" class="d">-}
</a><a href="#h2-0-119" id="h2-0-119" class="d">-
</a><a href="#h2-0-120" id="h2-0-120" class="d">-/// Encodes an i64. Uses big-endian form, with the first bit flipped to order negative/positive
</a><a href="#h2-0-121" id="h2-0-121" class="d">-/// numbers correctly.
</a><a href="#h2-0-122" id="h2-0-122" class="d">-pub fn encode_i64(n: i64) -&gt; [u8; 8] {
</a><a href="#h2-0-123" id="h2-0-123" class="d">-    let mut bytes = n.to_be_bytes();
</a><a href="#h2-0-124" id="h2-0-124" class="d">-    bytes[0] ^= 1 &lt;&lt; 7; // Flip left-most bit in the first byte, i.e. sign bit.
</a><a href="#h2-0-125" id="h2-0-125" class="d">-    bytes
</a><a href="#h2-0-126" id="h2-0-126" class="d">-}
</a><a href="#h2-0-127" id="h2-0-127" class="d">-
</a><a href="#h2-0-128" id="h2-0-128" class="d">-/// Decodes an i64. See encode_i64() for format.
</a><a href="#h2-0-129" id="h2-0-129" class="d">-pub fn decode_i64(mut bytes: [u8; 8]) -&gt; i64 {
</a><a href="#h2-0-130" id="h2-0-130" class="d">-    bytes[0] ^= 1 &lt;&lt; 7;
</a><a href="#h2-0-131" id="h2-0-131" class="d">-    i64::from_be_bytes(bytes)
</a><a href="#h2-0-132" id="h2-0-132" class="d">-}
</a><a href="#h2-0-133" id="h2-0-133" class="d">-
</a><a href="#h2-0-134" id="h2-0-134" class="d">-/// Decodes a i64 from a slice and shrinks the slice.
</a><a href="#h2-0-135" id="h2-0-135" class="d">-pub fn take_i64(bytes: &amp;mut &amp;[u8]) -&gt; Result&lt;i64&gt; {
</a><a href="#h2-0-136" id="h2-0-136" class="d">-    if bytes.len() &lt; 8 {
</a><a href="#h2-0-137" id="h2-0-137" class="d">-        return Err(Error::Internal(format!(&quot;Unable to decode i64 from {} bytes&quot;, bytes.len())));
</a><a href="#h2-0-138" id="h2-0-138" class="d">-    }
</a><a href="#h2-0-139" id="h2-0-139" class="d">-    let n = decode_i64(bytes[0..8].try_into()?);
</a><a href="#h2-0-140" id="h2-0-140" class="d">-    *bytes = &amp;bytes[8..];
</a><a href="#h2-0-141" id="h2-0-141" class="d">-    Ok(n)
</a><a href="#h2-0-142" id="h2-0-142" class="d">-}
</a><a href="#h2-0-143" id="h2-0-143" class="d">-
</a><a href="#h2-0-144" id="h2-0-144" class="d">-/// Encodes a string. Simply converts to a byte vector and encodes that.
</a><a href="#h2-0-145" id="h2-0-145" class="d">-pub fn encode_string(string: &amp;str) -&gt; Vec&lt;u8&gt; {
</a><a href="#h2-0-146" id="h2-0-146" class="d">-    encode_bytes(string.as_bytes())
</a><a href="#h2-0-147" id="h2-0-147" class="d">-}
</a><a href="#h2-0-148" id="h2-0-148" class="d">-
</a><a href="#h2-0-149" id="h2-0-149" class="d">-/// Decodes a string from a slice and shrinks the slice.
</a><a href="#h2-0-150" id="h2-0-150" class="d">-pub fn take_string(bytes: &amp;mut &amp;[u8]) -&gt; Result&lt;String&gt; {
</a><a href="#h2-0-151" id="h2-0-151" class="d">-    Ok(String::from_utf8(take_bytes(bytes)?)?)
</a><a href="#h2-0-152" id="h2-0-152" class="d">-}
</a><a href="#h2-0-153" id="h2-0-153" class="d">-
</a><a href="#h2-0-154" id="h2-0-154" class="d">-/// Encodes a u64. Simply uses the big-endian form, which preserves order. Does not attempt to
</a><a href="#h2-0-155" id="h2-0-155" class="d">-/// compress it, for now.
</a><a href="#h2-0-156" id="h2-0-156" class="d">-pub fn encode_u64(n: u64) -&gt; [u8; 8] {
</a><a href="#h2-0-157" id="h2-0-157" class="d">-    n.to_be_bytes()
</a><a href="#h2-0-158" id="h2-0-158" class="d">-}
</a><a href="#h2-0-159" id="h2-0-159" class="d">-
</a><a href="#h2-0-160" id="h2-0-160" class="d">-/// Decodes a u64. See encode_u64() for format.
</a><a href="#h2-0-161" id="h2-0-161" class="d">-pub fn decode_u64(bytes: [u8; 8]) -&gt; u64 {
</a><a href="#h2-0-162" id="h2-0-162" class="d">-    u64::from_be_bytes(bytes)
</a><a href="#h2-0-163" id="h2-0-163" class="d">-}
</a><a href="#h2-0-164" id="h2-0-164" class="d">-
</a><a href="#h2-0-165" id="h2-0-165" class="d">-/// Decodes a u64 from a slice and shrinks the slice.
</a><a href="#h2-0-166" id="h2-0-166" class="d">-pub fn take_u64(bytes: &amp;mut &amp;[u8]) -&gt; Result&lt;u64&gt; {
</a><a href="#h2-0-167" id="h2-0-167" class="d">-    if bytes.len() &lt; 8 {
</a><a href="#h2-0-168" id="h2-0-168" class="d">-        return Err(Error::Internal(format!(&quot;Unable to decode u64 from {} bytes&quot;, bytes.len())));
</a><a href="#h2-0-169" id="h2-0-169" class="d">-    }
</a><a href="#h2-0-170" id="h2-0-170" class="d">-    let n = decode_u64(bytes[0..8].try_into()?);
</a><a href="#h2-0-171" id="h2-0-171" class="d">-    *bytes = &amp;bytes[8..];
</a><a href="#h2-0-172" id="h2-0-172" class="d">-    Ok(n)
</a><a href="#h2-0-173" id="h2-0-173" class="d">-}
</a><a href="#h2-0-174" id="h2-0-174" class="d">-
</a><a href="#h2-0-175" id="h2-0-175" class="d">-/// Encodes a value, using the first byte for the value type and delegating to other encoders.
</a><a href="#h2-0-176" id="h2-0-176" class="d">-pub fn encode_value(value: &amp;Value) -&gt; Vec&lt;u8&gt; {
</a><a href="#h2-0-177" id="h2-0-177" class="d">-    match value {
</a><a href="#h2-0-178" id="h2-0-178" class="d">-        Value::Null =&gt; vec![0x00],
</a><a href="#h2-0-179" id="h2-0-179" class="d">-        Value::Boolean(b) =&gt; vec![0x01, encode_boolean(*b)],
</a><a href="#h2-0-180" id="h2-0-180" class="d">-        Value::Float(f) =&gt; [&amp;[0x02][..], &amp;encode_f64(*f)].concat(),
</a><a href="#h2-0-181" id="h2-0-181" class="d">-        Value::Integer(i) =&gt; [&amp;[0x03][..], &amp;encode_i64(*i)].concat(),
</a><a href="#h2-0-182" id="h2-0-182" class="d">-        Value::String(s) =&gt; [&amp;[0x04][..], &amp;encode_string(s)].concat(),
</a><a href="#h2-0-183" id="h2-0-183" class="d">-    }
</a><a href="#h2-0-184" id="h2-0-184" class="d">-}
</a><a href="#h2-0-185" id="h2-0-185" class="d">-
</a><a href="#h2-0-186" id="h2-0-186" class="d">-/// Decodes a value from a slice and shrinks the slice.
</a><a href="#h2-0-187" id="h2-0-187" class="d">-pub fn take_value(bytes: &amp;mut &amp;[u8]) -&gt; Result&lt;Value&gt; {
</a><a href="#h2-0-188" id="h2-0-188" class="d">-    match take_byte(bytes)? {
</a><a href="#h2-0-189" id="h2-0-189" class="d">-        0x00 =&gt; Ok(Value::Null),
</a><a href="#h2-0-190" id="h2-0-190" class="d">-        0x01 =&gt; Ok(Value::Boolean(take_boolean(bytes)?)),
</a><a href="#h2-0-191" id="h2-0-191" class="d">-        0x02 =&gt; Ok(Value::Float(take_f64(bytes)?)),
</a><a href="#h2-0-192" id="h2-0-192" class="d">-        0x03 =&gt; Ok(Value::Integer(take_i64(bytes)?)),
</a><a href="#h2-0-193" id="h2-0-193" class="d">-        0x04 =&gt; Ok(Value::String(take_string(bytes)?)),
</a><a href="#h2-0-194" id="h2-0-194" class="d">-        n =&gt; Err(Error::Internal(format!(&quot;Invalid value prefix {:x?}&quot;, n))),
</a><a href="#h2-0-195" id="h2-0-195" class="d">-    }
</a><a href="#h2-0-196" id="h2-0-196" class="d">-}
</a><a href="#h2-0-197" id="h2-0-197" class="d">-
</a><a href="#h2-0-198" id="h2-0-198" class="d">-#[cfg(test)]
</a><a href="#h2-0-199" id="h2-0-199" class="d">-mod tests {
</a><a href="#h2-0-200" id="h2-0-200" class="d">-    use super::*;
</a><a href="#h2-0-201" id="h2-0-201" class="d">-    use pretty_assertions::assert_eq;
</a><a href="#h2-0-202" id="h2-0-202" class="d">-
</a><a href="#h2-0-203" id="h2-0-203" class="d">-    #[test]
</a><a href="#h2-0-204" id="h2-0-204" class="d">-    fn encode_boolean() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-205" id="h2-0-205" class="d">-        use super::encode_boolean;
</a><a href="#h2-0-206" id="h2-0-206" class="d">-        assert_eq!(encode_boolean(false), 0x00);
</a><a href="#h2-0-207" id="h2-0-207" class="d">-        assert_eq!(encode_boolean(true), 0x01);
</a><a href="#h2-0-208" id="h2-0-208" class="d">-        Ok(())
</a><a href="#h2-0-209" id="h2-0-209" class="d">-    }
</a><a href="#h2-0-210" id="h2-0-210" class="d">-
</a><a href="#h2-0-211" id="h2-0-211" class="d">-    #[test]
</a><a href="#h2-0-212" id="h2-0-212" class="d">-    fn decode_boolean() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-213" id="h2-0-213" class="d">-        use super::decode_boolean;
</a><a href="#h2-0-214" id="h2-0-214" class="d">-        assert!(!decode_boolean(0x00)?);
</a><a href="#h2-0-215" id="h2-0-215" class="d">-        assert!(decode_boolean(0x01)?);
</a><a href="#h2-0-216" id="h2-0-216" class="d">-        assert!(decode_boolean(0x02).is_err());
</a><a href="#h2-0-217" id="h2-0-217" class="d">-        Ok(())
</a><a href="#h2-0-218" id="h2-0-218" class="d">-    }
</a><a href="#h2-0-219" id="h2-0-219" class="d">-
</a><a href="#h2-0-220" id="h2-0-220" class="d">-    #[test]
</a><a href="#h2-0-221" id="h2-0-221" class="d">-    fn take_boolean() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-222" id="h2-0-222" class="d">-        use super::take_boolean;
</a><a href="#h2-0-223" id="h2-0-223" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x01, 0xaf];
</a><a href="#h2-0-224" id="h2-0-224" class="d">-        assert!(take_boolean(&amp;mut bytes)?);
</a><a href="#h2-0-225" id="h2-0-225" class="d">-        assert_eq!(bytes, &amp;[0xaf]);
</a><a href="#h2-0-226" id="h2-0-226" class="d">-        Ok(())
</a><a href="#h2-0-227" id="h2-0-227" class="d">-    }
</a><a href="#h2-0-228" id="h2-0-228" class="d">-
</a><a href="#h2-0-229" id="h2-0-229" class="d">-    #[test]
</a><a href="#h2-0-230" id="h2-0-230" class="d">-    fn encode_bytes() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-231" id="h2-0-231" class="d">-        use super::encode_bytes;
</a><a href="#h2-0-232" id="h2-0-232" class="d">-        assert_eq!(encode_bytes(&amp;[]), vec![0x00, 0x00]);
</a><a href="#h2-0-233" id="h2-0-233" class="d">-        assert_eq!(encode_bytes(&amp;[0x01, 0x02, 0x03]), vec![0x01, 0x02, 0x03, 0x00, 0x00]);
</a><a href="#h2-0-234" id="h2-0-234" class="d">-        assert_eq!(encode_bytes(&amp;[0x00, 0x01, 0x02]), vec![0x00, 0xff, 0x01, 0x02, 0x00, 0x00]);
</a><a href="#h2-0-235" id="h2-0-235" class="d">-        Ok(())
</a><a href="#h2-0-236" id="h2-0-236" class="d">-    }
</a><a href="#h2-0-237" id="h2-0-237" class="d">-
</a><a href="#h2-0-238" id="h2-0-238" class="d">-    #[test]
</a><a href="#h2-0-239" id="h2-0-239" class="d">-    fn take_bytes() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-240" id="h2-0-240" class="d">-        use super::take_bytes;
</a><a href="#h2-0-241" id="h2-0-241" class="d">-
</a><a href="#h2-0-242" id="h2-0-242" class="d">-        let mut bytes: &amp;[u8] = &amp;[];
</a><a href="#h2-0-243" id="h2-0-243" class="d">-        assert!(take_bytes(&amp;mut bytes).is_err());
</a><a href="#h2-0-244" id="h2-0-244" class="d">-
</a><a href="#h2-0-245" id="h2-0-245" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x00, 0x00];
</a><a href="#h2-0-246" id="h2-0-246" class="d">-        assert_eq!(take_bytes(&amp;mut bytes)?, Vec::&lt;u8&gt;::new());
</a><a href="#h2-0-247" id="h2-0-247" class="d">-        assert!(bytes.is_empty());
</a><a href="#h2-0-248" id="h2-0-248" class="d">-
</a><a href="#h2-0-249" id="h2-0-249" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x01, 0x02, 0x03, 0x00, 0x00, 0xa0, 0xb0];
</a><a href="#h2-0-250" id="h2-0-250" class="d">-        assert_eq!(take_bytes(&amp;mut bytes)?, &amp;[0x01, 0x02, 0x03]);
</a><a href="#h2-0-251" id="h2-0-251" class="d">-        assert_eq!(bytes, &amp;[0xa0, 0xb0]);
</a><a href="#h2-0-252" id="h2-0-252" class="d">-
</a><a href="#h2-0-253" id="h2-0-253" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x00, 0xff, 0x01, 0x02, 0x00, 0x00];
</a><a href="#h2-0-254" id="h2-0-254" class="d">-        assert_eq!(take_bytes(&amp;mut bytes)?, &amp;[0x00, 0x01, 0x02]);
</a><a href="#h2-0-255" id="h2-0-255" class="d">-        assert!(bytes.is_empty());
</a><a href="#h2-0-256" id="h2-0-256" class="d">-
</a><a href="#h2-0-257" id="h2-0-257" class="d">-        assert!(take_bytes(&amp;mut &amp;[0x00][..]).is_err());
</a><a href="#h2-0-258" id="h2-0-258" class="d">-        assert!(take_bytes(&amp;mut &amp;[0x01][..]).is_err());
</a><a href="#h2-0-259" id="h2-0-259" class="d">-        assert!(take_bytes(&amp;mut &amp;[0x00, 0x01, 0x00, 0x00][..]).is_err());
</a><a href="#h2-0-260" id="h2-0-260" class="d">-
</a><a href="#h2-0-261" id="h2-0-261" class="d">-        Ok(())
</a><a href="#h2-0-262" id="h2-0-262" class="d">-    }
</a><a href="#h2-0-263" id="h2-0-263" class="d">-
</a><a href="#h2-0-264" id="h2-0-264" class="d">-    #[test]
</a><a href="#h2-0-265" id="h2-0-265" class="d">-    fn encode_f64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-266" id="h2-0-266" class="d">-        use super::encode_f64;
</a><a href="#h2-0-267" id="h2-0-267" class="d">-        use std::f64;
</a><a href="#h2-0-268" id="h2-0-268" class="d">-        use std::f64::consts::PI;
</a><a href="#h2-0-269" id="h2-0-269" class="d">-        assert_eq!(encode_f64(f64::NEG_INFINITY), [0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
</a><a href="#h2-0-270" id="h2-0-270" class="d">-        assert_eq!(encode_f64(-PI * 1e100), [0x2b, 0x33, 0x46, 0x0a, 0x3c, 0x0d, 0x14, 0x7b]);
</a><a href="#h2-0-271" id="h2-0-271" class="d">-        assert_eq!(encode_f64(-PI * 1e2), [0x3f, 0x8c, 0x5d, 0x73, 0xa6, 0x2a, 0xbc, 0xc4]);
</a><a href="#h2-0-272" id="h2-0-272" class="d">-        assert_eq!(encode_f64(-0_f64), [0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
</a><a href="#h2-0-273" id="h2-0-273" class="d">-        assert_eq!(encode_f64(0_f64), [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
</a><a href="#h2-0-274" id="h2-0-274" class="d">-        assert_eq!(encode_f64(PI), [0xc0, 0x09, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18]);
</a><a href="#h2-0-275" id="h2-0-275" class="d">-        assert_eq!(encode_f64(PI * 1e2), [0xc0, 0x73, 0xa2, 0x8c, 0x59, 0xd5, 0x43, 0x3b]);
</a><a href="#h2-0-276" id="h2-0-276" class="d">-        assert_eq!(encode_f64(PI * 1e100), [0xd4, 0xcc, 0xb9, 0xf5, 0xc3, 0xf2, 0xeb, 0x84]);
</a><a href="#h2-0-277" id="h2-0-277" class="d">-        assert_eq!(encode_f64(f64::INFINITY), [0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
</a><a href="#h2-0-278" id="h2-0-278" class="d">-        assert_eq!(encode_f64(f64::NAN), [0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
</a><a href="#h2-0-279" id="h2-0-279" class="d">-        Ok(())
</a><a href="#h2-0-280" id="h2-0-280" class="d">-    }
</a><a href="#h2-0-281" id="h2-0-281" class="d">-
</a><a href="#h2-0-282" id="h2-0-282" class="d">-    #[test]
</a><a href="#h2-0-283" id="h2-0-283" class="d">-    #[allow(clippy::float_cmp)]
</a><a href="#h2-0-284" id="h2-0-284" class="d">-    fn decode_f64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-285" id="h2-0-285" class="d">-        use super::{decode_f64, encode_f64};
</a><a href="#h2-0-286" id="h2-0-286" class="d">-        use std::f64;
</a><a href="#h2-0-287" id="h2-0-287" class="d">-        use std::f64::consts::PI;
</a><a href="#h2-0-288" id="h2-0-288" class="d">-        assert_eq!(decode_f64(encode_f64(f64::NEG_INFINITY)), f64::NEG_INFINITY);
</a><a href="#h2-0-289" id="h2-0-289" class="d">-        assert_eq!(decode_f64(encode_f64(-PI)), -PI);
</a><a href="#h2-0-290" id="h2-0-290" class="d">-        assert_eq!(decode_f64(encode_f64(-0.0)), -0.0);
</a><a href="#h2-0-291" id="h2-0-291" class="d">-        assert_eq!(decode_f64(encode_f64(0.0)), 0.0);
</a><a href="#h2-0-292" id="h2-0-292" class="d">-        assert_eq!(decode_f64(encode_f64(PI)), PI);
</a><a href="#h2-0-293" id="h2-0-293" class="d">-        assert_eq!(decode_f64(encode_f64(f64::INFINITY)), f64::INFINITY);
</a><a href="#h2-0-294" id="h2-0-294" class="d">-        assert!(decode_f64(encode_f64(f64::NAN)).is_nan());
</a><a href="#h2-0-295" id="h2-0-295" class="d">-        Ok(())
</a><a href="#h2-0-296" id="h2-0-296" class="d">-    }
</a><a href="#h2-0-297" id="h2-0-297" class="d">-
</a><a href="#h2-0-298" id="h2-0-298" class="d">-    #[test]
</a><a href="#h2-0-299" id="h2-0-299" class="d">-    #[allow(clippy::float_cmp)]
</a><a href="#h2-0-300" id="h2-0-300" class="d">-    fn take_f64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-301" id="h2-0-301" class="d">-        use super::take_f64;
</a><a href="#h2-0-302" id="h2-0-302" class="d">-
</a><a href="#h2-0-303" id="h2-0-303" class="d">-        let mut bytes: &amp;[u8] = &amp;[];
</a><a href="#h2-0-304" id="h2-0-304" class="d">-        assert!(take_f64(&amp;mut bytes).is_err());
</a><a href="#h2-0-305" id="h2-0-305" class="d">-
</a><a href="#h2-0-306" id="h2-0-306" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07];
</a><a href="#h2-0-307" id="h2-0-307" class="d">-        assert!(take_f64(&amp;mut bytes).is_err());
</a><a href="#h2-0-308" id="h2-0-308" class="d">-        assert_eq!(bytes.len(), 7);
</a><a href="#h2-0-309" id="h2-0-309" class="d">-
</a><a href="#h2-0-310" id="h2-0-310" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
</a><a href="#h2-0-311" id="h2-0-311" class="d">-        assert_eq!(take_f64(&amp;mut bytes)?, 0.0);
</a><a href="#h2-0-312" id="h2-0-312" class="d">-        assert!(bytes.is_empty());
</a><a href="#h2-0-313" id="h2-0-313" class="d">-
</a><a href="#h2-0-314" id="h2-0-314" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf];
</a><a href="#h2-0-315" id="h2-0-315" class="d">-        assert_eq!(take_f64(&amp;mut bytes)?, -0.0);
</a><a href="#h2-0-316" id="h2-0-316" class="d">-        assert_eq!(bytes, &amp;[0xaf]);
</a><a href="#h2-0-317" id="h2-0-317" class="d">-
</a><a href="#h2-0-318" id="h2-0-318" class="d">-        Ok(())
</a><a href="#h2-0-319" id="h2-0-319" class="d">-    }
</a><a href="#h2-0-320" id="h2-0-320" class="d">-
</a><a href="#h2-0-321" id="h2-0-321" class="d">-    #[test]
</a><a href="#h2-0-322" id="h2-0-322" class="d">-    fn encode_i64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-323" id="h2-0-323" class="d">-        use super::encode_i64;
</a><a href="#h2-0-324" id="h2-0-324" class="d">-        assert_eq!(encode_i64(std::i64::MIN), [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
</a><a href="#h2-0-325" id="h2-0-325" class="d">-        assert_eq!(encode_i64(-1024), [0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00]);
</a><a href="#h2-0-326" id="h2-0-326" class="d">-        assert_eq!(encode_i64(-1), [0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
</a><a href="#h2-0-327" id="h2-0-327" class="d">-        assert_eq!(encode_i64(0), [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
</a><a href="#h2-0-328" id="h2-0-328" class="d">-        assert_eq!(encode_i64(1), [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]);
</a><a href="#h2-0-329" id="h2-0-329" class="d">-        assert_eq!(encode_i64(1024), [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00]);
</a><a href="#h2-0-330" id="h2-0-330" class="d">-        assert_eq!(encode_i64(std::i64::MAX), [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
</a><a href="#h2-0-331" id="h2-0-331" class="d">-        Ok(())
</a><a href="#h2-0-332" id="h2-0-332" class="d">-    }
</a><a href="#h2-0-333" id="h2-0-333" class="d">-
</a><a href="#h2-0-334" id="h2-0-334" class="d">-    #[test]
</a><a href="#h2-0-335" id="h2-0-335" class="d">-    fn decode_i64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-336" id="h2-0-336" class="d">-        use super::decode_i64;
</a><a href="#h2-0-337" id="h2-0-337" class="d">-        assert_eq!(decode_i64([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), std::i64::MIN);
</a><a href="#h2-0-338" id="h2-0-338" class="d">-        assert_eq!(decode_i64([0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00]), -1024);
</a><a href="#h2-0-339" id="h2-0-339" class="d">-        assert_eq!(decode_i64([0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]), -1);
</a><a href="#h2-0-340" id="h2-0-340" class="d">-        assert_eq!(decode_i64([0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), 0);
</a><a href="#h2-0-341" id="h2-0-341" class="d">-        assert_eq!(decode_i64([0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]), 1);
</a><a href="#h2-0-342" id="h2-0-342" class="d">-        assert_eq!(decode_i64([0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00]), 1024);
</a><a href="#h2-0-343" id="h2-0-343" class="d">-        assert_eq!(decode_i64([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]), std::i64::MAX);
</a><a href="#h2-0-344" id="h2-0-344" class="d">-        Ok(())
</a><a href="#h2-0-345" id="h2-0-345" class="d">-    }
</a><a href="#h2-0-346" id="h2-0-346" class="d">-
</a><a href="#h2-0-347" id="h2-0-347" class="d">-    #[test]
</a><a href="#h2-0-348" id="h2-0-348" class="d">-    fn take_i64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-349" id="h2-0-349" class="d">-        use super::take_i64;
</a><a href="#h2-0-350" id="h2-0-350" class="d">-
</a><a href="#h2-0-351" id="h2-0-351" class="d">-        let mut bytes: &amp;[u8] = &amp;[];
</a><a href="#h2-0-352" id="h2-0-352" class="d">-        assert!(take_i64(&amp;mut bytes).is_err());
</a><a href="#h2-0-353" id="h2-0-353" class="d">-
</a><a href="#h2-0-354" id="h2-0-354" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07];
</a><a href="#h2-0-355" id="h2-0-355" class="d">-        assert!(take_i64(&amp;mut bytes).is_err());
</a><a href="#h2-0-356" id="h2-0-356" class="d">-        assert_eq!(bytes.len(), 7);
</a><a href="#h2-0-357" id="h2-0-357" class="d">-
</a><a href="#h2-0-358" id="h2-0-358" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00];
</a><a href="#h2-0-359" id="h2-0-359" class="d">-        assert_eq!(take_i64(&amp;mut bytes)?, 1024);
</a><a href="#h2-0-360" id="h2-0-360" class="d">-        assert!(bytes.is_empty());
</a><a href="#h2-0-361" id="h2-0-361" class="d">-
</a><a href="#h2-0-362" id="h2-0-362" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0xff];
</a><a href="#h2-0-363" id="h2-0-363" class="d">-        assert_eq!(take_i64(&amp;mut bytes)?, -1024);
</a><a href="#h2-0-364" id="h2-0-364" class="d">-        assert_eq!(bytes, &amp;[0xff]);
</a><a href="#h2-0-365" id="h2-0-365" class="d">-
</a><a href="#h2-0-366" id="h2-0-366" class="d">-        Ok(())
</a><a href="#h2-0-367" id="h2-0-367" class="d">-    }
</a><a href="#h2-0-368" id="h2-0-368" class="d">-
</a><a href="#h2-0-369" id="h2-0-369" class="d">-    #[test]
</a><a href="#h2-0-370" id="h2-0-370" class="d">-    fn encode_string() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-371" id="h2-0-371" class="d">-        use super::encode_string;
</a><a href="#h2-0-372" id="h2-0-372" class="d">-        assert_eq!(encode_string(&quot;&quot;), vec![0x00, 0x00]);
</a><a href="#h2-0-373" id="h2-0-373" class="d">-        assert_eq!(encode_string(&quot;abc&quot;), vec![0x61, 0x62, 0x63, 0x00, 0x00]);
</a><a href="#h2-0-374" id="h2-0-374" class="d">-        assert_eq!(
</a><a href="#h2-0-375" id="h2-0-375" class="d">-            encode_string(&quot;x \u{0000} z&quot;),
</a><a href="#h2-0-376" id="h2-0-376" class="d">-            vec![0x78, 0x20, 0x00, 0xff, 0x20, 0x7a, 0x00, 0x00]
</a><a href="#h2-0-377" id="h2-0-377" class="d">-        );
</a><a href="#h2-0-378" id="h2-0-378" class="d">-        assert_eq!(encode_string(&quot;aáåA&quot;), vec![0x61, 0xc3, 0xa1, 0xc3, 0xa5, 0x41, 0x00, 0x00]);
</a><a href="#h2-0-379" id="h2-0-379" class="d">-        Ok(())
</a><a href="#h2-0-380" id="h2-0-380" class="d">-    }
</a><a href="#h2-0-381" id="h2-0-381" class="d">-
</a><a href="#h2-0-382" id="h2-0-382" class="d">-    #[test]
</a><a href="#h2-0-383" id="h2-0-383" class="d">-    fn take_string() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-384" id="h2-0-384" class="d">-        use super::take_string;
</a><a href="#h2-0-385" id="h2-0-385" class="d">-
</a><a href="#h2-0-386" id="h2-0-386" class="d">-        let mut bytes: &amp;[u8] = &amp;[];
</a><a href="#h2-0-387" id="h2-0-387" class="d">-        assert!(take_string(&amp;mut bytes).is_err());
</a><a href="#h2-0-388" id="h2-0-388" class="d">-
</a><a href="#h2-0-389" id="h2-0-389" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x00, 0x00];
</a><a href="#h2-0-390" id="h2-0-390" class="d">-        assert_eq!(take_string(&amp;mut bytes)?, &quot;&quot;.to_owned());
</a><a href="#h2-0-391" id="h2-0-391" class="d">-        assert!(bytes.is_empty());
</a><a href="#h2-0-392" id="h2-0-392" class="d">-
</a><a href="#h2-0-393" id="h2-0-393" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x61, 0x62, 0x63, 0x00, 0x00];
</a><a href="#h2-0-394" id="h2-0-394" class="d">-        assert_eq!(take_string(&amp;mut bytes)?, &quot;abc&quot;.to_owned());
</a><a href="#h2-0-395" id="h2-0-395" class="d">-        assert!(bytes.is_empty());
</a><a href="#h2-0-396" id="h2-0-396" class="d">-
</a><a href="#h2-0-397" id="h2-0-397" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x78, 0x20, 0x00, 0xff, 0x20, 0x7a, 0x00, 0x00, 0x01, 0x02, 0x03];
</a><a href="#h2-0-398" id="h2-0-398" class="d">-        assert_eq!(take_string(&amp;mut bytes)?, &quot;x \u{0000} z&quot;.to_owned());
</a><a href="#h2-0-399" id="h2-0-399" class="d">-        assert_eq!(bytes, &amp;[0x01, 0x02, 0x03]);
</a><a href="#h2-0-400" id="h2-0-400" class="d">-
</a><a href="#h2-0-401" id="h2-0-401" class="d">-        let mut bytes: &amp;[u8] = &amp;[0xff, 0x00, 0x00]; // invalid utf-8
</a><a href="#h2-0-402" id="h2-0-402" class="d">-        assert!(take_string(&amp;mut bytes).is_err());
</a><a href="#h2-0-403" id="h2-0-403" class="d">-
</a><a href="#h2-0-404" id="h2-0-404" class="d">-        Ok(())
</a><a href="#h2-0-405" id="h2-0-405" class="d">-    }
</a><a href="#h2-0-406" id="h2-0-406" class="d">-
</a><a href="#h2-0-407" id="h2-0-407" class="d">-    #[test]
</a><a href="#h2-0-408" id="h2-0-408" class="d">-    fn encode_u64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-409" id="h2-0-409" class="d">-        use super::encode_u64;
</a><a href="#h2-0-410" id="h2-0-410" class="d">-        assert_eq!(encode_u64(0), [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
</a><a href="#h2-0-411" id="h2-0-411" class="d">-        assert_eq!(encode_u64(1), [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]);
</a><a href="#h2-0-412" id="h2-0-412" class="d">-        assert_eq!(encode_u64(1024), [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00]);
</a><a href="#h2-0-413" id="h2-0-413" class="d">-        assert_eq!(encode_u64(std::u64::MAX), [0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
</a><a href="#h2-0-414" id="h2-0-414" class="d">-        Ok(())
</a><a href="#h2-0-415" id="h2-0-415" class="d">-    }
</a><a href="#h2-0-416" id="h2-0-416" class="d">-
</a><a href="#h2-0-417" id="h2-0-417" class="d">-    #[test]
</a><a href="#h2-0-418" id="h2-0-418" class="d">-    fn decode_u64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-419" id="h2-0-419" class="d">-        use super::decode_u64;
</a><a href="#h2-0-420" id="h2-0-420" class="d">-        assert_eq!(decode_u64([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), 0);
</a><a href="#h2-0-421" id="h2-0-421" class="d">-        assert_eq!(decode_u64([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]), 1);
</a><a href="#h2-0-422" id="h2-0-422" class="d">-        assert_eq!(decode_u64([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00]), 1024);
</a><a href="#h2-0-423" id="h2-0-423" class="d">-        assert_eq!(decode_u64([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]), std::u64::MAX);
</a><a href="#h2-0-424" id="h2-0-424" class="d">-        Ok(())
</a><a href="#h2-0-425" id="h2-0-425" class="d">-    }
</a><a href="#h2-0-426" id="h2-0-426" class="d">-
</a><a href="#h2-0-427" id="h2-0-427" class="d">-    #[test]
</a><a href="#h2-0-428" id="h2-0-428" class="d">-    fn take_u64() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-429" id="h2-0-429" class="d">-        use super::take_u64;
</a><a href="#h2-0-430" id="h2-0-430" class="d">-
</a><a href="#h2-0-431" id="h2-0-431" class="d">-        let mut bytes: &amp;[u8] = &amp;[];
</a><a href="#h2-0-432" id="h2-0-432" class="d">-        assert!(take_u64(&amp;mut bytes).is_err());
</a><a href="#h2-0-433" id="h2-0-433" class="d">-
</a><a href="#h2-0-434" id="h2-0-434" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07];
</a><a href="#h2-0-435" id="h2-0-435" class="d">-        assert!(take_u64(&amp;mut bytes).is_err());
</a><a href="#h2-0-436" id="h2-0-436" class="d">-        assert_eq!(bytes.len(), 7);
</a><a href="#h2-0-437" id="h2-0-437" class="d">-
</a><a href="#h2-0-438" id="h2-0-438" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
</a><a href="#h2-0-439" id="h2-0-439" class="d">-        assert_eq!(take_u64(&amp;mut bytes)?, 1);
</a><a href="#h2-0-440" id="h2-0-440" class="d">-        assert!(bytes.is_empty());
</a><a href="#h2-0-441" id="h2-0-441" class="d">-
</a><a href="#h2-0-442" id="h2-0-442" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff];
</a><a href="#h2-0-443" id="h2-0-443" class="d">-        assert_eq!(take_u64(&amp;mut bytes)?, 1);
</a><a href="#h2-0-444" id="h2-0-444" class="d">-        assert_eq!(bytes, &amp;[0xff]);
</a><a href="#h2-0-445" id="h2-0-445" class="d">-
</a><a href="#h2-0-446" id="h2-0-446" class="d">-        Ok(())
</a><a href="#h2-0-447" id="h2-0-447" class="d">-    }
</a><a href="#h2-0-448" id="h2-0-448" class="d">-
</a><a href="#h2-0-449" id="h2-0-449" class="d">-    #[test]
</a><a href="#h2-0-450" id="h2-0-450" class="d">-    fn encode_value() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-451" id="h2-0-451" class="d">-        use super::encode_value;
</a><a href="#h2-0-452" id="h2-0-452" class="d">-
</a><a href="#h2-0-453" id="h2-0-453" class="d">-        assert_eq!(encode_value(&amp;Value::Null), vec![0x00]);
</a><a href="#h2-0-454" id="h2-0-454" class="d">-        assert_eq!(encode_value(&amp;Value::Boolean(false)), vec![0x01, 0x00]);
</a><a href="#h2-0-455" id="h2-0-455" class="d">-        assert_eq!(encode_value(&amp;Value::Boolean(true)), vec![0x01, 0x01]);
</a><a href="#h2-0-456" id="h2-0-456" class="d">-        assert_eq!(
</a><a href="#h2-0-457" id="h2-0-457" class="d">-            encode_value(&amp;Value::Float(-0.0)),
</a><a href="#h2-0-458" id="h2-0-458" class="d">-            vec![0x02, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]
</a><a href="#h2-0-459" id="h2-0-459" class="d">-        );
</a><a href="#h2-0-460" id="h2-0-460" class="d">-        assert_eq!(
</a><a href="#h2-0-461" id="h2-0-461" class="d">-            encode_value(&amp;Value::Integer(1024)),
</a><a href="#h2-0-462" id="h2-0-462" class="d">-            vec![0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00]
</a><a href="#h2-0-463" id="h2-0-463" class="d">-        );
</a><a href="#h2-0-464" id="h2-0-464" class="d">-        assert_eq!(
</a><a href="#h2-0-465" id="h2-0-465" class="d">-            encode_value(&amp;Value::String(&quot;abc&quot;.into())),
</a><a href="#h2-0-466" id="h2-0-466" class="d">-            vec![0x04, 0x61, 0x62, 0x63, 0x00, 0x00]
</a><a href="#h2-0-467" id="h2-0-467" class="d">-        );
</a><a href="#h2-0-468" id="h2-0-468" class="d">-        Ok(())
</a><a href="#h2-0-469" id="h2-0-469" class="d">-    }
</a><a href="#h2-0-470" id="h2-0-470" class="d">-
</a><a href="#h2-0-471" id="h2-0-471" class="d">-    #[test]
</a><a href="#h2-0-472" id="h2-0-472" class="d">-    fn take_value() -&gt; Result&lt;()&gt; {
</a><a href="#h2-0-473" id="h2-0-473" class="d">-        use super::take_value;
</a><a href="#h2-0-474" id="h2-0-474" class="d">-
</a><a href="#h2-0-475" id="h2-0-475" class="d">-        let mut bytes: &amp;[u8] = &amp;[];
</a><a href="#h2-0-476" id="h2-0-476" class="d">-        assert!(take_value(&amp;mut bytes).is_err());
</a><a href="#h2-0-477" id="h2-0-477" class="d">-
</a><a href="#h2-0-478" id="h2-0-478" class="d">-        let mut bytes: &amp;[u8] = &amp;[0xaf];
</a><a href="#h2-0-479" id="h2-0-479" class="d">-        assert!(take_value(&amp;mut bytes).is_err());
</a><a href="#h2-0-480" id="h2-0-480" class="d">-
</a><a href="#h2-0-481" id="h2-0-481" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x00, 0xaf];
</a><a href="#h2-0-482" id="h2-0-482" class="d">-        assert_eq!(take_value(&amp;mut bytes)?, Value::Null);
</a><a href="#h2-0-483" id="h2-0-483" class="d">-        assert_eq!(bytes, &amp;[0xaf]);
</a><a href="#h2-0-484" id="h2-0-484" class="d">-
</a><a href="#h2-0-485" id="h2-0-485" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x01, 0x01, 0xaf];
</a><a href="#h2-0-486" id="h2-0-486" class="d">-        assert_eq!(take_value(&amp;mut bytes)?, Value::Boolean(true));
</a><a href="#h2-0-487" id="h2-0-487" class="d">-        assert_eq!(bytes, &amp;[0xaf]);
</a><a href="#h2-0-488" id="h2-0-488" class="d">-
</a><a href="#h2-0-489" id="h2-0-489" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x02, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf];
</a><a href="#h2-0-490" id="h2-0-490" class="d">-        assert_eq!(take_value(&amp;mut bytes)?, Value::Float(-0.0));
</a><a href="#h2-0-491" id="h2-0-491" class="d">-        assert_eq!(bytes, &amp;[0xaf]);
</a><a href="#h2-0-492" id="h2-0-492" class="d">-
</a><a href="#h2-0-493" id="h2-0-493" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xaf];
</a><a href="#h2-0-494" id="h2-0-494" class="d">-        assert_eq!(take_value(&amp;mut bytes)?, Value::Integer(1024));
</a><a href="#h2-0-495" id="h2-0-495" class="d">-        assert_eq!(bytes, &amp;[0xaf]);
</a><a href="#h2-0-496" id="h2-0-496" class="d">-
</a><a href="#h2-0-497" id="h2-0-497" class="d">-        let mut bytes: &amp;[u8] = &amp;[0x04, 0x61, 0x62, 0x63, 0x00, 0x00, 0xaf];
</a><a href="#h2-0-498" id="h2-0-498" class="d">-        assert_eq!(take_value(&amp;mut bytes)?, Value::String(&quot;abc&quot;.into()));
</a><a href="#h2-0-499" id="h2-0-499" class="d">-        assert_eq!(bytes, &amp;[0xaf]);
</a><a href="#h2-0-500" id="h2-0-500" class="d">-
</a><a href="#h2-0-501" id="h2-0-501" class="d">-        Ok(())
</a><a href="#h2-0-502" id="h2-0-502" class="d">-    }
</a><a href="#h2-0-503" id="h2-0-503" class="d">-}
</a><b>diff --git a/<a id="h3" href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a> b/<a href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,4 +1,3 @@
</a><a href="#h3-0-0" id="h3-0-0" class="d">-pub mod encoding;
</a> pub mod engine;
 pub mod keycode;
 pub mod log;
<b>diff --git a/<a id="h4" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h4-0-0" id="h4-0-0" class="d">-use super::{encoding, Engine};
</a><a href="#h4-0-1" id="h4-0-1" class="i">+use super::{keycode, Engine};
</a> use crate::error::{Error, Result};
 
 use serde::{Deserialize, Serialize};
<a href="#h4-1" id="h4-1" class="h">@@ -8,6 +8,49 @@ use std::iter::Peekable;
</a> use std::ops::{Bound, RangeBounds};
 use std::sync::{Arc, Mutex, MutexGuard};
 
<a href="#h4-1-3" id="h4-1-3" class="i">+/// MVCC keys, using the KeyCode encoding which preserves the ordering and
</a><a href="#h4-1-4" id="h4-1-4" class="i">+/// grouping of keys. Cow byte slices allow encoding borrowed values and
</a><a href="#h4-1-5" id="h4-1-5" class="i">+/// decoding into owned values.
</a><a href="#h4-1-6" id="h4-1-6" class="i">+#[derive(Debug, Deserialize, Serialize)]
</a><a href="#h4-1-7" id="h4-1-7" class="i">+enum Key&lt;&#39;a&gt; {
</a><a href="#h4-1-8" id="h4-1-8" class="i">+    /// The next available transaction ID.
</a><a href="#h4-1-9" id="h4-1-9" class="i">+    TxnNext,
</a><a href="#h4-1-10" id="h4-1-10" class="i">+    /// Markers for active (uncommitted) transactions by ID, storing the mode.
</a><a href="#h4-1-11" id="h4-1-11" class="i">+    TxnActive(u64),
</a><a href="#h4-1-12" id="h4-1-12" class="i">+    /// Transaction snapshot by ID, storing concurrent active transaction IDs.
</a><a href="#h4-1-13" id="h4-1-13" class="i">+    TxnSnapshot(u64),
</a><a href="#h4-1-14" id="h4-1-14" class="i">+    /// Update marker for a txn ID and key, used for rollback.
</a><a href="#h4-1-15" id="h4-1-15" class="i">+    TxnUpdate(
</a><a href="#h4-1-16" id="h4-1-16" class="i">+        u64,
</a><a href="#h4-1-17" id="h4-1-17" class="i">+        #[serde(with = &quot;serde_bytes&quot;)]
</a><a href="#h4-1-18" id="h4-1-18" class="i">+        #[serde(borrow)]
</a><a href="#h4-1-19" id="h4-1-19" class="i">+        Cow&lt;&#39;a, [u8]&gt;,
</a><a href="#h4-1-20" id="h4-1-20" class="i">+    ),
</a><a href="#h4-1-21" id="h4-1-21" class="i">+    /// A record for a key/version pair.
</a><a href="#h4-1-22" id="h4-1-22" class="i">+    Record(
</a><a href="#h4-1-23" id="h4-1-23" class="i">+        #[serde(with = &quot;serde_bytes&quot;)]
</a><a href="#h4-1-24" id="h4-1-24" class="i">+        #[serde(borrow)]
</a><a href="#h4-1-25" id="h4-1-25" class="i">+        Cow&lt;&#39;a, [u8]&gt;,
</a><a href="#h4-1-26" id="h4-1-26" class="i">+        u64,
</a><a href="#h4-1-27" id="h4-1-27" class="i">+    ),
</a><a href="#h4-1-28" id="h4-1-28" class="i">+    /// Arbitrary unversioned metadata.
</a><a href="#h4-1-29" id="h4-1-29" class="i">+    Metadata(
</a><a href="#h4-1-30" id="h4-1-30" class="i">+        #[serde(with = &quot;serde_bytes&quot;)]
</a><a href="#h4-1-31" id="h4-1-31" class="i">+        #[serde(borrow)]
</a><a href="#h4-1-32" id="h4-1-32" class="i">+        Cow&lt;&#39;a, [u8]&gt;,
</a><a href="#h4-1-33" id="h4-1-33" class="i">+    ),
</a><a href="#h4-1-34" id="h4-1-34" class="i">+}
</a><a href="#h4-1-35" id="h4-1-35" class="i">+
</a><a href="#h4-1-36" id="h4-1-36" class="i">+impl&lt;&#39;a&gt; Key&lt;&#39;a&gt; {
</a><a href="#h4-1-37" id="h4-1-37" class="i">+    fn decode(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h4-1-38" id="h4-1-38" class="i">+        keycode::deserialize(bytes)
</a><a href="#h4-1-39" id="h4-1-39" class="i">+    }
</a><a href="#h4-1-40" id="h4-1-40" class="i">+
</a><a href="#h4-1-41" id="h4-1-41" class="i">+    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h4-1-42" id="h4-1-42" class="i">+        keycode::serialize(&amp;self)
</a><a href="#h4-1-43" id="h4-1-43" class="i">+    }
</a><a href="#h4-1-44" id="h4-1-44" class="i">+}
</a><a href="#h4-1-45" id="h4-1-45" class="i">+
</a> /// MVCC status
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub struct Status {
<a href="#h4-2" id="h4-2" class="h">@@ -53,13 +96,13 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a>     /// Fetches an unversioned metadata value
     pub fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
         let mut session = self.engine.lock()?;
<a href="#h4-2-3" id="h4-2-3" class="d">-        session.get(&amp;Key::Metadata(key.into()).encode())
</a><a href="#h4-2-4" id="h4-2-4" class="i">+        session.get(&amp;Key::Metadata(key.into()).encode()?)
</a>     }
 
     /// Sets an unversioned metadata value
     pub fn set_metadata(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
         let mut session = self.engine.lock()?;
<a href="#h4-2-10" id="h4-2-10" class="d">-        session.set(&amp;Key::Metadata(key.into()).encode(), value)
</a><a href="#h4-2-11" id="h4-2-11" class="i">+        session.set(&amp;Key::Metadata(key.into()).encode()?, value)
</a>     }
 
     /// Returns engine status
<a href="#h4-3" id="h4-3" class="h">@@ -71,12 +114,12 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a>         let mut engine = self.engine.lock()?;
         return Ok(Status {
             storage: engine.to_string(),
<a href="#h4-3-3" id="h4-3-3" class="d">-            txns: match engine.get(&amp;Key::TxnNext.encode())? {
</a><a href="#h4-3-4" id="h4-3-4" class="i">+            txns: match engine.get(&amp;Key::TxnNext.encode()?)? {
</a>                 Some(ref v) =&gt; deserialize(v)?,
                 None =&gt; 1,
             } - 1,
             txns_active: engine
<a href="#h4-3-9" id="h4-3-9" class="d">-                .scan(Key::TxnActive(0).encode()..Key::TxnActive(std::u64::MAX).encode())
</a><a href="#h4-3-10" id="h4-3-10" class="i">+                .scan(Key::TxnActive(0).encode()?..Key::TxnActive(std::u64::MAX).encode()?)
</a>                 .try_fold(0, |count, r| r.map(|_| count + 1))?,
         });
     }
<a href="#h4-4" id="h4-4" class="h">@@ -109,12 +152,12 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     fn begin(engine: Arc&lt;Mutex&lt;E&gt;&gt;, mode: Mode) -&gt; Result&lt;Self&gt; {
         let mut session = engine.lock()?;
 
<a href="#h4-4-3" id="h4-4-3" class="d">-        let id = match session.get(&amp;Key::TxnNext.encode())? {
</a><a href="#h4-4-4" id="h4-4-4" class="i">+        let id = match session.get(&amp;Key::TxnNext.encode()?)? {
</a>             Some(ref v) =&gt; deserialize(v)?,
             None =&gt; 1,
         };
<a href="#h4-4-8" id="h4-4-8" class="d">-        session.set(&amp;Key::TxnNext.encode(), serialize(&amp;(id + 1))?)?;
</a><a href="#h4-4-9" id="h4-4-9" class="d">-        session.set(&amp;Key::TxnActive(id).encode(), serialize(&amp;mode)?)?;
</a><a href="#h4-4-10" id="h4-4-10" class="i">+        session.set(&amp;Key::TxnNext.encode()?, serialize(&amp;(id + 1))?)?;
</a><a href="#h4-4-11" id="h4-4-11" class="i">+        session.set(&amp;Key::TxnActive(id).encode()?, serialize(&amp;mode)?)?;
</a> 
         // We always take a new snapshot, even for snapshot transactions, because all transactions
         // increment the transaction ID and we need to properly record currently active transactions
<a href="#h4-5" id="h4-5" class="h">@@ -131,7 +174,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// Resumes an active transaction with the given ID. Errors if the transaction is not active.
     fn resume(engine: Arc&lt;Mutex&lt;E&gt;&gt;, id: u64) -&gt; Result&lt;Self&gt; {
         let mut session = engine.lock()?;
<a href="#h4-5-3" id="h4-5-3" class="d">-        let mode = match session.get(&amp;Key::TxnActive(id).encode())? {
</a><a href="#h4-5-4" id="h4-5-4" class="i">+        let mode = match session.get(&amp;Key::TxnActive(id).encode()?)? {
</a>             Some(v) =&gt; deserialize(&amp;v)?,
             None =&gt; return Err(Error::Value(format!(&quot;No active transaction {}&quot;, id))),
         };
<a href="#h4-6" id="h4-6" class="h">@@ -156,7 +199,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// Commits the transaction, by removing the txn from the active set.
     pub fn commit(self) -&gt; Result&lt;()&gt; {
         let mut session = self.engine.lock()?;
<a href="#h4-6-3" id="h4-6-3" class="d">-        session.delete(&amp;Key::TxnActive(self.id).encode())?;
</a><a href="#h4-6-4" id="h4-6-4" class="i">+        session.delete(&amp;Key::TxnActive(self.id).encode()?)?;
</a>         session.flush()
     }
 
<a href="#h4-7" id="h4-7" class="h">@@ -166,8 +209,8 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         if self.mode.mutable() {
             let mut rollback = Vec::new();
             let mut scan = session.scan(
<a href="#h4-7-3" id="h4-7-3" class="d">-                Key::TxnUpdate(self.id, vec![].into()).encode()
</a><a href="#h4-7-4" id="h4-7-4" class="d">-                    ..Key::TxnUpdate(self.id + 1, vec![].into()).encode(),
</a><a href="#h4-7-5" id="h4-7-5" class="i">+                Key::TxnUpdate(self.id, vec![].into()).encode()?
</a><a href="#h4-7-6" id="h4-7-6" class="i">+                    ..Key::TxnUpdate(self.id + 1, vec![].into()).encode()?,
</a>             );
             while let Some((key, _)) = scan.next().transpose()? {
                 match Key::decode(&amp;key)? {
<a href="#h4-8" id="h4-8" class="h">@@ -181,7 +224,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>                 session.delete(&amp;key)?;
             }
         }
<a href="#h4-8-3" id="h4-8-3" class="d">-        session.delete(&amp;Key::TxnActive(self.id).encode())
</a><a href="#h4-8-4" id="h4-8-4" class="i">+        session.delete(&amp;Key::TxnActive(self.id).encode()?)
</a>     }
 
     /// Deletes a key.
<a href="#h4-9" id="h4-9" class="h">@@ -193,7 +236,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     pub fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
         let mut session = self.engine.lock()?;
         let mut scan = session
<a href="#h4-9-3" id="h4-9-3" class="d">-            .scan(Key::Record(key.into(), 0).encode()..=Key::Record(key.into(), self.id).encode())
</a><a href="#h4-9-4" id="h4-9-4" class="i">+            .scan(Key::Record(key.into(), 0).encode()?..=Key::Record(key.into(), self.id).encode()?)
</a>             .rev();
         while let Some((k, v)) = scan.next().transpose()? {
             match Key::decode(&amp;k)? {
<a href="#h4-10" id="h4-10" class="h">@@ -211,13 +254,13 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// Scans a key range.
     pub fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;ScanIterator&gt; {
         let start = match range.start_bound() {
<a href="#h4-10-3" id="h4-10-3" class="d">-            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Record(k.into(), std::u64::MAX).encode()),
</a><a href="#h4-10-4" id="h4-10-4" class="d">-            Bound::Included(k) =&gt; Bound::Included(Key::Record(k.into(), 0).encode()),
</a><a href="#h4-10-5" id="h4-10-5" class="d">-            Bound::Unbounded =&gt; Bound::Included(Key::Record(vec![].into(), 0).encode()),
</a><a href="#h4-10-6" id="h4-10-6" class="i">+            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Record(k.into(), std::u64::MAX).encode()?),
</a><a href="#h4-10-7" id="h4-10-7" class="i">+            Bound::Included(k) =&gt; Bound::Included(Key::Record(k.into(), 0).encode()?),
</a><a href="#h4-10-8" id="h4-10-8" class="i">+            Bound::Unbounded =&gt; Bound::Included(Key::Record(vec![].into(), 0).encode()?),
</a>         };
         let end = match range.end_bound() {
<a href="#h4-10-11" id="h4-10-11" class="d">-            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Record(k.into(), 0).encode()),
</a><a href="#h4-10-12" id="h4-10-12" class="d">-            Bound::Included(k) =&gt; Bound::Included(Key::Record(k.into(), std::u64::MAX).encode()),
</a><a href="#h4-10-13" id="h4-10-13" class="i">+            Bound::Excluded(k) =&gt; Bound::Excluded(Key::Record(k.into(), 0).encode()?),
</a><a href="#h4-10-14" id="h4-10-14" class="i">+            Bound::Included(k) =&gt; Bound::Included(Key::Record(k.into(), std::u64::MAX).encode()?),
</a>             Bound::Unbounded =&gt; Bound::Unbounded,
         };
         // TODO: For now, collect results from the engine to not have to deal with lifetimes.
<a href="#h4-11" id="h4-11" class="h">@@ -266,8 +309,8 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         let min = self.snapshot.invisible.iter().min().cloned().unwrap_or(self.id + 1);
         let mut scan = session
             .scan(
<a href="#h4-11-3" id="h4-11-3" class="d">-                Key::Record(key.into(), min).encode()
</a><a href="#h4-11-4" id="h4-11-4" class="d">-                    ..=Key::Record(key.into(), std::u64::MAX).encode(),
</a><a href="#h4-11-5" id="h4-11-5" class="i">+                Key::Record(key.into(), min).encode()?
</a><a href="#h4-11-6" id="h4-11-6" class="i">+                    ..=Key::Record(key.into(), std::u64::MAX).encode()?,
</a>             )
             .rev();
         while let Some((k, _)) = scan.next().transpose()? {
<a href="#h4-12" id="h4-12" class="h">@@ -283,8 +326,8 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         std::mem::drop(scan);
 
         // Write the key and its update record.
<a href="#h4-12-3" id="h4-12-3" class="d">-        let key = Key::Record(key.into(), self.id).encode();
</a><a href="#h4-12-4" id="h4-12-4" class="d">-        let update = Key::TxnUpdate(self.id, (&amp;key).into()).encode();
</a><a href="#h4-12-5" id="h4-12-5" class="i">+        let key = Key::Record(key.into(), self.id).encode()?;
</a><a href="#h4-12-6" id="h4-12-6" class="i">+        let update = Key::TxnUpdate(self.id, (&amp;key).into()).encode()?;
</a>         session.set(&amp;update, vec![])?;
         session.set(&amp;key, serialize(&amp;value)?)
     }
<a href="#h4-13" id="h4-13" class="h">@@ -340,7 +383,7 @@ impl Snapshot {
</a>     /// Takes a new snapshot, persisting it as `Key::TxnSnapshot(version)`.
     fn take&lt;E: Engine&gt;(session: &amp;mut MutexGuard&lt;E&gt;, version: u64) -&gt; Result&lt;Self&gt; {
         let mut snapshot = Self { version, invisible: HashSet::new() };
<a href="#h4-13-3" id="h4-13-3" class="d">-        let mut scan = session.scan(Key::TxnActive(0).encode()..Key::TxnActive(version).encode());
</a><a href="#h4-13-4" id="h4-13-4" class="i">+        let mut scan = session.scan(Key::TxnActive(0).encode()?..Key::TxnActive(version).encode()?);
</a>         while let Some((key, _)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::TxnActive(id) =&gt; snapshot.invisible.insert(id),
<a href="#h4-14" id="h4-14" class="h">@@ -348,13 +391,13 @@ impl Snapshot {
</a>             };
         }
         std::mem::drop(scan);
<a href="#h4-14-3" id="h4-14-3" class="d">-        session.set(&amp;Key::TxnSnapshot(version).encode(), serialize(&amp;snapshot.invisible)?)?;
</a><a href="#h4-14-4" id="h4-14-4" class="i">+        session.set(&amp;Key::TxnSnapshot(version).encode()?, serialize(&amp;snapshot.invisible)?)?;
</a>         Ok(snapshot)
     }
 
     /// Reengines an existing snapshot from `Key::TxnSnapshot(version)`, or errors if not found.
     fn reengine&lt;E: Engine&gt;(session: &amp;mut MutexGuard&lt;E&gt;, version: u64) -&gt; Result&lt;Self&gt; {
<a href="#h4-14-10" id="h4-14-10" class="d">-        match session.get(&amp;Key::TxnSnapshot(version).encode())? {
</a><a href="#h4-14-11" id="h4-14-11" class="i">+        match session.get(&amp;Key::TxnSnapshot(version).encode()?)? {
</a>             Some(ref v) =&gt; Ok(Self { version, invisible: deserialize(v)? }),
             None =&gt; Err(Error::Value(format!(&quot;Snapshot not found for version {}&quot;, version))),
         }
<a href="#h4-15" id="h4-15" class="h">@@ -366,62 +409,6 @@ impl Snapshot {
</a>     }
 }
 
<a href="#h4-15-3" id="h4-15-3" class="d">-/// MVCC keys. The encoding preserves the grouping and ordering of keys. Uses a Cow since we want
</a><a href="#h4-15-4" id="h4-15-4" class="d">-/// to take borrows when encoding and return owned when decoding.
</a><a href="#h4-15-5" id="h4-15-5" class="d">-#[derive(Debug)]
</a><a href="#h4-15-6" id="h4-15-6" class="d">-enum Key&lt;&#39;a&gt; {
</a><a href="#h4-15-7" id="h4-15-7" class="d">-    /// The next available txn ID. Used when starting new txns.
</a><a href="#h4-15-8" id="h4-15-8" class="d">-    TxnNext,
</a><a href="#h4-15-9" id="h4-15-9" class="d">-    /// Active txn markers, containing the mode. Used to detect concurrent txns, and to resume.
</a><a href="#h4-15-10" id="h4-15-10" class="d">-    TxnActive(u64),
</a><a href="#h4-15-11" id="h4-15-11" class="d">-    /// Txn snapshot, containing concurrent active txns at start of txn.
</a><a href="#h4-15-12" id="h4-15-12" class="d">-    TxnSnapshot(u64),
</a><a href="#h4-15-13" id="h4-15-13" class="d">-    /// Update marker for a txn ID and key, used for rollback.
</a><a href="#h4-15-14" id="h4-15-14" class="d">-    TxnUpdate(u64, Cow&lt;&#39;a, [u8]&gt;),
</a><a href="#h4-15-15" id="h4-15-15" class="d">-    /// A record for a key/version pair.
</a><a href="#h4-15-16" id="h4-15-16" class="d">-    Record(Cow&lt;&#39;a, [u8]&gt;, u64),
</a><a href="#h4-15-17" id="h4-15-17" class="d">-    /// Arbitrary unversioned metadata.
</a><a href="#h4-15-18" id="h4-15-18" class="d">-    Metadata(Cow&lt;&#39;a, [u8]&gt;),
</a><a href="#h4-15-19" id="h4-15-19" class="d">-}
</a><a href="#h4-15-20" id="h4-15-20" class="d">-
</a><a href="#h4-15-21" id="h4-15-21" class="d">-impl&lt;&#39;a&gt; Key&lt;&#39;a&gt; {
</a><a href="#h4-15-22" id="h4-15-22" class="d">-    /// Encodes a key into a byte vector.
</a><a href="#h4-15-23" id="h4-15-23" class="d">-    fn encode(self) -&gt; Vec&lt;u8&gt; {
</a><a href="#h4-15-24" id="h4-15-24" class="d">-        use encoding::*;
</a><a href="#h4-15-25" id="h4-15-25" class="d">-        match self {
</a><a href="#h4-15-26" id="h4-15-26" class="d">-            Self::TxnNext =&gt; vec![0x01],
</a><a href="#h4-15-27" id="h4-15-27" class="d">-            Self::TxnActive(id) =&gt; [&amp;[0x02][..], &amp;encode_u64(id)].concat(),
</a><a href="#h4-15-28" id="h4-15-28" class="d">-            Self::TxnSnapshot(version) =&gt; [&amp;[0x03][..], &amp;encode_u64(version)].concat(),
</a><a href="#h4-15-29" id="h4-15-29" class="d">-            Self::TxnUpdate(id, key) =&gt; {
</a><a href="#h4-15-30" id="h4-15-30" class="d">-                [&amp;[0x04][..], &amp;encode_u64(id), &amp;encode_bytes(&amp;key)].concat()
</a><a href="#h4-15-31" id="h4-15-31" class="d">-            }
</a><a href="#h4-15-32" id="h4-15-32" class="d">-            Self::Metadata(key) =&gt; [&amp;[0x05][..], &amp;encode_bytes(&amp;key)].concat(),
</a><a href="#h4-15-33" id="h4-15-33" class="d">-            Self::Record(key, version) =&gt; {
</a><a href="#h4-15-34" id="h4-15-34" class="d">-                [&amp;[0xff][..], &amp;encode_bytes(&amp;key), &amp;encode_u64(version)].concat()
</a><a href="#h4-15-35" id="h4-15-35" class="d">-            }
</a><a href="#h4-15-36" id="h4-15-36" class="d">-        }
</a><a href="#h4-15-37" id="h4-15-37" class="d">-    }
</a><a href="#h4-15-38" id="h4-15-38" class="d">-
</a><a href="#h4-15-39" id="h4-15-39" class="d">-    /// Decodes a key from a byte representation.
</a><a href="#h4-15-40" id="h4-15-40" class="d">-    fn decode(mut bytes: &amp;[u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h4-15-41" id="h4-15-41" class="d">-        use encoding::*;
</a><a href="#h4-15-42" id="h4-15-42" class="d">-        let bytes = &amp;mut bytes;
</a><a href="#h4-15-43" id="h4-15-43" class="d">-        let key = match take_byte(bytes)? {
</a><a href="#h4-15-44" id="h4-15-44" class="d">-            0x01 =&gt; Self::TxnNext,
</a><a href="#h4-15-45" id="h4-15-45" class="d">-            0x02 =&gt; Self::TxnActive(take_u64(bytes)?),
</a><a href="#h4-15-46" id="h4-15-46" class="d">-            0x03 =&gt; Self::TxnSnapshot(take_u64(bytes)?),
</a><a href="#h4-15-47" id="h4-15-47" class="d">-            0x04 =&gt; Self::TxnUpdate(take_u64(bytes)?, take_bytes(bytes)?.into()),
</a><a href="#h4-15-48" id="h4-15-48" class="d">-            0x05 =&gt; Self::Metadata(take_bytes(bytes)?.into()),
</a><a href="#h4-15-49" id="h4-15-49" class="d">-            0xff =&gt; Self::Record(take_bytes(bytes)?.into(), take_u64(bytes)?),
</a><a href="#h4-15-50" id="h4-15-50" class="d">-            b =&gt; return Err(Error::Internal(format!(&quot;Unknown MVCC key prefix {:x?}&quot;, b))),
</a><a href="#h4-15-51" id="h4-15-51" class="d">-        };
</a><a href="#h4-15-52" id="h4-15-52" class="d">-        if !bytes.is_empty() {
</a><a href="#h4-15-53" id="h4-15-53" class="d">-            return Err(Error::Internal(&quot;Unexpected data remaining at end of key&quot;.into()));
</a><a href="#h4-15-54" id="h4-15-54" class="d">-        }
</a><a href="#h4-15-55" id="h4-15-55" class="d">-        Ok(key)
</a><a href="#h4-15-56" id="h4-15-56" class="d">-    }
</a><a href="#h4-15-57" id="h4-15-57" class="d">-}
</a><a href="#h4-15-58" id="h4-15-58" class="d">-
</a> pub type ScanIterator&lt;&#39;a&gt; =
     Box&lt;dyn DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; + Send + &#39;a&gt;;
 
</pre>
</div>
</body>
</html>
