<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>encoding: tweak Keycode comments - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/249fd65d06e38b91ae0f6f5315633fdefe15f065.html">249fd65d06e38b91ae0f6f5315633fdefe15f065</a>
<b>parent</b> <a href="../commit/67b06ee62dcd5cc9c50ae35889a10e8d8fdfa0ad.html">67b06ee62dcd5cc9c50ae35889a10e8d8fdfa0ad</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Wed, 19 Jun 2024 15:49:40 +0200

encoding: tweak Keycode comments

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/encoding/keycode.rs</a></td><td> | </td><td class="num">53</td><td><span class="i">++++++++++++++++++++++++++++++</span><span class="d">-----------------------</span></td></tr>
</table></pre><pre>1 file changed, 30 insertions(+), 23 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/encoding/keycode.rs.html">src/encoding/keycode.rs</a> b/<a href="../file/src/encoding/keycode.rs.html">src/encoding/keycode.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -50,7 +50,14 @@ use serde::{de, ser};
</a> use crate::errdata;
 use crate::error::{Error, Result};
 
<a href="#h0-0-3" id="h0-0-3" class="d">-// Serializes a key to a binary KeyCode representation.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+/// Serializes a key to a binary KeyCode representation.
</a><a href="#h0-0-5" id="h0-0-5" class="i">+///
</a><a href="#h0-0-6" id="h0-0-6" class="i">+/// This will allocate a new byte vector for every call. Often, keys are used
</a><a href="#h0-0-7" id="h0-0-7" class="i">+/// immediately and then discarded, so we could reuse a byte buffer between
</a><a href="#h0-0-8" id="h0-0-8" class="i">+/// calls to avoid the allocations. We don&#39;t, for simplicity.
</a><a href="#h0-0-9" id="h0-0-9" class="i">+///
</a><a href="#h0-0-10" id="h0-0-10" class="i">+/// TODO: given lifetime enforcement, it would be trivial to hand out references
</a><a href="#h0-0-11" id="h0-0-11" class="i">+/// to the reused byte buffer. Consider adding this.
</a> pub fn serialize&lt;T: serde::Serialize&gt;(key: &amp;T) -&gt; Vec&lt;u8&gt; {
     let mut serializer = Serializer { output: Vec::new() };
     // Panic on serialization failures, as this is typically an issue with the
<a href="#h0-1" id="h0-1" class="h">@@ -59,7 +66,7 @@ pub fn serialize&lt;T: serde::Serialize&gt;(key: &amp;T) -&gt; Vec&lt;u8&gt; {
</a>     serializer.output
 }
 
<a href="#h0-1-3" id="h0-1-3" class="d">-// Deserializes a key from a binary KeyCode representation.
</a><a href="#h0-1-4" id="h0-1-4" class="i">+/// Deserializes a key from a binary KeyCode representation.
</a> pub fn deserialize&lt;&#39;a, T: serde::Deserialize&lt;&#39;a&gt;&gt;(input: &amp;&#39;a [u8]) -&gt; Result&lt;T&gt; {
     let mut deserializer = Deserializer::from_bytes(input);
     let t = T::deserialize(&amp;mut deserializer)?;
<a href="#h0-2" id="h0-2" class="h">@@ -72,7 +79,7 @@ pub fn deserialize&lt;&#39;a, T: serde::Deserialize&lt;&#39;a&gt;&gt;(input: &amp;&#39;a [u8]) -&gt; Result&lt;T&gt; 
</a>     Ok(t)
 }
 
<a href="#h0-2-3" id="h0-2-3" class="d">-// Serializes keys as binary byte vectors.
</a><a href="#h0-2-4" id="h0-2-4" class="i">+/// Serializes keys as binary byte vectors.
</a> struct Serializer {
     output: Vec&lt;u8&gt;,
 }
<a href="#h0-3" id="h0-3" class="h">@@ -197,7 +204,7 @@ impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a>         unimplemented!()
     }
 
<a href="#h0-3-3" id="h0-3-3" class="d">-    // Enum variants are serialized using their index, as a single byte.
</a><a href="#h0-3-4" id="h0-3-4" class="i">+    /// Enum variants are serialized using their index, as a single byte.
</a>     fn serialize_unit_variant(self, _: &amp;&#39;static str, index: u32, _: &amp;&#39;static str) -&gt; Result&lt;()&gt; {
         self.output.push(u8::try_from(index)?);
         Ok(())
<a href="#h0-4" id="h0-4" class="h">@@ -211,7 +218,7 @@ impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a>         unimplemented!()
     }
 
<a href="#h0-4-3" id="h0-4-3" class="d">-    // Newtype variants are serialized using the variant index and inner type.
</a><a href="#h0-4-4" id="h0-4-4" class="i">+    /// Newtype variants are serialized using the variant index and inner type.
</a>     fn serialize_newtype_variant&lt;T: serde::Serialize + ?Sized&gt;(
         self,
         name: &amp;&#39;static str,
<a href="#h0-5" id="h0-5" class="h">@@ -223,12 +230,12 @@ impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a>         value.serialize(self)
     }
 
<a href="#h0-5-3" id="h0-5-3" class="d">-    // Sequences are serialized as the concatenation of the serialized elements.
</a><a href="#h0-5-4" id="h0-5-4" class="i">+    /// Sequences are serialized as the concatenation of the serialized elements.
</a>     fn serialize_seq(self, _: Option&lt;usize&gt;) -&gt; Result&lt;Self::SerializeSeq&gt; {
         Ok(self)
     }
 
<a href="#h0-5-9" id="h0-5-9" class="d">-    // Tuples are serialized as the concatenation of the serialized elements.
</a><a href="#h0-5-10" id="h0-5-10" class="i">+    /// Tuples are serialized as the concatenation of the serialized elements.
</a>     fn serialize_tuple(self, _: usize) -&gt; Result&lt;Self::SerializeTuple&gt; {
         Ok(self)
     }
<a href="#h0-6" id="h0-6" class="h">@@ -241,8 +248,8 @@ impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a>         unimplemented!()
     }
 
<a href="#h0-6-3" id="h0-6-3" class="d">-    // Tuple variants are serialized using the variant index and the
</a><a href="#h0-6-4" id="h0-6-4" class="d">-    // concatenation of the serialized elements.
</a><a href="#h0-6-5" id="h0-6-5" class="i">+    /// Tuple variants are serialized using the variant index and the
</a><a href="#h0-6-6" id="h0-6-6" class="i">+    /// concatenation of the serialized elements.
</a>     fn serialize_tuple_variant(
         self,
         name: &amp;&#39;static str,
<a href="#h0-7" id="h0-7" class="h">@@ -273,7 +280,7 @@ impl&lt;&#39;a&gt; serde::Serializer for &amp;&#39;a mut Serializer {
</a>     }
 }
 
<a href="#h0-7-3" id="h0-7-3" class="d">-// Sequences simply concatenate the serialized elements, with no external structure.
</a><a href="#h0-7-4" id="h0-7-4" class="i">+/// Sequences simply concatenate the serialized elements, with no external structure.
</a> impl&lt;&#39;a&gt; ser::SerializeSeq for &amp;&#39;a mut Serializer {
     type Ok = ();
     type Error = Error;
<a href="#h0-8" id="h0-8" class="h">@@ -287,7 +294,7 @@ impl&lt;&#39;a&gt; ser::SerializeSeq for &amp;&#39;a mut Serializer {
</a>     }
 }
 
<a href="#h0-8-3" id="h0-8-3" class="d">-// Tuples, like sequences, simply concatenate the serialized elements.
</a><a href="#h0-8-4" id="h0-8-4" class="i">+/// Tuples, like sequences, simply concatenate the serialized elements.
</a> impl&lt;&#39;a&gt; ser::SerializeTuple for &amp;&#39;a mut Serializer {
     type Ok = ();
     type Error = Error;
<a href="#h0-9" id="h0-9" class="h">@@ -301,7 +308,7 @@ impl&lt;&#39;a&gt; ser::SerializeTuple for &amp;&#39;a mut Serializer {
</a>     }
 }
 
<a href="#h0-9-3" id="h0-9-3" class="d">-// Tuples, like sequences, simply concatenate the serialized elements.
</a><a href="#h0-9-4" id="h0-9-4" class="i">+/// Tuples, like sequences, simply concatenate the serialized elements.
</a> impl&lt;&#39;a&gt; ser::SerializeTupleVariant for &amp;&#39;a mut Serializer {
     type Ok = ();
     type Error = Error;
<a href="#h0-10" id="h0-10" class="h">@@ -315,21 +322,21 @@ impl&lt;&#39;a&gt; ser::SerializeTupleVariant for &amp;&#39;a mut Serializer {
</a>     }
 }
 
<a href="#h0-10-3" id="h0-10-3" class="d">-// Deserializes keys from byte slices into a given type. The format is not
</a><a href="#h0-10-4" id="h0-10-4" class="d">-// self-describing, so the caller must provide a concrete type to deserialize
</a><a href="#h0-10-5" id="h0-10-5" class="d">-// into.
</a><a href="#h0-10-6" id="h0-10-6" class="i">+/// Deserializes keys from byte slices into a given type. The format is not
</a><a href="#h0-10-7" id="h0-10-7" class="i">+/// self-describing, so the caller must provide a concrete type to deserialize
</a><a href="#h0-10-8" id="h0-10-8" class="i">+/// into.
</a> pub struct Deserializer&lt;&#39;de&gt; {
     input: &amp;&#39;de [u8],
 }
 
 impl&lt;&#39;de&gt; Deserializer&lt;&#39;de&gt; {
<a href="#h0-10-14" id="h0-10-14" class="d">-    // Creates a deserializer for a byte slice.
</a><a href="#h0-10-15" id="h0-10-15" class="i">+    /// Creates a deserializer for a byte slice.
</a>     pub fn from_bytes(input: &amp;&#39;de [u8]) -&gt; Self {
         Deserializer { input }
     }
 
<a href="#h0-10-20" id="h0-10-20" class="d">-    // Chops off and returns the next len bytes of the byte slice, or errors if
</a><a href="#h0-10-21" id="h0-10-21" class="d">-    // there aren&#39;t enough bytes left.
</a><a href="#h0-10-22" id="h0-10-22" class="i">+    /// Chops off and returns the next len bytes of the byte slice, or errors if
</a><a href="#h0-10-23" id="h0-10-23" class="i">+    /// there aren&#39;t enough bytes left.
</a>     fn take_bytes(&amp;mut self, len: usize) -&gt; Result&lt;&amp;[u8]&gt; {
         if self.input.len() &lt; len {
             return errdata!(&quot;insufficient bytes, expected {len} bytes for {:x?}&quot;, self.input);
<a href="#h0-11" id="h0-11" class="h">@@ -339,7 +346,7 @@ impl&lt;&#39;de&gt; Deserializer&lt;&#39;de&gt; {
</a>         Ok(bytes)
     }
 
<a href="#h0-11-3" id="h0-11-3" class="d">-    // Decodes and chops off the next encoded byte slice.
</a><a href="#h0-11-4" id="h0-11-4" class="i">+    /// Decodes and chops off the next encoded byte slice.
</a>     fn decode_next_bytes(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
         // We can&#39;t easily share state between Iterator.scan() and
         // Iterator.filter() when processing escape sequences, so use a
<a href="#h0-12" id="h0-12" class="h">@@ -362,7 +369,7 @@ impl&lt;&#39;de&gt; Deserializer&lt;&#39;de&gt; {
</a>     }
 }
 
<a href="#h0-12-3" id="h0-12-3" class="d">-// For details on serialization formats, see Serializer.
</a><a href="#h0-12-4" id="h0-12-4" class="i">+/// For details on serialization formats, see Serializer.
</a> impl&lt;&#39;de, &#39;a&gt; serde::Deserializer&lt;&#39;de&gt; for &amp;&#39;a mut Deserializer&lt;&#39;de&gt; {
     type Error = Error;
 
<a href="#h0-13" id="h0-13" class="h">@@ -522,7 +529,7 @@ impl&lt;&#39;de, &#39;a&gt; serde::Deserializer&lt;&#39;de&gt; for &amp;&#39;a mut Deserializer&lt;&#39;de&gt; {
</a>     }
 }
 
<a href="#h0-13-3" id="h0-13-3" class="d">-// Sequences are simply deserialized until the byte slice is exhausted.
</a><a href="#h0-13-4" id="h0-13-4" class="i">+/// Sequences are simply deserialized until the byte slice is exhausted.
</a> impl&lt;&#39;de&gt; de::SeqAccess&lt;&#39;de&gt; for Deserializer&lt;&#39;de&gt; {
     type Error = Error;
 
<a href="#h0-14" id="h0-14" class="h">@@ -537,7 +544,7 @@ impl&lt;&#39;de&gt; de::SeqAccess&lt;&#39;de&gt; for Deserializer&lt;&#39;de&gt; {
</a>     }
 }
 
<a href="#h0-14-3" id="h0-14-3" class="d">-// Enum variants are deserialized by their index.
</a><a href="#h0-14-4" id="h0-14-4" class="i">+/// Enum variants are deserialized by their index.
</a> impl&lt;&#39;de&gt; de::EnumAccess&lt;&#39;de&gt; for &amp;mut Deserializer&lt;&#39;de&gt; {
     type Error = Error;
     type Variant = Self;
<a href="#h0-15" id="h0-15" class="h">@@ -552,7 +559,7 @@ impl&lt;&#39;de&gt; de::EnumAccess&lt;&#39;de&gt; for &amp;mut Deserializer&lt;&#39;de&gt; {
</a>     }
 }
 
<a href="#h0-15-3" id="h0-15-3" class="d">-// Enum variant contents are deserialized as sequences.
</a><a href="#h0-15-4" id="h0-15-4" class="i">+/// Enum variant contents are deserialized as sequences.
</a> impl&lt;&#39;de&gt; de::VariantAccess&lt;&#39;de&gt; for &amp;mut Deserializer&lt;&#39;de&gt; {
     type Error = Error;
 
</pre>
</div>
</body>
</html>
