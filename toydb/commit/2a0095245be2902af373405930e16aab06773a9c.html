<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: clean up plan module - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/2a0095245be2902af373405930e16aab06773a9c.html">2a0095245be2902af373405930e16aab06773a9c</a>
<b>parent</b> <a href="../commit/4c4ce6afeb084be5e4fe9b62bb367fc4f763c25f.html">4c4ce6afeb084be5e4fe9b62bb367fc4f763c25f</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Fri, 21 Jun 2024 15:40:46 +0200

sql: clean up plan module

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/execution/execute.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/execution/transform.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/execution/write.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/planner/plan.rs</a></td><td> | </td><td class="num">444</td><td><span class="i">++++++++++++++++++++++++++++++++++++++</span><span class="d">-----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++</span><span class="d">---------</span></td></tr>
</table></pre><pre>5 files changed, 233 insertions(+), 253 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a> b/<a href="../file/src/sql/execution/execute.rs.html">src/sql/execution/execute.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -29,9 +29,9 @@ pub fn execute_plan(
</a>             ExecutionResult::DropTable { name: table, existed }
         }
 
<a href="#h0-0-3" id="h0-0-3" class="d">-        Plan::Delete { table, key_index, source } =&gt; {
</a><a href="#h0-0-4" id="h0-0-4" class="i">+        Plan::Delete { table, primary_key, source } =&gt; {
</a>             let source = execute(source, txn)?;
<a href="#h0-0-6" id="h0-0-6" class="d">-            let count = write::delete(txn, table, key_index, source)?;
</a><a href="#h0-0-7" id="h0-0-7" class="i">+            let count = write::delete(txn, table, primary_key, source)?;
</a>             ExecutionResult::Delete { count }
         }
 
<a href="#h0-1" id="h0-1" class="h">@@ -43,10 +43,10 @@ pub fn execute_plan(
</a> 
         Plan::Select(node) =&gt; ExecutionResult::Select { iter: execute(node, txn)? },
 
<a href="#h0-1-3" id="h0-1-3" class="d">-        Plan::Update { table, key_index, source, expressions } =&gt; {
</a><a href="#h0-1-4" id="h0-1-4" class="i">+        Plan::Update { table, primary_key, source, expressions } =&gt; {
</a>             let source = execute(source, txn)?;
             let expressions = expressions.into_iter().map(|(i, _, expr)| (i, expr)).collect();
<a href="#h0-1-7" id="h0-1-7" class="d">-            let count = write::update(txn, table, key_index, source, expressions)?;
</a><a href="#h0-1-8" id="h0-1-8" class="i">+            let count = write::update(txn, table, primary_key, source, expressions)?;
</a>             ExecutionResult::Update { count }
         }
     })
<b>diff --git a/<a id="h1" href="../file/src/sql/execution/transform.rs.html">src/sql/execution/transform.rs</a> b/<a href="../file/src/sql/execution/transform.rs.html">src/sql/execution/transform.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -22,13 +22,13 @@ pub(super) fn filter(source: QueryIterator, predicate: Expression) -&gt; QueryItera
</a> }
 
 /// Limits the result to the given number of rows (i.e. LIMIT).
<a href="#h1-0-3" id="h1-0-3" class="d">-pub(super) fn limit(source: QueryIterator, limit: u64) -&gt; QueryIterator {
</a><a href="#h1-0-4" id="h1-0-4" class="d">-    source.map_rows(|rows| rows.take(limit as usize))
</a><a href="#h1-0-5" id="h1-0-5" class="i">+pub(super) fn limit(source: QueryIterator, limit: usize) -&gt; QueryIterator {
</a><a href="#h1-0-6" id="h1-0-6" class="i">+    source.map_rows(|rows| rows.take(limit))
</a> }
 
 /// Skips the given number of rows (i.e. OFFSET).
<a href="#h1-0-10" id="h1-0-10" class="d">-pub(super) fn offset(source: QueryIterator, offset: u64) -&gt; QueryIterator {
</a><a href="#h1-0-11" id="h1-0-11" class="d">-    source.map_rows(|rows| rows.skip(offset as usize))
</a><a href="#h1-0-12" id="h1-0-12" class="i">+pub(super) fn offset(source: QueryIterator, offset: usize) -&gt; QueryIterator {
</a><a href="#h1-0-13" id="h1-0-13" class="i">+    source.map_rows(|rows| rows.skip(offset))
</a> }
 
 /// Sorts the rows (i.e. ORDER BY).
<b>diff --git a/<a id="h2" href="../file/src/sql/execution/write.rs.html">src/sql/execution/write.rs</a> b/<a href="../file/src/sql/execution/write.rs.html">src/sql/execution/write.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -6,17 +6,17 @@ use crate::{errdata, errinput};
</a> 
 use std::collections::HashMap;
 
<a href="#h2-0-3" id="h2-0-3" class="d">-/// Deletes rows, taking primary keys from the source (i.e. DELETE).
</a><a href="#h2-0-4" id="h2-0-4" class="d">-/// Returns the number of rows deleted.
</a><a href="#h2-0-5" id="h2-0-5" class="i">+/// Deletes rows, taking primary keys from the source (i.e. DELETE) using the
</a><a href="#h2-0-6" id="h2-0-6" class="i">+/// primary_key field index. Returns the number of rows deleted.
</a> pub(super) fn delete(
     txn: &amp;impl Transaction,
     table: String,
<a href="#h2-0-10" id="h2-0-10" class="d">-    key_index: usize,
</a><a href="#h2-0-11" id="h2-0-11" class="i">+    primary_key: usize,
</a>     source: QueryIterator,
 ) -&gt; Result&lt;u64&gt; {
     let ids = source
         // TODO: consider moving this out to a QueryIterator helper.
<a href="#h2-0-16" id="h2-0-16" class="d">-        .map(|r| r.and_then(|row| row.into_iter().nth(key_index).ok_or(errdata!(&quot;short row&quot;))))
</a><a href="#h2-0-17" id="h2-0-17" class="i">+        .map(|r| r.and_then(|row| row.into_iter().nth(primary_key).ok_or(errdata!(&quot;short row&quot;))))
</a>         .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
     let count = ids.len() as u64;
     txn.delete(&amp;table, &amp;ids)?;
<a href="#h2-1" id="h2-1" class="h">@@ -81,7 +81,7 @@ pub(super) fn insert(
</a> pub(super) fn update(
     txn: &amp;impl Transaction,
     table: String,
<a href="#h2-1-3" id="h2-1-3" class="d">-    key_index: usize,
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    primary_key: usize,
</a>     mut source: QueryIterator,
     expressions: Vec&lt;(usize, Expression)&gt;,
 ) -&gt; Result&lt;u64&gt; {
<a href="#h2-2" id="h2-2" class="h">@@ -91,7 +91,7 @@ pub(super) fn update(
</a>         for (field, expr) in &amp;expressions {
             new[*field] = expr.evaluate(Some(&amp;row))?;
         }
<a href="#h2-2-3" id="h2-2-3" class="d">-        let id = row.into_iter().nth(key_index).ok_or::&lt;Error&gt;(errdata!(&quot;short row&quot;))?;
</a><a href="#h2-2-4" id="h2-2-4" class="i">+        let id = row.into_iter().nth(primary_key).ok_or::&lt;Error&gt;(errdata!(&quot;short row&quot;))?;
</a>         updates.insert(id, new);
     }
     let count = updates.len() as u64;
<b>diff --git a/<a id="h3" href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a> b/<a href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -10,27 +10,42 @@ use itertools::Itertools as _;
</a> use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
 
<a href="#h3-0-3" id="h3-0-3" class="d">-/// A statement execution plan. These are mostly made up of nested query plan
</a><a href="#h3-0-4" id="h3-0-4" class="d">-/// Nodes, which process and stream rows, but the root nodes can also perform
</a><a href="#h3-0-5" id="h3-0-5" class="d">-/// data modifications or schema changes.
</a><a href="#h3-0-6" id="h3-0-6" class="i">+/// A statement execution plan. Primarily made up of a tree of query plan Nodes,
</a><a href="#h3-0-7" id="h3-0-7" class="i">+/// which process and stream rows, but the root nodes can perform data
</a><a href="#h3-0-8" id="h3-0-8" class="i">+/// modifications or schema changes.
</a> #[derive(Debug, PartialEq, Serialize, Deserialize)]
 pub enum Plan {
<a href="#h3-0-11" id="h3-0-11" class="d">-    /// A CREATE TABLE plan.
</a><a href="#h3-0-12" id="h3-0-12" class="i">+    /// A CREATE TABLE plan. Creates a new table with the given schema. Errors
</a><a href="#h3-0-13" id="h3-0-13" class="i">+    /// if the table already exists or the schema is invalid.
</a>     CreateTable { schema: Table },
<a href="#h3-0-15" id="h3-0-15" class="d">-    /// A DROP TABLE plan.
</a><a href="#h3-0-16" id="h3-0-16" class="i">+    /// A DROP TABLE plan. Drops the given table. Errors if the table does not
</a><a href="#h3-0-17" id="h3-0-17" class="i">+    /// exist, unless if_exists is true.
</a>     DropTable { table: String, if_exists: bool },
<a href="#h3-0-19" id="h3-0-19" class="d">-    /// A DELETE plan.
</a><a href="#h3-0-20" id="h3-0-20" class="d">-    Delete { table: String, key_index: usize, source: Node },
</a><a href="#h3-0-21" id="h3-0-21" class="d">-    /// An INSERT plan.
</a><a href="#h3-0-22" id="h3-0-22" class="i">+    /// A DELETE plan. Deletes rows in table that match the rows from source.
</a><a href="#h3-0-23" id="h3-0-23" class="i">+    /// primary_key specifies the primary key column index in source rows.
</a><a href="#h3-0-24" id="h3-0-24" class="i">+    Delete { table: String, primary_key: usize, source: Node },
</a><a href="#h3-0-25" id="h3-0-25" class="i">+    /// An INSERT plan. Inserts rows from source (typically a Values node) into
</a><a href="#h3-0-26" id="h3-0-26" class="i">+    /// table. If column_map is given, it maps table → source column indexes and
</a><a href="#h3-0-27" id="h3-0-27" class="i">+    /// must have one entry for every column in source. Columns not emitted by
</a><a href="#h3-0-28" id="h3-0-28" class="i">+    /// source will get the column&#39;s default value if any, otherwise error.
</a>     Insert { table: Table, column_map: Option&lt;HashMap&lt;usize, usize&gt;&gt;, source: Node },
<a href="#h3-0-30" id="h3-0-30" class="d">-    /// An UPDATE plan.
</a><a href="#h3-0-31" id="h3-0-31" class="i">+    /// An UPDATE plan. Updates rows in table that match the rows from source,
</a><a href="#h3-0-32" id="h3-0-32" class="i">+    /// where primary_key specifies the source row column index of primary keys
</a><a href="#h3-0-33" id="h3-0-33" class="i">+    /// to update. The given column/expression pairs specify the row updates to
</a><a href="#h3-0-34" id="h3-0-34" class="i">+    /// be made, and will be evaluated using the old row entry from source. Rows
</a><a href="#h3-0-35" id="h3-0-35" class="i">+    /// in source must be complete, existing rows from the table to update.
</a><a href="#h3-0-36" id="h3-0-36" class="i">+    ///
</a><a href="#h3-0-37" id="h3-0-37" class="i">+    /// TODO: the expressions string is only used when displaying the plan, i.e.
</a><a href="#h3-0-38" id="h3-0-38" class="i">+    /// &quot;column = expr&quot;. Consider getting rid of it, or combining it with other
</a><a href="#h3-0-39" id="h3-0-39" class="i">+    /// label/column handling elsewhere.
</a>     Update {
         table: String,
<a href="#h3-0-42" id="h3-0-42" class="d">-        key_index: usize,
</a><a href="#h3-0-43" id="h3-0-43" class="i">+        primary_key: usize,
</a>         source: Node,
<a href="#h3-0-45" id="h3-0-45" class="d">-        expressions: Vec&lt;(usize, Option&lt;String&gt;, Expression)&gt;,
</a><a href="#h3-0-46" id="h3-0-46" class="i">+        expressions: Vec&lt;(usize, String, Expression)&gt;,
</a>     },
<a href="#h3-0-48" id="h3-0-48" class="d">-    /// A SELECT plan.
</a><a href="#h3-0-49" id="h3-0-49" class="i">+    /// A SELECT plan. Recursively executes the query plan tree and returns the
</a><a href="#h3-0-50" id="h3-0-50" class="i">+    /// resulting rows.
</a>     Select(Node),
 }
 
<a href="#h3-1" id="h3-1" class="h">@@ -57,65 +72,33 @@ impl Plan {
</a>         };
         Ok(match self {
             Self::CreateTable { .. } | Self::DropTable { .. } | Self::Insert { .. } =&gt; self,
<a href="#h3-1-3" id="h3-1-3" class="d">-            Self::Delete { table, key_index, source } =&gt; {
</a><a href="#h3-1-4" id="h3-1-4" class="d">-                Self::Delete { table, key_index, source: optimize(source)? }
</a><a href="#h3-1-5" id="h3-1-5" class="i">+            Self::Delete { table, primary_key, source } =&gt; {
</a><a href="#h3-1-6" id="h3-1-6" class="i">+                Self::Delete { table, primary_key, source: optimize(source)? }
</a>             }
<a href="#h3-1-8" id="h3-1-8" class="d">-            Self::Update { table, key_index, source, expressions } =&gt; {
</a><a href="#h3-1-9" id="h3-1-9" class="d">-                Self::Update { table, key_index, source: optimize(source)?, expressions }
</a><a href="#h3-1-10" id="h3-1-10" class="i">+            Self::Update { table, primary_key, source, expressions } =&gt; {
</a><a href="#h3-1-11" id="h3-1-11" class="i">+                Self::Update { table, primary_key, source: optimize(source)?, expressions }
</a>             }
             Self::Select(root) =&gt; Self::Select(optimize(root)?),
         })
     }
 }
 
<a href="#h3-1-18" id="h3-1-18" class="d">-// TODO: this needs testing and cleaning up.
</a><a href="#h3-1-19" id="h3-1-19" class="d">-impl std::fmt::Display for Plan {
</a><a href="#h3-1-20" id="h3-1-20" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h3-1-21" id="h3-1-21" class="d">-        match self {
</a><a href="#h3-1-22" id="h3-1-22" class="d">-            Self::CreateTable { schema } =&gt; write!(f, &quot;CreateTable: {}&quot;, schema.name),
</a><a href="#h3-1-23" id="h3-1-23" class="d">-            Self::DropTable { table, if_exists: _ } =&gt; write!(f, &quot;DropTable: {table}&quot;),
</a><a href="#h3-1-24" id="h3-1-24" class="d">-            Self::Delete { table, key_index: _, source } =&gt; {
</a><a href="#h3-1-25" id="h3-1-25" class="d">-                write!(
</a><a href="#h3-1-26" id="h3-1-26" class="d">-                    f,
</a><a href="#h3-1-27" id="h3-1-27" class="d">-                    &quot;Delete: {table}\n{}&quot;,
</a><a href="#h3-1-28" id="h3-1-28" class="d">-                    source.format(String::new(), false, true).trim_end()
</a><a href="#h3-1-29" id="h3-1-29" class="d">-                )
</a><a href="#h3-1-30" id="h3-1-30" class="d">-            }
</a><a href="#h3-1-31" id="h3-1-31" class="d">-            Self::Insert { table, column_map: _, source: _ } =&gt; {
</a><a href="#h3-1-32" id="h3-1-32" class="d">-                write!(f, &quot;Insert: {}&quot;, table.name)
</a><a href="#h3-1-33" id="h3-1-33" class="d">-            }
</a><a href="#h3-1-34" id="h3-1-34" class="d">-            Self::Select(root) =&gt; root.fmt(f),
</a><a href="#h3-1-35" id="h3-1-35" class="d">-            Self::Update { table, key_index: _, source, expressions } =&gt; {
</a><a href="#h3-1-36" id="h3-1-36" class="d">-                write!(
</a><a href="#h3-1-37" id="h3-1-37" class="d">-                    f,
</a><a href="#h3-1-38" id="h3-1-38" class="d">-                    &quot;Update: {table} ({})\n{}&quot;,
</a><a href="#h3-1-39" id="h3-1-39" class="d">-                    expressions
</a><a href="#h3-1-40" id="h3-1-40" class="d">-                        .iter()
</a><a href="#h3-1-41" id="h3-1-41" class="d">-                        .map(|(i, l, e)| format!(
</a><a href="#h3-1-42" id="h3-1-42" class="d">-                            &quot;{}={}&quot;,
</a><a href="#h3-1-43" id="h3-1-43" class="d">-                            l.clone().unwrap_or_else(|| format!(&quot;#{}&quot;, i)),
</a><a href="#h3-1-44" id="h3-1-44" class="d">-                            e
</a><a href="#h3-1-45" id="h3-1-45" class="d">-                        ))
</a><a href="#h3-1-46" id="h3-1-46" class="d">-                        .collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h3-1-47" id="h3-1-47" class="d">-                        .join(&quot;,&quot;),
</a><a href="#h3-1-48" id="h3-1-48" class="d">-                    source.format(String::new(), false, true).trim_end()
</a><a href="#h3-1-49" id="h3-1-49" class="d">-                )
</a><a href="#h3-1-50" id="h3-1-50" class="d">-            }
</a><a href="#h3-1-51" id="h3-1-51" class="d">-        }
</a><a href="#h3-1-52" id="h3-1-52" class="d">-    }
</a><a href="#h3-1-53" id="h3-1-53" class="d">-}
</a><a href="#h3-1-54" id="h3-1-54" class="d">-
</a> /// A query plan node. These return row iterators and can be nested.
 #[derive(Debug, PartialEq, Serialize, Deserialize)]
 pub enum Node {
<a href="#h3-1-58" id="h3-1-58" class="d">-    Aggregation {
</a><a href="#h3-1-59" id="h3-1-59" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h3-1-60" id="h3-1-60" class="d">-        aggregates: Vec&lt;Aggregate&gt;,
</a><a href="#h3-1-61" id="h3-1-61" class="d">-    },
</a><a href="#h3-1-62" id="h3-1-62" class="d">-    Filter {
</a><a href="#h3-1-63" id="h3-1-63" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h3-1-64" id="h3-1-64" class="d">-        predicate: Expression,
</a><a href="#h3-1-65" id="h3-1-65" class="d">-    },
</a><a href="#h3-1-66" id="h3-1-66" class="i">+    /// Aggregates the input rows by computing the given aggregates for the
</a><a href="#h3-1-67" id="h3-1-67" class="i">+    /// corresponding source columns. Additional columns in source for which
</a><a href="#h3-1-68" id="h3-1-68" class="i">+    /// there are no aggregates are used as group by buckets.
</a><a href="#h3-1-69" id="h3-1-69" class="i">+    ///
</a><a href="#h3-1-70" id="h3-1-70" class="i">+    /// TODO: consider making aggregates a field/aggregate pair.
</a><a href="#h3-1-71" id="h3-1-71" class="i">+    Aggregation { source: Box&lt;Node&gt;, aggregates: Vec&lt;Aggregate&gt; },
</a><a href="#h3-1-72" id="h3-1-72" class="i">+    /// Filters source rows, by only emitting rows for which the predicate
</a><a href="#h3-1-73" id="h3-1-73" class="i">+    /// evaluates to true.
</a><a href="#h3-1-74" id="h3-1-74" class="i">+    Filter { source: Box&lt;Node&gt;, predicate: Expression },
</a><a href="#h3-1-75" id="h3-1-75" class="i">+    /// Joins the left and right sources on the given fields by building an
</a><a href="#h3-1-76" id="h3-1-76" class="i">+    /// in-memory hashmap of the right source and looking up matches for each
</a><a href="#h3-1-77" id="h3-1-77" class="i">+    /// row in the left source. When outer is true (e.g. LEFT JOIN), a left row
</a><a href="#h3-1-78" id="h3-1-78" class="i">+    /// without a right match is emitted anyway, with NULLs for the right row.
</a>     HashJoin {
         left: Box&lt;Node&gt;,
         left_field: (usize, Option&lt;Label&gt;),
<a href="#h3-2" id="h3-2" class="h">@@ -123,21 +106,16 @@ pub enum Node {
</a>         right_field: (usize, Option&lt;Label&gt;),
         outer: bool,
     },
<a href="#h3-2-3" id="h3-2-3" class="d">-    IndexLookup {
</a><a href="#h3-2-4" id="h3-2-4" class="d">-        table: Table,
</a><a href="#h3-2-5" id="h3-2-5" class="d">-        alias: Option&lt;String&gt;,
</a><a href="#h3-2-6" id="h3-2-6" class="d">-        column: String,
</a><a href="#h3-2-7" id="h3-2-7" class="d">-        values: Vec&lt;Value&gt;,
</a><a href="#h3-2-8" id="h3-2-8" class="d">-    },
</a><a href="#h3-2-9" id="h3-2-9" class="d">-    KeyLookup {
</a><a href="#h3-2-10" id="h3-2-10" class="d">-        table: Table,
</a><a href="#h3-2-11" id="h3-2-11" class="d">-        alias: Option&lt;String&gt;,
</a><a href="#h3-2-12" id="h3-2-12" class="d">-        keys: Vec&lt;Value&gt;,
</a><a href="#h3-2-13" id="h3-2-13" class="d">-    },
</a><a href="#h3-2-14" id="h3-2-14" class="d">-    Limit {
</a><a href="#h3-2-15" id="h3-2-15" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h3-2-16" id="h3-2-16" class="d">-        limit: u64,
</a><a href="#h3-2-17" id="h3-2-17" class="d">-    },
</a><a href="#h3-2-18" id="h3-2-18" class="i">+    /// Looks up the given values in a secondary index and emits matching rows.
</a><a href="#h3-2-19" id="h3-2-19" class="i">+    IndexLookup { table: Table, alias: Option&lt;String&gt;, column: String, values: Vec&lt;Value&gt; },
</a><a href="#h3-2-20" id="h3-2-20" class="i">+    /// Looks up the given primary keys and emits their rows.
</a><a href="#h3-2-21" id="h3-2-21" class="i">+    KeyLookup { table: Table, alias: Option&lt;String&gt;, keys: Vec&lt;Value&gt; },
</a><a href="#h3-2-22" id="h3-2-22" class="i">+    /// Only emits the first limit rows from the source, discards the rest.
</a><a href="#h3-2-23" id="h3-2-23" class="i">+    Limit { source: Box&lt;Node&gt;, limit: usize },
</a><a href="#h3-2-24" id="h3-2-24" class="i">+    /// Joins the left and right sources on the given predicate by buffering the
</a><a href="#h3-2-25" id="h3-2-25" class="i">+    /// right source and iterating over it for every row in the left source.
</a><a href="#h3-2-26" id="h3-2-26" class="i">+    /// When outer is true (e.g. LEFT JOIN), a left row without a right match is
</a><a href="#h3-2-27" id="h3-2-27" class="i">+    /// emitted anyway, with NULLs for the right row.
</a>     NestedLoopJoin {
         left: Box&lt;Node&gt;,
         left_size: usize,
<a href="#h3-3" id="h3-3" class="h">@@ -145,106 +123,85 @@ pub enum Node {
</a>         predicate: Option&lt;Expression&gt;,
         outer: bool,
     },
<a href="#h3-3-3" id="h3-3-3" class="d">-    // TODO: replace with Values, but requires changes to aggregate planning.
</a><a href="#h3-3-4" id="h3-3-4" class="i">+    /// Emits a single empty row. Used for SELECT queries with no FROM clause.
</a><a href="#h3-3-5" id="h3-3-5" class="i">+    /// TODO: replace with Values, but requires changes to aggregate planning.
</a>     Nothing,
<a href="#h3-3-7" id="h3-3-7" class="d">-    Offset {
</a><a href="#h3-3-8" id="h3-3-8" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h3-3-9" id="h3-3-9" class="d">-        offset: u64,
</a><a href="#h3-3-10" id="h3-3-10" class="d">-    },
</a><a href="#h3-3-11" id="h3-3-11" class="d">-    Order {
</a><a href="#h3-3-12" id="h3-3-12" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h3-3-13" id="h3-3-13" class="d">-        orders: Vec&lt;(Expression, Direction)&gt;,
</a><a href="#h3-3-14" id="h3-3-14" class="d">-    },
</a><a href="#h3-3-15" id="h3-3-15" class="d">-    Projection {
</a><a href="#h3-3-16" id="h3-3-16" class="d">-        source: Box&lt;Node&gt;,
</a><a href="#h3-3-17" id="h3-3-17" class="d">-        labels: Vec&lt;Option&lt;Label&gt;&gt;,
</a><a href="#h3-3-18" id="h3-3-18" class="d">-        expressions: Vec&lt;Expression&gt;,
</a><a href="#h3-3-19" id="h3-3-19" class="d">-    },
</a><a href="#h3-3-20" id="h3-3-20" class="d">-    Scan {
</a><a href="#h3-3-21" id="h3-3-21" class="d">-        table: Table,
</a><a href="#h3-3-22" id="h3-3-22" class="d">-        alias: Option&lt;String&gt;,
</a><a href="#h3-3-23" id="h3-3-23" class="d">-        filter: Option&lt;Expression&gt;,
</a><a href="#h3-3-24" id="h3-3-24" class="d">-    },
</a><a href="#h3-3-25" id="h3-3-25" class="d">-    Values {
</a><a href="#h3-3-26" id="h3-3-26" class="d">-        labels: Vec&lt;Option&lt;Label&gt;&gt;,
</a><a href="#h3-3-27" id="h3-3-27" class="d">-        rows: Vec&lt;Vec&lt;Expression&gt;&gt;,
</a><a href="#h3-3-28" id="h3-3-28" class="d">-    },
</a><a href="#h3-3-29" id="h3-3-29" class="i">+    /// Discards the first offset rows from source, emits the rest.
</a><a href="#h3-3-30" id="h3-3-30" class="i">+    Offset { source: Box&lt;Node&gt;, offset: usize },
</a><a href="#h3-3-31" id="h3-3-31" class="i">+    /// Sorts the source rows by the given expression/direction pairs. Buffers
</a><a href="#h3-3-32" id="h3-3-32" class="i">+    /// the entire row set in memory.
</a><a href="#h3-3-33" id="h3-3-33" class="i">+    Order { source: Box&lt;Node&gt;, orders: Vec&lt;(Expression, Direction)&gt; },
</a><a href="#h3-3-34" id="h3-3-34" class="i">+    /// Projects the input rows by evaluating the given expressions.
</a><a href="#h3-3-35" id="h3-3-35" class="i">+    Projection { source: Box&lt;Node&gt;, labels: Vec&lt;Option&lt;Label&gt;&gt;, expressions: Vec&lt;Expression&gt; },
</a><a href="#h3-3-36" id="h3-3-36" class="i">+    /// A full table scan, with an optional filter pushdown.
</a><a href="#h3-3-37" id="h3-3-37" class="i">+    Scan { table: Table, alias: Option&lt;String&gt;, filter: Option&lt;Expression&gt; },
</a><a href="#h3-3-38" id="h3-3-38" class="i">+    /// A constant set of values.
</a><a href="#h3-3-39" id="h3-3-39" class="i">+    Values { labels: Vec&lt;Option&lt;Label&gt;&gt;, rows: Vec&lt;Vec&lt;Expression&gt;&gt; },
</a> }
 
 impl Node {
<a href="#h3-3-43" id="h3-3-43" class="d">-    /// Recursively transforms query nodes by applying the given closures before
</a><a href="#h3-3-44" id="h3-3-44" class="d">-    /// and after descending.
</a><a href="#h3-3-45" id="h3-3-45" class="i">+    /// Recursively transforms query nodes depth-first by applying the given
</a><a href="#h3-3-46" id="h3-3-46" class="i">+    /// closures before and after descending.
</a>     pub fn transform&lt;B, A&gt;(mut self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
     where
         B: Fn(Self) -&gt; Result&lt;Self&gt;,
         A: Fn(Self) -&gt; Result&lt;Self&gt;,
     {
<a href="#h3-3-52" id="h3-3-52" class="i">+        // Helper for transforming boxed nodes.
</a><a href="#h3-3-53" id="h3-3-53" class="i">+        let transform = |mut node: Box&lt;Node&gt;| -&gt; Result&lt;Box&lt;Node&gt;&gt; {
</a><a href="#h3-3-54" id="h3-3-54" class="i">+            *node = node.transform(before, after)?;
</a><a href="#h3-3-55" id="h3-3-55" class="i">+            Ok(node)
</a><a href="#h3-3-56" id="h3-3-56" class="i">+        };
</a><a href="#h3-3-57" id="h3-3-57" class="i">+
</a>         self = before(self)?;
         self = match self {
<a href="#h3-3-60" id="h3-3-60" class="d">-            node @ (Self::IndexLookup { .. }
</a><a href="#h3-3-61" id="h3-3-61" class="d">-            | Self::KeyLookup { .. }
</a><a href="#h3-3-62" id="h3-3-62" class="d">-            | Self::Nothing
</a><a href="#h3-3-63" id="h3-3-63" class="d">-            | Self::Scan { .. }
</a><a href="#h3-3-64" id="h3-3-64" class="d">-            | Self::Values { .. }) =&gt; node,
</a><a href="#h3-3-65" id="h3-3-65" class="d">-
</a>             Self::Aggregation { source, aggregates } =&gt; {
<a href="#h3-3-67" id="h3-3-67" class="d">-                Self::Aggregation { source: source.transform(before, after)?.into(), aggregates }
</a><a href="#h3-3-68" id="h3-3-68" class="i">+                Self::Aggregation { source: transform(source)?, aggregates }
</a>             }
             Self::Filter { source, predicate } =&gt; {
<a href="#h3-3-71" id="h3-3-71" class="d">-                Self::Filter { source: source.transform(before, after)?.into(), predicate }
</a><a href="#h3-3-72" id="h3-3-72" class="i">+                Self::Filter { source: transform(source)?, predicate }
</a>             }
             Self::HashJoin { left, left_field, right, right_field, outer } =&gt; Self::HashJoin {
<a href="#h3-3-75" id="h3-3-75" class="d">-                left: left.transform(before, after)?.into(),
</a><a href="#h3-3-76" id="h3-3-76" class="i">+                left: transform(left)?,
</a>                 left_field,
<a href="#h3-3-78" id="h3-3-78" class="d">-                right: right.transform(before, after)?.into(),
</a><a href="#h3-3-79" id="h3-3-79" class="i">+                right: transform(right)?,
</a>                 right_field,
                 outer,
             },
<a href="#h3-3-83" id="h3-3-83" class="d">-            Self::Limit { source, limit } =&gt; {
</a><a href="#h3-3-84" id="h3-3-84" class="d">-                Self::Limit { source: source.transform(before, after)?.into(), limit }
</a><a href="#h3-3-85" id="h3-3-85" class="d">-            }
</a><a href="#h3-3-86" id="h3-3-86" class="i">+            Self::Limit { source, limit } =&gt; Self::Limit { source: transform(source)?, limit },
</a>             Self::NestedLoopJoin { left, left_size, right, predicate, outer } =&gt; {
                 Self::NestedLoopJoin {
<a href="#h3-3-89" id="h3-3-89" class="d">-                    left: left.transform(before, after)?.into(),
</a><a href="#h3-3-90" id="h3-3-90" class="i">+                    left: transform(left)?,
</a>                     left_size,
<a href="#h3-3-92" id="h3-3-92" class="d">-                    right: right.transform(before, after)?.into(),
</a><a href="#h3-3-93" id="h3-3-93" class="i">+                    right: transform(right)?,
</a>                     predicate,
                     outer,
                 }
             }
<a href="#h3-3-98" id="h3-3-98" class="d">-            Self::Offset { source, offset } =&gt; {
</a><a href="#h3-3-99" id="h3-3-99" class="d">-                Self::Offset { source: source.transform(before, after)?.into(), offset }
</a><a href="#h3-3-100" id="h3-3-100" class="d">-            }
</a><a href="#h3-3-101" id="h3-3-101" class="d">-            Self::Order { source, orders } =&gt; {
</a><a href="#h3-3-102" id="h3-3-102" class="d">-                Self::Order { source: source.transform(before, after)?.into(), orders }
</a><a href="#h3-3-103" id="h3-3-103" class="i">+            Self::Offset { source, offset } =&gt; Self::Offset { source: transform(source)?, offset },
</a><a href="#h3-3-104" id="h3-3-104" class="i">+            Self::Order { source, orders } =&gt; Self::Order { source: transform(source)?, orders },
</a><a href="#h3-3-105" id="h3-3-105" class="i">+            Self::Projection { source, labels, expressions } =&gt; {
</a><a href="#h3-3-106" id="h3-3-106" class="i">+                Self::Projection { source: transform(source)?, labels, expressions }
</a>             }
<a href="#h3-3-108" id="h3-3-108" class="d">-            Self::Projection { source, labels, expressions } =&gt; Self::Projection {
</a><a href="#h3-3-109" id="h3-3-109" class="d">-                source: source.transform(before, after)?.into(),
</a><a href="#h3-3-110" id="h3-3-110" class="d">-                labels,
</a><a href="#h3-3-111" id="h3-3-111" class="d">-                expressions,
</a><a href="#h3-3-112" id="h3-3-112" class="d">-            },
</a><a href="#h3-3-113" id="h3-3-113" class="i">+
</a><a href="#h3-3-114" id="h3-3-114" class="i">+            node @ (Self::IndexLookup { .. }
</a><a href="#h3-3-115" id="h3-3-115" class="i">+            | Self::KeyLookup { .. }
</a><a href="#h3-3-116" id="h3-3-116" class="i">+            | Self::Nothing
</a><a href="#h3-3-117" id="h3-3-117" class="i">+            | Self::Scan { .. }
</a><a href="#h3-3-118" id="h3-3-118" class="i">+            | Self::Values { .. }) =&gt; node,
</a>         };
<a href="#h3-3-120" id="h3-3-120" class="d">-        after(self)
</a><a href="#h3-3-121" id="h3-3-121" class="i">+        self = after(self)?;
</a><a href="#h3-3-122" id="h3-3-122" class="i">+        Ok(self)
</a>     }
 
<a href="#h3-3-125" id="h3-3-125" class="d">-    /// Recursively transforms all expressions in a node by calling the given closures
</a><a href="#h3-3-126" id="h3-3-126" class="d">-    /// on them before and after descending.
</a><a href="#h3-3-127" id="h3-3-127" class="i">+    /// Recursively transforms all expressions in a node by calling the given
</a><a href="#h3-3-128" id="h3-3-128" class="i">+    /// closures on them before and after descending.
</a>     pub fn transform_expressions&lt;B, A&gt;(self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
     where
         B: Fn(Expression) -&gt; Result&lt;Expression&gt;,
         A: Fn(Expression) -&gt; Result&lt;Expression&gt;,
     {
         Ok(match self {
<a href="#h3-3-135" id="h3-3-135" class="d">-            node @ Self::Aggregation { .. }
</a><a href="#h3-3-136" id="h3-3-136" class="d">-            | node @ Self::HashJoin { .. }
</a><a href="#h3-3-137" id="h3-3-137" class="d">-            | node @ Self::IndexLookup { .. }
</a><a href="#h3-3-138" id="h3-3-138" class="d">-            | node @ Self::KeyLookup { .. }
</a><a href="#h3-3-139" id="h3-3-139" class="d">-            | node @ Self::Limit { .. }
</a><a href="#h3-3-140" id="h3-3-140" class="d">-            | node @ Self::NestedLoopJoin { predicate: None, .. }
</a><a href="#h3-3-141" id="h3-3-141" class="d">-            | node @ Self::Nothing
</a><a href="#h3-3-142" id="h3-3-142" class="d">-            | node @ Self::Offset { .. }
</a><a href="#h3-3-143" id="h3-3-143" class="d">-            | node @ Self::Scan { filter: None, .. } =&gt; node,
</a><a href="#h3-3-144" id="h3-3-144" class="d">-
</a>             Self::Filter { source, predicate } =&gt; {
                 Self::Filter { source, predicate: predicate.transform(before, after)? }
             }
<a href="#h3-4" id="h3-4" class="h">@@ -282,147 +239,174 @@ impl Node {
</a>                     .map(|row| row.into_iter().map(|e| e.transform(before, after)).collect())
                     .collect::&lt;Result&lt;_&gt;&gt;()?,
             },
<a href="#h3-4-3" id="h3-4-3" class="i">+
</a><a href="#h3-4-4" id="h3-4-4" class="i">+            node @ Self::Aggregation { .. }
</a><a href="#h3-4-5" id="h3-4-5" class="i">+            | node @ Self::HashJoin { .. }
</a><a href="#h3-4-6" id="h3-4-6" class="i">+            | node @ Self::IndexLookup { .. }
</a><a href="#h3-4-7" id="h3-4-7" class="i">+            | node @ Self::KeyLookup { .. }
</a><a href="#h3-4-8" id="h3-4-8" class="i">+            | node @ Self::Limit { .. }
</a><a href="#h3-4-9" id="h3-4-9" class="i">+            | node @ Self::NestedLoopJoin { predicate: None, .. }
</a><a href="#h3-4-10" id="h3-4-10" class="i">+            | node @ Self::Nothing
</a><a href="#h3-4-11" id="h3-4-11" class="i">+            | node @ Self::Offset { .. }
</a><a href="#h3-4-12" id="h3-4-12" class="i">+            | node @ Self::Scan { filter: None, .. } =&gt; node,
</a>         })
     }
<a href="#h3-4-15" id="h3-4-15" class="i">+}
</a><a href="#h3-4-16" id="h3-4-16" class="i">+
</a><a href="#h3-4-17" id="h3-4-17" class="i">+/// Formats the plan as an EXPLAIN tree.
</a><a href="#h3-4-18" id="h3-4-18" class="i">+impl std::fmt::Display for Plan {
</a><a href="#h3-4-19" id="h3-4-19" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h3-4-20" id="h3-4-20" class="i">+        match self {
</a><a href="#h3-4-21" id="h3-4-21" class="i">+            Self::CreateTable { schema } =&gt; write!(f, &quot;CreateTable: {}&quot;, schema.name),
</a><a href="#h3-4-22" id="h3-4-22" class="i">+            Self::DropTable { table, .. } =&gt; write!(f, &quot;DropTable: {table}&quot;),
</a><a href="#h3-4-23" id="h3-4-23" class="i">+            Self::Delete { table, source, .. } =&gt; {
</a><a href="#h3-4-24" id="h3-4-24" class="i">+                write!(f, &quot;Delete: {table}&quot;)?;
</a><a href="#h3-4-25" id="h3-4-25" class="i">+                source.format(f, String::new(), false, true)
</a><a href="#h3-4-26" id="h3-4-26" class="i">+            }
</a><a href="#h3-4-27" id="h3-4-27" class="i">+            Self::Insert { table, source, .. } =&gt; {
</a><a href="#h3-4-28" id="h3-4-28" class="i">+                write!(f, &quot;Insert: {}&quot;, table.name)?;
</a><a href="#h3-4-29" id="h3-4-29" class="i">+                source.format(f, String::new(), false, true)
</a><a href="#h3-4-30" id="h3-4-30" class="i">+            }
</a><a href="#h3-4-31" id="h3-4-31" class="i">+            Self::Update { table, source, expressions, .. } =&gt; {
</a><a href="#h3-4-32" id="h3-4-32" class="i">+                let expressions = expressions.iter().map(|(_, l, e)| format!(&quot;{l}={e}&quot;)).join(&quot;,&quot;);
</a><a href="#h3-4-33" id="h3-4-33" class="i">+                write!(f, &quot;Update: {table} ({expressions})&quot;)?;
</a><a href="#h3-4-34" id="h3-4-34" class="i">+                source.format(f, String::new(), false, true)
</a><a href="#h3-4-35" id="h3-4-35" class="i">+            }
</a><a href="#h3-4-36" id="h3-4-36" class="i">+            Self::Select(root) =&gt; root.fmt(f),
</a><a href="#h3-4-37" id="h3-4-37" class="i">+        }
</a><a href="#h3-4-38" id="h3-4-38" class="i">+    }
</a><a href="#h3-4-39" id="h3-4-39" class="i">+}
</a> 
<a href="#h3-4-41" id="h3-4-41" class="d">-    // Displays the node, where prefix gives the node prefix.
</a><a href="#h3-4-42" id="h3-4-42" class="d">-    pub fn format(&amp;self, mut indent: String, root: bool, last: bool) -&gt; String {
</a><a href="#h3-4-43" id="h3-4-43" class="d">-        // TODO: indent should be &amp;str or int.
</a><a href="#h3-4-44" id="h3-4-44" class="d">-        let mut s = indent.clone();
</a><a href="#h3-4-45" id="h3-4-45" class="i">+impl std::fmt::Display for Node {
</a><a href="#h3-4-46" id="h3-4-46" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h3-4-47" id="h3-4-47" class="i">+        self.format(f, String::new(), true, true)
</a><a href="#h3-4-48" id="h3-4-48" class="i">+    }
</a><a href="#h3-4-49" id="h3-4-49" class="i">+}
</a><a href="#h3-4-50" id="h3-4-50" class="i">+
</a><a href="#h3-4-51" id="h3-4-51" class="i">+impl Node {
</a><a href="#h3-4-52" id="h3-4-52" class="i">+    /// Recursively formats the node. Prefix is used for tree branches. root is
</a><a href="#h3-4-53" id="h3-4-53" class="i">+    /// true if this is the root (first) node, and last is used if this is the
</a><a href="#h3-4-54" id="h3-4-54" class="i">+    /// last node in this branch.
</a><a href="#h3-4-55" id="h3-4-55" class="i">+    pub fn format(
</a><a href="#h3-4-56" id="h3-4-56" class="i">+        &amp;self,
</a><a href="#h3-4-57" id="h3-4-57" class="i">+        f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;,
</a><a href="#h3-4-58" id="h3-4-58" class="i">+        mut prefix: String,
</a><a href="#h3-4-59" id="h3-4-59" class="i">+        root: bool,
</a><a href="#h3-4-60" id="h3-4-60" class="i">+        last: bool,
</a><a href="#h3-4-61" id="h3-4-61" class="i">+    ) -&gt; std::fmt::Result {
</a><a href="#h3-4-62" id="h3-4-62" class="i">+        // If this is not the root node, emit a newline after the previous node.
</a><a href="#h3-4-63" id="h3-4-63" class="i">+        // This avoids a spurious newline at the end of the plan.
</a><a href="#h3-4-64" id="h3-4-64" class="i">+        if !root {
</a><a href="#h3-4-65" id="h3-4-65" class="i">+            writeln!(f)?;
</a><a href="#h3-4-66" id="h3-4-66" class="i">+        }
</a><a href="#h3-4-67" id="h3-4-67" class="i">+
</a><a href="#h3-4-68" id="h3-4-68" class="i">+        // Prefix the node with a tree branch line. Modify the prefix for any
</a><a href="#h3-4-69" id="h3-4-69" class="i">+        // child nodes we&#39;ll recurse into.
</a><a href="#h3-4-70" id="h3-4-70" class="i">+        write!(f, &quot;{prefix}&quot;)?;
</a>         if !last {
<a href="#h3-4-72" id="h3-4-72" class="d">-            s += &quot;├─ &quot;;
</a><a href="#h3-4-73" id="h3-4-73" class="d">-            indent += &quot;│  &quot;
</a><a href="#h3-4-74" id="h3-4-74" class="i">+            write!(f, &quot;├─ &quot;)?;
</a><a href="#h3-4-75" id="h3-4-75" class="i">+            prefix += &quot;│  &quot;
</a>         } else if !root {
<a href="#h3-4-77" id="h3-4-77" class="d">-            s += &quot;└─ &quot;;
</a><a href="#h3-4-78" id="h3-4-78" class="d">-            indent += &quot;   &quot;;
</a><a href="#h3-4-79" id="h3-4-79" class="i">+            write!(f, &quot;└─ &quot;)?;
</a><a href="#h3-4-80" id="h3-4-80" class="i">+            prefix += &quot;   &quot;;
</a>         }
<a href="#h3-4-82" id="h3-4-82" class="i">+
</a><a href="#h3-4-83" id="h3-4-83" class="i">+        // Format the node.
</a>         match self {
             Self::Aggregation { source, aggregates } =&gt; {
<a href="#h3-4-86" id="h3-4-86" class="d">-                s += &amp;format!(
</a><a href="#h3-4-87" id="h3-4-87" class="d">-                    &quot;Aggregation: {}\n&quot;,
</a><a href="#h3-4-88" id="h3-4-88" class="d">-                    aggregates.iter().map(|a| a.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h3-4-89" id="h3-4-89" class="d">-                );
</a><a href="#h3-4-90" id="h3-4-90" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h3-4-91" id="h3-4-91" class="i">+                write!(f, &quot;Aggregation: {}&quot;, aggregates.iter().join(&quot;, &quot;))?;
</a><a href="#h3-4-92" id="h3-4-92" class="i">+                source.format(f, prefix, false, true)?;
</a>             }
             Self::Filter { source, predicate } =&gt; {
<a href="#h3-4-95" id="h3-4-95" class="d">-                s += &amp;format!(&quot;Filter: {}\n&quot;, predicate);
</a><a href="#h3-4-96" id="h3-4-96" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h3-4-97" id="h3-4-97" class="i">+                write!(f, &quot;Filter: {predicate}&quot;)?;
</a><a href="#h3-4-98" id="h3-4-98" class="i">+                source.format(f, prefix, false, true)?;
</a>             }
             Self::HashJoin { left, left_field, right, right_field, outer } =&gt; {
<a href="#h3-4-101" id="h3-4-101" class="d">-                s += &amp;format!(
</a><a href="#h3-4-102" id="h3-4-102" class="d">-                    &quot;HashJoin: {} on {} = {}\n&quot;,
</a><a href="#h3-4-103" id="h3-4-103" class="d">-                    if *outer { &quot;outer&quot; } else { &quot;inner&quot; },
</a><a href="#h3-4-104" id="h3-4-104" class="d">-                    match left_field {
</a><a href="#h3-4-105" id="h3-4-105" class="d">-                        (_, Some((Some(t), n))) =&gt; format!(&quot;{}.{}&quot;, t, n),
</a><a href="#h3-4-106" id="h3-4-106" class="d">-                        (_, Some((None, n))) =&gt; n.clone(),
</a><a href="#h3-4-107" id="h3-4-107" class="d">-                        (i, None) =&gt; format!(&quot;left #{}&quot;, i),
</a><a href="#h3-4-108" id="h3-4-108" class="d">-                    },
</a><a href="#h3-4-109" id="h3-4-109" class="d">-                    match right_field {
</a><a href="#h3-4-110" id="h3-4-110" class="d">-                        (_, Some((Some(t), n))) =&gt; format!(&quot;{}.{}&quot;, t, n),
</a><a href="#h3-4-111" id="h3-4-111" class="d">-                        (_, Some((None, n))) =&gt; n.clone(),
</a><a href="#h3-4-112" id="h3-4-112" class="d">-                        (i, None) =&gt; format!(&quot;right #{}&quot;, i),
</a><a href="#h3-4-113" id="h3-4-113" class="d">-                    },
</a><a href="#h3-4-114" id="h3-4-114" class="d">-                );
</a><a href="#h3-4-115" id="h3-4-115" class="d">-                s += &amp;left.format(indent.clone(), false, false);
</a><a href="#h3-4-116" id="h3-4-116" class="d">-                s += &amp;right.format(indent, false, true);
</a><a href="#h3-4-117" id="h3-4-117" class="i">+                let kind = if *outer { &quot;outer&quot; } else { &quot;inner&quot; };
</a><a href="#h3-4-118" id="h3-4-118" class="i">+                // TODO: make Label a proper type with formatting.
</a><a href="#h3-4-119" id="h3-4-119" class="i">+                let left_label = match left_field {
</a><a href="#h3-4-120" id="h3-4-120" class="i">+                    (_, Some((Some(t), n))) =&gt; format!(&quot;{t}.{n}&quot;),
</a><a href="#h3-4-121" id="h3-4-121" class="i">+                    (_, Some((None, n))) =&gt; n.clone(),
</a><a href="#h3-4-122" id="h3-4-122" class="i">+                    (i, None) =&gt; format!(&quot;left #{}&quot;, i),
</a><a href="#h3-4-123" id="h3-4-123" class="i">+                };
</a><a href="#h3-4-124" id="h3-4-124" class="i">+                let right_label = match right_field {
</a><a href="#h3-4-125" id="h3-4-125" class="i">+                    (_, Some((Some(t), n))) =&gt; format!(&quot;{t}.{n}&quot;),
</a><a href="#h3-4-126" id="h3-4-126" class="i">+                    (_, Some((None, n))) =&gt; n.clone(),
</a><a href="#h3-4-127" id="h3-4-127" class="i">+                    (i, None) =&gt; format!(&quot;right #{}&quot;, i),
</a><a href="#h3-4-128" id="h3-4-128" class="i">+                };
</a><a href="#h3-4-129" id="h3-4-129" class="i">+                write!(f, &quot;HashJoin: {kind} on {left_label} = {right_label}&quot;)?;
</a><a href="#h3-4-130" id="h3-4-130" class="i">+                left.format(f, prefix.clone(), false, false)?;
</a><a href="#h3-4-131" id="h3-4-131" class="i">+                right.format(f, prefix, false, true)?;
</a>             }
             Self::IndexLookup { table, column, alias, values } =&gt; {
<a href="#h3-4-134" id="h3-4-134" class="d">-                s += &amp;format!(&quot;IndexLookup: {}&quot;, table.name);
</a><a href="#h3-4-135" id="h3-4-135" class="i">+                write!(f, &quot;IndexLookup: {}&quot;, table.name)?;
</a>                 if let Some(alias) = alias {
<a href="#h3-4-137" id="h3-4-137" class="d">-                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h3-4-138" id="h3-4-138" class="i">+                    write!(f, &quot; as {}&quot;, alias)?;
</a>                 }
<a href="#h3-4-140" id="h3-4-140" class="d">-                s += &amp;format!(&quot; column {}&quot;, column);
</a><a href="#h3-4-141" id="h3-4-141" class="i">+                write!(f, &quot; column {}&quot;, column)?;
</a>                 if !values.is_empty() &amp;&amp; values.len() &lt; 10 {
<a href="#h3-4-143" id="h3-4-143" class="d">-                    s += &amp;format!(
</a><a href="#h3-4-144" id="h3-4-144" class="d">-                        &quot; ({})&quot;,
</a><a href="#h3-4-145" id="h3-4-145" class="d">-                        values.iter().map(|k| k.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h3-4-146" id="h3-4-146" class="d">-                    );
</a><a href="#h3-4-147" id="h3-4-147" class="i">+                    write!(f, &quot; ({})&quot;, values.iter().join(&quot;, &quot;))?;
</a>                 } else {
<a href="#h3-4-149" id="h3-4-149" class="d">-                    s += &amp;format!(&quot; ({} values)&quot;, values.len());
</a><a href="#h3-4-150" id="h3-4-150" class="i">+                    write!(f, &quot; ({} values)&quot;, values.len())?;
</a>                 }
<a href="#h3-4-152" id="h3-4-152" class="d">-                s += &quot;\n&quot;;
</a>             }
             Self::KeyLookup { table, alias, keys } =&gt; {
<a href="#h3-4-155" id="h3-4-155" class="d">-                s += &amp;format!(&quot;KeyLookup: {}&quot;, table.name);
</a><a href="#h3-4-156" id="h3-4-156" class="i">+                write!(f, &quot;KeyLookup: {}&quot;, table.name)?;
</a>                 if let Some(alias) = alias {
<a href="#h3-4-158" id="h3-4-158" class="d">-                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h3-4-159" id="h3-4-159" class="i">+                    write!(f, &quot; as {alias}&quot;)?;
</a>                 }
                 if !keys.is_empty() &amp;&amp; keys.len() &lt; 10 {
<a href="#h3-4-162" id="h3-4-162" class="d">-                    s += &amp;format!(
</a><a href="#h3-4-163" id="h3-4-163" class="d">-                        &quot; ({})&quot;,
</a><a href="#h3-4-164" id="h3-4-164" class="d">-                        keys.iter().map(|k| k.to_string()).collect::&lt;Vec&lt;_&gt;&gt;().join(&quot;, &quot;)
</a><a href="#h3-4-165" id="h3-4-165" class="d">-                    );
</a><a href="#h3-4-166" id="h3-4-166" class="i">+                    write!(f, &quot; ({})&quot;, keys.iter().join(&quot;, &quot;))?;
</a>                 } else {
<a href="#h3-4-168" id="h3-4-168" class="d">-                    s += &amp;format!(&quot; ({} keys)&quot;, keys.len());
</a><a href="#h3-4-169" id="h3-4-169" class="i">+                    write!(f, &quot; ({} keys)&quot;, keys.len())?;
</a>                 }
<a href="#h3-4-171" id="h3-4-171" class="d">-                s += &quot;\n&quot;;
</a>             }
             Self::Limit { source, limit } =&gt; {
<a href="#h3-4-174" id="h3-4-174" class="d">-                s += &amp;format!(&quot;Limit: {}\n&quot;, limit);
</a><a href="#h3-4-175" id="h3-4-175" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h3-4-176" id="h3-4-176" class="i">+                write!(f, &quot;Limit: {limit}&quot;)?;
</a><a href="#h3-4-177" id="h3-4-177" class="i">+                source.format(f, prefix, false, true)?;
</a>             }
<a href="#h3-4-179" id="h3-4-179" class="d">-            Self::NestedLoopJoin { left, left_size: _, right, predicate, outer } =&gt; {
</a><a href="#h3-4-180" id="h3-4-180" class="d">-                s += &amp;format!(&quot;NestedLoopJoin: {}&quot;, if *outer { &quot;outer&quot; } else { &quot;inner&quot; });
</a><a href="#h3-4-181" id="h3-4-181" class="i">+            Self::NestedLoopJoin { left, right, predicate, outer, .. } =&gt; {
</a><a href="#h3-4-182" id="h3-4-182" class="i">+                write!(f, &quot;NestedLoopJoin: {}&quot;, if *outer { &quot;outer&quot; } else { &quot;inner&quot; })?;
</a>                 if let Some(expr) = predicate {
<a href="#h3-4-184" id="h3-4-184" class="d">-                    s += &amp;format!(&quot; on {}&quot;, expr);
</a><a href="#h3-4-185" id="h3-4-185" class="i">+                    write!(f, &quot; on {expr}&quot;)?;
</a>                 }
<a href="#h3-4-187" id="h3-4-187" class="d">-                s += &quot;\n&quot;;
</a><a href="#h3-4-188" id="h3-4-188" class="d">-                s += &amp;left.format(indent.clone(), false, false);
</a><a href="#h3-4-189" id="h3-4-189" class="d">-                s += &amp;right.format(indent, false, true);
</a><a href="#h3-4-190" id="h3-4-190" class="i">+                left.format(f, prefix.clone(), false, false)?;
</a><a href="#h3-4-191" id="h3-4-191" class="i">+                right.format(f, prefix, false, true)?;
</a>             }
             Self::Nothing {} =&gt; {
<a href="#h3-4-194" id="h3-4-194" class="d">-                s += &quot;Nothing\n&quot;;
</a><a href="#h3-4-195" id="h3-4-195" class="i">+                write!(f, &quot;Nothing&quot;)?;
</a>             }
             Self::Offset { source, offset } =&gt; {
<a href="#h3-4-198" id="h3-4-198" class="d">-                s += &amp;format!(&quot;Offset: {}\n&quot;, offset);
</a><a href="#h3-4-199" id="h3-4-199" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h3-4-200" id="h3-4-200" class="i">+                write!(f, &quot;Offset: {offset}&quot;)?;
</a><a href="#h3-4-201" id="h3-4-201" class="i">+                source.format(f, prefix, false, true)?;
</a>             }
             Self::Order { source, orders } =&gt; {
<a href="#h3-4-204" id="h3-4-204" class="d">-                s += &amp;format!(
</a><a href="#h3-4-205" id="h3-4-205" class="d">-                    &quot;Order: {}\n&quot;,
</a><a href="#h3-4-206" id="h3-4-206" class="d">-                    orders
</a><a href="#h3-4-207" id="h3-4-207" class="d">-                        .iter()
</a><a href="#h3-4-208" id="h3-4-208" class="d">-                        .map(|(expr, dir)| format!(&quot;{} {}&quot;, expr, dir))
</a><a href="#h3-4-209" id="h3-4-209" class="d">-                        .collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h3-4-210" id="h3-4-210" class="d">-                        .join(&quot;, &quot;)
</a><a href="#h3-4-211" id="h3-4-211" class="d">-                );
</a><a href="#h3-4-212" id="h3-4-212" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h3-4-213" id="h3-4-213" class="i">+                let orders = orders.iter().map(|(expr, dir)| format!(&quot;{expr} {dir}&quot;)).join(&quot;, &quot;);
</a><a href="#h3-4-214" id="h3-4-214" class="i">+                write!(f, &quot;Order: {orders}&quot;)?;
</a><a href="#h3-4-215" id="h3-4-215" class="i">+                source.format(f, prefix, false, true)?;
</a>             }
<a href="#h3-4-217" id="h3-4-217" class="d">-            Self::Projection { source, labels: _, expressions } =&gt; {
</a><a href="#h3-4-218" id="h3-4-218" class="d">-                s += &amp;format!(
</a><a href="#h3-4-219" id="h3-4-219" class="d">-                    &quot;Projection: {}\n&quot;,
</a><a href="#h3-4-220" id="h3-4-220" class="d">-                    expressions.iter().map(|expr| expr.to_string()).join(&quot;, &quot;)
</a><a href="#h3-4-221" id="h3-4-221" class="d">-                );
</a><a href="#h3-4-222" id="h3-4-222" class="d">-                s += &amp;source.format(indent, false, true);
</a><a href="#h3-4-223" id="h3-4-223" class="i">+            Self::Projection { source, expressions, .. } =&gt; {
</a><a href="#h3-4-224" id="h3-4-224" class="i">+                write!(f, &quot;Projection: {}&quot;, expressions.iter().join(&quot;, &quot;))?;
</a><a href="#h3-4-225" id="h3-4-225" class="i">+                source.format(f, prefix, false, true)?;
</a>             }
             Self::Scan { table, alias, filter } =&gt; {
<a href="#h3-4-228" id="h3-4-228" class="d">-                s += &amp;format!(&quot;Scan: {}&quot;, table.name);
</a><a href="#h3-4-229" id="h3-4-229" class="i">+                write!(f, &quot;Scan: {}&quot;, table.name)?;
</a>                 if let Some(alias) = alias {
<a href="#h3-4-231" id="h3-4-231" class="d">-                    s += &amp;format!(&quot; as {}&quot;, alias);
</a><a href="#h3-4-232" id="h3-4-232" class="i">+                    write!(f, &quot; as {alias}&quot;)?;
</a>                 }
                 if let Some(expr) = filter {
<a href="#h3-4-235" id="h3-4-235" class="d">-                    s += &amp;format!(&quot; ({})&quot;, expr);
</a><a href="#h3-4-236" id="h3-4-236" class="i">+                    write!(f, &quot; ({expr})&quot;)?;
</a>                 }
<a href="#h3-4-238" id="h3-4-238" class="d">-                s += &quot;\n&quot;;
</a>             }
<a href="#h3-4-240" id="h3-4-240" class="d">-            Self::Values { labels: _, rows } =&gt; {
</a><a href="#h3-4-241" id="h3-4-241" class="d">-                s += &amp;format!(&quot;Values: {} rows\n&quot;, rows.len());
</a><a href="#h3-4-242" id="h3-4-242" class="i">+            Self::Values { rows, .. } =&gt; {
</a><a href="#h3-4-243" id="h3-4-243" class="i">+                write!(f, &quot;Values: {} rows&quot;, rows.len())?;
</a>             }
         };
<a href="#h3-4-246" id="h3-4-246" class="d">-        if root {
</a><a href="#h3-4-247" id="h3-4-247" class="d">-            s = s.trim_end().to_string()
</a><a href="#h3-4-248" id="h3-4-248" class="d">-        }
</a><a href="#h3-4-249" id="h3-4-249" class="d">-        s
</a><a href="#h3-4-250" id="h3-4-250" class="d">-    }
</a><a href="#h3-4-251" id="h3-4-251" class="d">-}
</a><a href="#h3-4-252" id="h3-4-252" class="d">-
</a><a href="#h3-4-253" id="h3-4-253" class="d">-impl std::fmt::Display for Node {
</a><a href="#h3-4-254" id="h3-4-254" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h3-4-255" id="h3-4-255" class="d">-        write!(f, &quot;{}&quot;, self.format(&quot;&quot;.to_string(), true, true))
</a><a href="#h3-4-256" id="h3-4-256" class="i">+        Ok(())
</a>     }
 }
 
<a href="#h3-4-260" id="h3-4-260" class="d">-/// An aggregate operation
</a><a href="#h3-4-261" id="h3-4-261" class="i">+/// An aggregation function.
</a> #[derive(Debug, PartialEq, Serialize, Deserialize)]
 pub enum Aggregate {
     Average,
<b>diff --git a/<a id="h4" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -77,7 +77,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 let scope = &amp;mut Scope::from_table(table.clone())?;
                 Plan::Delete {
                     table: table.name.clone(),
<a href="#h4-0-3" id="h4-0-3" class="d">-                    key_index: table.primary_key,
</a><a href="#h4-0-4" id="h4-0-4" class="i">+                    primary_key: table.primary_key,
</a>                     source: Node::Scan {
                         table,
                         alias: None,
<a href="#h4-1" id="h4-1" class="h">@@ -118,7 +118,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 let scope = &amp;mut Scope::from_table(table.clone())?;
                 Plan::Update {
                     table: table.name.clone(),
<a href="#h4-1-3" id="h4-1-3" class="d">-                    key_index: table.primary_key,
</a><a href="#h4-1-4" id="h4-1-4" class="i">+                    primary_key: table.primary_key,
</a>                     source: Node::Scan {
                         table,
                         alias: None,
<a href="#h4-2" id="h4-2" class="h">@@ -127,11 +127,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                     expressions: set
                         .into_iter()
                         .map(|(c, e)| {
<a href="#h4-2-3" id="h4-2-3" class="d">-                            Ok((
</a><a href="#h4-2-4" id="h4-2-4" class="d">-                                scope.resolve(None, &amp;c)?,
</a><a href="#h4-2-5" id="h4-2-5" class="d">-                                Some(c),
</a><a href="#h4-2-6" id="h4-2-6" class="d">-                                self.build_expression(scope, e)?,
</a><a href="#h4-2-7" id="h4-2-7" class="d">-                            ))
</a><a href="#h4-2-8" id="h4-2-8" class="i">+                            Ok((scope.resolve(None, &amp;c)?, c, self.build_expression(scope, e)?))
</a>                         })
                         .collect::&lt;Result&lt;_&gt;&gt;()?,
                 }
<a href="#h4-3" id="h4-3" class="h">@@ -244,7 +240,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                     node = Node::Offset {
                         source: Box::new(node),
                         offset: match self.evaluate_constant(expr)? {
<a href="#h4-3-3" id="h4-3-3" class="d">-                            Value::Integer(i) if i &gt;= 0 =&gt; Ok(i as u64),
</a><a href="#h4-3-4" id="h4-3-4" class="i">+                            Value::Integer(i) if i &gt;= 0 =&gt; Ok(i as usize),
</a>                             v =&gt; errinput!(&quot;invalid offset {v}&quot;),
                         }?,
                     }
<a href="#h4-4" id="h4-4" class="h">@@ -255,7 +251,7 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                     node = Node::Limit {
                         source: Box::new(node),
                         limit: match self.evaluate_constant(expr)? {
<a href="#h4-4-3" id="h4-4-3" class="d">-                            Value::Integer(i) if i &gt;= 0 =&gt; Ok(i as u64),
</a><a href="#h4-4-4" id="h4-4-4" class="i">+                            Value::Integer(i) if i &gt;= 0 =&gt; Ok(i as usize),
</a>                             v =&gt; errinput!(&quot;invalid limit {v}&quot;),
                         }?,
                     }
</pre>
</div>
</body>
</html>
