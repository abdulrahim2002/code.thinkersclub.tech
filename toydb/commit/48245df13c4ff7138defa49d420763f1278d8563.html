<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: use expression/label tuples for projections - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/48245df13c4ff7138defa49d420763f1278d8563.html">48245df13c4ff7138defa49d420763f1278d8563</a>
<b>parent</b> <a href="../commit/bf2e465926cd27828961502353536ff15457796c.html">bf2e465926cd27828961502353536ff15457796c</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sat, 30 May 2020 21:16:13 +0200

sql: use expression/label tuples for projections

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/execution/mod.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/execution/projection.rs</a></td><td> | </td><td class="num">68</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d">---------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">5</td><td><span class="i">+</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/parser/mod.rs</a></td><td> | </td><td class="num">13</td><td><span class="i">+++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/plan/mod.rs</a></td><td> | </td><td class="num">23</td><td><span class="i">+++++++++</span><span class="d">--------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/plan/planner.rs</a></td><td> | </td><td class="num">66</td><td><span class="i">++++++++++++++++++++++++++++</span><span class="d">--------------------------------------</span></td></tr>
</table></pre><pre>6 files changed, 76 insertions(+), 103 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a> b/<a href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -71,8 +71,8 @@ impl&lt;T: Transaction + &#39;static&gt; dyn Executor&lt;T&gt; {
</a>             Node::Nothing =&gt; Nothing::new(),
             Node::Offset { source, offset } =&gt; Offset::new(Self::build(*source), offset),
             Node::Order { source, orders } =&gt; Order::new(Self::build(*source), orders),
<a href="#h0-0-3" id="h0-0-3" class="d">-            Node::Projection { source, labels, expressions } =&gt; {
</a><a href="#h0-0-4" id="h0-0-4" class="d">-                Projection::new(Self::build(*source), labels, expressions)
</a><a href="#h0-0-5" id="h0-0-5" class="i">+            Node::Projection { source, expressions } =&gt; {
</a><a href="#h0-0-6" id="h0-0-6" class="i">+                Projection::new(Self::build(*source), expressions)
</a>             }
             Node::Scan { table, filter, alias: _ } =&gt; Scan::new(table, filter),
             Node::Update { table, source, expressions } =&gt; {
<b>diff --git a/<a id="h1" href="../file/src/sql/execution/projection.rs.html">src/sql/execution/projection.rs</a> b/<a href="../file/src/sql/execution/projection.rs.html">src/sql/execution/projection.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,59 +1,49 @@
</a> use super::super::engine::Transaction;
<a href="#h1-0-1" id="h1-0-1" class="d">-use super::super::types::{Column, Expression, Expressions};
</a><a href="#h1-0-2" id="h1-0-2" class="i">+use super::super::types::{Column, Expression};
</a> use super::{Executor, ResultSet};
 use crate::error::{Error, Result};
 
<a href="#h1-0-6" id="h1-0-6" class="d">-/// A filter executor
</a><a href="#h1-0-7" id="h1-0-7" class="i">+/// A projection executor
</a> pub struct Projection&lt;T: Transaction&gt; {
<a href="#h1-0-9" id="h1-0-9" class="d">-    /// The source of rows to project
</a>     source: Box&lt;dyn Executor&lt;T&gt;&gt;,
<a href="#h1-0-11" id="h1-0-11" class="d">-    /// Labels for each column, if any
</a><a href="#h1-0-12" id="h1-0-12" class="d">-    labels: Vec&lt;Option&lt;String&gt;&gt;,
</a><a href="#h1-0-13" id="h1-0-13" class="d">-    /// Expressions to project
</a><a href="#h1-0-14" id="h1-0-14" class="d">-    expressions: Expressions,
</a><a href="#h1-0-15" id="h1-0-15" class="i">+    expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a> }
 
 impl&lt;T: Transaction&gt; Projection&lt;T&gt; {
     pub fn new(
         source: Box&lt;dyn Executor&lt;T&gt;&gt;,
<a href="#h1-0-21" id="h1-0-21" class="d">-        labels: Vec&lt;Option&lt;String&gt;&gt;,
</a><a href="#h1-0-22" id="h1-0-22" class="d">-        expressions: Expressions,
</a><a href="#h1-0-23" id="h1-0-23" class="i">+        expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a>     ) -&gt; Box&lt;Self&gt; {
<a href="#h1-0-25" id="h1-0-25" class="d">-        Box::new(Self { source, labels, expressions })
</a><a href="#h1-0-26" id="h1-0-26" class="i">+        Box::new(Self { source, expressions })
</a>     }
 }
 
 impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Projection&lt;T&gt; {
     fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
<a href="#h1-0-32" id="h1-0-32" class="d">-        match self.source.execute(txn)? {
</a><a href="#h1-0-33" id="h1-0-33" class="d">-            ResultSet::Query { columns, rows } =&gt; {
</a><a href="#h1-0-34" id="h1-0-34" class="d">-                let labels = self.labels;
</a><a href="#h1-0-35" id="h1-0-35" class="d">-                let columns = self
</a><a href="#h1-0-36" id="h1-0-36" class="d">-                    .expressions
</a><a href="#h1-0-37" id="h1-0-37" class="d">-                    .iter()
</a><a href="#h1-0-38" id="h1-0-38" class="d">-                    .enumerate()
</a><a href="#h1-0-39" id="h1-0-39" class="d">-                    .map(|(i, e)| {
</a><a href="#h1-0-40" id="h1-0-40" class="d">-                        Ok(if let Some(Some(label)) = labels.get(i) {
</a><a href="#h1-0-41" id="h1-0-41" class="d">-                            Column { name: Some(label.clone()) }
</a><a href="#h1-0-42" id="h1-0-42" class="d">-                        } else if let Expression::Field(i, _) = e {
</a><a href="#h1-0-43" id="h1-0-43" class="d">-                            columns[*i].clone()
</a><a href="#h1-0-44" id="h1-0-44" class="d">-                        } else {
</a><a href="#h1-0-45" id="h1-0-45" class="d">-                            Column { name: None }
</a><a href="#h1-0-46" id="h1-0-46" class="d">-                        })
</a><a href="#h1-0-47" id="h1-0-47" class="d">-                    })
</a><a href="#h1-0-48" id="h1-0-48" class="d">-                    .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h1-0-49" id="h1-0-49" class="d">-                let expressions = self.expressions;
</a><a href="#h1-0-50" id="h1-0-50" class="d">-                let rows = Box::new(rows.map(move |r| {
</a><a href="#h1-0-51" id="h1-0-51" class="d">-                    r.and_then(|row| {
</a><a href="#h1-0-52" id="h1-0-52" class="d">-                        Ok(expressions
</a><a href="#h1-0-53" id="h1-0-53" class="d">-                            .iter()
</a><a href="#h1-0-54" id="h1-0-54" class="d">-                            .map(|e| e.evaluate(Some(&amp;row)))
</a><a href="#h1-0-55" id="h1-0-55" class="d">-                            .collect::&lt;Result&lt;_&gt;&gt;()?)
</a><a href="#h1-0-56" id="h1-0-56" class="d">-                    })
</a><a href="#h1-0-57" id="h1-0-57" class="d">-                }));
</a><a href="#h1-0-58" id="h1-0-58" class="d">-                Ok(ResultSet::Query { columns, rows })
</a><a href="#h1-0-59" id="h1-0-59" class="d">-            }
</a><a href="#h1-0-60" id="h1-0-60" class="d">-            r =&gt; Err(Error::Internal(format!(&quot;Unexpected result {:?}&quot;, r))),
</a><a href="#h1-0-61" id="h1-0-61" class="i">+        if let ResultSet::Query { columns, rows } = self.source.execute(txn)? {
</a><a href="#h1-0-62" id="h1-0-62" class="i">+            let (expressions, labels): (Vec&lt;Expression&gt;, Vec&lt;Option&lt;String&gt;&gt;) =
</a><a href="#h1-0-63" id="h1-0-63" class="i">+                self.expressions.into_iter().unzip();
</a><a href="#h1-0-64" id="h1-0-64" class="i">+            let columns = expressions
</a><a href="#h1-0-65" id="h1-0-65" class="i">+                .iter()
</a><a href="#h1-0-66" id="h1-0-66" class="i">+                .enumerate()
</a><a href="#h1-0-67" id="h1-0-67" class="i">+                .map(|(i, e)| {
</a><a href="#h1-0-68" id="h1-0-68" class="i">+                    if let Some(Some(label)) = labels.get(i) {
</a><a href="#h1-0-69" id="h1-0-69" class="i">+                        Column { name: Some(label.clone()) }
</a><a href="#h1-0-70" id="h1-0-70" class="i">+                    } else if let Expression::Field(i, _) = e {
</a><a href="#h1-0-71" id="h1-0-71" class="i">+                        columns.get(*i).cloned().unwrap_or(Column { name: None })
</a><a href="#h1-0-72" id="h1-0-72" class="i">+                    } else {
</a><a href="#h1-0-73" id="h1-0-73" class="i">+                        Column { name: None }
</a><a href="#h1-0-74" id="h1-0-74" class="i">+                    }
</a><a href="#h1-0-75" id="h1-0-75" class="i">+                })
</a><a href="#h1-0-76" id="h1-0-76" class="i">+                .collect();
</a><a href="#h1-0-77" id="h1-0-77" class="i">+            let rows = Box::new(rows.map(move |r| {
</a><a href="#h1-0-78" id="h1-0-78" class="i">+                r.and_then(|row| {
</a><a href="#h1-0-79" id="h1-0-79" class="i">+                    Ok(expressions.iter().map(|e| e.evaluate(Some(&amp;row))).collect::&lt;Result&lt;_&gt;&gt;()?)
</a><a href="#h1-0-80" id="h1-0-80" class="i">+                })
</a><a href="#h1-0-81" id="h1-0-81" class="i">+            }));
</a><a href="#h1-0-82" id="h1-0-82" class="i">+            Ok(ResultSet::Query { columns, rows })
</a><a href="#h1-0-83" id="h1-0-83" class="i">+        } else {
</a><a href="#h1-0-84" id="h1-0-84" class="i">+            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a>         }
     }
 }
<b>diff --git a/<a id="h2" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -65,10 +65,7 @@ pub struct Column {
</a> /// A SELECT clause
 #[derive(Clone, Debug, PartialEq)]
 pub struct SelectClause {
<a href="#h2-0-3" id="h2-0-3" class="d">-    /// The expressions to select. Empty list means everything, i.e. *.
</a><a href="#h2-0-4" id="h2-0-4" class="d">-    pub expressions: Vec&lt;Expression&gt;,
</a><a href="#h2-0-5" id="h2-0-5" class="d">-    /// The expression labels, if any
</a><a href="#h2-0-6" id="h2-0-6" class="d">-    pub labels: Vec&lt;Option&lt;String&gt;&gt;,
</a><a href="#h2-0-7" id="h2-0-7" class="i">+    pub expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a> }
 
 /// A FROM clause
<b>diff --git a/<a id="h3" href="../file/src/sql/parser/mod.rs.html">src/sql/parser/mod.rs</a> b/<a href="../file/src/sql/parser/mod.rs.html">src/sql/parser/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -482,25 +482,26 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>         if self.next_if_token(Keyword::Select.into()).is_none() {
             return Ok(None);
         }
<a href="#h3-0-3" id="h3-0-3" class="d">-        let mut clause = ast::SelectClause { expressions: Vec::new(), labels: Vec::new() };
</a><a href="#h3-0-4" id="h3-0-4" class="i">+        let mut select = ast::SelectClause { expressions: Vec::new() };
</a>         loop {
<a href="#h3-0-6" id="h3-0-6" class="d">-            if self.next_if_token(Token::Asterisk).is_some() &amp;&amp; clause.expressions.is_empty() {
</a><a href="#h3-0-7" id="h3-0-7" class="i">+            if self.next_if_token(Token::Asterisk).is_some() &amp;&amp; select.expressions.is_empty() {
</a>                 break;
             }
<a href="#h3-0-10" id="h3-0-10" class="d">-            clause.expressions.push(self.parse_expression(0)?);
</a><a href="#h3-0-11" id="h3-0-11" class="d">-            clause.labels.push(match self.peek()? {
</a><a href="#h3-0-12" id="h3-0-12" class="i">+            let expr = self.parse_expression(0)?;
</a><a href="#h3-0-13" id="h3-0-13" class="i">+            let label = match self.peek()? {
</a>                 Some(Token::Keyword(Keyword::As)) =&gt; {
                     self.next()?;
                     Some(self.next_ident()?)
                 }
                 Some(Token::Ident(_)) =&gt; Some(self.next_ident()?),
                 _ =&gt; None,
<a href="#h3-0-20" id="h3-0-20" class="d">-            });
</a><a href="#h3-0-21" id="h3-0-21" class="i">+            };
</a><a href="#h3-0-22" id="h3-0-22" class="i">+            select.expressions.push((expr, label));
</a>             if self.next_if_token(Token::Comma).is_none() {
                 break;
             }
         }
<a href="#h3-0-27" id="h3-0-27" class="d">-        Ok(Some(clause))
</a><a href="#h3-0-28" id="h3-0-28" class="i">+        Ok(Some(select))
</a>     }
 
     /// Parses a WHERE clause
<b>diff --git a/<a id="h4" href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a> b/<a href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -18,18 +18,17 @@ use std::collections::BTreeMap;
</a> pub struct Plan(pub Node);
 
 impl Plan {
<a href="#h4-0-3" id="h4-0-3" class="d">-    /// Builds a plan from an AST statement
</a><a href="#h4-0-4" id="h4-0-4" class="d">-    /// FIXME Catalog should be generic, not trait object
</a><a href="#h4-0-5" id="h4-0-5" class="i">+    /// Builds a plan from an AST statement.
</a>     pub fn build&lt;C: Catalog&gt;(statement: ast::Statement, catalog: &amp;mut C) -&gt; Result&lt;Self&gt; {
         Planner::new(catalog).build(statement)
     }
 
<a href="#h4-0-10" id="h4-0-10" class="d">-    /// Executes the plan, consuming it
</a><a href="#h4-0-11" id="h4-0-11" class="i">+    /// Executes the plan, consuming it.
</a>     pub fn execute&lt;T: Transaction + &#39;static&gt;(self, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
         Executor::build(self.0).execute(txn)
     }
 
<a href="#h4-0-16" id="h4-0-16" class="d">-    /// Optimizes the plan, consuming it
</a><a href="#h4-0-17" id="h4-0-17" class="i">+    /// Optimizes the plan, consuming it.
</a>     pub fn optimize&lt;C: Catalog&gt;(self, catalog: &amp;mut C) -&gt; Result&lt;Self&gt; {
         let mut root = self.0;
         root = optimizer::ConstantFolder.optimize(root)?;
<a href="#h4-1" id="h4-1" class="h">@@ -98,8 +97,7 @@ pub enum Node {
</a>     },
     Projection {
         source: Box&lt;Node&gt;,
<a href="#h4-1-3" id="h4-1-3" class="d">-        labels: Vec&lt;Option&lt;String&gt;&gt;,
</a><a href="#h4-1-4" id="h4-1-4" class="d">-        expressions: Expressions,
</a><a href="#h4-1-5" id="h4-1-5" class="i">+        expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a>     },
     Scan {
         table: String,
<a href="#h4-2" id="h4-2" class="h">@@ -155,11 +153,9 @@ impl Node {
</a>             Self::Order { source, orders } =&gt; {
                 Self::Order { source: source.transform(pre, post)?.into(), orders }
             }
<a href="#h4-2-3" id="h4-2-3" class="d">-            Self::Projection { source, labels, expressions } =&gt; Self::Projection {
</a><a href="#h4-2-4" id="h4-2-4" class="d">-                source: source.transform(pre, post)?.into(),
</a><a href="#h4-2-5" id="h4-2-5" class="d">-                labels,
</a><a href="#h4-2-6" id="h4-2-6" class="d">-                expressions,
</a><a href="#h4-2-7" id="h4-2-7" class="d">-            },
</a><a href="#h4-2-8" id="h4-2-8" class="i">+            Self::Projection { source, expressions } =&gt; {
</a><a href="#h4-2-9" id="h4-2-9" class="i">+                Self::Projection { source: source.transform(pre, post)?.into(), expressions }
</a><a href="#h4-2-10" id="h4-2-10" class="i">+            }
</a>             Self::Update { table, source, expressions } =&gt; {
                 Self::Update { table, source: source.transform(pre, post)?.into(), expressions }
             }
<a href="#h4-3" id="h4-3" class="h">@@ -204,12 +200,11 @@ impl Node {
</a>                     .map(|(e, o)| e.transform(pre, post).map(|e| (e, o)))
                     .collect::&lt;Result&lt;_&gt;&gt;()?,
             },
<a href="#h4-3-3" id="h4-3-3" class="d">-            Self::Projection { source, labels, expressions } =&gt; Self::Projection {
</a><a href="#h4-3-4" id="h4-3-4" class="i">+            Self::Projection { source, expressions } =&gt; Self::Projection {
</a>                 source,
<a href="#h4-3-6" id="h4-3-6" class="d">-                labels,
</a>                 expressions: expressions
                     .into_iter()
<a href="#h4-3-9" id="h4-3-9" class="d">-                    .map(|e| e.transform(pre, post))
</a><a href="#h4-3-10" id="h4-3-10" class="i">+                    .map(|(e, l)| Ok((e.transform(pre, post)?, l)))
</a>                     .collect::&lt;Result&lt;_&gt;&gt;()?,
             },
             Self::Scan { table, alias, filter: Some(filter) } =&gt; {
<b>diff --git a/<a id="h5" href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a> b/<a href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,6 +1,6 @@
</a> use super::super::parser::ast;
 use super::super::schema::{Catalog, Column, Table};
<a href="#h5-0-2" id="h5-0-2" class="d">-use super::super::types::{Expression, Expressions, Value};
</a><a href="#h5-0-3" id="h5-0-3" class="i">+use super::super::types::{Expression, Value};
</a> use super::{Aggregate, Direction, Node, Plan};
 use crate::error::{Error, Result};
 
<a href="#h5-1" id="h5-1" class="h">@@ -91,7 +91,12 @@ impl&lt;&#39;a&gt; Planner&lt;&#39;a&gt; {
</a>                 columns: columns.unwrap_or_else(Vec::new),
                 expressions: values
                     .into_iter()
<a href="#h5-1-3" id="h5-1-3" class="d">-                    .map(|exprs| self.build_expressions(&amp;mut Scope::new(), exprs))
</a><a href="#h5-1-4" id="h5-1-4" class="i">+                    .map(|exprs| {
</a><a href="#h5-1-5" id="h5-1-5" class="i">+                        exprs
</a><a href="#h5-1-6" id="h5-1-6" class="i">+                            .into_iter()
</a><a href="#h5-1-7" id="h5-1-7" class="i">+                            .map(|expr| self.build_expression(&amp;mut Scope::constant(), expr))
</a><a href="#h5-1-8" id="h5-1-8" class="i">+                            .collect::&lt;Result&lt;_&gt;&gt;()
</a><a href="#h5-1-9" id="h5-1-9" class="i">+                    })
</a>                     .collect::&lt;Result&lt;_&gt;&gt;()?,
             },
 
<a href="#h5-2" id="h5-2" class="h">@@ -148,7 +153,7 @@ impl&lt;&#39;a&gt; Planner&lt;&#39;a&gt; {
</a> 
                 // Build SELECT clause.
                 if !select.expressions.is_empty() {
<a href="#h5-2-3" id="h5-2-3" class="d">-                    let mut exprs = select.expressions.clone(); // FIXME No need to clone
</a><a href="#h5-2-4" id="h5-2-4" class="i">+                    let mut exprs = select.expressions;
</a> 
                     // Extract any aggregate functions and GROUP BY expressions, replacing them with
                     // Column placeholders. Aggregations are handled by evaluating group expressions
<a href="#h5-3" id="h5-3" class="h">@@ -157,7 +162,7 @@ impl&lt;&#39;a&gt; Planner&lt;&#39;a&gt; {
</a>                     // in the post-projection. See build_aggregates() for details.
                     let aggregates = self.extract_aggregates(&amp;mut exprs)?;
                     let groups = if let Some(ast::GroupByClause(group_by)) = group_by {
<a href="#h5-3-3" id="h5-3-3" class="d">-                        self.extract_groups(&amp;mut exprs, &amp;select.labels, group_by, aggregates.len())?
</a><a href="#h5-3-4" id="h5-3-4" class="i">+                        self.extract_groups(&amp;mut exprs, group_by, aggregates.len())?
</a>                     } else {
                         Vec::new()
                     };
<a href="#h5-4" id="h5-4" class="h">@@ -166,15 +171,12 @@ impl&lt;&#39;a&gt; Planner&lt;&#39;a&gt; {
</a>                     }
 
                     // Build the remaining non-aggregate projection.
<a href="#h5-4-3" id="h5-4-3" class="d">-                    let exprs = self.build_expressions(scope, exprs)?;
</a><a href="#h5-4-4" id="h5-4-4" class="d">-                    scope.project(
</a><a href="#h5-4-5" id="h5-4-5" class="d">-                        exprs.iter().cloned().zip(select.labels.iter().cloned()).collect(),
</a><a href="#h5-4-6" id="h5-4-6" class="d">-                    )?;
</a><a href="#h5-4-7" id="h5-4-7" class="d">-                    node = Node::Projection {
</a><a href="#h5-4-8" id="h5-4-8" class="d">-                        source: Box::new(node),
</a><a href="#h5-4-9" id="h5-4-9" class="d">-                        labels: select.labels,
</a><a href="#h5-4-10" id="h5-4-10" class="d">-                        expressions: exprs,
</a><a href="#h5-4-11" id="h5-4-11" class="d">-                    };
</a><a href="#h5-4-12" id="h5-4-12" class="i">+                    let expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt; = exprs
</a><a href="#h5-4-13" id="h5-4-13" class="i">+                        .into_iter()
</a><a href="#h5-4-14" id="h5-4-14" class="i">+                        .map(|(e, l)| Ok((self.build_expression(scope, e)?, l)))
</a><a href="#h5-4-15" id="h5-4-15" class="i">+                        .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h5-4-16" id="h5-4-16" class="i">+                    scope.project(expressions.clone())?;
</a><a href="#h5-4-17" id="h5-4-17" class="i">+                    node = Node::Projection { source: Box::new(node), expressions };
</a>                 };
 
                 // Build HAVING clause.
<a href="#h5-5" id="h5-5" class="h">@@ -308,21 +310,18 @@ impl&lt;&#39;a&gt; Planner&lt;&#39;a&gt; {
</a>     ) -&gt; Result&lt;Node&gt; {
         let mut aggregates = Vec::new();
         let mut expressions = Vec::new();
<a href="#h5-5-3" id="h5-5-3" class="d">-        let mut labels = Vec::new();
</a>         for (aggregate, expr) in aggregations {
             aggregates.push(aggregate);
<a href="#h5-5-6" id="h5-5-6" class="d">-            expressions.push(self.build_expression(scope, expr)?);
</a><a href="#h5-5-7" id="h5-5-7" class="d">-            labels.push(None);
</a><a href="#h5-5-8" id="h5-5-8" class="i">+            expressions.push((self.build_expression(scope, expr)?, None));
</a>         }
         for (expr, label) in groups {
<a href="#h5-5-11" id="h5-5-11" class="d">-            expressions.push(self.build_expression(scope, expr)?);
</a><a href="#h5-5-12" id="h5-5-12" class="d">-            labels.push(label);
</a><a href="#h5-5-13" id="h5-5-13" class="i">+            expressions.push((self.build_expression(scope, expr)?, label));
</a>         }
         // FIXME This is probably wrong for the aggregate columns, since we don&#39;t want to inherit
         // from them if they are simple field references.
<a href="#h5-5-17" id="h5-5-17" class="d">-        scope.project(expressions.iter().cloned().zip(labels.iter().cloned()).collect())?;
</a><a href="#h5-5-18" id="h5-5-18" class="i">+        scope.project(expressions.clone())?;
</a>         let node = Node::Aggregation {
<a href="#h5-5-20" id="h5-5-20" class="d">-            source: Box::new(Node::Projection { source: Box::new(source), labels, expressions }),
</a><a href="#h5-5-21" id="h5-5-21" class="i">+            source: Box::new(Node::Projection { source: Box::new(source), expressions }),
</a>             aggregates,
         };
         Ok(node)
<a href="#h5-6" id="h5-6" class="h">@@ -333,10 +332,10 @@ impl&lt;&#39;a&gt; Planner&lt;&#39;a&gt; {
</a>     /// to aggregates, and returns them along with their argument expressions.
     fn extract_aggregates(
         &amp;self,
<a href="#h5-6-3" id="h5-6-3" class="d">-        exprs: &amp;mut [ast::Expression],
</a><a href="#h5-6-4" id="h5-6-4" class="i">+        exprs: &amp;mut [(ast::Expression, Option&lt;String&gt;)],
</a>     ) -&gt; Result&lt;Vec&lt;(Aggregate, ast::Expression)&gt;&gt; {
         let mut aggregates = Vec::new();
<a href="#h5-6-7" id="h5-6-7" class="d">-        for expr in exprs {
</a><a href="#h5-6-8" id="h5-6-8" class="i">+        for (expr, _) in exprs {
</a>             expr.replace_with(|e| {
                 e.transform(
                     &amp;mut |mut e| match &amp;mut e {
<a href="#h5-7" id="h5-7" class="h">@@ -369,33 +368,29 @@ impl&lt;&#39;a&gt; Planner&lt;&#39;a&gt; {
</a>     /// SELECT released / 100 AS century, COUNT(*) FROM movies GROUP BY century
     /// SELECT released / 100, COUNT(*) FROM movies GROUP BY released / 100
     /// SELECT COUNT(*) FROM movies GROUP BY released / 100
<a href="#h5-7-3" id="h5-7-3" class="d">-    ///
</a><a href="#h5-7-4" id="h5-7-4" class="d">-    /// FIXME Perhaps put labels and expressions in common structure, and add new type for labels.
</a>     fn extract_groups(
         &amp;self,
<a href="#h5-7-7" id="h5-7-7" class="d">-        exprs: &amp;mut Vec&lt;ast::Expression&gt;,
</a><a href="#h5-7-8" id="h5-7-8" class="d">-        labels: &amp;[Option&lt;String&gt;],
</a><a href="#h5-7-9" id="h5-7-9" class="i">+        exprs: &amp;mut Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a>         group_by: Vec&lt;ast::Expression&gt;,
         offset: usize,
     ) -&gt; Result&lt;Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;&gt; {
<a href="#h5-7-13" id="h5-7-13" class="d">-        let labels = labels.to_vec(); // FIXME Avoid this
</a>         let mut groups = Vec::new();
         for g in group_by {
             // Look for references to SELECT columns with AS labels
             if let ast::Expression::Field(None, label) = &amp;g {
<a href="#h5-7-18" id="h5-7-18" class="d">-                if let Some(i) = labels.iter().position(|l| l.as_deref() == Some(label)) {
</a><a href="#h5-7-19" id="h5-7-19" class="i">+                if let Some(i) = exprs.iter().position(|(_, l)| l.as_deref() == Some(label)) {
</a>                     groups.push((
<a href="#h5-7-21" id="h5-7-21" class="d">-                        replace(&amp;mut exprs[i], ast::Expression::Column(offset + groups.len())),
</a><a href="#h5-7-22" id="h5-7-22" class="d">-                        labels[i].clone(),
</a><a href="#h5-7-23" id="h5-7-23" class="i">+                        replace(&amp;mut exprs[i].0, ast::Expression::Column(offset + groups.len())),
</a><a href="#h5-7-24" id="h5-7-24" class="i">+                        exprs[i].1.clone(),
</a>                     ));
                     continue;
                 }
             }
             // Look for expressions exactly equal to the group expression
<a href="#h5-7-30" id="h5-7-30" class="d">-            if let Some(i) = exprs.iter().position(|e| e == &amp;g) {
</a><a href="#h5-7-31" id="h5-7-31" class="i">+            if let Some(i) = exprs.iter().position(|(e, _)| e == &amp;g) {
</a>                 groups.push((
<a href="#h5-7-33" id="h5-7-33" class="d">-                    replace(&amp;mut exprs[i], ast::Expression::Column(offset + groups.len())),
</a><a href="#h5-7-34" id="h5-7-34" class="d">-                    labels[i].clone(),
</a><a href="#h5-7-35" id="h5-7-35" class="i">+                    replace(&amp;mut exprs[i].0, ast::Expression::Column(offset + groups.len())),
</a><a href="#h5-7-36" id="h5-7-36" class="i">+                    exprs[i].1.clone(),
</a>                 ));
                 continue;
             }
<a href="#h5-8" id="h5-8" class="h">@@ -544,11 +539,6 @@ impl&lt;&#39;a&gt; Planner&lt;&#39;a&gt; {
</a>         })
     }
 
<a href="#h5-8-3" id="h5-8-3" class="d">-    /// Builds expressions from AST expressions
</a><a href="#h5-8-4" id="h5-8-4" class="d">-    fn build_expressions(&amp;self, scope: &amp;mut Scope, exprs: ast::Expressions) -&gt; Result&lt;Expressions&gt; {
</a><a href="#h5-8-5" id="h5-8-5" class="d">-        exprs.into_iter().map(|e| self.build_expression(scope, e)).collect()
</a><a href="#h5-8-6" id="h5-8-6" class="d">-    }
</a><a href="#h5-8-7" id="h5-8-7" class="d">-
</a>     /// Builds and evaluates a constant AST expression.
     fn evaluate_constant(&amp;self, expr: ast::Expression) -&gt; Result&lt;Value&gt; {
         self.build_expression(&amp;mut Scope::constant(), expr)?.evaluate(None)
</pre>
</div>
</body>
</html>
