<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>error: remove `Error::Assert`, use panic - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/e1c3d9add0bfa3e055bf05893d7e9bd8b4060639.html">e1c3d9add0bfa3e055bf05893d7e9bd8b4060639</a>
<b>parent</b> <a href="../commit/bf3204405f3b496755ff8836fd9c1293a4cd3623.html">bf3204405f3b496755ff8836fd9c1293a4cd3623</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Fri,  7 Jun 2024 19:42:16 +0200

error: remove `Error::Assert`, use panic

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/encoding/keycode.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/error.rs</a></td><td> | </td><td class="num">28</td><td><span class="i">+++</span><span class="d">-------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/log.rs</a></td><td> | </td><td class="num">33</td><td><span class="i">++++++++++++++++</span><span class="d">-----------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/node.rs</a></td><td> | </td><td class="num">3</td><td><span class="i">+</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/testscripts/log/append</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/raft/testscripts/log/commit</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/raft/testscripts/log/splice</a></td><td> | </td><td class="num">20</td><td><span class="i">++++++++++</span><span class="d">----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/raft/testscripts/log/term</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/sql/plan/planner.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++</span><span class="d">------</span></td></tr>
</table></pre><pre>9 files changed, 49 insertions(+), 73 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/encoding/keycode.rs.html">src/encoding/keycode.rs</a> b/<a href="../file/src/encoding/keycode.rs.html">src/encoding/keycode.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -47,8 +47,8 @@
</a> use de::IntoDeserializer;
 use serde::{de, ser};
 
<a href="#h0-0-3" id="h0-0-3" class="i">+use crate::errdata;
</a> use crate::error::{Error, Result};
<a href="#h0-0-5" id="h0-0-5" class="d">-use crate::{errassert, errdata};
</a> 
 // Serializes a key to a binary KeyCode representation.
 pub fn serialize&lt;T: serde::Serialize&gt;(key: &amp;T) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
<a href="#h0-1" id="h0-1" class="h">@@ -365,7 +365,7 @@ impl&lt;&#39;de, &#39;a&gt; serde::Deserializer&lt;&#39;de&gt; for &amp;&#39;a mut Deserializer&lt;&#39;de&gt; {
</a>     type Error = Error;
 
     fn deserialize_any&lt;V: de::Visitor&lt;&#39;de&gt;&gt;(self, _: V) -&gt; Result&lt;V::Value&gt; {
<a href="#h0-1-3" id="h0-1-3" class="d">-        errassert!(&quot;must provide type, KeyCode is not self-describing&quot;)
</a><a href="#h0-1-4" id="h0-1-4" class="i">+        panic!(&quot;must provide type, KeyCode is not self-describing&quot;)
</a>     }
 
     fn deserialize_bool&lt;V: de::Visitor&lt;&#39;de&gt;&gt;(self, visitor: V) -&gt; Result&lt;V::Value&gt; {
<b>diff --git a/<a id="h1" href="../file/src/error.rs.html">src/error.rs</a> b/<a href="../file/src/error.rs.html">src/error.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -6,9 +6,6 @@ pub enum Error {
</a>     /// The operation was aborted and must be retried. This typically happens
     /// with e.g. Raft leader changes.
     Abort,
<a href="#h1-0-3" id="h1-0-3" class="d">-    /// An assertion failure. Should never happen.
</a><a href="#h1-0-4" id="h1-0-4" class="d">-    /// TODO: include backtrace.
</a><a href="#h1-0-5" id="h1-0-5" class="d">-    Assert(String),
</a>     /// Invalid data, typically decoding errors or unexpected internal values.
     InvalidData(String),
     /// Invalid user input, typically parser or query errors.
<a href="#h1-1" id="h1-1" class="h">@@ -28,7 +25,6 @@ impl std::fmt::Display for Error {
</a>     fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
         match self {
             Error::Abort =&gt; write!(f, &quot;operation aborted&quot;),
<a href="#h1-1-3" id="h1-1-3" class="d">-            Error::Assert(msg) =&gt; write!(f, &quot;assertion failed: {msg}&quot;),
</a>             Error::InvalidData(msg) =&gt; write!(f, &quot;invalid data: {msg}&quot;),
             Error::InvalidInput(msg) =&gt; write!(f, &quot;invalid input: {msg}&quot;),
             Error::IO(msg) =&gt; write!(f, &quot;io error: {msg}&quot;),
<a href="#h1-2" id="h1-2" class="h">@@ -48,9 +44,6 @@ impl Error {
</a>         match self {
             // Aborts don&#39;t happen during application, only leader changes.
             Error::Abort =&gt; true,
<a href="#h1-2-3" id="h1-2-3" class="d">-            // Assertion failures typically indicate invariant violations or
</a><a href="#h1-2-4" id="h1-2-4" class="d">-            // data corruption, so we should assume it&#39;s unsafe to continue.
</a><a href="#h1-2-5" id="h1-2-5" class="d">-            Error::Assert(_) =&gt; false,
</a>             // Possible data corruption local to this node.
             Error::InvalidData(_) =&gt; false,
             // Input errors are (likely) deterministic. We could employ command
<a href="#h1-3" id="h1-3" class="h">@@ -66,12 +59,6 @@ impl Error {
</a>     }
 }
 
<a href="#h1-3-3" id="h1-3-3" class="d">-/// Constructs an Error::Assert via format!() and into().
</a><a href="#h1-3-4" id="h1-3-4" class="d">-#[macro_export]
</a><a href="#h1-3-5" id="h1-3-5" class="d">-macro_rules! errassert {
</a><a href="#h1-3-6" id="h1-3-6" class="d">-    ($($args:tt)*) =&gt; { $crate::error::Error::Assert(format!($($args)*)).into() };
</a><a href="#h1-3-7" id="h1-3-7" class="d">-}
</a><a href="#h1-3-8" id="h1-3-8" class="d">-
</a> /// Constructs an Error::InvalidData via format!() and into().
 #[macro_export]
 macro_rules! errdata {
<a href="#h1-4" id="h1-4" class="h">@@ -84,15 +71,6 @@ macro_rules! errinput {
</a>     ($($args:tt)*) =&gt; { $crate::error::Error::InvalidInput(format!($($args)*)).into() };
 }
 
<a href="#h1-4-3" id="h1-4-3" class="d">-/// Returns an Error::Assert if the given condition is false.
</a><a href="#h1-4-4" id="h1-4-4" class="d">-/// TODO: use this instead of assert! where appropriate.
</a><a href="#h1-4-5" id="h1-4-5" class="d">-#[macro_export]
</a><a href="#h1-4-6" id="h1-4-6" class="d">-macro_rules! asserterr {
</a><a href="#h1-4-7" id="h1-4-7" class="d">-    ($cond:expr, $($args:tt)*) =&gt; {
</a><a href="#h1-4-8" id="h1-4-8" class="d">-        if !$cond { return errassert!($($args)*) }
</a><a href="#h1-4-9" id="h1-4-9" class="d">-    };
</a><a href="#h1-4-10" id="h1-4-10" class="d">-}
</a><a href="#h1-4-11" id="h1-4-11" class="d">-
</a> /// Result returning Error.
 pub type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;
 
<a href="#h1-5" id="h1-5" class="h">@@ -152,7 +130,7 @@ impl&lt;T&gt; From&lt;crossbeam::channel::TrySendError&lt;T&gt;&gt; for Error {
</a> 
 impl From&lt;hdrhistogram::CreationError&gt; for Error {
     fn from(err: hdrhistogram::CreationError) -&gt; Self {
<a href="#h1-5-3" id="h1-5-3" class="d">-        Error::Assert(err.to_string())
</a><a href="#h1-5-4" id="h1-5-4" class="i">+        panic!(&quot;{err}&quot;)
</a>     }
 }
 
<a href="#h1-6" id="h1-6" class="h">@@ -170,13 +148,13 @@ impl From&lt;log::ParseLevelError&gt; for Error {
</a> 
 impl From&lt;log::SetLoggerError&gt; for Error {
     fn from(err: log::SetLoggerError) -&gt; Self {
<a href="#h1-6-3" id="h1-6-3" class="d">-        Error::Assert(err.to_string())
</a><a href="#h1-6-4" id="h1-6-4" class="i">+        panic!(&quot;{err}&quot;)
</a>     }
 }
 
 impl From&lt;regex::Error&gt; for Error {
     fn from(err: regex::Error) -&gt; Self {
<a href="#h1-6-10" id="h1-6-10" class="d">-        Error::Assert(err.to_string())
</a><a href="#h1-6-11" id="h1-6-11" class="i">+        panic!(&quot;{err}&quot;)
</a>     }
 }
 
<b>diff --git a/<a id="h2" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -2,7 +2,6 @@ use super::{NodeID, Term};
</a> use crate::encoding::{self, bincode, Key as _, Value as _};
 use crate::error::Result;
 use crate::storage;
<a href="#h2-0-3" id="h2-0-3" class="d">-use crate::{asserterr, errassert};
</a> 
 use serde::{Deserialize, Serialize};
 
<a href="#h2-1" id="h2-1" class="h">@@ -148,12 +147,12 @@ impl Log {
</a>     /// term does not regress, and that we only vote for one node in a term.
     pub fn set_term(&amp;mut self, term: Term, vote: Option&lt;NodeID&gt;) -&gt; Result&lt;()&gt; {
         match self.get_term()? {
<a href="#h2-1-3" id="h2-1-3" class="d">-            (t, _) if term &lt; t =&gt; return errassert!(&quot;term regression {t} → {term}&quot;),
</a><a href="#h2-1-4" id="h2-1-4" class="i">+            (t, _) if term &lt; t =&gt; panic!(&quot;term regression {t} → {term}&quot;),
</a>             (t, _) if term &gt; t =&gt; {} // below, term == t
<a href="#h2-1-6" id="h2-1-6" class="d">-            (0, _) =&gt; return errassert!(&quot;can&#39;t set term 0&quot;),
</a><a href="#h2-1-7" id="h2-1-7" class="i">+            (0, _) =&gt; panic!(&quot;can&#39;t set term 0&quot;),
</a>             (t, v) if t == term &amp;&amp; v == vote =&gt; return Ok(()),
             (_, None) =&gt; {}
<a href="#h2-1-10" id="h2-1-10" class="d">-            (_, v) if vote != v =&gt; return errassert!(&quot;can&#39;t change vote {v:?} → {vote:?}&quot;),
</a><a href="#h2-1-11" id="h2-1-11" class="i">+            (_, v) if vote != v =&gt; panic!(&quot;can&#39;t change vote {v:?} → {vote:?}&quot;),
</a>             (_, _) =&gt; {}
         };
         self.engine.set(&amp;Key::TermVote.encode()?, bincode::serialize(&amp;(term, vote))?)?;
<a href="#h2-2" id="h2-2" class="h">@@ -166,9 +165,9 @@ impl Log {
</a>     /// The term must be equal to or greater than the previous entry.
     pub fn append(&amp;mut self, term: Term, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;Index&gt; {
         match self.get(self.last_index)? {
<a href="#h2-2-3" id="h2-2-3" class="d">-            Some(e) if term &lt; e.term =&gt; return errassert!(&quot;term regression {} → {term}&quot;, e.term),
</a><a href="#h2-2-4" id="h2-2-4" class="d">-            None if self.last_index &gt; 0 =&gt; return errassert!(&quot;log gap at {}&quot;, self.last_index),
</a><a href="#h2-2-5" id="h2-2-5" class="d">-            None if term == 0 =&gt; return errassert!(&quot;can&#39;t append entry with term 0&quot;),
</a><a href="#h2-2-6" id="h2-2-6" class="i">+            Some(e) if term &lt; e.term =&gt; panic!(&quot;term regression {} → {term}&quot;, e.term),
</a><a href="#h2-2-7" id="h2-2-7" class="i">+            None if self.last_index &gt; 0 =&gt; panic!(&quot;log gap at {}&quot;, self.last_index),
</a><a href="#h2-2-8" id="h2-2-8" class="i">+            None if term == 0 =&gt; panic!(&quot;can&#39;t append entry with term 0&quot;),
</a>             Some(_) | None =&gt; {}
         }
         // We could omit the index in the encoded value, since it&#39;s also stored
<a href="#h2-3" id="h2-3" class="h">@@ -186,11 +185,11 @@ impl Log {
</a>     pub fn commit(&amp;mut self, index: Index) -&gt; Result&lt;Index&gt; {
         let term = match self.get(index)? {
             Some(e) if e.index &lt; self.commit_index =&gt; {
<a href="#h2-3-3" id="h2-3-3" class="d">-                return errassert!(&quot;commit index regression {} → {}&quot;, self.commit_index, e.index);
</a><a href="#h2-3-4" id="h2-3-4" class="i">+                panic!(&quot;commit index regression {} → {}&quot;, self.commit_index, e.index);
</a>             }
             Some(e) if e.index == self.commit_index =&gt; return Ok(index),
             Some(e) =&gt; e.term,
<a href="#h2-3-8" id="h2-3-8" class="d">-            None =&gt; return errassert!(&quot;commit index {index} does not exist&quot;),
</a><a href="#h2-3-9" id="h2-3-9" class="i">+            None =&gt; panic!(&quot;commit index {index} does not exist&quot;),
</a>         };
         self.engine.set(&amp;Key::CommitIndex.encode()?, bincode::serialize(&amp;(index, term))?)?;
         // NB: the commit index doesn&#39;t need to be fsynced, since the entries
<a href="#h2-4" id="h2-4" class="h">@@ -251,24 +250,24 @@ impl Log {
</a> 
         // Check that the entries are well-formed.
         if first.index == 0 || first.term == 0 {
<a href="#h2-4-3" id="h2-4-3" class="d">-            return errassert!(&quot;spliced entry has index or term 0&quot;);
</a><a href="#h2-4-4" id="h2-4-4" class="i">+            panic!(&quot;spliced entry has index or term 0&quot;);
</a>         }
         if !entries.windows(2).all(|w| w[0].index + 1 == w[1].index) {
<a href="#h2-4-7" id="h2-4-7" class="d">-            return errassert!(&quot;spliced entries are not contiguous&quot;);
</a><a href="#h2-4-8" id="h2-4-8" class="i">+            panic!(&quot;spliced entries are not contiguous&quot;);
</a>         }
         if !entries.windows(2).all(|w| w[0].term &lt;= w[1].term) {
<a href="#h2-4-11" id="h2-4-11" class="d">-            return errassert!(&quot;spliced entries have term regression&quot;);
</a><a href="#h2-4-12" id="h2-4-12" class="i">+            panic!(&quot;spliced entries have term regression&quot;);
</a>         }
 
         // Check that the entries connect to the existing log (if any), and that the
         // term doesn&#39;t regress.
         match self.get(first.index - 1)? {
             Some(base) if first.term &lt; base.term =&gt; {
<a href="#h2-4-19" id="h2-4-19" class="d">-                return errassert!(&quot;splice term regression {} → {}&quot;, base.term, first.term)
</a><a href="#h2-4-20" id="h2-4-20" class="i">+                panic!(&quot;splice term regression {} → {}&quot;, base.term, first.term)
</a>             }
             Some(_) =&gt; {}
             None if first.index == 1 =&gt; {}
<a href="#h2-4-24" id="h2-4-24" class="d">-            None =&gt; return errassert!(&quot;first index {} must touch existing log&quot;, first.index),
</a><a href="#h2-4-25" id="h2-4-25" class="i">+            None =&gt; panic!(&quot;first index {} must touch existing log&quot;, first.index),
</a>         }
 
         // Skip entries that are already in the log.
<a href="#h2-5" id="h2-5" class="h">@@ -276,11 +275,11 @@ impl Log {
</a>         let mut scan = self.scan(first.index..=last.index)?;
         while let Some(entry) = scan.next().transpose()? {
             // [0] is ok, because the scan has the same size as entries.
<a href="#h2-5-3" id="h2-5-3" class="d">-            asserterr!(entry.index == entries[0].index, &quot;index mismatch at {entry:?}&quot;);
</a><a href="#h2-5-4" id="h2-5-4" class="i">+            assert!(entry.index == entries[0].index, &quot;index mismatch at {entry:?}&quot;);
</a>             if entry.term != entries[0].term {
                 break;
             }
<a href="#h2-5-8" id="h2-5-8" class="d">-            asserterr!(entry.command == entries[0].command, &quot;command mismatch at {entry:?}&quot;);
</a><a href="#h2-5-9" id="h2-5-9" class="i">+            assert!(entry.command == entries[0].command, &quot;command mismatch at {entry:?}&quot;);
</a>             entries = &amp;entries[1..];
         }
         drop(scan);
<a href="#h2-6" id="h2-6" class="h">@@ -293,7 +292,7 @@ impl Log {
</a>         // Write the entries that weren&#39;t already in the log, and remove the
         // tail of the old log if any. We can&#39;t write below the commit index,
         // since these entries must be immutable.
<a href="#h2-6-3" id="h2-6-3" class="d">-        asserterr!(first.index &gt; self.commit_index, &quot;spliced entries below commit index&quot;);
</a><a href="#h2-6-4" id="h2-6-4" class="i">+        assert!(first.index &gt; self.commit_index, &quot;spliced entries below commit index&quot;);
</a> 
         for entry in entries {
             self.engine.set(&amp;Key::Entry(entry.index).encode()?, entry.encode()?)?;
<b>diff --git a/<a id="h3" href="../file/src/raft/node.rs.html">src/raft/node.rs</a> b/<a href="../file/src/raft/node.rs.html">src/raft/node.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1228,7 +1228,6 @@ fn quorum_value&lt;T: Ord + Copy&gt;(mut values: Vec&lt;T&gt;) -&gt; T {
</a> mod tests {
     use super::*;
     use crate::encoding::{self, bincode, Value as _};
<a href="#h3-0-3" id="h3-0-3" class="d">-    use crate::errassert;
</a>     use crate::raft::{
         Entry, Request, RequestID, Response, ELECTION_TIMEOUT_RANGE, HEARTBEAT_INTERVAL,
         MAX_APPEND_ENTRIES,
<a href="#h3-1" id="h3-1" class="h">@@ -1478,7 +1477,7 @@ mod tests {
</a>                     Ok(node.into())
                 }
                 Node::Follower(node) =&gt; Ok(node.into_candidate()?.into()),
<a href="#h3-1-3" id="h3-1-3" class="d">-                Node::Leader(node) =&gt; errassert!(&quot;{} is a leader&quot;, node.id),
</a><a href="#h3-1-4" id="h3-1-4" class="i">+                Node::Leader(node) =&gt; panic!(&quot;{} is a leader&quot;, node.id),
</a>             };
             for id in ids.iter().copied() {
                 self.transition(id, campaign, output)?;
<b>diff --git a/<a id="h4" href="../file/src/raft/testscripts/log/append.html">src/raft/testscripts/log/append</a> b/<a href="../file/src/raft/testscripts/log/append.html">src/raft/testscripts/log/append</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -1,7 +1,7 @@
</a> # Appending an entry with term 0 fails, even on an empty log.
 !append 0 foo
 ---
<a href="#h4-0-3" id="h4-0-3" class="d">-Error: assertion failed: can&#39;t append entry with term 0
</a><a href="#h4-0-4" id="h4-0-4" class="i">+Panic: can&#39;t append entry with term 0
</a> 
 # Appending to an empty log works. The term doesn&#39;t have to be 1, and doesn&#39;t
 # have to match get_term(). The entry is written to the engine and flushed
<a href="#h4-1" id="h4-1" class="h">@@ -43,8 +43,8 @@ append → 4@5 None
</a> !append 4 old
 !append 0
 ---
<a href="#h4-1-3" id="h4-1-3" class="d">-Error: assertion failed: term regression 5 → 4
</a><a href="#h4-1-4" id="h4-1-4" class="d">-Error: assertion failed: term regression 5 → 0
</a><a href="#h4-1-5" id="h4-1-5" class="i">+Panic: term regression 5 → 4
</a><a href="#h4-1-6" id="h4-1-6" class="i">+Panic: term regression 5 → 0
</a> 
 # Dump the final status and data.
 status
<b>diff --git a/<a id="h5" href="../file/src/raft/testscripts/log/commit.html">src/raft/testscripts/log/commit</a> b/<a href="../file/src/raft/testscripts/log/commit.html">src/raft/testscripts/log/commit</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,7 +1,7 @@
</a> # Committing fails on an empty engine.
 !commit 1
 ---
<a href="#h5-0-3" id="h5-0-3" class="d">-Error: assertion failed: commit index 1 does not exist
</a><a href="#h5-0-4" id="h5-0-4" class="i">+Panic: commit index 1 does not exist
</a> 
 # Add some entries.
 splice 1@1= 2@1=foo 3@2=bar
<a href="#h5-1" id="h5-1" class="h">@@ -11,7 +11,7 @@ splice → 3@2 bar
</a> # Committing entry 0 fails.
 !commit 0
 ---
<a href="#h5-1-3" id="h5-1-3" class="d">-Error: assertion failed: commit index 0 does not exist
</a><a href="#h5-1-4" id="h5-1-4" class="i">+Panic: commit index 0 does not exist
</a> 
 # Committing entry 1 works, and updates the commit index.
 #
<a href="#h5-2" id="h5-2" class="h">@@ -50,14 +50,14 @@ last=3@2 commit=3@2
</a> !commit 2
 status
 ---
<a href="#h5-2-3" id="h5-2-3" class="d">-Error: assertion failed: commit index regression 3 → 2
</a><a href="#h5-2-4" id="h5-2-4" class="i">+Panic: commit index regression 3 → 2
</a> last=3@2 commit=3@2
 
 # Committing non-existant indexes error.
 !commit 4
 status
 ---
<a href="#h5-2-11" id="h5-2-11" class="d">-Error: assertion failed: commit index 4 does not exist
</a><a href="#h5-2-12" id="h5-2-12" class="i">+Panic: commit index 4 does not exist
</a> last=3@2 commit=3@2
 
 # Dump the raw values.
<b>diff --git a/<a id="h6" href="../file/src/raft/testscripts/log/splice.html">src/raft/testscripts/log/splice</a> b/<a href="../file/src/raft/testscripts/log/splice.html">src/raft/testscripts/log/splice</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,12 +1,12 @@
</a> # Splicing at index 0 should fail.
 !splice 0@1=foo
 ---
<a href="#h6-0-3" id="h6-0-3" class="d">-Error: assertion failed: spliced entry has index or term 0
</a><a href="#h6-0-4" id="h6-0-4" class="i">+Panic: spliced entry has index or term 0
</a> 
 # Splicing at index 2 should fail (creates gap).
 !splice 2@1=foo
 ---
<a href="#h6-0-9" id="h6-0-9" class="d">-Error: assertion failed: first index 2 must touch existing log
</a><a href="#h6-0-10" id="h6-0-10" class="i">+Panic: first index 2 must touch existing log
</a> 
 # Splicing entries at start should work, both with and without commands, and
 # starting at a term after 1. They should be written to the engine and flushed
<a href="#h6-1" id="h6-1" class="h">@@ -36,27 +36,27 @@ last=2@2 commit=0@0
</a> # Splicing multiple duplicate entries should fail.
 !splice 3@2= 3@2=
 ---
<a href="#h6-1-3" id="h6-1-3" class="d">-Error: assertion failed: spliced entries are not contiguous
</a><a href="#h6-1-4" id="h6-1-4" class="i">+Panic: spliced entries are not contiguous
</a> 
 # Splicing entries with a gap should fail.
 !splice 3@2= 5@2=
 ---
<a href="#h6-1-9" id="h6-1-9" class="d">-Error: assertion failed: spliced entries are not contiguous
</a><a href="#h6-1-10" id="h6-1-10" class="i">+Panic: spliced entries are not contiguous
</a> 
 # Splicing entries with a term regression should fail.
 !splice 3@2= 4@1=
 ---
<a href="#h6-1-15" id="h6-1-15" class="d">-Error: assertion failed: spliced entries have term regression
</a><a href="#h6-1-16" id="h6-1-16" class="i">+Panic: spliced entries have term regression
</a> 
 # Splicing entries with a gap from the base should fail.
 !splice 4@2=
 ---
<a href="#h6-1-21" id="h6-1-21" class="d">-Error: assertion failed: first index 4 must touch existing log
</a><a href="#h6-1-22" id="h6-1-22" class="i">+Panic: first index 4 must touch existing log
</a> 
 # Splicing with a term regression from the base should fail.
 !splice 3@1=
 ---
<a href="#h6-1-27" id="h6-1-27" class="d">-Error: assertion failed: splice term regression 2 → 1
</a><a href="#h6-1-28" id="h6-1-28" class="i">+Panic: splice term regression 2 → 1
</a> 
 # Fully overlapping entries is a noop.
 splice 1@2= 2@2=command oplog=true
<a href="#h6-2" id="h6-2" class="h">@@ -86,7 +86,7 @@ splice → 2@2 command
</a> !splice 2@2=foo
 scan
 ---
<a href="#h6-2-3" id="h6-2-3" class="d">-Error: assertion failed: command mismatch at Entry { index: 2, term: 2, command: Some([99, 111, 109, 109, 97, 110, 100]) }
</a><a href="#h6-2-4" id="h6-2-4" class="i">+Panic: command mismatch at Entry { index: 2, term: 2, command: Some([99, 111, 109, 109, 97, 110, 100]) }
</a> 1@2 None
 2@2 command
 
<a href="#h6-3" id="h6-3" class="h">@@ -180,8 +180,8 @@ last=4@6 commit=2@5
</a> !splice 2@7=
 !splice 1@7=
 ---
<a href="#h6-3-3" id="h6-3-3" class="d">-Error: assertion failed: spliced entries below commit index
</a><a href="#h6-3-4" id="h6-3-4" class="d">-Error: assertion failed: spliced entries below commit index
</a><a href="#h6-3-5" id="h6-3-5" class="i">+Panic: spliced entries below commit index
</a><a href="#h6-3-6" id="h6-3-6" class="i">+Panic: spliced entries below commit index
</a> 
 # Dump the raw data.
 dump
<b>diff --git a/<a id="h7" href="../file/src/raft/testscripts/log/term.html">src/raft/testscripts/log/term</a> b/<a href="../file/src/raft/testscripts/log/term.html">src/raft/testscripts/log/term</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -6,7 +6,7 @@ term=0 vote=None
</a> # Storing a 0 term errors.
 !set_term 0
 ---
<a href="#h7-0-3" id="h7-0-3" class="d">-Error: assertion failed: can&#39;t set term 0
</a><a href="#h7-0-4" id="h7-0-4" class="i">+Panic: can&#39;t set term 0
</a> 
 # set_term stores a term and empty vote, writing it to the engine
 # and flushing it to durable storage.
<a href="#h7-1" id="h7-1" class="h">@@ -46,17 +46,17 @@ term=9 vote=1
</a> # Regressing the term errors.
 !set_term 8
 ---
<a href="#h7-1-3" id="h7-1-3" class="d">-Error: assertion failed: term regression 9 → 8
</a><a href="#h7-1-4" id="h7-1-4" class="i">+Panic: term regression 9 → 8
</a> 
 # Clearing the vote errors.
 !set_term 9
 ---
<a href="#h7-1-9" id="h7-1-9" class="d">-Error: assertion failed: can&#39;t change vote Some(1) → None
</a><a href="#h7-1-10" id="h7-1-10" class="i">+Panic: can&#39;t change vote Some(1) → None
</a> 
 # Changing the vote errors.
 !set_term 9 2
 ---
<a href="#h7-1-15" id="h7-1-15" class="d">-Error: assertion failed: can&#39;t change vote Some(1) → Some(2)
</a><a href="#h7-1-16" id="h7-1-16" class="i">+Panic: can&#39;t change vote Some(1) → Some(2)
</a> 
 # The above errors should not have changed the term/vote.
 get_term
<b>diff --git a/<a id="h8" href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a> b/<a href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -2,8 +2,8 @@ use super::super::parser::ast;
</a> use super::super::schema::{Catalog, Column, Table};
 use super::super::types::{Expression, Value};
 use super::{Aggregate, Direction, Node, Plan};
<a href="#h8-0-3" id="h8-0-3" class="i">+use crate::errinput;
</a> use crate::error::Result;
<a href="#h8-0-5" id="h8-0-5" class="d">-use crate::{errassert, errinput};
</a> 
 use std::collections::{HashMap, HashSet};
 use std::mem::replace;
<a href="#h8-1" id="h8-1" class="h">@@ -29,10 +29,10 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         Ok(match statement {
             // Transaction control and explain statements should have been handled by session.
             ast::Statement::Begin { .. } | ast::Statement::Commit | ast::Statement::Rollback =&gt; {
<a href="#h8-1-3" id="h8-1-3" class="d">-                return errassert!(&quot;unexpected transaction statement {statement:?}&quot;)
</a><a href="#h8-1-4" id="h8-1-4" class="i">+                panic!(&quot;unexpected transaction statement {statement:?}&quot;)
</a>             }
 
<a href="#h8-1-7" id="h8-1-7" class="d">-            ast::Statement::Explain(_) =&gt; return errassert!(&quot;unexpected explain statement&quot;),
</a><a href="#h8-1-8" id="h8-1-8" class="i">+            ast::Statement::Explain(_) =&gt; panic!(&quot;unexpected explain statement&quot;),
</a> 
             // DDL statements (schema changes).
             ast::Statement::CreateTable { name, columns } =&gt; Node::CreateTable {
<a href="#h8-2" id="h8-2" class="h">@@ -698,7 +698,7 @@ impl Scope {
</a>     /// Adds a table to the scope.
     fn add_table(&amp;mut self, label: String, table: Table) -&gt; Result&lt;()&gt; {
         if self.constant {
<a href="#h8-2-3" id="h8-2-3" class="d">-            return errassert!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h8-2-4" id="h8-2-4" class="i">+            panic!(&quot;can&#39;t modify constant scope&quot;);
</a>         }
         if self.tables.contains_key(&amp;label) {
             return errinput!(&quot;duplicate table name {label}&quot;);
<a href="#h8-3" id="h8-3" class="h">@@ -729,7 +729,7 @@ impl Scope {
</a>     /// Merges two scopes, by appending the given scope to self.
     fn merge(&amp;mut self, scope: Scope) -&gt; Result&lt;()&gt; {
         if self.constant {
<a href="#h8-3-3" id="h8-3-3" class="d">-            return errassert!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h8-3-4" id="h8-3-4" class="i">+            panic!(&quot;can&#39;t modify constant scope&quot;);
</a>         }
         for (label, table) in scope.tables {
             if self.tables.contains_key(&amp;label) {
<a href="#h8-4" id="h8-4" class="h">@@ -775,7 +775,7 @@ impl Scope {
</a>     /// and returns a new scope for the projection.
     fn project(&amp;mut self, projection: &amp;[(Expression, Option&lt;String&gt;)]) -&gt; Result&lt;()&gt; {
         if self.constant {
<a href="#h8-4-3" id="h8-4-3" class="d">-            return errassert!(&quot;can&#39;t modify constant scope&quot;);
</a><a href="#h8-4-4" id="h8-4-4" class="i">+            panic!(&quot;can&#39;t modify constant scope&quot;);
</a>         }
         let mut new = Self::new();
         new.tables = self.tables.clone();
</pre>
</div>
</body>
</html>
