<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: normalize -NaN as NaN, and consider NaN == NaN for Value::Float - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/d0a896d9dc3c7e37a795bee9301c9838c67d238f.html">d0a896d9dc3c7e37a795bee9301c9838c67d238f</a>
<b>parent</b> <a href="../commit/681de5bd182166ab9b734de07a948045701d79c7.html">681de5bd182166ab9b734de07a948045701d79c7</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Mon,  8 Jul 2024 18:12:42 +0200

sql: normalize -NaN as NaN, and consider NaN == NaN for Value::Float

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/testscripts/writes/insert_datatypes</a></td><td> | </td><td class="num">10</td><td><span class="i">++++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/testscripts/writes/update_datatypes</a></td><td> | </td><td class="num">21</td><td><span class="i">++++++++++++++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/types/value.rs</a></td><td> | </td><td class="num">61</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------</span></td></tr>
</table></pre><pre>3 files changed, 61 insertions(+), 31 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/testscripts/writes/insert_datatypes.html">src/sql/testscripts/writes/insert_datatypes</a> b/<a href="../file/src/sql/testscripts/writes/insert_datatypes.html">src/sql/testscripts/writes/insert_datatypes</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -63,7 +63,7 @@ Error: invalid input: invalid datatype BOOLEAN for INTEGER column int
</a> Error: invalid input: invalid datatype FLOAT for INTEGER column int
 Error: invalid input: invalid datatype STRING for INTEGER column int
 
<a href="#h0-0-3" id="h0-0-3" class="d">-# Floats. -0.0 is normalized as 0.0.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+# Floats. -0.0 and -NaN is normalized as 0.0 and NaN.
</a> &gt; BEGIN
 &gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (1, 3.14)
 &gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (2, -3.14)
<a href="#h0-1" id="h0-1" class="h">@@ -73,8 +73,9 @@ Error: invalid input: invalid datatype STRING for INTEGER column int
</a> &gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (6, -1.23456789012345e308)
 &gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (7, INFINITY)
 &gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (8, -INFINITY)
<a href="#h0-1-3" id="h0-1-3" class="d">-&gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (9, NAN)
</a><a href="#h0-1-4" id="h0-1-4" class="d">-&gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (10, NULL)
</a><a href="#h0-1-5" id="h0-1-5" class="i">+&gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (9, -NAN)
</a><a href="#h0-1-6" id="h0-1-6" class="i">+&gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (10, NAN)
</a><a href="#h0-1-7" id="h0-1-7" class="i">+&gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (11, NULL)
</a> ---
 ok
 
<a href="#h0-2" id="h0-2" class="h">@@ -90,7 +91,8 @@ ok
</a> 7, NULL, NULL, inf, NULL
 8, NULL, NULL, -inf, NULL
 9, NULL, NULL, NaN, NULL
<a href="#h0-2-3" id="h0-2-3" class="d">-10, NULL, NULL, NULL, NULL
</a><a href="#h0-2-4" id="h0-2-4" class="i">+10, NULL, NULL, NaN, NULL
</a><a href="#h0-2-5" id="h0-2-5" class="i">+11, NULL, NULL, NULL, NULL
</a> 
 !&gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (0, false)
 !&gt; INSERT INTO datatypes (id, &quot;float&quot;) VALUES (0, 3)
<b>diff --git a/<a id="h1" href="../file/src/sql/testscripts/writes/update_datatypes.html">src/sql/testscripts/writes/update_datatypes</a> b/<a href="../file/src/sql/testscripts/writes/update_datatypes.html">src/sql/testscripts/writes/update_datatypes</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -51,16 +51,27 @@ Error: invalid input: invalid datatype STRING for INTEGER column int
</a> &gt; UPDATE datatypes SET &quot;float&quot; = NULL
 &gt; UPDATE datatypes SET &quot;float&quot; = 3.14
 &gt; UPDATE datatypes SET &quot;float&quot; = -3.14
<a href="#h1-0-3" id="h1-0-3" class="d">-&gt; UPDATE datatypes SET &quot;float&quot; = 0.0
</a><a href="#h1-0-4" id="h1-0-4" class="d">-&gt; UPDATE datatypes SET &quot;float&quot; = -0.0
</a> &gt; UPDATE datatypes SET &quot;float&quot; = 1.23456789012345e308
 &gt; UPDATE datatypes SET &quot;float&quot; = -1.23456789012345e308
 &gt; UPDATE datatypes SET &quot;float&quot; = INFINITY
 &gt; UPDATE datatypes SET &quot;float&quot; = -INFINITY
<a href="#h1-0-9" id="h1-0-9" class="d">-&gt; UPDATE datatypes SET &quot;float&quot; = NAN
</a> &gt; SELECT * FROM datatypes
 ---
<a href="#h1-0-12" id="h1-0-12" class="d">-1, TRUE, -9223372036854775807, NaN, NULL
</a><a href="#h1-0-13" id="h1-0-13" class="i">+1, TRUE, -9223372036854775807, -inf, NULL
</a><a href="#h1-0-14" id="h1-0-14" class="i">+
</a><a href="#h1-0-15" id="h1-0-15" class="i">+&gt; UPDATE datatypes SET &quot;float&quot; = NAN
</a><a href="#h1-0-16" id="h1-0-16" class="i">+&gt; SELECT &quot;float&quot; FROM datatypes
</a><a href="#h1-0-17" id="h1-0-17" class="i">+&gt; UPDATE datatypes SET &quot;float&quot; = -NAN
</a><a href="#h1-0-18" id="h1-0-18" class="i">+&gt; SELECT &quot;float&quot; FROM datatypes
</a><a href="#h1-0-19" id="h1-0-19" class="i">+&gt; UPDATE datatypes SET &quot;float&quot; = 0.0
</a><a href="#h1-0-20" id="h1-0-20" class="i">+&gt; SELECT &quot;float&quot; FROM datatypes
</a><a href="#h1-0-21" id="h1-0-21" class="i">+&gt; UPDATE datatypes SET &quot;float&quot; = -0.0
</a><a href="#h1-0-22" id="h1-0-22" class="i">+&gt; SELECT &quot;float&quot; FROM datatypes
</a><a href="#h1-0-23" id="h1-0-23" class="i">+---
</a><a href="#h1-0-24" id="h1-0-24" class="i">+NaN
</a><a href="#h1-0-25" id="h1-0-25" class="i">+NaN
</a><a href="#h1-0-26" id="h1-0-26" class="i">+0
</a><a href="#h1-0-27" id="h1-0-27" class="i">+0
</a> 
 # Strings.
 &gt; UPDATE datatypes SET &quot;string&quot; = NULL
<a href="#h1-1" id="h1-1" class="h">@@ -70,7 +81,7 @@ Error: invalid input: invalid datatype STRING for INTEGER column int
</a> &gt; UPDATE datatypes SET &quot;string&quot; = &#39;Hi! ðŸ‘‹&#39;
 &gt; SELECT * FROM datatypes
 ---
<a href="#h1-1-3" id="h1-1-3" class="d">-1, TRUE, -9223372036854775807, NaN, Hi! ðŸ‘‹
</a><a href="#h1-1-4" id="h1-1-4" class="i">+1, TRUE, -9223372036854775807, 0, Hi! ðŸ‘‹
</a> 
 !&gt; UPDATE datatypes SET &quot;string&quot; = false
 !&gt; UPDATE datatypes SET &quot;string&quot; = 3
<b>diff --git a/<a id="h2" href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a> b/<a href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -33,8 +33,15 @@ impl std::fmt::Display for DataType {
</a> 
 /// A primitive value.
 ///
<a href="#h2-0-3" id="h2-0-3" class="i">+/// Unlike SQL and IEEE 754 floating point, Null and NaN are considered equal
</a><a href="#h2-0-4" id="h2-0-4" class="i">+/// and comparable in code. This is necessary to allow sorting and processing of
</a><a href="#h2-0-5" id="h2-0-5" class="i">+/// these values (e.g. in index lookups, aggregation buckets, etc.). SQL
</a><a href="#h2-0-6" id="h2-0-6" class="i">+/// expression evaluation have special handling of these values to produce the
</a><a href="#h2-0-7" id="h2-0-7" class="i">+/// desired NULL != NULL and NAN != NAN semantics in SQL queries.
</a><a href="#h2-0-8" id="h2-0-8" class="i">+///
</a> /// Float -0.0 is considered equal to 0.0. It is normalized to 0.0 when stored.
<a href="#h2-0-10" id="h2-0-10" class="d">-#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h2-0-11" id="h2-0-11" class="i">+/// Similarly, -NaN is normalized to NaN.
</a><a href="#h2-0-12" id="h2-0-12" class="i">+#[derive(Clone, Debug, Serialize, Deserialize)]
</a> pub enum Value {
     /// An unknown value of unknown type.
     Null,
<a href="#h2-1" id="h2-1" class="h">@@ -50,14 +57,27 @@ pub enum Value {
</a> 
 impl encoding::Value for Value {}
 
<a href="#h2-1-3" id="h2-1-3" class="d">-// TODO: revisit and document the f64 handling here. FWIW, PostgreSQL considers
</a><a href="#h2-1-4" id="h2-1-4" class="d">-// NaN = NaN, maybe we should too. However, a better option is probably to cast
</a><a href="#h2-1-5" id="h2-1-5" class="d">-// NaN to NULL.
</a><a href="#h2-1-6" id="h2-1-6" class="i">+// In code, consider Null and NaN equal, so that we can detect and process these
</a><a href="#h2-1-7" id="h2-1-7" class="i">+// values (e.g. in index lookups, aggregation groups, etc). SQL expressions
</a><a href="#h2-1-8" id="h2-1-8" class="i">+// handle them specially to provide their undefined value semantics.
</a><a href="#h2-1-9" id="h2-1-9" class="i">+impl std::cmp::PartialEq for Value {
</a><a href="#h2-1-10" id="h2-1-10" class="i">+    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
</a><a href="#h2-1-11" id="h2-1-11" class="i">+        match (self, other) {
</a><a href="#h2-1-12" id="h2-1-12" class="i">+            (Self::Boolean(l), Self::Boolean(r)) =&gt; l == r,
</a><a href="#h2-1-13" id="h2-1-13" class="i">+            (Self::Integer(l), Self::Integer(r)) =&gt; l == r,
</a><a href="#h2-1-14" id="h2-1-14" class="i">+            (Self::Float(l), Self::Float(r)) =&gt; l.is_nan() &amp;&amp; r.is_nan() || l == r,
</a><a href="#h2-1-15" id="h2-1-15" class="i">+            (Self::String(l), Self::String(r)) =&gt; l == r,
</a><a href="#h2-1-16" id="h2-1-16" class="i">+            _ =&gt; core::mem::discriminant(self) == core::mem::discriminant(other),
</a><a href="#h2-1-17" id="h2-1-17" class="i">+        }
</a><a href="#h2-1-18" id="h2-1-18" class="i">+    }
</a><a href="#h2-1-19" id="h2-1-19" class="i">+}
</a><a href="#h2-1-20" id="h2-1-20" class="i">+
</a> impl std::cmp::Eq for Value {}
 
 impl std::hash::Hash for Value {
     fn hash&lt;H: std::hash::Hasher&gt;(&amp;self, state: &amp;mut H) {
         self.datatype().hash(state);
<a href="#h2-1-26" id="h2-1-26" class="i">+        // Normalize to treat +/-0.0 and +/-NAN as equal when hashing.
</a>         match self.normalize_ref().as_ref() {
             Self::Null =&gt; self.hash(state),
             Self::Boolean(v) =&gt; v.hash(state),
<a href="#h2-2" id="h2-2" class="h">@@ -68,12 +88,13 @@ impl std::hash::Hash for Value {
</a>     }
 }
 
<a href="#h2-2-3" id="h2-2-3" class="i">+// For ordering purposes, we consider NULL and NaN equal. We establish a total
</a><a href="#h2-2-4" id="h2-2-4" class="i">+// order across all types, even though mixed types will rarely/never come up.
</a> impl Ord for Value {
     fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {
         use std::cmp::Ordering;
<a href="#h2-2-8" id="h2-2-8" class="i">+        #[allow(unreachable_patterns)]
</a>         match (self, other) {
<a href="#h2-2-10" id="h2-2-10" class="d">-            // For ordering purposes, we consider e.g. NULL and NaN equal, and
</a><a href="#h2-2-11" id="h2-2-11" class="d">-            // establish a total order.
</a>             (Self::Null, Self::Null) =&gt; Ordering::Equal,
             (Self::Boolean(a), Self::Boolean(b)) =&gt; a.cmp(b),
             (Self::Integer(a), Self::Integer(b)) =&gt; a.cmp(b),
<a href="#h2-3" id="h2-3" class="h">@@ -82,9 +103,6 @@ impl Ord for Value {
</a>             (Self::Float(a), Self::Float(b)) =&gt; a.total_cmp(b),
             (Self::String(a), Self::String(b)) =&gt; a.cmp(b),
 
<a href="#h2-3-3" id="h2-3-3" class="d">-            // Mixed types. Should rarely come up, but we may as well establish
</a><a href="#h2-3-4" id="h2-3-4" class="d">-            // an order, especially since we also implement Eq. We can handle
</a><a href="#h2-3-5" id="h2-3-5" class="d">-            // any special cases during expression evaluation.
</a>             (Self::Null, _) =&gt; Ordering::Less,
             (_, Self::Null) =&gt; Ordering::Greater,
             (Self::Boolean(_), _) =&gt; Ordering::Less,
<a href="#h2-4" id="h2-4" class="h">@@ -93,9 +111,7 @@ impl Ord for Value {
</a>             (_, Self::Float(_)) =&gt; Ordering::Greater,
             (Self::Integer(_), _) =&gt; Ordering::Less,
             (_, Self::Integer(_)) =&gt; Ordering::Greater,
<a href="#h2-4-3" id="h2-4-3" class="d">-            #[allow(unreachable_patterns)]
</a>             (Self::String(_), _) =&gt; Ordering::Less,
<a href="#h2-4-5" id="h2-4-5" class="d">-            #[allow(unreachable_patterns)]
</a>             (_, Self::String(_)) =&gt; Ordering::Greater,
         }
     }
<a href="#h2-5" id="h2-5" class="h">@@ -225,9 +241,9 @@ impl Value {
</a>         }
     }
 
<a href="#h2-5-3" id="h2-5-3" class="d">-    /// Normalizes a value. Currently only normalizes -0.0 to 0.0, since these
</a><a href="#h2-5-4" id="h2-5-4" class="d">-    /// values are equivalent and should be handled as such e.g. in primary key
</a><a href="#h2-5-5" id="h2-5-5" class="d">-    /// and index lookups.
</a><a href="#h2-5-6" id="h2-5-6" class="i">+    /// Normalizes a value. Currently normalizes -0.0 and -NAN to 0.0 and NAN
</a><a href="#h2-5-7" id="h2-5-7" class="i">+    /// respectively, which is the canonical value used e.g. in primary key and
</a><a href="#h2-5-8" id="h2-5-8" class="i">+    /// index lookups.
</a>     pub fn normalize(self) -&gt; Self {
         match self.normalize_ref() {
             Cow::Borrowed(_) =&gt; self, // no change
<a href="#h2-6" id="h2-6" class="h">@@ -235,16 +251,17 @@ impl Value {
</a>         }
     }
 
<a href="#h2-6-3" id="h2-6-3" class="d">-    /// Normalizes a borrowed value. Currently only normalizes -0.0 to 0.0,
</a><a href="#h2-6-4" id="h2-6-4" class="d">-    /// since these values are equivalent and should be handled as such e.g. in
</a><a href="#h2-6-5" id="h2-6-5" class="d">-    /// primary key and index lookups. Returns a Cow to avoid allocating in the
</a><a href="#h2-6-6" id="h2-6-6" class="d">-    /// common case where the value doesn&#39;t change.
</a><a href="#h2-6-7" id="h2-6-7" class="i">+    /// Normalizes a borrowed value. Currently normalizes -0.0 and -NAN to 0.0
</a><a href="#h2-6-8" id="h2-6-8" class="i">+    /// and NAN respectively, which is the canonical value used e.g. in primary
</a><a href="#h2-6-9" id="h2-6-9" class="i">+    /// key and index lookups. Returns a Cow to avoid allocating in the common
</a><a href="#h2-6-10" id="h2-6-10" class="i">+    /// case where the value doesn&#39;t change.
</a>     pub fn normalize_ref(&amp;self) -&gt; Cow&lt;&#39;_, Self&gt; {
<a href="#h2-6-12" id="h2-6-12" class="d">-        match self {
</a><a href="#h2-6-13" id="h2-6-13" class="d">-            // TODO: NaN and -NaN may be different too, normalize them.
</a><a href="#h2-6-14" id="h2-6-14" class="d">-            Self::Float(f) if *f == 0.0 &amp;&amp; f.is_sign_negative() =&gt; Cow::Owned(Self::Float(0.0)),
</a><a href="#h2-6-15" id="h2-6-15" class="d">-            v =&gt; Cow::Borrowed(v),
</a><a href="#h2-6-16" id="h2-6-16" class="i">+        if let Self::Float(f) = self {
</a><a href="#h2-6-17" id="h2-6-17" class="i">+            if f.is_sign_negative() &amp;&amp; (f.is_nan() || *f == -0.0) {
</a><a href="#h2-6-18" id="h2-6-18" class="i">+                return Cow::Owned(Self::Float(-f));
</a><a href="#h2-6-19" id="h2-6-19" class="i">+            }
</a>         }
<a href="#h2-6-21" id="h2-6-21" class="i">+        Cow::Borrowed(self)
</a>     }
 
     // Returns true if the value is already normalized.
</pre>
</div>
</body>
</html>
