<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: tweak expression operator parsing - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/3c06bc6d7264001973f4deed1f4577ec2ac98a9b.html">3c06bc6d7264001973f4deed1f4577ec2ac98a9b</a>
<b>parent</b> <a href="../commit/ae00835f8a664ed3d52b28830b0fafa8bc9dfc22.html">ae00835f8a664ed3d52b28830b0fafa8bc9dfc22</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Mon, 24 Jun 2024 13:02:38 +0200

sql: tweak expression operator parsing

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/parser/parser.rs</a></td><td> | </td><td class="num">210</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++</span><span class="d">--------------------------------------</span></td></tr>
</table></pre><pre>2 files changed, 114 insertions(+), 102 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -284,3 +284,9 @@ impl core::convert::From&lt;Operator&gt; for Expression {
</a>         Self::Operator(op)
     }
 }
<a href="#h0-0-3" id="h0-0-3" class="i">+
</a><a href="#h0-0-4" id="h0-0-4" class="i">+impl core::convert::From&lt;Operator&gt; for Box&lt;Expression&gt; {
</a><a href="#h0-0-5" id="h0-0-5" class="i">+    fn from(value: Operator) -&gt; Self {
</a><a href="#h0-0-6" id="h0-0-6" class="i">+        Box::new(value.into())
</a><a href="#h0-0-7" id="h0-0-7" class="i">+    }
</a><a href="#h0-0-8" id="h0-0-8" class="i">+}
</a><b>diff --git a/<a id="h1" href="../file/src/sql/parser/parser.rs.html">src/sql/parser/parser.rs</a> b/<a href="../file/src/sql/parser/parser.rs.html">src/sql/parser/parser.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -483,18 +483,18 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>     fn parse_expression_at(&amp;mut self, min_precedence: Precedence) -&gt; Result&lt;ast::Expression&gt; {
         // If there is a prefix operator, parse it and its right-hand operand.
         // Otherwise, parse the left-hand atom.
<a href="#h1-0-3" id="h1-0-3" class="d">-        let mut lhs = if let Some(prefix) = PrefixOperator::parse(self, min_precedence)? {
</a><a href="#h1-0-4" id="h1-0-4" class="i">+        let mut lhs = if let Some(prefix) = self.parse_prefix_operator(min_precedence)? {
</a>             let at_precedence = prefix.precedence() + prefix.associativity();
             prefix.build(self.parse_expression_at(at_precedence)?)
         } else {
             self.parse_expression_atom()?
         };
         // Apply any postfix operators.
<a href="#h1-0-11" id="h1-0-11" class="d">-        while let Some(postfix) = PostfixOperator::parse(self, min_precedence)? {
</a><a href="#h1-0-12" id="h1-0-12" class="i">+        while let Some(postfix) = self.parse_postfix_operator(min_precedence)? {
</a>             lhs = postfix.build(lhs)
         }
         // Apply any binary infix operators, parsing the right-hand operand.
<a href="#h1-0-16" id="h1-0-16" class="d">-        while let Some(infix) = InfixOperator::parse(self, min_precedence)? {
</a><a href="#h1-0-17" id="h1-0-17" class="i">+        while let Some(infix) = self.parse_infix_operator(min_precedence)? {
</a>             let at_precedence = infix.precedence() + infix.associativity();
             let rhs = self.parse_expression_at(at_precedence)?;
             lhs = infix.build(lhs, rhs)
<a href="#h1-1" id="h1-1" class="h">@@ -555,6 +555,84 @@ impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a>             token =&gt; return errinput!(&quot;expected expression atom, found {token}&quot;),
         })
     }
<a href="#h1-1-3" id="h1-1-3" class="i">+
</a><a href="#h1-1-4" id="h1-1-4" class="i">+    /// Parses a prefix operator, if there is one and it&#39;s precedence is at
</a><a href="#h1-1-5" id="h1-1-5" class="i">+    /// least min_precedence.
</a><a href="#h1-1-6" id="h1-1-6" class="i">+    fn parse_prefix_operator(
</a><a href="#h1-1-7" id="h1-1-7" class="i">+        &amp;mut self,
</a><a href="#h1-1-8" id="h1-1-8" class="i">+        min_precedence: Precedence,
</a><a href="#h1-1-9" id="h1-1-9" class="i">+    ) -&gt; Result&lt;Option&lt;PrefixOperator&gt;&gt; {
</a><a href="#h1-1-10" id="h1-1-10" class="i">+        self.next_if_map(|token| {
</a><a href="#h1-1-11" id="h1-1-11" class="i">+            let operator = match token {
</a><a href="#h1-1-12" id="h1-1-12" class="i">+                Token::Keyword(Keyword::Not) =&gt; PrefixOperator::Not,
</a><a href="#h1-1-13" id="h1-1-13" class="i">+                Token::Minus =&gt; PrefixOperator::Minus,
</a><a href="#h1-1-14" id="h1-1-14" class="i">+                Token::Plus =&gt; PrefixOperator::Plus,
</a><a href="#h1-1-15" id="h1-1-15" class="i">+                _ =&gt; return None,
</a><a href="#h1-1-16" id="h1-1-16" class="i">+            };
</a><a href="#h1-1-17" id="h1-1-17" class="i">+            Some(operator).filter(|op| op.precedence() &gt;= min_precedence)
</a><a href="#h1-1-18" id="h1-1-18" class="i">+        })
</a><a href="#h1-1-19" id="h1-1-19" class="i">+    }
</a><a href="#h1-1-20" id="h1-1-20" class="i">+
</a><a href="#h1-1-21" id="h1-1-21" class="i">+    /// Parses an infix operator, if there is one and it&#39;s precedence is at
</a><a href="#h1-1-22" id="h1-1-22" class="i">+    /// least min_precedence.
</a><a href="#h1-1-23" id="h1-1-23" class="i">+    fn parse_infix_operator(
</a><a href="#h1-1-24" id="h1-1-24" class="i">+        &amp;mut self,
</a><a href="#h1-1-25" id="h1-1-25" class="i">+        min_precedence: Precedence,
</a><a href="#h1-1-26" id="h1-1-26" class="i">+    ) -&gt; Result&lt;Option&lt;InfixOperator&gt;&gt; {
</a><a href="#h1-1-27" id="h1-1-27" class="i">+        self.next_if_map(|token| {
</a><a href="#h1-1-28" id="h1-1-28" class="i">+            let operator = match token {
</a><a href="#h1-1-29" id="h1-1-29" class="i">+                Token::Asterisk =&gt; InfixOperator::Multiply,
</a><a href="#h1-1-30" id="h1-1-30" class="i">+                Token::Caret =&gt; InfixOperator::Exponentiate,
</a><a href="#h1-1-31" id="h1-1-31" class="i">+                Token::Equal =&gt; InfixOperator::Equal,
</a><a href="#h1-1-32" id="h1-1-32" class="i">+                Token::GreaterThan =&gt; InfixOperator::GreaterThan,
</a><a href="#h1-1-33" id="h1-1-33" class="i">+                Token::GreaterThanOrEqual =&gt; InfixOperator::GreaterThanOrEqual,
</a><a href="#h1-1-34" id="h1-1-34" class="i">+                Token::Keyword(Keyword::And) =&gt; InfixOperator::And,
</a><a href="#h1-1-35" id="h1-1-35" class="i">+                Token::Keyword(Keyword::Like) =&gt; InfixOperator::Like,
</a><a href="#h1-1-36" id="h1-1-36" class="i">+                Token::Keyword(Keyword::Or) =&gt; InfixOperator::Or,
</a><a href="#h1-1-37" id="h1-1-37" class="i">+                Token::LessOrGreaterThan =&gt; InfixOperator::NotEqual,
</a><a href="#h1-1-38" id="h1-1-38" class="i">+                Token::LessThan =&gt; InfixOperator::LessThan,
</a><a href="#h1-1-39" id="h1-1-39" class="i">+                Token::LessThanOrEqual =&gt; InfixOperator::LessThanOrEqual,
</a><a href="#h1-1-40" id="h1-1-40" class="i">+                Token::Minus =&gt; InfixOperator::Subtract,
</a><a href="#h1-1-41" id="h1-1-41" class="i">+                Token::NotEqual =&gt; InfixOperator::NotEqual,
</a><a href="#h1-1-42" id="h1-1-42" class="i">+                Token::Percent =&gt; InfixOperator::Modulo,
</a><a href="#h1-1-43" id="h1-1-43" class="i">+                Token::Plus =&gt; InfixOperator::Add,
</a><a href="#h1-1-44" id="h1-1-44" class="i">+                Token::Slash =&gt; InfixOperator::Divide,
</a><a href="#h1-1-45" id="h1-1-45" class="i">+                _ =&gt; return None,
</a><a href="#h1-1-46" id="h1-1-46" class="i">+            };
</a><a href="#h1-1-47" id="h1-1-47" class="i">+            Some(operator).filter(|op| op.precedence() &gt;= min_precedence)
</a><a href="#h1-1-48" id="h1-1-48" class="i">+        })
</a><a href="#h1-1-49" id="h1-1-49" class="i">+    }
</a><a href="#h1-1-50" id="h1-1-50" class="i">+
</a><a href="#h1-1-51" id="h1-1-51" class="i">+    /// Parses a postfix operator, if there is one and it&#39;s precedence is at
</a><a href="#h1-1-52" id="h1-1-52" class="i">+    /// least min_precedence.
</a><a href="#h1-1-53" id="h1-1-53" class="i">+    fn parse_postfix_operator(
</a><a href="#h1-1-54" id="h1-1-54" class="i">+        &amp;mut self,
</a><a href="#h1-1-55" id="h1-1-55" class="i">+        min_precedence: Precedence,
</a><a href="#h1-1-56" id="h1-1-56" class="i">+    ) -&gt; Result&lt;Option&lt;PostfixOperator&gt;&gt; {
</a><a href="#h1-1-57" id="h1-1-57" class="i">+        // Handle IS (NOT) NULL separately, since it&#39;s multiple tokens.
</a><a href="#h1-1-58" id="h1-1-58" class="i">+        if let Some(Token::Keyword(Keyword::Is)) = self.peek()? {
</a><a href="#h1-1-59" id="h1-1-59" class="i">+            // We can&#39;t consume tokens unless the precedence is satisfied, so we
</a><a href="#h1-1-60" id="h1-1-60" class="i">+            // assume IS NULL (they both have the same precedence).
</a><a href="#h1-1-61" id="h1-1-61" class="i">+            if PostfixOperator::IsNull.precedence() &lt; min_precedence {
</a><a href="#h1-1-62" id="h1-1-62" class="i">+                return Ok(None);
</a><a href="#h1-1-63" id="h1-1-63" class="i">+            }
</a><a href="#h1-1-64" id="h1-1-64" class="i">+            self.expect(Keyword::Is.into())?;
</a><a href="#h1-1-65" id="h1-1-65" class="i">+            if self.next_is(Keyword::Not.into()) {
</a><a href="#h1-1-66" id="h1-1-66" class="i">+                self.expect(Keyword::Null.into())?;
</a><a href="#h1-1-67" id="h1-1-67" class="i">+                return Ok(Some(PostfixOperator::IsNotNull));
</a><a href="#h1-1-68" id="h1-1-68" class="i">+            }
</a><a href="#h1-1-69" id="h1-1-69" class="i">+            self.expect(Keyword::Null.into())?;
</a><a href="#h1-1-70" id="h1-1-70" class="i">+            return Ok(Some(PostfixOperator::IsNull));
</a><a href="#h1-1-71" id="h1-1-71" class="i">+        }
</a><a href="#h1-1-72" id="h1-1-72" class="i">+
</a><a href="#h1-1-73" id="h1-1-73" class="i">+        self.next_if_map(|token| {
</a><a href="#h1-1-74" id="h1-1-74" class="i">+            let operator = match token {
</a><a href="#h1-1-75" id="h1-1-75" class="i">+                Token::Exclamation =&gt; PostfixOperator::Factorial,
</a><a href="#h1-1-76" id="h1-1-76" class="i">+                _ =&gt; return None,
</a><a href="#h1-1-77" id="h1-1-77" class="i">+            };
</a><a href="#h1-1-78" id="h1-1-78" class="i">+            Some(operator).filter(|op| op.precedence() &gt;= min_precedence)
</a><a href="#h1-1-79" id="h1-1-79" class="i">+        })
</a><a href="#h1-1-80" id="h1-1-80" class="i">+    }
</a> }
 
 /// Operator precedence.
<a href="#h1-2" id="h1-2" class="h">@@ -571,20 +649,6 @@ enum PrefixOperator {
</a> }
 
 impl PrefixOperator {
<a href="#h1-2-3" id="h1-2-3" class="d">-    /// Parses a prefix operator, if there is one and it&#39;s precedence is at
</a><a href="#h1-2-4" id="h1-2-4" class="d">-    /// least min_precedence.
</a><a href="#h1-2-5" id="h1-2-5" class="d">-    fn parse(parser: &amp;mut Parser, min_precedence: Precedence) -&gt; Result&lt;Option&lt;Self&gt;&gt; {
</a><a href="#h1-2-6" id="h1-2-6" class="d">-        parser.next_if_map(|token| {
</a><a href="#h1-2-7" id="h1-2-7" class="d">-            let operator = match token {
</a><a href="#h1-2-8" id="h1-2-8" class="d">-                Token::Keyword(Keyword::Not) =&gt; Self::Not,
</a><a href="#h1-2-9" id="h1-2-9" class="d">-                Token::Minus =&gt; Self::Minus,
</a><a href="#h1-2-10" id="h1-2-10" class="d">-                Token::Plus =&gt; Self::Plus,
</a><a href="#h1-2-11" id="h1-2-11" class="d">-                _ =&gt; return None,
</a><a href="#h1-2-12" id="h1-2-12" class="d">-            };
</a><a href="#h1-2-13" id="h1-2-13" class="d">-            Some(operator).filter(|op| op.precedence() &gt;= min_precedence)
</a><a href="#h1-2-14" id="h1-2-14" class="d">-        })
</a><a href="#h1-2-15" id="h1-2-15" class="d">-    }
</a><a href="#h1-2-16" id="h1-2-16" class="d">-
</a>     /// The operator precedence. Prefix operators have the highest precedence.
     fn precedence(&amp;self) -&gt; Precedence {
         9
<a href="#h1-3" id="h1-3" class="h">@@ -599,12 +663,11 @@ impl PrefixOperator {
</a>     /// Builds an AST expression for the operator.
     fn build(&amp;self, rhs: ast::Expression) -&gt; ast::Expression {
         let rhs = Box::new(rhs);
<a href="#h1-3-3" id="h1-3-3" class="d">-        let operator = match self {
</a><a href="#h1-3-4" id="h1-3-4" class="d">-            Self::Plus =&gt; ast::Operator::Identity(rhs),
</a><a href="#h1-3-5" id="h1-3-5" class="d">-            Self::Minus =&gt; ast::Operator::Negate(rhs),
</a><a href="#h1-3-6" id="h1-3-6" class="d">-            Self::Not =&gt; ast::Operator::Not(rhs),
</a><a href="#h1-3-7" id="h1-3-7" class="d">-        };
</a><a href="#h1-3-8" id="h1-3-8" class="d">-        ast::Expression::Operator(operator)
</a><a href="#h1-3-9" id="h1-3-9" class="i">+        match self {
</a><a href="#h1-3-10" id="h1-3-10" class="i">+            Self::Plus =&gt; ast::Operator::Identity(rhs).into(),
</a><a href="#h1-3-11" id="h1-3-11" class="i">+            Self::Minus =&gt; ast::Operator::Negate(rhs).into(),
</a><a href="#h1-3-12" id="h1-3-12" class="i">+            Self::Not =&gt; ast::Operator::Not(rhs).into(),
</a><a href="#h1-3-13" id="h1-3-13" class="i">+        }
</a>     }
 }
 
<a href="#h1-4" id="h1-4" class="h">@@ -628,33 +691,6 @@ enum InfixOperator {
</a> }
 
 impl InfixOperator {
<a href="#h1-4-3" id="h1-4-3" class="d">-    /// Parses an infix operator, if there is one and it&#39;s precedence is at
</a><a href="#h1-4-4" id="h1-4-4" class="d">-    /// least min_precedence.
</a><a href="#h1-4-5" id="h1-4-5" class="d">-    fn parse(parser: &amp;mut Parser, min_precedence: Precedence) -&gt; Result&lt;Option&lt;Self&gt;&gt; {
</a><a href="#h1-4-6" id="h1-4-6" class="d">-        parser.next_if_map(|token| {
</a><a href="#h1-4-7" id="h1-4-7" class="d">-            let operator = match token {
</a><a href="#h1-4-8" id="h1-4-8" class="d">-                Token::Asterisk =&gt; Self::Multiply,
</a><a href="#h1-4-9" id="h1-4-9" class="d">-                Token::Caret =&gt; Self::Exponentiate,
</a><a href="#h1-4-10" id="h1-4-10" class="d">-                Token::Equal =&gt; Self::Equal,
</a><a href="#h1-4-11" id="h1-4-11" class="d">-                Token::GreaterThan =&gt; Self::GreaterThan,
</a><a href="#h1-4-12" id="h1-4-12" class="d">-                Token::GreaterThanOrEqual =&gt; Self::GreaterThanOrEqual,
</a><a href="#h1-4-13" id="h1-4-13" class="d">-                Token::Keyword(Keyword::And) =&gt; Self::And,
</a><a href="#h1-4-14" id="h1-4-14" class="d">-                Token::Keyword(Keyword::Like) =&gt; Self::Like,
</a><a href="#h1-4-15" id="h1-4-15" class="d">-                Token::Keyword(Keyword::Or) =&gt; Self::Or,
</a><a href="#h1-4-16" id="h1-4-16" class="d">-                Token::LessOrGreaterThan =&gt; Self::NotEqual,
</a><a href="#h1-4-17" id="h1-4-17" class="d">-                Token::LessThan =&gt; Self::LessThan,
</a><a href="#h1-4-18" id="h1-4-18" class="d">-                Token::LessThanOrEqual =&gt; Self::LessThanOrEqual,
</a><a href="#h1-4-19" id="h1-4-19" class="d">-                Token::Minus =&gt; Self::Subtract,
</a><a href="#h1-4-20" id="h1-4-20" class="d">-                Token::NotEqual =&gt; Self::NotEqual,
</a><a href="#h1-4-21" id="h1-4-21" class="d">-                Token::Percent =&gt; Self::Modulo,
</a><a href="#h1-4-22" id="h1-4-22" class="d">-                Token::Plus =&gt; Self::Add,
</a><a href="#h1-4-23" id="h1-4-23" class="d">-                Token::Slash =&gt; Self::Divide,
</a><a href="#h1-4-24" id="h1-4-24" class="d">-                _ =&gt; return None,
</a><a href="#h1-4-25" id="h1-4-25" class="d">-            };
</a><a href="#h1-4-26" id="h1-4-26" class="d">-            Some(operator).filter(|op| op.precedence() &gt;= min_precedence)
</a><a href="#h1-4-27" id="h1-4-27" class="d">-        })
</a><a href="#h1-4-28" id="h1-4-28" class="d">-    }
</a><a href="#h1-4-29" id="h1-4-29" class="d">-
</a>     /// The operator precedence.
     fn precedence(&amp;self) -&gt; Precedence {
         match self {
<a href="#h1-5" id="h1-5" class="h">@@ -682,24 +718,23 @@ impl InfixOperator {
</a>     /// Builds an AST expression for the infix operator.
     fn build(&amp;self, lhs: ast::Expression, rhs: ast::Expression) -&gt; ast::Expression {
         let (lhs, rhs) = (Box::new(lhs), Box::new(rhs));
<a href="#h1-5-3" id="h1-5-3" class="d">-        let operator = match self {
</a><a href="#h1-5-4" id="h1-5-4" class="d">-            Self::Add =&gt; ast::Operator::Add(lhs, rhs),
</a><a href="#h1-5-5" id="h1-5-5" class="d">-            Self::And =&gt; ast::Operator::And(lhs, rhs),
</a><a href="#h1-5-6" id="h1-5-6" class="d">-            Self::Divide =&gt; ast::Operator::Divide(lhs, rhs),
</a><a href="#h1-5-7" id="h1-5-7" class="d">-            Self::Equal =&gt; ast::Operator::Equal(lhs, rhs),
</a><a href="#h1-5-8" id="h1-5-8" class="d">-            Self::Exponentiate =&gt; ast::Operator::Exponentiate(lhs, rhs),
</a><a href="#h1-5-9" id="h1-5-9" class="d">-            Self::GreaterThan =&gt; ast::Operator::GreaterThan(lhs, rhs),
</a><a href="#h1-5-10" id="h1-5-10" class="d">-            Self::GreaterThanOrEqual =&gt; ast::Operator::GreaterThanOrEqual(lhs, rhs),
</a><a href="#h1-5-11" id="h1-5-11" class="d">-            Self::LessThan =&gt; ast::Operator::LessThan(lhs, rhs),
</a><a href="#h1-5-12" id="h1-5-12" class="d">-            Self::LessThanOrEqual =&gt; ast::Operator::LessThanOrEqual(lhs, rhs),
</a><a href="#h1-5-13" id="h1-5-13" class="d">-            Self::Like =&gt; ast::Operator::Like(lhs, rhs),
</a><a href="#h1-5-14" id="h1-5-14" class="d">-            Self::Modulo =&gt; ast::Operator::Modulo(lhs, rhs),
</a><a href="#h1-5-15" id="h1-5-15" class="d">-            Self::Multiply =&gt; ast::Operator::Multiply(lhs, rhs),
</a><a href="#h1-5-16" id="h1-5-16" class="d">-            Self::NotEqual =&gt; ast::Operator::NotEqual(lhs, rhs),
</a><a href="#h1-5-17" id="h1-5-17" class="d">-            Self::Or =&gt; ast::Operator::Or(lhs, rhs),
</a><a href="#h1-5-18" id="h1-5-18" class="d">-            Self::Subtract =&gt; ast::Operator::Subtract(lhs, rhs),
</a><a href="#h1-5-19" id="h1-5-19" class="d">-        };
</a><a href="#h1-5-20" id="h1-5-20" class="d">-        ast::Expression::Operator(operator)
</a><a href="#h1-5-21" id="h1-5-21" class="i">+        match self {
</a><a href="#h1-5-22" id="h1-5-22" class="i">+            Self::Add =&gt; ast::Operator::Add(lhs, rhs).into(),
</a><a href="#h1-5-23" id="h1-5-23" class="i">+            Self::And =&gt; ast::Operator::And(lhs, rhs).into(),
</a><a href="#h1-5-24" id="h1-5-24" class="i">+            Self::Divide =&gt; ast::Operator::Divide(lhs, rhs).into(),
</a><a href="#h1-5-25" id="h1-5-25" class="i">+            Self::Equal =&gt; ast::Operator::Equal(lhs, rhs).into(),
</a><a href="#h1-5-26" id="h1-5-26" class="i">+            Self::Exponentiate =&gt; ast::Operator::Exponentiate(lhs, rhs).into(),
</a><a href="#h1-5-27" id="h1-5-27" class="i">+            Self::GreaterThan =&gt; ast::Operator::GreaterThan(lhs, rhs).into(),
</a><a href="#h1-5-28" id="h1-5-28" class="i">+            Self::GreaterThanOrEqual =&gt; ast::Operator::GreaterThanOrEqual(lhs, rhs).into(),
</a><a href="#h1-5-29" id="h1-5-29" class="i">+            Self::LessThan =&gt; ast::Operator::LessThan(lhs, rhs).into(),
</a><a href="#h1-5-30" id="h1-5-30" class="i">+            Self::LessThanOrEqual =&gt; ast::Operator::LessThanOrEqual(lhs, rhs).into(),
</a><a href="#h1-5-31" id="h1-5-31" class="i">+            Self::Like =&gt; ast::Operator::Like(lhs, rhs).into(),
</a><a href="#h1-5-32" id="h1-5-32" class="i">+            Self::Modulo =&gt; ast::Operator::Modulo(lhs, rhs).into(),
</a><a href="#h1-5-33" id="h1-5-33" class="i">+            Self::Multiply =&gt; ast::Operator::Multiply(lhs, rhs).into(),
</a><a href="#h1-5-34" id="h1-5-34" class="i">+            Self::NotEqual =&gt; ast::Operator::NotEqual(lhs, rhs).into(),
</a><a href="#h1-5-35" id="h1-5-35" class="i">+            Self::Or =&gt; ast::Operator::Or(lhs, rhs).into(),
</a><a href="#h1-5-36" id="h1-5-36" class="i">+            Self::Subtract =&gt; ast::Operator::Subtract(lhs, rhs).into(),
</a><a href="#h1-5-37" id="h1-5-37" class="i">+        }
</a>     }
 }
 
<a href="#h1-6" id="h1-6" class="h">@@ -711,34 +746,6 @@ enum PostfixOperator {
</a> }
 
 impl PostfixOperator {
<a href="#h1-6-3" id="h1-6-3" class="d">-    /// Parses a postfix operator, if there is one and it&#39;s precedence is at
</a><a href="#h1-6-4" id="h1-6-4" class="d">-    /// least min_precedence.
</a><a href="#h1-6-5" id="h1-6-5" class="d">-    fn parse(parser: &amp;mut Parser, min_precedence: Precedence) -&gt; Result&lt;Option&lt;Self&gt;&gt; {
</a><a href="#h1-6-6" id="h1-6-6" class="d">-        // Handle IS (NOT) NULL separately, since it&#39;s multiple tokens.
</a><a href="#h1-6-7" id="h1-6-7" class="d">-        if let Some(Token::Keyword(Keyword::Is)) = parser.peek()? {
</a><a href="#h1-6-8" id="h1-6-8" class="d">-            // We can&#39;t consume tokens unless the precedence is satisfied, so we
</a><a href="#h1-6-9" id="h1-6-9" class="d">-            // assume IS NULL (they both have the same precedence).
</a><a href="#h1-6-10" id="h1-6-10" class="d">-            if Self::IsNull.precedence() &lt; min_precedence {
</a><a href="#h1-6-11" id="h1-6-11" class="d">-                return Ok(None);
</a><a href="#h1-6-12" id="h1-6-12" class="d">-            }
</a><a href="#h1-6-13" id="h1-6-13" class="d">-            parser.expect(Keyword::Is.into())?;
</a><a href="#h1-6-14" id="h1-6-14" class="d">-            if parser.next_is(Keyword::Not.into()) {
</a><a href="#h1-6-15" id="h1-6-15" class="d">-                parser.expect(Keyword::Null.into())?;
</a><a href="#h1-6-16" id="h1-6-16" class="d">-                return Ok(Some(Self::IsNotNull));
</a><a href="#h1-6-17" id="h1-6-17" class="d">-            }
</a><a href="#h1-6-18" id="h1-6-18" class="d">-            parser.expect(Keyword::Null.into())?;
</a><a href="#h1-6-19" id="h1-6-19" class="d">-            return Ok(Some(Self::IsNull));
</a><a href="#h1-6-20" id="h1-6-20" class="d">-        }
</a><a href="#h1-6-21" id="h1-6-21" class="d">-
</a><a href="#h1-6-22" id="h1-6-22" class="d">-        parser.next_if_map(|token| {
</a><a href="#h1-6-23" id="h1-6-23" class="d">-            let op = match token {
</a><a href="#h1-6-24" id="h1-6-24" class="d">-                Token::Exclamation =&gt; Self::Factorial,
</a><a href="#h1-6-25" id="h1-6-25" class="d">-                _ =&gt; return None,
</a><a href="#h1-6-26" id="h1-6-26" class="d">-            };
</a><a href="#h1-6-27" id="h1-6-27" class="d">-            Some(op).filter(|op| op.precedence() &gt;= min_precedence)
</a><a href="#h1-6-28" id="h1-6-28" class="d">-        })
</a><a href="#h1-6-29" id="h1-6-29" class="d">-    }
</a><a href="#h1-6-30" id="h1-6-30" class="d">-
</a>     // The operator precedence. Postfix operators are below prefix operators.
     fn precedence(&amp;self) -&gt; Precedence {
         8
<a href="#h1-7" id="h1-7" class="h">@@ -747,11 +754,10 @@ impl PostfixOperator {
</a>     /// Builds an AST expression for the operator.
     fn build(&amp;self, lhs: ast::Expression) -&gt; ast::Expression {
         let lhs = Box::new(lhs);
<a href="#h1-7-3" id="h1-7-3" class="d">-        let operator = match self {
</a><a href="#h1-7-4" id="h1-7-4" class="d">-            Self::Factorial =&gt; ast::Operator::Factorial(lhs),
</a><a href="#h1-7-5" id="h1-7-5" class="d">-            Self::IsNotNull =&gt; ast::Operator::Not(Box::new(ast::Operator::IsNull(lhs).into())),
</a><a href="#h1-7-6" id="h1-7-6" class="d">-            Self::IsNull =&gt; ast::Operator::IsNull(lhs),
</a><a href="#h1-7-7" id="h1-7-7" class="d">-        };
</a><a href="#h1-7-8" id="h1-7-8" class="d">-        ast::Expression::Operator(operator)
</a><a href="#h1-7-9" id="h1-7-9" class="i">+        match self {
</a><a href="#h1-7-10" id="h1-7-10" class="i">+            Self::Factorial =&gt; ast::Operator::Factorial(lhs).into(),
</a><a href="#h1-7-11" id="h1-7-11" class="i">+            Self::IsNotNull =&gt; ast::Operator::Not(ast::Operator::IsNull(lhs).into()).into(),
</a><a href="#h1-7-12" id="h1-7-12" class="i">+            Self::IsNull =&gt; ast::Operator::IsNull(lhs).into(),
</a><a href="#h1-7-13" id="h1-7-13" class="i">+        }
</a>     }
 }
</pre>
</div>
</body>
</html>
