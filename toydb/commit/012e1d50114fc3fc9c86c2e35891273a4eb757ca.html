<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: clean up types module - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/012e1d50114fc3fc9c86c2e35891273a4eb757ca.html">012e1d50114fc3fc9c86c2e35891273a4eb757ca</a>
<b>parent</b> <a href="../commit/1cbd5ad5495b137ea7a0cfdf12b0c394bbc377e4.html">1cbd5ad5495b137ea7a0cfdf12b0c394bbc377e4</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sat, 20 Jul 2024 11:46:35 +0200

sql: clean up types module

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/planner/optimizer.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/testscripts/expressions/func_sqrt</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/testscripts/expressions/op_logic_and</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/testscripts/expressions/op_logic_not</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/testscripts/expressions/op_logic_or</a></td><td> | </td><td class="num">18</td><td><span class="i">+++++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/testscripts/expressions/op_precedence</a></td><td> | </td><td class="num">10</td><td><span class="i">+++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/testscripts/schema/create_table_default</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/sql/types/expression.rs</a></td><td> | </td><td class="num">288</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">src/sql/types/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/sql/types/schema.rs</a></td><td> | </td><td class="num">50</td><td><span class="i">+++++++++++++++++++++++++</span><span class="d">-------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">src/sql/types/value.rs</a></td><td> | </td><td class="num">161</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
</table></pre><pre>12 files changed, 293 insertions(+), 278 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -146,7 +146,7 @@ impl std::hash::Hash for Literal {
</a>             Self::Null =&gt; {}
             Self::Boolean(v) =&gt; v.hash(state),
             Self::Integer(v) =&gt; v.hash(state),
<a href="#h0-0-3" id="h0-0-3" class="d">-            Self::Float(v) =&gt; v.to_be_bytes().hash(state),
</a><a href="#h0-0-4" id="h0-0-4" class="i">+            Self::Float(v) =&gt; v.to_bits().hash(state),
</a>             Self::String(v) =&gt; v.hash(state),
         }
     }
<b>diff --git a/<a id="h1" href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a> b/<a href="../file/src/sql/planner/optimizer.rs.html">src/sql/planner/optimizer.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -229,16 +229,16 @@ pub(super) fn index_lookup(node: Node) -&gt; Result&lt;Node&gt; {
</a> 
         // Find the first expression that&#39;s either a primary key or secondary
         // index lookup. We could be more clever here, but this is fine.
<a href="#h1-0-3" id="h1-0-3" class="d">-        let Some(i) = cnf.iter().enumerate().find_map(|(i, e)| {
</a><a href="#h1-0-4" id="h1-0-4" class="i">+        let Some((i, column)) = cnf.iter().enumerate().find_map(|(i, e)| {
</a>             e.is_column_lookup()
<a href="#h1-0-6" id="h1-0-6" class="d">-                .filter(|f| *f == table.primary_key || table.columns[*f].index)
</a><a href="#h1-0-7" id="h1-0-7" class="d">-                .and(Some(i))
</a><a href="#h1-0-8" id="h1-0-8" class="i">+                .filter(|c| *c == table.primary_key || table.columns[*c].index)
</a><a href="#h1-0-9" id="h1-0-9" class="i">+                .map(|c| (i, c))
</a>         }) else {
             return Node::Scan { table, alias, filter: Some(filter) };
         };
 
         // Extract the lookup values and expression from the cnf vector.
<a href="#h1-0-15" id="h1-0-15" class="d">-        let (column, values) = cnf.remove(i).into_column_values().expect(&quot;column lookup failed&quot;);
</a><a href="#h1-0-16" id="h1-0-16" class="i">+        let values = cnf.remove(i).into_column_values(column);
</a> 
         // Build the primary key or secondary index lookup node.
         if column == table.primary_key {
<b>diff --git a/<a id="h2" href="../file/src/sql/testscripts/expressions/func_sqrt.html">src/sql/testscripts/expressions/func_sqrt</a> b/<a href="../file/src/sql/testscripts/expressions/func_sqrt.html">src/sql/testscripts/expressions/func_sqrt</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -11,7 +11,7 @@ Float(10.0) ← sqrt(100)
</a> !&gt; sqrt(-1)
 &gt; sqrt(0)
 ---
<a href="#h2-0-3" id="h2-0-3" class="d">-Error: invalid input: can&#39;t take square root of -1
</a><a href="#h2-0-4" id="h2-0-4" class="i">+Error: invalid input: can&#39;t take negative square root
</a> Float(0.0)
 
 # Floats work.
<b>diff --git a/<a id="h3" href="../file/src/sql/testscripts/expressions/op_logic_and.html">src/sql/testscripts/expressions/op_logic_and</a> b/<a href="../file/src/sql/testscripts/expressions/op_logic_and.html">src/sql/testscripts/expressions/op_logic_and</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -35,12 +35,12 @@ Null
</a> !&gt; TRUE AND &#39;true&#39;
 !&gt; &#39;true&#39; AND &#39;true&#39;
 ---
<a href="#h3-0-3" id="h3-0-3" class="d">-Error: invalid input: can&#39;t and 1 and TRUE
</a><a href="#h3-0-4" id="h3-0-4" class="d">-Error: invalid input: can&#39;t and TRUE and 1
</a><a href="#h3-0-5" id="h3-0-5" class="d">-Error: invalid input: can&#39;t and 1 and 1
</a><a href="#h3-0-6" id="h3-0-6" class="d">-Error: invalid input: can&#39;t and 3.14 and TRUE
</a><a href="#h3-0-7" id="h3-0-7" class="d">-Error: invalid input: can&#39;t and TRUE and 3.14
</a><a href="#h3-0-8" id="h3-0-8" class="d">-Error: invalid input: can&#39;t and 3.14 and 3.14
</a><a href="#h3-0-9" id="h3-0-9" class="d">-Error: invalid input: can&#39;t and &#39;true&#39; and TRUE
</a><a href="#h3-0-10" id="h3-0-10" class="d">-Error: invalid input: can&#39;t and TRUE and &#39;true&#39;
</a><a href="#h3-0-11" id="h3-0-11" class="d">-Error: invalid input: can&#39;t and &#39;true&#39; and &#39;true&#39;
</a><a href="#h3-0-12" id="h3-0-12" class="i">+Error: invalid input: can&#39;t AND 1 and TRUE
</a><a href="#h3-0-13" id="h3-0-13" class="i">+Error: invalid input: can&#39;t AND TRUE and 1
</a><a href="#h3-0-14" id="h3-0-14" class="i">+Error: invalid input: can&#39;t AND 1 and 1
</a><a href="#h3-0-15" id="h3-0-15" class="i">+Error: invalid input: can&#39;t AND 3.14 and TRUE
</a><a href="#h3-0-16" id="h3-0-16" class="i">+Error: invalid input: can&#39;t AND TRUE and 3.14
</a><a href="#h3-0-17" id="h3-0-17" class="i">+Error: invalid input: can&#39;t AND 3.14 and 3.14
</a><a href="#h3-0-18" id="h3-0-18" class="i">+Error: invalid input: can&#39;t AND &#39;true&#39; and TRUE
</a><a href="#h3-0-19" id="h3-0-19" class="i">+Error: invalid input: can&#39;t AND TRUE and &#39;true&#39;
</a><a href="#h3-0-20" id="h3-0-20" class="i">+Error: invalid input: can&#39;t AND &#39;true&#39; and &#39;true&#39;
</a><b>diff --git a/<a id="h4" href="../file/src/sql/testscripts/expressions/op_logic_not.html">src/sql/testscripts/expressions/op_logic_not</a> b/<a href="../file/src/sql/testscripts/expressions/op_logic_not.html">src/sql/testscripts/expressions/op_logic_not</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -13,6 +13,6 @@ Null
</a> !&gt; NOT 3.14
 !&gt; NOT &#39;true&#39;
 ---
<a href="#h4-0-3" id="h4-0-3" class="d">-Error: invalid input: can&#39;t negate 1
</a><a href="#h4-0-4" id="h4-0-4" class="d">-Error: invalid input: can&#39;t negate 3.14
</a><a href="#h4-0-5" id="h4-0-5" class="d">-Error: invalid input: can&#39;t negate &#39;true&#39;
</a><a href="#h4-0-6" id="h4-0-6" class="i">+Error: invalid input: can&#39;t NOT 1
</a><a href="#h4-0-7" id="h4-0-7" class="i">+Error: invalid input: can&#39;t NOT 3.14
</a><a href="#h4-0-8" id="h4-0-8" class="i">+Error: invalid input: can&#39;t NOT &#39;true&#39;
</a><b>diff --git a/<a id="h5" href="../file/src/sql/testscripts/expressions/op_logic_or.html">src/sql/testscripts/expressions/op_logic_or</a> b/<a href="../file/src/sql/testscripts/expressions/op_logic_or.html">src/sql/testscripts/expressions/op_logic_or</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -35,12 +35,12 @@ Null
</a> !&gt; TRUE OR &#39;true&#39;
 !&gt; &#39;true&#39; OR &#39;true&#39;
 ---
<a href="#h5-0-3" id="h5-0-3" class="d">-Error: invalid input: can&#39;t or 1 and TRUE
</a><a href="#h5-0-4" id="h5-0-4" class="d">-Error: invalid input: can&#39;t or TRUE and 1
</a><a href="#h5-0-5" id="h5-0-5" class="d">-Error: invalid input: can&#39;t or 1 and 1
</a><a href="#h5-0-6" id="h5-0-6" class="d">-Error: invalid input: can&#39;t or 3.14 and TRUE
</a><a href="#h5-0-7" id="h5-0-7" class="d">-Error: invalid input: can&#39;t or TRUE and 3.14
</a><a href="#h5-0-8" id="h5-0-8" class="d">-Error: invalid input: can&#39;t or 3.14 and 3.14
</a><a href="#h5-0-9" id="h5-0-9" class="d">-Error: invalid input: can&#39;t or &#39;true&#39; and TRUE
</a><a href="#h5-0-10" id="h5-0-10" class="d">-Error: invalid input: can&#39;t or TRUE and &#39;true&#39;
</a><a href="#h5-0-11" id="h5-0-11" class="d">-Error: invalid input: can&#39;t or &#39;true&#39; and &#39;true&#39;
</a><a href="#h5-0-12" id="h5-0-12" class="i">+Error: invalid input: can&#39;t OR 1 and TRUE
</a><a href="#h5-0-13" id="h5-0-13" class="i">+Error: invalid input: can&#39;t OR TRUE and 1
</a><a href="#h5-0-14" id="h5-0-14" class="i">+Error: invalid input: can&#39;t OR 1 and 1
</a><a href="#h5-0-15" id="h5-0-15" class="i">+Error: invalid input: can&#39;t OR 3.14 and TRUE
</a><a href="#h5-0-16" id="h5-0-16" class="i">+Error: invalid input: can&#39;t OR TRUE and 3.14
</a><a href="#h5-0-17" id="h5-0-17" class="i">+Error: invalid input: can&#39;t OR 3.14 and 3.14
</a><a href="#h5-0-18" id="h5-0-18" class="i">+Error: invalid input: can&#39;t OR &#39;true&#39; and TRUE
</a><a href="#h5-0-19" id="h5-0-19" class="i">+Error: invalid input: can&#39;t OR TRUE and &#39;true&#39;
</a><a href="#h5-0-20" id="h5-0-20" class="i">+Error: invalid input: can&#39;t OR &#39;true&#39; and &#39;true&#39;
</a><b>diff --git a/<a id="h6" href="../file/src/sql/testscripts/expressions/op_precedence.html">src/sql/testscripts/expressions/op_precedence</a> b/<a href="../file/src/sql/testscripts/expressions/op_precedence.html">src/sql/testscripts/expressions/op_precedence</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -323,7 +323,7 @@ Error: invalid input: can&#39;t LIKE 1 and &#39;abc&#39;
</a> Boolean(true)
 Error: invalid input: can&#39;t compare 1 and TRUE
 Boolean(false)
<a href="#h6-0-3" id="h6-0-3" class="d">-Error: invalid input: can&#39;t negate 1
</a><a href="#h6-0-4" id="h6-0-4" class="i">+Error: invalid input: can&#39;t NOT 1
</a> 
 # !=
 &gt; 1 != 1 != FALSE
<a href="#h6-1" id="h6-1" class="h">@@ -342,7 +342,7 @@ Error: invalid input: can&#39;t LIKE 1 and &#39;abc&#39;
</a> Boolean(true)
 Error: invalid input: can&#39;t compare 1 and TRUE
 Boolean(true)
<a href="#h6-1-3" id="h6-1-3" class="d">-Error: invalid input: can&#39;t negate 1
</a><a href="#h6-1-4" id="h6-1-4" class="i">+Error: invalid input: can&#39;t NOT 1
</a> 
 # LIKE
 &gt; &#39;abc&#39; LIKE NULL IS NULL
<a href="#h6-2" id="h6-2" class="h">@@ -353,7 +353,7 @@ Error: invalid input: can&#39;t negate 1
</a> Boolean(true)
 Error: invalid input: can&#39;t LIKE &#39;abc&#39; and TRUE
 Boolean(false)
<a href="#h6-2-3" id="h6-2-3" class="d">-Error: invalid input: can&#39;t negate &#39;abc&#39;
</a><a href="#h6-2-4" id="h6-2-4" class="i">+Error: invalid input: can&#39;t NOT &#39;abc&#39;
</a> 
 # IS NULL
 &gt; NOT NULL IS NULL
<a href="#h6-3" id="h6-3" class="h">@@ -374,14 +374,14 @@ Boolean(false)
</a> !&gt; (NOT NAN) IS NAN
 ---
 Boolean(false)
<a href="#h6-3-3" id="h6-3-3" class="d">-Error: invalid input: can&#39;t negate NaN
</a><a href="#h6-3-4" id="h6-3-4" class="i">+Error: invalid input: can&#39;t NOT NaN
</a> 
 # IS NOT NAN
 &gt; NOT NAN IS NOT NAN
 !&gt; (NOT NAN) IS NOT NAN
 ---
 Boolean(true)
<a href="#h6-3-11" id="h6-3-11" class="d">-Error: invalid input: can&#39;t negate NaN
</a><a href="#h6-3-12" id="h6-3-12" class="i">+Error: invalid input: can&#39;t NOT NaN
</a> 
 # NOT.
 &gt; NOT TRUE AND FALSE
<b>diff --git a/<a id="h7" href="../file/src/sql/testscripts/schema/create_table_default.html">src/sql/testscripts/schema/create_table_default</a> b/<a href="../file/src/sql/testscripts/schema/create_table_default.html">src/sql/testscripts/schema/create_table_default</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -23,9 +23,9 @@ CREATE TABLE datatypes (
</a> !&gt; CREATE TABLE name (id INT PRIMARY KEY, value INTEGER DEFAULT 3.14)
 !&gt; CREATE TABLE name (id INT PRIMARY KEY, value FLOAT DEFAULT 7)
 ---
<a href="#h7-0-3" id="h7-0-3" class="d">-Error: invalid input: invalid datatype INTEGER for STRING column value
</a><a href="#h7-0-4" id="h7-0-4" class="d">-Error: invalid input: invalid datatype FLOAT for INTEGER column value
</a><a href="#h7-0-5" id="h7-0-5" class="d">-Error: invalid input: invalid datatype INTEGER for FLOAT column value
</a><a href="#h7-0-6" id="h7-0-6" class="i">+Error: invalid input: invalid default type INTEGER for STRING column value
</a><a href="#h7-0-7" id="h7-0-7" class="i">+Error: invalid input: invalid default type FLOAT for INTEGER column value
</a><a href="#h7-0-8" id="h7-0-8" class="i">+Error: invalid input: invalid default type INTEGER for FLOAT column value
</a> 
 # Default values can be expressions.
 &gt; CREATE TABLE expr (id INT PRIMARY KEY, value INT DEFAULT 7 + 3 * 2)
<b>diff --git a/<a id="h8" href="../file/src/sql/types/expression.rs.html">src/sql/types/expression.rs</a> b/<a href="../file/src/sql/types/expression.rs.html">src/sql/types/expression.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -5,12 +5,13 @@ use crate::sql::planner::Node;
</a> 
 use serde::{Deserialize, Serialize};
 
<a href="#h8-0-3" id="h8-0-3" class="d">-/// An expression, made up of nested values and operators. Values can either be
</a><a href="#h8-0-4" id="h8-0-4" class="d">-/// constants or row column references.
</a><a href="#h8-0-5" id="h8-0-5" class="i">+/// An expression, made up of nested operations and values. Values are either
</a><a href="#h8-0-6" id="h8-0-6" class="i">+/// constants or dynamic column references. Evaluates to a final value during
</a><a href="#h8-0-7" id="h8-0-7" class="i">+/// query execution, using row values for column references.
</a> ///
 /// Since this is a recursive data structure, we have to box each child
<a href="#h8-0-10" id="h8-0-10" class="d">-/// expression, which incurs a heap allocation. There are clever ways to get
</a><a href="#h8-0-11" id="h8-0-11" class="d">-/// around this, but we keep it simple.
</a><a href="#h8-0-12" id="h8-0-12" class="i">+/// expression, which incurs a heap allocation per expression node. There are
</a><a href="#h8-0-13" id="h8-0-13" class="i">+/// clever ways to avoid this, but we keep it simple.
</a> #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Expression {
     /// A constant value.
<a href="#h8-1" id="h8-1" class="h">@@ -27,9 +28,9 @@ pub enum Expression {
</a> 
     /// Equality comparison of two values: a = b.
     Equal(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
<a href="#h8-1-3" id="h8-1-3" class="d">-    /// &gt; comparison of two values: a &gt; b.
</a><a href="#h8-1-4" id="h8-1-4" class="i">+    /// Greater than comparison of two values: a &gt; b.
</a>     GreaterThan(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
<a href="#h8-1-6" id="h8-1-6" class="d">-    /// &lt; comparison of two values: a &lt; b.
</a><a href="#h8-1-7" id="h8-1-7" class="i">+    /// Less than comparison of two values: a &lt; b.
</a>     LessThan(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
     /// Checks for the given value: IS NULL or IS NAN.
     Is(Box&lt;Expression&gt;, Value),
<a href="#h8-2" id="h8-2" class="h">@@ -42,7 +43,7 @@ pub enum Expression {
</a>     Exponentiate(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
     /// Takes the factorial of a number: 4! = 4*3*2*1.
     Factorial(Box&lt;Expression&gt;),
<a href="#h8-2-3" id="h8-2-3" class="d">-    /// The identify function, which simply returns the same number.
</a><a href="#h8-2-4" id="h8-2-4" class="i">+    /// The identify function, which simply returns the same number: +a.
</a>     Identity(Box&lt;Expression&gt;),
     /// Multiplies two numbers: a * b.
     Multiply(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
<a href="#h8-3" id="h8-3" class="h">@@ -60,11 +61,13 @@ pub enum Expression {
</a> }
 
 impl Expression {
<a href="#h8-3-3" id="h8-3-3" class="d">-    /// Formats the expression, using the given Node to look up column labels.
</a><a href="#h8-3-4" id="h8-3-4" class="i">+    /// Formats the expression, using the given plan node to look up labels for
</a><a href="#h8-3-5" id="h8-3-5" class="i">+    /// numeric column references.
</a>     pub fn format(&amp;self, node: &amp;Node) -&gt; String {
<a href="#h8-3-7" id="h8-3-7" class="i">+        use Expression::*;
</a><a href="#h8-3-8" id="h8-3-8" class="i">+
</a>         // Precedence levels, for grouping. Matches the parser precedence.
         fn precedence(expr: &amp;Expression) -&gt; u8 {
<a href="#h8-3-11" id="h8-3-11" class="d">-            use Expression::*;
</a>             match expr {
                 Column(_) | Constant(_) | SquareRoot(_) =&gt; 11,
                 Identity(_) | Negate(_) =&gt; 10,
<a href="#h8-4" id="h8-4" class="h">@@ -80,46 +83,45 @@ impl Expression {
</a>             }
         }
 
<a href="#h8-4-3" id="h8-4-3" class="d">-        // Helper to format a boxed expression.
</a><a href="#h8-4-4" id="h8-4-4" class="i">+        // Helper to format a boxed expression, grouping it with () if needed.
</a>         let format = |expr: &amp;Expression| {
<a href="#h8-4-6" id="h8-4-6" class="d">-            let group = precedence(expr) &lt; precedence(self);
</a><a href="#h8-4-7" id="h8-4-7" class="d">-            let mut s = expr.format(node);
</a><a href="#h8-4-8" id="h8-4-8" class="d">-            if group {
</a><a href="#h8-4-9" id="h8-4-9" class="d">-                s = format!(&quot;({s})&quot;);
</a><a href="#h8-4-10" id="h8-4-10" class="i">+            let mut string = expr.format(node);
</a><a href="#h8-4-11" id="h8-4-11" class="i">+            if precedence(expr) &lt; precedence(self) {
</a><a href="#h8-4-12" id="h8-4-12" class="i">+                string = format!(&quot;({string})&quot;);
</a>             }
<a href="#h8-4-14" id="h8-4-14" class="d">-            s
</a><a href="#h8-4-15" id="h8-4-15" class="i">+            string
</a>         };
 
         match self {
<a href="#h8-4-19" id="h8-4-19" class="d">-            Self::Column(index) =&gt; match node.column_label(*index) {
</a><a href="#h8-4-20" id="h8-4-20" class="i">+            Constant(value) =&gt; format!(&quot;{value}&quot;),
</a><a href="#h8-4-21" id="h8-4-21" class="i">+            Column(index) =&gt; match node.column_label(*index) {
</a>                 Label::None =&gt; format!(&quot;#{index}&quot;),
                 label =&gt; format!(&quot;{label}&quot;),
             },
<a href="#h8-4-25" id="h8-4-25" class="d">-            Self::Constant(value) =&gt; format!(&quot;{value}&quot;),
</a><a href="#h8-4-26" id="h8-4-26" class="d">-
</a><a href="#h8-4-27" id="h8-4-27" class="d">-            Self::And(lhs, rhs) =&gt; format!(&quot;{} AND {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-28" id="h8-4-28" class="d">-            Self::Or(lhs, rhs) =&gt; format!(&quot;{} OR {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-29" id="h8-4-29" class="d">-            Self::Not(expr) =&gt; format!(&quot;NOT {}&quot;, format(expr)),
</a><a href="#h8-4-30" id="h8-4-30" class="d">-
</a><a href="#h8-4-31" id="h8-4-31" class="d">-            Self::Equal(lhs, rhs) =&gt; format!(&quot;{} = {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-32" id="h8-4-32" class="d">-            Self::GreaterThan(lhs, rhs) =&gt; format!(&quot;{} &gt; {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-33" id="h8-4-33" class="d">-            Self::LessThan(lhs, rhs) =&gt; format!(&quot;{} &lt; {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-34" id="h8-4-34" class="d">-            Self::Is(expr, Value::Null) =&gt; format!(&quot;{} IS NULL&quot;, format(expr)),
</a><a href="#h8-4-35" id="h8-4-35" class="d">-            Self::Is(expr, Value::Float(f)) if f.is_nan() =&gt; format!(&quot;{} IS NAN&quot;, format(expr)),
</a><a href="#h8-4-36" id="h8-4-36" class="d">-            Self::Is(_, v) =&gt; panic!(&quot;unexpected IS value {v}&quot;),
</a><a href="#h8-4-37" id="h8-4-37" class="d">-
</a><a href="#h8-4-38" id="h8-4-38" class="d">-            Self::Add(lhs, rhs) =&gt; format!(&quot;{} + {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-39" id="h8-4-39" class="d">-            Self::Divide(lhs, rhs) =&gt; format!(&quot;{} / {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-40" id="h8-4-40" class="d">-            Self::Exponentiate(lhs, rhs) =&gt; format!(&quot;{} ^ {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-41" id="h8-4-41" class="d">-            Self::Factorial(expr) =&gt; format!(&quot;{}!&quot;, format(expr)),
</a><a href="#h8-4-42" id="h8-4-42" class="d">-            Self::Identity(expr) =&gt; format(expr),
</a><a href="#h8-4-43" id="h8-4-43" class="d">-            Self::Multiply(lhs, rhs) =&gt; format!(&quot;{} * {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-44" id="h8-4-44" class="d">-            Self::Negate(expr) =&gt; format!(&quot;-{}&quot;, format(expr)),
</a><a href="#h8-4-45" id="h8-4-45" class="d">-            Self::Remainder(lhs, rhs) =&gt; format!(&quot;{} % {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-46" id="h8-4-46" class="d">-            Self::SquareRoot(expr) =&gt; format!(&quot;sqrt({})&quot;, format(expr)),
</a><a href="#h8-4-47" id="h8-4-47" class="d">-            Self::Subtract(lhs, rhs) =&gt; format!(&quot;{} - {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-48" id="h8-4-48" class="d">-
</a><a href="#h8-4-49" id="h8-4-49" class="d">-            Self::Like(lhs, rhs) =&gt; format!(&quot;{} LIKE {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-50" id="h8-4-50" class="i">+
</a><a href="#h8-4-51" id="h8-4-51" class="i">+            And(lhs, rhs) =&gt; format!(&quot;{} AND {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-52" id="h8-4-52" class="i">+            Or(lhs, rhs) =&gt; format!(&quot;{} OR {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-53" id="h8-4-53" class="i">+            Not(expr) =&gt; format!(&quot;NOT {}&quot;, format(expr)),
</a><a href="#h8-4-54" id="h8-4-54" class="i">+
</a><a href="#h8-4-55" id="h8-4-55" class="i">+            Equal(lhs, rhs) =&gt; format!(&quot;{} = {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-56" id="h8-4-56" class="i">+            GreaterThan(lhs, rhs) =&gt; format!(&quot;{} &gt; {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-57" id="h8-4-57" class="i">+            LessThan(lhs, rhs) =&gt; format!(&quot;{} &lt; {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-58" id="h8-4-58" class="i">+            Is(expr, Value::Null) =&gt; format!(&quot;{} IS NULL&quot;, format(expr)),
</a><a href="#h8-4-59" id="h8-4-59" class="i">+            Is(expr, Value::Float(f)) if f.is_nan() =&gt; format!(&quot;{} IS NAN&quot;, format(expr)),
</a><a href="#h8-4-60" id="h8-4-60" class="i">+            Is(_, v) =&gt; panic!(&quot;unexpected IS value {v}&quot;),
</a><a href="#h8-4-61" id="h8-4-61" class="i">+
</a><a href="#h8-4-62" id="h8-4-62" class="i">+            Add(lhs, rhs) =&gt; format!(&quot;{} + {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-63" id="h8-4-63" class="i">+            Divide(lhs, rhs) =&gt; format!(&quot;{} / {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-64" id="h8-4-64" class="i">+            Exponentiate(lhs, rhs) =&gt; format!(&quot;{} ^ {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-65" id="h8-4-65" class="i">+            Factorial(expr) =&gt; format!(&quot;{}!&quot;, format(expr)),
</a><a href="#h8-4-66" id="h8-4-66" class="i">+            Identity(expr) =&gt; format(expr),
</a><a href="#h8-4-67" id="h8-4-67" class="i">+            Multiply(lhs, rhs) =&gt; format!(&quot;{} * {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-68" id="h8-4-68" class="i">+            Negate(expr) =&gt; format!(&quot;-{}&quot;, format(expr)),
</a><a href="#h8-4-69" id="h8-4-69" class="i">+            Remainder(lhs, rhs) =&gt; format!(&quot;{} % {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-70" id="h8-4-70" class="i">+            SquareRoot(expr) =&gt; format!(&quot;sqrt({})&quot;, format(expr)),
</a><a href="#h8-4-71" id="h8-4-71" class="i">+            Subtract(lhs, rhs) =&gt; format!(&quot;{} - {}&quot;, format(lhs), format(rhs)),
</a><a href="#h8-4-72" id="h8-4-72" class="i">+
</a><a href="#h8-4-73" id="h8-4-73" class="i">+            Like(lhs, rhs) =&gt; format!(&quot;{} LIKE {}&quot;, format(lhs), format(rhs)),
</a>         }
     }
 
<a href="#h8-5" id="h8-5" class="h">@@ -128,13 +130,13 @@ impl Expression {
</a>     pub fn evaluate(&amp;self, row: Option&lt;&amp;Row&gt;) -&gt; Result&lt;Value&gt; {
         use Value::*;
         Ok(match self {
<a href="#h8-5-3" id="h8-5-3" class="d">-            // Constant values return itself.
</a><a href="#h8-5-4" id="h8-5-4" class="i">+            // Constant values return themselves.
</a>             Self::Constant(value) =&gt; value.clone(),
 
             // Column references look up a row value. The planner ensures that
             // only constant expressions are evaluated without a row.
             Self::Column(index) =&gt; match row {
<a href="#h8-5-10" id="h8-5-10" class="d">-                Some(row) =&gt; row[*index].clone(),
</a><a href="#h8-5-11" id="h8-5-11" class="i">+                Some(row) =&gt; row.get(*index).expect(&quot;short row&quot;).clone(),
</a>                 None =&gt; panic!(&quot;can&#39;t reference column {index} with constant evaluation&quot;),
             },
 
<a href="#h8-6" id="h8-6" class="h">@@ -144,7 +146,7 @@ impl Expression {
</a>                 (Boolean(lhs), Boolean(rhs)) =&gt; Boolean(lhs &amp;&amp; rhs),
                 (Boolean(b), Null) | (Null, Boolean(b)) if !b =&gt; Boolean(false),
                 (Boolean(_), Null) | (Null, Boolean(_)) | (Null, Null) =&gt; Null,
<a href="#h8-6-3" id="h8-6-3" class="d">-                (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t and {lhs} and {rhs}&quot;),
</a><a href="#h8-6-4" id="h8-6-4" class="i">+                (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t AND {lhs} and {rhs}&quot;),
</a>             },
 
             // Logical OR. Inputs must be boolean or NULL. NULLs generally
<a href="#h8-7" id="h8-7" class="h">@@ -153,21 +155,21 @@ impl Expression {
</a>                 (Boolean(lhs), Boolean(rhs)) =&gt; Boolean(lhs || rhs),
                 (Boolean(b), Null) | (Null, Boolean(b)) if b =&gt; Boolean(true),
                 (Boolean(_), Null) | (Null, Boolean(_)) | (Null, Null) =&gt; Null,
<a href="#h8-7-3" id="h8-7-3" class="d">-                (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t or {lhs} and {rhs}&quot;),
</a><a href="#h8-7-4" id="h8-7-4" class="i">+                (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t OR {lhs} and {rhs}&quot;),
</a>             },
 
             // Logical NOT. Input must be boolean or NULL.
             Self::Not(expr) =&gt; match expr.evaluate(row)? {
                 Boolean(b) =&gt; Boolean(!b),
                 Null =&gt; Null,
<a href="#h8-7-11" id="h8-7-11" class="d">-                value =&gt; return errinput!(&quot;can&#39;t negate {value}&quot;),
</a><a href="#h8-7-12" id="h8-7-12" class="i">+                value =&gt; return errinput!(&quot;can&#39;t NOT {value}&quot;),
</a>             },
 
             // Comparisons. Must be of same type, except floats and integers
             // which are interchangeable. NULLs yield NULL, NaNs yield NaN.
             //
             // Does not dispatch to Value.cmp() because sorting and comparisons
<a href="#h8-7-19" id="h8-7-19" class="d">-            // are different for f64 NaN and -0 values.
</a><a href="#h8-7-20" id="h8-7-20" class="i">+            // are different for f64 NaN and -0.0 values.
</a>             #[allow(clippy::float_cmp)]
             Self::Equal(lhs, rhs) =&gt; match (lhs.evaluate(row)?, rhs.evaluate(row)?) {
                 (Boolean(lhs), Boolean(rhs)) =&gt; Boolean(lhs == rhs),
<a href="#h8-8" id="h8-8" class="h">@@ -179,6 +181,7 @@ impl Expression {
</a>                 (Null, _) | (_, Null) =&gt; Null,
                 (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t compare {lhs} and {rhs}&quot;),
             },
<a href="#h8-8-3" id="h8-8-3" class="i">+
</a>             Self::GreaterThan(lhs, rhs) =&gt; match (lhs.evaluate(row)?, rhs.evaluate(row)?) {
                 #[allow(clippy::bool_comparison)]
                 (Boolean(lhs), Boolean(rhs)) =&gt; Boolean(lhs &gt; rhs),
<a href="#h8-9" id="h8-9" class="h">@@ -190,6 +193,7 @@ impl Expression {
</a>                 (Null, _) | (_, Null) =&gt; Null,
                 (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t compare {lhs} and {rhs}&quot;),
             },
<a href="#h8-9-3" id="h8-9-3" class="i">+
</a>             Self::LessThan(lhs, rhs) =&gt; match (lhs.evaluate(row)?, rhs.evaluate(row)?) {
                 #[allow(clippy::bool_comparison)]
                 (Boolean(lhs), Boolean(rhs)) =&gt; Boolean(lhs &lt; rhs),
<a href="#h8-10" id="h8-10" class="h">@@ -201,16 +205,18 @@ impl Expression {
</a>                 (Null, _) | (_, Null) =&gt; Null,
                 (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t compare {lhs} and {rhs}&quot;),
             },
<a href="#h8-10-3" id="h8-10-3" class="i">+
</a>             Self::Is(expr, Null) =&gt; Boolean(expr.evaluate(row)? == Null),
             Self::Is(expr, Float(f)) if f.is_nan() =&gt; match expr.evaluate(row)? {
                 Float(f) =&gt; Boolean(f.is_nan()),
                 Null =&gt; Null,
                 v =&gt; return errinput!(&quot;IS NAN can&#39;t be used with {}&quot;, v.datatype().unwrap()),
             },
<a href="#h8-10-10" id="h8-10-10" class="d">-            Self::Is(_, v) =&gt; return errinput!(&quot;invalid IS value {v}&quot;),
</a><a href="#h8-10-11" id="h8-10-11" class="i">+            Self::Is(_, v) =&gt; panic!(&quot;invalid IS value {v}&quot;), // enforced by parser
</a> 
             // Mathematical operations. Inputs must be numbers, but integers and
             // floats are interchangeable (float when mixed). NULLs yield NULL.
<a href="#h8-10-15" id="h8-10-15" class="i">+            // Errors on integer overflow, while floats yield infinity or NaN.
</a>             Self::Add(lhs, rhs) =&gt; lhs.evaluate(row)?.checked_add(&amp;rhs.evaluate(row)?)?,
             Self::Divide(lhs, rhs) =&gt; lhs.evaluate(row)?.checked_div(&amp;rhs.evaluate(row)?)?,
             Self::Exponentiate(lhs, rhs) =&gt; lhs.evaluate(row)?.checked_pow(&amp;rhs.evaluate(row)?)?,
<a href="#h8-11" id="h8-11" class="h">@@ -233,7 +239,8 @@ impl Expression {
</a>             },
             Self::Remainder(lhs, rhs) =&gt; lhs.evaluate(row)?.checked_rem(&amp;rhs.evaluate(row)?)?,
             Self::SquareRoot(expr) =&gt; match expr.evaluate(row)? {
<a href="#h8-11-3" id="h8-11-3" class="d">-                Integer(i) if i &gt;= 0 =&gt; Float((i as f64).sqrt()),
</a><a href="#h8-11-4" id="h8-11-4" class="i">+                Integer(i) if i &lt; 0 =&gt; return errinput!(&quot;can&#39;t take negative square root&quot;),
</a><a href="#h8-11-5" id="h8-11-5" class="i">+                Integer(i) =&gt; Float((i as f64).sqrt()),
</a>                 Float(f) =&gt; Float(f.sqrt()),
                 Null =&gt; Null,
                 value =&gt; return errinput!(&quot;can&#39;t take square root of {value}&quot;),
<a href="#h8-12" id="h8-12" class="h">@@ -245,6 +252,8 @@ impl Expression {
</a>             // NULL. There&#39;s no support for escaping an _ and %.
             Self::Like(lhs, rhs) =&gt; match (lhs.evaluate(row)?, rhs.evaluate(row)?) {
                 (String(lhs), String(rhs)) =&gt; {
<a href="#h8-12-3" id="h8-12-3" class="i">+                    // We could precompile the pattern if it&#39;s constant, instead
</a><a href="#h8-12-4" id="h8-12-4" class="i">+                    // of recompiling it for every row, but this is fine.
</a>                     let pattern =
                         format!(&quot;^{}$&quot;, regex::escape(&amp;rhs).replace(&#39;%&#39;, &quot;.*&quot;).replace(&#39;_&#39;, &quot;.&quot;));
                     Boolean(regex::Regex::new(&amp;pattern)?.is_match(&amp;lhs))
<a href="#h8-13" id="h8-13" class="h">@@ -258,30 +267,32 @@ impl Expression {
</a>     /// Recursively walks the expression tree depth-first, calling the given
     /// closure until it returns false. Returns true otherwise.
     pub fn walk(&amp;self, visitor: &amp;mut impl FnMut(&amp;Expression) -&gt; bool) -&gt; bool {
<a href="#h8-13-3" id="h8-13-3" class="d">-        visitor(self)
</a><a href="#h8-13-4" id="h8-13-4" class="d">-            &amp;&amp; match self {
</a><a href="#h8-13-5" id="h8-13-5" class="d">-                Self::Add(lhs, rhs)
</a><a href="#h8-13-6" id="h8-13-6" class="d">-                | Self::And(lhs, rhs)
</a><a href="#h8-13-7" id="h8-13-7" class="d">-                | Self::Divide(lhs, rhs)
</a><a href="#h8-13-8" id="h8-13-8" class="d">-                | Self::Equal(lhs, rhs)
</a><a href="#h8-13-9" id="h8-13-9" class="d">-                | Self::Exponentiate(lhs, rhs)
</a><a href="#h8-13-10" id="h8-13-10" class="d">-                | Self::GreaterThan(lhs, rhs)
</a><a href="#h8-13-11" id="h8-13-11" class="d">-                | Self::LessThan(lhs, rhs)
</a><a href="#h8-13-12" id="h8-13-12" class="d">-                | Self::Like(lhs, rhs)
</a><a href="#h8-13-13" id="h8-13-13" class="d">-                | Self::Multiply(lhs, rhs)
</a><a href="#h8-13-14" id="h8-13-14" class="d">-                | Self::Or(lhs, rhs)
</a><a href="#h8-13-15" id="h8-13-15" class="d">-                | Self::Remainder(lhs, rhs)
</a><a href="#h8-13-16" id="h8-13-16" class="d">-                | Self::Subtract(lhs, rhs) =&gt; lhs.walk(visitor) &amp;&amp; rhs.walk(visitor),
</a><a href="#h8-13-17" id="h8-13-17" class="d">-
</a><a href="#h8-13-18" id="h8-13-18" class="d">-                Self::Factorial(expr)
</a><a href="#h8-13-19" id="h8-13-19" class="d">-                | Self::Identity(expr)
</a><a href="#h8-13-20" id="h8-13-20" class="d">-                | Self::Is(expr, _)
</a><a href="#h8-13-21" id="h8-13-21" class="d">-                | Self::Negate(expr)
</a><a href="#h8-13-22" id="h8-13-22" class="d">-                | Self::Not(expr)
</a><a href="#h8-13-23" id="h8-13-23" class="d">-                | Self::SquareRoot(expr) =&gt; expr.walk(visitor),
</a><a href="#h8-13-24" id="h8-13-24" class="d">-
</a><a href="#h8-13-25" id="h8-13-25" class="d">-                Self::Constant(_) | Self::Column(_) =&gt; true,
</a><a href="#h8-13-26" id="h8-13-26" class="d">-            }
</a><a href="#h8-13-27" id="h8-13-27" class="i">+        if !visitor(self) {
</a><a href="#h8-13-28" id="h8-13-28" class="i">+            return false;
</a><a href="#h8-13-29" id="h8-13-29" class="i">+        }
</a><a href="#h8-13-30" id="h8-13-30" class="i">+        match self {
</a><a href="#h8-13-31" id="h8-13-31" class="i">+            Self::Add(lhs, rhs)
</a><a href="#h8-13-32" id="h8-13-32" class="i">+            | Self::And(lhs, rhs)
</a><a href="#h8-13-33" id="h8-13-33" class="i">+            | Self::Divide(lhs, rhs)
</a><a href="#h8-13-34" id="h8-13-34" class="i">+            | Self::Equal(lhs, rhs)
</a><a href="#h8-13-35" id="h8-13-35" class="i">+            | Self::Exponentiate(lhs, rhs)
</a><a href="#h8-13-36" id="h8-13-36" class="i">+            | Self::GreaterThan(lhs, rhs)
</a><a href="#h8-13-37" id="h8-13-37" class="i">+            | Self::LessThan(lhs, rhs)
</a><a href="#h8-13-38" id="h8-13-38" class="i">+            | Self::Like(lhs, rhs)
</a><a href="#h8-13-39" id="h8-13-39" class="i">+            | Self::Multiply(lhs, rhs)
</a><a href="#h8-13-40" id="h8-13-40" class="i">+            | Self::Or(lhs, rhs)
</a><a href="#h8-13-41" id="h8-13-41" class="i">+            | Self::Remainder(lhs, rhs)
</a><a href="#h8-13-42" id="h8-13-42" class="i">+            | Self::Subtract(lhs, rhs) =&gt; lhs.walk(visitor) &amp;&amp; rhs.walk(visitor),
</a><a href="#h8-13-43" id="h8-13-43" class="i">+
</a><a href="#h8-13-44" id="h8-13-44" class="i">+            Self::Factorial(expr)
</a><a href="#h8-13-45" id="h8-13-45" class="i">+            | Self::Identity(expr)
</a><a href="#h8-13-46" id="h8-13-46" class="i">+            | Self::Is(expr, _)
</a><a href="#h8-13-47" id="h8-13-47" class="i">+            | Self::Negate(expr)
</a><a href="#h8-13-48" id="h8-13-48" class="i">+            | Self::Not(expr)
</a><a href="#h8-13-49" id="h8-13-49" class="i">+            | Self::SquareRoot(expr) =&gt; expr.walk(visitor),
</a><a href="#h8-13-50" id="h8-13-50" class="i">+
</a><a href="#h8-13-51" id="h8-13-51" class="i">+            Self::Constant(_) | Self::Column(_) =&gt; true,
</a><a href="#h8-13-52" id="h8-13-52" class="i">+        }
</a>     }
 
     /// Recursively walks the expression tree depth-first, calling the given
<a href="#h8-14" id="h8-14" class="h">@@ -291,40 +302,40 @@ impl Expression {
</a>         !self.walk(&amp;mut |e| !visitor(e))
     }
 
<a href="#h8-14-3" id="h8-14-3" class="d">-    /// Transforms the expression tree by recursively applying the given
</a><a href="#h8-14-4" id="h8-14-4" class="d">-    /// closures depth-first to each node before/after descending.
</a><a href="#h8-14-5" id="h8-14-5" class="d">-    pub fn transform&lt;B, A&gt;(mut self, before: &amp;B, after: &amp;A) -&gt; Result&lt;Self&gt;
</a><a href="#h8-14-6" id="h8-14-6" class="d">-    where
</a><a href="#h8-14-7" id="h8-14-7" class="d">-        B: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h8-14-8" id="h8-14-8" class="d">-        A: Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h8-14-9" id="h8-14-9" class="d">-    {
</a><a href="#h8-14-10" id="h8-14-10" class="i">+    /// Transforms the expression by recursively applying the given closures
</a><a href="#h8-14-11" id="h8-14-11" class="i">+    /// depth-first to each node before/after descending.
</a><a href="#h8-14-12" id="h8-14-12" class="i">+    pub fn transform(
</a><a href="#h8-14-13" id="h8-14-13" class="i">+        mut self,
</a><a href="#h8-14-14" id="h8-14-14" class="i">+        before: &amp;impl Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h8-14-15" id="h8-14-15" class="i">+        after: &amp;impl Fn(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h8-14-16" id="h8-14-16" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a>         // Helper for transforming boxed expressions.
<a href="#h8-14-18" id="h8-14-18" class="d">-        let transform = |mut expr: Box&lt;Expression&gt;| -&gt; Result&lt;Box&lt;Expression&gt;&gt; {
</a><a href="#h8-14-19" id="h8-14-19" class="i">+        let xform = |mut expr: Box&lt;Expression&gt;| -&gt; Result&lt;Box&lt;Expression&gt;&gt; {
</a>             *expr = expr.transform(before, after)?;
             Ok(expr)
         };
 
         self = before(self)?;
         self = match self {
<a href="#h8-14-26" id="h8-14-26" class="d">-            Self::Add(lhs, rhs) =&gt; Self::Add(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-27" id="h8-14-27" class="d">-            Self::And(lhs, rhs) =&gt; Self::And(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-28" id="h8-14-28" class="d">-            Self::Divide(lhs, rhs) =&gt; Self::Divide(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-29" id="h8-14-29" class="d">-            Self::Equal(lhs, rhs) =&gt; Self::Equal(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-30" id="h8-14-30" class="d">-            Self::Exponentiate(lhs, rhs) =&gt; Self::Exponentiate(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-31" id="h8-14-31" class="d">-            Self::GreaterThan(lhs, rhs) =&gt; Self::GreaterThan(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-32" id="h8-14-32" class="d">-            Self::LessThan(lhs, rhs) =&gt; Self::LessThan(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-33" id="h8-14-33" class="d">-            Self::Like(lhs, rhs) =&gt; Self::Like(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-34" id="h8-14-34" class="d">-            Self::Multiply(lhs, rhs) =&gt; Self::Multiply(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-35" id="h8-14-35" class="d">-            Self::Or(lhs, rhs) =&gt; Self::Or(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-36" id="h8-14-36" class="d">-            Self::Remainder(lhs, rhs) =&gt; Self::Remainder(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-37" id="h8-14-37" class="d">-            Self::SquareRoot(expr) =&gt; Self::SquareRoot(transform(expr)?),
</a><a href="#h8-14-38" id="h8-14-38" class="d">-            Self::Subtract(lhs, rhs) =&gt; Self::Subtract(transform(lhs)?, transform(rhs)?),
</a><a href="#h8-14-39" id="h8-14-39" class="d">-
</a><a href="#h8-14-40" id="h8-14-40" class="d">-            Self::Factorial(expr) =&gt; Self::Factorial(transform(expr)?),
</a><a href="#h8-14-41" id="h8-14-41" class="d">-            Self::Identity(expr) =&gt; Self::Identity(transform(expr)?),
</a><a href="#h8-14-42" id="h8-14-42" class="d">-            Self::Is(expr, value) =&gt; Self::Is(transform(expr)?, value),
</a><a href="#h8-14-43" id="h8-14-43" class="d">-            Self::Negate(expr) =&gt; Self::Negate(transform(expr)?),
</a><a href="#h8-14-44" id="h8-14-44" class="d">-            Self::Not(expr) =&gt; Self::Not(transform(expr)?),
</a><a href="#h8-14-45" id="h8-14-45" class="i">+            Self::Add(lhs, rhs) =&gt; Self::Add(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-46" id="h8-14-46" class="i">+            Self::And(lhs, rhs) =&gt; Self::And(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-47" id="h8-14-47" class="i">+            Self::Divide(lhs, rhs) =&gt; Self::Divide(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-48" id="h8-14-48" class="i">+            Self::Equal(lhs, rhs) =&gt; Self::Equal(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-49" id="h8-14-49" class="i">+            Self::Exponentiate(lhs, rhs) =&gt; Self::Exponentiate(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-50" id="h8-14-50" class="i">+            Self::GreaterThan(lhs, rhs) =&gt; Self::GreaterThan(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-51" id="h8-14-51" class="i">+            Self::LessThan(lhs, rhs) =&gt; Self::LessThan(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-52" id="h8-14-52" class="i">+            Self::Like(lhs, rhs) =&gt; Self::Like(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-53" id="h8-14-53" class="i">+            Self::Multiply(lhs, rhs) =&gt; Self::Multiply(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-54" id="h8-14-54" class="i">+            Self::Or(lhs, rhs) =&gt; Self::Or(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-55" id="h8-14-55" class="i">+            Self::Remainder(lhs, rhs) =&gt; Self::Remainder(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-56" id="h8-14-56" class="i">+            Self::SquareRoot(expr) =&gt; Self::SquareRoot(xform(expr)?),
</a><a href="#h8-14-57" id="h8-14-57" class="i">+            Self::Subtract(lhs, rhs) =&gt; Self::Subtract(xform(lhs)?, xform(rhs)?),
</a><a href="#h8-14-58" id="h8-14-58" class="i">+
</a><a href="#h8-14-59" id="h8-14-59" class="i">+            Self::Factorial(expr) =&gt; Self::Factorial(xform(expr)?),
</a><a href="#h8-14-60" id="h8-14-60" class="i">+            Self::Identity(expr) =&gt; Self::Identity(xform(expr)?),
</a><a href="#h8-14-61" id="h8-14-61" class="i">+            Self::Is(expr, value) =&gt; Self::Is(xform(expr)?, value),
</a><a href="#h8-14-62" id="h8-14-62" class="i">+            Self::Negate(expr) =&gt; Self::Negate(xform(expr)?),
</a><a href="#h8-14-63" id="h8-14-63" class="i">+            Self::Not(expr) =&gt; Self::Not(xform(expr)?),
</a> 
             expr @ (Self::Constant(_) | Self::Column(_)) =&gt; expr,
         };
<a href="#h8-15" id="h8-15" class="h">@@ -337,7 +348,7 @@ impl Expression {
</a>     /// to negation normal form and then applying De Morgan&#39;s distributive law.
     pub fn into_cnf(self) -&gt; Self {
         use Expression::*;
<a href="#h8-15-3" id="h8-15-3" class="d">-        let transform = |expr| {
</a><a href="#h8-15-4" id="h8-15-4" class="i">+        let xform = |expr| {
</a>             // We can&#39;t use a single match, since it needs deref patterns.
             let Or(lhs, rhs) = expr else { return expr };
             match (*lhs, *rhs) {
<a href="#h8-16" id="h8-16" class="h">@@ -349,7 +360,7 @@ impl Expression {
</a>                 (lhs, rhs) =&gt; Or(lhs.into(), rhs.into()),
             }
         };
<a href="#h8-16-3" id="h8-16-3" class="d">-        self.into_nnf().transform(&amp;|e| Ok(transform(e)), &amp;Ok).unwrap() // never fails
</a><a href="#h8-16-4" id="h8-16-4" class="i">+        self.into_nnf().transform(&amp;|e| Ok(xform(e)), &amp;Ok).unwrap() // infallible
</a>     }
 
     /// Converts the expression into negation normal form. This pushes NOT
<a href="#h8-17" id="h8-17" class="h">@@ -358,7 +369,7 @@ impl Expression {
</a>     /// applying other logical normalizations.
     pub fn into_nnf(self) -&gt; Self {
         use Expression::*;
<a href="#h8-17-3" id="h8-17-3" class="d">-        let transform = |expr| {
</a><a href="#h8-17-4" id="h8-17-4" class="i">+        let xform = |expr| {
</a>             let Not(inner) = expr else { return expr };
             match *inner {
                 // NOT (x AND y) → (NOT x) OR (NOT y)
<a href="#h8-18" id="h8-18" class="h">@@ -371,7 +382,7 @@ impl Expression {
</a>                 expr =&gt; Not(expr.into()),
             }
         };
<a href="#h8-18-3" id="h8-18-3" class="d">-        self.transform(&amp;|e| Ok(transform(e)), &amp;Ok).unwrap() // never fails
</a><a href="#h8-18-4" id="h8-18-4" class="i">+        self.transform(&amp;|e| Ok(xform(e)), &amp;Ok).unwrap() // never fails
</a>     }
 
     /// Converts the expression into conjunctive normal form as a vector of
<a href="#h8-19" id="h8-19" class="h">@@ -381,7 +392,7 @@ impl Expression {
</a>         let mut stack = vec![self.into_cnf()];
         while let Some(expr) = stack.pop() {
             if let Self::And(lhs, rhs) = expr {
<a href="#h8-19-3" id="h8-19-3" class="d">-                stack.extend([*rhs, *lhs]); // put LHS last to process next
</a><a href="#h8-19-4" id="h8-19-4" class="i">+                stack.extend([*rhs, *lhs]); // push lhs last to pop it first
</a>             } else {
                 cnf.push(expr);
             }
<a href="#h8-20" id="h8-20" class="h">@@ -400,25 +411,23 @@ impl Expression {
</a>     }
 
     /// Checks if an expression is a single column lookup (i.e. a disjunction of
<a href="#h8-20-3" id="h8-20-3" class="d">-    /// = or IS NULL/NAN referencing a single column), returning the column
</a><a href="#h8-20-4" id="h8-20-4" class="d">-    /// index.
</a><a href="#h8-20-5" id="h8-20-5" class="i">+    /// = or IS NULL/NAN for a single column), returning the column index.
</a>     pub fn is_column_lookup(&amp;self) -&gt; Option&lt;usize&gt; {
         use Expression::*;
         match &amp;self {
<a href="#h8-20-9" id="h8-20-9" class="d">-            // Equality comparisons with = between column and constant value can
</a><a href="#h8-20-10" id="h8-20-10" class="d">-            // use index lookups. NULL and NaN won&#39;t return any matches, but we
</a><a href="#h8-20-11" id="h8-20-11" class="d">-            // handle this in into_column_values().
</a><a href="#h8-20-12" id="h8-20-12" class="i">+            // Column/constant equality can use index lookups. NULL and NaN are
</a><a href="#h8-20-13" id="h8-20-13" class="i">+            // handled in into_column_values().
</a>             Equal(lhs, rhs) =&gt; match (lhs.as_ref(), rhs.as_ref()) {
<a href="#h8-20-15" id="h8-20-15" class="d">-                (Column(f), Constant(_)) | (Constant(_), Column(f)) =&gt; Some(*f),
</a><a href="#h8-20-16" id="h8-20-16" class="i">+                (Column(c), Constant(_)) | (Constant(_), Column(c)) =&gt; Some(*c),
</a>                 _ =&gt; None,
             },
             // IS NULL and IS NAN can use index lookups.
             Is(expr, _) =&gt; match expr.as_ref() {
<a href="#h8-20-21" id="h8-20-21" class="d">-                Column(f) =&gt; Some(*f),
</a><a href="#h8-20-22" id="h8-20-22" class="i">+                Column(c) =&gt; Some(*c),
</a>                 _ =&gt; None,
             },
<a href="#h8-20-25" id="h8-20-25" class="d">-            // For OR branches, check if all branches are lookups on the same
</a><a href="#h8-20-26" id="h8-20-26" class="d">-            // column, i.e. foo = 1 OR foo = 2 OR foo = 3.
</a><a href="#h8-20-27" id="h8-20-27" class="i">+            // All OR branches must be lookups on the same column:
</a><a href="#h8-20-28" id="h8-20-28" class="i">+            // id = 1 OR id = 2 OR id = 3.
</a>             Or(lhs, rhs) =&gt; match (lhs.is_column_lookup(), rhs.is_column_lookup()) {
                 (Some(l), Some(r)) if l == r =&gt; Some(l),
                 _ =&gt; None,
<a href="#h8-21" id="h8-21" class="h">@@ -427,51 +436,58 @@ impl Expression {
</a>         }
     }
 
<a href="#h8-21-3" id="h8-21-3" class="d">-    /// Converts the expression into a set of single-column lookup values if possible.
</a><a href="#h8-21-4" id="h8-21-4" class="d">-    pub fn into_column_values(self) -&gt; Option&lt;(usize, Vec&lt;Value&gt;)&gt; {
</a><a href="#h8-21-5" id="h8-21-5" class="i">+    /// Extracts column lookup values for the given column. Panics if the
</a><a href="#h8-21-6" id="h8-21-6" class="i">+    /// expression isn&#39;t a lookup of the given column, i.e. is_column_lookup()
</a><a href="#h8-21-7" id="h8-21-7" class="i">+    /// must return true for the expression.
</a><a href="#h8-21-8" id="h8-21-8" class="i">+    pub fn into_column_values(self, index: usize) -&gt; Vec&lt;Value&gt; {
</a>         use Expression::*;
         match self {
             Equal(lhs, rhs) =&gt; match (*lhs, *rhs) {
<a href="#h8-21-12" id="h8-21-12" class="d">-                // NULL and NAN index lookups are for IS NULL and IS NAN.
</a><a href="#h8-21-13" id="h8-21-13" class="d">-                // Equality comparisons with = shouldn&#39;t yield any results, so
</a><a href="#h8-21-14" id="h8-21-14" class="d">-                // just return an empty value set for these.
</a><a href="#h8-21-15" id="h8-21-15" class="d">-                (Column(f), Constant(v)) | (Constant(v), Column(f)) if v.is_undefined() =&gt; {
</a><a href="#h8-21-16" id="h8-21-16" class="d">-                    Some((f, Vec::new()))
</a><a href="#h8-21-17" id="h8-21-17" class="i">+                (Column(column), Constant(value)) | (Constant(value), Column(column)) =&gt; {
</a><a href="#h8-21-18" id="h8-21-18" class="i">+                    assert_eq!(column, index, &quot;unexpected column&quot;);
</a><a href="#h8-21-19" id="h8-21-19" class="i">+                    // NULL and NAN index lookups are for IS NULL and IS NAN.
</a><a href="#h8-21-20" id="h8-21-20" class="i">+                    // Equality shouldn&#39;t match anything, return empty vec.
</a><a href="#h8-21-21" id="h8-21-21" class="i">+                    if value.is_undefined() {
</a><a href="#h8-21-22" id="h8-21-22" class="i">+                        Vec::new()
</a><a href="#h8-21-23" id="h8-21-23" class="i">+                    } else {
</a><a href="#h8-21-24" id="h8-21-24" class="i">+                        vec![value]
</a><a href="#h8-21-25" id="h8-21-25" class="i">+                    }
</a>                 }
<a href="#h8-21-27" id="h8-21-27" class="d">-                (Column(f), Constant(v)) | (Constant(v), Column(f)) =&gt; Some((f, vec![v])),
</a><a href="#h8-21-28" id="h8-21-28" class="d">-                _ =&gt; None,
</a><a href="#h8-21-29" id="h8-21-29" class="i">+                (lhs, rhs) =&gt; panic!(&quot;unexpected expression {:?}&quot;, Equal(lhs.into(), rhs.into())),
</a>             },
             // IS NULL and IS NAN can use index lookups.
             Is(expr, value) =&gt; match *expr {
<a href="#h8-21-33" id="h8-21-33" class="d">-                Column(f) =&gt; Some((f, vec![value])),
</a><a href="#h8-21-34" id="h8-21-34" class="d">-                _ =&gt; None,
</a><a href="#h8-21-35" id="h8-21-35" class="d">-            },
</a><a href="#h8-21-36" id="h8-21-36" class="d">-            Or(lhs, rhs) =&gt; match (lhs.into_column_values(), rhs.into_column_values()) {
</a><a href="#h8-21-37" id="h8-21-37" class="d">-                (Some((l, lvec)), Some((r, rvec))) if l == r =&gt; {
</a><a href="#h8-21-38" id="h8-21-38" class="d">-                    Some((l, lvec.into_iter().chain(rvec).collect()))
</a><a href="#h8-21-39" id="h8-21-39" class="i">+                Column(column) =&gt; {
</a><a href="#h8-21-40" id="h8-21-40" class="i">+                    assert_eq!(column, index, &quot;unexpected column&quot;);
</a><a href="#h8-21-41" id="h8-21-41" class="i">+                    vec![value]
</a>                 }
<a href="#h8-21-43" id="h8-21-43" class="d">-                _ =&gt; None,
</a><a href="#h8-21-44" id="h8-21-44" class="i">+                expr =&gt; panic!(&quot;unexpected expression {expr:?}&quot;),
</a>             },
<a href="#h8-21-46" id="h8-21-46" class="d">-            _ =&gt; None,
</a><a href="#h8-21-47" id="h8-21-47" class="i">+            Or(lhs, rhs) =&gt; {
</a><a href="#h8-21-48" id="h8-21-48" class="i">+                let mut values = lhs.into_column_values(index);
</a><a href="#h8-21-49" id="h8-21-49" class="i">+                values.extend(rhs.into_column_values(index));
</a><a href="#h8-21-50" id="h8-21-50" class="i">+                values
</a><a href="#h8-21-51" id="h8-21-51" class="i">+            }
</a><a href="#h8-21-52" id="h8-21-52" class="i">+            expr =&gt; panic!(&quot;unexpected expression {expr:?}&quot;),
</a>         }
     }
 
     /// Replaces column references with the given column.
     pub fn replace_column(self, from: usize, to: usize) -&gt; Self {
<a href="#h8-21-58" id="h8-21-58" class="d">-        let transform = |expr| match expr {
</a><a href="#h8-21-59" id="h8-21-59" class="i">+        let xform = |expr| match expr {
</a>             Expression::Column(i) if i == from =&gt; Expression::Column(to),
             expr =&gt; expr,
         };
<a href="#h8-21-63" id="h8-21-63" class="d">-        self.transform(&amp;|e| Ok(transform(e)), &amp;Ok).unwrap() // infallible
</a><a href="#h8-21-64" id="h8-21-64" class="i">+        self.transform(&amp;|e| Ok(xform(e)), &amp;Ok).unwrap() // infallible
</a>     }
 
<a href="#h8-21-67" id="h8-21-67" class="d">-    /// Shifts any column indexes by the given amount.
</a><a href="#h8-21-68" id="h8-21-68" class="i">+    /// Shifts column references by the given amount.
</a>     pub fn shift_column(self, diff: isize) -&gt; Self {
<a href="#h8-21-70" id="h8-21-70" class="d">-        let transform = |expr| match expr {
</a><a href="#h8-21-71" id="h8-21-71" class="i">+        let xform = |expr| match expr {
</a>             Expression::Column(i) =&gt; Expression::Column((i as isize + diff) as usize),
             expr =&gt; expr,
         };
<a href="#h8-21-75" id="h8-21-75" class="d">-        self.transform(&amp;|e| Ok(transform(e)), &amp;Ok).unwrap() // infallible
</a><a href="#h8-21-76" id="h8-21-76" class="i">+        self.transform(&amp;|e| Ok(xform(e)), &amp;Ok).unwrap() // infallible
</a>     }
 }
 
<b>diff --git a/<a id="h9" href="../file/src/sql/types/mod.rs.html">src/sql/types/mod.rs</a> b/<a href="../file/src/sql/types/mod.rs.html">src/sql/types/mod.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,3 +1,5 @@
</a><a href="#h9-0-0" id="h9-0-0" class="i">+//! The SQL data model, including data types, expressions, and schema objects.
</a><a href="#h9-0-1" id="h9-0-1" class="i">+
</a> mod expression;
 mod schema;
 mod value;
<b>diff --git a/<a id="h10" href="../file/src/sql/types/schema.rs.html">src/sql/types/schema.rs</a> b/<a href="../file/src/sql/types/schema.rs.html">src/sql/types/schema.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -7,7 +7,7 @@ use crate::sql::engine::{Catalog, Transaction};
</a> use serde::{Deserialize, Serialize};
 use std::borrow::Cow;
 
<a href="#h10-0-3" id="h10-0-3" class="d">-/// A table schema, which specifies the data structure and constraints.
</a><a href="#h10-0-4" id="h10-0-4" class="i">+/// A table schema, which specifies its data structure and constraints.
</a> ///
 /// Tables can&#39;t change after they are created. There is no ALTER TABLE nor
 /// CREATE/DROP INDEX -- only CREATE TABLE and DROP TABLE.
<a href="#h10-1" id="h10-1" class="h">@@ -37,11 +37,12 @@ pub struct Column {
</a>     /// value. Must match the column datatype. Nullable columns require a
     /// default (often Null), and Null is only a valid default when nullable.
     pub default: Option&lt;Value&gt;,
<a href="#h10-1-3" id="h10-1-3" class="d">-    /// Whether the column should only allow unique values. Must be true for a
</a><a href="#h10-1-4" id="h10-1-4" class="d">-    /// primary key column.
</a><a href="#h10-1-5" id="h10-1-5" class="i">+    /// Whether the column should only allow unique values (ignoring NULLs).
</a><a href="#h10-1-6" id="h10-1-6" class="i">+    /// Must be true for a primary key column.
</a>     pub unique: bool,
<a href="#h10-1-8" id="h10-1-8" class="d">-    /// Whether the column should have a secondary index. Never set for primary
</a><a href="#h10-1-9" id="h10-1-9" class="d">-    /// keys, which have an implicit primary index.
</a><a href="#h10-1-10" id="h10-1-10" class="i">+    /// Whether the column should have a secondary index. Must be false for
</a><a href="#h10-1-11" id="h10-1-11" class="i">+    /// primary keys, which are the implicit primary index. Must be true for
</a><a href="#h10-1-12" id="h10-1-12" class="i">+    /// unique or reference columns.
</a>     pub index: bool,
     /// If set, this column is a foreign key reference to the given table&#39;s
     /// primary key. Must be of the same type as the target primary key.
<a href="#h10-2" id="h10-2" class="h">@@ -82,7 +83,8 @@ impl std::fmt::Display for Table {
</a> }
 
 impl Table {
<a href="#h10-2-3" id="h10-2-3" class="d">-    /// Validates the table schema.
</a><a href="#h10-2-4" id="h10-2-4" class="i">+    /// Validates the table schema, using the catalog to validate foreign key
</a><a href="#h10-2-5" id="h10-2-5" class="i">+    /// references.
</a>     pub fn validate(&amp;self, catalog: &amp;impl Catalog) -&gt; Result&lt;()&gt; {
         if self.name.is_empty() {
             return errinput!(&quot;table name can&#39;t be empty&quot;);
<a href="#h10-3" id="h10-3" class="h">@@ -98,7 +100,7 @@ impl Table {
</a>             if column.name.is_empty() {
                 return errinput!(&quot;column name can&#39;t be empty&quot;);
             }
<a href="#h10-3-3" id="h10-3-3" class="d">-            let cname = &amp;column.name; // for formatting convenience
</a><a href="#h10-3-4" id="h10-3-4" class="i">+            let (cname, ctype) = (&amp;column.name, &amp;column.datatype); // for formatting convenience
</a> 
             // Validate primary key.
             let is_primary_key = i == self.primary_key;
<a href="#h10-4" id="h10-4" class="h">@@ -115,20 +117,17 @@ impl Table {
</a>             }
 
             // Validate default value.
<a href="#h10-4-3" id="h10-4-3" class="d">-            match &amp;column.default {
</a><a href="#h10-4-4" id="h10-4-4" class="d">-                Some(Value::Null) if !column.nullable =&gt; {
</a><a href="#h10-4-5" id="h10-4-5" class="d">-                    return errinput!(&quot;invalid NULL default for non-nullable column {cname}&quot;)
</a><a href="#h10-4-6" id="h10-4-6" class="d">-                }
</a><a href="#h10-4-7" id="h10-4-7" class="d">-                Some(Value::Null) =&gt; {}
</a><a href="#h10-4-8" id="h10-4-8" class="d">-                Some(value) if value.datatype().as_ref() != Some(&amp;column.datatype) =&gt; {
</a><a href="#h10-4-9" id="h10-4-9" class="d">-                    let (ctype, vtype) = (&amp;column.datatype, value.datatype().unwrap());
</a><a href="#h10-4-10" id="h10-4-10" class="d">-                    return errinput!(&quot;invalid datatype {vtype} for {ctype} column {cname}&quot;,);
</a><a href="#h10-4-11" id="h10-4-11" class="d">-                }
</a><a href="#h10-4-12" id="h10-4-12" class="d">-                Some(_) =&gt; {}
</a><a href="#h10-4-13" id="h10-4-13" class="i">+            match column.default.as_ref().map(|v| v.datatype()) {
</a>                 None if column.nullable =&gt; {
                     return errinput!(&quot;nullable column {cname} must have a default value&quot;)
                 }
<a href="#h10-4-17" id="h10-4-17" class="d">-                None =&gt; {}
</a><a href="#h10-4-18" id="h10-4-18" class="i">+                Some(None) if !column.nullable =&gt; {
</a><a href="#h10-4-19" id="h10-4-19" class="i">+                    return errinput!(&quot;invalid NULL default for non-nullable column {cname}&quot;)
</a><a href="#h10-4-20" id="h10-4-20" class="i">+                }
</a><a href="#h10-4-21" id="h10-4-21" class="i">+                Some(Some(vtype)) if vtype != column.datatype =&gt; {
</a><a href="#h10-4-22" id="h10-4-22" class="i">+                    return errinput!(&quot;invalid default type {vtype} for {ctype} column {cname}&quot;);
</a><a href="#h10-4-23" id="h10-4-23" class="i">+                }
</a><a href="#h10-4-24" id="h10-4-24" class="i">+                Some(_) | None =&gt; {}
</a>             }
 
             // Validate unique index.
<a href="#h10-5" id="h10-5" class="h">@@ -141,29 +140,30 @@ impl Table {
</a>                 if !column.index &amp;&amp; !is_primary_key {
                     return errinput!(&quot;reference column {cname} must have a secondary index&quot;);
                 }
<a href="#h10-5-3" id="h10-5-3" class="d">-                let target_type = if reference == &amp;self.name {
</a><a href="#h10-5-4" id="h10-5-4" class="i">+                let reftype = if reference == &amp;self.name {
</a>                     self.columns[self.primary_key].datatype
                 } else if let Some(target) = catalog.get_table(reference)? {
                     target.columns[target.primary_key].datatype
                 } else {
                     return errinput!(&quot;unknown table {reference} referenced by column {cname}&quot;);
                 };
<a href="#h10-5-11" id="h10-5-11" class="d">-                if column.datatype != target_type {
</a><a href="#h10-5-12" id="h10-5-12" class="d">-                    return errinput!(
</a><a href="#h10-5-13" id="h10-5-13" class="d">-                        &quot;can&#39;t reference {target_type} primary key of {reference} from {} column {cname}&quot;,
</a><a href="#h10-5-14" id="h10-5-14" class="d">-                        column.datatype,
</a><a href="#h10-5-15" id="h10-5-15" class="d">-                    );
</a><a href="#h10-5-16" id="h10-5-16" class="i">+                if column.datatype != reftype {
</a><a href="#h10-5-17" id="h10-5-17" class="i">+                    return errinput!(&quot;can&#39;t reference {reftype} primary key of {reference} from {ctype} column {cname}&quot;);
</a>                 }
             }
         }
         Ok(())
     }
 
<a href="#h10-5-24" id="h10-5-24" class="d">-    /// Validates a row, including uniqueness constraints and references.
</a><a href="#h10-5-25" id="h10-5-25" class="i">+    /// Validates a row, including uniqueness and reference checks using the
</a><a href="#h10-5-26" id="h10-5-26" class="i">+    /// given transaction.
</a>     ///
     /// If update is true, the row replaces an existing entry with the same
     /// primary key. Otherwise, it is an insert. Primary key changes are
     /// implemented as a delete+insert.
<a href="#h10-5-31" id="h10-5-31" class="i">+    ///
</a><a href="#h10-5-32" id="h10-5-32" class="i">+    /// Validating uniqueness and references individually for each row is not
</a><a href="#h10-5-33" id="h10-5-33" class="i">+    /// performant, but it&#39;s fine for our purposes.
</a>     pub fn validate_row(&amp;self, row: &amp;[Value], update: bool, txn: &amp;impl Transaction) -&gt; Result&lt;()&gt; {
         if row.len() != self.columns.len() {
             return errinput!(&quot;invalid row size for table {}&quot;, self.name);
<b>diff --git a/<a id="h11" href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a> b/<a href="../file/src/sql/types/value.rs.html">src/sql/types/value.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -1,42 +1,20 @@
</a><a href="#h11-0-0" id="h11-0-0" class="d">-use std::borrow::Cow;
</a><a href="#h11-0-1" id="h11-0-1" class="d">-
</a> use crate::encoding;
<a href="#h11-0-3" id="h11-0-3" class="d">-use crate::errdata;
</a><a href="#h11-0-4" id="h11-0-4" class="d">-use crate::errinput;
</a> use crate::error::{Error, Result};
 use crate::sql::parser::ast;
<a href="#h11-0-7" id="h11-0-7" class="i">+use crate::{errdata, errinput};
</a> 
 use dyn_clone::DynClone;
 use serde::{Deserialize, Serialize};
<a href="#h11-0-11" id="h11-0-11" class="i">+use std::borrow::Cow;
</a> 
<a href="#h11-0-13" id="h11-0-13" class="d">-/// A primitive data type.
</a><a href="#h11-0-14" id="h11-0-14" class="d">-#[derive(Clone, Copy, Debug, Hash, PartialEq, Serialize, Deserialize)]
</a><a href="#h11-0-15" id="h11-0-15" class="d">-pub enum DataType {
</a><a href="#h11-0-16" id="h11-0-16" class="d">-    /// A boolean: true or false.
</a><a href="#h11-0-17" id="h11-0-17" class="d">-    Boolean,
</a><a href="#h11-0-18" id="h11-0-18" class="d">-    /// A 64-bit signed integer.
</a><a href="#h11-0-19" id="h11-0-19" class="d">-    Integer,
</a><a href="#h11-0-20" id="h11-0-20" class="d">-    /// A 64-bit floating point number.
</a><a href="#h11-0-21" id="h11-0-21" class="d">-    Float,
</a><a href="#h11-0-22" id="h11-0-22" class="d">-    /// A UTF-8 encoded string.
</a><a href="#h11-0-23" id="h11-0-23" class="d">-    String,
</a><a href="#h11-0-24" id="h11-0-24" class="d">-}
</a><a href="#h11-0-25" id="h11-0-25" class="d">-
</a><a href="#h11-0-26" id="h11-0-26" class="d">-impl std::fmt::Display for DataType {
</a><a href="#h11-0-27" id="h11-0-27" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
</a><a href="#h11-0-28" id="h11-0-28" class="d">-        f.write_str(match self {
</a><a href="#h11-0-29" id="h11-0-29" class="d">-            Self::Boolean =&gt; &quot;BOOLEAN&quot;,
</a><a href="#h11-0-30" id="h11-0-30" class="d">-            Self::Integer =&gt; &quot;INTEGER&quot;,
</a><a href="#h11-0-31" id="h11-0-31" class="d">-            Self::Float =&gt; &quot;FLOAT&quot;,
</a><a href="#h11-0-32" id="h11-0-32" class="d">-            Self::String =&gt; &quot;STRING&quot;,
</a><a href="#h11-0-33" id="h11-0-33" class="d">-        })
</a><a href="#h11-0-34" id="h11-0-34" class="d">-    }
</a><a href="#h11-0-35" id="h11-0-35" class="d">-}
</a><a href="#h11-0-36" id="h11-0-36" class="d">-
</a><a href="#h11-0-37" id="h11-0-37" class="d">-/// A primitive value.
</a><a href="#h11-0-38" id="h11-0-38" class="i">+/// A primitive SQL value.
</a><a href="#h11-0-39" id="h11-0-39" class="i">+///
</a><a href="#h11-0-40" id="h11-0-40" class="i">+/// For simplicity, only a handful of representative scalar types are supported,
</a><a href="#h11-0-41" id="h11-0-41" class="i">+/// no compound types or more compact variants.
</a> ///
<a href="#h11-0-43" id="h11-0-43" class="d">-/// Unlike SQL and IEEE 754 floating point, Null and NaN are considered equal
</a><a href="#h11-0-44" id="h11-0-44" class="d">-/// and comparable in code. This is necessary to allow sorting and processing of
</a><a href="#h11-0-45" id="h11-0-45" class="i">+/// In SQL, neither Null nor floating point NaN are considered equal to
</a><a href="#h11-0-46" id="h11-0-46" class="i">+/// themselves (they are unknown values). However, in code, we consider them
</a><a href="#h11-0-47" id="h11-0-47" class="i">+/// equal and comparable. This is necessary to allow sorting and processing of
</a> /// these values (e.g. in index lookups, aggregation buckets, etc.). SQL
 /// expression evaluation have special handling of these values to produce the
 /// desired NULL != NULL and NAN != NAN semantics in SQL queries.
<a href="#h11-1" id="h11-1" class="h">@@ -67,9 +45,9 @@ impl std::cmp::PartialEq for Value {
</a>         match (self, other) {
             (Self::Boolean(l), Self::Boolean(r)) =&gt; l == r,
             (Self::Integer(l), Self::Integer(r)) =&gt; l == r,
<a href="#h11-1-3" id="h11-1-3" class="d">-            (Self::Float(l), Self::Float(r)) =&gt; l.is_nan() &amp;&amp; r.is_nan() || l == r,
</a><a href="#h11-1-4" id="h11-1-4" class="i">+            (Self::Float(l), Self::Float(r)) =&gt; l == r || l.is_nan() &amp;&amp; r.is_nan(),
</a>             (Self::String(l), Self::String(r)) =&gt; l == r,
<a href="#h11-1-6" id="h11-1-6" class="d">-            _ =&gt; core::mem::discriminant(self) == core::mem::discriminant(other),
</a><a href="#h11-1-7" id="h11-1-7" class="i">+            (l, r) =&gt; core::mem::discriminant(l) == core::mem::discriminant(r),
</a>         }
     }
 }
<a href="#h11-2" id="h11-2" class="h">@@ -84,7 +62,7 @@ impl std::hash::Hash for Value {
</a>             Self::Null =&gt; {}
             Self::Boolean(v) =&gt; v.hash(state),
             Self::Integer(v) =&gt; v.hash(state),
<a href="#h11-2-3" id="h11-2-3" class="d">-            Self::Float(v) =&gt; v.to_be_bytes().hash(state),
</a><a href="#h11-2-4" id="h11-2-4" class="i">+            Self::Float(v) =&gt; v.to_bits().hash(state),
</a>             Self::String(v) =&gt; v.hash(state),
         }
     }
<a href="#h11-3" id="h11-3" class="h">@@ -94,27 +72,26 @@ impl std::hash::Hash for Value {
</a> // order across all types, even though mixed types will rarely/never come up.
 impl Ord for Value {
     fn cmp(&amp;self, other: &amp;Self) -&gt; std::cmp::Ordering {
<a href="#h11-3-3" id="h11-3-3" class="d">-        use std::cmp::Ordering;
</a><a href="#h11-3-4" id="h11-3-4" class="d">-        #[allow(unreachable_patterns)]
</a><a href="#h11-3-5" id="h11-3-5" class="i">+        use std::cmp::Ordering::*;
</a><a href="#h11-3-6" id="h11-3-6" class="i">+        use Value::*;
</a>         match (self, other) {
<a href="#h11-3-8" id="h11-3-8" class="d">-            (Self::Null, Self::Null) =&gt; Ordering::Equal,
</a><a href="#h11-3-9" id="h11-3-9" class="d">-            (Self::Boolean(a), Self::Boolean(b)) =&gt; a.cmp(b),
</a><a href="#h11-3-10" id="h11-3-10" class="d">-            (Self::Integer(a), Self::Integer(b)) =&gt; a.cmp(b),
</a><a href="#h11-3-11" id="h11-3-11" class="d">-            (Self::Integer(a), Self::Float(b)) =&gt; (*a as f64).total_cmp(b),
</a><a href="#h11-3-12" id="h11-3-12" class="d">-            (Self::Float(a), Self::Integer(b)) =&gt; a.total_cmp(&amp;(*b as f64)),
</a><a href="#h11-3-13" id="h11-3-13" class="d">-            (Self::Float(a), Self::Float(b)) =&gt; a.total_cmp(b),
</a><a href="#h11-3-14" id="h11-3-14" class="d">-            (Self::String(a), Self::String(b)) =&gt; a.cmp(b),
</a><a href="#h11-3-15" id="h11-3-15" class="d">-
</a><a href="#h11-3-16" id="h11-3-16" class="d">-            (Self::Null, _) =&gt; Ordering::Less,
</a><a href="#h11-3-17" id="h11-3-17" class="d">-            (_, Self::Null) =&gt; Ordering::Greater,
</a><a href="#h11-3-18" id="h11-3-18" class="d">-            (Self::Boolean(_), _) =&gt; Ordering::Less,
</a><a href="#h11-3-19" id="h11-3-19" class="d">-            (_, Self::Boolean(_)) =&gt; Ordering::Greater,
</a><a href="#h11-3-20" id="h11-3-20" class="d">-            (Self::Float(_), _) =&gt; Ordering::Less,
</a><a href="#h11-3-21" id="h11-3-21" class="d">-            (_, Self::Float(_)) =&gt; Ordering::Greater,
</a><a href="#h11-3-22" id="h11-3-22" class="d">-            (Self::Integer(_), _) =&gt; Ordering::Less,
</a><a href="#h11-3-23" id="h11-3-23" class="d">-            (_, Self::Integer(_)) =&gt; Ordering::Greater,
</a><a href="#h11-3-24" id="h11-3-24" class="d">-            (Self::String(_), _) =&gt; Ordering::Less,
</a><a href="#h11-3-25" id="h11-3-25" class="d">-            (_, Self::String(_)) =&gt; Ordering::Greater,
</a><a href="#h11-3-26" id="h11-3-26" class="i">+            (Null, Null) =&gt; Equal,
</a><a href="#h11-3-27" id="h11-3-27" class="i">+            (Boolean(a), Boolean(b)) =&gt; a.cmp(b),
</a><a href="#h11-3-28" id="h11-3-28" class="i">+            (Integer(a), Integer(b)) =&gt; a.cmp(b),
</a><a href="#h11-3-29" id="h11-3-29" class="i">+            (Integer(a), Float(b)) =&gt; (*a as f64).total_cmp(b),
</a><a href="#h11-3-30" id="h11-3-30" class="i">+            (Float(a), Integer(b)) =&gt; a.total_cmp(&amp;(*b as f64)),
</a><a href="#h11-3-31" id="h11-3-31" class="i">+            (Float(a), Float(b)) =&gt; a.total_cmp(b),
</a><a href="#h11-3-32" id="h11-3-32" class="i">+            (String(a), String(b)) =&gt; a.cmp(b),
</a><a href="#h11-3-33" id="h11-3-33" class="i">+
</a><a href="#h11-3-34" id="h11-3-34" class="i">+            (Null, _) =&gt; Less,
</a><a href="#h11-3-35" id="h11-3-35" class="i">+            (_, Null) =&gt; Greater,
</a><a href="#h11-3-36" id="h11-3-36" class="i">+            (Boolean(_), _) =&gt; Less,
</a><a href="#h11-3-37" id="h11-3-37" class="i">+            (_, Boolean(_)) =&gt; Greater,
</a><a href="#h11-3-38" id="h11-3-38" class="i">+            (Float(_), _) =&gt; Less,
</a><a href="#h11-3-39" id="h11-3-39" class="i">+            (_, Float(_)) =&gt; Greater,
</a><a href="#h11-3-40" id="h11-3-40" class="i">+            (Integer(_), _) =&gt; Less,
</a><a href="#h11-3-41" id="h11-3-41" class="i">+            (_, Integer(_)) =&gt; Greater,
</a><a href="#h11-3-42" id="h11-3-42" class="i">+            // String is ordered last.
</a>         }
     }
 }
<a href="#h11-4" id="h11-4" class="h">@@ -158,6 +135,23 @@ impl Value {
</a>         })
     }
 
<a href="#h11-4-3" id="h11-4-3" class="i">+    /// Multiplies two values. Errors when invalid.
</a><a href="#h11-4-4" id="h11-4-4" class="i">+    pub fn checked_mul(&amp;self, other: &amp;Self) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-4-5" id="h11-4-5" class="i">+        use Value::*;
</a><a href="#h11-4-6" id="h11-4-6" class="i">+        Ok(match (self, other) {
</a><a href="#h11-4-7" id="h11-4-7" class="i">+            (Integer(lhs), Integer(rhs)) =&gt; match lhs.checked_mul(*rhs) {
</a><a href="#h11-4-8" id="h11-4-8" class="i">+                Some(i) =&gt; Integer(i),
</a><a href="#h11-4-9" id="h11-4-9" class="i">+                None =&gt; return errinput!(&quot;integer overflow&quot;),
</a><a href="#h11-4-10" id="h11-4-10" class="i">+            },
</a><a href="#h11-4-11" id="h11-4-11" class="i">+            (Integer(lhs), Float(rhs)) =&gt; Float(*lhs as f64 * rhs),
</a><a href="#h11-4-12" id="h11-4-12" class="i">+            (Float(lhs), Integer(rhs)) =&gt; Float(lhs * *rhs as f64),
</a><a href="#h11-4-13" id="h11-4-13" class="i">+            (Float(lhs), Float(rhs)) =&gt; Float(lhs * rhs),
</a><a href="#h11-4-14" id="h11-4-14" class="i">+            (Null, Integer(_) | Float(_) | Null) =&gt; Null,
</a><a href="#h11-4-15" id="h11-4-15" class="i">+            (Integer(_) | Float(_), Null) =&gt; Null,
</a><a href="#h11-4-16" id="h11-4-16" class="i">+            (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t multiply {lhs} and {rhs}&quot;),
</a><a href="#h11-4-17" id="h11-4-17" class="i">+        })
</a><a href="#h11-4-18" id="h11-4-18" class="i">+    }
</a><a href="#h11-4-19" id="h11-4-19" class="i">+
</a>     /// Exponentiates two values. Errors when invalid.
     pub fn checked_pow(&amp;self, other: &amp;Self) -&gt; Result&lt;Self&gt; {
         use Value::*;
<a href="#h11-5" id="h11-5" class="h">@@ -179,23 +173,6 @@ impl Value {
</a>         })
     }
 
<a href="#h11-5-3" id="h11-5-3" class="d">-    /// Multiplies two values. Errors when invalid.
</a><a href="#h11-5-4" id="h11-5-4" class="d">-    pub fn checked_mul(&amp;self, other: &amp;Self) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-5-5" id="h11-5-5" class="d">-        use Value::*;
</a><a href="#h11-5-6" id="h11-5-6" class="d">-        Ok(match (self, other) {
</a><a href="#h11-5-7" id="h11-5-7" class="d">-            (Integer(lhs), Integer(rhs)) =&gt; match lhs.checked_mul(*rhs) {
</a><a href="#h11-5-8" id="h11-5-8" class="d">-                Some(i) =&gt; Integer(i),
</a><a href="#h11-5-9" id="h11-5-9" class="d">-                None =&gt; return errinput!(&quot;integer overflow&quot;),
</a><a href="#h11-5-10" id="h11-5-10" class="d">-            },
</a><a href="#h11-5-11" id="h11-5-11" class="d">-            (Integer(lhs), Float(rhs)) =&gt; Float(*lhs as f64 * rhs),
</a><a href="#h11-5-12" id="h11-5-12" class="d">-            (Float(lhs), Integer(rhs)) =&gt; Float(lhs * *rhs as f64),
</a><a href="#h11-5-13" id="h11-5-13" class="d">-            (Float(lhs), Float(rhs)) =&gt; Float(lhs * rhs),
</a><a href="#h11-5-14" id="h11-5-14" class="d">-            (Null, Integer(_) | Float(_) | Null) =&gt; Null,
</a><a href="#h11-5-15" id="h11-5-15" class="d">-            (Integer(_) | Float(_), Null) =&gt; Null,
</a><a href="#h11-5-16" id="h11-5-16" class="d">-            (lhs, rhs) =&gt; return errinput!(&quot;can&#39;t multiply {lhs} and {rhs}&quot;),
</a><a href="#h11-5-17" id="h11-5-17" class="d">-        })
</a><a href="#h11-5-18" id="h11-5-18" class="d">-    }
</a><a href="#h11-5-19" id="h11-5-19" class="d">-
</a>     /// Finds the remainder of two values. Errors when invalid.
     ///
     /// NB: uses the remainder, not modulo, like Postgres. For negative values,
<a href="#h11-6" id="h11-6" class="h">@@ -245,11 +222,7 @@ impl Value {
</a> 
     /// Returns true if the value is undefined (NULL or NaN).
     pub fn is_undefined(&amp;self) -&gt; bool {
<a href="#h11-6-3" id="h11-6-3" class="d">-        match self {
</a><a href="#h11-6-4" id="h11-6-4" class="d">-            Self::Null =&gt; true,
</a><a href="#h11-6-5" id="h11-6-5" class="d">-            Self::Float(f) if f.is_nan() =&gt; true,
</a><a href="#h11-6-6" id="h11-6-6" class="d">-            _ =&gt; false,
</a><a href="#h11-6-7" id="h11-6-7" class="d">-        }
</a><a href="#h11-6-8" id="h11-6-8" class="i">+        *self == Self::Null || matches!(self, Self::Float(f) if f.is_nan())
</a>     }
 
     /// Normalizes a value in place. Currently normalizes -0.0 and -NAN to 0.0
<a href="#h11-7" id="h11-7" class="h">@@ -267,7 +240,7 @@ impl Value {
</a>     /// allocating in the common case where the value doesn&#39;t change.
     pub fn normalize_ref(&amp;self) -&gt; Cow&lt;&#39;_, Self&gt; {
         if let Self::Float(f) = self {
<a href="#h11-7-3" id="h11-7-3" class="d">-            if f.is_sign_negative() &amp;&amp; (f.is_nan() || *f == -0.0) {
</a><a href="#h11-7-4" id="h11-7-4" class="i">+            if (f.is_nan() || *f == -0.0) &amp;&amp; f.is_sign_negative() {
</a>                 return Cow::Owned(Self::Float(-f));
             }
         }
<a href="#h11-8" id="h11-8" class="h">@@ -365,19 +338,43 @@ impl&lt;&#39;a&gt; From&lt;&amp;&#39;a Value&gt; for Cow&lt;&#39;a, Value&gt; {
</a>     }
 }
 
<a href="#h11-8-3" id="h11-8-3" class="i">+/// A primitive data type.
</a><a href="#h11-8-4" id="h11-8-4" class="i">+#[derive(Clone, Copy, Debug, Hash, PartialEq, Serialize, Deserialize)]
</a><a href="#h11-8-5" id="h11-8-5" class="i">+pub enum DataType {
</a><a href="#h11-8-6" id="h11-8-6" class="i">+    /// A boolean: true or false.
</a><a href="#h11-8-7" id="h11-8-7" class="i">+    Boolean,
</a><a href="#h11-8-8" id="h11-8-8" class="i">+    /// A 64-bit signed integer.
</a><a href="#h11-8-9" id="h11-8-9" class="i">+    Integer,
</a><a href="#h11-8-10" id="h11-8-10" class="i">+    /// A 64-bit floating point number.
</a><a href="#h11-8-11" id="h11-8-11" class="i">+    Float,
</a><a href="#h11-8-12" id="h11-8-12" class="i">+    /// A UTF-8 encoded string.
</a><a href="#h11-8-13" id="h11-8-13" class="i">+    String,
</a><a href="#h11-8-14" id="h11-8-14" class="i">+}
</a><a href="#h11-8-15" id="h11-8-15" class="i">+
</a><a href="#h11-8-16" id="h11-8-16" class="i">+impl std::fmt::Display for DataType {
</a><a href="#h11-8-17" id="h11-8-17" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
</a><a href="#h11-8-18" id="h11-8-18" class="i">+        match self {
</a><a href="#h11-8-19" id="h11-8-19" class="i">+            Self::Boolean =&gt; write!(f, &quot;BOOLEAN&quot;),
</a><a href="#h11-8-20" id="h11-8-20" class="i">+            Self::Integer =&gt; write!(f, &quot;INTEGER&quot;),
</a><a href="#h11-8-21" id="h11-8-21" class="i">+            Self::Float =&gt; write!(f, &quot;FLOAT&quot;),
</a><a href="#h11-8-22" id="h11-8-22" class="i">+            Self::String =&gt; write!(f, &quot;STRING&quot;),
</a><a href="#h11-8-23" id="h11-8-23" class="i">+        }
</a><a href="#h11-8-24" id="h11-8-24" class="i">+    }
</a><a href="#h11-8-25" id="h11-8-25" class="i">+}
</a><a href="#h11-8-26" id="h11-8-26" class="i">+
</a> /// A row of values.
 pub type Row = Vec&lt;Value&gt;;
 
 /// A row iterator.
 pub type Rows = Box&lt;dyn RowIterator&gt;;
 
<a href="#h11-8-33" id="h11-8-33" class="d">-/// A row iterator trait, which requires it to be clonable and object-safe. It
</a><a href="#h11-8-34" id="h11-8-34" class="d">-/// has a blanket implementation for all iterators.
</a><a href="#h11-8-35" id="h11-8-35" class="i">+/// A row iterator trait, which requires the iterator to be both clonable and
</a><a href="#h11-8-36" id="h11-8-36" class="i">+/// object-safe. Cloning is needed to be able to reset an iterator back to an
</a><a href="#h11-8-37" id="h11-8-37" class="i">+/// initial state, e.g. during nested loop joins. It has a blanket
</a><a href="#h11-8-38" id="h11-8-38" class="i">+/// implementation for all matching iterators.
</a> pub trait RowIterator: Iterator&lt;Item = Result&lt;Row&gt;&gt; + DynClone {}
<a href="#h11-8-40" id="h11-8-40" class="d">-
</a><a href="#h11-8-41" id="h11-8-41" class="d">-dyn_clone::clone_trait_object!(RowIterator);
</a><a href="#h11-8-42" id="h11-8-42" class="d">-
</a> impl&lt;I: Iterator&lt;Item = Result&lt;Row&gt;&gt; + DynClone&gt; RowIterator for I {}
<a href="#h11-8-44" id="h11-8-44" class="i">+dyn_clone::clone_trait_object!(RowIterator);
</a> 
 /// A column label, used in query results and plans.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</pre>
</div>
</body>
</html>
