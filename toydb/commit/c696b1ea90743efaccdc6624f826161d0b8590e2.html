<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: rewrite aggregate function and GROUP BY planning - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/c696b1ea90743efaccdc6624f826161d0b8590e2.html">c696b1ea90743efaccdc6624f826161d0b8590e2</a>
<b>parent</b> <a href="../commit/f4fac4f6b9d6b5a93cf317152a73619c77e9bfa7.html">f4fac4f6b9d6b5a93cf317152a73619c77e9bfa7</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sat, 13 Jul 2024 22:34:45 +0200

sql: rewrite aggregate function and GROUP BY planning

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/execution/aggregate.rs</a></td><td> | </td><td class="num">10</td><td><span class="i">++++++++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">84</td><td><span class="i">++</span><span class="d">-----------------------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/planner/plan.rs</a></td><td> | </td><td class="num">23</td><td><span class="i">+++</span><span class="d">--------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/sql/planner/planner.rs</a></td><td> | </td><td class="num">412</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/testscripts/queries/aggregate</a></td><td> | </td><td class="num">15</td><td><span class="i">++++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/testscripts/queries/group_by</a></td><td> | </td><td class="num">86</td><td><span class="i">++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/testscripts/queries/having</a></td><td> | </td><td class="num">66</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/testscripts/queries/order</a></td><td> | </td><td class="num">69</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-----</span></td></tr>
</table></pre><pre>8 files changed, 379 insertions(+), 386 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/execution/aggregate.rs.html">src/sql/execution/aggregate.rs</a> b/<a href="../file/src/sql/execution/aggregate.rs.html">src/sql/execution/aggregate.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -34,8 +34,14 @@ struct Aggregator {
</a> impl Aggregator {
     /// Creates a new aggregator for the given aggregates and GROUP BY buckets.
     fn new(aggregates: Vec&lt;Aggregate&gt;, group_by: Vec&lt;Expression&gt;) -&gt; Self {
<a href="#h0-0-3" id="h0-0-3" class="i">+        use Aggregate::*;
</a>         let accumulators = aggregates.iter().map(Accumulator::new).collect();
<a href="#h0-0-5" id="h0-0-5" class="d">-        let exprs = aggregates.into_iter().map(|a| a.into_inner()).collect();
</a><a href="#h0-0-6" id="h0-0-6" class="i">+        let exprs = aggregates
</a><a href="#h0-0-7" id="h0-0-7" class="i">+            .into_iter()
</a><a href="#h0-0-8" id="h0-0-8" class="i">+            .map(|aggregate| match aggregate {
</a><a href="#h0-0-9" id="h0-0-9" class="i">+                Average(expr) | Count(expr) | Max(expr) | Min(expr) | Sum(expr) =&gt; expr,
</a><a href="#h0-0-10" id="h0-0-10" class="i">+            })
</a><a href="#h0-0-11" id="h0-0-11" class="i">+            .collect();
</a>         Self { buckets: BTreeMap::new(), empty: accumulators, group_by, exprs }
     }
 
<a href="#h0-1" id="h0-1" class="h">@@ -101,7 +107,7 @@ impl Accumulator {
</a>     }
 
     /// Adds a value to the accumulator.
<a href="#h0-1-3" id="h0-1-3" class="d">-    /// TODO: have this take &amp;Value.
</a><a href="#h0-1-4" id="h0-1-4" class="i">+    /// TODO: NULL values should possibly be ignored, not yield NULL (see Postgres?).
</a>     fn add(&amp;mut self, value: Value) -&gt; Result&lt;()&gt; {
         use std::cmp::Ordering;
         match (self, value) {
<b>diff --git a/<a id="h1" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,4 +1,3 @@
</a><a href="#h1-0-0" id="h1-0-0" class="d">-use crate::error::Result;
</a> use crate::sql::types::DataType;
 
 use std::collections::BTreeMap;
<a href="#h1-1" id="h1-1" class="h">@@ -101,9 +100,6 @@ pub enum Order {
</a> pub enum Expression {
     /// A field reference, with an optional table qualifier.
     Field(Option&lt;String&gt;, String),
<a href="#h1-1-3" id="h1-1-3" class="d">-    /// A column index (only used during planning to break off subtrees).
</a><a href="#h1-1-4" id="h1-1-4" class="d">-    /// TODO: get rid of this, planning shouldn&#39;t modify the AST.
</a><a href="#h1-1-5" id="h1-1-5" class="d">-    Column(usize),
</a>     /// A literal value.
     Literal(Literal),
     /// A function call (name and parameters).
<a href="#h1-2" id="h1-2" class="h">@@ -188,82 +184,6 @@ pub enum Operator {
</a> }
 
 impl Expression {
<a href="#h1-2-3" id="h1-2-3" class="d">-    /// Transforms the expression tree depth-first by applying a closure before
</a><a href="#h1-2-4" id="h1-2-4" class="d">-    /// and after descending.
</a><a href="#h1-2-5" id="h1-2-5" class="d">-    ///
</a><a href="#h1-2-6" id="h1-2-6" class="d">-    /// TODO: make closures non-mut.
</a><a href="#h1-2-7" id="h1-2-7" class="d">-    pub fn transform&lt;B, A&gt;(mut self, before: &amp;mut B, after: &amp;mut A) -&gt; Result&lt;Self&gt;
</a><a href="#h1-2-8" id="h1-2-8" class="d">-    where
</a><a href="#h1-2-9" id="h1-2-9" class="d">-        B: FnMut(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h1-2-10" id="h1-2-10" class="d">-        A: FnMut(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h1-2-11" id="h1-2-11" class="d">-    {
</a><a href="#h1-2-12" id="h1-2-12" class="d">-        use Operator::*;
</a><a href="#h1-2-13" id="h1-2-13" class="d">-        self = before(self)?;
</a><a href="#h1-2-14" id="h1-2-14" class="d">-
</a><a href="#h1-2-15" id="h1-2-15" class="d">-        // Helper for transforming a boxed expression.
</a><a href="#h1-2-16" id="h1-2-16" class="d">-        let mut transform = |mut expr: Box&lt;Expression&gt;| -&gt; Result&lt;Box&lt;Expression&gt;&gt; {
</a><a href="#h1-2-17" id="h1-2-17" class="d">-            *expr = expr.transform(before, after)?;
</a><a href="#h1-2-18" id="h1-2-18" class="d">-            Ok(expr)
</a><a href="#h1-2-19" id="h1-2-19" class="d">-        };
</a><a href="#h1-2-20" id="h1-2-20" class="d">-
</a><a href="#h1-2-21" id="h1-2-21" class="d">-        self = match self {
</a><a href="#h1-2-22" id="h1-2-22" class="d">-            Self::Literal(_) | Self::Field(_, _) | Self::Column(_) =&gt; self,
</a><a href="#h1-2-23" id="h1-2-23" class="d">-
</a><a href="#h1-2-24" id="h1-2-24" class="d">-            Self::Function(name, exprs) =&gt; Self::Function(
</a><a href="#h1-2-25" id="h1-2-25" class="d">-                name,
</a><a href="#h1-2-26" id="h1-2-26" class="d">-                exprs.into_iter().map(|e| e.transform(before, after)).collect::&lt;Result&lt;_&gt;&gt;()?,
</a><a href="#h1-2-27" id="h1-2-27" class="d">-            ),
</a><a href="#h1-2-28" id="h1-2-28" class="d">-
</a><a href="#h1-2-29" id="h1-2-29" class="d">-            Self::Operator(op) =&gt; Self::Operator(match op {
</a><a href="#h1-2-30" id="h1-2-30" class="d">-                Add(lhs, rhs) =&gt; Add(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-31" id="h1-2-31" class="d">-                And(lhs, rhs) =&gt; And(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-32" id="h1-2-32" class="d">-                Divide(lhs, rhs) =&gt; Divide(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-33" id="h1-2-33" class="d">-                Equal(lhs, rhs) =&gt; Equal(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-34" id="h1-2-34" class="d">-                Exponentiate(lhs, rhs) =&gt; Exponentiate(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-35" id="h1-2-35" class="d">-                Factorial(expr) =&gt; Factorial(transform(expr)?),
</a><a href="#h1-2-36" id="h1-2-36" class="d">-                GreaterThan(lhs, rhs) =&gt; GreaterThan(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-37" id="h1-2-37" class="d">-                GreaterThanOrEqual(lhs, rhs) =&gt; {
</a><a href="#h1-2-38" id="h1-2-38" class="d">-                    GreaterThanOrEqual(transform(lhs)?, transform(rhs)?)
</a><a href="#h1-2-39" id="h1-2-39" class="d">-                }
</a><a href="#h1-2-40" id="h1-2-40" class="d">-                Identity(expr) =&gt; Identity(transform(expr)?),
</a><a href="#h1-2-41" id="h1-2-41" class="d">-                IsNaN(expr) =&gt; IsNaN(transform(expr)?),
</a><a href="#h1-2-42" id="h1-2-42" class="d">-                IsNull(expr) =&gt; IsNull(transform(expr)?),
</a><a href="#h1-2-43" id="h1-2-43" class="d">-                LessThan(lhs, rhs) =&gt; LessThan(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-44" id="h1-2-44" class="d">-                LessThanOrEqual(lhs, rhs) =&gt; LessThanOrEqual(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-45" id="h1-2-45" class="d">-                Like(lhs, rhs) =&gt; Like(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-46" id="h1-2-46" class="d">-                Modulo(lhs, rhs) =&gt; Modulo(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-47" id="h1-2-47" class="d">-                Multiply(lhs, rhs) =&gt; Multiply(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-48" id="h1-2-48" class="d">-                Negate(expr) =&gt; Negate(transform(expr)?),
</a><a href="#h1-2-49" id="h1-2-49" class="d">-                Not(expr) =&gt; Not(transform(expr)?),
</a><a href="#h1-2-50" id="h1-2-50" class="d">-                NotEqual(lhs, rhs) =&gt; NotEqual(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-51" id="h1-2-51" class="d">-                Or(lhs, rhs) =&gt; Or(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-52" id="h1-2-52" class="d">-                Subtract(lhs, rhs) =&gt; Subtract(transform(lhs)?, transform(rhs)?),
</a><a href="#h1-2-53" id="h1-2-53" class="d">-            }),
</a><a href="#h1-2-54" id="h1-2-54" class="d">-        };
</a><a href="#h1-2-55" id="h1-2-55" class="d">-        self = after(self)?;
</a><a href="#h1-2-56" id="h1-2-56" class="d">-        Ok(self)
</a><a href="#h1-2-57" id="h1-2-57" class="d">-    }
</a><a href="#h1-2-58" id="h1-2-58" class="d">-
</a><a href="#h1-2-59" id="h1-2-59" class="d">-    /// Transforms an expression using a mutable reference.
</a><a href="#h1-2-60" id="h1-2-60" class="d">-    /// TODO: try to get rid of this and replace_with().
</a><a href="#h1-2-61" id="h1-2-61" class="d">-    pub fn transform_mut&lt;B, A&gt;(&amp;mut self, before: &amp;mut B, after: &amp;mut A) -&gt; Result&lt;()&gt;
</a><a href="#h1-2-62" id="h1-2-62" class="d">-    where
</a><a href="#h1-2-63" id="h1-2-63" class="d">-        B: FnMut(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h1-2-64" id="h1-2-64" class="d">-        A: FnMut(Self) -&gt; Result&lt;Self&gt;,
</a><a href="#h1-2-65" id="h1-2-65" class="d">-    {
</a><a href="#h1-2-66" id="h1-2-66" class="d">-        self.replace_with(|e| e.transform(before, after))
</a><a href="#h1-2-67" id="h1-2-67" class="d">-    }
</a><a href="#h1-2-68" id="h1-2-68" class="d">-
</a><a href="#h1-2-69" id="h1-2-69" class="d">-    /// Replaces the expression with result of the closure. Helper function for
</a><a href="#h1-2-70" id="h1-2-70" class="d">-    /// transform().
</a><a href="#h1-2-71" id="h1-2-71" class="d">-    fn replace_with(&amp;mut self, mut f: impl FnMut(Self) -&gt; Result&lt;Self&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h1-2-72" id="h1-2-72" class="d">-        // Temporarily replace expression with a null value, in case closure panics. May consider
</a><a href="#h1-2-73" id="h1-2-73" class="d">-        // replace_with crate if this hampers performance.
</a><a href="#h1-2-74" id="h1-2-74" class="d">-        let expr = std::mem::replace(self, Expression::Literal(Literal::Null));
</a><a href="#h1-2-75" id="h1-2-75" class="d">-        *self = f(expr)?;
</a><a href="#h1-2-76" id="h1-2-76" class="d">-        Ok(())
</a><a href="#h1-2-77" id="h1-2-77" class="d">-    }
</a><a href="#h1-2-78" id="h1-2-78" class="d">-
</a>     /// Walks the expression tree depth-first, calling a closure for every node.
     /// Halts and returns false if the closure returns false.
     pub fn walk(&amp;self, visitor: &amp;mut impl FnMut(&amp;Expression) -&gt; bool) -&gt; bool {
<a href="#h1-3" id="h1-3" class="h">@@ -297,7 +217,7 @@ impl Expression {
</a> 
             Self::Function(_, exprs) =&gt; exprs.iter().any(|expr| expr.walk(visitor)),
 
<a href="#h1-3-3" id="h1-3-3" class="d">-            Self::Literal(_) | Self::Field(_, _) | Self::Column(_) =&gt; true,
</a><a href="#h1-3-4" id="h1-3-4" class="i">+            Self::Literal(_) | Self::Field(_, _) =&gt; true,
</a>         }
     }
 
<a href="#h1-4" id="h1-4" class="h">@@ -348,7 +268,7 @@ impl Expression {
</a> 
             Self::Function(_, exprs) =&gt; exprs.iter().for_each(|expr| expr.collect(visitor, c)),
 
<a href="#h1-4-3" id="h1-4-3" class="d">-            Self::Literal(_) | Self::Field(_, _) | Self::Column(_) =&gt; {}
</a><a href="#h1-4-4" id="h1-4-4" class="i">+            Self::Literal(_) | Self::Field(_, _) =&gt; {}
</a>         }
     }
 }
<b>diff --git a/<a id="h2" href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a> b/<a href="../file/src/sql/planner/plan.rs.html">src/sql/planner/plan.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -85,7 +85,9 @@ impl Plan {
</a> #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Node {
     /// Computes aggregate values for the given expressions and group_by buckets
<a href="#h2-0-3" id="h2-0-3" class="d">-    /// across all rows in the source node.
</a><a href="#h2-0-4" id="h2-0-4" class="i">+    /// across all rows in the source node. The aggregate columns are output
</a><a href="#h2-0-5" id="h2-0-5" class="i">+    /// first, followed by the group_by columns, in the given order.
</a><a href="#h2-0-6" id="h2-0-6" class="i">+    /// TODO: reverse the order.
</a>     Aggregate { source: Box&lt;Node&gt;, aggregates: Vec&lt;Aggregate&gt;, group_by: Vec&lt;Expression&gt; },
     /// Filters source rows, by only emitting rows for which the predicate
     /// evaluates to true.
<a href="#h2-1" id="h2-1" class="h">@@ -465,25 +467,6 @@ impl std::fmt::Display for Aggregate {
</a>     }
 }
 
<a href="#h2-1-3" id="h2-1-3" class="d">-impl Aggregate {
</a><a href="#h2-1-4" id="h2-1-4" class="d">-    /// Returns the inner aggregate expression. Currently, all aggregate
</a><a href="#h2-1-5" id="h2-1-5" class="d">-    /// functions take a single input expression.
</a><a href="#h2-1-6" id="h2-1-6" class="d">-    pub fn into_inner(self) -&gt; Expression {
</a><a href="#h2-1-7" id="h2-1-7" class="d">-        match self {
</a><a href="#h2-1-8" id="h2-1-8" class="d">-            Self::Average(expr)
</a><a href="#h2-1-9" id="h2-1-9" class="d">-            | Self::Count(expr)
</a><a href="#h2-1-10" id="h2-1-10" class="d">-            | Self::Max(expr)
</a><a href="#h2-1-11" id="h2-1-11" class="d">-            | Self::Min(expr)
</a><a href="#h2-1-12" id="h2-1-12" class="d">-            | Self::Sum(expr) =&gt; expr,
</a><a href="#h2-1-13" id="h2-1-13" class="d">-        }
</a><a href="#h2-1-14" id="h2-1-14" class="d">-    }
</a><a href="#h2-1-15" id="h2-1-15" class="d">-
</a><a href="#h2-1-16" id="h2-1-16" class="d">-    // TODO: get rid of this.
</a><a href="#h2-1-17" id="h2-1-17" class="d">-    pub(super) fn is(name: &amp;str) -&gt; bool {
</a><a href="#h2-1-18" id="h2-1-18" class="d">-        [&quot;avg&quot;, &quot;count&quot;, &quot;max&quot;, &quot;min&quot;, &quot;sum&quot;].contains(&amp;name)
</a><a href="#h2-1-19" id="h2-1-19" class="d">-    }
</a><a href="#h2-1-20" id="h2-1-20" class="d">-}
</a><a href="#h2-1-21" id="h2-1-21" class="d">-
</a> /// A sort order direction.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Direction {
<b>diff --git a/<a id="h3" href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a> b/<a href="../file/src/sql/planner/planner.rs.html">src/sql/planner/planner.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -148,11 +148,11 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     #[allow(clippy::too_many_arguments)]
     fn build_select(
         &amp;self,
<a href="#h3-0-3" id="h3-0-3" class="d">-        mut select: Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h3-0-4" id="h3-0-4" class="i">+        select: Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a>         from: Vec&lt;ast::From&gt;,
         r#where: Option&lt;ast::Expression&gt;,
         group_by: Vec&lt;ast::Expression&gt;,
<a href="#h3-0-8" id="h3-0-8" class="d">-        mut having: Option&lt;ast::Expression&gt;,
</a><a href="#h3-0-9" id="h3-0-9" class="i">+        having: Option&lt;ast::Expression&gt;,
</a>         order: Vec&lt;(ast::Expression, ast::Order)&gt;,
         offset: Option&lt;ast::Expression&gt;,
         limit: Option&lt;ast::Expression&gt;,
<a href="#h3-1" id="h3-1" class="h">@@ -174,40 +174,27 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             node = Node::Filter { source: Box::new(node), predicate };
         };
 
<a href="#h3-1-3" id="h3-1-3" class="i">+        // Build aggregate functions and GROUP BY clause.
</a><a href="#h3-1-4" id="h3-1-4" class="i">+        let aggregates = Self::collect_aggregates(&amp;select, &amp;having, &amp;order);
</a><a href="#h3-1-5" id="h3-1-5" class="i">+        if !group_by.is_empty() || !aggregates.is_empty() {
</a><a href="#h3-1-6" id="h3-1-6" class="i">+            node = self.build_aggregate(&amp;mut scope, node, group_by, aggregates)?;
</a><a href="#h3-1-7" id="h3-1-7" class="i">+        }
</a><a href="#h3-1-8" id="h3-1-8" class="i">+
</a>         // Build SELECT clause.
         let mut hidden = 0;
         if !select.is_empty() {
<a href="#h3-1-12" id="h3-1-12" class="d">-            // Inject hidden SELECT columns for fields and aggregates used in ORDER BY and
</a><a href="#h3-1-13" id="h3-1-13" class="d">-            // HAVING expressions but not present in existing SELECT output. These will be
</a><a href="#h3-1-14" id="h3-1-14" class="d">-            // removed again by a later projection.
</a><a href="#h3-1-15" id="h3-1-15" class="d">-            if let Some(ref mut expr) = having {
</a><a href="#h3-1-16" id="h3-1-16" class="d">-                hidden += self.inject_hidden(expr, &amp;mut select)?;
</a><a href="#h3-1-17" id="h3-1-17" class="d">-            }
</a><a href="#h3-1-18" id="h3-1-18" class="d">-
</a><a href="#h3-1-19" id="h3-1-19" class="d">-            // Extract any aggregate functions and GROUP BY expressions and
</a><a href="#h3-1-20" id="h3-1-20" class="d">-            // build an aggregation node for them, replacing them with Column
</a><a href="#h3-1-21" id="h3-1-21" class="d">-            // placeholders.
</a><a href="#h3-1-22" id="h3-1-22" class="d">-            //
</a><a href="#h3-1-23" id="h3-1-23" class="d">-            // TODO: handle ORDER BY aggregates.
</a><a href="#h3-1-24" id="h3-1-24" class="d">-            let aggregates = self.extract_aggregates(&amp;scope, &amp;mut select)?;
</a><a href="#h3-1-25" id="h3-1-25" class="d">-            let groups = self.extract_groups(&amp;mut select, group_by, aggregates.len())?;
</a><a href="#h3-1-26" id="h3-1-26" class="d">-            if !aggregates.is_empty() || !groups.is_empty() {
</a><a href="#h3-1-27" id="h3-1-27" class="d">-                node = self.build_aggregation(&amp;mut scope, node, groups, aggregates)?;
</a><a href="#h3-1-28" id="h3-1-28" class="d">-            }
</a><a href="#h3-1-29" id="h3-1-29" class="d">-
</a><a href="#h3-1-30" id="h3-1-30" class="d">-            // Build the remaining non-aggregate projection.
</a>             let labels = select.iter().map(|(_, l)| Label::maybe_name(l.clone())).collect_vec();
<a href="#h3-1-32" id="h3-1-32" class="d">-            let mut expressions = select
</a><a href="#h3-1-33" id="h3-1-33" class="i">+            let mut expressions: Vec&lt;_&gt; = select
</a>                 .into_iter()
                 .map(|(e, _)| Self::build_expression(e, &amp;scope))
<a href="#h3-1-36" id="h3-1-36" class="d">-                .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h3-1-37" id="h3-1-37" class="i">+                .collect::&lt;Result&lt;_&gt;&gt;()?;
</a>             let parent_scope = scope;
             scope = parent_scope.project(&amp;expressions, &amp;labels)?;
 
<a href="#h3-1-41" id="h3-1-41" class="d">-            // Add hidden columns for any ORDER BY fields not in the projection.
</a><a href="#h3-1-42" id="h3-1-42" class="i">+            // Add hidden columns for HAVING and ORDER BY fields not in SELECT.
</a>             // TODO: track hidden fields in Scope.
             let size = expressions.len();
<a href="#h3-1-45" id="h3-1-45" class="d">-            for (expr, _) in &amp;order {
</a><a href="#h3-1-46" id="h3-1-46" class="i">+            for expr in having.iter().chain(order.iter().map(|(e, _)| e)) {
</a>                 self.build_hidden(&amp;mut scope, &amp;parent_scope, &amp;mut expressions, expr);
             }
             hidden += expressions.len() - size;
<a href="#h3-2" id="h3-2" class="h">@@ -345,118 +332,124 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         Ok(node)
     }
 
<a href="#h3-2-3" id="h3-2-3" class="d">-    /// Builds an aggregate node.
</a><a href="#h3-2-4" id="h3-2-4" class="i">+    /// Builds an aggregate node, computing aggregate functions for a set of
</a><a href="#h3-2-5" id="h3-2-5" class="i">+    /// GROUP BY buckets.
</a><a href="#h3-2-6" id="h3-2-6" class="i">+    ///
</a><a href="#h3-2-7" id="h3-2-7" class="i">+    /// The aggregate functions have been collected from the SELECT, HAVING, and
</a><a href="#h3-2-8" id="h3-2-8" class="i">+    /// ORDER BY clauses (all of which can contain their own aggregate
</a><a href="#h3-2-9" id="h3-2-9" class="i">+    /// functions).
</a>     ///
<a href="#h3-2-11" id="h3-2-11" class="d">-    /// TODO: revisit this.
</a><a href="#h3-2-12" id="h3-2-12" class="d">-    fn build_aggregation(
</a><a href="#h3-2-13" id="h3-2-13" class="i">+    /// The ast::Expression for each aggregate function and each GROUP BY
</a><a href="#h3-2-14" id="h3-2-14" class="i">+    /// expression (except trivial column names) is stored in the Scope along
</a><a href="#h3-2-15" id="h3-2-15" class="i">+    /// with the column index. Later nodes (i.e. SELECT, HAVING, and ORDER BY)
</a><a href="#h3-2-16" id="h3-2-16" class="i">+    /// can look up the column index of aggregate expressions via Scope.
</a><a href="#h3-2-17" id="h3-2-17" class="i">+    /// Similarly, they are allowed to reference GROUP BY expressions by
</a><a href="#h3-2-18" id="h3-2-18" class="i">+    /// specifying the exact same expression.
</a><a href="#h3-2-19" id="h3-2-19" class="i">+    ///
</a><a href="#h3-2-20" id="h3-2-20" class="i">+    /// TODO: consider avoiding the expr cloning by taking &amp;Expression in
</a><a href="#h3-2-21" id="h3-2-21" class="i">+    /// various places.
</a><a href="#h3-2-22" id="h3-2-22" class="i">+    fn build_aggregate(
</a>         &amp;self,
         scope: &amp;mut Scope,
         source: Node,
<a href="#h3-2-26" id="h3-2-26" class="d">-        groups: Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h3-2-27" id="h3-2-27" class="d">-        aggregates: Vec&lt;Aggregate&gt;,
</a><a href="#h3-2-28" id="h3-2-28" class="i">+        group_by: Vec&lt;ast::Expression&gt;,
</a><a href="#h3-2-29" id="h3-2-29" class="i">+        aggregates: Vec&lt;&amp;ast::Expression&gt;,
</a>     ) -&gt; Result&lt;Node&gt; {
<a href="#h3-2-31" id="h3-2-31" class="d">-        let mut group_by = Vec::new();
</a><a href="#h3-2-32" id="h3-2-32" class="d">-        let mut expressions = Vec::new();
</a><a href="#h3-2-33" id="h3-2-33" class="d">-        let mut labels = Vec::new();
</a><a href="#h3-2-34" id="h3-2-34" class="d">-        for _ in &amp;aggregates {
</a><a href="#h3-2-35" id="h3-2-35" class="d">-            expressions.push(Expression::Constant(Value::Null));
</a><a href="#h3-2-36" id="h3-2-36" class="d">-            labels.push(Label::None);
</a><a href="#h3-2-37" id="h3-2-37" class="i">+        // Construct a child scope with the group_by and aggregate AST
</a><a href="#h3-2-38" id="h3-2-38" class="i">+        // expressions, such that downstream nodes can identify and reference
</a><a href="#h3-2-39" id="h3-2-39" class="i">+        // them. Discard redundant expressions.
</a><a href="#h3-2-40" id="h3-2-40" class="i">+        //
</a><a href="#h3-2-41" id="h3-2-41" class="i">+        // TODO: reverse the order of the emitted columns: group_by then
</a><a href="#h3-2-42" id="h3-2-42" class="i">+        // aggregates.
</a><a href="#h3-2-43" id="h3-2-43" class="i">+        let mut child_scope = scope.project(&amp;[], &amp;[])?; // project to keep tables
</a><a href="#h3-2-44" id="h3-2-44" class="i">+        let aggregates = aggregates
</a><a href="#h3-2-45" id="h3-2-45" class="i">+            .into_iter()
</a><a href="#h3-2-46" id="h3-2-46" class="i">+            .filter(|&amp;expr| {
</a><a href="#h3-2-47" id="h3-2-47" class="i">+                if child_scope.lookup_aggregate(expr).is_some() {
</a><a href="#h3-2-48" id="h3-2-48" class="i">+                    return false;
</a><a href="#h3-2-49" id="h3-2-49" class="i">+                }
</a><a href="#h3-2-50" id="h3-2-50" class="i">+                child_scope.add_aggregate((expr).clone(), Label::None);
</a><a href="#h3-2-51" id="h3-2-51" class="i">+                true
</a><a href="#h3-2-52" id="h3-2-52" class="i">+            })
</a><a href="#h3-2-53" id="h3-2-53" class="i">+            .collect_vec();
</a><a href="#h3-2-54" id="h3-2-54" class="i">+        let group_by = group_by
</a><a href="#h3-2-55" id="h3-2-55" class="i">+            .into_iter()
</a><a href="#h3-2-56" id="h3-2-56" class="i">+            .filter(|expr| {
</a><a href="#h3-2-57" id="h3-2-57" class="i">+                if child_scope.lookup_aggregate(expr).is_some() {
</a><a href="#h3-2-58" id="h3-2-58" class="i">+                    return false; // already exists in child scope
</a><a href="#h3-2-59" id="h3-2-59" class="i">+                }
</a><a href="#h3-2-60" id="h3-2-60" class="i">+                let mut label = Label::None;
</a><a href="#h3-2-61" id="h3-2-61" class="i">+                // TODO: add a Scope method to pass through columns from a parent scope.
</a><a href="#h3-2-62" id="h3-2-62" class="i">+                if let ast::Expression::Field(table, column) = expr {
</a><a href="#h3-2-63" id="h3-2-63" class="i">+                    if let Ok(index) = scope.lookup_column(table.as_deref(), column.as_str()) {
</a><a href="#h3-2-64" id="h3-2-64" class="i">+                        label = scope.get_column_label(index).unwrap();
</a><a href="#h3-2-65" id="h3-2-65" class="i">+                    }
</a><a href="#h3-2-66" id="h3-2-66" class="i">+                }
</a><a href="#h3-2-67" id="h3-2-67" class="i">+                child_scope.add_aggregate(expr.clone(), label);
</a><a href="#h3-2-68" id="h3-2-68" class="i">+                true
</a><a href="#h3-2-69" id="h3-2-69" class="i">+            })
</a><a href="#h3-2-70" id="h3-2-70" class="i">+            .collect_vec();
</a><a href="#h3-2-71" id="h3-2-71" class="i">+
</a><a href="#h3-2-72" id="h3-2-72" class="i">+        // Build the node from the remaining expressions.
</a><a href="#h3-2-73" id="h3-2-73" class="i">+        let aggregates = aggregates
</a><a href="#h3-2-74" id="h3-2-74" class="i">+            .into_iter()
</a><a href="#h3-2-75" id="h3-2-75" class="i">+            .map(|expr| Self::build_aggregate_function(scope, expr.clone()))
</a><a href="#h3-2-76" id="h3-2-76" class="i">+            .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h3-2-77" id="h3-2-77" class="i">+        let group_by = group_by
</a><a href="#h3-2-78" id="h3-2-78" class="i">+            .into_iter()
</a><a href="#h3-2-79" id="h3-2-79" class="i">+            .map(|expr| Self::build_expression(expr, scope))
</a><a href="#h3-2-80" id="h3-2-80" class="i">+            .collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h3-2-81" id="h3-2-81" class="i">+
</a><a href="#h3-2-82" id="h3-2-82" class="i">+        *scope = child_scope;
</a><a href="#h3-2-83" id="h3-2-83" class="i">+        Ok(Node::Aggregate { source: Box::new(source), group_by, aggregates })
</a><a href="#h3-2-84" id="h3-2-84" class="i">+    }
</a><a href="#h3-2-85" id="h3-2-85" class="i">+
</a><a href="#h3-2-86" id="h3-2-86" class="i">+    /// Builds an aggregate function from an AST expression.
</a><a href="#h3-2-87" id="h3-2-87" class="i">+    fn build_aggregate_function(scope: &amp;Scope, expr: ast::Expression) -&gt; Result&lt;Aggregate&gt; {
</a><a href="#h3-2-88" id="h3-2-88" class="i">+        let ast::Expression::Function(name, mut args) = expr else {
</a><a href="#h3-2-89" id="h3-2-89" class="i">+            panic!(&quot;aggregate expression must be function&quot;);
</a><a href="#h3-2-90" id="h3-2-90" class="i">+        };
</a><a href="#h3-2-91" id="h3-2-91" class="i">+        if args.len() != 1 {
</a><a href="#h3-2-92" id="h3-2-92" class="i">+            return errinput!(&quot;{name} takes 1 argument&quot;);
</a>         }
<a href="#h3-2-94" id="h3-2-94" class="d">-        for (expr, label) in groups {
</a><a href="#h3-2-95" id="h3-2-95" class="d">-            let expr = Self::build_expression(expr, scope)?;
</a><a href="#h3-2-96" id="h3-2-96" class="d">-            expressions.push(expr.clone());
</a><a href="#h3-2-97" id="h3-2-97" class="d">-            group_by.push(expr);
</a><a href="#h3-2-98" id="h3-2-98" class="d">-            labels.push(Label::maybe_name(label));
</a><a href="#h3-2-99" id="h3-2-99" class="i">+        if args[0].contains(&amp;|expr| Self::is_aggregate_function(expr)) {
</a><a href="#h3-2-100" id="h3-2-100" class="i">+            return errinput!(&quot;aggregate functions can&#39;t be nested&quot;);
</a>         }
<a href="#h3-2-102" id="h3-2-102" class="d">-        let node = Node::Aggregate { source: Box::new(source), group_by, aggregates };
</a><a href="#h3-2-103" id="h3-2-103" class="d">-        *scope = scope.project(&amp;expressions, &amp;labels)?;
</a><a href="#h3-2-104" id="h3-2-104" class="d">-        Ok(node)
</a><a href="#h3-2-105" id="h3-2-105" class="i">+        let expr = Self::build_expression(args.remove(0), scope)?;
</a><a href="#h3-2-106" id="h3-2-106" class="i">+        Ok(match name.as_str() {
</a><a href="#h3-2-107" id="h3-2-107" class="i">+            &quot;avg&quot; =&gt; Aggregate::Average(expr),
</a><a href="#h3-2-108" id="h3-2-108" class="i">+            &quot;count&quot; =&gt; Aggregate::Count(expr),
</a><a href="#h3-2-109" id="h3-2-109" class="i">+            &quot;min&quot; =&gt; Aggregate::Min(expr),
</a><a href="#h3-2-110" id="h3-2-110" class="i">+            &quot;max&quot; =&gt; Aggregate::Max(expr),
</a><a href="#h3-2-111" id="h3-2-111" class="i">+            &quot;sum&quot; =&gt; Aggregate::Sum(expr),
</a><a href="#h3-2-112" id="h3-2-112" class="i">+            name =&gt; return errinput!(&quot;unknown aggregate function {name}&quot;),
</a><a href="#h3-2-113" id="h3-2-113" class="i">+        })
</a>     }
 
<a href="#h3-2-116" id="h3-2-116" class="d">-    /// Extracts aggregate functions from an AST expression tree. This finds the aggregate
</a><a href="#h3-2-117" id="h3-2-117" class="d">-    /// function calls, replaces them with ast::Expression::Column(i), maps the aggregate functions
</a><a href="#h3-2-118" id="h3-2-118" class="d">-    /// to aggregates, and returns them along with their argument expressions.
</a><a href="#h3-2-119" id="h3-2-119" class="d">-    fn extract_aggregates(
</a><a href="#h3-2-120" id="h3-2-120" class="d">-        &amp;self,
</a><a href="#h3-2-121" id="h3-2-121" class="d">-        scope: &amp;Scope,
</a><a href="#h3-2-122" id="h3-2-122" class="d">-        exprs: &amp;mut [(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h3-2-123" id="h3-2-123" class="d">-    ) -&gt; Result&lt;Vec&lt;Aggregate&gt;&gt; {
</a><a href="#h3-2-124" id="h3-2-124" class="d">-        let mut aggregates = Vec::new();
</a><a href="#h3-2-125" id="h3-2-125" class="d">-        for (expr, _) in exprs {
</a><a href="#h3-2-126" id="h3-2-126" class="d">-            expr.transform_mut(
</a><a href="#h3-2-127" id="h3-2-127" class="d">-                &amp;mut |e| match e {
</a><a href="#h3-2-128" id="h3-2-128" class="d">-                    ast::Expression::Function(f, mut args)
</a><a href="#h3-2-129" id="h3-2-129" class="d">-                        if Aggregate::is(&amp;f) &amp;&amp; args.len() == 1 =&gt;
</a><a href="#h3-2-130" id="h3-2-130" class="d">-                    {
</a><a href="#h3-2-131" id="h3-2-131" class="d">-                        let expr = Self::build_expression(args.remove(0), scope)?;
</a><a href="#h3-2-132" id="h3-2-132" class="d">-                        aggregates.push(match f.as_str() {
</a><a href="#h3-2-133" id="h3-2-133" class="d">-                            &quot;avg&quot; =&gt; Aggregate::Average(expr),
</a><a href="#h3-2-134" id="h3-2-134" class="d">-                            &quot;count&quot; =&gt; Aggregate::Count(expr),
</a><a href="#h3-2-135" id="h3-2-135" class="d">-                            &quot;min&quot; =&gt; Aggregate::Min(expr),
</a><a href="#h3-2-136" id="h3-2-136" class="d">-                            &quot;max&quot; =&gt; Aggregate::Max(expr),
</a><a href="#h3-2-137" id="h3-2-137" class="d">-                            &quot;sum&quot; =&gt; Aggregate::Sum(expr),
</a><a href="#h3-2-138" id="h3-2-138" class="d">-                            f =&gt; panic!(&quot;invalid aggregate function {f}&quot;),
</a><a href="#h3-2-139" id="h3-2-139" class="d">-                        });
</a><a href="#h3-2-140" id="h3-2-140" class="d">-                        Ok(ast::Expression::Column(aggregates.len() - 1))
</a><a href="#h3-2-141" id="h3-2-141" class="d">-                    }
</a><a href="#h3-2-142" id="h3-2-142" class="d">-                    _ =&gt; Ok(e),
</a><a href="#h3-2-143" id="h3-2-143" class="d">-                },
</a><a href="#h3-2-144" id="h3-2-144" class="d">-                &amp;mut Ok,
</a><a href="#h3-2-145" id="h3-2-145" class="d">-            )?;
</a><a href="#h3-2-146" id="h3-2-146" class="i">+    /// Checks whether a given AST expression is an aggregate function.
</a><a href="#h3-2-147" id="h3-2-147" class="i">+    fn is_aggregate_function(expr: &amp;ast::Expression) -&gt; bool {
</a><a href="#h3-2-148" id="h3-2-148" class="i">+        if let ast::Expression::Function(name, _) = expr {
</a><a href="#h3-2-149" id="h3-2-149" class="i">+            [&quot;avg&quot;, &quot;count&quot;, &quot;max&quot;, &quot;min&quot;, &quot;sum&quot;].contains(&amp;name.as_str())
</a><a href="#h3-2-150" id="h3-2-150" class="i">+        } else {
</a><a href="#h3-2-151" id="h3-2-151" class="i">+            false
</a>         }
<a href="#h3-2-153" id="h3-2-153" class="d">-        Ok(aggregates)
</a>     }
 
<a href="#h3-2-156" id="h3-2-156" class="d">-    /// Extracts group by expressions, and replaces them with column references with the given
</a><a href="#h3-2-157" id="h3-2-157" class="d">-    /// offset. These can be either an arbitray expression, a reference to a SELECT column, or the
</a><a href="#h3-2-158" id="h3-2-158" class="d">-    /// same expression as a SELECT column. The following are all valid:
</a><a href="#h3-2-159" id="h3-2-159" class="d">-    ///
</a><a href="#h3-2-160" id="h3-2-160" class="d">-    /// SELECT released / 100 AS century, COUNT(*) FROM movies GROUP BY century
</a><a href="#h3-2-161" id="h3-2-161" class="d">-    /// SELECT released / 100, COUNT(*) FROM movies GROUP BY released / 100
</a><a href="#h3-2-162" id="h3-2-162" class="d">-    /// SELECT COUNT(*) FROM movies GROUP BY released / 100
</a><a href="#h3-2-163" id="h3-2-163" class="d">-    fn extract_groups(
</a><a href="#h3-2-164" id="h3-2-164" class="d">-        &amp;self,
</a><a href="#h3-2-165" id="h3-2-165" class="d">-        exprs: &amp;mut [(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h3-2-166" id="h3-2-166" class="d">-        group_by: Vec&lt;ast::Expression&gt;,
</a><a href="#h3-2-167" id="h3-2-167" class="d">-        offset: usize,
</a><a href="#h3-2-168" id="h3-2-168" class="d">-    ) -&gt; Result&lt;Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;&gt; {
</a><a href="#h3-2-169" id="h3-2-169" class="d">-        let mut groups = Vec::new();
</a><a href="#h3-2-170" id="h3-2-170" class="d">-        for g in group_by {
</a><a href="#h3-2-171" id="h3-2-171" class="d">-            // Look for references to SELECT columns with AS labels
</a><a href="#h3-2-172" id="h3-2-172" class="d">-            if let ast::Expression::Field(None, label) = &amp;g {
</a><a href="#h3-2-173" id="h3-2-173" class="d">-                if let Some(i) = exprs.iter().position(|(_, l)| l.as_deref() == Some(label)) {
</a><a href="#h3-2-174" id="h3-2-174" class="d">-                    groups.push((
</a><a href="#h3-2-175" id="h3-2-175" class="d">-                        std::mem::replace(
</a><a href="#h3-2-176" id="h3-2-176" class="d">-                            &amp;mut exprs[i].0,
</a><a href="#h3-2-177" id="h3-2-177" class="d">-                            ast::Expression::Column(offset + groups.len()),
</a><a href="#h3-2-178" id="h3-2-178" class="d">-                        ),
</a><a href="#h3-2-179" id="h3-2-179" class="d">-                        exprs[i].1.clone(),
</a><a href="#h3-2-180" id="h3-2-180" class="d">-                    ));
</a><a href="#h3-2-181" id="h3-2-181" class="d">-                    continue;
</a><a href="#h3-2-182" id="h3-2-182" class="d">-                }
</a><a href="#h3-2-183" id="h3-2-183" class="d">-            }
</a><a href="#h3-2-184" id="h3-2-184" class="d">-            // Look for expressions exactly equal to the group expression
</a><a href="#h3-2-185" id="h3-2-185" class="d">-            if let Some(i) = exprs.iter().position(|(e, _)| e == &amp;g) {
</a><a href="#h3-2-186" id="h3-2-186" class="d">-                groups.push((
</a><a href="#h3-2-187" id="h3-2-187" class="d">-                    std::mem::replace(
</a><a href="#h3-2-188" id="h3-2-188" class="d">-                        &amp;mut exprs[i].0,
</a><a href="#h3-2-189" id="h3-2-189" class="d">-                        ast::Expression::Column(offset + groups.len()),
</a><a href="#h3-2-190" id="h3-2-190" class="d">-                    ),
</a><a href="#h3-2-191" id="h3-2-191" class="d">-                    exprs[i].1.clone(),
</a><a href="#h3-2-192" id="h3-2-192" class="d">-                ));
</a><a href="#h3-2-193" id="h3-2-193" class="d">-                continue;
</a><a href="#h3-2-194" id="h3-2-194" class="d">-            }
</a><a href="#h3-2-195" id="h3-2-195" class="d">-            // Otherwise, just use the group expression directly
</a><a href="#h3-2-196" id="h3-2-196" class="d">-            groups.push((g, None))
</a><a href="#h3-2-197" id="h3-2-197" class="d">-        }
</a><a href="#h3-2-198" id="h3-2-198" class="d">-        // Make sure no group expressions contain Column references, which would be placed here
</a><a href="#h3-2-199" id="h3-2-199" class="d">-        // during extract_aggregates().
</a><a href="#h3-2-200" id="h3-2-200" class="d">-        for (expr, _) in &amp;groups {
</a><a href="#h3-2-201" id="h3-2-201" class="d">-            if Self::is_aggregate(expr) {
</a><a href="#h3-2-202" id="h3-2-202" class="d">-                return errinput!(&quot;group expression cannot contain aggregates&quot;);
</a><a href="#h3-2-203" id="h3-2-203" class="d">-            }
</a><a href="#h3-2-204" id="h3-2-204" class="i">+    /// Collects aggregate functions from SELECT, HAVING, and ORDER BY clauses.
</a><a href="#h3-2-205" id="h3-2-205" class="i">+    fn collect_aggregates&lt;&#39;c&gt;(
</a><a href="#h3-2-206" id="h3-2-206" class="i">+        select: &amp;&#39;c [(ast::Expression, Option&lt;String&gt;)],
</a><a href="#h3-2-207" id="h3-2-207" class="i">+        having: &amp;&#39;c Option&lt;ast::Expression&gt;,
</a><a href="#h3-2-208" id="h3-2-208" class="i">+        order_by: &amp;&#39;c [(ast::Expression, ast::Order)],
</a><a href="#h3-2-209" id="h3-2-209" class="i">+    ) -&gt; Vec&lt;&amp;&#39;c ast::Expression&gt; {
</a><a href="#h3-2-210" id="h3-2-210" class="i">+        let select = select.iter().map(|(expr, _)| expr);
</a><a href="#h3-2-211" id="h3-2-211" class="i">+        let having = having.iter();
</a><a href="#h3-2-212" id="h3-2-212" class="i">+        let order_by = order_by.iter().map(|(expr, _)| expr);
</a><a href="#h3-2-213" id="h3-2-213" class="i">+
</a><a href="#h3-2-214" id="h3-2-214" class="i">+        let mut aggregates = Vec::new();
</a><a href="#h3-2-215" id="h3-2-215" class="i">+        for expr in select.chain(having).chain(order_by) {
</a><a href="#h3-2-216" id="h3-2-216" class="i">+            expr.collect(&amp;|e| Self::is_aggregate_function(e), &amp;mut aggregates)
</a>         }
<a href="#h3-2-218" id="h3-2-218" class="d">-        Ok(groups)
</a><a href="#h3-2-219" id="h3-2-219" class="i">+        aggregates
</a>     }
 
     /// Adds hidden columns to a projection to pass through fields that are used
<a href="#h3-3" id="h3-3" class="h">@@ -477,9 +470,20 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>         projection: &amp;mut Vec&lt;Expression&gt;,
         expr: &amp;ast::Expression,
     ) {
<a href="#h3-3-3" id="h3-3-3" class="d">-        expr.walk(&amp;mut |e| {
</a><a href="#h3-3-4" id="h3-3-4" class="d">-            // Look for field references.
</a><a href="#h3-3-5" id="h3-3-5" class="d">-            let ast::Expression::Field(table, name) = e else {
</a><a href="#h3-3-6" id="h3-3-6" class="i">+        expr.walk(&amp;mut |expr| {
</a><a href="#h3-3-7" id="h3-3-7" class="i">+            // If this is an aggregate function or GROUP BY expression that
</a><a href="#h3-3-8" id="h3-3-8" class="i">+            // isn&#39;t already available in the child scope, pass it through.
</a><a href="#h3-3-9" id="h3-3-9" class="i">+            if let Some(index) = parent_scope.lookup_aggregate(expr) {
</a><a href="#h3-3-10" id="h3-3-10" class="i">+                if scope.lookup_aggregate(expr).is_none() {
</a><a href="#h3-3-11" id="h3-3-11" class="i">+                    let label = parent_scope.get_column_label(index).unwrap();
</a><a href="#h3-3-12" id="h3-3-12" class="i">+                    scope.add_aggregate(expr.clone(), label);
</a><a href="#h3-3-13" id="h3-3-13" class="i">+                    projection.push(Expression::Field(index, Label::None));
</a><a href="#h3-3-14" id="h3-3-14" class="i">+                    return true;
</a><a href="#h3-3-15" id="h3-3-15" class="i">+                }
</a><a href="#h3-3-16" id="h3-3-16" class="i">+            }
</a><a href="#h3-3-17" id="h3-3-17" class="i">+
</a><a href="#h3-3-18" id="h3-3-18" class="i">+            // Otherwise, only look for field references.
</a><a href="#h3-3-19" id="h3-3-19" class="i">+            let ast::Expression::Field(table, name) = expr else {
</a>                 return true;
             };
             // If the field already exists post-projection, do nothing.
<a href="#h3-4" id="h3-4" class="h">@@ -492,79 +496,27 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>             let Ok(index) = parent_scope.lookup_column(table.as_deref(), name) else {
                 return true;
             };
<a href="#h3-4-3" id="h3-4-3" class="d">-            // Add a hidden column to the projection.
</a><a href="#h3-4-4" id="h3-4-4" class="d">-            let label = Label::maybe_qualified(table.clone(), name.clone());
</a><a href="#h3-4-5" id="h3-4-5" class="d">-            scope.add_column(label.clone());
</a><a href="#h3-4-6" id="h3-4-6" class="d">-            projection.push(Expression::Field(index, label));
</a><a href="#h3-4-7" id="h3-4-7" class="i">+            // Add a hidden column to the projection. Use the given label for
</a><a href="#h3-4-8" id="h3-4-8" class="i">+            // the projection, but the qualified label for the scope.
</a><a href="#h3-4-9" id="h3-4-9" class="i">+            scope.add_column(parent_scope.get_column_label(index).unwrap());
</a><a href="#h3-4-10" id="h3-4-10" class="i">+            projection.push(Expression::Field(
</a><a href="#h3-4-11" id="h3-4-11" class="i">+                index,
</a><a href="#h3-4-12" id="h3-4-12" class="i">+                Label::maybe_qualified(table.clone(), name.clone()),
</a><a href="#h3-4-13" id="h3-4-13" class="i">+            ));
</a>             true
         });
     }
 
<a href="#h3-4-18" id="h3-4-18" class="d">-    /// Injects hidden expressions into SELECT expressions. This is used for ORDER BY and HAVING, in
</a><a href="#h3-4-19" id="h3-4-19" class="d">-    /// order to apply these to fields or aggregates that are not present in the SELECT output, e.g.
</a><a href="#h3-4-20" id="h3-4-20" class="d">-    /// to order on a column that is not selected. This is done by replacing the relevant parts of
</a><a href="#h3-4-21" id="h3-4-21" class="d">-    /// the given expression with Column references to either existing columns or new, hidden
</a><a href="#h3-4-22" id="h3-4-22" class="d">-    /// columns in the select expressions. Returns the number of hidden columns added.
</a><a href="#h3-4-23" id="h3-4-23" class="d">-    fn inject_hidden(
</a><a href="#h3-4-24" id="h3-4-24" class="d">-        &amp;self,
</a><a href="#h3-4-25" id="h3-4-25" class="d">-        expr: &amp;mut ast::Expression,
</a><a href="#h3-4-26" id="h3-4-26" class="d">-        select: &amp;mut Vec&lt;(ast::Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h3-4-27" id="h3-4-27" class="d">-    ) -&gt; Result&lt;usize&gt; {
</a><a href="#h3-4-28" id="h3-4-28" class="d">-        // Replace any identical expressions or label references with column references.
</a><a href="#h3-4-29" id="h3-4-29" class="d">-        //
</a><a href="#h3-4-30" id="h3-4-30" class="d">-        // TODO: instead of trying to deduplicate here, before the optimizer has
</a><a href="#h3-4-31" id="h3-4-31" class="d">-        // normalized expressions and such, we should just go ahead and add new
</a><a href="#h3-4-32" id="h3-4-32" class="d">-        // columns for all fields and expressions, and have a separate optimizer
</a><a href="#h3-4-33" id="h3-4-33" class="d">-        // that looks at duplicate expressions in a single projection and
</a><a href="#h3-4-34" id="h3-4-34" class="d">-        // collapses them, rewriting downstream field references.
</a><a href="#h3-4-35" id="h3-4-35" class="d">-        for (i, (sexpr, label)) in select.iter().enumerate() {
</a><a href="#h3-4-36" id="h3-4-36" class="d">-            if expr == sexpr {
</a><a href="#h3-4-37" id="h3-4-37" class="d">-                *expr = ast::Expression::Column(i);
</a><a href="#h3-4-38" id="h3-4-38" class="d">-                continue;
</a><a href="#h3-4-39" id="h3-4-39" class="d">-            }
</a><a href="#h3-4-40" id="h3-4-40" class="d">-            if let Some(label) = label {
</a><a href="#h3-4-41" id="h3-4-41" class="d">-                expr.transform_mut(
</a><a href="#h3-4-42" id="h3-4-42" class="d">-                    &amp;mut |e| match e {
</a><a href="#h3-4-43" id="h3-4-43" class="d">-                        ast::Expression::Field(None, ref l) if l == label =&gt; {
</a><a href="#h3-4-44" id="h3-4-44" class="d">-                            Ok(ast::Expression::Column(i))
</a><a href="#h3-4-45" id="h3-4-45" class="d">-                        }
</a><a href="#h3-4-46" id="h3-4-46" class="d">-                        e =&gt; Ok(e),
</a><a href="#h3-4-47" id="h3-4-47" class="d">-                    },
</a><a href="#h3-4-48" id="h3-4-48" class="d">-                    &amp;mut Ok,
</a><a href="#h3-4-49" id="h3-4-49" class="d">-                )?;
</a><a href="#h3-4-50" id="h3-4-50" class="d">-            }
</a><a href="#h3-4-51" id="h3-4-51" class="d">-        }
</a><a href="#h3-4-52" id="h3-4-52" class="d">-        // Any remaining aggregate functions and field references must be extracted as hidden
</a><a href="#h3-4-53" id="h3-4-53" class="d">-        // columns.
</a><a href="#h3-4-54" id="h3-4-54" class="d">-        let mut hidden = 0;
</a><a href="#h3-4-55" id="h3-4-55" class="d">-        expr.transform_mut(
</a><a href="#h3-4-56" id="h3-4-56" class="d">-            &amp;mut |e| match &amp;e {
</a><a href="#h3-4-57" id="h3-4-57" class="d">-                ast::Expression::Function(f, a) if Aggregate::is(f) =&gt; {
</a><a href="#h3-4-58" id="h3-4-58" class="d">-                    if let ast::Expression::Column(c) = a[0] {
</a><a href="#h3-4-59" id="h3-4-59" class="d">-                        if Self::is_aggregate(&amp;select[c].0) {
</a><a href="#h3-4-60" id="h3-4-60" class="d">-                            return errinput!(&quot;aggregate function cannot reference aggregate&quot;);
</a><a href="#h3-4-61" id="h3-4-61" class="d">-                        }
</a><a href="#h3-4-62" id="h3-4-62" class="d">-                    }
</a><a href="#h3-4-63" id="h3-4-63" class="d">-                    select.push((e, None));
</a><a href="#h3-4-64" id="h3-4-64" class="d">-                    hidden += 1;
</a><a href="#h3-4-65" id="h3-4-65" class="d">-                    Ok(ast::Expression::Column(select.len() - 1))
</a><a href="#h3-4-66" id="h3-4-66" class="d">-                }
</a><a href="#h3-4-67" id="h3-4-67" class="d">-                ast::Expression::Field(_, _) =&gt; {
</a><a href="#h3-4-68" id="h3-4-68" class="d">-                    select.push((e, None));
</a><a href="#h3-4-69" id="h3-4-69" class="d">-                    hidden += 1;
</a><a href="#h3-4-70" id="h3-4-70" class="d">-                    Ok(ast::Expression::Column(select.len() - 1))
</a><a href="#h3-4-71" id="h3-4-71" class="d">-                }
</a><a href="#h3-4-72" id="h3-4-72" class="d">-                _ =&gt; Ok(e),
</a><a href="#h3-4-73" id="h3-4-73" class="d">-            },
</a><a href="#h3-4-74" id="h3-4-74" class="d">-            &amp;mut Ok,
</a><a href="#h3-4-75" id="h3-4-75" class="d">-        )?;
</a><a href="#h3-4-76" id="h3-4-76" class="d">-        Ok(hidden)
</a><a href="#h3-4-77" id="h3-4-77" class="d">-    }
</a><a href="#h3-4-78" id="h3-4-78" class="d">-
</a>     /// Builds an expression from an AST expression.
     pub fn build_expression(expr: ast::Expression, scope: &amp;Scope) -&gt; Result&lt;Expression&gt; {
         use Expression::*;
 
<a href="#h3-4-83" id="h3-4-83" class="i">+        // Look up aggregate functions or GROUP BY expressions. These were added
</a><a href="#h3-4-84" id="h3-4-84" class="i">+        // to the parent scope when building the Aggregate node, if any.
</a><a href="#h3-4-85" id="h3-4-85" class="i">+        if let Some(index) = scope.lookup_aggregate(&amp;expr) {
</a><a href="#h3-4-86" id="h3-4-86" class="i">+            return Ok(Field(index, scope.get_column_label(index)?));
</a><a href="#h3-4-87" id="h3-4-87" class="i">+        }
</a><a href="#h3-4-88" id="h3-4-88" class="i">+
</a>         // Helper for building a boxed expression.
         let build = |expr: Box&lt;ast::Expression&gt;| -&gt; Result&lt;Box&lt;Expression&gt;&gt; {
             Ok(Box::new(Self::build_expression(*expr, scope)?))
<a href="#h3-5" id="h3-5" class="h">@@ -578,13 +530,11 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>                 ast::Literal::Float(f) =&gt; Value::Float(f),
                 ast::Literal::String(s) =&gt; Value::String(s),
             }),
<a href="#h3-5-3" id="h3-5-3" class="d">-            ast::Expression::Column(i) =&gt; Field(i, scope.get_column_label(i)?),
</a>             ast::Expression::Field(table, name) =&gt; Field(
                 scope.lookup_column(table.as_deref(), &amp;name)?,
                 Label::maybe_qualified(table, name),
             ),
<a href="#h3-5-8" id="h3-5-8" class="d">-            // All functions are currently aggregate functions, which should be
</a><a href="#h3-5-9" id="h3-5-9" class="d">-            // processed separately.
</a><a href="#h3-5-10" id="h3-5-10" class="i">+            // Currently, all functions are aggregates, and processed above.
</a>             // TODO: consider adding some basic functions for fun.
             ast::Expression::Function(name, _) =&gt; return errinput!(&quot;unknown function {name}&quot;),
             ast::Expression::Operator(op) =&gt; match op {
<a href="#h3-6" id="h3-6" class="h">@@ -625,11 +575,6 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a>     fn evaluate_constant(expr: ast::Expression) -&gt; Result&lt;Value&gt; {
         Self::build_expression(expr, &amp;Scope::new())?.evaluate(None)
     }
<a href="#h3-6-3" id="h3-6-3" class="d">-
</a><a href="#h3-6-4" id="h3-6-4" class="d">-    /// Checks whether a given expression is an aggregate expression.
</a><a href="#h3-6-5" id="h3-6-5" class="d">-    fn is_aggregate(expr: &amp;ast::Expression) -&gt; bool {
</a><a href="#h3-6-6" id="h3-6-6" class="d">-        expr.contains(&amp;|e| matches!(e, ast::Expression::Function(f, _) if Aggregate::is(f)))
</a><a href="#h3-6-7" id="h3-6-7" class="d">-    }
</a> }
 
 /// A scope maps column/table names to input column indexes for expressions,
<a href="#h3-7" id="h3-7" class="h">@@ -641,6 +586,9 @@ impl&lt;&#39;a, C: Catalog&gt; Planner&lt;&#39;a, C&gt; {
</a> /// currently visible and what names they have. During expression planning, the
 /// scope is used to resolve column names to column indexes, which are placed in
 /// the plan and used during execution.
<a href="#h3-7-3" id="h3-7-3" class="i">+///
</a><a href="#h3-7-4" id="h3-7-4" class="i">+/// It also keeps track of output columns for aggregate functions and GROUP BY
</a><a href="#h3-7-5" id="h3-7-5" class="i">+/// expressions in Aggregate nodes. See aggregates field.
</a> pub struct Scope {
     /// The currently visible columns. If empty, only constant expressions can
     /// be used (no field references).
<a href="#h3-8" id="h3-8" class="h">@@ -653,6 +601,22 @@ pub struct Scope {
</a>     /// Index of unqualified column names to column indexes. If a name points
     /// to multiple columns, lookups will fail with an ambiguous name error.
     unqualified: HashMap&lt;String, Vec&lt;usize&gt;&gt;,
<a href="#h3-8-3" id="h3-8-3" class="i">+    /// Index of aggregate expressions to column indexes. This is used to track
</a><a href="#h3-8-4" id="h3-8-4" class="i">+    /// output columns of Aggregate nodes, e.g. SUM(2 * a + b), and look them up
</a><a href="#h3-8-5" id="h3-8-5" class="i">+    /// from expressions in downstream SELECT, HAVING, and ORDER BY columns,
</a><a href="#h3-8-6" id="h3-8-6" class="i">+    /// e.g. SELECT SUM(2 * a + b) / COUNT(*) FROM table. When build_expression
</a><a href="#h3-8-7" id="h3-8-7" class="i">+    /// encounters an aggregate function, it&#39;s mapped onto an aggregate column
</a><a href="#h3-8-8" id="h3-8-8" class="i">+    /// index via this index.
</a><a href="#h3-8-9" id="h3-8-9" class="i">+    ///
</a><a href="#h3-8-10" id="h3-8-10" class="i">+    /// This is also used to map GROUP BY expressions to the corresponding
</a><a href="#h3-8-11" id="h3-8-11" class="i">+    /// Aggregate node output column when evaluating downstream node expressions
</a><a href="#h3-8-12" id="h3-8-12" class="i">+    /// in SELECT, HAVING, and ORDER BY. For trivial column references, e.g.
</a><a href="#h3-8-13" id="h3-8-13" class="i">+    /// GROUP BY a, b, the column can be accessed and looked up as normal via
</a><a href="#h3-8-14" id="h3-8-14" class="i">+    /// lookup_column() in downstream node expressions, but for more complex
</a><a href="#h3-8-15" id="h3-8-15" class="i">+    /// expressions like GROUP BY a * b / 2, the group column can be accessed
</a><a href="#h3-8-16" id="h3-8-16" class="i">+    /// using the same expression in other nodes, e.g.  GROUP BY a * b / 2 ORDER
</a><a href="#h3-8-17" id="h3-8-17" class="i">+    /// BY a * b / 2.
</a><a href="#h3-8-18" id="h3-8-18" class="i">+    aggregates: HashMap&lt;ast::Expression, usize&gt;,
</a> }
 
 impl Scope {
<a href="#h3-9" id="h3-9" class="h">@@ -663,6 +627,7 @@ impl Scope {
</a>             tables: HashSet::new(),
             qualified: HashMap::new(),
             unqualified: HashMap::new(),
<a href="#h3-9-3" id="h3-9-3" class="i">+            aggregates: HashMap::new(),
</a>         }
     }
 
<a href="#h3-10" id="h3-10" class="h">@@ -701,26 +666,30 @@ impl Scope {
</a> 
     /// Looks up a column index by name, if possible.
     fn lookup_column(&amp;self, table: Option&lt;&amp;str&gt;, name: &amp;str) -&gt; Result&lt;usize&gt; {
<a href="#h3-10-3" id="h3-10-3" class="i">+        let fmtname = || table.map(|table| format!(&quot;{table}.{name}&quot;)).unwrap_or(name.to_string());
</a>         if self.columns.is_empty() {
<a href="#h3-10-5" id="h3-10-5" class="d">-            let field = table.map(|t| format!(&quot;{t}.{name}&quot;)).unwrap_or(name.to_string());
</a><a href="#h3-10-6" id="h3-10-6" class="d">-            return errinput!(&quot;expression must be constant, found field {field}&quot;);
</a><a href="#h3-10-7" id="h3-10-7" class="i">+            return errinput!(&quot;expression must be constant, found field {}&quot;, fmtname());
</a>         }
         if let Some(table) = table {
             if !self.tables.contains(table) {
                 return errinput!(&quot;unknown table {table}&quot;);
             }
<a href="#h3-10-13" id="h3-10-13" class="d">-            self.qualified
</a><a href="#h3-10-14" id="h3-10-14" class="d">-                .get(&amp;(table.to_string(), name.to_string()))
</a><a href="#h3-10-15" id="h3-10-15" class="d">-                .copied()
</a><a href="#h3-10-16" id="h3-10-16" class="d">-                .ok_or(errinput!(&quot;unknown field {table}.{name}&quot;))
</a><a href="#h3-10-17" id="h3-10-17" class="i">+            if let Some(index) = self.qualified.get(&amp;(table.to_string(), name.to_string())) {
</a><a href="#h3-10-18" id="h3-10-18" class="i">+                return Ok(*index);
</a><a href="#h3-10-19" id="h3-10-19" class="i">+            }
</a>         } else if let Some(indexes) = self.unqualified.get(name) {
             if indexes.len() &gt; 1 {
                 return errinput!(&quot;ambiguous field {name}&quot;);
             }
<a href="#h3-10-24" id="h3-10-24" class="d">-            Ok(indexes[0])
</a><a href="#h3-10-25" id="h3-10-25" class="d">-        } else {
</a><a href="#h3-10-26" id="h3-10-26" class="d">-            errinput!(&quot;unknown field {name}&quot;)
</a><a href="#h3-10-27" id="h3-10-27" class="i">+            return Ok(indexes[0]);
</a>         }
<a href="#h3-10-29" id="h3-10-29" class="i">+        if !self.aggregates.is_empty() {
</a><a href="#h3-10-30" id="h3-10-30" class="i">+            return errinput!(
</a><a href="#h3-10-31" id="h3-10-31" class="i">+                &quot;field {} must be used in an aggregate or GROUP BY expression&quot;,
</a><a href="#h3-10-32" id="h3-10-32" class="i">+                fmtname()
</a><a href="#h3-10-33" id="h3-10-33" class="i">+            );
</a><a href="#h3-10-34" id="h3-10-34" class="i">+        }
</a><a href="#h3-10-35" id="h3-10-35" class="i">+        errinput!(&quot;unknown field {}&quot;, fmtname())
</a>     }
 
     /// Fetches a column label by index, if any.
<a href="#h3-11" id="h3-11" class="h">@@ -735,6 +704,31 @@ impl Scope {
</a>         }
     }
 
<a href="#h3-11-3" id="h3-11-3" class="i">+    /// Adds an aggregate expression to the scope, returning the column index.
</a><a href="#h3-11-4" id="h3-11-4" class="i">+    /// This is either an aggregate function or a GROUP BY expression (i.e. not
</a><a href="#h3-11-5" id="h3-11-5" class="i">+    /// just a simple column name). It is used to access the aggregate output or
</a><a href="#h3-11-6" id="h3-11-6" class="i">+    /// GROUP BY column in downstream nodes like SELECT, HAVING, and ORDER BY.
</a><a href="#h3-11-7" id="h3-11-7" class="i">+    ///
</a><a href="#h3-11-8" id="h3-11-8" class="i">+    /// If the expression already exists, the current index is returned.
</a><a href="#h3-11-9" id="h3-11-9" class="i">+    fn add_aggregate(&amp;mut self, expr: ast::Expression, label: Label) -&gt; usize {
</a><a href="#h3-11-10" id="h3-11-10" class="i">+        if let Some(index) = self.aggregates.get(&amp;expr) {
</a><a href="#h3-11-11" id="h3-11-11" class="i">+            return *index;
</a><a href="#h3-11-12" id="h3-11-12" class="i">+        }
</a><a href="#h3-11-13" id="h3-11-13" class="i">+        let index = self.add_column(label);
</a><a href="#h3-11-14" id="h3-11-14" class="i">+        self.aggregates.insert(expr, index);
</a><a href="#h3-11-15" id="h3-11-15" class="i">+        index
</a><a href="#h3-11-16" id="h3-11-16" class="i">+    }
</a><a href="#h3-11-17" id="h3-11-17" class="i">+
</a><a href="#h3-11-18" id="h3-11-18" class="i">+    /// Looks up an aggregate column index by aggregate function or GROUP BY
</a><a href="#h3-11-19" id="h3-11-19" class="i">+    /// expression, if any. Trivial GROUP BY column names are accessed via
</a><a href="#h3-11-20" id="h3-11-20" class="i">+    /// lookup_column() as normal.
</a><a href="#h3-11-21" id="h3-11-21" class="i">+    ///
</a><a href="#h3-11-22" id="h3-11-22" class="i">+    /// Unlike lookup_column(), this returns an option since the caller is
</a><a href="#h3-11-23" id="h3-11-23" class="i">+    /// expected to fall back to normal expressions building.
</a><a href="#h3-11-24" id="h3-11-24" class="i">+    fn lookup_aggregate(&amp;self, expr: &amp;ast::Expression) -&gt; Option&lt;usize&gt; {
</a><a href="#h3-11-25" id="h3-11-25" class="i">+        self.aggregates.get(expr).copied()
</a><a href="#h3-11-26" id="h3-11-26" class="i">+    }
</a><a href="#h3-11-27" id="h3-11-27" class="i">+
</a>     /// Number of columns currently in the scope.
     fn len(&amp;self) -&gt; usize {
         self.columns.len()
<b>diff --git a/<a id="h4" href="../file/src/sql/testscripts/queries/aggregate.html">src/sql/testscripts/queries/aggregate</a> b/<a href="../file/src/sql/testscripts/queries/aggregate.html">src/sql/testscripts/queries/aggregate</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -17,7 +17,7 @@
</a> ok
 
 # COUNT(*) returns the row count.
<a href="#h4-0-3" id="h4-0-3" class="d">-# TODO: revisit the plan here.
</a><a href="#h4-0-4" id="h4-0-4" class="i">+# TODO: revisit the plan here. This can be eliminated by short-circuiting optimizer.
</a> [plan]&gt; SELECT COUNT(*) FROM test
 ---
 Projection: #0
<a href="#h4-1" id="h4-1" class="h">@@ -26,7 +26,7 @@ Projection: #0
</a> 6
 
 # COUNT works on constant values.
<a href="#h4-1-3" id="h4-1-3" class="d">-# TODO: revisit the plan here.
</a><a href="#h4-1-4" id="h4-1-4" class="i">+# TODO: revisit the plan here. This can be eliminated by short-circuiting optimizer.
</a> [plan,header]&gt; SELECT COUNT(NULL), COUNT(TRUE), COUNT(1), COUNT(3.14), COUNT(NAN), COUNT(&#39;&#39;)
 ---
 Projection: #0, #1, #2, #3, #4, #5
<a href="#h4-2" id="h4-2" class="h">@@ -44,7 +44,7 @@ Projection: #0, #1, #2, #3
</a> 0, 0, 0, 0
 
 # COUNT returns number of non-NULL values.
<a href="#h4-2-3" id="h4-2-3" class="d">-# TODO: revisit the plan here, the last projection is unnecessary.
</a><a href="#h4-2-4" id="h4-2-4" class="i">+# TODO: revisit the plan here. This can be eliminated by short-circuiting optimizer.
</a> [plan,header]&gt; SELECT COUNT(id), COUNT(&quot;bool&quot;), COUNT(&quot;float&quot;), COUNT(&quot;string&quot;) FROM test
 ---
 Projection: #0, #1, #2, #3
<a href="#h4-3" id="h4-3" class="h">@@ -283,14 +283,12 @@ Projection: #0, #1, #2, #3, #4
</a>    └─ Scan: test
 6, 1, 1, 6, 1
 
<a href="#h4-3-3" id="h4-3-3" class="d">-# Constant aggregates can be used with rows including values.
</a><a href="#h4-3-4" id="h4-3-4" class="d">-# TODO: this doesn&#39;t work with SELECT *. It also doesn&#39;t work with fields.
</a><a href="#h4-3-5" id="h4-3-5" class="d">-# It shouldn&#39;t, but the error message count be better.
</a><a href="#h4-3-6" id="h4-3-6" class="i">+# Constant aggregates can&#39;t be used with value rows.
</a> [plan]!&gt; SELECT *, COUNT(1), MIN(1), MAX(1), SUM(1), AVG(1) FROM test
 [plan]!&gt; SELECT id, COUNT(1), MIN(1), MAX(1), SUM(1), AVG(1) FROM test
 ---
 Error: invalid input: unexpected token ,
<a href="#h4-3-11" id="h4-3-11" class="d">-Error: invalid input: unknown field id
</a><a href="#h4-3-12" id="h4-3-12" class="i">+Error: invalid input: field id must be used in an aggregate or GROUP BY expression
</a> 
 # Aggregate can be expression, both inside and outside the aggregate.
 [plan]&gt; SELECT SUM(&quot;int&quot; * 10) / COUNT(&quot;int&quot;) + 7 FROM test WHERE &quot;int&quot; IS NOT NULL
<a href="#h4-4" id="h4-4" class="h">@@ -301,7 +299,6 @@ Projection: #0 / #1 + 7
</a> 117
 
 # Aggregate functions can&#39;t be nested.
<a href="#h4-4-3" id="h4-4-3" class="d">-# TODO: improve the error message here.
</a> !&gt; SELECT MIN(MAX(&quot;int&quot;)) FROM test
 ---
<a href="#h4-4-6" id="h4-4-6" class="d">-Error: invalid input: unknown function max
</a><a href="#h4-4-7" id="h4-4-7" class="i">+Error: invalid input: aggregate functions can&#39;t be nested
</a><b>diff --git a/<a id="h5" href="../file/src/sql/testscripts/queries/group_by.html">src/sql/testscripts/queries/group_by</a> b/<a href="../file/src/sql/testscripts/queries/group_by.html">src/sql/testscripts/queries/group_by</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -28,7 +28,7 @@ Projection: #0, #1, #2, #3, #4
</a> └─ Aggregate: count(id), min(id), max(id), sum(id), avg(id) group by id
    └─ Nothing
 
<a href="#h5-0-3" id="h5-0-3" class="d">-# Simple GROUP BY.
</a><a href="#h5-0-4" id="h5-0-4" class="i">+# Simple GROUP BY, including NULL group.
</a> [plan]&gt; SELECT &quot;group&quot;, COUNT(*) FROM test GROUP BY &quot;group&quot;
 ---
 Projection: test.group, #0
<a href="#h5-1" id="h5-1" class="h">@@ -39,39 +39,32 @@ a, 3
</a> b, 3
 
 [plan]&gt; SELECT &quot;group&quot;, COUNT(*), MIN(&quot;bool&quot;), MAX(&quot;string&quot;), SUM(&quot;int&quot;), AVG(&quot;float&quot;) \
<a href="#h5-1-3" id="h5-1-3" class="d">-    FROM test WHERE id != 0 GROUP BY &quot;group&quot;
</a><a href="#h5-1-4" id="h5-1-4" class="i">+    FROM test GROUP BY &quot;group&quot;
</a> ---
 Projection: test.group, #0, #1, #2, #3, #4
 └─ Aggregate: count(TRUE), min(bool), max(string), sum(int), avg(float) group by group
<a href="#h5-1-8" id="h5-1-8" class="d">-   └─ Scan: test (NOT id = 0)
</a><a href="#h5-1-9" id="h5-1-9" class="i">+   └─ Scan: test
</a><a href="#h5-1-10" id="h5-1-10" class="i">+NULL, 1, NULL, NULL, NULL, NULL
</a> a, 3, FALSE, AB, 9, NaN
 b, 3, FALSE, 👋, 41, NaN
 
<a href="#h5-1-14" id="h5-1-14" class="d">-# GROUP BY works with a NULL group.
</a><a href="#h5-1-15" id="h5-1-15" class="d">-[plan]&gt; SELECT &quot;group&quot;, COUNT(*) FROM test GROUP BY &quot;group&quot;
</a><a href="#h5-1-16" id="h5-1-16" class="d">----
</a><a href="#h5-1-17" id="h5-1-17" class="d">-Projection: test.group, #0
</a><a href="#h5-1-18" id="h5-1-18" class="d">-└─ Aggregate: count(TRUE) group by group
</a><a href="#h5-1-19" id="h5-1-19" class="d">-   └─ Scan: test
</a><a href="#h5-1-20" id="h5-1-20" class="d">-NULL, 1
</a><a href="#h5-1-21" id="h5-1-21" class="d">-a, 3
</a><a href="#h5-1-22" id="h5-1-22" class="d">-b, 3
</a><a href="#h5-1-23" id="h5-1-23" class="d">-
</a> # GROUP BY works on booleans.
<a href="#h5-1-25" id="h5-1-25" class="d">-[plan]&gt; SELECT &quot;bool&quot;, COUNT(*) FROM test WHERE id != 0 GROUP BY &quot;bool&quot;
</a><a href="#h5-1-26" id="h5-1-26" class="i">+[plan]&gt; SELECT &quot;bool&quot;, COUNT(*) FROM test GROUP BY &quot;bool&quot;
</a> ---
 Projection: test.bool, #0
 └─ Aggregate: count(TRUE) group by bool
<a href="#h5-1-30" id="h5-1-30" class="d">-   └─ Scan: test (NOT id = 0)
</a><a href="#h5-1-31" id="h5-1-31" class="i">+   └─ Scan: test
</a><a href="#h5-1-32" id="h5-1-32" class="i">+NULL, 1
</a> FALSE, 3
 TRUE, 3
 
 # GROUP BY works on integers.
<a href="#h5-1-37" id="h5-1-37" class="d">-[plan]&gt; SELECT &quot;int&quot;, COUNT(*) FROM test WHERE id != 0 GROUP BY &quot;int&quot;
</a><a href="#h5-1-38" id="h5-1-38" class="i">+[plan]&gt; SELECT &quot;int&quot;, COUNT(*) FROM test GROUP BY &quot;int&quot;
</a> ---
 Projection: test.int, #0
 └─ Aggregate: count(TRUE) group by int
<a href="#h5-1-42" id="h5-1-42" class="d">-   └─ Scan: test (NOT id = 0)
</a><a href="#h5-1-43" id="h5-1-43" class="i">+   └─ Scan: test
</a><a href="#h5-1-44" id="h5-1-44" class="i">+NULL, 1
</a> -1, 2
 0, 1
 3, 1
<a href="#h5-2" id="h5-2" class="h">@@ -79,54 +72,53 @@ Projection: test.int, #0
</a> 42, 1
 
 # GROUP BY works with floats, including a NAN group and -0.0 and 0.0 being equal.
<a href="#h5-2-3" id="h5-2-3" class="d">-[plan]&gt; SELECT &quot;float&quot;, COUNT(*) FROM test WHERE id != 0 GROUP BY &quot;float&quot;
</a><a href="#h5-2-4" id="h5-2-4" class="i">+[plan]&gt; SELECT &quot;float&quot;, COUNT(*) FROM test GROUP BY &quot;float&quot;
</a> ---
 Projection: test.float, #0
 └─ Aggregate: count(TRUE) group by float
<a href="#h5-2-8" id="h5-2-8" class="d">-   └─ Scan: test (NOT id = 0)
</a><a href="#h5-2-9" id="h5-2-9" class="i">+   └─ Scan: test
</a><a href="#h5-2-10" id="h5-2-10" class="i">+NULL, 1
</a> 0, 2
 3.14, 1
 inf, 1
 NaN, 2
 
 # GROUP BY works on strings.
<a href="#h5-2-17" id="h5-2-17" class="d">-[plan]&gt; SELECT &quot;string&quot;, COUNT(*) FROM test WHERE id != 0 GROUP BY &quot;string&quot;
</a><a href="#h5-2-18" id="h5-2-18" class="i">+[plan]&gt; SELECT &quot;string&quot;, COUNT(*) FROM test GROUP BY &quot;string&quot;
</a> ---
 Projection: test.string, #0
 └─ Aggregate: count(TRUE) group by string
<a href="#h5-2-22" id="h5-2-22" class="d">-   └─ Scan: test (NOT id = 0)
</a><a href="#h5-2-23" id="h5-2-23" class="i">+   └─ Scan: test
</a><a href="#h5-2-24" id="h5-2-24" class="i">+NULL, 1
</a> , 2
 AB, 1
 abc, 2
 👋, 1
 
 # GROUP BY works even if the group column isn&#39;t in the result.
<a href="#h5-2-31" id="h5-2-31" class="d">-[plan]&gt; SELECT COUNT(*) FROM test WHERE id != 0 GROUP BY &quot;group&quot;
</a><a href="#h5-2-32" id="h5-2-32" class="i">+[plan]&gt; SELECT COUNT(*) FROM test GROUP BY &quot;group&quot;
</a> ---
 Projection: #0
 └─ Aggregate: count(TRUE) group by group
<a href="#h5-2-36" id="h5-2-36" class="d">-   └─ Scan: test (NOT id = 0)
</a><a href="#h5-2-37" id="h5-2-37" class="i">+   └─ Scan: test
</a><a href="#h5-2-38" id="h5-2-38" class="i">+1
</a> 3
 3
 
 # GROUP BY works when there is no aggregate function.
<a href="#h5-2-43" id="h5-2-43" class="d">-[plan]&gt; SELECT &quot;group&quot; FROM test WHERE id != 0 GROUP BY &quot;group&quot;
</a><a href="#h5-2-44" id="h5-2-44" class="i">+[plan]&gt; SELECT &quot;group&quot; FROM test GROUP BY &quot;group&quot;
</a> ---
 Projection: test.group
 └─ Aggregate:  group by group
<a href="#h5-2-48" id="h5-2-48" class="d">-   └─ Scan: test (NOT id = 0)
</a><a href="#h5-2-49" id="h5-2-49" class="i">+   └─ Scan: test
</a><a href="#h5-2-50" id="h5-2-50" class="i">+NULL
</a> a
 b
 
<a href="#h5-2-54" id="h5-2-54" class="d">-# GROUP BY works on aliases, in which case the original table is unknown.
</a><a href="#h5-2-55" id="h5-2-55" class="d">-[plan]&gt; SELECT &quot;group&quot; AS g, COUNT(*) FROM test GROUP BY g
</a><a href="#h5-2-56" id="h5-2-56" class="i">+# GROUP BY does not work with SELECT aliases (also the case in e.g. SQL server).
</a><a href="#h5-2-57" id="h5-2-57" class="i">+!&gt; SELECT &quot;group&quot; AS g, COUNT(*) FROM test GROUP BY g
</a> ---
<a href="#h5-2-59" id="h5-2-59" class="d">-Projection: g, #0
</a><a href="#h5-2-60" id="h5-2-60" class="d">-└─ Aggregate: count(TRUE) group by group
</a><a href="#h5-2-61" id="h5-2-61" class="d">-   └─ Scan: test
</a><a href="#h5-2-62" id="h5-2-62" class="d">-NULL, 1
</a><a href="#h5-2-63" id="h5-2-63" class="d">-a, 3
</a><a href="#h5-2-64" id="h5-2-64" class="d">-b, 3
</a><a href="#h5-2-65" id="h5-2-65" class="i">+Error: invalid input: unknown field g
</a> 
 [plan]&gt; SELECT &quot;group&quot;, COUNT(*) FROM test AS t GROUP BY t.&quot;group&quot;
 ---
<a href="#h5-3" id="h5-3" class="h">@@ -142,14 +134,13 @@ b, 3
</a> Error: invalid input: unknown table test
 
 # It errors when there is a non-group column.
<a href="#h5-3-3" id="h5-3-3" class="d">-# TODO: improve the error message.
</a><a href="#h5-3-4" id="h5-3-4" class="d">-!&gt; SELECT &quot;group&quot;, id FROM test WHERE id != 0 GROUP BY &quot;group&quot;
</a><a href="#h5-3-5" id="h5-3-5" class="i">+!&gt; SELECT &quot;group&quot;, id FROM test GROUP BY &quot;group&quot;
</a> ---
<a href="#h5-3-7" id="h5-3-7" class="d">-Error: invalid input: unknown field id
</a><a href="#h5-3-8" id="h5-3-8" class="i">+Error: invalid input: field id must be used in an aggregate or GROUP BY expression
</a> 
 # It errors on unknown tables and columns.
<a href="#h5-3-11" id="h5-3-11" class="d">-!&gt; SELECT COUNT(*) FROM test WHERE id != 0 GROUP BY unknown
</a><a href="#h5-3-12" id="h5-3-12" class="d">-!&gt; SELECT COUNT(*) FROM test WHERE id != 0 GROUP BY unknown.id
</a><a href="#h5-3-13" id="h5-3-13" class="i">+!&gt; SELECT COUNT(*) FROM test GROUP BY unknown
</a><a href="#h5-3-14" id="h5-3-14" class="i">+!&gt; SELECT COUNT(*) FROM test GROUP BY unknown.id
</a> ---
 Error: invalid input: unknown field unknown
 Error: invalid input: unknown table unknown
<a href="#h5-4" id="h5-4" class="h">@@ -179,32 +170,29 @@ Projection: #1, #0
</a> 0, 4
 1, 3
 
<a href="#h5-4-3" id="h5-4-3" class="d">-# GROUP BY can use an aliased expression.
</a><a href="#h5-4-4" id="h5-4-4" class="d">-[plan]&gt; SELECT id % 2 AS mod, COUNT(*) FROM test GROUP BY mod
</a><a href="#h5-4-5" id="h5-4-5" class="i">+# GROUP BY can&#39;t use an aliased expression.
</a><a href="#h5-4-6" id="h5-4-6" class="i">+!&gt; SELECT id % 2 AS mod, COUNT(*) FROM test GROUP BY mod
</a> ---
<a href="#h5-4-8" id="h5-4-8" class="d">-Projection: mod, #0
</a><a href="#h5-4-9" id="h5-4-9" class="d">-└─ Aggregate: count(TRUE) group by id % 2
</a><a href="#h5-4-10" id="h5-4-10" class="d">-   └─ Scan: test
</a><a href="#h5-4-11" id="h5-4-11" class="d">-0, 4
</a><a href="#h5-4-12" id="h5-4-12" class="d">-1, 3
</a><a href="#h5-4-13" id="h5-4-13" class="i">+Error: invalid input: unknown field mod
</a> 
 # GROUP BY can&#39;t use aggregate functions.
 !&gt; SELECT COUNT(*) FROM test GROUP BY MIN(id)
 ---
<a href="#h5-4-18" id="h5-4-18" class="d">-Error: invalid input: group expression cannot contain aggregates
</a><a href="#h5-4-19" id="h5-4-19" class="i">+Error: invalid input: unknown function min
</a> 
 # GROUP BY works with multiple groups.
<a href="#h5-4-22" id="h5-4-22" class="d">-[plan]&gt; SELECT &quot;group&quot;, &quot;bool&quot;, COUNT(*) FROM test WHERE id != 0 GROUP BY &quot;group&quot;, &quot;bool&quot;
</a><a href="#h5-4-23" id="h5-4-23" class="i">+[plan]&gt; SELECT &quot;group&quot;, &quot;bool&quot;, COUNT(*) FROM test GROUP BY &quot;group&quot;, &quot;bool&quot;
</a> ---
 Projection: test.group, test.bool, #0
 └─ Aggregate: count(TRUE) group by group, bool
<a href="#h5-4-27" id="h5-4-27" class="d">-   └─ Scan: test (NOT id = 0)
</a><a href="#h5-4-28" id="h5-4-28" class="i">+   └─ Scan: test
</a><a href="#h5-4-29" id="h5-4-29" class="i">+NULL, NULL, 1
</a> a, FALSE, 1
 a, TRUE, 2
 b, FALSE, 2
 b, TRUE, 1
 
<a href="#h5-4-35" id="h5-4-35" class="d">-# GROUP BY work with joins.
</a><a href="#h5-4-36" id="h5-4-36" class="i">+# GROUP BY works with joins.
</a> [plan]&gt; SELECT t.id % 2, COUNT(*) FROM test t JOIN other o ON t.id % 2 = o.id GROUP BY t.id % 2
 ---
 Projection: #1, #0
<b>diff --git a/<a id="h6" href="../file/src/sql/testscripts/queries/having.html">src/sql/testscripts/queries/having</a> b/<a href="../file/src/sql/testscripts/queries/having.html">src/sql/testscripts/queries/having</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -32,21 +32,37 @@ Scan: test (id &gt; 3)
</a> [plan]&gt; SELECT id FROM test HAVING &quot;int&quot; &gt; 3
 ---
 Projection: #0
<a href="#h6-0-3" id="h6-0-3" class="d">-└─ Filter: test.int &gt; 3
</a><a href="#h6-0-4" id="h6-0-4" class="i">+└─ Filter: int &gt; 3
</a>    └─ Projection: id, int
       └─ Scan: test
 4
 5
 
<a href="#h6-0-10" id="h6-0-10" class="d">-# Having works with an aggregate function.
</a><a href="#h6-0-11" id="h6-0-11" class="d">-# TODO: it&#39;s unnecessary do duplicate the aggregation here.
</a><a href="#h6-0-12" id="h6-0-12" class="d">-# TODO: test without a GROUP BY clause.
</a><a href="#h6-0-13" id="h6-0-13" class="i">+# Having works with an aggregate function, even if it&#39;s not in SELECT.
</a> [plan]&gt; SELECT &quot;group&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) &gt; 10
 ---
 Projection: #0, #1
 └─ Filter: #2 &gt; 10
<a href="#h6-0-18" id="h6-0-18" class="d">-   └─ Projection: test.group, #0, #1
</a><a href="#h6-0-19" id="h6-0-19" class="d">-      └─ Aggregate: max(int), max(int) group by group
</a><a href="#h6-0-20" id="h6-0-20" class="i">+   └─ Projection: test.group, #0, #0
</a><a href="#h6-0-21" id="h6-0-21" class="i">+      └─ Aggregate: max(int) group by group
</a><a href="#h6-0-22" id="h6-0-22" class="i">+         └─ Scan: test
</a><a href="#h6-0-23" id="h6-0-23" class="i">+b, 42
</a><a href="#h6-0-24" id="h6-0-24" class="i">+
</a><a href="#h6-0-25" id="h6-0-25" class="i">+[plan]&gt; SELECT &quot;group&quot; FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) &gt; 10
</a><a href="#h6-0-26" id="h6-0-26" class="i">+---
</a><a href="#h6-0-27" id="h6-0-27" class="i">+Projection: #0
</a><a href="#h6-0-28" id="h6-0-28" class="i">+└─ Filter: #1 &gt; 10
</a><a href="#h6-0-29" id="h6-0-29" class="i">+   └─ Projection: test.group, #0
</a><a href="#h6-0-30" id="h6-0-30" class="i">+      └─ Aggregate: max(int) group by group
</a><a href="#h6-0-31" id="h6-0-31" class="i">+         └─ Scan: test
</a><a href="#h6-0-32" id="h6-0-32" class="i">+b
</a><a href="#h6-0-33" id="h6-0-33" class="i">+
</a><a href="#h6-0-34" id="h6-0-34" class="i">+[plan]&gt; SELECT &quot;group&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;group&quot; HAVING MAX(&quot;int&quot;) - MIN(&quot;int&quot;) &gt; 10
</a><a href="#h6-0-35" id="h6-0-35" class="i">+---
</a><a href="#h6-0-36" id="h6-0-36" class="i">+Projection: #0, #1
</a><a href="#h6-0-37" id="h6-0-37" class="i">+└─ Filter: #2 - #3 &gt; 10
</a><a href="#h6-0-38" id="h6-0-38" class="i">+   └─ Projection: test.group, #0, #0, #1
</a><a href="#h6-0-39" id="h6-0-39" class="i">+      └─ Aggregate: max(int), min(int) group by group
</a>          └─ Scan: test
 b, 42
 
<a href="#h6-1" id="h6-1" class="h">@@ -74,16 +90,46 @@ b, 3
</a> ---
 Projection: #0, #1
 └─ Filter: #2 / #3 &gt; 3
<a href="#h6-1-3" id="h6-1-3" class="d">-   └─ Projection: test.group, #0, #1, #2
</a><a href="#h6-1-4" id="h6-1-4" class="d">-      └─ Aggregate: count(TRUE), max(int), count(TRUE) group by group
</a><a href="#h6-1-5" id="h6-1-5" class="i">+   └─ Projection: test.group, #0, #1, #0
</a><a href="#h6-1-6" id="h6-1-6" class="i">+      └─ Aggregate: count(TRUE), max(int) group by group
</a>          └─ Scan: test
 b, 3
 
<a href="#h6-1-10" id="h6-1-10" class="i">+# Having works with compound expressions using complex GROUP BY expressions
</a><a href="#h6-1-11" id="h6-1-11" class="i">+# that are not on the SELECT clause.
</a><a href="#h6-1-12" id="h6-1-12" class="i">+[plan]&gt; SELECT COUNT(*) FROM test GROUP BY id % 2 HAVING 2 - id % 2 + 1 &gt; 1
</a><a href="#h6-1-13" id="h6-1-13" class="i">+---
</a><a href="#h6-1-14" id="h6-1-14" class="i">+Projection: #0
</a><a href="#h6-1-15" id="h6-1-15" class="i">+└─ Filter: 2 - #1 + 1 &gt; 1
</a><a href="#h6-1-16" id="h6-1-16" class="i">+   └─ Projection: #0, #1
</a><a href="#h6-1-17" id="h6-1-17" class="i">+      └─ Aggregate: count(TRUE) group by id % 2
</a><a href="#h6-1-18" id="h6-1-18" class="i">+         └─ Scan: test
</a><a href="#h6-1-19" id="h6-1-19" class="i">+4
</a><a href="#h6-1-20" id="h6-1-20" class="i">+3
</a><a href="#h6-1-21" id="h6-1-21" class="i">+
</a><a href="#h6-1-22" id="h6-1-22" class="i">+# Having can use (un)qualified expressions for an (un)qualified GROUP BY.
</a><a href="#h6-1-23" id="h6-1-23" class="i">+[plan]&gt; SELECT COUNT(*) FROM test GROUP BY &quot;group&quot; HAVING test.&quot;group&quot; = &#39;a&#39;
</a><a href="#h6-1-24" id="h6-1-24" class="i">+---
</a><a href="#h6-1-25" id="h6-1-25" class="i">+Projection: #0
</a><a href="#h6-1-26" id="h6-1-26" class="i">+└─ Filter: test.group = a
</a><a href="#h6-1-27" id="h6-1-27" class="i">+   └─ Projection: #0, test.group
</a><a href="#h6-1-28" id="h6-1-28" class="i">+      └─ Aggregate: count(TRUE) group by group
</a><a href="#h6-1-29" id="h6-1-29" class="i">+         └─ Scan: test
</a><a href="#h6-1-30" id="h6-1-30" class="i">+3
</a><a href="#h6-1-31" id="h6-1-31" class="i">+
</a><a href="#h6-1-32" id="h6-1-32" class="i">+[plan]&gt; SELECT COUNT(*) FROM test GROUP BY test.&quot;group&quot; HAVING &quot;group&quot; = &#39;a&#39;
</a><a href="#h6-1-33" id="h6-1-33" class="i">+---
</a><a href="#h6-1-34" id="h6-1-34" class="i">+Projection: #0
</a><a href="#h6-1-35" id="h6-1-35" class="i">+└─ Filter: group = a
</a><a href="#h6-1-36" id="h6-1-36" class="i">+   └─ Projection: #0, group
</a><a href="#h6-1-37" id="h6-1-37" class="i">+      └─ Aggregate: count(TRUE) group by test.group
</a><a href="#h6-1-38" id="h6-1-38" class="i">+         └─ Scan: test
</a><a href="#h6-1-39" id="h6-1-39" class="i">+3
</a><a href="#h6-1-40" id="h6-1-40" class="i">+
</a> # Having errors on nested aggregate functions.
<a href="#h6-1-42" id="h6-1-42" class="d">-# TODO: fix the error message.
</a> !&gt; SELECT &quot;group&quot;, COUNT(*) FROM test GROUP BY &quot;group&quot; HAVING MAX(MIN(&quot;int&quot;)) &gt; 0
 ---
<a href="#h6-1-45" id="h6-1-45" class="d">-Error: invalid input: unknown function min
</a><a href="#h6-1-46" id="h6-1-46" class="i">+Error: invalid input: aggregate functions can&#39;t be nested
</a> 
 # Having errors on fields not in the SELECT or GROUP BY clauses.
 # TODO: improve the error message.
<b>diff --git a/<a id="h7" href="../file/src/sql/testscripts/queries/order.html">src/sql/testscripts/queries/order</a> b/<a href="../file/src/sql/testscripts/queries/order.html">src/sql/testscripts/queries/order</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -470,11 +470,70 @@ Order: o.id desc, t.id asc
</a> 9, NULL, NULL, NULL, 👍, 1, 1, a
 
 # Order by aggregates, both when in SELECT and otherwise.
<a href="#h7-0-3" id="h7-0-3" class="d">-# TODO: fix these.
</a><a href="#h7-0-4" id="h7-0-4" class="d">-[plan]!&gt; SELECT &quot;bool&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;bool&quot; ORDER BY MAX(&quot;int&quot;) DESC
</a><a href="#h7-0-5" id="h7-0-5" class="i">+[plan]&gt; SELECT &quot;bool&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;bool&quot; ORDER BY MAX(&quot;int&quot;) DESC
</a> ---
<a href="#h7-0-7" id="h7-0-7" class="d">-Error: invalid input: unknown function max
</a><a href="#h7-0-8" id="h7-0-8" class="i">+Projection: #0, #1
</a><a href="#h7-0-9" id="h7-0-9" class="i">+└─ Order: #2 desc
</a><a href="#h7-0-10" id="h7-0-10" class="i">+   └─ Projection: test.bool, #0, #0
</a><a href="#h7-0-11" id="h7-0-11" class="i">+      └─ Aggregate: max(int) group by bool
</a><a href="#h7-0-12" id="h7-0-12" class="i">+         └─ Scan: test
</a><a href="#h7-0-13" id="h7-0-13" class="i">+TRUE, 0
</a><a href="#h7-0-14" id="h7-0-14" class="i">+FALSE, -1
</a><a href="#h7-0-15" id="h7-0-15" class="i">+NULL, NULL
</a><a href="#h7-0-16" id="h7-0-16" class="i">+
</a><a href="#h7-0-17" id="h7-0-17" class="i">+[plan]&gt; SELECT &quot;bool&quot; FROM test GROUP BY &quot;bool&quot; ORDER BY MAX(&quot;int&quot;) DESC
</a><a href="#h7-0-18" id="h7-0-18" class="i">+---
</a><a href="#h7-0-19" id="h7-0-19" class="i">+Projection: #0
</a><a href="#h7-0-20" id="h7-0-20" class="i">+└─ Order: #1 desc
</a><a href="#h7-0-21" id="h7-0-21" class="i">+   └─ Projection: test.bool, #0
</a><a href="#h7-0-22" id="h7-0-22" class="i">+      └─ Aggregate: max(int) group by bool
</a><a href="#h7-0-23" id="h7-0-23" class="i">+         └─ Scan: test
</a><a href="#h7-0-24" id="h7-0-24" class="i">+TRUE
</a><a href="#h7-0-25" id="h7-0-25" class="i">+FALSE
</a><a href="#h7-0-26" id="h7-0-26" class="i">+NULL
</a><a href="#h7-0-27" id="h7-0-27" class="i">+
</a><a href="#h7-0-28" id="h7-0-28" class="i">+[plan]&gt; SELECT &quot;bool&quot;, MAX(&quot;int&quot;) FROM test GROUP BY &quot;bool&quot; ORDER BY MAX(&quot;int&quot;) - MIN(&quot;int&quot;) DESC
</a><a href="#h7-0-29" id="h7-0-29" class="i">+---
</a><a href="#h7-0-30" id="h7-0-30" class="i">+Projection: #0, #1
</a><a href="#h7-0-31" id="h7-0-31" class="i">+└─ Order: #2 - #3 desc
</a><a href="#h7-0-32" id="h7-0-32" class="i">+   └─ Projection: test.bool, #0, #0, #1
</a><a href="#h7-0-33" id="h7-0-33" class="i">+      └─ Aggregate: max(int), min(int) group by bool
</a><a href="#h7-0-34" id="h7-0-34" class="i">+         └─ Scan: test
</a><a href="#h7-0-35" id="h7-0-35" class="i">+FALSE, -1
</a><a href="#h7-0-36" id="h7-0-36" class="i">+TRUE, 0
</a><a href="#h7-0-37" id="h7-0-37" class="i">+NULL, NULL
</a><a href="#h7-0-38" id="h7-0-38" class="i">+
</a><a href="#h7-0-39" id="h7-0-39" class="i">+# ORDER BY works with compound expressions using complex GROUP BY expressions
</a><a href="#h7-0-40" id="h7-0-40" class="i">+# that are not on the SELECT clause.
</a><a href="#h7-0-41" id="h7-0-41" class="i">+[plan]&gt; SELECT COUNT(*) FROM test GROUP BY id % 2 ORDER BY 2 - id % 2 + 1 &gt; 1
</a><a href="#h7-0-42" id="h7-0-42" class="i">+---
</a><a href="#h7-0-43" id="h7-0-43" class="i">+Projection: #0
</a><a href="#h7-0-44" id="h7-0-44" class="i">+└─ Order: 2 - #1 + 1 &gt; 1 asc
</a><a href="#h7-0-45" id="h7-0-45" class="i">+   └─ Projection: #0, #1
</a><a href="#h7-0-46" id="h7-0-46" class="i">+      └─ Aggregate: count(TRUE) group by id % 2
</a><a href="#h7-0-47" id="h7-0-47" class="i">+         └─ Scan: test
</a><a href="#h7-0-48" id="h7-0-48" class="i">+5
</a><a href="#h7-0-49" id="h7-0-49" class="i">+5
</a> 
<a href="#h7-0-51" id="h7-0-51" class="d">-[plan]!&gt; SELECT &quot;bool&quot; FROM test GROUP BY &quot;bool&quot; ORDER BY MAX(&quot;int&quot;) DESC
</a><a href="#h7-0-52" id="h7-0-52" class="i">+# ORDER BY can use (un)qualified expressions for an (un)qualified GROUP BY.
</a><a href="#h7-0-53" id="h7-0-53" class="i">+[plan]&gt; SELECT COUNT(*) FROM test GROUP BY &quot;bool&quot; ORDER BY test.&quot;bool&quot;
</a> ---
<a href="#h7-0-55" id="h7-0-55" class="d">-Error: invalid input: unknown function max
</a><a href="#h7-0-56" id="h7-0-56" class="i">+Projection: #0
</a><a href="#h7-0-57" id="h7-0-57" class="i">+└─ Order: test.bool asc
</a><a href="#h7-0-58" id="h7-0-58" class="i">+   └─ Projection: #0, test.bool
</a><a href="#h7-0-59" id="h7-0-59" class="i">+      └─ Aggregate: count(TRUE) group by bool
</a><a href="#h7-0-60" id="h7-0-60" class="i">+         └─ Scan: test
</a><a href="#h7-0-61" id="h7-0-61" class="i">+8
</a><a href="#h7-0-62" id="h7-0-62" class="i">+1
</a><a href="#h7-0-63" id="h7-0-63" class="i">+1
</a><a href="#h7-0-64" id="h7-0-64" class="i">+
</a><a href="#h7-0-65" id="h7-0-65" class="i">+[plan]&gt; SELECT COUNT(*) FROM test GROUP BY test.&quot;bool&quot; ORDER BY &quot;bool&quot;
</a><a href="#h7-0-66" id="h7-0-66" class="i">+---
</a><a href="#h7-0-67" id="h7-0-67" class="i">+Projection: #0
</a><a href="#h7-0-68" id="h7-0-68" class="i">+└─ Order: bool asc
</a><a href="#h7-0-69" id="h7-0-69" class="i">+   └─ Projection: #0, bool
</a><a href="#h7-0-70" id="h7-0-70" class="i">+      └─ Aggregate: count(TRUE) group by test.bool
</a><a href="#h7-0-71" id="h7-0-71" class="i">+         └─ Scan: test
</a><a href="#h7-0-72" id="h7-0-72" class="i">+8
</a><a href="#h7-0-73" id="h7-0-73" class="i">+1
</a><a href="#h7-0-74" id="h7-0-74" class="i">+1
</a></pre>
</div>
</body>
</html>
