<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>storage: flatten module - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/1f7bdbb021b2629d01020a5af8148e6a84cb6253.html">1f7bdbb021b2629d01020a5af8148e6a84cb6253</a>
<b>parent</b> <a href="../commit/7cca62e9110233904a67094eeb65d602a812ce14.html">7cca62e9110233904a67094eeb65d602a812ce14</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue,  9 Apr 2024 20:24:58 +0200

storage: flatten module

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/bin/toydb.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/bin/toydump.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/log.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/node/follower.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/raft/node/leader.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/raft/node/mod.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">16</td><td><span class="i">++++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="A">A</td><td><a href="#h9">src/storage/bitcask.rs</a></td><td> | </td><td class="num">671</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h10">src/storage/engine.rs</a></td><td> | </td><td class="num">470</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="D">D</td><td><a href="#h11">src/storage/engine/bitcask.rs</a></td><td> | </td><td class="num">671</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h12">src/storage/engine/memory.rs</a></td><td> | </td><td class="num">97</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h13">src/storage/engine/mod.rs</a></td><td> | </td><td class="num">478</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="A">A</td><td><a href="#h14">src/storage/memory.rs</a></td><td> | </td><td class="num">97</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h15">src/storage/mod.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h16">src/storage/mvcc.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h17">tests/sql/mod.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
</table></pre><pre>18 files changed, 1276 insertions(+), 1276 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a> b/<a href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -40,19 +40,19 @@ async fn main() -&gt; Result&lt;()&gt; {
</a>     let path = std::path::Path::new(&amp;cfg.data_dir);
     let raft_log = match cfg.storage_raft.as_str() {
         &quot;bitcask&quot; | &quot;&quot; =&gt; raft::Log::new(
<a href="#h0-0-3" id="h0-0-3" class="d">-            storage::engine::BitCask::new_compact(
</a><a href="#h0-0-4" id="h0-0-4" class="i">+            storage::BitCask::new_compact(
</a>                 path.join(&quot;log&quot;),
                 cfg.compact_threshold,
                 COMPACT_MIN_BYTES,
             )?,
             cfg.sync,
         )?,
<a href="#h0-0-11" id="h0-0-11" class="d">-        &quot;memory&quot; =&gt; raft::Log::new(storage::engine::Memory::new(), false)?,
</a><a href="#h0-0-12" id="h0-0-12" class="i">+        &quot;memory&quot; =&gt; raft::Log::new(storage::Memory::new(), false)?,
</a>         name =&gt; return Err(Error::Config(format!(&quot;Unknown Raft storage engine {}&quot;, name))),
     };
     let raft_state: Box&lt;dyn raft::State&gt; = match cfg.storage_sql.as_str() {
         &quot;bitcask&quot; | &quot;&quot; =&gt; {
<a href="#h0-0-17" id="h0-0-17" class="d">-            let engine = storage::engine::BitCask::new_compact(
</a><a href="#h0-0-18" id="h0-0-18" class="i">+            let engine = storage::BitCask::new_compact(
</a>                 path.join(&quot;state&quot;),
                 cfg.compact_threshold,
                 COMPACT_MIN_BYTES,
<a href="#h0-1" id="h0-1" class="h">@@ -60,7 +60,7 @@ async fn main() -&gt; Result&lt;()&gt; {
</a>             Box::new(sql::engine::Raft::new_state(engine)?)
         }
         &quot;memory&quot; =&gt; {
<a href="#h0-1-3" id="h0-1-3" class="d">-            let engine = storage::engine::Memory::new();
</a><a href="#h0-1-4" id="h0-1-4" class="i">+            let engine = storage::Memory::new();
</a>             Box::new(sql::engine::Raft::new_state(engine)?)
         }
         name =&gt; return Err(Error::Config(format!(&quot;Unknown SQL storage engine {}&quot;, name))),
<b>diff --git a/<a id="h1" href="../file/src/bin/toydump.rs.html">src/bin/toydump.rs</a> b/<a href="../file/src/bin/toydump.rs.html">src/bin/toydump.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -4,7 +4,7 @@
</a> 
 use toydb::error::{Error, Result};
 use toydb::storage::debug;
<a href="#h1-0-3" id="h1-0-3" class="d">-use toydb::storage::engine::{BitCask, Engine};
</a><a href="#h1-0-4" id="h1-0-4" class="i">+use toydb::storage::{BitCask, Engine};
</a> 
 fn main() -&gt; Result&lt;()&gt; {
     let args = clap::command!()
<b>diff --git a/<a id="h2" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -60,7 +60,7 @@ pub struct Log {
</a>     /// The underlying storage engine. Uses a trait object instead of generics,
     /// to allow runtime selection of the engine (based on the program config)
     /// and avoid propagating the generic type parameters throughout.
<a href="#h2-0-3" id="h2-0-3" class="d">-    engine: Box&lt;dyn storage::engine::Engine&gt;,
</a><a href="#h2-0-4" id="h2-0-4" class="i">+    engine: Box&lt;dyn storage::Engine&gt;,
</a>     /// The index of the last stored entry.
     last_index: Index,
     /// The term of the last stored entry.
<a href="#h2-1" id="h2-1" class="h">@@ -75,7 +75,7 @@ pub struct Log {
</a> 
 impl Log {
     /// Creates a new log, using the given storage engine.
<a href="#h2-1-3" id="h2-1-3" class="d">-    pub fn new(mut engine: impl storage::engine::Engine + &#39;static, sync: bool) -&gt; Result&lt;Self&gt; {
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    pub fn new(mut engine: impl storage::Engine + &#39;static, sync: bool) -&gt; Result&lt;Self&gt; {
</a>         let (last_index, last_term) = engine
             .scan_prefix(&amp;KeyPrefix::Entry.encode()?)
             .last()
<a href="#h2-2" id="h2-2" class="h">@@ -277,7 +277,7 @@ impl Log {
</a> #[cfg(test)]
 mod tests {
     use super::*;
<a href="#h2-2-3" id="h2-2-3" class="d">-    use crate::storage::engine::Memory;
</a><a href="#h2-2-4" id="h2-2-4" class="i">+    use crate::storage::Memory;
</a>     use pretty_assertions::assert_eq;
 
     fn setup() -&gt; Log {
<b>diff --git a/<a id="h3" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -179,7 +179,7 @@ mod tests {
</a>     fn setup() -&gt; Result&lt;(RawNode&lt;Candidate&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let state = Box::new(TestState::new(0));
<a href="#h3-0-3" id="h3-0-3" class="d">-        let mut log = Log::new(storage::engine::Memory::new(), false)?;
</a><a href="#h3-0-4" id="h3-0-4" class="i">+        let mut log = Log::new(storage::Memory::new(), false)?;
</a> 
         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
<b>diff --git a/<a id="h4" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -294,7 +294,7 @@ pub mod tests {
</a>     fn setup() -&gt; Result&lt;(RawNode&lt;Follower&gt;, mpsc::UnboundedReceiver&lt;Message&gt;)&gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let state = Box::new(TestState::new(0));
<a href="#h4-0-3" id="h4-0-3" class="d">-        let mut log = Log::new(storage::engine::Memory::new(), false)?;
</a><a href="#h4-0-4" id="h4-0-4" class="i">+        let mut log = Log::new(storage::Memory::new(), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<a href="#h4-1" id="h4-1" class="h">@@ -591,7 +591,7 @@ pub mod tests {
</a>     fn step_appendentries_base0() -&gt; Result&lt;()&gt; {
         // TODO: Move this into a setup function.
         let (node_tx, mut node_rx) = mpsc::unbounded_channel();
<a href="#h4-1-3" id="h4-1-3" class="d">-        let mut log = Log::new(storage::engine::Memory::new(), false)?;
</a><a href="#h4-1-4" id="h4-1-4" class="i">+        let mut log = Log::new(storage::Memory::new(), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<b>diff --git a/<a id="h5" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -414,7 +414,7 @@ mod tests {
</a>         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let peers = HashSet::from([2, 3, 4, 5]);
         let state = Box::new(TestState::new(0));
<a href="#h5-0-3" id="h5-0-3" class="d">-        let mut log = Log::new(storage::engine::Memory::new(), false)?;
</a><a href="#h5-0-4" id="h5-0-4" class="i">+        let mut log = Log::new(storage::Memory::new(), false)?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
<b>diff --git a/<a id="h6" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -445,7 +445,7 @@ mod tests {
</a>             id: 1,
             peers: HashSet::from_iter(peers),
             term: 1,
<a href="#h6-0-3" id="h6-0-3" class="d">-            log: Log::new(storage::engine::Memory::new(), false)?,
</a><a href="#h6-0-4" id="h6-0-4" class="i">+            log: Log::new(storage::Memory::new(), false)?,
</a>             state: Box::new(TestState::new(0)),
             node_tx,
         };
<a href="#h6-1" id="h6-1" class="h">@@ -458,7 +458,7 @@ mod tests {
</a>         let node = Node::new(
             1,
             HashSet::from([2, 3]),
<a href="#h6-1-3" id="h6-1-3" class="d">-            Log::new(storage::engine::Memory::new(), false)?,
</a><a href="#h6-1-4" id="h6-1-4" class="i">+            Log::new(storage::Memory::new(), false)?,
</a>             Box::new(TestState::new(0)),
             node_tx,
         )?;
<a href="#h6-2" id="h6-2" class="h">@@ -479,7 +479,7 @@ mod tests {
</a>         let node = Node::new(
             1,
             HashSet::new(),
<a href="#h6-2-3" id="h6-2-3" class="d">-            Log::new(storage::engine::Memory::new(), false)?,
</a><a href="#h6-2-4" id="h6-2-4" class="i">+            Log::new(storage::Memory::new(), false)?,
</a>             Box::new(TestState::new(0)),
             node_tx,
         )?;
<b>diff --git a/<a id="h7" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -11,19 +11,19 @@ use std::clone::Clone;
</a> use std::collections::HashSet;
 
 /// A SQL engine based on an underlying MVCC key/value store.
<a href="#h7-0-3" id="h7-0-3" class="d">-pub struct KV&lt;E: storage::engine::Engine&gt; {
</a><a href="#h7-0-4" id="h7-0-4" class="i">+pub struct KV&lt;E: storage::Engine&gt; {
</a>     /// The underlying key/value store.
     pub(super) kv: storage::mvcc::MVCC&lt;E&gt;,
 }
 
 // FIXME Implement Clone manually due to https://github.com/rust-lang/rust/issues/26925
<a href="#h7-0-10" id="h7-0-10" class="d">-impl&lt;E: storage::engine::Engine&gt; Clone for KV&lt;E&gt; {
</a><a href="#h7-0-11" id="h7-0-11" class="i">+impl&lt;E: storage::Engine&gt; Clone for KV&lt;E&gt; {
</a>     fn clone(&amp;self) -&gt; Self {
         KV { kv: self.kv.clone() }
     }
 }
 
<a href="#h7-0-17" id="h7-0-17" class="d">-impl&lt;E: storage::engine::Engine&gt; KV&lt;E&gt; {
</a><a href="#h7-0-18" id="h7-0-18" class="i">+impl&lt;E: storage::Engine&gt; KV&lt;E&gt; {
</a>     /// Creates a new key/value-based SQL engine
     pub fn new(engine: E) -&gt; Self {
         Self { kv: storage::mvcc::MVCC::new(engine) }
<a href="#h7-1" id="h7-1" class="h">@@ -48,7 +48,7 @@ impl&lt;E: storage::engine::Engine&gt; KV&lt;E&gt; {
</a>     }
 }
 
<a href="#h7-1-3" id="h7-1-3" class="d">-impl&lt;E: storage::engine::Engine&gt; super::Engine for KV&lt;E&gt; {
</a><a href="#h7-1-4" id="h7-1-4" class="i">+impl&lt;E: storage::Engine&gt; super::Engine for KV&lt;E&gt; {
</a>     type Transaction = Transaction&lt;E&gt;;
 
     fn begin(&amp;self) -&gt; Result&lt;Self::Transaction&gt; {
<a href="#h7-2" id="h7-2" class="h">@@ -75,11 +75,11 @@ fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a> }
 
 /// An SQL transaction based on an MVCC key/value transaction
<a href="#h7-2-3" id="h7-2-3" class="d">-pub struct Transaction&lt;E: storage::engine::Engine&gt; {
</a><a href="#h7-2-4" id="h7-2-4" class="i">+pub struct Transaction&lt;E: storage::Engine&gt; {
</a>     txn: storage::mvcc::Transaction&lt;E&gt;,
 }
 
<a href="#h7-2-8" id="h7-2-8" class="d">-impl&lt;E: storage::engine::Engine&gt; Transaction&lt;E&gt; {
</a><a href="#h7-2-9" id="h7-2-9" class="i">+impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>     /// Creates a new SQL transaction from an MVCC transaction
     fn new(txn: storage::mvcc::Transaction&lt;E&gt;) -&gt; Self {
         Self { txn }
<a href="#h7-3" id="h7-3" class="h">@@ -117,7 +117,7 @@ impl&lt;E: storage::engine::Engine&gt; Transaction&lt;E&gt; {
</a>     }
 }
 
<a href="#h7-3-3" id="h7-3-3" class="d">-impl&lt;E: storage::engine::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a><a href="#h7-3-4" id="h7-3-4" class="i">+impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>     fn version(&amp;self) -&gt; u64 {
         self.txn.version()
     }
<a href="#h7-4" id="h7-4" class="h">@@ -287,7 +287,7 @@ impl&lt;E: storage::engine::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>     }
 }
 
<a href="#h7-4-3" id="h7-4-3" class="d">-impl&lt;E: storage::engine::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a><a href="#h7-4-4" id="h7-4-4" class="i">+impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>     fn create_table(&amp;mut self, table: Table) -&gt; Result&lt;()&gt; {
         if self.read_table(&amp;table.name)?.is_some() {
             return Err(Error::Value(format!(&quot;Table {} already exists&quot;, table.name)));
<b>diff --git a/<a id="h8" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -128,7 +128,7 @@ impl Raft {
</a>     }
 
     /// Creates an underlying state machine for a Raft engine.
<a href="#h8-0-3" id="h8-0-3" class="d">-    pub fn new_state&lt;E: storage::engine::Engine&gt;(engine: E) -&gt; Result&lt;State&lt;E&gt;&gt; {
</a><a href="#h8-0-4" id="h8-0-4" class="i">+    pub fn new_state&lt;E: storage::Engine&gt;(engine: E) -&gt; Result&lt;State&lt;E&gt;&gt; {
</a>         State::new(engine)
     }
 
<a href="#h8-1" id="h8-1" class="h">@@ -277,14 +277,14 @@ impl Catalog for Transaction {
</a> }
 
 /// The Raft state machine for the Raft-based SQL engine, using a KV SQL engine
<a href="#h8-1-3" id="h8-1-3" class="d">-pub struct State&lt;E: storage::engine::Engine&gt; {
</a><a href="#h8-1-4" id="h8-1-4" class="i">+pub struct State&lt;E: storage::Engine&gt; {
</a>     /// The underlying KV SQL engine
     engine: super::KV&lt;E&gt;,
     /// The last applied index
     applied_index: u64,
 }
 
<a href="#h8-1-11" id="h8-1-11" class="d">-impl&lt;E: storage::engine::Engine&gt; State&lt;E&gt; {
</a><a href="#h8-1-12" id="h8-1-12" class="i">+impl&lt;E: storage::Engine&gt; State&lt;E&gt; {
</a>     /// Creates a new Raft state maching using the given storage engine.
     pub fn new(engine: E) -&gt; Result&lt;Self&gt; {
         let engine = super::KV::new(engine);
<a href="#h8-2" id="h8-2" class="h">@@ -331,7 +331,7 @@ impl&lt;E: storage::engine::Engine&gt; State&lt;E&gt; {
</a>     }
 }
 
<a href="#h8-2-3" id="h8-2-3" class="d">-impl&lt;E: storage::engine::Engine&gt; raft::State for State&lt;E&gt; {
</a><a href="#h8-2-4" id="h8-2-4" class="i">+impl&lt;E: storage::Engine&gt; raft::State for State&lt;E&gt; {
</a>     fn get_applied_index(&amp;self) -&gt; u64 {
         self.applied_index
     }
<b>diff --git a/<a id="h9" href="../file/src/storage/bitcask.rs.html">src/storage/bitcask.rs</a> b/<a href="../file/src/storage/bitcask.rs.html">src/storage/bitcask.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -0,0 +1,671 @@
</a><a href="#h9-0-0" id="h9-0-0" class="i">+use super::{Engine, Status};
</a><a href="#h9-0-1" id="h9-0-1" class="i">+use crate::error::Result;
</a><a href="#h9-0-2" id="h9-0-2" class="i">+
</a><a href="#h9-0-3" id="h9-0-3" class="i">+use fs4::FileExt;
</a><a href="#h9-0-4" id="h9-0-4" class="i">+use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, Write};
</a><a href="#h9-0-5" id="h9-0-5" class="i">+use std::path::PathBuf;
</a><a href="#h9-0-6" id="h9-0-6" class="i">+
</a><a href="#h9-0-7" id="h9-0-7" class="i">+/// A very simple variant of BitCask, itself a very simple log-structured
</a><a href="#h9-0-8" id="h9-0-8" class="i">+/// key-value engine used e.g. by the Riak database. It is not compatible with
</a><a href="#h9-0-9" id="h9-0-9" class="i">+/// BitCask databases generated by other implementations. See:
</a><a href="#h9-0-10" id="h9-0-10" class="i">+/// https://riak.com/assets/bitcask-intro.pdf
</a><a href="#h9-0-11" id="h9-0-11" class="i">+///
</a><a href="#h9-0-12" id="h9-0-12" class="i">+/// BitCask writes key-value pairs to an append-only log file, and keeps a
</a><a href="#h9-0-13" id="h9-0-13" class="i">+/// mapping of keys to file positions in memory. All live keys must fit in
</a><a href="#h9-0-14" id="h9-0-14" class="i">+/// memory. Deletes write a tombstone value to the log file. To remove old
</a><a href="#h9-0-15" id="h9-0-15" class="i">+/// garbage, logs can be compacted by writing new logs containing only live
</a><a href="#h9-0-16" id="h9-0-16" class="i">+/// data, skipping replaced values and tombstones.
</a><a href="#h9-0-17" id="h9-0-17" class="i">+///
</a><a href="#h9-0-18" id="h9-0-18" class="i">+/// This implementation makes several significant simplifications over
</a><a href="#h9-0-19" id="h9-0-19" class="i">+/// standard BitCask:
</a><a href="#h9-0-20" id="h9-0-20" class="i">+///
</a><a href="#h9-0-21" id="h9-0-21" class="i">+/// - Instead of writing multiple fixed-size log files, it uses a single
</a><a href="#h9-0-22" id="h9-0-22" class="i">+///   append-only log file of arbitrary size. This increases the compaction
</a><a href="#h9-0-23" id="h9-0-23" class="i">+///   volume, since the entire log file must be rewritten on every compaction,
</a><a href="#h9-0-24" id="h9-0-24" class="i">+///   and can exceed the filesystem&#39;s file size limit, but ToyDB databases are
</a><a href="#h9-0-25" id="h9-0-25" class="i">+///   expected to be small.
</a><a href="#h9-0-26" id="h9-0-26" class="i">+///
</a><a href="#h9-0-27" id="h9-0-27" class="i">+/// - Compactions lock the database for reads and writes. This is ok since ToyDB
</a><a href="#h9-0-28" id="h9-0-28" class="i">+///   only compacts during node startup and files are expected to be small.
</a><a href="#h9-0-29" id="h9-0-29" class="i">+///
</a><a href="#h9-0-30" id="h9-0-30" class="i">+/// - Hint files are not used, the log itself is scanned when opened to
</a><a href="#h9-0-31" id="h9-0-31" class="i">+///   build the keydir. Hint files only omit values, and ToyDB values are
</a><a href="#h9-0-32" id="h9-0-32" class="i">+///   expected to be small, so the hint files would be nearly as large as
</a><a href="#h9-0-33" id="h9-0-33" class="i">+///   the compacted log files themselves.
</a><a href="#h9-0-34" id="h9-0-34" class="i">+///
</a><a href="#h9-0-35" id="h9-0-35" class="i">+/// - Log entries don&#39;t contain timestamps or checksums.
</a><a href="#h9-0-36" id="h9-0-36" class="i">+///
</a><a href="#h9-0-37" id="h9-0-37" class="i">+/// The structure of a log entry is:
</a><a href="#h9-0-38" id="h9-0-38" class="i">+///
</a><a href="#h9-0-39" id="h9-0-39" class="i">+/// - Key length as big-endian u32.
</a><a href="#h9-0-40" id="h9-0-40" class="i">+/// - Value length as big-endian i32, or -1 for tombstones.
</a><a href="#h9-0-41" id="h9-0-41" class="i">+/// - Key as raw bytes (max 2 GB).
</a><a href="#h9-0-42" id="h9-0-42" class="i">+/// - Value as raw bytes (max 2 GB).
</a><a href="#h9-0-43" id="h9-0-43" class="i">+pub struct BitCask {
</a><a href="#h9-0-44" id="h9-0-44" class="i">+    /// The active append-only log file.
</a><a href="#h9-0-45" id="h9-0-45" class="i">+    log: Log,
</a><a href="#h9-0-46" id="h9-0-46" class="i">+    /// Maps keys to a value position and length in the log file.
</a><a href="#h9-0-47" id="h9-0-47" class="i">+    keydir: KeyDir,
</a><a href="#h9-0-48" id="h9-0-48" class="i">+}
</a><a href="#h9-0-49" id="h9-0-49" class="i">+
</a><a href="#h9-0-50" id="h9-0-50" class="i">+/// Maps keys to a value position and length in the log file.
</a><a href="#h9-0-51" id="h9-0-51" class="i">+type KeyDir = std::collections::BTreeMap&lt;Vec&lt;u8&gt;, (u64, u32)&gt;;
</a><a href="#h9-0-52" id="h9-0-52" class="i">+
</a><a href="#h9-0-53" id="h9-0-53" class="i">+impl BitCask {
</a><a href="#h9-0-54" id="h9-0-54" class="i">+    /// Opens or creates a BitCask database in the given file.
</a><a href="#h9-0-55" id="h9-0-55" class="i">+    pub fn new(path: PathBuf) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-0-56" id="h9-0-56" class="i">+        log::info!(&quot;Opening database {}&quot;, path.display());
</a><a href="#h9-0-57" id="h9-0-57" class="i">+        let mut log = Log::new(path.clone())?;
</a><a href="#h9-0-58" id="h9-0-58" class="i">+        let keydir = log.build_keydir()?;
</a><a href="#h9-0-59" id="h9-0-59" class="i">+        log::info!(&quot;Indexed {} live keys in {}&quot;, keydir.len(), path.display());
</a><a href="#h9-0-60" id="h9-0-60" class="i">+        Ok(Self { log, keydir })
</a><a href="#h9-0-61" id="h9-0-61" class="i">+    }
</a><a href="#h9-0-62" id="h9-0-62" class="i">+
</a><a href="#h9-0-63" id="h9-0-63" class="i">+    /// Opens a BitCask database, and automatically compacts it if the amount
</a><a href="#h9-0-64" id="h9-0-64" class="i">+    /// of garbage exceeds the given ratio and byte size when opened.
</a><a href="#h9-0-65" id="h9-0-65" class="i">+    pub fn new_compact(
</a><a href="#h9-0-66" id="h9-0-66" class="i">+        path: PathBuf,
</a><a href="#h9-0-67" id="h9-0-67" class="i">+        garbage_min_ratio: f64,
</a><a href="#h9-0-68" id="h9-0-68" class="i">+        garbage_min_bytes: u64,
</a><a href="#h9-0-69" id="h9-0-69" class="i">+    ) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-0-70" id="h9-0-70" class="i">+        let mut s = Self::new(path)?;
</a><a href="#h9-0-71" id="h9-0-71" class="i">+
</a><a href="#h9-0-72" id="h9-0-72" class="i">+        let status = s.status()?;
</a><a href="#h9-0-73" id="h9-0-73" class="i">+        let garbage_ratio = status.garbage_disk_size as f64 / status.total_disk_size as f64;
</a><a href="#h9-0-74" id="h9-0-74" class="i">+        if status.garbage_disk_size &gt; 0
</a><a href="#h9-0-75" id="h9-0-75" class="i">+            &amp;&amp; status.garbage_disk_size &gt;= garbage_min_bytes
</a><a href="#h9-0-76" id="h9-0-76" class="i">+            &amp;&amp; garbage_ratio &gt;= garbage_min_ratio
</a><a href="#h9-0-77" id="h9-0-77" class="i">+        {
</a><a href="#h9-0-78" id="h9-0-78" class="i">+            log::info!(
</a><a href="#h9-0-79" id="h9-0-79" class="i">+                &quot;Compacting {} to remove {:.0}% garbage ({} MB out of {} MB)&quot;,
</a><a href="#h9-0-80" id="h9-0-80" class="i">+                s.log.path.display(),
</a><a href="#h9-0-81" id="h9-0-81" class="i">+                garbage_ratio * 100.0,
</a><a href="#h9-0-82" id="h9-0-82" class="i">+                status.garbage_disk_size / 1024 / 1024,
</a><a href="#h9-0-83" id="h9-0-83" class="i">+                status.total_disk_size / 1024 / 1024
</a><a href="#h9-0-84" id="h9-0-84" class="i">+            );
</a><a href="#h9-0-85" id="h9-0-85" class="i">+            s.compact()?;
</a><a href="#h9-0-86" id="h9-0-86" class="i">+            log::info!(
</a><a href="#h9-0-87" id="h9-0-87" class="i">+                &quot;Compacted {} to size {} MB&quot;,
</a><a href="#h9-0-88" id="h9-0-88" class="i">+                s.log.path.display(),
</a><a href="#h9-0-89" id="h9-0-89" class="i">+                (status.total_disk_size - status.garbage_disk_size) / 1024 / 1024
</a><a href="#h9-0-90" id="h9-0-90" class="i">+            );
</a><a href="#h9-0-91" id="h9-0-91" class="i">+        }
</a><a href="#h9-0-92" id="h9-0-92" class="i">+
</a><a href="#h9-0-93" id="h9-0-93" class="i">+        Ok(s)
</a><a href="#h9-0-94" id="h9-0-94" class="i">+    }
</a><a href="#h9-0-95" id="h9-0-95" class="i">+}
</a><a href="#h9-0-96" id="h9-0-96" class="i">+
</a><a href="#h9-0-97" id="h9-0-97" class="i">+impl std::fmt::Display for BitCask {
</a><a href="#h9-0-98" id="h9-0-98" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h9-0-99" id="h9-0-99" class="i">+        write!(f, &quot;bitcask&quot;)
</a><a href="#h9-0-100" id="h9-0-100" class="i">+    }
</a><a href="#h9-0-101" id="h9-0-101" class="i">+}
</a><a href="#h9-0-102" id="h9-0-102" class="i">+
</a><a href="#h9-0-103" id="h9-0-103" class="i">+impl Engine for BitCask {
</a><a href="#h9-0-104" id="h9-0-104" class="i">+    type ScanIterator&lt;&#39;a&gt; = ScanIterator&lt;&#39;a&gt;;
</a><a href="#h9-0-105" id="h9-0-105" class="i">+
</a><a href="#h9-0-106" id="h9-0-106" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-107" id="h9-0-107" class="i">+        self.log.write_entry(key, None)?;
</a><a href="#h9-0-108" id="h9-0-108" class="i">+        self.keydir.remove(key);
</a><a href="#h9-0-109" id="h9-0-109" class="i">+        Ok(())
</a><a href="#h9-0-110" id="h9-0-110" class="i">+    }
</a><a href="#h9-0-111" id="h9-0-111" class="i">+
</a><a href="#h9-0-112" id="h9-0-112" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-113" id="h9-0-113" class="i">+        Ok(self.log.file.sync_all()?)
</a><a href="#h9-0-114" id="h9-0-114" class="i">+    }
</a><a href="#h9-0-115" id="h9-0-115" class="i">+
</a><a href="#h9-0-116" id="h9-0-116" class="i">+    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h9-0-117" id="h9-0-117" class="i">+        if let Some((value_pos, value_len)) = self.keydir.get(key) {
</a><a href="#h9-0-118" id="h9-0-118" class="i">+            Ok(Some(self.log.read_value(*value_pos, *value_len)?))
</a><a href="#h9-0-119" id="h9-0-119" class="i">+        } else {
</a><a href="#h9-0-120" id="h9-0-120" class="i">+            Ok(None)
</a><a href="#h9-0-121" id="h9-0-121" class="i">+        }
</a><a href="#h9-0-122" id="h9-0-122" class="i">+    }
</a><a href="#h9-0-123" id="h9-0-123" class="i">+
</a><a href="#h9-0-124" id="h9-0-124" class="i">+    fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h9-0-125" id="h9-0-125" class="i">+        ScanIterator { inner: self.keydir.range(range), log: &amp;mut self.log }
</a><a href="#h9-0-126" id="h9-0-126" class="i">+    }
</a><a href="#h9-0-127" id="h9-0-127" class="i">+
</a><a href="#h9-0-128" id="h9-0-128" class="i">+    fn scan_dyn(
</a><a href="#h9-0-129" id="h9-0-129" class="i">+        &amp;mut self,
</a><a href="#h9-0-130" id="h9-0-130" class="i">+        range: (std::ops::Bound&lt;Vec&lt;u8&gt;&gt;, std::ops::Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h9-0-131" id="h9-0-131" class="i">+    ) -&gt; Box&lt;dyn super::ScanIterator + &#39;_&gt; {
</a><a href="#h9-0-132" id="h9-0-132" class="i">+        Box::new(self.scan(range))
</a><a href="#h9-0-133" id="h9-0-133" class="i">+    }
</a><a href="#h9-0-134" id="h9-0-134" class="i">+
</a><a href="#h9-0-135" id="h9-0-135" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-136" id="h9-0-136" class="i">+        let (pos, len) = self.log.write_entry(key, Some(&amp;*value))?;
</a><a href="#h9-0-137" id="h9-0-137" class="i">+        let value_len = value.len() as u32;
</a><a href="#h9-0-138" id="h9-0-138" class="i">+        self.keydir.insert(key.to_vec(), (pos + len as u64 - value_len as u64, value_len));
</a><a href="#h9-0-139" id="h9-0-139" class="i">+        Ok(())
</a><a href="#h9-0-140" id="h9-0-140" class="i">+    }
</a><a href="#h9-0-141" id="h9-0-141" class="i">+
</a><a href="#h9-0-142" id="h9-0-142" class="i">+    fn status(&amp;mut self) -&gt; Result&lt;Status&gt; {
</a><a href="#h9-0-143" id="h9-0-143" class="i">+        let keys = self.keydir.len() as u64;
</a><a href="#h9-0-144" id="h9-0-144" class="i">+        let size = self
</a><a href="#h9-0-145" id="h9-0-145" class="i">+            .keydir
</a><a href="#h9-0-146" id="h9-0-146" class="i">+            .iter()
</a><a href="#h9-0-147" id="h9-0-147" class="i">+            .fold(0, |size, (key, (_, value_len))| size + key.len() as u64 + *value_len as u64);
</a><a href="#h9-0-148" id="h9-0-148" class="i">+        let total_disk_size = self.log.file.metadata()?.len();
</a><a href="#h9-0-149" id="h9-0-149" class="i">+        let live_disk_size = size + 8 * keys; // account for length prefixes
</a><a href="#h9-0-150" id="h9-0-150" class="i">+        let garbage_disk_size = total_disk_size - live_disk_size;
</a><a href="#h9-0-151" id="h9-0-151" class="i">+        Ok(Status {
</a><a href="#h9-0-152" id="h9-0-152" class="i">+            name: self.to_string(),
</a><a href="#h9-0-153" id="h9-0-153" class="i">+            keys,
</a><a href="#h9-0-154" id="h9-0-154" class="i">+            size,
</a><a href="#h9-0-155" id="h9-0-155" class="i">+            total_disk_size,
</a><a href="#h9-0-156" id="h9-0-156" class="i">+            live_disk_size,
</a><a href="#h9-0-157" id="h9-0-157" class="i">+            garbage_disk_size,
</a><a href="#h9-0-158" id="h9-0-158" class="i">+        })
</a><a href="#h9-0-159" id="h9-0-159" class="i">+    }
</a><a href="#h9-0-160" id="h9-0-160" class="i">+}
</a><a href="#h9-0-161" id="h9-0-161" class="i">+
</a><a href="#h9-0-162" id="h9-0-162" class="i">+pub struct ScanIterator&lt;&#39;a&gt; {
</a><a href="#h9-0-163" id="h9-0-163" class="i">+    inner: std::collections::btree_map::Range&lt;&#39;a, Vec&lt;u8&gt;, (u64, u32)&gt;,
</a><a href="#h9-0-164" id="h9-0-164" class="i">+    log: &amp;&#39;a mut Log,
</a><a href="#h9-0-165" id="h9-0-165" class="i">+}
</a><a href="#h9-0-166" id="h9-0-166" class="i">+
</a><a href="#h9-0-167" id="h9-0-167" class="i">+impl&lt;&#39;a&gt; ScanIterator&lt;&#39;a&gt; {
</a><a href="#h9-0-168" id="h9-0-168" class="i">+    fn map(&amp;mut self, item: (&amp;Vec&lt;u8&gt;, &amp;(u64, u32))) -&gt; &lt;Self as Iterator&gt;::Item {
</a><a href="#h9-0-169" id="h9-0-169" class="i">+        let (key, (value_pos, value_len)) = item;
</a><a href="#h9-0-170" id="h9-0-170" class="i">+        Ok((key.clone(), self.log.read_value(*value_pos, *value_len)?))
</a><a href="#h9-0-171" id="h9-0-171" class="i">+    }
</a><a href="#h9-0-172" id="h9-0-172" class="i">+}
</a><a href="#h9-0-173" id="h9-0-173" class="i">+
</a><a href="#h9-0-174" id="h9-0-174" class="i">+impl&lt;&#39;a&gt; Iterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h9-0-175" id="h9-0-175" class="i">+    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a><a href="#h9-0-176" id="h9-0-176" class="i">+
</a><a href="#h9-0-177" id="h9-0-177" class="i">+    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h9-0-178" id="h9-0-178" class="i">+        self.inner.next().map(|item| self.map(item))
</a><a href="#h9-0-179" id="h9-0-179" class="i">+    }
</a><a href="#h9-0-180" id="h9-0-180" class="i">+}
</a><a href="#h9-0-181" id="h9-0-181" class="i">+
</a><a href="#h9-0-182" id="h9-0-182" class="i">+impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h9-0-183" id="h9-0-183" class="i">+    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h9-0-184" id="h9-0-184" class="i">+        self.inner.next_back().map(|item| self.map(item))
</a><a href="#h9-0-185" id="h9-0-185" class="i">+    }
</a><a href="#h9-0-186" id="h9-0-186" class="i">+}
</a><a href="#h9-0-187" id="h9-0-187" class="i">+
</a><a href="#h9-0-188" id="h9-0-188" class="i">+impl BitCask {
</a><a href="#h9-0-189" id="h9-0-189" class="i">+    /// Compacts the current log file by writing out a new log file containing
</a><a href="#h9-0-190" id="h9-0-190" class="i">+    /// only live keys and replacing the current file with it.
</a><a href="#h9-0-191" id="h9-0-191" class="i">+    pub fn compact(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-192" id="h9-0-192" class="i">+        let mut tmp_path = self.log.path.clone();
</a><a href="#h9-0-193" id="h9-0-193" class="i">+        tmp_path.set_extension(&quot;new&quot;);
</a><a href="#h9-0-194" id="h9-0-194" class="i">+        let (mut new_log, new_keydir) = self.write_log(tmp_path)?;
</a><a href="#h9-0-195" id="h9-0-195" class="i">+
</a><a href="#h9-0-196" id="h9-0-196" class="i">+        std::fs::rename(&amp;new_log.path, &amp;self.log.path)?;
</a><a href="#h9-0-197" id="h9-0-197" class="i">+        new_log.path = self.log.path.clone();
</a><a href="#h9-0-198" id="h9-0-198" class="i">+
</a><a href="#h9-0-199" id="h9-0-199" class="i">+        self.log = new_log;
</a><a href="#h9-0-200" id="h9-0-200" class="i">+        self.keydir = new_keydir;
</a><a href="#h9-0-201" id="h9-0-201" class="i">+        Ok(())
</a><a href="#h9-0-202" id="h9-0-202" class="i">+    }
</a><a href="#h9-0-203" id="h9-0-203" class="i">+
</a><a href="#h9-0-204" id="h9-0-204" class="i">+    /// Writes out a new log file with the live entries of the current log file
</a><a href="#h9-0-205" id="h9-0-205" class="i">+    /// and returns it along with its keydir. Entries are written in key order.
</a><a href="#h9-0-206" id="h9-0-206" class="i">+    fn write_log(&amp;mut self, path: PathBuf) -&gt; Result&lt;(Log, KeyDir)&gt; {
</a><a href="#h9-0-207" id="h9-0-207" class="i">+        let mut new_keydir = KeyDir::new();
</a><a href="#h9-0-208" id="h9-0-208" class="i">+        let mut new_log = Log::new(path)?;
</a><a href="#h9-0-209" id="h9-0-209" class="i">+        new_log.file.set_len(0)?; // truncate file if it exists
</a><a href="#h9-0-210" id="h9-0-210" class="i">+        for (key, (value_pos, value_len)) in self.keydir.iter() {
</a><a href="#h9-0-211" id="h9-0-211" class="i">+            let value = self.log.read_value(*value_pos, *value_len)?;
</a><a href="#h9-0-212" id="h9-0-212" class="i">+            let (pos, len) = new_log.write_entry(key, Some(&amp;value))?;
</a><a href="#h9-0-213" id="h9-0-213" class="i">+            new_keydir.insert(key.clone(), (pos + len as u64 - *value_len as u64, *value_len));
</a><a href="#h9-0-214" id="h9-0-214" class="i">+        }
</a><a href="#h9-0-215" id="h9-0-215" class="i">+        Ok((new_log, new_keydir))
</a><a href="#h9-0-216" id="h9-0-216" class="i">+    }
</a><a href="#h9-0-217" id="h9-0-217" class="i">+}
</a><a href="#h9-0-218" id="h9-0-218" class="i">+
</a><a href="#h9-0-219" id="h9-0-219" class="i">+/// Attempt to flush the file when the database is closed.
</a><a href="#h9-0-220" id="h9-0-220" class="i">+impl Drop for BitCask {
</a><a href="#h9-0-221" id="h9-0-221" class="i">+    fn drop(&amp;mut self) {
</a><a href="#h9-0-222" id="h9-0-222" class="i">+        if let Err(error) = self.flush() {
</a><a href="#h9-0-223" id="h9-0-223" class="i">+            log::error!(&quot;failed to flush file: {}&quot;, error)
</a><a href="#h9-0-224" id="h9-0-224" class="i">+        }
</a><a href="#h9-0-225" id="h9-0-225" class="i">+    }
</a><a href="#h9-0-226" id="h9-0-226" class="i">+}
</a><a href="#h9-0-227" id="h9-0-227" class="i">+
</a><a href="#h9-0-228" id="h9-0-228" class="i">+/// A BitCask append-only log file, containing a sequence of key/value
</a><a href="#h9-0-229" id="h9-0-229" class="i">+/// entries encoded as follows;
</a><a href="#h9-0-230" id="h9-0-230" class="i">+///
</a><a href="#h9-0-231" id="h9-0-231" class="i">+/// - Key length as big-endian u32.
</a><a href="#h9-0-232" id="h9-0-232" class="i">+/// - Value length as big-endian i32, or -1 for tombstones.
</a><a href="#h9-0-233" id="h9-0-233" class="i">+/// - Key as raw bytes (max 2 GB).
</a><a href="#h9-0-234" id="h9-0-234" class="i">+/// - Value as raw bytes (max 2 GB).
</a><a href="#h9-0-235" id="h9-0-235" class="i">+struct Log {
</a><a href="#h9-0-236" id="h9-0-236" class="i">+    /// Path to the log file.
</a><a href="#h9-0-237" id="h9-0-237" class="i">+    path: PathBuf,
</a><a href="#h9-0-238" id="h9-0-238" class="i">+    /// The opened file containing the log.
</a><a href="#h9-0-239" id="h9-0-239" class="i">+    file: std::fs::File,
</a><a href="#h9-0-240" id="h9-0-240" class="i">+}
</a><a href="#h9-0-241" id="h9-0-241" class="i">+
</a><a href="#h9-0-242" id="h9-0-242" class="i">+impl Log {
</a><a href="#h9-0-243" id="h9-0-243" class="i">+    /// Opens a log file, or creates one if it does not exist. Takes out an
</a><a href="#h9-0-244" id="h9-0-244" class="i">+    /// exclusive lock on the file until it is closed, or errors if the lock is
</a><a href="#h9-0-245" id="h9-0-245" class="i">+    /// already held.
</a><a href="#h9-0-246" id="h9-0-246" class="i">+    fn new(path: PathBuf) -&gt; Result&lt;Self&gt; {
</a><a href="#h9-0-247" id="h9-0-247" class="i">+        if let Some(dir) = path.parent() {
</a><a href="#h9-0-248" id="h9-0-248" class="i">+            std::fs::create_dir_all(dir)?
</a><a href="#h9-0-249" id="h9-0-249" class="i">+        }
</a><a href="#h9-0-250" id="h9-0-250" class="i">+        let file = std::fs::OpenOptions::new()
</a><a href="#h9-0-251" id="h9-0-251" class="i">+            .read(true)
</a><a href="#h9-0-252" id="h9-0-252" class="i">+            .write(true)
</a><a href="#h9-0-253" id="h9-0-253" class="i">+            .create(true)
</a><a href="#h9-0-254" id="h9-0-254" class="i">+            .truncate(false)
</a><a href="#h9-0-255" id="h9-0-255" class="i">+            .open(&amp;path)?;
</a><a href="#h9-0-256" id="h9-0-256" class="i">+        file.try_lock_exclusive()?;
</a><a href="#h9-0-257" id="h9-0-257" class="i">+        Ok(Self { path, file })
</a><a href="#h9-0-258" id="h9-0-258" class="i">+    }
</a><a href="#h9-0-259" id="h9-0-259" class="i">+
</a><a href="#h9-0-260" id="h9-0-260" class="i">+    /// Builds a keydir by scanning the log file. If an incomplete entry is
</a><a href="#h9-0-261" id="h9-0-261" class="i">+    /// encountered, it is assumed to be caused by an incomplete write operation
</a><a href="#h9-0-262" id="h9-0-262" class="i">+    /// and the remainder of the file is truncated.
</a><a href="#h9-0-263" id="h9-0-263" class="i">+    fn build_keydir(&amp;mut self) -&gt; Result&lt;KeyDir&gt; {
</a><a href="#h9-0-264" id="h9-0-264" class="i">+        let mut len_buf = [0u8; 4];
</a><a href="#h9-0-265" id="h9-0-265" class="i">+        let mut keydir = KeyDir::new();
</a><a href="#h9-0-266" id="h9-0-266" class="i">+        let file_len = self.file.metadata()?.len();
</a><a href="#h9-0-267" id="h9-0-267" class="i">+        let mut r = BufReader::new(&amp;mut self.file);
</a><a href="#h9-0-268" id="h9-0-268" class="i">+        let mut pos = r.seek(SeekFrom::Start(0))?;
</a><a href="#h9-0-269" id="h9-0-269" class="i">+
</a><a href="#h9-0-270" id="h9-0-270" class="i">+        while pos &lt; file_len {
</a><a href="#h9-0-271" id="h9-0-271" class="i">+            // Read the next entry from the file, returning the key, value
</a><a href="#h9-0-272" id="h9-0-272" class="i">+            // position, and value length or None for tombstones.
</a><a href="#h9-0-273" id="h9-0-273" class="i">+            let result = || -&gt; std::result::Result&lt;(Vec&lt;u8&gt;, u64, Option&lt;u32&gt;), std::io::Error&gt; {
</a><a href="#h9-0-274" id="h9-0-274" class="i">+                r.read_exact(&amp;mut len_buf)?;
</a><a href="#h9-0-275" id="h9-0-275" class="i">+                let key_len = u32::from_be_bytes(len_buf);
</a><a href="#h9-0-276" id="h9-0-276" class="i">+                r.read_exact(&amp;mut len_buf)?;
</a><a href="#h9-0-277" id="h9-0-277" class="i">+                let value_len_or_tombstone = match i32::from_be_bytes(len_buf) {
</a><a href="#h9-0-278" id="h9-0-278" class="i">+                    l if l &gt;= 0 =&gt; Some(l as u32),
</a><a href="#h9-0-279" id="h9-0-279" class="i">+                    _ =&gt; None, // -1 for tombstones
</a><a href="#h9-0-280" id="h9-0-280" class="i">+                };
</a><a href="#h9-0-281" id="h9-0-281" class="i">+                let value_pos = pos + 4 + 4 + key_len as u64;
</a><a href="#h9-0-282" id="h9-0-282" class="i">+
</a><a href="#h9-0-283" id="h9-0-283" class="i">+                let mut key = vec![0; key_len as usize];
</a><a href="#h9-0-284" id="h9-0-284" class="i">+                r.read_exact(&amp;mut key)?;
</a><a href="#h9-0-285" id="h9-0-285" class="i">+
</a><a href="#h9-0-286" id="h9-0-286" class="i">+                if let Some(value_len) = value_len_or_tombstone {
</a><a href="#h9-0-287" id="h9-0-287" class="i">+                    if value_pos + value_len as u64 &gt; file_len {
</a><a href="#h9-0-288" id="h9-0-288" class="i">+                        return Err(std::io::Error::new(
</a><a href="#h9-0-289" id="h9-0-289" class="i">+                            std::io::ErrorKind::UnexpectedEof,
</a><a href="#h9-0-290" id="h9-0-290" class="i">+                            &quot;value extends beyond end of file&quot;,
</a><a href="#h9-0-291" id="h9-0-291" class="i">+                        ));
</a><a href="#h9-0-292" id="h9-0-292" class="i">+                    }
</a><a href="#h9-0-293" id="h9-0-293" class="i">+                    r.seek_relative(value_len as i64)?; // avoids discarding buffer
</a><a href="#h9-0-294" id="h9-0-294" class="i">+                }
</a><a href="#h9-0-295" id="h9-0-295" class="i">+
</a><a href="#h9-0-296" id="h9-0-296" class="i">+                Ok((key, value_pos, value_len_or_tombstone))
</a><a href="#h9-0-297" id="h9-0-297" class="i">+            }();
</a><a href="#h9-0-298" id="h9-0-298" class="i">+
</a><a href="#h9-0-299" id="h9-0-299" class="i">+            match result {
</a><a href="#h9-0-300" id="h9-0-300" class="i">+                // Populate the keydir with the entry, or remove it on tombstones.
</a><a href="#h9-0-301" id="h9-0-301" class="i">+                Ok((key, value_pos, Some(value_len))) =&gt; {
</a><a href="#h9-0-302" id="h9-0-302" class="i">+                    keydir.insert(key, (value_pos, value_len));
</a><a href="#h9-0-303" id="h9-0-303" class="i">+                    pos = value_pos + value_len as u64;
</a><a href="#h9-0-304" id="h9-0-304" class="i">+                }
</a><a href="#h9-0-305" id="h9-0-305" class="i">+                Ok((key, value_pos, None)) =&gt; {
</a><a href="#h9-0-306" id="h9-0-306" class="i">+                    keydir.remove(&amp;key);
</a><a href="#h9-0-307" id="h9-0-307" class="i">+                    pos = value_pos;
</a><a href="#h9-0-308" id="h9-0-308" class="i">+                }
</a><a href="#h9-0-309" id="h9-0-309" class="i">+                // If an incomplete entry was found at the end of the file, assume an
</a><a href="#h9-0-310" id="h9-0-310" class="i">+                // incomplete write and truncate the file.
</a><a href="#h9-0-311" id="h9-0-311" class="i">+                Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof =&gt; {
</a><a href="#h9-0-312" id="h9-0-312" class="i">+                    log::error!(&quot;Found incomplete entry at offset {}, truncating file&quot;, pos);
</a><a href="#h9-0-313" id="h9-0-313" class="i">+                    self.file.set_len(pos)?;
</a><a href="#h9-0-314" id="h9-0-314" class="i">+                    break;
</a><a href="#h9-0-315" id="h9-0-315" class="i">+                }
</a><a href="#h9-0-316" id="h9-0-316" class="i">+                Err(err) =&gt; return Err(err.into()),
</a><a href="#h9-0-317" id="h9-0-317" class="i">+            }
</a><a href="#h9-0-318" id="h9-0-318" class="i">+        }
</a><a href="#h9-0-319" id="h9-0-319" class="i">+
</a><a href="#h9-0-320" id="h9-0-320" class="i">+        Ok(keydir)
</a><a href="#h9-0-321" id="h9-0-321" class="i">+    }
</a><a href="#h9-0-322" id="h9-0-322" class="i">+
</a><a href="#h9-0-323" id="h9-0-323" class="i">+    /// Reads a value from the log file.
</a><a href="#h9-0-324" id="h9-0-324" class="i">+    fn read_value(&amp;mut self, value_pos: u64, value_len: u32) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h9-0-325" id="h9-0-325" class="i">+        let mut value = vec![0; value_len as usize];
</a><a href="#h9-0-326" id="h9-0-326" class="i">+        self.file.seek(SeekFrom::Start(value_pos))?;
</a><a href="#h9-0-327" id="h9-0-327" class="i">+        self.file.read_exact(&amp;mut value)?;
</a><a href="#h9-0-328" id="h9-0-328" class="i">+        Ok(value)
</a><a href="#h9-0-329" id="h9-0-329" class="i">+    }
</a><a href="#h9-0-330" id="h9-0-330" class="i">+
</a><a href="#h9-0-331" id="h9-0-331" class="i">+    /// Appends a key/value entry to the log file, using a None value for
</a><a href="#h9-0-332" id="h9-0-332" class="i">+    /// tombstones. It returns the position and length of the entry.
</a><a href="#h9-0-333" id="h9-0-333" class="i">+    fn write_entry(&amp;mut self, key: &amp;[u8], value: Option&lt;&amp;[u8]&gt;) -&gt; Result&lt;(u64, u32)&gt; {
</a><a href="#h9-0-334" id="h9-0-334" class="i">+        let key_len = key.len() as u32;
</a><a href="#h9-0-335" id="h9-0-335" class="i">+        let value_len = value.map_or(0, |v| v.len() as u32);
</a><a href="#h9-0-336" id="h9-0-336" class="i">+        let value_len_or_tombstone = value.map_or(-1, |v| v.len() as i32);
</a><a href="#h9-0-337" id="h9-0-337" class="i">+        let len = 4 + 4 + key_len + value_len;
</a><a href="#h9-0-338" id="h9-0-338" class="i">+
</a><a href="#h9-0-339" id="h9-0-339" class="i">+        let pos = self.file.seek(SeekFrom::End(0))?;
</a><a href="#h9-0-340" id="h9-0-340" class="i">+        let mut w = BufWriter::with_capacity(len as usize, &amp;mut self.file);
</a><a href="#h9-0-341" id="h9-0-341" class="i">+        w.write_all(&amp;key_len.to_be_bytes())?;
</a><a href="#h9-0-342" id="h9-0-342" class="i">+        w.write_all(&amp;value_len_or_tombstone.to_be_bytes())?;
</a><a href="#h9-0-343" id="h9-0-343" class="i">+        w.write_all(key)?;
</a><a href="#h9-0-344" id="h9-0-344" class="i">+        if let Some(value) = value {
</a><a href="#h9-0-345" id="h9-0-345" class="i">+            w.write_all(value)?;
</a><a href="#h9-0-346" id="h9-0-346" class="i">+        }
</a><a href="#h9-0-347" id="h9-0-347" class="i">+        w.flush()?;
</a><a href="#h9-0-348" id="h9-0-348" class="i">+
</a><a href="#h9-0-349" id="h9-0-349" class="i">+        Ok((pos, len))
</a><a href="#h9-0-350" id="h9-0-350" class="i">+    }
</a><a href="#h9-0-351" id="h9-0-351" class="i">+
</a><a href="#h9-0-352" id="h9-0-352" class="i">+    #[cfg(test)]
</a><a href="#h9-0-353" id="h9-0-353" class="i">+    /// Prints the entire log file to the given writer in human-readable form.
</a><a href="#h9-0-354" id="h9-0-354" class="i">+    fn print&lt;W: Write&gt;(&amp;mut self, w: &amp;mut W) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-355" id="h9-0-355" class="i">+        let mut len_buf = [0u8; 4];
</a><a href="#h9-0-356" id="h9-0-356" class="i">+        let file_len = self.file.metadata()?.len();
</a><a href="#h9-0-357" id="h9-0-357" class="i">+        let mut r = BufReader::new(&amp;mut self.file);
</a><a href="#h9-0-358" id="h9-0-358" class="i">+        let mut pos = r.seek(SeekFrom::Start(0))?;
</a><a href="#h9-0-359" id="h9-0-359" class="i">+        let mut idx = 0;
</a><a href="#h9-0-360" id="h9-0-360" class="i">+
</a><a href="#h9-0-361" id="h9-0-361" class="i">+        while pos &lt; file_len {
</a><a href="#h9-0-362" id="h9-0-362" class="i">+            writeln!(w, &quot;entry = {}, offset {}&quot;, idx, pos)?;
</a><a href="#h9-0-363" id="h9-0-363" class="i">+
</a><a href="#h9-0-364" id="h9-0-364" class="i">+            r.read_exact(&amp;mut len_buf)?;
</a><a href="#h9-0-365" id="h9-0-365" class="i">+            let key_len = u32::from_be_bytes(len_buf);
</a><a href="#h9-0-366" id="h9-0-366" class="i">+            writeln!(w, &quot;klen  = {} {:x?}&quot;, key_len, len_buf)?;
</a><a href="#h9-0-367" id="h9-0-367" class="i">+
</a><a href="#h9-0-368" id="h9-0-368" class="i">+            r.read_exact(&amp;mut len_buf)?;
</a><a href="#h9-0-369" id="h9-0-369" class="i">+            let value_len_or_tombstone = i32::from_be_bytes(len_buf); // NB: -1 for tombstones
</a><a href="#h9-0-370" id="h9-0-370" class="i">+            let value_len = value_len_or_tombstone.max(0) as u32;
</a><a href="#h9-0-371" id="h9-0-371" class="i">+            writeln!(w, &quot;vlen  = {} {:x?}&quot;, value_len_or_tombstone, len_buf)?;
</a><a href="#h9-0-372" id="h9-0-372" class="i">+
</a><a href="#h9-0-373" id="h9-0-373" class="i">+            let mut key = vec![0; key_len as usize];
</a><a href="#h9-0-374" id="h9-0-374" class="i">+            r.read_exact(&amp;mut key)?;
</a><a href="#h9-0-375" id="h9-0-375" class="i">+            write!(w, &quot;key   = &quot;)?;
</a><a href="#h9-0-376" id="h9-0-376" class="i">+            if let Ok(str) = std::str::from_utf8(&amp;key) {
</a><a href="#h9-0-377" id="h9-0-377" class="i">+                write!(w, r#&quot;&quot;{}&quot; &quot;#, str)?;
</a><a href="#h9-0-378" id="h9-0-378" class="i">+            }
</a><a href="#h9-0-379" id="h9-0-379" class="i">+            writeln!(w, &quot;{:x?}&quot;, key)?;
</a><a href="#h9-0-380" id="h9-0-380" class="i">+
</a><a href="#h9-0-381" id="h9-0-381" class="i">+            let mut value = vec![0; value_len as usize];
</a><a href="#h9-0-382" id="h9-0-382" class="i">+            r.read_exact(&amp;mut value)?;
</a><a href="#h9-0-383" id="h9-0-383" class="i">+            write!(w, &quot;value = &quot;)?;
</a><a href="#h9-0-384" id="h9-0-384" class="i">+            if value_len_or_tombstone &lt; 0 {
</a><a href="#h9-0-385" id="h9-0-385" class="i">+                write!(w, &quot;tombstone &quot;)?;
</a><a href="#h9-0-386" id="h9-0-386" class="i">+            } else if let Ok(str) = std::str::from_utf8(&amp;value) {
</a><a href="#h9-0-387" id="h9-0-387" class="i">+                if str.chars().all(|c| !c.is_control()) {
</a><a href="#h9-0-388" id="h9-0-388" class="i">+                    write!(w, r#&quot;&quot;{}&quot; &quot;#, str)?;
</a><a href="#h9-0-389" id="h9-0-389" class="i">+                }
</a><a href="#h9-0-390" id="h9-0-390" class="i">+            }
</a><a href="#h9-0-391" id="h9-0-391" class="i">+            write!(w, &quot;{:x?}\n\n&quot;, value)?;
</a><a href="#h9-0-392" id="h9-0-392" class="i">+
</a><a href="#h9-0-393" id="h9-0-393" class="i">+            pos += 4 + 4 + key_len as u64 + value_len as u64;
</a><a href="#h9-0-394" id="h9-0-394" class="i">+            idx += 1;
</a><a href="#h9-0-395" id="h9-0-395" class="i">+        }
</a><a href="#h9-0-396" id="h9-0-396" class="i">+        Ok(())
</a><a href="#h9-0-397" id="h9-0-397" class="i">+    }
</a><a href="#h9-0-398" id="h9-0-398" class="i">+}
</a><a href="#h9-0-399" id="h9-0-399" class="i">+
</a><a href="#h9-0-400" id="h9-0-400" class="i">+#[cfg(test)]
</a><a href="#h9-0-401" id="h9-0-401" class="i">+mod tests {
</a><a href="#h9-0-402" id="h9-0-402" class="i">+    use super::*;
</a><a href="#h9-0-403" id="h9-0-403" class="i">+
</a><a href="#h9-0-404" id="h9-0-404" class="i">+    const GOLDEN_DIR: &amp;str = &quot;src/storage/golden/bitcask&quot;;
</a><a href="#h9-0-405" id="h9-0-405" class="i">+
</a><a href="#h9-0-406" id="h9-0-406" class="i">+    super::super::engine::tests::test_engine!({
</a><a href="#h9-0-407" id="h9-0-407" class="i">+        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h9-0-408" id="h9-0-408" class="i">+        BitCask::new(path)?
</a><a href="#h9-0-409" id="h9-0-409" class="i">+    });
</a><a href="#h9-0-410" id="h9-0-410" class="i">+
</a><a href="#h9-0-411" id="h9-0-411" class="i">+    /// Creates a new BitCask engine for testing.
</a><a href="#h9-0-412" id="h9-0-412" class="i">+    fn setup() -&gt; Result&lt;BitCask&gt; {
</a><a href="#h9-0-413" id="h9-0-413" class="i">+        BitCask::new(tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;))
</a><a href="#h9-0-414" id="h9-0-414" class="i">+    }
</a><a href="#h9-0-415" id="h9-0-415" class="i">+
</a><a href="#h9-0-416" id="h9-0-416" class="i">+    /// Writes various values primarily for testing log file handling.
</a><a href="#h9-0-417" id="h9-0-417" class="i">+    ///
</a><a href="#h9-0-418" id="h9-0-418" class="i">+    /// - &#39;&#39;: empty key and value
</a><a href="#h9-0-419" id="h9-0-419" class="i">+    /// - a: write
</a><a href="#h9-0-420" id="h9-0-420" class="i">+    /// - b: write, write
</a><a href="#h9-0-421" id="h9-0-421" class="i">+    /// - c: write, delete, write
</a><a href="#h9-0-422" id="h9-0-422" class="i">+    /// - d: delete, write
</a><a href="#h9-0-423" id="h9-0-423" class="i">+    /// - e: write, delete
</a><a href="#h9-0-424" id="h9-0-424" class="i">+    /// - f: delete
</a><a href="#h9-0-425" id="h9-0-425" class="i">+    fn setup_log(s: &amp;mut BitCask) -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-426" id="h9-0-426" class="i">+        s.set(b&quot;b&quot;, vec![0x01])?;
</a><a href="#h9-0-427" id="h9-0-427" class="i">+        s.set(b&quot;b&quot;, vec![0x02])?;
</a><a href="#h9-0-428" id="h9-0-428" class="i">+
</a><a href="#h9-0-429" id="h9-0-429" class="i">+        s.set(b&quot;e&quot;, vec![0x05])?;
</a><a href="#h9-0-430" id="h9-0-430" class="i">+        s.delete(b&quot;e&quot;)?;
</a><a href="#h9-0-431" id="h9-0-431" class="i">+
</a><a href="#h9-0-432" id="h9-0-432" class="i">+        s.set(b&quot;c&quot;, vec![0x00])?;
</a><a href="#h9-0-433" id="h9-0-433" class="i">+        s.delete(b&quot;c&quot;)?;
</a><a href="#h9-0-434" id="h9-0-434" class="i">+        s.set(b&quot;c&quot;, vec![0x03])?;
</a><a href="#h9-0-435" id="h9-0-435" class="i">+
</a><a href="#h9-0-436" id="h9-0-436" class="i">+        s.set(b&quot;&quot;, vec![])?;
</a><a href="#h9-0-437" id="h9-0-437" class="i">+
</a><a href="#h9-0-438" id="h9-0-438" class="i">+        s.set(b&quot;a&quot;, vec![0x01])?;
</a><a href="#h9-0-439" id="h9-0-439" class="i">+
</a><a href="#h9-0-440" id="h9-0-440" class="i">+        s.delete(b&quot;f&quot;)?;
</a><a href="#h9-0-441" id="h9-0-441" class="i">+
</a><a href="#h9-0-442" id="h9-0-442" class="i">+        s.delete(b&quot;d&quot;)?;
</a><a href="#h9-0-443" id="h9-0-443" class="i">+        s.set(b&quot;d&quot;, vec![0x04])?;
</a><a href="#h9-0-444" id="h9-0-444" class="i">+
</a><a href="#h9-0-445" id="h9-0-445" class="i">+        // Make sure the scan yields the expected results.
</a><a href="#h9-0-446" id="h9-0-446" class="i">+        assert_eq!(
</a><a href="#h9-0-447" id="h9-0-447" class="i">+            vec![
</a><a href="#h9-0-448" id="h9-0-448" class="i">+                (b&quot;&quot;.to_vec(), vec![]),
</a><a href="#h9-0-449" id="h9-0-449" class="i">+                (b&quot;a&quot;.to_vec(), vec![0x01]),
</a><a href="#h9-0-450" id="h9-0-450" class="i">+                (b&quot;b&quot;.to_vec(), vec![0x02]),
</a><a href="#h9-0-451" id="h9-0-451" class="i">+                (b&quot;c&quot;.to_vec(), vec![0x03]),
</a><a href="#h9-0-452" id="h9-0-452" class="i">+                (b&quot;d&quot;.to_vec(), vec![0x04]),
</a><a href="#h9-0-453" id="h9-0-453" class="i">+            ],
</a><a href="#h9-0-454" id="h9-0-454" class="i">+            s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h9-0-455" id="h9-0-455" class="i">+        );
</a><a href="#h9-0-456" id="h9-0-456" class="i">+
</a><a href="#h9-0-457" id="h9-0-457" class="i">+        Ok(())
</a><a href="#h9-0-458" id="h9-0-458" class="i">+    }
</a><a href="#h9-0-459" id="h9-0-459" class="i">+
</a><a href="#h9-0-460" id="h9-0-460" class="i">+    #[test]
</a><a href="#h9-0-461" id="h9-0-461" class="i">+    /// Tests that logs are written correctly using a golden file.
</a><a href="#h9-0-462" id="h9-0-462" class="i">+    fn log() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-463" id="h9-0-463" class="i">+        let mut s = setup()?;
</a><a href="#h9-0-464" id="h9-0-464" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h9-0-465" id="h9-0-465" class="i">+
</a><a href="#h9-0-466" id="h9-0-466" class="i">+        let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
</a><a href="#h9-0-467" id="h9-0-467" class="i">+        s.log.print(&amp;mut mint.new_goldenfile(&quot;log&quot;)?)?;
</a><a href="#h9-0-468" id="h9-0-468" class="i">+        Ok(())
</a><a href="#h9-0-469" id="h9-0-469" class="i">+    }
</a><a href="#h9-0-470" id="h9-0-470" class="i">+
</a><a href="#h9-0-471" id="h9-0-471" class="i">+    #[test]
</a><a href="#h9-0-472" id="h9-0-472" class="i">+    /// Tests that writing and then reading a file yields the same results.
</a><a href="#h9-0-473" id="h9-0-473" class="i">+    fn reopen() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-474" id="h9-0-474" class="i">+        // NB: Don&#39;t use setup(), because the tempdir will be removed when
</a><a href="#h9-0-475" id="h9-0-475" class="i">+        // the path falls out of scope.
</a><a href="#h9-0-476" id="h9-0-476" class="i">+        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h9-0-477" id="h9-0-477" class="i">+        let mut s = BitCask::new(path.clone())?;
</a><a href="#h9-0-478" id="h9-0-478" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h9-0-479" id="h9-0-479" class="i">+
</a><a href="#h9-0-480" id="h9-0-480" class="i">+        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h9-0-481" id="h9-0-481" class="i">+        drop(s);
</a><a href="#h9-0-482" id="h9-0-482" class="i">+        let mut s = BitCask::new(path)?;
</a><a href="#h9-0-483" id="h9-0-483" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h9-0-484" id="h9-0-484" class="i">+
</a><a href="#h9-0-485" id="h9-0-485" class="i">+        Ok(())
</a><a href="#h9-0-486" id="h9-0-486" class="i">+    }
</a><a href="#h9-0-487" id="h9-0-487" class="i">+
</a><a href="#h9-0-488" id="h9-0-488" class="i">+    #[test]
</a><a href="#h9-0-489" id="h9-0-489" class="i">+    /// Tests log compaction, by writing golden files of the before/after state,
</a><a href="#h9-0-490" id="h9-0-490" class="i">+    /// and checking that the database contains the same results, even after
</a><a href="#h9-0-491" id="h9-0-491" class="i">+    /// reopening the file.
</a><a href="#h9-0-492" id="h9-0-492" class="i">+    fn compact() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-493" id="h9-0-493" class="i">+        // NB: Don&#39;t use setup(), because the tempdir will be removed when
</a><a href="#h9-0-494" id="h9-0-494" class="i">+        // the path falls out of scope.
</a><a href="#h9-0-495" id="h9-0-495" class="i">+        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h9-0-496" id="h9-0-496" class="i">+        let mut s = BitCask::new(path.clone())?;
</a><a href="#h9-0-497" id="h9-0-497" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h9-0-498" id="h9-0-498" class="i">+
</a><a href="#h9-0-499" id="h9-0-499" class="i">+        // Dump the initial log file.
</a><a href="#h9-0-500" id="h9-0-500" class="i">+        let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
</a><a href="#h9-0-501" id="h9-0-501" class="i">+        s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-before&quot;)?)?;
</a><a href="#h9-0-502" id="h9-0-502" class="i">+        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h9-0-503" id="h9-0-503" class="i">+
</a><a href="#h9-0-504" id="h9-0-504" class="i">+        // Compact the log file and assert the new log file contents.
</a><a href="#h9-0-505" id="h9-0-505" class="i">+        s.compact()?;
</a><a href="#h9-0-506" id="h9-0-506" class="i">+        assert_eq!(path, s.log.path);
</a><a href="#h9-0-507" id="h9-0-507" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h9-0-508" id="h9-0-508" class="i">+        s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-after&quot;)?)?;
</a><a href="#h9-0-509" id="h9-0-509" class="i">+
</a><a href="#h9-0-510" id="h9-0-510" class="i">+        // Reopen the log file and assert that the contents are the same.
</a><a href="#h9-0-511" id="h9-0-511" class="i">+        drop(s);
</a><a href="#h9-0-512" id="h9-0-512" class="i">+        let mut s = BitCask::new(path)?;
</a><a href="#h9-0-513" id="h9-0-513" class="i">+        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h9-0-514" id="h9-0-514" class="i">+
</a><a href="#h9-0-515" id="h9-0-515" class="i">+        Ok(())
</a><a href="#h9-0-516" id="h9-0-516" class="i">+    }
</a><a href="#h9-0-517" id="h9-0-517" class="i">+
</a><a href="#h9-0-518" id="h9-0-518" class="i">+    #[test]
</a><a href="#h9-0-519" id="h9-0-519" class="i">+    /// Tests that new_compact() will automatically compact the file when appropriate.
</a><a href="#h9-0-520" id="h9-0-520" class="i">+    fn new_compact() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-521" id="h9-0-521" class="i">+        // Create an initial log file with a few entries.
</a><a href="#h9-0-522" id="h9-0-522" class="i">+        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h9-0-523" id="h9-0-523" class="i">+        let path = dir.path().join(&quot;orig&quot;);
</a><a href="#h9-0-524" id="h9-0-524" class="i">+        let compactpath = dir.path().join(&quot;compact&quot;);
</a><a href="#h9-0-525" id="h9-0-525" class="i">+
</a><a href="#h9-0-526" id="h9-0-526" class="i">+        let mut s = BitCask::new_compact(path.clone(), 0.2, 0)?;
</a><a href="#h9-0-527" id="h9-0-527" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h9-0-528" id="h9-0-528" class="i">+        let status = s.status()?;
</a><a href="#h9-0-529" id="h9-0-529" class="i">+        let garbage_ratio = status.garbage_disk_size as f64 / status.total_disk_size as f64;
</a><a href="#h9-0-530" id="h9-0-530" class="i">+        let garbage_size = status.garbage_disk_size;
</a><a href="#h9-0-531" id="h9-0-531" class="i">+        drop(s);
</a><a href="#h9-0-532" id="h9-0-532" class="i">+
</a><a href="#h9-0-533" id="h9-0-533" class="i">+        // Test a few ratio/size thresholds and assert whether it should trigger compaction.
</a><a href="#h9-0-534" id="h9-0-534" class="i">+        let cases = vec![
</a><a href="#h9-0-535" id="h9-0-535" class="i">+            (-1.0, 0, true),
</a><a href="#h9-0-536" id="h9-0-536" class="i">+            (0.0, 0, true),
</a><a href="#h9-0-537" id="h9-0-537" class="i">+            (garbage_ratio - 0.001, 0, true),
</a><a href="#h9-0-538" id="h9-0-538" class="i">+            (garbage_ratio, 0, true),
</a><a href="#h9-0-539" id="h9-0-539" class="i">+            (garbage_ratio + 0.001, 0, false),
</a><a href="#h9-0-540" id="h9-0-540" class="i">+            (1.0, 0, false),
</a><a href="#h9-0-541" id="h9-0-541" class="i">+            (2.0, 0, false),
</a><a href="#h9-0-542" id="h9-0-542" class="i">+            (0.0, 1, true),
</a><a href="#h9-0-543" id="h9-0-543" class="i">+            (0.0, garbage_size - 1, true),
</a><a href="#h9-0-544" id="h9-0-544" class="i">+            (0.0, garbage_size, true),
</a><a href="#h9-0-545" id="h9-0-545" class="i">+            (0.0, garbage_size + 1, false),
</a><a href="#h9-0-546" id="h9-0-546" class="i">+        ];
</a><a href="#h9-0-547" id="h9-0-547" class="i">+        for (min_ratio, min_size, expect_compact) in cases.into_iter() {
</a><a href="#h9-0-548" id="h9-0-548" class="i">+            std::fs::copy(&amp;path, &amp;compactpath)?;
</a><a href="#h9-0-549" id="h9-0-549" class="i">+            let mut s = BitCask::new_compact(compactpath.clone(), min_ratio, min_size)?;
</a><a href="#h9-0-550" id="h9-0-550" class="i">+            let new_status = s.status()?;
</a><a href="#h9-0-551" id="h9-0-551" class="i">+            assert_eq!(new_status.live_disk_size, status.live_disk_size);
</a><a href="#h9-0-552" id="h9-0-552" class="i">+            if expect_compact {
</a><a href="#h9-0-553" id="h9-0-553" class="i">+                assert_eq!(new_status.total_disk_size, status.live_disk_size);
</a><a href="#h9-0-554" id="h9-0-554" class="i">+                assert_eq!(new_status.garbage_disk_size, 0);
</a><a href="#h9-0-555" id="h9-0-555" class="i">+            } else {
</a><a href="#h9-0-556" id="h9-0-556" class="i">+                assert_eq!(new_status, status);
</a><a href="#h9-0-557" id="h9-0-557" class="i">+            }
</a><a href="#h9-0-558" id="h9-0-558" class="i">+        }
</a><a href="#h9-0-559" id="h9-0-559" class="i">+
</a><a href="#h9-0-560" id="h9-0-560" class="i">+        Ok(())
</a><a href="#h9-0-561" id="h9-0-561" class="i">+    }
</a><a href="#h9-0-562" id="h9-0-562" class="i">+
</a><a href="#h9-0-563" id="h9-0-563" class="i">+    #[test]
</a><a href="#h9-0-564" id="h9-0-564" class="i">+    /// Tests that exclusive locks are taken out on log files, released when the
</a><a href="#h9-0-565" id="h9-0-565" class="i">+    /// database is closed, and that an error is returned if a lock is already
</a><a href="#h9-0-566" id="h9-0-566" class="i">+    /// held.
</a><a href="#h9-0-567" id="h9-0-567" class="i">+    fn log_lock() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-568" id="h9-0-568" class="i">+        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h9-0-569" id="h9-0-569" class="i">+        let s = BitCask::new(path.clone())?;
</a><a href="#h9-0-570" id="h9-0-570" class="i">+
</a><a href="#h9-0-571" id="h9-0-571" class="i">+        assert!(BitCask::new(path.clone()).is_err());
</a><a href="#h9-0-572" id="h9-0-572" class="i">+        drop(s);
</a><a href="#h9-0-573" id="h9-0-573" class="i">+        assert!(BitCask::new(path.clone()).is_ok());
</a><a href="#h9-0-574" id="h9-0-574" class="i">+
</a><a href="#h9-0-575" id="h9-0-575" class="i">+        Ok(())
</a><a href="#h9-0-576" id="h9-0-576" class="i">+    }
</a><a href="#h9-0-577" id="h9-0-577" class="i">+
</a><a href="#h9-0-578" id="h9-0-578" class="i">+    #[test]
</a><a href="#h9-0-579" id="h9-0-579" class="i">+    /// Tests that an incomplete write at the end of the log file can be
</a><a href="#h9-0-580" id="h9-0-580" class="i">+    /// recovered by discarding the last entry.
</a><a href="#h9-0-581" id="h9-0-581" class="i">+    fn recovery() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-582" id="h9-0-582" class="i">+        // Create an initial log file with a few entries.
</a><a href="#h9-0-583" id="h9-0-583" class="i">+        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h9-0-584" id="h9-0-584" class="i">+        let path = dir.path().join(&quot;complete&quot;);
</a><a href="#h9-0-585" id="h9-0-585" class="i">+        let truncpath = dir.path().join(&quot;truncated&quot;);
</a><a href="#h9-0-586" id="h9-0-586" class="i">+
</a><a href="#h9-0-587" id="h9-0-587" class="i">+        let mut log = Log::new(path.clone())?;
</a><a href="#h9-0-588" id="h9-0-588" class="i">+        let mut ends = vec![];
</a><a href="#h9-0-589" id="h9-0-589" class="i">+
</a><a href="#h9-0-590" id="h9-0-590" class="i">+        let (pos, len) = log.write_entry(&quot;deleted&quot;.as_bytes(), Some(&amp;[1, 2, 3]))?;
</a><a href="#h9-0-591" id="h9-0-591" class="i">+        ends.push(pos + len as u64);
</a><a href="#h9-0-592" id="h9-0-592" class="i">+
</a><a href="#h9-0-593" id="h9-0-593" class="i">+        let (pos, len) = log.write_entry(&quot;deleted&quot;.as_bytes(), None)?;
</a><a href="#h9-0-594" id="h9-0-594" class="i">+        ends.push(pos + len as u64);
</a><a href="#h9-0-595" id="h9-0-595" class="i">+
</a><a href="#h9-0-596" id="h9-0-596" class="i">+        let (pos, len) = log.write_entry(&amp;[], Some(&amp;[]))?;
</a><a href="#h9-0-597" id="h9-0-597" class="i">+        ends.push(pos + len as u64);
</a><a href="#h9-0-598" id="h9-0-598" class="i">+
</a><a href="#h9-0-599" id="h9-0-599" class="i">+        let (pos, len) = log.write_entry(&quot;key&quot;.as_bytes(), Some(&amp;[1, 2, 3, 4, 5]))?;
</a><a href="#h9-0-600" id="h9-0-600" class="i">+        ends.push(pos + len as u64);
</a><a href="#h9-0-601" id="h9-0-601" class="i">+
</a><a href="#h9-0-602" id="h9-0-602" class="i">+        drop(log);
</a><a href="#h9-0-603" id="h9-0-603" class="i">+
</a><a href="#h9-0-604" id="h9-0-604" class="i">+        // Copy the file, and truncate it at each byte, then try to open it
</a><a href="#h9-0-605" id="h9-0-605" class="i">+        // and assert that we always retain a prefix of entries.
</a><a href="#h9-0-606" id="h9-0-606" class="i">+        let size = std::fs::metadata(&amp;path)?.len();
</a><a href="#h9-0-607" id="h9-0-607" class="i">+        for pos in 0..=size {
</a><a href="#h9-0-608" id="h9-0-608" class="i">+            std::fs::copy(&amp;path, &amp;truncpath)?;
</a><a href="#h9-0-609" id="h9-0-609" class="i">+            let f = std::fs::OpenOptions::new().write(true).open(&amp;truncpath)?;
</a><a href="#h9-0-610" id="h9-0-610" class="i">+            f.set_len(pos)?;
</a><a href="#h9-0-611" id="h9-0-611" class="i">+            drop(f);
</a><a href="#h9-0-612" id="h9-0-612" class="i">+
</a><a href="#h9-0-613" id="h9-0-613" class="i">+            let mut expect = vec![];
</a><a href="#h9-0-614" id="h9-0-614" class="i">+            if pos &gt;= ends[0] {
</a><a href="#h9-0-615" id="h9-0-615" class="i">+                expect.push((b&quot;deleted&quot;.to_vec(), vec![1, 2, 3]))
</a><a href="#h9-0-616" id="h9-0-616" class="i">+            }
</a><a href="#h9-0-617" id="h9-0-617" class="i">+            if pos &gt;= ends[1] {
</a><a href="#h9-0-618" id="h9-0-618" class="i">+                expect.pop(); // &quot;deleted&quot; key removed
</a><a href="#h9-0-619" id="h9-0-619" class="i">+            }
</a><a href="#h9-0-620" id="h9-0-620" class="i">+            if pos &gt;= ends[2] {
</a><a href="#h9-0-621" id="h9-0-621" class="i">+                expect.push((b&quot;&quot;.to_vec(), vec![]))
</a><a href="#h9-0-622" id="h9-0-622" class="i">+            }
</a><a href="#h9-0-623" id="h9-0-623" class="i">+            if pos &gt;= ends[3] {
</a><a href="#h9-0-624" id="h9-0-624" class="i">+                expect.push((b&quot;key&quot;.to_vec(), vec![1, 2, 3, 4, 5]))
</a><a href="#h9-0-625" id="h9-0-625" class="i">+            }
</a><a href="#h9-0-626" id="h9-0-626" class="i">+
</a><a href="#h9-0-627" id="h9-0-627" class="i">+            let mut s = BitCask::new(truncpath.clone())?;
</a><a href="#h9-0-628" id="h9-0-628" class="i">+            assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h9-0-629" id="h9-0-629" class="i">+        }
</a><a href="#h9-0-630" id="h9-0-630" class="i">+
</a><a href="#h9-0-631" id="h9-0-631" class="i">+        Ok(())
</a><a href="#h9-0-632" id="h9-0-632" class="i">+    }
</a><a href="#h9-0-633" id="h9-0-633" class="i">+
</a><a href="#h9-0-634" id="h9-0-634" class="i">+    #[test]
</a><a href="#h9-0-635" id="h9-0-635" class="i">+    /// Tests status(), both for a log file with known garbage, and
</a><a href="#h9-0-636" id="h9-0-636" class="i">+    /// after compacting it when the live size must equal the file size.
</a><a href="#h9-0-637" id="h9-0-637" class="i">+    fn status_full() -&gt; Result&lt;()&gt; {
</a><a href="#h9-0-638" id="h9-0-638" class="i">+        let mut s = setup()?;
</a><a href="#h9-0-639" id="h9-0-639" class="i">+        setup_log(&amp;mut s)?;
</a><a href="#h9-0-640" id="h9-0-640" class="i">+
</a><a href="#h9-0-641" id="h9-0-641" class="i">+        // Before compaction.
</a><a href="#h9-0-642" id="h9-0-642" class="i">+        assert_eq!(
</a><a href="#h9-0-643" id="h9-0-643" class="i">+            s.status()?,
</a><a href="#h9-0-644" id="h9-0-644" class="i">+            Status {
</a><a href="#h9-0-645" id="h9-0-645" class="i">+                name: &quot;bitcask&quot;.to_string(),
</a><a href="#h9-0-646" id="h9-0-646" class="i">+                keys: 5,
</a><a href="#h9-0-647" id="h9-0-647" class="i">+                size: 8,
</a><a href="#h9-0-648" id="h9-0-648" class="i">+                total_disk_size: 114,
</a><a href="#h9-0-649" id="h9-0-649" class="i">+                live_disk_size: 48,
</a><a href="#h9-0-650" id="h9-0-650" class="i">+                garbage_disk_size: 66
</a><a href="#h9-0-651" id="h9-0-651" class="i">+            }
</a><a href="#h9-0-652" id="h9-0-652" class="i">+        );
</a><a href="#h9-0-653" id="h9-0-653" class="i">+
</a><a href="#h9-0-654" id="h9-0-654" class="i">+        // After compaction.
</a><a href="#h9-0-655" id="h9-0-655" class="i">+        s.compact()?;
</a><a href="#h9-0-656" id="h9-0-656" class="i">+        assert_eq!(
</a><a href="#h9-0-657" id="h9-0-657" class="i">+            s.status()?,
</a><a href="#h9-0-658" id="h9-0-658" class="i">+            Status {
</a><a href="#h9-0-659" id="h9-0-659" class="i">+                name: &quot;bitcask&quot;.to_string(),
</a><a href="#h9-0-660" id="h9-0-660" class="i">+                keys: 5,
</a><a href="#h9-0-661" id="h9-0-661" class="i">+                size: 8,
</a><a href="#h9-0-662" id="h9-0-662" class="i">+                total_disk_size: 48,
</a><a href="#h9-0-663" id="h9-0-663" class="i">+                live_disk_size: 48,
</a><a href="#h9-0-664" id="h9-0-664" class="i">+                garbage_disk_size: 0,
</a><a href="#h9-0-665" id="h9-0-665" class="i">+            }
</a><a href="#h9-0-666" id="h9-0-666" class="i">+        );
</a><a href="#h9-0-667" id="h9-0-667" class="i">+
</a><a href="#h9-0-668" id="h9-0-668" class="i">+        Ok(())
</a><a href="#h9-0-669" id="h9-0-669" class="i">+    }
</a><a href="#h9-0-670" id="h9-0-670" class="i">+}
</a><b>diff --git a/<a id="h10" href="../file/src/storage/engine.rs.html">src/storage/engine.rs</a> b/<a href="../file/src/storage/engine.rs.html">src/storage/engine.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -0,0 +1,470 @@
</a><a href="#h10-0-0" id="h10-0-0" class="i">+use crate::error::Result;
</a><a href="#h10-0-1" id="h10-0-1" class="i">+
</a><a href="#h10-0-2" id="h10-0-2" class="i">+use serde::{Deserialize, Serialize};
</a><a href="#h10-0-3" id="h10-0-3" class="i">+
</a><a href="#h10-0-4" id="h10-0-4" class="i">+/// A key/value storage engine, where both keys and values are arbitrary byte
</a><a href="#h10-0-5" id="h10-0-5" class="i">+/// strings between 0 B and 2 GB, stored in lexicographical key order. Writes
</a><a href="#h10-0-6" id="h10-0-6" class="i">+/// are only guaranteed durable after calling flush().
</a><a href="#h10-0-7" id="h10-0-7" class="i">+///
</a><a href="#h10-0-8" id="h10-0-8" class="i">+/// Only supports single-threaded use since all methods (including reads) take a
</a><a href="#h10-0-9" id="h10-0-9" class="i">+/// mutable reference -- serialized access can&#39;t be avoided anyway, since both
</a><a href="#h10-0-10" id="h10-0-10" class="i">+/// Raft execution and file access is serial.
</a><a href="#h10-0-11" id="h10-0-11" class="i">+pub trait Engine: std::fmt::Display + Send + Sync {
</a><a href="#h10-0-12" id="h10-0-12" class="i">+    /// The iterator returned by scan().
</a><a href="#h10-0-13" id="h10-0-13" class="i">+    type ScanIterator&lt;&#39;a&gt;: ScanIterator + &#39;a
</a><a href="#h10-0-14" id="h10-0-14" class="i">+    where
</a><a href="#h10-0-15" id="h10-0-15" class="i">+        Self: Sized + &#39;a; // omit in trait objects, for object safety
</a><a href="#h10-0-16" id="h10-0-16" class="i">+
</a><a href="#h10-0-17" id="h10-0-17" class="i">+    /// Deletes a key, or does nothing if it does not exist.
</a><a href="#h10-0-18" id="h10-0-18" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt;;
</a><a href="#h10-0-19" id="h10-0-19" class="i">+
</a><a href="#h10-0-20" id="h10-0-20" class="i">+    /// Flushes any buffered data to the underlying storage medium.
</a><a href="#h10-0-21" id="h10-0-21" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</a><a href="#h10-0-22" id="h10-0-22" class="i">+
</a><a href="#h10-0-23" id="h10-0-23" class="i">+    /// Gets a value for a key, if it exists.
</a><a href="#h10-0-24" id="h10-0-24" class="i">+    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
</a><a href="#h10-0-25" id="h10-0-25" class="i">+
</a><a href="#h10-0-26" id="h10-0-26" class="i">+    /// Iterates over an ordered range of key/value pairs.
</a><a href="#h10-0-27" id="h10-0-27" class="i">+    fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self::ScanIterator&lt;&#39;_&gt;
</a><a href="#h10-0-28" id="h10-0-28" class="i">+    where
</a><a href="#h10-0-29" id="h10-0-29" class="i">+        Self: Sized; // omit in trait objects, for object safety
</a><a href="#h10-0-30" id="h10-0-30" class="i">+
</a><a href="#h10-0-31" id="h10-0-31" class="i">+    /// Like scan, but can be used from trait objects. The iterator will use
</a><a href="#h10-0-32" id="h10-0-32" class="i">+    /// dynamic dispatch, which has a minor performance penalty.
</a><a href="#h10-0-33" id="h10-0-33" class="i">+    fn scan_dyn(
</a><a href="#h10-0-34" id="h10-0-34" class="i">+        &amp;mut self,
</a><a href="#h10-0-35" id="h10-0-35" class="i">+        range: (std::ops::Bound&lt;Vec&lt;u8&gt;&gt;, std::ops::Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h10-0-36" id="h10-0-36" class="i">+    ) -&gt; Box&lt;dyn ScanIterator + &#39;_&gt;;
</a><a href="#h10-0-37" id="h10-0-37" class="i">+
</a><a href="#h10-0-38" id="h10-0-38" class="i">+    /// Iterates over all key/value pairs starting with prefix.
</a><a href="#h10-0-39" id="h10-0-39" class="i">+    fn scan_prefix(&amp;mut self, prefix: &amp;[u8]) -&gt; Self::ScanIterator&lt;&#39;_&gt;
</a><a href="#h10-0-40" id="h10-0-40" class="i">+    where
</a><a href="#h10-0-41" id="h10-0-41" class="i">+        Self: Sized, // omit in trait objects, for object safety
</a><a href="#h10-0-42" id="h10-0-42" class="i">+    {
</a><a href="#h10-0-43" id="h10-0-43" class="i">+        let start = std::ops::Bound::Included(prefix.to_vec());
</a><a href="#h10-0-44" id="h10-0-44" class="i">+        let end = match prefix.iter().rposition(|b| *b != 0xff) {
</a><a href="#h10-0-45" id="h10-0-45" class="i">+            Some(i) =&gt; std::ops::Bound::Excluded(
</a><a href="#h10-0-46" id="h10-0-46" class="i">+                prefix.iter().take(i).copied().chain(std::iter::once(prefix[i] + 1)).collect(),
</a><a href="#h10-0-47" id="h10-0-47" class="i">+            ),
</a><a href="#h10-0-48" id="h10-0-48" class="i">+            None =&gt; std::ops::Bound::Unbounded,
</a><a href="#h10-0-49" id="h10-0-49" class="i">+        };
</a><a href="#h10-0-50" id="h10-0-50" class="i">+        self.scan((start, end))
</a><a href="#h10-0-51" id="h10-0-51" class="i">+    }
</a><a href="#h10-0-52" id="h10-0-52" class="i">+
</a><a href="#h10-0-53" id="h10-0-53" class="i">+    /// Sets a value for a key, replacing the existing value if any.
</a><a href="#h10-0-54" id="h10-0-54" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;
</a><a href="#h10-0-55" id="h10-0-55" class="i">+
</a><a href="#h10-0-56" id="h10-0-56" class="i">+    /// Returns engine status.
</a><a href="#h10-0-57" id="h10-0-57" class="i">+    fn status(&amp;mut self) -&gt; Result&lt;Status&gt;;
</a><a href="#h10-0-58" id="h10-0-58" class="i">+}
</a><a href="#h10-0-59" id="h10-0-59" class="i">+
</a><a href="#h10-0-60" id="h10-0-60" class="i">+/// A scan iterator, with a blanket implementation (in lieu of trait aliases).
</a><a href="#h10-0-61" id="h10-0-61" class="i">+pub trait ScanIterator: DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; {}
</a><a href="#h10-0-62" id="h10-0-62" class="i">+
</a><a href="#h10-0-63" id="h10-0-63" class="i">+impl&lt;I: DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt;&gt; ScanIterator for I {}
</a><a href="#h10-0-64" id="h10-0-64" class="i">+
</a><a href="#h10-0-65" id="h10-0-65" class="i">+/// Engine status.
</a><a href="#h10-0-66" id="h10-0-66" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h10-0-67" id="h10-0-67" class="i">+pub struct Status {
</a><a href="#h10-0-68" id="h10-0-68" class="i">+    /// The name of the storage engine.
</a><a href="#h10-0-69" id="h10-0-69" class="i">+    pub name: String,
</a><a href="#h10-0-70" id="h10-0-70" class="i">+    /// The number of live keys in the engine.
</a><a href="#h10-0-71" id="h10-0-71" class="i">+    pub keys: u64,
</a><a href="#h10-0-72" id="h10-0-72" class="i">+    /// The logical size of live key/value pairs.
</a><a href="#h10-0-73" id="h10-0-73" class="i">+    pub size: u64,
</a><a href="#h10-0-74" id="h10-0-74" class="i">+    /// The on-disk size of all data, live and garbage.
</a><a href="#h10-0-75" id="h10-0-75" class="i">+    pub total_disk_size: u64,
</a><a href="#h10-0-76" id="h10-0-76" class="i">+    /// The on-disk size of live data.
</a><a href="#h10-0-77" id="h10-0-77" class="i">+    pub live_disk_size: u64,
</a><a href="#h10-0-78" id="h10-0-78" class="i">+    /// The on-disk size of garbage data.
</a><a href="#h10-0-79" id="h10-0-79" class="i">+    pub garbage_disk_size: u64,
</a><a href="#h10-0-80" id="h10-0-80" class="i">+}
</a><a href="#h10-0-81" id="h10-0-81" class="i">+
</a><a href="#h10-0-82" id="h10-0-82" class="i">+#[cfg(test)]
</a><a href="#h10-0-83" id="h10-0-83" class="i">+pub(crate) mod tests {
</a><a href="#h10-0-84" id="h10-0-84" class="i">+    /// Generates common tests for any Engine implementation.
</a><a href="#h10-0-85" id="h10-0-85" class="i">+    macro_rules! test_engine {
</a><a href="#h10-0-86" id="h10-0-86" class="i">+        ($setup:expr) =&gt; {
</a><a href="#h10-0-87" id="h10-0-87" class="i">+            #[track_caller]
</a><a href="#h10-0-88" id="h10-0-88" class="i">+            /// Asserts that a scan yields the expected items.
</a><a href="#h10-0-89" id="h10-0-89" class="i">+            fn assert_scan&lt;I&gt;(iter: I, expect: Vec&lt;(&amp;[u8], Vec&lt;u8&gt;)&gt;) -&gt; Result&lt;()&gt;
</a><a href="#h10-0-90" id="h10-0-90" class="i">+            where
</a><a href="#h10-0-91" id="h10-0-91" class="i">+                I: Iterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt;,
</a><a href="#h10-0-92" id="h10-0-92" class="i">+            {
</a><a href="#h10-0-93" id="h10-0-93" class="i">+                assert_eq!(
</a><a href="#h10-0-94" id="h10-0-94" class="i">+                    iter.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h10-0-95" id="h10-0-95" class="i">+                    expect.into_iter().map(|(k, v)| (k.to_vec(), v)).collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h10-0-96" id="h10-0-96" class="i">+                );
</a><a href="#h10-0-97" id="h10-0-97" class="i">+                Ok(())
</a><a href="#h10-0-98" id="h10-0-98" class="i">+            }
</a><a href="#h10-0-99" id="h10-0-99" class="i">+
</a><a href="#h10-0-100" id="h10-0-100" class="i">+            /// Tests Engine point operations, i.e. set, get, and delete.
</a><a href="#h10-0-101" id="h10-0-101" class="i">+            #[test]
</a><a href="#h10-0-102" id="h10-0-102" class="i">+            fn point_ops() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-103" id="h10-0-103" class="i">+                let mut s = $setup;
</a><a href="#h10-0-104" id="h10-0-104" class="i">+
</a><a href="#h10-0-105" id="h10-0-105" class="i">+                // Getting a missing key should return None.
</a><a href="#h10-0-106" id="h10-0-106" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h10-0-107" id="h10-0-107" class="i">+
</a><a href="#h10-0-108" id="h10-0-108" class="i">+                // Setting and getting a key should return its value.
</a><a href="#h10-0-109" id="h10-0-109" class="i">+                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h10-0-110" id="h10-0-110" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![1]));
</a><a href="#h10-0-111" id="h10-0-111" class="i">+
</a><a href="#h10-0-112" id="h10-0-112" class="i">+                // Setting a different key should not affect the first.
</a><a href="#h10-0-113" id="h10-0-113" class="i">+                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h10-0-114" id="h10-0-114" class="i">+                assert_eq!(s.get(b&quot;b&quot;)?, Some(vec![2]));
</a><a href="#h10-0-115" id="h10-0-115" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![1]));
</a><a href="#h10-0-116" id="h10-0-116" class="i">+
</a><a href="#h10-0-117" id="h10-0-117" class="i">+                // Getting a different missing key should return None. The
</a><a href="#h10-0-118" id="h10-0-118" class="i">+                // comparison is case-insensitive for strings.
</a><a href="#h10-0-119" id="h10-0-119" class="i">+                assert_eq!(s.get(b&quot;c&quot;)?, None);
</a><a href="#h10-0-120" id="h10-0-120" class="i">+                assert_eq!(s.get(b&quot;A&quot;)?, None);
</a><a href="#h10-0-121" id="h10-0-121" class="i">+
</a><a href="#h10-0-122" id="h10-0-122" class="i">+                // Setting an existing key should replace its value.
</a><a href="#h10-0-123" id="h10-0-123" class="i">+                s.set(b&quot;a&quot;, vec![0])?;
</a><a href="#h10-0-124" id="h10-0-124" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![0]));
</a><a href="#h10-0-125" id="h10-0-125" class="i">+
</a><a href="#h10-0-126" id="h10-0-126" class="i">+                // Deleting a key should remove it, but not affect others.
</a><a href="#h10-0-127" id="h10-0-127" class="i">+                s.delete(b&quot;a&quot;)?;
</a><a href="#h10-0-128" id="h10-0-128" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h10-0-129" id="h10-0-129" class="i">+                assert_eq!(s.get(b&quot;b&quot;)?, Some(vec![2]));
</a><a href="#h10-0-130" id="h10-0-130" class="i">+
</a><a href="#h10-0-131" id="h10-0-131" class="i">+                // Deletes are idempotent.
</a><a href="#h10-0-132" id="h10-0-132" class="i">+                s.delete(b&quot;a&quot;)?;
</a><a href="#h10-0-133" id="h10-0-133" class="i">+                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h10-0-134" id="h10-0-134" class="i">+
</a><a href="#h10-0-135" id="h10-0-135" class="i">+                Ok(())
</a><a href="#h10-0-136" id="h10-0-136" class="i">+            }
</a><a href="#h10-0-137" id="h10-0-137" class="i">+
</a><a href="#h10-0-138" id="h10-0-138" class="i">+            #[test]
</a><a href="#h10-0-139" id="h10-0-139" class="i">+            /// Tests Engine point operations on empty keys and values. These
</a><a href="#h10-0-140" id="h10-0-140" class="i">+            /// are as valid as any other key/value.
</a><a href="#h10-0-141" id="h10-0-141" class="i">+            fn point_ops_empty() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-142" id="h10-0-142" class="i">+                let mut s = $setup;
</a><a href="#h10-0-143" id="h10-0-143" class="i">+                assert_eq!(s.get(b&quot;&quot;)?, None);
</a><a href="#h10-0-144" id="h10-0-144" class="i">+                s.set(b&quot;&quot;, vec![])?;
</a><a href="#h10-0-145" id="h10-0-145" class="i">+                assert_eq!(s.get(b&quot;&quot;)?, Some(vec![]));
</a><a href="#h10-0-146" id="h10-0-146" class="i">+                s.delete(b&quot;&quot;)?;
</a><a href="#h10-0-147" id="h10-0-147" class="i">+                assert_eq!(s.get(b&quot;&quot;)?, None);
</a><a href="#h10-0-148" id="h10-0-148" class="i">+                Ok(())
</a><a href="#h10-0-149" id="h10-0-149" class="i">+            }
</a><a href="#h10-0-150" id="h10-0-150" class="i">+
</a><a href="#h10-0-151" id="h10-0-151" class="i">+            #[test]
</a><a href="#h10-0-152" id="h10-0-152" class="i">+            /// Tests Engine point operations on keys and values of increasing
</a><a href="#h10-0-153" id="h10-0-153" class="i">+            /// sizes, up to 16 MB.
</a><a href="#h10-0-154" id="h10-0-154" class="i">+            fn point_ops_sizes() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-155" id="h10-0-155" class="i">+                let mut s = $setup;
</a><a href="#h10-0-156" id="h10-0-156" class="i">+
</a><a href="#h10-0-157" id="h10-0-157" class="i">+                // Generate keys/values for increasing powers of two.
</a><a href="#h10-0-158" id="h10-0-158" class="i">+                for size in (1..=24).map(|i| 1 &lt;&lt; i) {
</a><a href="#h10-0-159" id="h10-0-159" class="i">+                    let bytes = &quot;x&quot;.repeat(size);
</a><a href="#h10-0-160" id="h10-0-160" class="i">+                    let key = bytes.as_bytes();
</a><a href="#h10-0-161" id="h10-0-161" class="i">+                    let value = bytes.clone().into_bytes();
</a><a href="#h10-0-162" id="h10-0-162" class="i">+
</a><a href="#h10-0-163" id="h10-0-163" class="i">+                    assert_eq!(s.get(key)?, None);
</a><a href="#h10-0-164" id="h10-0-164" class="i">+                    s.set(key, value.clone())?;
</a><a href="#h10-0-165" id="h10-0-165" class="i">+                    assert_eq!(s.get(key)?, Some(value));
</a><a href="#h10-0-166" id="h10-0-166" class="i">+                    s.delete(key)?;
</a><a href="#h10-0-167" id="h10-0-167" class="i">+                    assert_eq!(s.get(key)?, None);
</a><a href="#h10-0-168" id="h10-0-168" class="i">+                }
</a><a href="#h10-0-169" id="h10-0-169" class="i">+
</a><a href="#h10-0-170" id="h10-0-170" class="i">+                Ok(())
</a><a href="#h10-0-171" id="h10-0-171" class="i">+            }
</a><a href="#h10-0-172" id="h10-0-172" class="i">+
</a><a href="#h10-0-173" id="h10-0-173" class="i">+            #[test]
</a><a href="#h10-0-174" id="h10-0-174" class="i">+            /// Tests various Engine scans.
</a><a href="#h10-0-175" id="h10-0-175" class="i">+            fn scan() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-176" id="h10-0-176" class="i">+                let mut s = $setup;
</a><a href="#h10-0-177" id="h10-0-177" class="i">+                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h10-0-178" id="h10-0-178" class="i">+                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h10-0-179" id="h10-0-179" class="i">+                s.set(b&quot;ba&quot;, vec![2, 1])?;
</a><a href="#h10-0-180" id="h10-0-180" class="i">+                s.set(b&quot;bb&quot;, vec![2, 2])?;
</a><a href="#h10-0-181" id="h10-0-181" class="i">+                s.set(b&quot;c&quot;, vec![3])?;
</a><a href="#h10-0-182" id="h10-0-182" class="i">+                s.set(b&quot;C&quot;, vec![3])?;
</a><a href="#h10-0-183" id="h10-0-183" class="i">+
</a><a href="#h10-0-184" id="h10-0-184" class="i">+                // Forward/reverse scans.
</a><a href="#h10-0-185" id="h10-0-185" class="i">+                assert_scan(
</a><a href="#h10-0-186" id="h10-0-186" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()),
</a><a href="#h10-0-187" id="h10-0-187" class="i">+                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;bb&quot;, vec![2, 2])],
</a><a href="#h10-0-188" id="h10-0-188" class="i">+                )?;
</a><a href="#h10-0-189" id="h10-0-189" class="i">+                assert_scan(
</a><a href="#h10-0-190" id="h10-0-190" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).rev(),
</a><a href="#h10-0-191" id="h10-0-191" class="i">+                    vec![(b&quot;bb&quot;, vec![2, 2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;b&quot;, vec![2])],
</a><a href="#h10-0-192" id="h10-0-192" class="i">+                )?;
</a><a href="#h10-0-193" id="h10-0-193" class="i">+
</a><a href="#h10-0-194" id="h10-0-194" class="i">+                // Inclusive/exclusive ranges.
</a><a href="#h10-0-195" id="h10-0-195" class="i">+                assert_scan(
</a><a href="#h10-0-196" id="h10-0-196" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()),
</a><a href="#h10-0-197" id="h10-0-197" class="i">+                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1])],
</a><a href="#h10-0-198" id="h10-0-198" class="i">+                )?;
</a><a href="#h10-0-199" id="h10-0-199" class="i">+                assert_scan(
</a><a href="#h10-0-200" id="h10-0-200" class="i">+                    s.scan(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()),
</a><a href="#h10-0-201" id="h10-0-201" class="i">+                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;bb&quot;, vec![2, 2])],
</a><a href="#h10-0-202" id="h10-0-202" class="i">+                )?;
</a><a href="#h10-0-203" id="h10-0-203" class="i">+
</a><a href="#h10-0-204" id="h10-0-204" class="i">+                // Open ranges.
</a><a href="#h10-0-205" id="h10-0-205" class="i">+                assert_scan(s.scan(b&quot;bb&quot;.to_vec()..), vec![(b&quot;bb&quot;, vec![2, 2]), (b&quot;c&quot;, vec![3])])?;
</a><a href="#h10-0-206" id="h10-0-206" class="i">+                assert_scan(
</a><a href="#h10-0-207" id="h10-0-207" class="i">+                    s.scan(..=b&quot;b&quot;.to_vec()),
</a><a href="#h10-0-208" id="h10-0-208" class="i">+                    vec![(b&quot;C&quot;, vec![3]), (b&quot;a&quot;, vec![1]), (b&quot;b&quot;, vec![2])],
</a><a href="#h10-0-209" id="h10-0-209" class="i">+                )?;
</a><a href="#h10-0-210" id="h10-0-210" class="i">+
</a><a href="#h10-0-211" id="h10-0-211" class="i">+                // Full range.
</a><a href="#h10-0-212" id="h10-0-212" class="i">+                assert_scan(
</a><a href="#h10-0-213" id="h10-0-213" class="i">+                    s.scan(..),
</a><a href="#h10-0-214" id="h10-0-214" class="i">+                    vec![
</a><a href="#h10-0-215" id="h10-0-215" class="i">+                        (b&quot;C&quot;, vec![3]),
</a><a href="#h10-0-216" id="h10-0-216" class="i">+                        (b&quot;a&quot;, vec![1]),
</a><a href="#h10-0-217" id="h10-0-217" class="i">+                        (b&quot;b&quot;, vec![2]),
</a><a href="#h10-0-218" id="h10-0-218" class="i">+                        (b&quot;ba&quot;, vec![2, 1]),
</a><a href="#h10-0-219" id="h10-0-219" class="i">+                        (b&quot;bb&quot;, vec![2, 2]),
</a><a href="#h10-0-220" id="h10-0-220" class="i">+                        (b&quot;c&quot;, vec![3]),
</a><a href="#h10-0-221" id="h10-0-221" class="i">+                    ],
</a><a href="#h10-0-222" id="h10-0-222" class="i">+                )?;
</a><a href="#h10-0-223" id="h10-0-223" class="i">+                Ok(())
</a><a href="#h10-0-224" id="h10-0-224" class="i">+            }
</a><a href="#h10-0-225" id="h10-0-225" class="i">+
</a><a href="#h10-0-226" id="h10-0-226" class="i">+            #[test]
</a><a href="#h10-0-227" id="h10-0-227" class="i">+            /// Tests prefix scans.
</a><a href="#h10-0-228" id="h10-0-228" class="i">+            fn scan_prefix() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-229" id="h10-0-229" class="i">+                let mut s = $setup;
</a><a href="#h10-0-230" id="h10-0-230" class="i">+                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h10-0-231" id="h10-0-231" class="i">+                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h10-0-232" id="h10-0-232" class="i">+                s.set(b&quot;ba&quot;, vec![2, 1])?;
</a><a href="#h10-0-233" id="h10-0-233" class="i">+                s.set(b&quot;bb&quot;, vec![2, 2])?;
</a><a href="#h10-0-234" id="h10-0-234" class="i">+                s.set(b&quot;b\xff&quot;, vec![2, 0xff])?;
</a><a href="#h10-0-235" id="h10-0-235" class="i">+                s.set(b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00])?;
</a><a href="#h10-0-236" id="h10-0-236" class="i">+                s.set(b&quot;b\xffb&quot;, vec![2, 0xff, 2])?;
</a><a href="#h10-0-237" id="h10-0-237" class="i">+                s.set(b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff])?;
</a><a href="#h10-0-238" id="h10-0-238" class="i">+                s.set(b&quot;c&quot;, vec![3])?;
</a><a href="#h10-0-239" id="h10-0-239" class="i">+                s.set(b&quot;\xff&quot;, vec![0xff])?;
</a><a href="#h10-0-240" id="h10-0-240" class="i">+                s.set(b&quot;\xff\xff&quot;, vec![0xff, 0xff])?;
</a><a href="#h10-0-241" id="h10-0-241" class="i">+                s.set(b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff])?;
</a><a href="#h10-0-242" id="h10-0-242" class="i">+                s.set(b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff])?;
</a><a href="#h10-0-243" id="h10-0-243" class="i">+
</a><a href="#h10-0-244" id="h10-0-244" class="i">+                assert_scan(
</a><a href="#h10-0-245" id="h10-0-245" class="i">+                    s.scan_prefix(b&quot;&quot;),
</a><a href="#h10-0-246" id="h10-0-246" class="i">+                    vec![
</a><a href="#h10-0-247" id="h10-0-247" class="i">+                        (b&quot;a&quot;, vec![1]),
</a><a href="#h10-0-248" id="h10-0-248" class="i">+                        (b&quot;b&quot;, vec![2]),
</a><a href="#h10-0-249" id="h10-0-249" class="i">+                        (b&quot;ba&quot;, vec![2, 1]),
</a><a href="#h10-0-250" id="h10-0-250" class="i">+                        (b&quot;bb&quot;, vec![2, 2]),
</a><a href="#h10-0-251" id="h10-0-251" class="i">+                        (b&quot;b\xff&quot;, vec![2, 0xff]),
</a><a href="#h10-0-252" id="h10-0-252" class="i">+                        (b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00]),
</a><a href="#h10-0-253" id="h10-0-253" class="i">+                        (b&quot;b\xffb&quot;, vec![2, 0xff, 2]),
</a><a href="#h10-0-254" id="h10-0-254" class="i">+                        (b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff]),
</a><a href="#h10-0-255" id="h10-0-255" class="i">+                        (b&quot;c&quot;, vec![3]),
</a><a href="#h10-0-256" id="h10-0-256" class="i">+                        (b&quot;\xff&quot;, vec![0xff]),
</a><a href="#h10-0-257" id="h10-0-257" class="i">+                        (b&quot;\xff\xff&quot;, vec![0xff, 0xff]),
</a><a href="#h10-0-258" id="h10-0-258" class="i">+                        (b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff]),
</a><a href="#h10-0-259" id="h10-0-259" class="i">+                        (b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff]),
</a><a href="#h10-0-260" id="h10-0-260" class="i">+                    ],
</a><a href="#h10-0-261" id="h10-0-261" class="i">+                )?;
</a><a href="#h10-0-262" id="h10-0-262" class="i">+
</a><a href="#h10-0-263" id="h10-0-263" class="i">+                assert_scan(
</a><a href="#h10-0-264" id="h10-0-264" class="i">+                    s.scan_prefix(b&quot;b&quot;),
</a><a href="#h10-0-265" id="h10-0-265" class="i">+                    vec![
</a><a href="#h10-0-266" id="h10-0-266" class="i">+                        (b&quot;b&quot;, vec![2]),
</a><a href="#h10-0-267" id="h10-0-267" class="i">+                        (b&quot;ba&quot;, vec![2, 1]),
</a><a href="#h10-0-268" id="h10-0-268" class="i">+                        (b&quot;bb&quot;, vec![2, 2]),
</a><a href="#h10-0-269" id="h10-0-269" class="i">+                        (b&quot;b\xff&quot;, vec![2, 0xff]),
</a><a href="#h10-0-270" id="h10-0-270" class="i">+                        (b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00]),
</a><a href="#h10-0-271" id="h10-0-271" class="i">+                        (b&quot;b\xffb&quot;, vec![2, 0xff, 2]),
</a><a href="#h10-0-272" id="h10-0-272" class="i">+                        (b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff]),
</a><a href="#h10-0-273" id="h10-0-273" class="i">+                    ],
</a><a href="#h10-0-274" id="h10-0-274" class="i">+                )?;
</a><a href="#h10-0-275" id="h10-0-275" class="i">+
</a><a href="#h10-0-276" id="h10-0-276" class="i">+                assert_scan(s.scan_prefix(b&quot;bb&quot;), vec![(b&quot;bb&quot;, vec![2, 2])])?;
</a><a href="#h10-0-277" id="h10-0-277" class="i">+
</a><a href="#h10-0-278" id="h10-0-278" class="i">+                assert_scan(s.scan_prefix(b&quot;bq&quot;), vec![])?;
</a><a href="#h10-0-279" id="h10-0-279" class="i">+
</a><a href="#h10-0-280" id="h10-0-280" class="i">+                assert_scan(
</a><a href="#h10-0-281" id="h10-0-281" class="i">+                    s.scan_prefix(b&quot;b\xff&quot;),
</a><a href="#h10-0-282" id="h10-0-282" class="i">+                    vec![
</a><a href="#h10-0-283" id="h10-0-283" class="i">+                        (b&quot;b\xff&quot;, vec![2, 0xff]),
</a><a href="#h10-0-284" id="h10-0-284" class="i">+                        (b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00]),
</a><a href="#h10-0-285" id="h10-0-285" class="i">+                        (b&quot;b\xffb&quot;, vec![2, 0xff, 2]),
</a><a href="#h10-0-286" id="h10-0-286" class="i">+                        (b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff]),
</a><a href="#h10-0-287" id="h10-0-287" class="i">+                    ],
</a><a href="#h10-0-288" id="h10-0-288" class="i">+                )?;
</a><a href="#h10-0-289" id="h10-0-289" class="i">+
</a><a href="#h10-0-290" id="h10-0-290" class="i">+                assert_scan(
</a><a href="#h10-0-291" id="h10-0-291" class="i">+                    s.scan_prefix(b&quot;b\xff\x00&quot;),
</a><a href="#h10-0-292" id="h10-0-292" class="i">+                    vec![(b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00])],
</a><a href="#h10-0-293" id="h10-0-293" class="i">+                )?;
</a><a href="#h10-0-294" id="h10-0-294" class="i">+
</a><a href="#h10-0-295" id="h10-0-295" class="i">+                assert_scan(
</a><a href="#h10-0-296" id="h10-0-296" class="i">+                    s.scan_prefix(b&quot;b\xff\xff&quot;),
</a><a href="#h10-0-297" id="h10-0-297" class="i">+                    vec![(b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff])],
</a><a href="#h10-0-298" id="h10-0-298" class="i">+                )?;
</a><a href="#h10-0-299" id="h10-0-299" class="i">+
</a><a href="#h10-0-300" id="h10-0-300" class="i">+                assert_scan(
</a><a href="#h10-0-301" id="h10-0-301" class="i">+                    s.scan_prefix(b&quot;\xff&quot;),
</a><a href="#h10-0-302" id="h10-0-302" class="i">+                    vec![
</a><a href="#h10-0-303" id="h10-0-303" class="i">+                        (b&quot;\xff&quot;, vec![0xff]),
</a><a href="#h10-0-304" id="h10-0-304" class="i">+                        (b&quot;\xff\xff&quot;, vec![0xff, 0xff]),
</a><a href="#h10-0-305" id="h10-0-305" class="i">+                        (b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff]),
</a><a href="#h10-0-306" id="h10-0-306" class="i">+                        (b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff]),
</a><a href="#h10-0-307" id="h10-0-307" class="i">+                    ],
</a><a href="#h10-0-308" id="h10-0-308" class="i">+                )?;
</a><a href="#h10-0-309" id="h10-0-309" class="i">+
</a><a href="#h10-0-310" id="h10-0-310" class="i">+                assert_scan(
</a><a href="#h10-0-311" id="h10-0-311" class="i">+                    s.scan_prefix(b&quot;\xff\xff&quot;),
</a><a href="#h10-0-312" id="h10-0-312" class="i">+                    vec![
</a><a href="#h10-0-313" id="h10-0-313" class="i">+                        (b&quot;\xff\xff&quot;, vec![0xff, 0xff]),
</a><a href="#h10-0-314" id="h10-0-314" class="i">+                        (b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff]),
</a><a href="#h10-0-315" id="h10-0-315" class="i">+                        (b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff]),
</a><a href="#h10-0-316" id="h10-0-316" class="i">+                    ],
</a><a href="#h10-0-317" id="h10-0-317" class="i">+                )?;
</a><a href="#h10-0-318" id="h10-0-318" class="i">+
</a><a href="#h10-0-319" id="h10-0-319" class="i">+                assert_scan(
</a><a href="#h10-0-320" id="h10-0-320" class="i">+                    s.scan_prefix(b&quot;\xff\xff\xff&quot;),
</a><a href="#h10-0-321" id="h10-0-321" class="i">+                    vec![
</a><a href="#h10-0-322" id="h10-0-322" class="i">+                        (b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff]),
</a><a href="#h10-0-323" id="h10-0-323" class="i">+                        (b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff]),
</a><a href="#h10-0-324" id="h10-0-324" class="i">+                    ],
</a><a href="#h10-0-325" id="h10-0-325" class="i">+                )?;
</a><a href="#h10-0-326" id="h10-0-326" class="i">+
</a><a href="#h10-0-327" id="h10-0-327" class="i">+                assert_scan(
</a><a href="#h10-0-328" id="h10-0-328" class="i">+                    s.scan_prefix(b&quot;\xff\xff\xff\xff&quot;),
</a><a href="#h10-0-329" id="h10-0-329" class="i">+                    vec![(b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff])],
</a><a href="#h10-0-330" id="h10-0-330" class="i">+                )?;
</a><a href="#h10-0-331" id="h10-0-331" class="i">+
</a><a href="#h10-0-332" id="h10-0-332" class="i">+                assert_scan(s.scan_prefix(b&quot;\xff\xff\xff\xff\xff&quot;), vec![])?;
</a><a href="#h10-0-333" id="h10-0-333" class="i">+
</a><a href="#h10-0-334" id="h10-0-334" class="i">+                Ok(())
</a><a href="#h10-0-335" id="h10-0-335" class="i">+            }
</a><a href="#h10-0-336" id="h10-0-336" class="i">+
</a><a href="#h10-0-337" id="h10-0-337" class="i">+            #[test]
</a><a href="#h10-0-338" id="h10-0-338" class="i">+            /// Runs random operations both on a Engine and a known-good
</a><a href="#h10-0-339" id="h10-0-339" class="i">+            /// BTreeMap, comparing the results of each operation as well as the
</a><a href="#h10-0-340" id="h10-0-340" class="i">+            /// final state.
</a><a href="#h10-0-341" id="h10-0-341" class="i">+            fn random_ops() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-342" id="h10-0-342" class="i">+                const NUM_OPS: u64 = 1000;
</a><a href="#h10-0-343" id="h10-0-343" class="i">+
</a><a href="#h10-0-344" id="h10-0-344" class="i">+                use rand::{seq::SliceRandom, Rng, RngCore};
</a><a href="#h10-0-345" id="h10-0-345" class="i">+                let seed: u64 = rand::thread_rng().gen();
</a><a href="#h10-0-346" id="h10-0-346" class="i">+                let mut rng: rand::rngs::StdRng = rand::SeedableRng::seed_from_u64(seed);
</a><a href="#h10-0-347" id="h10-0-347" class="i">+                println!(&quot;seed = {}&quot;, seed);
</a><a href="#h10-0-348" id="h10-0-348" class="i">+
</a><a href="#h10-0-349" id="h10-0-349" class="i">+                #[derive(Debug)]
</a><a href="#h10-0-350" id="h10-0-350" class="i">+                enum Op {
</a><a href="#h10-0-351" id="h10-0-351" class="i">+                    Set,
</a><a href="#h10-0-352" id="h10-0-352" class="i">+                    Delete,
</a><a href="#h10-0-353" id="h10-0-353" class="i">+                    Get,
</a><a href="#h10-0-354" id="h10-0-354" class="i">+                    Scan,
</a><a href="#h10-0-355" id="h10-0-355" class="i">+                }
</a><a href="#h10-0-356" id="h10-0-356" class="i">+
</a><a href="#h10-0-357" id="h10-0-357" class="i">+                impl rand::distributions::Distribution&lt;Op&gt; for rand::distributions::Standard {
</a><a href="#h10-0-358" id="h10-0-358" class="i">+                    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; Op {
</a><a href="#h10-0-359" id="h10-0-359" class="i">+                        match rng.gen_range(0..=3) {
</a><a href="#h10-0-360" id="h10-0-360" class="i">+                            0 =&gt; Op::Set,
</a><a href="#h10-0-361" id="h10-0-361" class="i">+                            1 =&gt; Op::Delete,
</a><a href="#h10-0-362" id="h10-0-362" class="i">+                            2 =&gt; Op::Get,
</a><a href="#h10-0-363" id="h10-0-363" class="i">+                            3 =&gt; Op::Scan,
</a><a href="#h10-0-364" id="h10-0-364" class="i">+                            _ =&gt; panic!(&quot;unexpected value&quot;),
</a><a href="#h10-0-365" id="h10-0-365" class="i">+                        }
</a><a href="#h10-0-366" id="h10-0-366" class="i">+                    }
</a><a href="#h10-0-367" id="h10-0-367" class="i">+                }
</a><a href="#h10-0-368" id="h10-0-368" class="i">+
</a><a href="#h10-0-369" id="h10-0-369" class="i">+                let mut s = $setup;
</a><a href="#h10-0-370" id="h10-0-370" class="i">+                let mut keys: Vec&lt;Vec&lt;u8&gt;&gt; = Vec::new();
</a><a href="#h10-0-371" id="h10-0-371" class="i">+                let mut m = std::collections::BTreeMap::new();
</a><a href="#h10-0-372" id="h10-0-372" class="i">+
</a><a href="#h10-0-373" id="h10-0-373" class="i">+                // Pick an already-used key with 80% probability, or generate a
</a><a href="#h10-0-374" id="h10-0-374" class="i">+                // new key.
</a><a href="#h10-0-375" id="h10-0-375" class="i">+                let mut random_key = |mut rng: &amp;mut rand::rngs::StdRng| -&gt; Vec&lt;u8&gt; {
</a><a href="#h10-0-376" id="h10-0-376" class="i">+                    if rng.gen::&lt;f64&gt;() &lt; 0.8 &amp;&amp; !keys.is_empty() {
</a><a href="#h10-0-377" id="h10-0-377" class="i">+                        keys.choose(&amp;mut rng).unwrap().clone()
</a><a href="#h10-0-378" id="h10-0-378" class="i">+                    } else {
</a><a href="#h10-0-379" id="h10-0-379" class="i">+                        let mut key = vec![0; rng.gen_range(0..=16)];
</a><a href="#h10-0-380" id="h10-0-380" class="i">+                        rng.fill_bytes(&amp;mut key);
</a><a href="#h10-0-381" id="h10-0-381" class="i">+                        keys.push(key.clone());
</a><a href="#h10-0-382" id="h10-0-382" class="i">+                        key
</a><a href="#h10-0-383" id="h10-0-383" class="i">+                    }
</a><a href="#h10-0-384" id="h10-0-384" class="i">+                };
</a><a href="#h10-0-385" id="h10-0-385" class="i">+
</a><a href="#h10-0-386" id="h10-0-386" class="i">+                let random_value = |rng: &amp;mut rand::rngs::StdRng| -&gt; Vec&lt;u8&gt; {
</a><a href="#h10-0-387" id="h10-0-387" class="i">+                    let mut value = vec![0; rng.gen_range(0..=16)];
</a><a href="#h10-0-388" id="h10-0-388" class="i">+                    rng.fill_bytes(&amp;mut value);
</a><a href="#h10-0-389" id="h10-0-389" class="i">+                    value
</a><a href="#h10-0-390" id="h10-0-390" class="i">+                };
</a><a href="#h10-0-391" id="h10-0-391" class="i">+
</a><a href="#h10-0-392" id="h10-0-392" class="i">+                // Run random operations.
</a><a href="#h10-0-393" id="h10-0-393" class="i">+                for _ in 0..NUM_OPS {
</a><a href="#h10-0-394" id="h10-0-394" class="i">+                    match rng.gen::&lt;Op&gt;() {
</a><a href="#h10-0-395" id="h10-0-395" class="i">+                        Op::Set =&gt; {
</a><a href="#h10-0-396" id="h10-0-396" class="i">+                            let key = random_key(&amp;mut rng);
</a><a href="#h10-0-397" id="h10-0-397" class="i">+                            let value = random_value(&amp;mut rng);
</a><a href="#h10-0-398" id="h10-0-398" class="i">+                            println!(&quot;set {:?} = {:?}&quot;, key, value);
</a><a href="#h10-0-399" id="h10-0-399" class="i">+                            s.set(&amp;key, value.clone())?;
</a><a href="#h10-0-400" id="h10-0-400" class="i">+                            m.insert(key, value);
</a><a href="#h10-0-401" id="h10-0-401" class="i">+                        }
</a><a href="#h10-0-402" id="h10-0-402" class="i">+                        Op::Delete =&gt; {
</a><a href="#h10-0-403" id="h10-0-403" class="i">+                            let key = random_key(&amp;mut rng);
</a><a href="#h10-0-404" id="h10-0-404" class="i">+                            println!(&quot;delete {:?}&quot;, key);
</a><a href="#h10-0-405" id="h10-0-405" class="i">+                            s.delete(&amp;key)?;
</a><a href="#h10-0-406" id="h10-0-406" class="i">+                            m.remove(&amp;key);
</a><a href="#h10-0-407" id="h10-0-407" class="i">+                        }
</a><a href="#h10-0-408" id="h10-0-408" class="i">+                        Op::Get =&gt; {
</a><a href="#h10-0-409" id="h10-0-409" class="i">+                            let key = random_key(&amp;mut rng);
</a><a href="#h10-0-410" id="h10-0-410" class="i">+                            let value = s.get(&amp;key)?;
</a><a href="#h10-0-411" id="h10-0-411" class="i">+                            let expect = m.get(&amp;key).cloned();
</a><a href="#h10-0-412" id="h10-0-412" class="i">+                            println!(&quot;get {:?} =&gt; {:?}&quot;, key, value);
</a><a href="#h10-0-413" id="h10-0-413" class="i">+                            assert_eq!(value, expect);
</a><a href="#h10-0-414" id="h10-0-414" class="i">+                        }
</a><a href="#h10-0-415" id="h10-0-415" class="i">+                        Op::Scan =&gt; {
</a><a href="#h10-0-416" id="h10-0-416" class="i">+                            let mut from = random_key(&amp;mut rng);
</a><a href="#h10-0-417" id="h10-0-417" class="i">+                            let mut to = random_key(&amp;mut rng);
</a><a href="#h10-0-418" id="h10-0-418" class="i">+                            if (to &lt; from) {
</a><a href="#h10-0-419" id="h10-0-419" class="i">+                                (from, to) = (to, from)
</a><a href="#h10-0-420" id="h10-0-420" class="i">+                            }
</a><a href="#h10-0-421" id="h10-0-421" class="i">+                            println!(&quot;scan {:?} .. {:?}&quot;, from, to);
</a><a href="#h10-0-422" id="h10-0-422" class="i">+                            let result =
</a><a href="#h10-0-423" id="h10-0-423" class="i">+                                s.scan(from.clone()..to.clone()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h10-0-424" id="h10-0-424" class="i">+                            let expect = m
</a><a href="#h10-0-425" id="h10-0-425" class="i">+                                .range(from..to)
</a><a href="#h10-0-426" id="h10-0-426" class="i">+                                .map(|(k, v)| (k.clone(), v.clone()))
</a><a href="#h10-0-427" id="h10-0-427" class="i">+                                .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h10-0-428" id="h10-0-428" class="i">+                            assert_eq!(result, expect);
</a><a href="#h10-0-429" id="h10-0-429" class="i">+                        }
</a><a href="#h10-0-430" id="h10-0-430" class="i">+                    }
</a><a href="#h10-0-431" id="h10-0-431" class="i">+                }
</a><a href="#h10-0-432" id="h10-0-432" class="i">+
</a><a href="#h10-0-433" id="h10-0-433" class="i">+                // Compare the final states.
</a><a href="#h10-0-434" id="h10-0-434" class="i">+                println!(&quot;comparing final state&quot;);
</a><a href="#h10-0-435" id="h10-0-435" class="i">+
</a><a href="#h10-0-436" id="h10-0-436" class="i">+                let state = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h10-0-437" id="h10-0-437" class="i">+                let expect = m
</a><a href="#h10-0-438" id="h10-0-438" class="i">+                    .range::&lt;Vec&lt;u8&gt;, _&gt;(..)
</a><a href="#h10-0-439" id="h10-0-439" class="i">+                    .map(|(k, v)| (k.clone(), v.clone()))
</a><a href="#h10-0-440" id="h10-0-440" class="i">+                    .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h10-0-441" id="h10-0-441" class="i">+                assert_eq!(state, expect);
</a><a href="#h10-0-442" id="h10-0-442" class="i">+
</a><a href="#h10-0-443" id="h10-0-443" class="i">+                Ok(())
</a><a href="#h10-0-444" id="h10-0-444" class="i">+            }
</a><a href="#h10-0-445" id="h10-0-445" class="i">+
</a><a href="#h10-0-446" id="h10-0-446" class="i">+            #[test]
</a><a href="#h10-0-447" id="h10-0-447" class="i">+            /// Tests implementation-independent aspects of Status.
</a><a href="#h10-0-448" id="h10-0-448" class="i">+            fn status() -&gt; Result&lt;()&gt; {
</a><a href="#h10-0-449" id="h10-0-449" class="i">+                let mut s = $setup;
</a><a href="#h10-0-450" id="h10-0-450" class="i">+                s.set(b&quot;foo&quot;, vec![1, 2, 3])?;
</a><a href="#h10-0-451" id="h10-0-451" class="i">+                s.set(b&quot;bar&quot;, vec![1])?;
</a><a href="#h10-0-452" id="h10-0-452" class="i">+                s.delete(b&quot;bar&quot;)?;
</a><a href="#h10-0-453" id="h10-0-453" class="i">+                s.set(b&quot;baz&quot;, vec![1])?;
</a><a href="#h10-0-454" id="h10-0-454" class="i">+                s.set(b&quot;baz&quot;, vec![2])?;
</a><a href="#h10-0-455" id="h10-0-455" class="i">+                s.set(b&quot;baz&quot;, vec![3])?;
</a><a href="#h10-0-456" id="h10-0-456" class="i">+                s.delete(b&quot;qux&quot;)?;
</a><a href="#h10-0-457" id="h10-0-457" class="i">+
</a><a href="#h10-0-458" id="h10-0-458" class="i">+                let status = s.status()?;
</a><a href="#h10-0-459" id="h10-0-459" class="i">+                assert!(status.name.len() &gt; 0);
</a><a href="#h10-0-460" id="h10-0-460" class="i">+                assert_eq!(status.keys, 2);
</a><a href="#h10-0-461" id="h10-0-461" class="i">+                assert_eq!(status.size, 10);
</a><a href="#h10-0-462" id="h10-0-462" class="i">+
</a><a href="#h10-0-463" id="h10-0-463" class="i">+                Ok(())
</a><a href="#h10-0-464" id="h10-0-464" class="i">+            }
</a><a href="#h10-0-465" id="h10-0-465" class="i">+        };
</a><a href="#h10-0-466" id="h10-0-466" class="i">+    }
</a><a href="#h10-0-467" id="h10-0-467" class="i">+
</a><a href="#h10-0-468" id="h10-0-468" class="i">+    pub(crate) use test_engine; // export for use in submodules
</a><a href="#h10-0-469" id="h10-0-469" class="i">+}
</a><b>diff --git a/<a id="h11" href="../file/src/storage/engine/bitcask.rs.html">src/storage/engine/bitcask.rs</a> b/<a href="../file/src/storage/engine/bitcask.rs.html">src/storage/engine/bitcask.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -1,671 +0,0 @@
</a><a href="#h11-0-0" id="h11-0-0" class="d">-use super::{Engine, Status};
</a><a href="#h11-0-1" id="h11-0-1" class="d">-use crate::error::Result;
</a><a href="#h11-0-2" id="h11-0-2" class="d">-
</a><a href="#h11-0-3" id="h11-0-3" class="d">-use fs4::FileExt;
</a><a href="#h11-0-4" id="h11-0-4" class="d">-use std::io::{BufReader, BufWriter, Read, Seek, SeekFrom, Write};
</a><a href="#h11-0-5" id="h11-0-5" class="d">-use std::path::PathBuf;
</a><a href="#h11-0-6" id="h11-0-6" class="d">-
</a><a href="#h11-0-7" id="h11-0-7" class="d">-/// A very simple variant of BitCask, itself a very simple log-structured
</a><a href="#h11-0-8" id="h11-0-8" class="d">-/// key-value engine used e.g. by the Riak database. It is not compatible with
</a><a href="#h11-0-9" id="h11-0-9" class="d">-/// BitCask databases generated by other implementations. See:
</a><a href="#h11-0-10" id="h11-0-10" class="d">-/// https://riak.com/assets/bitcask-intro.pdf
</a><a href="#h11-0-11" id="h11-0-11" class="d">-///
</a><a href="#h11-0-12" id="h11-0-12" class="d">-/// BitCask writes key-value pairs to an append-only log file, and keeps a
</a><a href="#h11-0-13" id="h11-0-13" class="d">-/// mapping of keys to file positions in memory. All live keys must fit in
</a><a href="#h11-0-14" id="h11-0-14" class="d">-/// memory. Deletes write a tombstone value to the log file. To remove old
</a><a href="#h11-0-15" id="h11-0-15" class="d">-/// garbage, logs can be compacted by writing new logs containing only live
</a><a href="#h11-0-16" id="h11-0-16" class="d">-/// data, skipping replaced values and tombstones.
</a><a href="#h11-0-17" id="h11-0-17" class="d">-///
</a><a href="#h11-0-18" id="h11-0-18" class="d">-/// This implementation makes several significant simplifications over
</a><a href="#h11-0-19" id="h11-0-19" class="d">-/// standard BitCask:
</a><a href="#h11-0-20" id="h11-0-20" class="d">-///
</a><a href="#h11-0-21" id="h11-0-21" class="d">-/// - Instead of writing multiple fixed-size log files, it uses a single
</a><a href="#h11-0-22" id="h11-0-22" class="d">-///   append-only log file of arbitrary size. This increases the compaction
</a><a href="#h11-0-23" id="h11-0-23" class="d">-///   volume, since the entire log file must be rewritten on every compaction,
</a><a href="#h11-0-24" id="h11-0-24" class="d">-///   and can exceed the filesystem&#39;s file size limit, but ToyDB databases are
</a><a href="#h11-0-25" id="h11-0-25" class="d">-///   expected to be small.
</a><a href="#h11-0-26" id="h11-0-26" class="d">-///
</a><a href="#h11-0-27" id="h11-0-27" class="d">-/// - Compactions lock the database for reads and writes. This is ok since ToyDB
</a><a href="#h11-0-28" id="h11-0-28" class="d">-///   only compacts during node startup and files are expected to be small.
</a><a href="#h11-0-29" id="h11-0-29" class="d">-///
</a><a href="#h11-0-30" id="h11-0-30" class="d">-/// - Hint files are not used, the log itself is scanned when opened to
</a><a href="#h11-0-31" id="h11-0-31" class="d">-///   build the keydir. Hint files only omit values, and ToyDB values are
</a><a href="#h11-0-32" id="h11-0-32" class="d">-///   expected to be small, so the hint files would be nearly as large as
</a><a href="#h11-0-33" id="h11-0-33" class="d">-///   the compacted log files themselves.
</a><a href="#h11-0-34" id="h11-0-34" class="d">-///
</a><a href="#h11-0-35" id="h11-0-35" class="d">-/// - Log entries don&#39;t contain timestamps or checksums.
</a><a href="#h11-0-36" id="h11-0-36" class="d">-///
</a><a href="#h11-0-37" id="h11-0-37" class="d">-/// The structure of a log entry is:
</a><a href="#h11-0-38" id="h11-0-38" class="d">-///
</a><a href="#h11-0-39" id="h11-0-39" class="d">-/// - Key length as big-endian u32.
</a><a href="#h11-0-40" id="h11-0-40" class="d">-/// - Value length as big-endian i32, or -1 for tombstones.
</a><a href="#h11-0-41" id="h11-0-41" class="d">-/// - Key as raw bytes (max 2 GB).
</a><a href="#h11-0-42" id="h11-0-42" class="d">-/// - Value as raw bytes (max 2 GB).
</a><a href="#h11-0-43" id="h11-0-43" class="d">-pub struct BitCask {
</a><a href="#h11-0-44" id="h11-0-44" class="d">-    /// The active append-only log file.
</a><a href="#h11-0-45" id="h11-0-45" class="d">-    log: Log,
</a><a href="#h11-0-46" id="h11-0-46" class="d">-    /// Maps keys to a value position and length in the log file.
</a><a href="#h11-0-47" id="h11-0-47" class="d">-    keydir: KeyDir,
</a><a href="#h11-0-48" id="h11-0-48" class="d">-}
</a><a href="#h11-0-49" id="h11-0-49" class="d">-
</a><a href="#h11-0-50" id="h11-0-50" class="d">-/// Maps keys to a value position and length in the log file.
</a><a href="#h11-0-51" id="h11-0-51" class="d">-type KeyDir = std::collections::BTreeMap&lt;Vec&lt;u8&gt;, (u64, u32)&gt;;
</a><a href="#h11-0-52" id="h11-0-52" class="d">-
</a><a href="#h11-0-53" id="h11-0-53" class="d">-impl BitCask {
</a><a href="#h11-0-54" id="h11-0-54" class="d">-    /// Opens or creates a BitCask database in the given file.
</a><a href="#h11-0-55" id="h11-0-55" class="d">-    pub fn new(path: PathBuf) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-0-56" id="h11-0-56" class="d">-        log::info!(&quot;Opening database {}&quot;, path.display());
</a><a href="#h11-0-57" id="h11-0-57" class="d">-        let mut log = Log::new(path.clone())?;
</a><a href="#h11-0-58" id="h11-0-58" class="d">-        let keydir = log.build_keydir()?;
</a><a href="#h11-0-59" id="h11-0-59" class="d">-        log::info!(&quot;Indexed {} live keys in {}&quot;, keydir.len(), path.display());
</a><a href="#h11-0-60" id="h11-0-60" class="d">-        Ok(Self { log, keydir })
</a><a href="#h11-0-61" id="h11-0-61" class="d">-    }
</a><a href="#h11-0-62" id="h11-0-62" class="d">-
</a><a href="#h11-0-63" id="h11-0-63" class="d">-    /// Opens a BitCask database, and automatically compacts it if the amount
</a><a href="#h11-0-64" id="h11-0-64" class="d">-    /// of garbage exceeds the given ratio and byte size when opened.
</a><a href="#h11-0-65" id="h11-0-65" class="d">-    pub fn new_compact(
</a><a href="#h11-0-66" id="h11-0-66" class="d">-        path: PathBuf,
</a><a href="#h11-0-67" id="h11-0-67" class="d">-        garbage_min_ratio: f64,
</a><a href="#h11-0-68" id="h11-0-68" class="d">-        garbage_min_bytes: u64,
</a><a href="#h11-0-69" id="h11-0-69" class="d">-    ) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-0-70" id="h11-0-70" class="d">-        let mut s = Self::new(path)?;
</a><a href="#h11-0-71" id="h11-0-71" class="d">-
</a><a href="#h11-0-72" id="h11-0-72" class="d">-        let status = s.status()?;
</a><a href="#h11-0-73" id="h11-0-73" class="d">-        let garbage_ratio = status.garbage_disk_size as f64 / status.total_disk_size as f64;
</a><a href="#h11-0-74" id="h11-0-74" class="d">-        if status.garbage_disk_size &gt; 0
</a><a href="#h11-0-75" id="h11-0-75" class="d">-            &amp;&amp; status.garbage_disk_size &gt;= garbage_min_bytes
</a><a href="#h11-0-76" id="h11-0-76" class="d">-            &amp;&amp; garbage_ratio &gt;= garbage_min_ratio
</a><a href="#h11-0-77" id="h11-0-77" class="d">-        {
</a><a href="#h11-0-78" id="h11-0-78" class="d">-            log::info!(
</a><a href="#h11-0-79" id="h11-0-79" class="d">-                &quot;Compacting {} to remove {:.0}% garbage ({} MB out of {} MB)&quot;,
</a><a href="#h11-0-80" id="h11-0-80" class="d">-                s.log.path.display(),
</a><a href="#h11-0-81" id="h11-0-81" class="d">-                garbage_ratio * 100.0,
</a><a href="#h11-0-82" id="h11-0-82" class="d">-                status.garbage_disk_size / 1024 / 1024,
</a><a href="#h11-0-83" id="h11-0-83" class="d">-                status.total_disk_size / 1024 / 1024
</a><a href="#h11-0-84" id="h11-0-84" class="d">-            );
</a><a href="#h11-0-85" id="h11-0-85" class="d">-            s.compact()?;
</a><a href="#h11-0-86" id="h11-0-86" class="d">-            log::info!(
</a><a href="#h11-0-87" id="h11-0-87" class="d">-                &quot;Compacted {} to size {} MB&quot;,
</a><a href="#h11-0-88" id="h11-0-88" class="d">-                s.log.path.display(),
</a><a href="#h11-0-89" id="h11-0-89" class="d">-                (status.total_disk_size - status.garbage_disk_size) / 1024 / 1024
</a><a href="#h11-0-90" id="h11-0-90" class="d">-            );
</a><a href="#h11-0-91" id="h11-0-91" class="d">-        }
</a><a href="#h11-0-92" id="h11-0-92" class="d">-
</a><a href="#h11-0-93" id="h11-0-93" class="d">-        Ok(s)
</a><a href="#h11-0-94" id="h11-0-94" class="d">-    }
</a><a href="#h11-0-95" id="h11-0-95" class="d">-}
</a><a href="#h11-0-96" id="h11-0-96" class="d">-
</a><a href="#h11-0-97" id="h11-0-97" class="d">-impl std::fmt::Display for BitCask {
</a><a href="#h11-0-98" id="h11-0-98" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h11-0-99" id="h11-0-99" class="d">-        write!(f, &quot;bitcask&quot;)
</a><a href="#h11-0-100" id="h11-0-100" class="d">-    }
</a><a href="#h11-0-101" id="h11-0-101" class="d">-}
</a><a href="#h11-0-102" id="h11-0-102" class="d">-
</a><a href="#h11-0-103" id="h11-0-103" class="d">-impl Engine for BitCask {
</a><a href="#h11-0-104" id="h11-0-104" class="d">-    type ScanIterator&lt;&#39;a&gt; = ScanIterator&lt;&#39;a&gt;;
</a><a href="#h11-0-105" id="h11-0-105" class="d">-
</a><a href="#h11-0-106" id="h11-0-106" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-107" id="h11-0-107" class="d">-        self.log.write_entry(key, None)?;
</a><a href="#h11-0-108" id="h11-0-108" class="d">-        self.keydir.remove(key);
</a><a href="#h11-0-109" id="h11-0-109" class="d">-        Ok(())
</a><a href="#h11-0-110" id="h11-0-110" class="d">-    }
</a><a href="#h11-0-111" id="h11-0-111" class="d">-
</a><a href="#h11-0-112" id="h11-0-112" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-113" id="h11-0-113" class="d">-        Ok(self.log.file.sync_all()?)
</a><a href="#h11-0-114" id="h11-0-114" class="d">-    }
</a><a href="#h11-0-115" id="h11-0-115" class="d">-
</a><a href="#h11-0-116" id="h11-0-116" class="d">-    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h11-0-117" id="h11-0-117" class="d">-        if let Some((value_pos, value_len)) = self.keydir.get(key) {
</a><a href="#h11-0-118" id="h11-0-118" class="d">-            Ok(Some(self.log.read_value(*value_pos, *value_len)?))
</a><a href="#h11-0-119" id="h11-0-119" class="d">-        } else {
</a><a href="#h11-0-120" id="h11-0-120" class="d">-            Ok(None)
</a><a href="#h11-0-121" id="h11-0-121" class="d">-        }
</a><a href="#h11-0-122" id="h11-0-122" class="d">-    }
</a><a href="#h11-0-123" id="h11-0-123" class="d">-
</a><a href="#h11-0-124" id="h11-0-124" class="d">-    fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h11-0-125" id="h11-0-125" class="d">-        ScanIterator { inner: self.keydir.range(range), log: &amp;mut self.log }
</a><a href="#h11-0-126" id="h11-0-126" class="d">-    }
</a><a href="#h11-0-127" id="h11-0-127" class="d">-
</a><a href="#h11-0-128" id="h11-0-128" class="d">-    fn scan_dyn(
</a><a href="#h11-0-129" id="h11-0-129" class="d">-        &amp;mut self,
</a><a href="#h11-0-130" id="h11-0-130" class="d">-        range: (std::ops::Bound&lt;Vec&lt;u8&gt;&gt;, std::ops::Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h11-0-131" id="h11-0-131" class="d">-    ) -&gt; Box&lt;dyn super::ScanIterator + &#39;_&gt; {
</a><a href="#h11-0-132" id="h11-0-132" class="d">-        Box::new(self.scan(range))
</a><a href="#h11-0-133" id="h11-0-133" class="d">-    }
</a><a href="#h11-0-134" id="h11-0-134" class="d">-
</a><a href="#h11-0-135" id="h11-0-135" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-136" id="h11-0-136" class="d">-        let (pos, len) = self.log.write_entry(key, Some(&amp;*value))?;
</a><a href="#h11-0-137" id="h11-0-137" class="d">-        let value_len = value.len() as u32;
</a><a href="#h11-0-138" id="h11-0-138" class="d">-        self.keydir.insert(key.to_vec(), (pos + len as u64 - value_len as u64, value_len));
</a><a href="#h11-0-139" id="h11-0-139" class="d">-        Ok(())
</a><a href="#h11-0-140" id="h11-0-140" class="d">-    }
</a><a href="#h11-0-141" id="h11-0-141" class="d">-
</a><a href="#h11-0-142" id="h11-0-142" class="d">-    fn status(&amp;mut self) -&gt; Result&lt;Status&gt; {
</a><a href="#h11-0-143" id="h11-0-143" class="d">-        let keys = self.keydir.len() as u64;
</a><a href="#h11-0-144" id="h11-0-144" class="d">-        let size = self
</a><a href="#h11-0-145" id="h11-0-145" class="d">-            .keydir
</a><a href="#h11-0-146" id="h11-0-146" class="d">-            .iter()
</a><a href="#h11-0-147" id="h11-0-147" class="d">-            .fold(0, |size, (key, (_, value_len))| size + key.len() as u64 + *value_len as u64);
</a><a href="#h11-0-148" id="h11-0-148" class="d">-        let total_disk_size = self.log.file.metadata()?.len();
</a><a href="#h11-0-149" id="h11-0-149" class="d">-        let live_disk_size = size + 8 * keys; // account for length prefixes
</a><a href="#h11-0-150" id="h11-0-150" class="d">-        let garbage_disk_size = total_disk_size - live_disk_size;
</a><a href="#h11-0-151" id="h11-0-151" class="d">-        Ok(Status {
</a><a href="#h11-0-152" id="h11-0-152" class="d">-            name: self.to_string(),
</a><a href="#h11-0-153" id="h11-0-153" class="d">-            keys,
</a><a href="#h11-0-154" id="h11-0-154" class="d">-            size,
</a><a href="#h11-0-155" id="h11-0-155" class="d">-            total_disk_size,
</a><a href="#h11-0-156" id="h11-0-156" class="d">-            live_disk_size,
</a><a href="#h11-0-157" id="h11-0-157" class="d">-            garbage_disk_size,
</a><a href="#h11-0-158" id="h11-0-158" class="d">-        })
</a><a href="#h11-0-159" id="h11-0-159" class="d">-    }
</a><a href="#h11-0-160" id="h11-0-160" class="d">-}
</a><a href="#h11-0-161" id="h11-0-161" class="d">-
</a><a href="#h11-0-162" id="h11-0-162" class="d">-pub struct ScanIterator&lt;&#39;a&gt; {
</a><a href="#h11-0-163" id="h11-0-163" class="d">-    inner: std::collections::btree_map::Range&lt;&#39;a, Vec&lt;u8&gt;, (u64, u32)&gt;,
</a><a href="#h11-0-164" id="h11-0-164" class="d">-    log: &amp;&#39;a mut Log,
</a><a href="#h11-0-165" id="h11-0-165" class="d">-}
</a><a href="#h11-0-166" id="h11-0-166" class="d">-
</a><a href="#h11-0-167" id="h11-0-167" class="d">-impl&lt;&#39;a&gt; ScanIterator&lt;&#39;a&gt; {
</a><a href="#h11-0-168" id="h11-0-168" class="d">-    fn map(&amp;mut self, item: (&amp;Vec&lt;u8&gt;, &amp;(u64, u32))) -&gt; &lt;Self as Iterator&gt;::Item {
</a><a href="#h11-0-169" id="h11-0-169" class="d">-        let (key, (value_pos, value_len)) = item;
</a><a href="#h11-0-170" id="h11-0-170" class="d">-        Ok((key.clone(), self.log.read_value(*value_pos, *value_len)?))
</a><a href="#h11-0-171" id="h11-0-171" class="d">-    }
</a><a href="#h11-0-172" id="h11-0-172" class="d">-}
</a><a href="#h11-0-173" id="h11-0-173" class="d">-
</a><a href="#h11-0-174" id="h11-0-174" class="d">-impl&lt;&#39;a&gt; Iterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h11-0-175" id="h11-0-175" class="d">-    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a><a href="#h11-0-176" id="h11-0-176" class="d">-
</a><a href="#h11-0-177" id="h11-0-177" class="d">-    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h11-0-178" id="h11-0-178" class="d">-        self.inner.next().map(|item| self.map(item))
</a><a href="#h11-0-179" id="h11-0-179" class="d">-    }
</a><a href="#h11-0-180" id="h11-0-180" class="d">-}
</a><a href="#h11-0-181" id="h11-0-181" class="d">-
</a><a href="#h11-0-182" id="h11-0-182" class="d">-impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h11-0-183" id="h11-0-183" class="d">-    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h11-0-184" id="h11-0-184" class="d">-        self.inner.next_back().map(|item| self.map(item))
</a><a href="#h11-0-185" id="h11-0-185" class="d">-    }
</a><a href="#h11-0-186" id="h11-0-186" class="d">-}
</a><a href="#h11-0-187" id="h11-0-187" class="d">-
</a><a href="#h11-0-188" id="h11-0-188" class="d">-impl BitCask {
</a><a href="#h11-0-189" id="h11-0-189" class="d">-    /// Compacts the current log file by writing out a new log file containing
</a><a href="#h11-0-190" id="h11-0-190" class="d">-    /// only live keys and replacing the current file with it.
</a><a href="#h11-0-191" id="h11-0-191" class="d">-    pub fn compact(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-192" id="h11-0-192" class="d">-        let mut tmp_path = self.log.path.clone();
</a><a href="#h11-0-193" id="h11-0-193" class="d">-        tmp_path.set_extension(&quot;new&quot;);
</a><a href="#h11-0-194" id="h11-0-194" class="d">-        let (mut new_log, new_keydir) = self.write_log(tmp_path)?;
</a><a href="#h11-0-195" id="h11-0-195" class="d">-
</a><a href="#h11-0-196" id="h11-0-196" class="d">-        std::fs::rename(&amp;new_log.path, &amp;self.log.path)?;
</a><a href="#h11-0-197" id="h11-0-197" class="d">-        new_log.path = self.log.path.clone();
</a><a href="#h11-0-198" id="h11-0-198" class="d">-
</a><a href="#h11-0-199" id="h11-0-199" class="d">-        self.log = new_log;
</a><a href="#h11-0-200" id="h11-0-200" class="d">-        self.keydir = new_keydir;
</a><a href="#h11-0-201" id="h11-0-201" class="d">-        Ok(())
</a><a href="#h11-0-202" id="h11-0-202" class="d">-    }
</a><a href="#h11-0-203" id="h11-0-203" class="d">-
</a><a href="#h11-0-204" id="h11-0-204" class="d">-    /// Writes out a new log file with the live entries of the current log file
</a><a href="#h11-0-205" id="h11-0-205" class="d">-    /// and returns it along with its keydir. Entries are written in key order.
</a><a href="#h11-0-206" id="h11-0-206" class="d">-    fn write_log(&amp;mut self, path: PathBuf) -&gt; Result&lt;(Log, KeyDir)&gt; {
</a><a href="#h11-0-207" id="h11-0-207" class="d">-        let mut new_keydir = KeyDir::new();
</a><a href="#h11-0-208" id="h11-0-208" class="d">-        let mut new_log = Log::new(path)?;
</a><a href="#h11-0-209" id="h11-0-209" class="d">-        new_log.file.set_len(0)?; // truncate file if it exists
</a><a href="#h11-0-210" id="h11-0-210" class="d">-        for (key, (value_pos, value_len)) in self.keydir.iter() {
</a><a href="#h11-0-211" id="h11-0-211" class="d">-            let value = self.log.read_value(*value_pos, *value_len)?;
</a><a href="#h11-0-212" id="h11-0-212" class="d">-            let (pos, len) = new_log.write_entry(key, Some(&amp;value))?;
</a><a href="#h11-0-213" id="h11-0-213" class="d">-            new_keydir.insert(key.clone(), (pos + len as u64 - *value_len as u64, *value_len));
</a><a href="#h11-0-214" id="h11-0-214" class="d">-        }
</a><a href="#h11-0-215" id="h11-0-215" class="d">-        Ok((new_log, new_keydir))
</a><a href="#h11-0-216" id="h11-0-216" class="d">-    }
</a><a href="#h11-0-217" id="h11-0-217" class="d">-}
</a><a href="#h11-0-218" id="h11-0-218" class="d">-
</a><a href="#h11-0-219" id="h11-0-219" class="d">-/// Attempt to flush the file when the database is closed.
</a><a href="#h11-0-220" id="h11-0-220" class="d">-impl Drop for BitCask {
</a><a href="#h11-0-221" id="h11-0-221" class="d">-    fn drop(&amp;mut self) {
</a><a href="#h11-0-222" id="h11-0-222" class="d">-        if let Err(error) = self.flush() {
</a><a href="#h11-0-223" id="h11-0-223" class="d">-            log::error!(&quot;failed to flush file: {}&quot;, error)
</a><a href="#h11-0-224" id="h11-0-224" class="d">-        }
</a><a href="#h11-0-225" id="h11-0-225" class="d">-    }
</a><a href="#h11-0-226" id="h11-0-226" class="d">-}
</a><a href="#h11-0-227" id="h11-0-227" class="d">-
</a><a href="#h11-0-228" id="h11-0-228" class="d">-/// A BitCask append-only log file, containing a sequence of key/value
</a><a href="#h11-0-229" id="h11-0-229" class="d">-/// entries encoded as follows;
</a><a href="#h11-0-230" id="h11-0-230" class="d">-///
</a><a href="#h11-0-231" id="h11-0-231" class="d">-/// - Key length as big-endian u32.
</a><a href="#h11-0-232" id="h11-0-232" class="d">-/// - Value length as big-endian i32, or -1 for tombstones.
</a><a href="#h11-0-233" id="h11-0-233" class="d">-/// - Key as raw bytes (max 2 GB).
</a><a href="#h11-0-234" id="h11-0-234" class="d">-/// - Value as raw bytes (max 2 GB).
</a><a href="#h11-0-235" id="h11-0-235" class="d">-struct Log {
</a><a href="#h11-0-236" id="h11-0-236" class="d">-    /// Path to the log file.
</a><a href="#h11-0-237" id="h11-0-237" class="d">-    path: PathBuf,
</a><a href="#h11-0-238" id="h11-0-238" class="d">-    /// The opened file containing the log.
</a><a href="#h11-0-239" id="h11-0-239" class="d">-    file: std::fs::File,
</a><a href="#h11-0-240" id="h11-0-240" class="d">-}
</a><a href="#h11-0-241" id="h11-0-241" class="d">-
</a><a href="#h11-0-242" id="h11-0-242" class="d">-impl Log {
</a><a href="#h11-0-243" id="h11-0-243" class="d">-    /// Opens a log file, or creates one if it does not exist. Takes out an
</a><a href="#h11-0-244" id="h11-0-244" class="d">-    /// exclusive lock on the file until it is closed, or errors if the lock is
</a><a href="#h11-0-245" id="h11-0-245" class="d">-    /// already held.
</a><a href="#h11-0-246" id="h11-0-246" class="d">-    fn new(path: PathBuf) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-0-247" id="h11-0-247" class="d">-        if let Some(dir) = path.parent() {
</a><a href="#h11-0-248" id="h11-0-248" class="d">-            std::fs::create_dir_all(dir)?
</a><a href="#h11-0-249" id="h11-0-249" class="d">-        }
</a><a href="#h11-0-250" id="h11-0-250" class="d">-        let file = std::fs::OpenOptions::new()
</a><a href="#h11-0-251" id="h11-0-251" class="d">-            .read(true)
</a><a href="#h11-0-252" id="h11-0-252" class="d">-            .write(true)
</a><a href="#h11-0-253" id="h11-0-253" class="d">-            .create(true)
</a><a href="#h11-0-254" id="h11-0-254" class="d">-            .truncate(false)
</a><a href="#h11-0-255" id="h11-0-255" class="d">-            .open(&amp;path)?;
</a><a href="#h11-0-256" id="h11-0-256" class="d">-        file.try_lock_exclusive()?;
</a><a href="#h11-0-257" id="h11-0-257" class="d">-        Ok(Self { path, file })
</a><a href="#h11-0-258" id="h11-0-258" class="d">-    }
</a><a href="#h11-0-259" id="h11-0-259" class="d">-
</a><a href="#h11-0-260" id="h11-0-260" class="d">-    /// Builds a keydir by scanning the log file. If an incomplete entry is
</a><a href="#h11-0-261" id="h11-0-261" class="d">-    /// encountered, it is assumed to be caused by an incomplete write operation
</a><a href="#h11-0-262" id="h11-0-262" class="d">-    /// and the remainder of the file is truncated.
</a><a href="#h11-0-263" id="h11-0-263" class="d">-    fn build_keydir(&amp;mut self) -&gt; Result&lt;KeyDir&gt; {
</a><a href="#h11-0-264" id="h11-0-264" class="d">-        let mut len_buf = [0u8; 4];
</a><a href="#h11-0-265" id="h11-0-265" class="d">-        let mut keydir = KeyDir::new();
</a><a href="#h11-0-266" id="h11-0-266" class="d">-        let file_len = self.file.metadata()?.len();
</a><a href="#h11-0-267" id="h11-0-267" class="d">-        let mut r = BufReader::new(&amp;mut self.file);
</a><a href="#h11-0-268" id="h11-0-268" class="d">-        let mut pos = r.seek(SeekFrom::Start(0))?;
</a><a href="#h11-0-269" id="h11-0-269" class="d">-
</a><a href="#h11-0-270" id="h11-0-270" class="d">-        while pos &lt; file_len {
</a><a href="#h11-0-271" id="h11-0-271" class="d">-            // Read the next entry from the file, returning the key, value
</a><a href="#h11-0-272" id="h11-0-272" class="d">-            // position, and value length or None for tombstones.
</a><a href="#h11-0-273" id="h11-0-273" class="d">-            let result = || -&gt; std::result::Result&lt;(Vec&lt;u8&gt;, u64, Option&lt;u32&gt;), std::io::Error&gt; {
</a><a href="#h11-0-274" id="h11-0-274" class="d">-                r.read_exact(&amp;mut len_buf)?;
</a><a href="#h11-0-275" id="h11-0-275" class="d">-                let key_len = u32::from_be_bytes(len_buf);
</a><a href="#h11-0-276" id="h11-0-276" class="d">-                r.read_exact(&amp;mut len_buf)?;
</a><a href="#h11-0-277" id="h11-0-277" class="d">-                let value_len_or_tombstone = match i32::from_be_bytes(len_buf) {
</a><a href="#h11-0-278" id="h11-0-278" class="d">-                    l if l &gt;= 0 =&gt; Some(l as u32),
</a><a href="#h11-0-279" id="h11-0-279" class="d">-                    _ =&gt; None, // -1 for tombstones
</a><a href="#h11-0-280" id="h11-0-280" class="d">-                };
</a><a href="#h11-0-281" id="h11-0-281" class="d">-                let value_pos = pos + 4 + 4 + key_len as u64;
</a><a href="#h11-0-282" id="h11-0-282" class="d">-
</a><a href="#h11-0-283" id="h11-0-283" class="d">-                let mut key = vec![0; key_len as usize];
</a><a href="#h11-0-284" id="h11-0-284" class="d">-                r.read_exact(&amp;mut key)?;
</a><a href="#h11-0-285" id="h11-0-285" class="d">-
</a><a href="#h11-0-286" id="h11-0-286" class="d">-                if let Some(value_len) = value_len_or_tombstone {
</a><a href="#h11-0-287" id="h11-0-287" class="d">-                    if value_pos + value_len as u64 &gt; file_len {
</a><a href="#h11-0-288" id="h11-0-288" class="d">-                        return Err(std::io::Error::new(
</a><a href="#h11-0-289" id="h11-0-289" class="d">-                            std::io::ErrorKind::UnexpectedEof,
</a><a href="#h11-0-290" id="h11-0-290" class="d">-                            &quot;value extends beyond end of file&quot;,
</a><a href="#h11-0-291" id="h11-0-291" class="d">-                        ));
</a><a href="#h11-0-292" id="h11-0-292" class="d">-                    }
</a><a href="#h11-0-293" id="h11-0-293" class="d">-                    r.seek_relative(value_len as i64)?; // avoids discarding buffer
</a><a href="#h11-0-294" id="h11-0-294" class="d">-                }
</a><a href="#h11-0-295" id="h11-0-295" class="d">-
</a><a href="#h11-0-296" id="h11-0-296" class="d">-                Ok((key, value_pos, value_len_or_tombstone))
</a><a href="#h11-0-297" id="h11-0-297" class="d">-            }();
</a><a href="#h11-0-298" id="h11-0-298" class="d">-
</a><a href="#h11-0-299" id="h11-0-299" class="d">-            match result {
</a><a href="#h11-0-300" id="h11-0-300" class="d">-                // Populate the keydir with the entry, or remove it on tombstones.
</a><a href="#h11-0-301" id="h11-0-301" class="d">-                Ok((key, value_pos, Some(value_len))) =&gt; {
</a><a href="#h11-0-302" id="h11-0-302" class="d">-                    keydir.insert(key, (value_pos, value_len));
</a><a href="#h11-0-303" id="h11-0-303" class="d">-                    pos = value_pos + value_len as u64;
</a><a href="#h11-0-304" id="h11-0-304" class="d">-                }
</a><a href="#h11-0-305" id="h11-0-305" class="d">-                Ok((key, value_pos, None)) =&gt; {
</a><a href="#h11-0-306" id="h11-0-306" class="d">-                    keydir.remove(&amp;key);
</a><a href="#h11-0-307" id="h11-0-307" class="d">-                    pos = value_pos;
</a><a href="#h11-0-308" id="h11-0-308" class="d">-                }
</a><a href="#h11-0-309" id="h11-0-309" class="d">-                // If an incomplete entry was found at the end of the file, assume an
</a><a href="#h11-0-310" id="h11-0-310" class="d">-                // incomplete write and truncate the file.
</a><a href="#h11-0-311" id="h11-0-311" class="d">-                Err(err) if err.kind() == std::io::ErrorKind::UnexpectedEof =&gt; {
</a><a href="#h11-0-312" id="h11-0-312" class="d">-                    log::error!(&quot;Found incomplete entry at offset {}, truncating file&quot;, pos);
</a><a href="#h11-0-313" id="h11-0-313" class="d">-                    self.file.set_len(pos)?;
</a><a href="#h11-0-314" id="h11-0-314" class="d">-                    break;
</a><a href="#h11-0-315" id="h11-0-315" class="d">-                }
</a><a href="#h11-0-316" id="h11-0-316" class="d">-                Err(err) =&gt; return Err(err.into()),
</a><a href="#h11-0-317" id="h11-0-317" class="d">-            }
</a><a href="#h11-0-318" id="h11-0-318" class="d">-        }
</a><a href="#h11-0-319" id="h11-0-319" class="d">-
</a><a href="#h11-0-320" id="h11-0-320" class="d">-        Ok(keydir)
</a><a href="#h11-0-321" id="h11-0-321" class="d">-    }
</a><a href="#h11-0-322" id="h11-0-322" class="d">-
</a><a href="#h11-0-323" id="h11-0-323" class="d">-    /// Reads a value from the log file.
</a><a href="#h11-0-324" id="h11-0-324" class="d">-    fn read_value(&amp;mut self, value_pos: u64, value_len: u32) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h11-0-325" id="h11-0-325" class="d">-        let mut value = vec![0; value_len as usize];
</a><a href="#h11-0-326" id="h11-0-326" class="d">-        self.file.seek(SeekFrom::Start(value_pos))?;
</a><a href="#h11-0-327" id="h11-0-327" class="d">-        self.file.read_exact(&amp;mut value)?;
</a><a href="#h11-0-328" id="h11-0-328" class="d">-        Ok(value)
</a><a href="#h11-0-329" id="h11-0-329" class="d">-    }
</a><a href="#h11-0-330" id="h11-0-330" class="d">-
</a><a href="#h11-0-331" id="h11-0-331" class="d">-    /// Appends a key/value entry to the log file, using a None value for
</a><a href="#h11-0-332" id="h11-0-332" class="d">-    /// tombstones. It returns the position and length of the entry.
</a><a href="#h11-0-333" id="h11-0-333" class="d">-    fn write_entry(&amp;mut self, key: &amp;[u8], value: Option&lt;&amp;[u8]&gt;) -&gt; Result&lt;(u64, u32)&gt; {
</a><a href="#h11-0-334" id="h11-0-334" class="d">-        let key_len = key.len() as u32;
</a><a href="#h11-0-335" id="h11-0-335" class="d">-        let value_len = value.map_or(0, |v| v.len() as u32);
</a><a href="#h11-0-336" id="h11-0-336" class="d">-        let value_len_or_tombstone = value.map_or(-1, |v| v.len() as i32);
</a><a href="#h11-0-337" id="h11-0-337" class="d">-        let len = 4 + 4 + key_len + value_len;
</a><a href="#h11-0-338" id="h11-0-338" class="d">-
</a><a href="#h11-0-339" id="h11-0-339" class="d">-        let pos = self.file.seek(SeekFrom::End(0))?;
</a><a href="#h11-0-340" id="h11-0-340" class="d">-        let mut w = BufWriter::with_capacity(len as usize, &amp;mut self.file);
</a><a href="#h11-0-341" id="h11-0-341" class="d">-        w.write_all(&amp;key_len.to_be_bytes())?;
</a><a href="#h11-0-342" id="h11-0-342" class="d">-        w.write_all(&amp;value_len_or_tombstone.to_be_bytes())?;
</a><a href="#h11-0-343" id="h11-0-343" class="d">-        w.write_all(key)?;
</a><a href="#h11-0-344" id="h11-0-344" class="d">-        if let Some(value) = value {
</a><a href="#h11-0-345" id="h11-0-345" class="d">-            w.write_all(value)?;
</a><a href="#h11-0-346" id="h11-0-346" class="d">-        }
</a><a href="#h11-0-347" id="h11-0-347" class="d">-        w.flush()?;
</a><a href="#h11-0-348" id="h11-0-348" class="d">-
</a><a href="#h11-0-349" id="h11-0-349" class="d">-        Ok((pos, len))
</a><a href="#h11-0-350" id="h11-0-350" class="d">-    }
</a><a href="#h11-0-351" id="h11-0-351" class="d">-
</a><a href="#h11-0-352" id="h11-0-352" class="d">-    #[cfg(test)]
</a><a href="#h11-0-353" id="h11-0-353" class="d">-    /// Prints the entire log file to the given writer in human-readable form.
</a><a href="#h11-0-354" id="h11-0-354" class="d">-    fn print&lt;W: Write&gt;(&amp;mut self, w: &amp;mut W) -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-355" id="h11-0-355" class="d">-        let mut len_buf = [0u8; 4];
</a><a href="#h11-0-356" id="h11-0-356" class="d">-        let file_len = self.file.metadata()?.len();
</a><a href="#h11-0-357" id="h11-0-357" class="d">-        let mut r = BufReader::new(&amp;mut self.file);
</a><a href="#h11-0-358" id="h11-0-358" class="d">-        let mut pos = r.seek(SeekFrom::Start(0))?;
</a><a href="#h11-0-359" id="h11-0-359" class="d">-        let mut idx = 0;
</a><a href="#h11-0-360" id="h11-0-360" class="d">-
</a><a href="#h11-0-361" id="h11-0-361" class="d">-        while pos &lt; file_len {
</a><a href="#h11-0-362" id="h11-0-362" class="d">-            writeln!(w, &quot;entry = {}, offset {}&quot;, idx, pos)?;
</a><a href="#h11-0-363" id="h11-0-363" class="d">-
</a><a href="#h11-0-364" id="h11-0-364" class="d">-            r.read_exact(&amp;mut len_buf)?;
</a><a href="#h11-0-365" id="h11-0-365" class="d">-            let key_len = u32::from_be_bytes(len_buf);
</a><a href="#h11-0-366" id="h11-0-366" class="d">-            writeln!(w, &quot;klen  = {} {:x?}&quot;, key_len, len_buf)?;
</a><a href="#h11-0-367" id="h11-0-367" class="d">-
</a><a href="#h11-0-368" id="h11-0-368" class="d">-            r.read_exact(&amp;mut len_buf)?;
</a><a href="#h11-0-369" id="h11-0-369" class="d">-            let value_len_or_tombstone = i32::from_be_bytes(len_buf); // NB: -1 for tombstones
</a><a href="#h11-0-370" id="h11-0-370" class="d">-            let value_len = value_len_or_tombstone.max(0) as u32;
</a><a href="#h11-0-371" id="h11-0-371" class="d">-            writeln!(w, &quot;vlen  = {} {:x?}&quot;, value_len_or_tombstone, len_buf)?;
</a><a href="#h11-0-372" id="h11-0-372" class="d">-
</a><a href="#h11-0-373" id="h11-0-373" class="d">-            let mut key = vec![0; key_len as usize];
</a><a href="#h11-0-374" id="h11-0-374" class="d">-            r.read_exact(&amp;mut key)?;
</a><a href="#h11-0-375" id="h11-0-375" class="d">-            write!(w, &quot;key   = &quot;)?;
</a><a href="#h11-0-376" id="h11-0-376" class="d">-            if let Ok(str) = std::str::from_utf8(&amp;key) {
</a><a href="#h11-0-377" id="h11-0-377" class="d">-                write!(w, r#&quot;&quot;{}&quot; &quot;#, str)?;
</a><a href="#h11-0-378" id="h11-0-378" class="d">-            }
</a><a href="#h11-0-379" id="h11-0-379" class="d">-            writeln!(w, &quot;{:x?}&quot;, key)?;
</a><a href="#h11-0-380" id="h11-0-380" class="d">-
</a><a href="#h11-0-381" id="h11-0-381" class="d">-            let mut value = vec![0; value_len as usize];
</a><a href="#h11-0-382" id="h11-0-382" class="d">-            r.read_exact(&amp;mut value)?;
</a><a href="#h11-0-383" id="h11-0-383" class="d">-            write!(w, &quot;value = &quot;)?;
</a><a href="#h11-0-384" id="h11-0-384" class="d">-            if value_len_or_tombstone &lt; 0 {
</a><a href="#h11-0-385" id="h11-0-385" class="d">-                write!(w, &quot;tombstone &quot;)?;
</a><a href="#h11-0-386" id="h11-0-386" class="d">-            } else if let Ok(str) = std::str::from_utf8(&amp;value) {
</a><a href="#h11-0-387" id="h11-0-387" class="d">-                if str.chars().all(|c| !c.is_control()) {
</a><a href="#h11-0-388" id="h11-0-388" class="d">-                    write!(w, r#&quot;&quot;{}&quot; &quot;#, str)?;
</a><a href="#h11-0-389" id="h11-0-389" class="d">-                }
</a><a href="#h11-0-390" id="h11-0-390" class="d">-            }
</a><a href="#h11-0-391" id="h11-0-391" class="d">-            write!(w, &quot;{:x?}\n\n&quot;, value)?;
</a><a href="#h11-0-392" id="h11-0-392" class="d">-
</a><a href="#h11-0-393" id="h11-0-393" class="d">-            pos += 4 + 4 + key_len as u64 + value_len as u64;
</a><a href="#h11-0-394" id="h11-0-394" class="d">-            idx += 1;
</a><a href="#h11-0-395" id="h11-0-395" class="d">-        }
</a><a href="#h11-0-396" id="h11-0-396" class="d">-        Ok(())
</a><a href="#h11-0-397" id="h11-0-397" class="d">-    }
</a><a href="#h11-0-398" id="h11-0-398" class="d">-}
</a><a href="#h11-0-399" id="h11-0-399" class="d">-
</a><a href="#h11-0-400" id="h11-0-400" class="d">-#[cfg(test)]
</a><a href="#h11-0-401" id="h11-0-401" class="d">-mod tests {
</a><a href="#h11-0-402" id="h11-0-402" class="d">-    use super::*;
</a><a href="#h11-0-403" id="h11-0-403" class="d">-
</a><a href="#h11-0-404" id="h11-0-404" class="d">-    const GOLDEN_DIR: &amp;str = &quot;src/storage/golden/bitcask&quot;;
</a><a href="#h11-0-405" id="h11-0-405" class="d">-
</a><a href="#h11-0-406" id="h11-0-406" class="d">-    super::super::tests::test_engine!({
</a><a href="#h11-0-407" id="h11-0-407" class="d">-        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h11-0-408" id="h11-0-408" class="d">-        BitCask::new(path)?
</a><a href="#h11-0-409" id="h11-0-409" class="d">-    });
</a><a href="#h11-0-410" id="h11-0-410" class="d">-
</a><a href="#h11-0-411" id="h11-0-411" class="d">-    /// Creates a new BitCask engine for testing.
</a><a href="#h11-0-412" id="h11-0-412" class="d">-    fn setup() -&gt; Result&lt;BitCask&gt; {
</a><a href="#h11-0-413" id="h11-0-413" class="d">-        BitCask::new(tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;))
</a><a href="#h11-0-414" id="h11-0-414" class="d">-    }
</a><a href="#h11-0-415" id="h11-0-415" class="d">-
</a><a href="#h11-0-416" id="h11-0-416" class="d">-    /// Writes various values primarily for testing log file handling.
</a><a href="#h11-0-417" id="h11-0-417" class="d">-    ///
</a><a href="#h11-0-418" id="h11-0-418" class="d">-    /// - &#39;&#39;: empty key and value
</a><a href="#h11-0-419" id="h11-0-419" class="d">-    /// - a: write
</a><a href="#h11-0-420" id="h11-0-420" class="d">-    /// - b: write, write
</a><a href="#h11-0-421" id="h11-0-421" class="d">-    /// - c: write, delete, write
</a><a href="#h11-0-422" id="h11-0-422" class="d">-    /// - d: delete, write
</a><a href="#h11-0-423" id="h11-0-423" class="d">-    /// - e: write, delete
</a><a href="#h11-0-424" id="h11-0-424" class="d">-    /// - f: delete
</a><a href="#h11-0-425" id="h11-0-425" class="d">-    fn setup_log(s: &amp;mut BitCask) -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-426" id="h11-0-426" class="d">-        s.set(b&quot;b&quot;, vec![0x01])?;
</a><a href="#h11-0-427" id="h11-0-427" class="d">-        s.set(b&quot;b&quot;, vec![0x02])?;
</a><a href="#h11-0-428" id="h11-0-428" class="d">-
</a><a href="#h11-0-429" id="h11-0-429" class="d">-        s.set(b&quot;e&quot;, vec![0x05])?;
</a><a href="#h11-0-430" id="h11-0-430" class="d">-        s.delete(b&quot;e&quot;)?;
</a><a href="#h11-0-431" id="h11-0-431" class="d">-
</a><a href="#h11-0-432" id="h11-0-432" class="d">-        s.set(b&quot;c&quot;, vec![0x00])?;
</a><a href="#h11-0-433" id="h11-0-433" class="d">-        s.delete(b&quot;c&quot;)?;
</a><a href="#h11-0-434" id="h11-0-434" class="d">-        s.set(b&quot;c&quot;, vec![0x03])?;
</a><a href="#h11-0-435" id="h11-0-435" class="d">-
</a><a href="#h11-0-436" id="h11-0-436" class="d">-        s.set(b&quot;&quot;, vec![])?;
</a><a href="#h11-0-437" id="h11-0-437" class="d">-
</a><a href="#h11-0-438" id="h11-0-438" class="d">-        s.set(b&quot;a&quot;, vec![0x01])?;
</a><a href="#h11-0-439" id="h11-0-439" class="d">-
</a><a href="#h11-0-440" id="h11-0-440" class="d">-        s.delete(b&quot;f&quot;)?;
</a><a href="#h11-0-441" id="h11-0-441" class="d">-
</a><a href="#h11-0-442" id="h11-0-442" class="d">-        s.delete(b&quot;d&quot;)?;
</a><a href="#h11-0-443" id="h11-0-443" class="d">-        s.set(b&quot;d&quot;, vec![0x04])?;
</a><a href="#h11-0-444" id="h11-0-444" class="d">-
</a><a href="#h11-0-445" id="h11-0-445" class="d">-        // Make sure the scan yields the expected results.
</a><a href="#h11-0-446" id="h11-0-446" class="d">-        assert_eq!(
</a><a href="#h11-0-447" id="h11-0-447" class="d">-            vec![
</a><a href="#h11-0-448" id="h11-0-448" class="d">-                (b&quot;&quot;.to_vec(), vec![]),
</a><a href="#h11-0-449" id="h11-0-449" class="d">-                (b&quot;a&quot;.to_vec(), vec![0x01]),
</a><a href="#h11-0-450" id="h11-0-450" class="d">-                (b&quot;b&quot;.to_vec(), vec![0x02]),
</a><a href="#h11-0-451" id="h11-0-451" class="d">-                (b&quot;c&quot;.to_vec(), vec![0x03]),
</a><a href="#h11-0-452" id="h11-0-452" class="d">-                (b&quot;d&quot;.to_vec(), vec![0x04]),
</a><a href="#h11-0-453" id="h11-0-453" class="d">-            ],
</a><a href="#h11-0-454" id="h11-0-454" class="d">-            s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h11-0-455" id="h11-0-455" class="d">-        );
</a><a href="#h11-0-456" id="h11-0-456" class="d">-
</a><a href="#h11-0-457" id="h11-0-457" class="d">-        Ok(())
</a><a href="#h11-0-458" id="h11-0-458" class="d">-    }
</a><a href="#h11-0-459" id="h11-0-459" class="d">-
</a><a href="#h11-0-460" id="h11-0-460" class="d">-    #[test]
</a><a href="#h11-0-461" id="h11-0-461" class="d">-    /// Tests that logs are written correctly using a golden file.
</a><a href="#h11-0-462" id="h11-0-462" class="d">-    fn log() -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-463" id="h11-0-463" class="d">-        let mut s = setup()?;
</a><a href="#h11-0-464" id="h11-0-464" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h11-0-465" id="h11-0-465" class="d">-
</a><a href="#h11-0-466" id="h11-0-466" class="d">-        let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
</a><a href="#h11-0-467" id="h11-0-467" class="d">-        s.log.print(&amp;mut mint.new_goldenfile(&quot;log&quot;)?)?;
</a><a href="#h11-0-468" id="h11-0-468" class="d">-        Ok(())
</a><a href="#h11-0-469" id="h11-0-469" class="d">-    }
</a><a href="#h11-0-470" id="h11-0-470" class="d">-
</a><a href="#h11-0-471" id="h11-0-471" class="d">-    #[test]
</a><a href="#h11-0-472" id="h11-0-472" class="d">-    /// Tests that writing and then reading a file yields the same results.
</a><a href="#h11-0-473" id="h11-0-473" class="d">-    fn reopen() -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-474" id="h11-0-474" class="d">-        // NB: Don&#39;t use setup(), because the tempdir will be removed when
</a><a href="#h11-0-475" id="h11-0-475" class="d">-        // the path falls out of scope.
</a><a href="#h11-0-476" id="h11-0-476" class="d">-        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h11-0-477" id="h11-0-477" class="d">-        let mut s = BitCask::new(path.clone())?;
</a><a href="#h11-0-478" id="h11-0-478" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h11-0-479" id="h11-0-479" class="d">-
</a><a href="#h11-0-480" id="h11-0-480" class="d">-        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h11-0-481" id="h11-0-481" class="d">-        drop(s);
</a><a href="#h11-0-482" id="h11-0-482" class="d">-        let mut s = BitCask::new(path)?;
</a><a href="#h11-0-483" id="h11-0-483" class="d">-        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h11-0-484" id="h11-0-484" class="d">-
</a><a href="#h11-0-485" id="h11-0-485" class="d">-        Ok(())
</a><a href="#h11-0-486" id="h11-0-486" class="d">-    }
</a><a href="#h11-0-487" id="h11-0-487" class="d">-
</a><a href="#h11-0-488" id="h11-0-488" class="d">-    #[test]
</a><a href="#h11-0-489" id="h11-0-489" class="d">-    /// Tests log compaction, by writing golden files of the before/after state,
</a><a href="#h11-0-490" id="h11-0-490" class="d">-    /// and checking that the database contains the same results, even after
</a><a href="#h11-0-491" id="h11-0-491" class="d">-    /// reopening the file.
</a><a href="#h11-0-492" id="h11-0-492" class="d">-    fn compact() -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-493" id="h11-0-493" class="d">-        // NB: Don&#39;t use setup(), because the tempdir will be removed when
</a><a href="#h11-0-494" id="h11-0-494" class="d">-        // the path falls out of scope.
</a><a href="#h11-0-495" id="h11-0-495" class="d">-        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h11-0-496" id="h11-0-496" class="d">-        let mut s = BitCask::new(path.clone())?;
</a><a href="#h11-0-497" id="h11-0-497" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h11-0-498" id="h11-0-498" class="d">-
</a><a href="#h11-0-499" id="h11-0-499" class="d">-        // Dump the initial log file.
</a><a href="#h11-0-500" id="h11-0-500" class="d">-        let mut mint = goldenfile::Mint::new(GOLDEN_DIR);
</a><a href="#h11-0-501" id="h11-0-501" class="d">-        s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-before&quot;)?)?;
</a><a href="#h11-0-502" id="h11-0-502" class="d">-        let expect = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h11-0-503" id="h11-0-503" class="d">-
</a><a href="#h11-0-504" id="h11-0-504" class="d">-        // Compact the log file and assert the new log file contents.
</a><a href="#h11-0-505" id="h11-0-505" class="d">-        s.compact()?;
</a><a href="#h11-0-506" id="h11-0-506" class="d">-        assert_eq!(path, s.log.path);
</a><a href="#h11-0-507" id="h11-0-507" class="d">-        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h11-0-508" id="h11-0-508" class="d">-        s.log.print(&amp;mut mint.new_goldenfile(&quot;compact-after&quot;)?)?;
</a><a href="#h11-0-509" id="h11-0-509" class="d">-
</a><a href="#h11-0-510" id="h11-0-510" class="d">-        // Reopen the log file and assert that the contents are the same.
</a><a href="#h11-0-511" id="h11-0-511" class="d">-        drop(s);
</a><a href="#h11-0-512" id="h11-0-512" class="d">-        let mut s = BitCask::new(path)?;
</a><a href="#h11-0-513" id="h11-0-513" class="d">-        assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,);
</a><a href="#h11-0-514" id="h11-0-514" class="d">-
</a><a href="#h11-0-515" id="h11-0-515" class="d">-        Ok(())
</a><a href="#h11-0-516" id="h11-0-516" class="d">-    }
</a><a href="#h11-0-517" id="h11-0-517" class="d">-
</a><a href="#h11-0-518" id="h11-0-518" class="d">-    #[test]
</a><a href="#h11-0-519" id="h11-0-519" class="d">-    /// Tests that new_compact() will automatically compact the file when appropriate.
</a><a href="#h11-0-520" id="h11-0-520" class="d">-    fn new_compact() -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-521" id="h11-0-521" class="d">-        // Create an initial log file with a few entries.
</a><a href="#h11-0-522" id="h11-0-522" class="d">-        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h11-0-523" id="h11-0-523" class="d">-        let path = dir.path().join(&quot;orig&quot;);
</a><a href="#h11-0-524" id="h11-0-524" class="d">-        let compactpath = dir.path().join(&quot;compact&quot;);
</a><a href="#h11-0-525" id="h11-0-525" class="d">-
</a><a href="#h11-0-526" id="h11-0-526" class="d">-        let mut s = BitCask::new_compact(path.clone(), 0.2, 0)?;
</a><a href="#h11-0-527" id="h11-0-527" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h11-0-528" id="h11-0-528" class="d">-        let status = s.status()?;
</a><a href="#h11-0-529" id="h11-0-529" class="d">-        let garbage_ratio = status.garbage_disk_size as f64 / status.total_disk_size as f64;
</a><a href="#h11-0-530" id="h11-0-530" class="d">-        let garbage_size = status.garbage_disk_size;
</a><a href="#h11-0-531" id="h11-0-531" class="d">-        drop(s);
</a><a href="#h11-0-532" id="h11-0-532" class="d">-
</a><a href="#h11-0-533" id="h11-0-533" class="d">-        // Test a few ratio/size thresholds and assert whether it should trigger compaction.
</a><a href="#h11-0-534" id="h11-0-534" class="d">-        let cases = vec![
</a><a href="#h11-0-535" id="h11-0-535" class="d">-            (-1.0, 0, true),
</a><a href="#h11-0-536" id="h11-0-536" class="d">-            (0.0, 0, true),
</a><a href="#h11-0-537" id="h11-0-537" class="d">-            (garbage_ratio - 0.001, 0, true),
</a><a href="#h11-0-538" id="h11-0-538" class="d">-            (garbage_ratio, 0, true),
</a><a href="#h11-0-539" id="h11-0-539" class="d">-            (garbage_ratio + 0.001, 0, false),
</a><a href="#h11-0-540" id="h11-0-540" class="d">-            (1.0, 0, false),
</a><a href="#h11-0-541" id="h11-0-541" class="d">-            (2.0, 0, false),
</a><a href="#h11-0-542" id="h11-0-542" class="d">-            (0.0, 1, true),
</a><a href="#h11-0-543" id="h11-0-543" class="d">-            (0.0, garbage_size - 1, true),
</a><a href="#h11-0-544" id="h11-0-544" class="d">-            (0.0, garbage_size, true),
</a><a href="#h11-0-545" id="h11-0-545" class="d">-            (0.0, garbage_size + 1, false),
</a><a href="#h11-0-546" id="h11-0-546" class="d">-        ];
</a><a href="#h11-0-547" id="h11-0-547" class="d">-        for (min_ratio, min_size, expect_compact) in cases.into_iter() {
</a><a href="#h11-0-548" id="h11-0-548" class="d">-            std::fs::copy(&amp;path, &amp;compactpath)?;
</a><a href="#h11-0-549" id="h11-0-549" class="d">-            let mut s = BitCask::new_compact(compactpath.clone(), min_ratio, min_size)?;
</a><a href="#h11-0-550" id="h11-0-550" class="d">-            let new_status = s.status()?;
</a><a href="#h11-0-551" id="h11-0-551" class="d">-            assert_eq!(new_status.live_disk_size, status.live_disk_size);
</a><a href="#h11-0-552" id="h11-0-552" class="d">-            if expect_compact {
</a><a href="#h11-0-553" id="h11-0-553" class="d">-                assert_eq!(new_status.total_disk_size, status.live_disk_size);
</a><a href="#h11-0-554" id="h11-0-554" class="d">-                assert_eq!(new_status.garbage_disk_size, 0);
</a><a href="#h11-0-555" id="h11-0-555" class="d">-            } else {
</a><a href="#h11-0-556" id="h11-0-556" class="d">-                assert_eq!(new_status, status);
</a><a href="#h11-0-557" id="h11-0-557" class="d">-            }
</a><a href="#h11-0-558" id="h11-0-558" class="d">-        }
</a><a href="#h11-0-559" id="h11-0-559" class="d">-
</a><a href="#h11-0-560" id="h11-0-560" class="d">-        Ok(())
</a><a href="#h11-0-561" id="h11-0-561" class="d">-    }
</a><a href="#h11-0-562" id="h11-0-562" class="d">-
</a><a href="#h11-0-563" id="h11-0-563" class="d">-    #[test]
</a><a href="#h11-0-564" id="h11-0-564" class="d">-    /// Tests that exclusive locks are taken out on log files, released when the
</a><a href="#h11-0-565" id="h11-0-565" class="d">-    /// database is closed, and that an error is returned if a lock is already
</a><a href="#h11-0-566" id="h11-0-566" class="d">-    /// held.
</a><a href="#h11-0-567" id="h11-0-567" class="d">-    fn log_lock() -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-568" id="h11-0-568" class="d">-        let path = tempdir::TempDir::new(&quot;toydb&quot;)?.path().join(&quot;toydb&quot;);
</a><a href="#h11-0-569" id="h11-0-569" class="d">-        let s = BitCask::new(path.clone())?;
</a><a href="#h11-0-570" id="h11-0-570" class="d">-
</a><a href="#h11-0-571" id="h11-0-571" class="d">-        assert!(BitCask::new(path.clone()).is_err());
</a><a href="#h11-0-572" id="h11-0-572" class="d">-        drop(s);
</a><a href="#h11-0-573" id="h11-0-573" class="d">-        assert!(BitCask::new(path.clone()).is_ok());
</a><a href="#h11-0-574" id="h11-0-574" class="d">-
</a><a href="#h11-0-575" id="h11-0-575" class="d">-        Ok(())
</a><a href="#h11-0-576" id="h11-0-576" class="d">-    }
</a><a href="#h11-0-577" id="h11-0-577" class="d">-
</a><a href="#h11-0-578" id="h11-0-578" class="d">-    #[test]
</a><a href="#h11-0-579" id="h11-0-579" class="d">-    /// Tests that an incomplete write at the end of the log file can be
</a><a href="#h11-0-580" id="h11-0-580" class="d">-    /// recovered by discarding the last entry.
</a><a href="#h11-0-581" id="h11-0-581" class="d">-    fn recovery() -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-582" id="h11-0-582" class="d">-        // Create an initial log file with a few entries.
</a><a href="#h11-0-583" id="h11-0-583" class="d">-        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h11-0-584" id="h11-0-584" class="d">-        let path = dir.path().join(&quot;complete&quot;);
</a><a href="#h11-0-585" id="h11-0-585" class="d">-        let truncpath = dir.path().join(&quot;truncated&quot;);
</a><a href="#h11-0-586" id="h11-0-586" class="d">-
</a><a href="#h11-0-587" id="h11-0-587" class="d">-        let mut log = Log::new(path.clone())?;
</a><a href="#h11-0-588" id="h11-0-588" class="d">-        let mut ends = vec![];
</a><a href="#h11-0-589" id="h11-0-589" class="d">-
</a><a href="#h11-0-590" id="h11-0-590" class="d">-        let (pos, len) = log.write_entry(&quot;deleted&quot;.as_bytes(), Some(&amp;[1, 2, 3]))?;
</a><a href="#h11-0-591" id="h11-0-591" class="d">-        ends.push(pos + len as u64);
</a><a href="#h11-0-592" id="h11-0-592" class="d">-
</a><a href="#h11-0-593" id="h11-0-593" class="d">-        let (pos, len) = log.write_entry(&quot;deleted&quot;.as_bytes(), None)?;
</a><a href="#h11-0-594" id="h11-0-594" class="d">-        ends.push(pos + len as u64);
</a><a href="#h11-0-595" id="h11-0-595" class="d">-
</a><a href="#h11-0-596" id="h11-0-596" class="d">-        let (pos, len) = log.write_entry(&amp;[], Some(&amp;[]))?;
</a><a href="#h11-0-597" id="h11-0-597" class="d">-        ends.push(pos + len as u64);
</a><a href="#h11-0-598" id="h11-0-598" class="d">-
</a><a href="#h11-0-599" id="h11-0-599" class="d">-        let (pos, len) = log.write_entry(&quot;key&quot;.as_bytes(), Some(&amp;[1, 2, 3, 4, 5]))?;
</a><a href="#h11-0-600" id="h11-0-600" class="d">-        ends.push(pos + len as u64);
</a><a href="#h11-0-601" id="h11-0-601" class="d">-
</a><a href="#h11-0-602" id="h11-0-602" class="d">-        drop(log);
</a><a href="#h11-0-603" id="h11-0-603" class="d">-
</a><a href="#h11-0-604" id="h11-0-604" class="d">-        // Copy the file, and truncate it at each byte, then try to open it
</a><a href="#h11-0-605" id="h11-0-605" class="d">-        // and assert that we always retain a prefix of entries.
</a><a href="#h11-0-606" id="h11-0-606" class="d">-        let size = std::fs::metadata(&amp;path)?.len();
</a><a href="#h11-0-607" id="h11-0-607" class="d">-        for pos in 0..=size {
</a><a href="#h11-0-608" id="h11-0-608" class="d">-            std::fs::copy(&amp;path, &amp;truncpath)?;
</a><a href="#h11-0-609" id="h11-0-609" class="d">-            let f = std::fs::OpenOptions::new().write(true).open(&amp;truncpath)?;
</a><a href="#h11-0-610" id="h11-0-610" class="d">-            f.set_len(pos)?;
</a><a href="#h11-0-611" id="h11-0-611" class="d">-            drop(f);
</a><a href="#h11-0-612" id="h11-0-612" class="d">-
</a><a href="#h11-0-613" id="h11-0-613" class="d">-            let mut expect = vec![];
</a><a href="#h11-0-614" id="h11-0-614" class="d">-            if pos &gt;= ends[0] {
</a><a href="#h11-0-615" id="h11-0-615" class="d">-                expect.push((b&quot;deleted&quot;.to_vec(), vec![1, 2, 3]))
</a><a href="#h11-0-616" id="h11-0-616" class="d">-            }
</a><a href="#h11-0-617" id="h11-0-617" class="d">-            if pos &gt;= ends[1] {
</a><a href="#h11-0-618" id="h11-0-618" class="d">-                expect.pop(); // &quot;deleted&quot; key removed
</a><a href="#h11-0-619" id="h11-0-619" class="d">-            }
</a><a href="#h11-0-620" id="h11-0-620" class="d">-            if pos &gt;= ends[2] {
</a><a href="#h11-0-621" id="h11-0-621" class="d">-                expect.push((b&quot;&quot;.to_vec(), vec![]))
</a><a href="#h11-0-622" id="h11-0-622" class="d">-            }
</a><a href="#h11-0-623" id="h11-0-623" class="d">-            if pos &gt;= ends[3] {
</a><a href="#h11-0-624" id="h11-0-624" class="d">-                expect.push((b&quot;key&quot;.to_vec(), vec![1, 2, 3, 4, 5]))
</a><a href="#h11-0-625" id="h11-0-625" class="d">-            }
</a><a href="#h11-0-626" id="h11-0-626" class="d">-
</a><a href="#h11-0-627" id="h11-0-627" class="d">-            let mut s = BitCask::new(truncpath.clone())?;
</a><a href="#h11-0-628" id="h11-0-628" class="d">-            assert_eq!(expect, s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?);
</a><a href="#h11-0-629" id="h11-0-629" class="d">-        }
</a><a href="#h11-0-630" id="h11-0-630" class="d">-
</a><a href="#h11-0-631" id="h11-0-631" class="d">-        Ok(())
</a><a href="#h11-0-632" id="h11-0-632" class="d">-    }
</a><a href="#h11-0-633" id="h11-0-633" class="d">-
</a><a href="#h11-0-634" id="h11-0-634" class="d">-    #[test]
</a><a href="#h11-0-635" id="h11-0-635" class="d">-    /// Tests status(), both for a log file with known garbage, and
</a><a href="#h11-0-636" id="h11-0-636" class="d">-    /// after compacting it when the live size must equal the file size.
</a><a href="#h11-0-637" id="h11-0-637" class="d">-    fn status_full() -&gt; Result&lt;()&gt; {
</a><a href="#h11-0-638" id="h11-0-638" class="d">-        let mut s = setup()?;
</a><a href="#h11-0-639" id="h11-0-639" class="d">-        setup_log(&amp;mut s)?;
</a><a href="#h11-0-640" id="h11-0-640" class="d">-
</a><a href="#h11-0-641" id="h11-0-641" class="d">-        // Before compaction.
</a><a href="#h11-0-642" id="h11-0-642" class="d">-        assert_eq!(
</a><a href="#h11-0-643" id="h11-0-643" class="d">-            s.status()?,
</a><a href="#h11-0-644" id="h11-0-644" class="d">-            Status {
</a><a href="#h11-0-645" id="h11-0-645" class="d">-                name: &quot;bitcask&quot;.to_string(),
</a><a href="#h11-0-646" id="h11-0-646" class="d">-                keys: 5,
</a><a href="#h11-0-647" id="h11-0-647" class="d">-                size: 8,
</a><a href="#h11-0-648" id="h11-0-648" class="d">-                total_disk_size: 114,
</a><a href="#h11-0-649" id="h11-0-649" class="d">-                live_disk_size: 48,
</a><a href="#h11-0-650" id="h11-0-650" class="d">-                garbage_disk_size: 66
</a><a href="#h11-0-651" id="h11-0-651" class="d">-            }
</a><a href="#h11-0-652" id="h11-0-652" class="d">-        );
</a><a href="#h11-0-653" id="h11-0-653" class="d">-
</a><a href="#h11-0-654" id="h11-0-654" class="d">-        // After compaction.
</a><a href="#h11-0-655" id="h11-0-655" class="d">-        s.compact()?;
</a><a href="#h11-0-656" id="h11-0-656" class="d">-        assert_eq!(
</a><a href="#h11-0-657" id="h11-0-657" class="d">-            s.status()?,
</a><a href="#h11-0-658" id="h11-0-658" class="d">-            Status {
</a><a href="#h11-0-659" id="h11-0-659" class="d">-                name: &quot;bitcask&quot;.to_string(),
</a><a href="#h11-0-660" id="h11-0-660" class="d">-                keys: 5,
</a><a href="#h11-0-661" id="h11-0-661" class="d">-                size: 8,
</a><a href="#h11-0-662" id="h11-0-662" class="d">-                total_disk_size: 48,
</a><a href="#h11-0-663" id="h11-0-663" class="d">-                live_disk_size: 48,
</a><a href="#h11-0-664" id="h11-0-664" class="d">-                garbage_disk_size: 0,
</a><a href="#h11-0-665" id="h11-0-665" class="d">-            }
</a><a href="#h11-0-666" id="h11-0-666" class="d">-        );
</a><a href="#h11-0-667" id="h11-0-667" class="d">-
</a><a href="#h11-0-668" id="h11-0-668" class="d">-        Ok(())
</a><a href="#h11-0-669" id="h11-0-669" class="d">-    }
</a><a href="#h11-0-670" id="h11-0-670" class="d">-}
</a><b>diff --git a/<a id="h12" href="../file/src/storage/engine/memory.rs.html">src/storage/engine/memory.rs</a> b/<a href="../file/src/storage/engine/memory.rs.html">src/storage/engine/memory.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -1,97 +0,0 @@
</a><a href="#h12-0-0" id="h12-0-0" class="d">-use super::{Engine, Status};
</a><a href="#h12-0-1" id="h12-0-1" class="d">-use crate::error::Result;
</a><a href="#h12-0-2" id="h12-0-2" class="d">-
</a><a href="#h12-0-3" id="h12-0-3" class="d">-/// An in-memory key/value storage engine using the Rust standard library B-tree
</a><a href="#h12-0-4" id="h12-0-4" class="d">-/// implementation. Data is not persisted.
</a><a href="#h12-0-5" id="h12-0-5" class="d">-pub struct Memory {
</a><a href="#h12-0-6" id="h12-0-6" class="d">-    data: std::collections::BTreeMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h12-0-7" id="h12-0-7" class="d">-}
</a><a href="#h12-0-8" id="h12-0-8" class="d">-
</a><a href="#h12-0-9" id="h12-0-9" class="d">-impl Memory {
</a><a href="#h12-0-10" id="h12-0-10" class="d">-    /// Creates a new Memory key-value storage engine.
</a><a href="#h12-0-11" id="h12-0-11" class="d">-    pub fn new() -&gt; Self {
</a><a href="#h12-0-12" id="h12-0-12" class="d">-        Self { data: std::collections::BTreeMap::new() }
</a><a href="#h12-0-13" id="h12-0-13" class="d">-    }
</a><a href="#h12-0-14" id="h12-0-14" class="d">-}
</a><a href="#h12-0-15" id="h12-0-15" class="d">-
</a><a href="#h12-0-16" id="h12-0-16" class="d">-impl std::fmt::Display for Memory {
</a><a href="#h12-0-17" id="h12-0-17" class="d">-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h12-0-18" id="h12-0-18" class="d">-        write!(f, &quot;memory&quot;)
</a><a href="#h12-0-19" id="h12-0-19" class="d">-    }
</a><a href="#h12-0-20" id="h12-0-20" class="d">-}
</a><a href="#h12-0-21" id="h12-0-21" class="d">-
</a><a href="#h12-0-22" id="h12-0-22" class="d">-impl Engine for Memory {
</a><a href="#h12-0-23" id="h12-0-23" class="d">-    type ScanIterator&lt;&#39;a&gt; = ScanIterator&lt;&#39;a&gt;;
</a><a href="#h12-0-24" id="h12-0-24" class="d">-
</a><a href="#h12-0-25" id="h12-0-25" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h12-0-26" id="h12-0-26" class="d">-        Ok(())
</a><a href="#h12-0-27" id="h12-0-27" class="d">-    }
</a><a href="#h12-0-28" id="h12-0-28" class="d">-
</a><a href="#h12-0-29" id="h12-0-29" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h12-0-30" id="h12-0-30" class="d">-        self.data.remove(key);
</a><a href="#h12-0-31" id="h12-0-31" class="d">-        Ok(())
</a><a href="#h12-0-32" id="h12-0-32" class="d">-    }
</a><a href="#h12-0-33" id="h12-0-33" class="d">-
</a><a href="#h12-0-34" id="h12-0-34" class="d">-    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h12-0-35" id="h12-0-35" class="d">-        Ok(self.data.get(key).cloned())
</a><a href="#h12-0-36" id="h12-0-36" class="d">-    }
</a><a href="#h12-0-37" id="h12-0-37" class="d">-
</a><a href="#h12-0-38" id="h12-0-38" class="d">-    fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h12-0-39" id="h12-0-39" class="d">-        ScanIterator { inner: self.data.range(range) }
</a><a href="#h12-0-40" id="h12-0-40" class="d">-    }
</a><a href="#h12-0-41" id="h12-0-41" class="d">-
</a><a href="#h12-0-42" id="h12-0-42" class="d">-    fn scan_dyn(
</a><a href="#h12-0-43" id="h12-0-43" class="d">-        &amp;mut self,
</a><a href="#h12-0-44" id="h12-0-44" class="d">-        range: (std::ops::Bound&lt;Vec&lt;u8&gt;&gt;, std::ops::Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h12-0-45" id="h12-0-45" class="d">-    ) -&gt; Box&lt;dyn super::ScanIterator + &#39;_&gt; {
</a><a href="#h12-0-46" id="h12-0-46" class="d">-        Box::new(self.scan(range))
</a><a href="#h12-0-47" id="h12-0-47" class="d">-    }
</a><a href="#h12-0-48" id="h12-0-48" class="d">-
</a><a href="#h12-0-49" id="h12-0-49" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h12-0-50" id="h12-0-50" class="d">-        self.data.insert(key.to_vec(), value);
</a><a href="#h12-0-51" id="h12-0-51" class="d">-        Ok(())
</a><a href="#h12-0-52" id="h12-0-52" class="d">-    }
</a><a href="#h12-0-53" id="h12-0-53" class="d">-
</a><a href="#h12-0-54" id="h12-0-54" class="d">-    fn status(&amp;mut self) -&gt; Result&lt;Status&gt; {
</a><a href="#h12-0-55" id="h12-0-55" class="d">-        Ok(Status {
</a><a href="#h12-0-56" id="h12-0-56" class="d">-            name: self.to_string(),
</a><a href="#h12-0-57" id="h12-0-57" class="d">-            keys: self.data.len() as u64,
</a><a href="#h12-0-58" id="h12-0-58" class="d">-            size: self.data.iter().fold(0, |size, (k, v)| size + k.len() as u64 + v.len() as u64),
</a><a href="#h12-0-59" id="h12-0-59" class="d">-            total_disk_size: 0,
</a><a href="#h12-0-60" id="h12-0-60" class="d">-            live_disk_size: 0,
</a><a href="#h12-0-61" id="h12-0-61" class="d">-            garbage_disk_size: 0,
</a><a href="#h12-0-62" id="h12-0-62" class="d">-        })
</a><a href="#h12-0-63" id="h12-0-63" class="d">-    }
</a><a href="#h12-0-64" id="h12-0-64" class="d">-}
</a><a href="#h12-0-65" id="h12-0-65" class="d">-
</a><a href="#h12-0-66" id="h12-0-66" class="d">-pub struct ScanIterator&lt;&#39;a&gt; {
</a><a href="#h12-0-67" id="h12-0-67" class="d">-    inner: std::collections::btree_map::Range&lt;&#39;a, Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h12-0-68" id="h12-0-68" class="d">-}
</a><a href="#h12-0-69" id="h12-0-69" class="d">-
</a><a href="#h12-0-70" id="h12-0-70" class="d">-impl&lt;&#39;a&gt; ScanIterator&lt;&#39;a&gt; {
</a><a href="#h12-0-71" id="h12-0-71" class="d">-    fn map(item: (&amp;Vec&lt;u8&gt;, &amp;Vec&lt;u8&gt;)) -&gt; &lt;Self as Iterator&gt;::Item {
</a><a href="#h12-0-72" id="h12-0-72" class="d">-        let (key, value) = item;
</a><a href="#h12-0-73" id="h12-0-73" class="d">-        Ok((key.clone(), value.clone()))
</a><a href="#h12-0-74" id="h12-0-74" class="d">-    }
</a><a href="#h12-0-75" id="h12-0-75" class="d">-}
</a><a href="#h12-0-76" id="h12-0-76" class="d">-
</a><a href="#h12-0-77" id="h12-0-77" class="d">-impl&lt;&#39;a&gt; Iterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h12-0-78" id="h12-0-78" class="d">-    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a><a href="#h12-0-79" id="h12-0-79" class="d">-
</a><a href="#h12-0-80" id="h12-0-80" class="d">-    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h12-0-81" id="h12-0-81" class="d">-        self.inner.next().map(Self::map)
</a><a href="#h12-0-82" id="h12-0-82" class="d">-    }
</a><a href="#h12-0-83" id="h12-0-83" class="d">-}
</a><a href="#h12-0-84" id="h12-0-84" class="d">-
</a><a href="#h12-0-85" id="h12-0-85" class="d">-impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h12-0-86" id="h12-0-86" class="d">-    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h12-0-87" id="h12-0-87" class="d">-        self.inner.next_back().map(Self::map)
</a><a href="#h12-0-88" id="h12-0-88" class="d">-    }
</a><a href="#h12-0-89" id="h12-0-89" class="d">-}
</a><a href="#h12-0-90" id="h12-0-90" class="d">-
</a><a href="#h12-0-91" id="h12-0-91" class="d">-#[cfg(test)]
</a><a href="#h12-0-92" id="h12-0-92" class="d">-mod tests {
</a><a href="#h12-0-93" id="h12-0-93" class="d">-    use super::*;
</a><a href="#h12-0-94" id="h12-0-94" class="d">-
</a><a href="#h12-0-95" id="h12-0-95" class="d">-    super::super::tests::test_engine!(Memory::new());
</a><a href="#h12-0-96" id="h12-0-96" class="d">-}
</a><b>diff --git a/<a id="h13" href="../file/src/storage/engine/mod.rs.html">src/storage/engine/mod.rs</a> b/<a href="../file/src/storage/engine/mod.rs.html">src/storage/engine/mod.rs</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -1,478 +0,0 @@
</a><a href="#h13-0-0" id="h13-0-0" class="d">-mod bitcask;
</a><a href="#h13-0-1" id="h13-0-1" class="d">-mod memory;
</a><a href="#h13-0-2" id="h13-0-2" class="d">-
</a><a href="#h13-0-3" id="h13-0-3" class="d">-#[cfg(test)]
</a><a href="#h13-0-4" id="h13-0-4" class="d">-pub use super::debug::Engine as Debug;
</a><a href="#h13-0-5" id="h13-0-5" class="d">-pub use bitcask::BitCask;
</a><a href="#h13-0-6" id="h13-0-6" class="d">-pub use memory::Memory;
</a><a href="#h13-0-7" id="h13-0-7" class="d">-
</a><a href="#h13-0-8" id="h13-0-8" class="d">-use crate::error::Result;
</a><a href="#h13-0-9" id="h13-0-9" class="d">-
</a><a href="#h13-0-10" id="h13-0-10" class="d">-use serde::{Deserialize, Serialize};
</a><a href="#h13-0-11" id="h13-0-11" class="d">-
</a><a href="#h13-0-12" id="h13-0-12" class="d">-/// A key/value storage engine, where both keys and values are arbitrary byte
</a><a href="#h13-0-13" id="h13-0-13" class="d">-/// strings between 0 B and 2 GB, stored in lexicographical key order. Writes
</a><a href="#h13-0-14" id="h13-0-14" class="d">-/// are only guaranteed durable after calling flush().
</a><a href="#h13-0-15" id="h13-0-15" class="d">-///
</a><a href="#h13-0-16" id="h13-0-16" class="d">-/// Only supports single-threaded use since all methods (including reads) take a
</a><a href="#h13-0-17" id="h13-0-17" class="d">-/// mutable reference -- serialized access can&#39;t be avoided anyway, since both
</a><a href="#h13-0-18" id="h13-0-18" class="d">-/// Raft execution and file access is serial.
</a><a href="#h13-0-19" id="h13-0-19" class="d">-pub trait Engine: std::fmt::Display + Send + Sync {
</a><a href="#h13-0-20" id="h13-0-20" class="d">-    /// The iterator returned by scan().
</a><a href="#h13-0-21" id="h13-0-21" class="d">-    type ScanIterator&lt;&#39;a&gt;: ScanIterator + &#39;a
</a><a href="#h13-0-22" id="h13-0-22" class="d">-    where
</a><a href="#h13-0-23" id="h13-0-23" class="d">-        Self: Sized + &#39;a; // omit in trait objects, for object safety
</a><a href="#h13-0-24" id="h13-0-24" class="d">-
</a><a href="#h13-0-25" id="h13-0-25" class="d">-    /// Deletes a key, or does nothing if it does not exist.
</a><a href="#h13-0-26" id="h13-0-26" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt;;
</a><a href="#h13-0-27" id="h13-0-27" class="d">-
</a><a href="#h13-0-28" id="h13-0-28" class="d">-    /// Flushes any buffered data to the underlying storage medium.
</a><a href="#h13-0-29" id="h13-0-29" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</a><a href="#h13-0-30" id="h13-0-30" class="d">-
</a><a href="#h13-0-31" id="h13-0-31" class="d">-    /// Gets a value for a key, if it exists.
</a><a href="#h13-0-32" id="h13-0-32" class="d">-    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt;;
</a><a href="#h13-0-33" id="h13-0-33" class="d">-
</a><a href="#h13-0-34" id="h13-0-34" class="d">-    /// Iterates over an ordered range of key/value pairs.
</a><a href="#h13-0-35" id="h13-0-35" class="d">-    fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self::ScanIterator&lt;&#39;_&gt;
</a><a href="#h13-0-36" id="h13-0-36" class="d">-    where
</a><a href="#h13-0-37" id="h13-0-37" class="d">-        Self: Sized; // omit in trait objects, for object safety
</a><a href="#h13-0-38" id="h13-0-38" class="d">-
</a><a href="#h13-0-39" id="h13-0-39" class="d">-    /// Like scan, but can be used from trait objects. The iterator will use
</a><a href="#h13-0-40" id="h13-0-40" class="d">-    /// dynamic dispatch, which has a minor performance penalty.
</a><a href="#h13-0-41" id="h13-0-41" class="d">-    fn scan_dyn(
</a><a href="#h13-0-42" id="h13-0-42" class="d">-        &amp;mut self,
</a><a href="#h13-0-43" id="h13-0-43" class="d">-        range: (std::ops::Bound&lt;Vec&lt;u8&gt;&gt;, std::ops::Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h13-0-44" id="h13-0-44" class="d">-    ) -&gt; Box&lt;dyn ScanIterator + &#39;_&gt;;
</a><a href="#h13-0-45" id="h13-0-45" class="d">-
</a><a href="#h13-0-46" id="h13-0-46" class="d">-    /// Iterates over all key/value pairs starting with prefix.
</a><a href="#h13-0-47" id="h13-0-47" class="d">-    fn scan_prefix(&amp;mut self, prefix: &amp;[u8]) -&gt; Self::ScanIterator&lt;&#39;_&gt;
</a><a href="#h13-0-48" id="h13-0-48" class="d">-    where
</a><a href="#h13-0-49" id="h13-0-49" class="d">-        Self: Sized, // omit in trait objects, for object safety
</a><a href="#h13-0-50" id="h13-0-50" class="d">-    {
</a><a href="#h13-0-51" id="h13-0-51" class="d">-        let start = std::ops::Bound::Included(prefix.to_vec());
</a><a href="#h13-0-52" id="h13-0-52" class="d">-        let end = match prefix.iter().rposition(|b| *b != 0xff) {
</a><a href="#h13-0-53" id="h13-0-53" class="d">-            Some(i) =&gt; std::ops::Bound::Excluded(
</a><a href="#h13-0-54" id="h13-0-54" class="d">-                prefix.iter().take(i).copied().chain(std::iter::once(prefix[i] + 1)).collect(),
</a><a href="#h13-0-55" id="h13-0-55" class="d">-            ),
</a><a href="#h13-0-56" id="h13-0-56" class="d">-            None =&gt; std::ops::Bound::Unbounded,
</a><a href="#h13-0-57" id="h13-0-57" class="d">-        };
</a><a href="#h13-0-58" id="h13-0-58" class="d">-        self.scan((start, end))
</a><a href="#h13-0-59" id="h13-0-59" class="d">-    }
</a><a href="#h13-0-60" id="h13-0-60" class="d">-
</a><a href="#h13-0-61" id="h13-0-61" class="d">-    /// Sets a value for a key, replacing the existing value if any.
</a><a href="#h13-0-62" id="h13-0-62" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt;;
</a><a href="#h13-0-63" id="h13-0-63" class="d">-
</a><a href="#h13-0-64" id="h13-0-64" class="d">-    /// Returns engine status.
</a><a href="#h13-0-65" id="h13-0-65" class="d">-    fn status(&amp;mut self) -&gt; Result&lt;Status&gt;;
</a><a href="#h13-0-66" id="h13-0-66" class="d">-}
</a><a href="#h13-0-67" id="h13-0-67" class="d">-
</a><a href="#h13-0-68" id="h13-0-68" class="d">-/// A scan iterator, with a blanket implementation (in lieu of trait aliases).
</a><a href="#h13-0-69" id="h13-0-69" class="d">-pub trait ScanIterator: DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt; {}
</a><a href="#h13-0-70" id="h13-0-70" class="d">-
</a><a href="#h13-0-71" id="h13-0-71" class="d">-impl&lt;I: DoubleEndedIterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt;&gt; ScanIterator for I {}
</a><a href="#h13-0-72" id="h13-0-72" class="d">-
</a><a href="#h13-0-73" id="h13-0-73" class="d">-/// Engine status.
</a><a href="#h13-0-74" id="h13-0-74" class="d">-#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h13-0-75" id="h13-0-75" class="d">-pub struct Status {
</a><a href="#h13-0-76" id="h13-0-76" class="d">-    /// The name of the storage engine.
</a><a href="#h13-0-77" id="h13-0-77" class="d">-    pub name: String,
</a><a href="#h13-0-78" id="h13-0-78" class="d">-    /// The number of live keys in the engine.
</a><a href="#h13-0-79" id="h13-0-79" class="d">-    pub keys: u64,
</a><a href="#h13-0-80" id="h13-0-80" class="d">-    /// The logical size of live key/value pairs.
</a><a href="#h13-0-81" id="h13-0-81" class="d">-    pub size: u64,
</a><a href="#h13-0-82" id="h13-0-82" class="d">-    /// The on-disk size of all data, live and garbage.
</a><a href="#h13-0-83" id="h13-0-83" class="d">-    pub total_disk_size: u64,
</a><a href="#h13-0-84" id="h13-0-84" class="d">-    /// The on-disk size of live data.
</a><a href="#h13-0-85" id="h13-0-85" class="d">-    pub live_disk_size: u64,
</a><a href="#h13-0-86" id="h13-0-86" class="d">-    /// The on-disk size of garbage data.
</a><a href="#h13-0-87" id="h13-0-87" class="d">-    pub garbage_disk_size: u64,
</a><a href="#h13-0-88" id="h13-0-88" class="d">-}
</a><a href="#h13-0-89" id="h13-0-89" class="d">-
</a><a href="#h13-0-90" id="h13-0-90" class="d">-#[cfg(test)]
</a><a href="#h13-0-91" id="h13-0-91" class="d">-mod tests {
</a><a href="#h13-0-92" id="h13-0-92" class="d">-    /// Generates common tests for any Engine implementation.
</a><a href="#h13-0-93" id="h13-0-93" class="d">-    macro_rules! test_engine {
</a><a href="#h13-0-94" id="h13-0-94" class="d">-        ($setup:expr) =&gt; {
</a><a href="#h13-0-95" id="h13-0-95" class="d">-            #[track_caller]
</a><a href="#h13-0-96" id="h13-0-96" class="d">-            /// Asserts that a scan yields the expected items.
</a><a href="#h13-0-97" id="h13-0-97" class="d">-            fn assert_scan&lt;I&gt;(iter: I, expect: Vec&lt;(&amp;[u8], Vec&lt;u8&gt;)&gt;) -&gt; Result&lt;()&gt;
</a><a href="#h13-0-98" id="h13-0-98" class="d">-            where
</a><a href="#h13-0-99" id="h13-0-99" class="d">-                I: Iterator&lt;Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;&gt;,
</a><a href="#h13-0-100" id="h13-0-100" class="d">-            {
</a><a href="#h13-0-101" id="h13-0-101" class="d">-                assert_eq!(
</a><a href="#h13-0-102" id="h13-0-102" class="d">-                    iter.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h13-0-103" id="h13-0-103" class="d">-                    expect.into_iter().map(|(k, v)| (k.to_vec(), v)).collect::&lt;Vec&lt;_&gt;&gt;()
</a><a href="#h13-0-104" id="h13-0-104" class="d">-                );
</a><a href="#h13-0-105" id="h13-0-105" class="d">-                Ok(())
</a><a href="#h13-0-106" id="h13-0-106" class="d">-            }
</a><a href="#h13-0-107" id="h13-0-107" class="d">-
</a><a href="#h13-0-108" id="h13-0-108" class="d">-            /// Tests Engine point operations, i.e. set, get, and delete.
</a><a href="#h13-0-109" id="h13-0-109" class="d">-            #[test]
</a><a href="#h13-0-110" id="h13-0-110" class="d">-            fn point_ops() -&gt; Result&lt;()&gt; {
</a><a href="#h13-0-111" id="h13-0-111" class="d">-                let mut s = $setup;
</a><a href="#h13-0-112" id="h13-0-112" class="d">-
</a><a href="#h13-0-113" id="h13-0-113" class="d">-                // Getting a missing key should return None.
</a><a href="#h13-0-114" id="h13-0-114" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h13-0-115" id="h13-0-115" class="d">-
</a><a href="#h13-0-116" id="h13-0-116" class="d">-                // Setting and getting a key should return its value.
</a><a href="#h13-0-117" id="h13-0-117" class="d">-                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h13-0-118" id="h13-0-118" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![1]));
</a><a href="#h13-0-119" id="h13-0-119" class="d">-
</a><a href="#h13-0-120" id="h13-0-120" class="d">-                // Setting a different key should not affect the first.
</a><a href="#h13-0-121" id="h13-0-121" class="d">-                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h13-0-122" id="h13-0-122" class="d">-                assert_eq!(s.get(b&quot;b&quot;)?, Some(vec![2]));
</a><a href="#h13-0-123" id="h13-0-123" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![1]));
</a><a href="#h13-0-124" id="h13-0-124" class="d">-
</a><a href="#h13-0-125" id="h13-0-125" class="d">-                // Getting a different missing key should return None. The
</a><a href="#h13-0-126" id="h13-0-126" class="d">-                // comparison is case-insensitive for strings.
</a><a href="#h13-0-127" id="h13-0-127" class="d">-                assert_eq!(s.get(b&quot;c&quot;)?, None);
</a><a href="#h13-0-128" id="h13-0-128" class="d">-                assert_eq!(s.get(b&quot;A&quot;)?, None);
</a><a href="#h13-0-129" id="h13-0-129" class="d">-
</a><a href="#h13-0-130" id="h13-0-130" class="d">-                // Setting an existing key should replace its value.
</a><a href="#h13-0-131" id="h13-0-131" class="d">-                s.set(b&quot;a&quot;, vec![0])?;
</a><a href="#h13-0-132" id="h13-0-132" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, Some(vec![0]));
</a><a href="#h13-0-133" id="h13-0-133" class="d">-
</a><a href="#h13-0-134" id="h13-0-134" class="d">-                // Deleting a key should remove it, but not affect others.
</a><a href="#h13-0-135" id="h13-0-135" class="d">-                s.delete(b&quot;a&quot;)?;
</a><a href="#h13-0-136" id="h13-0-136" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h13-0-137" id="h13-0-137" class="d">-                assert_eq!(s.get(b&quot;b&quot;)?, Some(vec![2]));
</a><a href="#h13-0-138" id="h13-0-138" class="d">-
</a><a href="#h13-0-139" id="h13-0-139" class="d">-                // Deletes are idempotent.
</a><a href="#h13-0-140" id="h13-0-140" class="d">-                s.delete(b&quot;a&quot;)?;
</a><a href="#h13-0-141" id="h13-0-141" class="d">-                assert_eq!(s.get(b&quot;a&quot;)?, None);
</a><a href="#h13-0-142" id="h13-0-142" class="d">-
</a><a href="#h13-0-143" id="h13-0-143" class="d">-                Ok(())
</a><a href="#h13-0-144" id="h13-0-144" class="d">-            }
</a><a href="#h13-0-145" id="h13-0-145" class="d">-
</a><a href="#h13-0-146" id="h13-0-146" class="d">-            #[test]
</a><a href="#h13-0-147" id="h13-0-147" class="d">-            /// Tests Engine point operations on empty keys and values. These
</a><a href="#h13-0-148" id="h13-0-148" class="d">-            /// are as valid as any other key/value.
</a><a href="#h13-0-149" id="h13-0-149" class="d">-            fn point_ops_empty() -&gt; Result&lt;()&gt; {
</a><a href="#h13-0-150" id="h13-0-150" class="d">-                let mut s = $setup;
</a><a href="#h13-0-151" id="h13-0-151" class="d">-                assert_eq!(s.get(b&quot;&quot;)?, None);
</a><a href="#h13-0-152" id="h13-0-152" class="d">-                s.set(b&quot;&quot;, vec![])?;
</a><a href="#h13-0-153" id="h13-0-153" class="d">-                assert_eq!(s.get(b&quot;&quot;)?, Some(vec![]));
</a><a href="#h13-0-154" id="h13-0-154" class="d">-                s.delete(b&quot;&quot;)?;
</a><a href="#h13-0-155" id="h13-0-155" class="d">-                assert_eq!(s.get(b&quot;&quot;)?, None);
</a><a href="#h13-0-156" id="h13-0-156" class="d">-                Ok(())
</a><a href="#h13-0-157" id="h13-0-157" class="d">-            }
</a><a href="#h13-0-158" id="h13-0-158" class="d">-
</a><a href="#h13-0-159" id="h13-0-159" class="d">-            #[test]
</a><a href="#h13-0-160" id="h13-0-160" class="d">-            /// Tests Engine point operations on keys and values of increasing
</a><a href="#h13-0-161" id="h13-0-161" class="d">-            /// sizes, up to 16 MB.
</a><a href="#h13-0-162" id="h13-0-162" class="d">-            fn point_ops_sizes() -&gt; Result&lt;()&gt; {
</a><a href="#h13-0-163" id="h13-0-163" class="d">-                let mut s = $setup;
</a><a href="#h13-0-164" id="h13-0-164" class="d">-
</a><a href="#h13-0-165" id="h13-0-165" class="d">-                // Generate keys/values for increasing powers of two.
</a><a href="#h13-0-166" id="h13-0-166" class="d">-                for size in (1..=24).map(|i| 1 &lt;&lt; i) {
</a><a href="#h13-0-167" id="h13-0-167" class="d">-                    let bytes = &quot;x&quot;.repeat(size);
</a><a href="#h13-0-168" id="h13-0-168" class="d">-                    let key = bytes.as_bytes();
</a><a href="#h13-0-169" id="h13-0-169" class="d">-                    let value = bytes.clone().into_bytes();
</a><a href="#h13-0-170" id="h13-0-170" class="d">-
</a><a href="#h13-0-171" id="h13-0-171" class="d">-                    assert_eq!(s.get(key)?, None);
</a><a href="#h13-0-172" id="h13-0-172" class="d">-                    s.set(key, value.clone())?;
</a><a href="#h13-0-173" id="h13-0-173" class="d">-                    assert_eq!(s.get(key)?, Some(value));
</a><a href="#h13-0-174" id="h13-0-174" class="d">-                    s.delete(key)?;
</a><a href="#h13-0-175" id="h13-0-175" class="d">-                    assert_eq!(s.get(key)?, None);
</a><a href="#h13-0-176" id="h13-0-176" class="d">-                }
</a><a href="#h13-0-177" id="h13-0-177" class="d">-
</a><a href="#h13-0-178" id="h13-0-178" class="d">-                Ok(())
</a><a href="#h13-0-179" id="h13-0-179" class="d">-            }
</a><a href="#h13-0-180" id="h13-0-180" class="d">-
</a><a href="#h13-0-181" id="h13-0-181" class="d">-            #[test]
</a><a href="#h13-0-182" id="h13-0-182" class="d">-            /// Tests various Engine scans.
</a><a href="#h13-0-183" id="h13-0-183" class="d">-            fn scan() -&gt; Result&lt;()&gt; {
</a><a href="#h13-0-184" id="h13-0-184" class="d">-                let mut s = $setup;
</a><a href="#h13-0-185" id="h13-0-185" class="d">-                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h13-0-186" id="h13-0-186" class="d">-                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h13-0-187" id="h13-0-187" class="d">-                s.set(b&quot;ba&quot;, vec![2, 1])?;
</a><a href="#h13-0-188" id="h13-0-188" class="d">-                s.set(b&quot;bb&quot;, vec![2, 2])?;
</a><a href="#h13-0-189" id="h13-0-189" class="d">-                s.set(b&quot;c&quot;, vec![3])?;
</a><a href="#h13-0-190" id="h13-0-190" class="d">-                s.set(b&quot;C&quot;, vec![3])?;
</a><a href="#h13-0-191" id="h13-0-191" class="d">-
</a><a href="#h13-0-192" id="h13-0-192" class="d">-                // Forward/reverse scans.
</a><a href="#h13-0-193" id="h13-0-193" class="d">-                assert_scan(
</a><a href="#h13-0-194" id="h13-0-194" class="d">-                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()),
</a><a href="#h13-0-195" id="h13-0-195" class="d">-                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;bb&quot;, vec![2, 2])],
</a><a href="#h13-0-196" id="h13-0-196" class="d">-                )?;
</a><a href="#h13-0-197" id="h13-0-197" class="d">-                assert_scan(
</a><a href="#h13-0-198" id="h13-0-198" class="d">-                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bz&quot;.to_vec()).rev(),
</a><a href="#h13-0-199" id="h13-0-199" class="d">-                    vec![(b&quot;bb&quot;, vec![2, 2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;b&quot;, vec![2])],
</a><a href="#h13-0-200" id="h13-0-200" class="d">-                )?;
</a><a href="#h13-0-201" id="h13-0-201" class="d">-
</a><a href="#h13-0-202" id="h13-0-202" class="d">-                // Inclusive/exclusive ranges.
</a><a href="#h13-0-203" id="h13-0-203" class="d">-                assert_scan(
</a><a href="#h13-0-204" id="h13-0-204" class="d">-                    s.scan(b&quot;b&quot;.to_vec()..b&quot;bb&quot;.to_vec()),
</a><a href="#h13-0-205" id="h13-0-205" class="d">-                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1])],
</a><a href="#h13-0-206" id="h13-0-206" class="d">-                )?;
</a><a href="#h13-0-207" id="h13-0-207" class="d">-                assert_scan(
</a><a href="#h13-0-208" id="h13-0-208" class="d">-                    s.scan(b&quot;b&quot;.to_vec()..=b&quot;bb&quot;.to_vec()),
</a><a href="#h13-0-209" id="h13-0-209" class="d">-                    vec![(b&quot;b&quot;, vec![2]), (b&quot;ba&quot;, vec![2, 1]), (b&quot;bb&quot;, vec![2, 2])],
</a><a href="#h13-0-210" id="h13-0-210" class="d">-                )?;
</a><a href="#h13-0-211" id="h13-0-211" class="d">-
</a><a href="#h13-0-212" id="h13-0-212" class="d">-                // Open ranges.
</a><a href="#h13-0-213" id="h13-0-213" class="d">-                assert_scan(s.scan(b&quot;bb&quot;.to_vec()..), vec![(b&quot;bb&quot;, vec![2, 2]), (b&quot;c&quot;, vec![3])])?;
</a><a href="#h13-0-214" id="h13-0-214" class="d">-                assert_scan(
</a><a href="#h13-0-215" id="h13-0-215" class="d">-                    s.scan(..=b&quot;b&quot;.to_vec()),
</a><a href="#h13-0-216" id="h13-0-216" class="d">-                    vec![(b&quot;C&quot;, vec![3]), (b&quot;a&quot;, vec![1]), (b&quot;b&quot;, vec![2])],
</a><a href="#h13-0-217" id="h13-0-217" class="d">-                )?;
</a><a href="#h13-0-218" id="h13-0-218" class="d">-
</a><a href="#h13-0-219" id="h13-0-219" class="d">-                // Full range.
</a><a href="#h13-0-220" id="h13-0-220" class="d">-                assert_scan(
</a><a href="#h13-0-221" id="h13-0-221" class="d">-                    s.scan(..),
</a><a href="#h13-0-222" id="h13-0-222" class="d">-                    vec![
</a><a href="#h13-0-223" id="h13-0-223" class="d">-                        (b&quot;C&quot;, vec![3]),
</a><a href="#h13-0-224" id="h13-0-224" class="d">-                        (b&quot;a&quot;, vec![1]),
</a><a href="#h13-0-225" id="h13-0-225" class="d">-                        (b&quot;b&quot;, vec![2]),
</a><a href="#h13-0-226" id="h13-0-226" class="d">-                        (b&quot;ba&quot;, vec![2, 1]),
</a><a href="#h13-0-227" id="h13-0-227" class="d">-                        (b&quot;bb&quot;, vec![2, 2]),
</a><a href="#h13-0-228" id="h13-0-228" class="d">-                        (b&quot;c&quot;, vec![3]),
</a><a href="#h13-0-229" id="h13-0-229" class="d">-                    ],
</a><a href="#h13-0-230" id="h13-0-230" class="d">-                )?;
</a><a href="#h13-0-231" id="h13-0-231" class="d">-                Ok(())
</a><a href="#h13-0-232" id="h13-0-232" class="d">-            }
</a><a href="#h13-0-233" id="h13-0-233" class="d">-
</a><a href="#h13-0-234" id="h13-0-234" class="d">-            #[test]
</a><a href="#h13-0-235" id="h13-0-235" class="d">-            /// Tests prefix scans.
</a><a href="#h13-0-236" id="h13-0-236" class="d">-            fn scan_prefix() -&gt; Result&lt;()&gt; {
</a><a href="#h13-0-237" id="h13-0-237" class="d">-                let mut s = $setup;
</a><a href="#h13-0-238" id="h13-0-238" class="d">-                s.set(b&quot;a&quot;, vec![1])?;
</a><a href="#h13-0-239" id="h13-0-239" class="d">-                s.set(b&quot;b&quot;, vec![2])?;
</a><a href="#h13-0-240" id="h13-0-240" class="d">-                s.set(b&quot;ba&quot;, vec![2, 1])?;
</a><a href="#h13-0-241" id="h13-0-241" class="d">-                s.set(b&quot;bb&quot;, vec![2, 2])?;
</a><a href="#h13-0-242" id="h13-0-242" class="d">-                s.set(b&quot;b\xff&quot;, vec![2, 0xff])?;
</a><a href="#h13-0-243" id="h13-0-243" class="d">-                s.set(b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00])?;
</a><a href="#h13-0-244" id="h13-0-244" class="d">-                s.set(b&quot;b\xffb&quot;, vec![2, 0xff, 2])?;
</a><a href="#h13-0-245" id="h13-0-245" class="d">-                s.set(b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff])?;
</a><a href="#h13-0-246" id="h13-0-246" class="d">-                s.set(b&quot;c&quot;, vec![3])?;
</a><a href="#h13-0-247" id="h13-0-247" class="d">-                s.set(b&quot;\xff&quot;, vec![0xff])?;
</a><a href="#h13-0-248" id="h13-0-248" class="d">-                s.set(b&quot;\xff\xff&quot;, vec![0xff, 0xff])?;
</a><a href="#h13-0-249" id="h13-0-249" class="d">-                s.set(b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff])?;
</a><a href="#h13-0-250" id="h13-0-250" class="d">-                s.set(b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff])?;
</a><a href="#h13-0-251" id="h13-0-251" class="d">-
</a><a href="#h13-0-252" id="h13-0-252" class="d">-                assert_scan(
</a><a href="#h13-0-253" id="h13-0-253" class="d">-                    s.scan_prefix(b&quot;&quot;),
</a><a href="#h13-0-254" id="h13-0-254" class="d">-                    vec![
</a><a href="#h13-0-255" id="h13-0-255" class="d">-                        (b&quot;a&quot;, vec![1]),
</a><a href="#h13-0-256" id="h13-0-256" class="d">-                        (b&quot;b&quot;, vec![2]),
</a><a href="#h13-0-257" id="h13-0-257" class="d">-                        (b&quot;ba&quot;, vec![2, 1]),
</a><a href="#h13-0-258" id="h13-0-258" class="d">-                        (b&quot;bb&quot;, vec![2, 2]),
</a><a href="#h13-0-259" id="h13-0-259" class="d">-                        (b&quot;b\xff&quot;, vec![2, 0xff]),
</a><a href="#h13-0-260" id="h13-0-260" class="d">-                        (b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00]),
</a><a href="#h13-0-261" id="h13-0-261" class="d">-                        (b&quot;b\xffb&quot;, vec![2, 0xff, 2]),
</a><a href="#h13-0-262" id="h13-0-262" class="d">-                        (b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff]),
</a><a href="#h13-0-263" id="h13-0-263" class="d">-                        (b&quot;c&quot;, vec![3]),
</a><a href="#h13-0-264" id="h13-0-264" class="d">-                        (b&quot;\xff&quot;, vec![0xff]),
</a><a href="#h13-0-265" id="h13-0-265" class="d">-                        (b&quot;\xff\xff&quot;, vec![0xff, 0xff]),
</a><a href="#h13-0-266" id="h13-0-266" class="d">-                        (b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff]),
</a><a href="#h13-0-267" id="h13-0-267" class="d">-                        (b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff]),
</a><a href="#h13-0-268" id="h13-0-268" class="d">-                    ],
</a><a href="#h13-0-269" id="h13-0-269" class="d">-                )?;
</a><a href="#h13-0-270" id="h13-0-270" class="d">-
</a><a href="#h13-0-271" id="h13-0-271" class="d">-                assert_scan(
</a><a href="#h13-0-272" id="h13-0-272" class="d">-                    s.scan_prefix(b&quot;b&quot;),
</a><a href="#h13-0-273" id="h13-0-273" class="d">-                    vec![
</a><a href="#h13-0-274" id="h13-0-274" class="d">-                        (b&quot;b&quot;, vec![2]),
</a><a href="#h13-0-275" id="h13-0-275" class="d">-                        (b&quot;ba&quot;, vec![2, 1]),
</a><a href="#h13-0-276" id="h13-0-276" class="d">-                        (b&quot;bb&quot;, vec![2, 2]),
</a><a href="#h13-0-277" id="h13-0-277" class="d">-                        (b&quot;b\xff&quot;, vec![2, 0xff]),
</a><a href="#h13-0-278" id="h13-0-278" class="d">-                        (b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00]),
</a><a href="#h13-0-279" id="h13-0-279" class="d">-                        (b&quot;b\xffb&quot;, vec![2, 0xff, 2]),
</a><a href="#h13-0-280" id="h13-0-280" class="d">-                        (b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff]),
</a><a href="#h13-0-281" id="h13-0-281" class="d">-                    ],
</a><a href="#h13-0-282" id="h13-0-282" class="d">-                )?;
</a><a href="#h13-0-283" id="h13-0-283" class="d">-
</a><a href="#h13-0-284" id="h13-0-284" class="d">-                assert_scan(s.scan_prefix(b&quot;bb&quot;), vec![(b&quot;bb&quot;, vec![2, 2])])?;
</a><a href="#h13-0-285" id="h13-0-285" class="d">-
</a><a href="#h13-0-286" id="h13-0-286" class="d">-                assert_scan(s.scan_prefix(b&quot;bq&quot;), vec![])?;
</a><a href="#h13-0-287" id="h13-0-287" class="d">-
</a><a href="#h13-0-288" id="h13-0-288" class="d">-                assert_scan(
</a><a href="#h13-0-289" id="h13-0-289" class="d">-                    s.scan_prefix(b&quot;b\xff&quot;),
</a><a href="#h13-0-290" id="h13-0-290" class="d">-                    vec![
</a><a href="#h13-0-291" id="h13-0-291" class="d">-                        (b&quot;b\xff&quot;, vec![2, 0xff]),
</a><a href="#h13-0-292" id="h13-0-292" class="d">-                        (b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00]),
</a><a href="#h13-0-293" id="h13-0-293" class="d">-                        (b&quot;b\xffb&quot;, vec![2, 0xff, 2]),
</a><a href="#h13-0-294" id="h13-0-294" class="d">-                        (b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff]),
</a><a href="#h13-0-295" id="h13-0-295" class="d">-                    ],
</a><a href="#h13-0-296" id="h13-0-296" class="d">-                )?;
</a><a href="#h13-0-297" id="h13-0-297" class="d">-
</a><a href="#h13-0-298" id="h13-0-298" class="d">-                assert_scan(
</a><a href="#h13-0-299" id="h13-0-299" class="d">-                    s.scan_prefix(b&quot;b\xff\x00&quot;),
</a><a href="#h13-0-300" id="h13-0-300" class="d">-                    vec![(b&quot;b\xff\x00&quot;, vec![2, 0xff, 0x00])],
</a><a href="#h13-0-301" id="h13-0-301" class="d">-                )?;
</a><a href="#h13-0-302" id="h13-0-302" class="d">-
</a><a href="#h13-0-303" id="h13-0-303" class="d">-                assert_scan(
</a><a href="#h13-0-304" id="h13-0-304" class="d">-                    s.scan_prefix(b&quot;b\xff\xff&quot;),
</a><a href="#h13-0-305" id="h13-0-305" class="d">-                    vec![(b&quot;b\xff\xff&quot;, vec![2, 0xff, 0xff])],
</a><a href="#h13-0-306" id="h13-0-306" class="d">-                )?;
</a><a href="#h13-0-307" id="h13-0-307" class="d">-
</a><a href="#h13-0-308" id="h13-0-308" class="d">-                assert_scan(
</a><a href="#h13-0-309" id="h13-0-309" class="d">-                    s.scan_prefix(b&quot;\xff&quot;),
</a><a href="#h13-0-310" id="h13-0-310" class="d">-                    vec![
</a><a href="#h13-0-311" id="h13-0-311" class="d">-                        (b&quot;\xff&quot;, vec![0xff]),
</a><a href="#h13-0-312" id="h13-0-312" class="d">-                        (b&quot;\xff\xff&quot;, vec![0xff, 0xff]),
</a><a href="#h13-0-313" id="h13-0-313" class="d">-                        (b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff]),
</a><a href="#h13-0-314" id="h13-0-314" class="d">-                        (b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff]),
</a><a href="#h13-0-315" id="h13-0-315" class="d">-                    ],
</a><a href="#h13-0-316" id="h13-0-316" class="d">-                )?;
</a><a href="#h13-0-317" id="h13-0-317" class="d">-
</a><a href="#h13-0-318" id="h13-0-318" class="d">-                assert_scan(
</a><a href="#h13-0-319" id="h13-0-319" class="d">-                    s.scan_prefix(b&quot;\xff\xff&quot;),
</a><a href="#h13-0-320" id="h13-0-320" class="d">-                    vec![
</a><a href="#h13-0-321" id="h13-0-321" class="d">-                        (b&quot;\xff\xff&quot;, vec![0xff, 0xff]),
</a><a href="#h13-0-322" id="h13-0-322" class="d">-                        (b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff]),
</a><a href="#h13-0-323" id="h13-0-323" class="d">-                        (b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff]),
</a><a href="#h13-0-324" id="h13-0-324" class="d">-                    ],
</a><a href="#h13-0-325" id="h13-0-325" class="d">-                )?;
</a><a href="#h13-0-326" id="h13-0-326" class="d">-
</a><a href="#h13-0-327" id="h13-0-327" class="d">-                assert_scan(
</a><a href="#h13-0-328" id="h13-0-328" class="d">-                    s.scan_prefix(b&quot;\xff\xff\xff&quot;),
</a><a href="#h13-0-329" id="h13-0-329" class="d">-                    vec![
</a><a href="#h13-0-330" id="h13-0-330" class="d">-                        (b&quot;\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff]),
</a><a href="#h13-0-331" id="h13-0-331" class="d">-                        (b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff]),
</a><a href="#h13-0-332" id="h13-0-332" class="d">-                    ],
</a><a href="#h13-0-333" id="h13-0-333" class="d">-                )?;
</a><a href="#h13-0-334" id="h13-0-334" class="d">-
</a><a href="#h13-0-335" id="h13-0-335" class="d">-                assert_scan(
</a><a href="#h13-0-336" id="h13-0-336" class="d">-                    s.scan_prefix(b&quot;\xff\xff\xff\xff&quot;),
</a><a href="#h13-0-337" id="h13-0-337" class="d">-                    vec![(b&quot;\xff\xff\xff\xff&quot;, vec![0xff, 0xff, 0xff, 0xff])],
</a><a href="#h13-0-338" id="h13-0-338" class="d">-                )?;
</a><a href="#h13-0-339" id="h13-0-339" class="d">-
</a><a href="#h13-0-340" id="h13-0-340" class="d">-                assert_scan(s.scan_prefix(b&quot;\xff\xff\xff\xff\xff&quot;), vec![])?;
</a><a href="#h13-0-341" id="h13-0-341" class="d">-
</a><a href="#h13-0-342" id="h13-0-342" class="d">-                Ok(())
</a><a href="#h13-0-343" id="h13-0-343" class="d">-            }
</a><a href="#h13-0-344" id="h13-0-344" class="d">-
</a><a href="#h13-0-345" id="h13-0-345" class="d">-            #[test]
</a><a href="#h13-0-346" id="h13-0-346" class="d">-            /// Runs random operations both on a Engine and a known-good
</a><a href="#h13-0-347" id="h13-0-347" class="d">-            /// BTreeMap, comparing the results of each operation as well as the
</a><a href="#h13-0-348" id="h13-0-348" class="d">-            /// final state.
</a><a href="#h13-0-349" id="h13-0-349" class="d">-            fn random_ops() -&gt; Result&lt;()&gt; {
</a><a href="#h13-0-350" id="h13-0-350" class="d">-                const NUM_OPS: u64 = 1000;
</a><a href="#h13-0-351" id="h13-0-351" class="d">-
</a><a href="#h13-0-352" id="h13-0-352" class="d">-                use rand::{seq::SliceRandom, Rng, RngCore};
</a><a href="#h13-0-353" id="h13-0-353" class="d">-                let seed: u64 = rand::thread_rng().gen();
</a><a href="#h13-0-354" id="h13-0-354" class="d">-                let mut rng: rand::rngs::StdRng = rand::SeedableRng::seed_from_u64(seed);
</a><a href="#h13-0-355" id="h13-0-355" class="d">-                println!(&quot;seed = {}&quot;, seed);
</a><a href="#h13-0-356" id="h13-0-356" class="d">-
</a><a href="#h13-0-357" id="h13-0-357" class="d">-                #[derive(Debug)]
</a><a href="#h13-0-358" id="h13-0-358" class="d">-                enum Op {
</a><a href="#h13-0-359" id="h13-0-359" class="d">-                    Set,
</a><a href="#h13-0-360" id="h13-0-360" class="d">-                    Delete,
</a><a href="#h13-0-361" id="h13-0-361" class="d">-                    Get,
</a><a href="#h13-0-362" id="h13-0-362" class="d">-                    Scan,
</a><a href="#h13-0-363" id="h13-0-363" class="d">-                }
</a><a href="#h13-0-364" id="h13-0-364" class="d">-
</a><a href="#h13-0-365" id="h13-0-365" class="d">-                impl rand::distributions::Distribution&lt;Op&gt; for rand::distributions::Standard {
</a><a href="#h13-0-366" id="h13-0-366" class="d">-                    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; Op {
</a><a href="#h13-0-367" id="h13-0-367" class="d">-                        match rng.gen_range(0..=3) {
</a><a href="#h13-0-368" id="h13-0-368" class="d">-                            0 =&gt; Op::Set,
</a><a href="#h13-0-369" id="h13-0-369" class="d">-                            1 =&gt; Op::Delete,
</a><a href="#h13-0-370" id="h13-0-370" class="d">-                            2 =&gt; Op::Get,
</a><a href="#h13-0-371" id="h13-0-371" class="d">-                            3 =&gt; Op::Scan,
</a><a href="#h13-0-372" id="h13-0-372" class="d">-                            _ =&gt; panic!(&quot;unexpected value&quot;),
</a><a href="#h13-0-373" id="h13-0-373" class="d">-                        }
</a><a href="#h13-0-374" id="h13-0-374" class="d">-                    }
</a><a href="#h13-0-375" id="h13-0-375" class="d">-                }
</a><a href="#h13-0-376" id="h13-0-376" class="d">-
</a><a href="#h13-0-377" id="h13-0-377" class="d">-                let mut s = $setup;
</a><a href="#h13-0-378" id="h13-0-378" class="d">-                let mut keys: Vec&lt;Vec&lt;u8&gt;&gt; = Vec::new();
</a><a href="#h13-0-379" id="h13-0-379" class="d">-                let mut m = std::collections::BTreeMap::new();
</a><a href="#h13-0-380" id="h13-0-380" class="d">-
</a><a href="#h13-0-381" id="h13-0-381" class="d">-                // Pick an already-used key with 80% probability, or generate a
</a><a href="#h13-0-382" id="h13-0-382" class="d">-                // new key.
</a><a href="#h13-0-383" id="h13-0-383" class="d">-                let mut random_key = |mut rng: &amp;mut rand::rngs::StdRng| -&gt; Vec&lt;u8&gt; {
</a><a href="#h13-0-384" id="h13-0-384" class="d">-                    if rng.gen::&lt;f64&gt;() &lt; 0.8 &amp;&amp; !keys.is_empty() {
</a><a href="#h13-0-385" id="h13-0-385" class="d">-                        keys.choose(&amp;mut rng).unwrap().clone()
</a><a href="#h13-0-386" id="h13-0-386" class="d">-                    } else {
</a><a href="#h13-0-387" id="h13-0-387" class="d">-                        let mut key = vec![0; rng.gen_range(0..=16)];
</a><a href="#h13-0-388" id="h13-0-388" class="d">-                        rng.fill_bytes(&amp;mut key);
</a><a href="#h13-0-389" id="h13-0-389" class="d">-                        keys.push(key.clone());
</a><a href="#h13-0-390" id="h13-0-390" class="d">-                        key
</a><a href="#h13-0-391" id="h13-0-391" class="d">-                    }
</a><a href="#h13-0-392" id="h13-0-392" class="d">-                };
</a><a href="#h13-0-393" id="h13-0-393" class="d">-
</a><a href="#h13-0-394" id="h13-0-394" class="d">-                let random_value = |rng: &amp;mut rand::rngs::StdRng| -&gt; Vec&lt;u8&gt; {
</a><a href="#h13-0-395" id="h13-0-395" class="d">-                    let mut value = vec![0; rng.gen_range(0..=16)];
</a><a href="#h13-0-396" id="h13-0-396" class="d">-                    rng.fill_bytes(&amp;mut value);
</a><a href="#h13-0-397" id="h13-0-397" class="d">-                    value
</a><a href="#h13-0-398" id="h13-0-398" class="d">-                };
</a><a href="#h13-0-399" id="h13-0-399" class="d">-
</a><a href="#h13-0-400" id="h13-0-400" class="d">-                // Run random operations.
</a><a href="#h13-0-401" id="h13-0-401" class="d">-                for _ in 0..NUM_OPS {
</a><a href="#h13-0-402" id="h13-0-402" class="d">-                    match rng.gen::&lt;Op&gt;() {
</a><a href="#h13-0-403" id="h13-0-403" class="d">-                        Op::Set =&gt; {
</a><a href="#h13-0-404" id="h13-0-404" class="d">-                            let key = random_key(&amp;mut rng);
</a><a href="#h13-0-405" id="h13-0-405" class="d">-                            let value = random_value(&amp;mut rng);
</a><a href="#h13-0-406" id="h13-0-406" class="d">-                            println!(&quot;set {:?} = {:?}&quot;, key, value);
</a><a href="#h13-0-407" id="h13-0-407" class="d">-                            s.set(&amp;key, value.clone())?;
</a><a href="#h13-0-408" id="h13-0-408" class="d">-                            m.insert(key, value);
</a><a href="#h13-0-409" id="h13-0-409" class="d">-                        }
</a><a href="#h13-0-410" id="h13-0-410" class="d">-                        Op::Delete =&gt; {
</a><a href="#h13-0-411" id="h13-0-411" class="d">-                            let key = random_key(&amp;mut rng);
</a><a href="#h13-0-412" id="h13-0-412" class="d">-                            println!(&quot;delete {:?}&quot;, key);
</a><a href="#h13-0-413" id="h13-0-413" class="d">-                            s.delete(&amp;key)?;
</a><a href="#h13-0-414" id="h13-0-414" class="d">-                            m.remove(&amp;key);
</a><a href="#h13-0-415" id="h13-0-415" class="d">-                        }
</a><a href="#h13-0-416" id="h13-0-416" class="d">-                        Op::Get =&gt; {
</a><a href="#h13-0-417" id="h13-0-417" class="d">-                            let key = random_key(&amp;mut rng);
</a><a href="#h13-0-418" id="h13-0-418" class="d">-                            let value = s.get(&amp;key)?;
</a><a href="#h13-0-419" id="h13-0-419" class="d">-                            let expect = m.get(&amp;key).cloned();
</a><a href="#h13-0-420" id="h13-0-420" class="d">-                            println!(&quot;get {:?} =&gt; {:?}&quot;, key, value);
</a><a href="#h13-0-421" id="h13-0-421" class="d">-                            assert_eq!(value, expect);
</a><a href="#h13-0-422" id="h13-0-422" class="d">-                        }
</a><a href="#h13-0-423" id="h13-0-423" class="d">-                        Op::Scan =&gt; {
</a><a href="#h13-0-424" id="h13-0-424" class="d">-                            let mut from = random_key(&amp;mut rng);
</a><a href="#h13-0-425" id="h13-0-425" class="d">-                            let mut to = random_key(&amp;mut rng);
</a><a href="#h13-0-426" id="h13-0-426" class="d">-                            if (to &lt; from) {
</a><a href="#h13-0-427" id="h13-0-427" class="d">-                                (from, to) = (to, from)
</a><a href="#h13-0-428" id="h13-0-428" class="d">-                            }
</a><a href="#h13-0-429" id="h13-0-429" class="d">-                            println!(&quot;scan {:?} .. {:?}&quot;, from, to);
</a><a href="#h13-0-430" id="h13-0-430" class="d">-                            let result =
</a><a href="#h13-0-431" id="h13-0-431" class="d">-                                s.scan(from.clone()..to.clone()).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h13-0-432" id="h13-0-432" class="d">-                            let expect = m
</a><a href="#h13-0-433" id="h13-0-433" class="d">-                                .range(from..to)
</a><a href="#h13-0-434" id="h13-0-434" class="d">-                                .map(|(k, v)| (k.clone(), v.clone()))
</a><a href="#h13-0-435" id="h13-0-435" class="d">-                                .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h13-0-436" id="h13-0-436" class="d">-                            assert_eq!(result, expect);
</a><a href="#h13-0-437" id="h13-0-437" class="d">-                        }
</a><a href="#h13-0-438" id="h13-0-438" class="d">-                    }
</a><a href="#h13-0-439" id="h13-0-439" class="d">-                }
</a><a href="#h13-0-440" id="h13-0-440" class="d">-
</a><a href="#h13-0-441" id="h13-0-441" class="d">-                // Compare the final states.
</a><a href="#h13-0-442" id="h13-0-442" class="d">-                println!(&quot;comparing final state&quot;);
</a><a href="#h13-0-443" id="h13-0-443" class="d">-
</a><a href="#h13-0-444" id="h13-0-444" class="d">-                let state = s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
</a><a href="#h13-0-445" id="h13-0-445" class="d">-                let expect = m
</a><a href="#h13-0-446" id="h13-0-446" class="d">-                    .range::&lt;Vec&lt;u8&gt;, _&gt;(..)
</a><a href="#h13-0-447" id="h13-0-447" class="d">-                    .map(|(k, v)| (k.clone(), v.clone()))
</a><a href="#h13-0-448" id="h13-0-448" class="d">-                    .collect::&lt;Vec&lt;_&gt;&gt;();
</a><a href="#h13-0-449" id="h13-0-449" class="d">-                assert_eq!(state, expect);
</a><a href="#h13-0-450" id="h13-0-450" class="d">-
</a><a href="#h13-0-451" id="h13-0-451" class="d">-                Ok(())
</a><a href="#h13-0-452" id="h13-0-452" class="d">-            }
</a><a href="#h13-0-453" id="h13-0-453" class="d">-
</a><a href="#h13-0-454" id="h13-0-454" class="d">-            #[test]
</a><a href="#h13-0-455" id="h13-0-455" class="d">-            /// Tests implementation-independent aspects of Status.
</a><a href="#h13-0-456" id="h13-0-456" class="d">-            fn status() -&gt; Result&lt;()&gt; {
</a><a href="#h13-0-457" id="h13-0-457" class="d">-                let mut s = $setup;
</a><a href="#h13-0-458" id="h13-0-458" class="d">-                s.set(b&quot;foo&quot;, vec![1, 2, 3])?;
</a><a href="#h13-0-459" id="h13-0-459" class="d">-                s.set(b&quot;bar&quot;, vec![1])?;
</a><a href="#h13-0-460" id="h13-0-460" class="d">-                s.delete(b&quot;bar&quot;)?;
</a><a href="#h13-0-461" id="h13-0-461" class="d">-                s.set(b&quot;baz&quot;, vec![1])?;
</a><a href="#h13-0-462" id="h13-0-462" class="d">-                s.set(b&quot;baz&quot;, vec![2])?;
</a><a href="#h13-0-463" id="h13-0-463" class="d">-                s.set(b&quot;baz&quot;, vec![3])?;
</a><a href="#h13-0-464" id="h13-0-464" class="d">-                s.delete(b&quot;qux&quot;)?;
</a><a href="#h13-0-465" id="h13-0-465" class="d">-
</a><a href="#h13-0-466" id="h13-0-466" class="d">-                let status = s.status()?;
</a><a href="#h13-0-467" id="h13-0-467" class="d">-                assert!(status.name.len() &gt; 0);
</a><a href="#h13-0-468" id="h13-0-468" class="d">-                assert_eq!(status.keys, 2);
</a><a href="#h13-0-469" id="h13-0-469" class="d">-                assert_eq!(status.size, 10);
</a><a href="#h13-0-470" id="h13-0-470" class="d">-
</a><a href="#h13-0-471" id="h13-0-471" class="d">-                Ok(())
</a><a href="#h13-0-472" id="h13-0-472" class="d">-            }
</a><a href="#h13-0-473" id="h13-0-473" class="d">-        };
</a><a href="#h13-0-474" id="h13-0-474" class="d">-    }
</a><a href="#h13-0-475" id="h13-0-475" class="d">-
</a><a href="#h13-0-476" id="h13-0-476" class="d">-    pub(super) use test_engine; // export for use in submodules
</a><a href="#h13-0-477" id="h13-0-477" class="d">-}
</a><b>diff --git a/<a id="h14" href="../file/src/storage/memory.rs.html">src/storage/memory.rs</a> b/<a href="../file/src/storage/memory.rs.html">src/storage/memory.rs</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -0,0 +1,97 @@
</a><a href="#h14-0-0" id="h14-0-0" class="i">+use super::{Engine, Status};
</a><a href="#h14-0-1" id="h14-0-1" class="i">+use crate::error::Result;
</a><a href="#h14-0-2" id="h14-0-2" class="i">+
</a><a href="#h14-0-3" id="h14-0-3" class="i">+/// An in-memory key/value storage engine using the Rust standard library B-tree
</a><a href="#h14-0-4" id="h14-0-4" class="i">+/// implementation. Data is not persisted.
</a><a href="#h14-0-5" id="h14-0-5" class="i">+pub struct Memory {
</a><a href="#h14-0-6" id="h14-0-6" class="i">+    data: std::collections::BTreeMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h14-0-7" id="h14-0-7" class="i">+}
</a><a href="#h14-0-8" id="h14-0-8" class="i">+
</a><a href="#h14-0-9" id="h14-0-9" class="i">+impl Memory {
</a><a href="#h14-0-10" id="h14-0-10" class="i">+    /// Creates a new Memory key-value storage engine.
</a><a href="#h14-0-11" id="h14-0-11" class="i">+    pub fn new() -&gt; Self {
</a><a href="#h14-0-12" id="h14-0-12" class="i">+        Self { data: std::collections::BTreeMap::new() }
</a><a href="#h14-0-13" id="h14-0-13" class="i">+    }
</a><a href="#h14-0-14" id="h14-0-14" class="i">+}
</a><a href="#h14-0-15" id="h14-0-15" class="i">+
</a><a href="#h14-0-16" id="h14-0-16" class="i">+impl std::fmt::Display for Memory {
</a><a href="#h14-0-17" id="h14-0-17" class="i">+    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
</a><a href="#h14-0-18" id="h14-0-18" class="i">+        write!(f, &quot;memory&quot;)
</a><a href="#h14-0-19" id="h14-0-19" class="i">+    }
</a><a href="#h14-0-20" id="h14-0-20" class="i">+}
</a><a href="#h14-0-21" id="h14-0-21" class="i">+
</a><a href="#h14-0-22" id="h14-0-22" class="i">+impl Engine for Memory {
</a><a href="#h14-0-23" id="h14-0-23" class="i">+    type ScanIterator&lt;&#39;a&gt; = ScanIterator&lt;&#39;a&gt;;
</a><a href="#h14-0-24" id="h14-0-24" class="i">+
</a><a href="#h14-0-25" id="h14-0-25" class="i">+    fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
</a><a href="#h14-0-26" id="h14-0-26" class="i">+        Ok(())
</a><a href="#h14-0-27" id="h14-0-27" class="i">+    }
</a><a href="#h14-0-28" id="h14-0-28" class="i">+
</a><a href="#h14-0-29" id="h14-0-29" class="i">+    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
</a><a href="#h14-0-30" id="h14-0-30" class="i">+        self.data.remove(key);
</a><a href="#h14-0-31" id="h14-0-31" class="i">+        Ok(())
</a><a href="#h14-0-32" id="h14-0-32" class="i">+    }
</a><a href="#h14-0-33" id="h14-0-33" class="i">+
</a><a href="#h14-0-34" id="h14-0-34" class="i">+    fn get(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {
</a><a href="#h14-0-35" id="h14-0-35" class="i">+        Ok(self.data.get(key).cloned())
</a><a href="#h14-0-36" id="h14-0-36" class="i">+    }
</a><a href="#h14-0-37" id="h14-0-37" class="i">+
</a><a href="#h14-0-38" id="h14-0-38" class="i">+    fn scan(&amp;mut self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Self::ScanIterator&lt;&#39;_&gt; {
</a><a href="#h14-0-39" id="h14-0-39" class="i">+        ScanIterator { inner: self.data.range(range) }
</a><a href="#h14-0-40" id="h14-0-40" class="i">+    }
</a><a href="#h14-0-41" id="h14-0-41" class="i">+
</a><a href="#h14-0-42" id="h14-0-42" class="i">+    fn scan_dyn(
</a><a href="#h14-0-43" id="h14-0-43" class="i">+        &amp;mut self,
</a><a href="#h14-0-44" id="h14-0-44" class="i">+        range: (std::ops::Bound&lt;Vec&lt;u8&gt;&gt;, std::ops::Bound&lt;Vec&lt;u8&gt;&gt;),
</a><a href="#h14-0-45" id="h14-0-45" class="i">+    ) -&gt; Box&lt;dyn super::ScanIterator + &#39;_&gt; {
</a><a href="#h14-0-46" id="h14-0-46" class="i">+        Box::new(self.scan(range))
</a><a href="#h14-0-47" id="h14-0-47" class="i">+    }
</a><a href="#h14-0-48" id="h14-0-48" class="i">+
</a><a href="#h14-0-49" id="h14-0-49" class="i">+    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
</a><a href="#h14-0-50" id="h14-0-50" class="i">+        self.data.insert(key.to_vec(), value);
</a><a href="#h14-0-51" id="h14-0-51" class="i">+        Ok(())
</a><a href="#h14-0-52" id="h14-0-52" class="i">+    }
</a><a href="#h14-0-53" id="h14-0-53" class="i">+
</a><a href="#h14-0-54" id="h14-0-54" class="i">+    fn status(&amp;mut self) -&gt; Result&lt;Status&gt; {
</a><a href="#h14-0-55" id="h14-0-55" class="i">+        Ok(Status {
</a><a href="#h14-0-56" id="h14-0-56" class="i">+            name: self.to_string(),
</a><a href="#h14-0-57" id="h14-0-57" class="i">+            keys: self.data.len() as u64,
</a><a href="#h14-0-58" id="h14-0-58" class="i">+            size: self.data.iter().fold(0, |size, (k, v)| size + k.len() as u64 + v.len() as u64),
</a><a href="#h14-0-59" id="h14-0-59" class="i">+            total_disk_size: 0,
</a><a href="#h14-0-60" id="h14-0-60" class="i">+            live_disk_size: 0,
</a><a href="#h14-0-61" id="h14-0-61" class="i">+            garbage_disk_size: 0,
</a><a href="#h14-0-62" id="h14-0-62" class="i">+        })
</a><a href="#h14-0-63" id="h14-0-63" class="i">+    }
</a><a href="#h14-0-64" id="h14-0-64" class="i">+}
</a><a href="#h14-0-65" id="h14-0-65" class="i">+
</a><a href="#h14-0-66" id="h14-0-66" class="i">+pub struct ScanIterator&lt;&#39;a&gt; {
</a><a href="#h14-0-67" id="h14-0-67" class="i">+    inner: std::collections::btree_map::Range&lt;&#39;a, Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h14-0-68" id="h14-0-68" class="i">+}
</a><a href="#h14-0-69" id="h14-0-69" class="i">+
</a><a href="#h14-0-70" id="h14-0-70" class="i">+impl&lt;&#39;a&gt; ScanIterator&lt;&#39;a&gt; {
</a><a href="#h14-0-71" id="h14-0-71" class="i">+    fn map(item: (&amp;Vec&lt;u8&gt;, &amp;Vec&lt;u8&gt;)) -&gt; &lt;Self as Iterator&gt;::Item {
</a><a href="#h14-0-72" id="h14-0-72" class="i">+        let (key, value) = item;
</a><a href="#h14-0-73" id="h14-0-73" class="i">+        Ok((key.clone(), value.clone()))
</a><a href="#h14-0-74" id="h14-0-74" class="i">+    }
</a><a href="#h14-0-75" id="h14-0-75" class="i">+}
</a><a href="#h14-0-76" id="h14-0-76" class="i">+
</a><a href="#h14-0-77" id="h14-0-77" class="i">+impl&lt;&#39;a&gt; Iterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h14-0-78" id="h14-0-78" class="i">+    type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt;;
</a><a href="#h14-0-79" id="h14-0-79" class="i">+
</a><a href="#h14-0-80" id="h14-0-80" class="i">+    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h14-0-81" id="h14-0-81" class="i">+        self.inner.next().map(Self::map)
</a><a href="#h14-0-82" id="h14-0-82" class="i">+    }
</a><a href="#h14-0-83" id="h14-0-83" class="i">+}
</a><a href="#h14-0-84" id="h14-0-84" class="i">+
</a><a href="#h14-0-85" id="h14-0-85" class="i">+impl&lt;&#39;a&gt; DoubleEndedIterator for ScanIterator&lt;&#39;a&gt; {
</a><a href="#h14-0-86" id="h14-0-86" class="i">+    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</a><a href="#h14-0-87" id="h14-0-87" class="i">+        self.inner.next_back().map(Self::map)
</a><a href="#h14-0-88" id="h14-0-88" class="i">+    }
</a><a href="#h14-0-89" id="h14-0-89" class="i">+}
</a><a href="#h14-0-90" id="h14-0-90" class="i">+
</a><a href="#h14-0-91" id="h14-0-91" class="i">+#[cfg(test)]
</a><a href="#h14-0-92" id="h14-0-92" class="i">+mod tests {
</a><a href="#h14-0-93" id="h14-0-93" class="i">+    use super::*;
</a><a href="#h14-0-94" id="h14-0-94" class="i">+
</a><a href="#h14-0-95" id="h14-0-95" class="i">+    super::super::engine::tests::test_engine!(Memory::new());
</a><a href="#h14-0-96" id="h14-0-96" class="i">+}
</a><b>diff --git a/<a id="h15" href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a> b/<a href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -1,3 +1,11 @@
</a><a href="#h15-0-0" id="h15-0-0" class="i">+mod bitcask;
</a> pub mod debug;
 pub mod engine;
<a href="#h15-0-3" id="h15-0-3" class="i">+mod memory;
</a> pub mod mvcc;
<a href="#h15-0-5" id="h15-0-5" class="i">+
</a><a href="#h15-0-6" id="h15-0-6" class="i">+pub use bitcask::BitCask;
</a><a href="#h15-0-7" id="h15-0-7" class="i">+#[cfg(test)]
</a><a href="#h15-0-8" id="h15-0-8" class="i">+pub use debug::Engine as Debug;
</a><a href="#h15-0-9" id="h15-0-9" class="i">+pub use engine::{Engine, ScanIterator, Status};
</a><a href="#h15-0-10" id="h15-0-10" class="i">+pub use memory::Memory;
</a><b>diff --git a/<a id="h16" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -787,7 +787,7 @@ impl&lt;&#39;a, E: Engine&gt; DoubleEndedIterator for VersionIterator&lt;&#39;a, E&gt; {
</a> #[cfg(test)]
 pub mod tests {
     use super::super::debug;
<a href="#h16-0-3" id="h16-0-3" class="d">-    use super::super::engine::{Debug, Memory};
</a><a href="#h16-0-4" id="h16-0-4" class="i">+    use super::super::{Debug, Memory};
</a>     use super::*;
     use std::collections::HashMap;
     use std::io::Write as _;
<b>diff --git a/<a id="h17" href="../file/tests/sql/mod.rs.html">tests/sql/mod.rs</a> b/<a href="../file/tests/sql/mod.rs.html">tests/sql/mod.rs</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -8,8 +8,8 @@ use toydb::sql::engine::{Engine, KV};
</a> use toydb::storage;
 
 /// Sets up a basic in-memory SQL engine with an initial dataset.
<a href="#h17-0-3" id="h17-0-3" class="d">-fn setup(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;KV&lt;storage::engine::Memory&gt;&gt; {
</a><a href="#h17-0-4" id="h17-0-4" class="d">-    let engine = KV::new(storage::engine::Memory::new());
</a><a href="#h17-0-5" id="h17-0-5" class="i">+fn setup(queries: Vec&lt;&amp;str&gt;) -&gt; Result&lt;KV&lt;storage::Memory&gt;&gt; {
</a><a href="#h17-0-6" id="h17-0-6" class="i">+    let engine = KV::new(storage::Memory::new());
</a>     let mut session = engine.session();
     session.execute(&quot;BEGIN&quot;)?;
     for query in queries {
</pre>
</div>
</body>
</html>
