<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>raft: rewrite state and request handling (fixes #28, fixes #22, fixes #19) - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/eba168643fe471da2c7b1e8319c0a425f7aba597.html">eba168643fe471da2c7b1e8319c0a425f7aba597</a>
<b>parent</b> <a href="../commit/e68e0b9ba57e6a74f65f134296ed4986218f0ea4.html">e68e0b9ba57e6a74f65f134296ed4986218f0ea4</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun,  3 May 2020 19:31:12 +0200

raft: rewrite state and request handling (fixes #28, fixes #22, fixes #19)

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">README.md</a></td><td> | </td><td class="num">12</td><td><span class="i">+++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/bin/toydb.rs</a></td><td> | </td><td class="num">3</td><td><span class="i">++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/client.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">+++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/error.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/kv/mvcc.rs</a></td><td> | </td><td class="num">30</td><td><span class="i">++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/raft/client.rs</a></td><td> | </td><td class="num">48</td><td><span class="i">++++++</span><span class="d">------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/raft/log.rs</a></td><td> | </td><td class="num">524</td><td><span class="i">++++++++++++++++++++++++++++++++</span><span class="d">-----------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/raft/message.rs</a></td><td> | </td><td class="num">191</td><td><span class="i">++++++++++++++++++</span><span class="d">-------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/raft/mod.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">286</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-----------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/raft/node/follower.rs</a></td><td> | </td><td class="num">849</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">src/raft/node/leader.rs</a></td><td> | </td><td class="num">855</td><td><span class="i">++++++++++++++++++++++++++++++++</span><span class="d">-----------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">src/raft/node/mod.rs</a></td><td> | </td><td class="num">411</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h13">src/raft/server.rs</a></td><td> | </td><td class="num">142</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h14">src/raft/state.rs</a></td><td> | </td><td class="num">390</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h15">src/server.rs</a></td><td> | </td><td class="num">47</td><td><span class="i">+++++++++++++++++++</span><span class="d">----------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h16">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">27</td><td><span class="i">+++++++++++++++++++</span><span class="d">--------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h17">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">116</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h18">tests/client/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h19">tests/setup.rs</a></td><td> | </td><td class="num">9</td><td><span class="i">++</span><span class="d">-------</span></td></tr>
</table></pre><pre>20 files changed, 2121 insertions(+), 1847 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/README.md.html">README.md</a> b/<a href="../file/README.md.html">README.md</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -8,7 +8,7 @@ Distributed SQL database in Rust, written as a learning project. Most components
</a> 
 * ACID-compliant transaction engine with MVCC-based snapshot isolation.
 
<a href="#h0-0-3" id="h0-0-3" class="d">-* Iterator-based query engine with heuristic optimization, secondary indexes, and time-travel support.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+* Iterator-based query engine with heuristic optimization and time-travel support.
</a> 
 * SQL interface including projections, filters, joins, and aggregates.
 
<a href="#h0-1" id="h0-1" class="h">@@ -86,17 +86,15 @@ The primary goal is to build a minimally functional yet correct distributed data
</a> 
 ### Networking
 
<a href="#h0-1-3" id="h0-1-3" class="d">-* **No security:** all network traffic is unauthenticated and in plaintext; any request from any source is accepted.
</a><a href="#h0-1-4" id="h0-1-4" class="i">+* **No security:** all network traffic is unauthenticated and in plaintext.
</a> 
 ### Raft
 
 * **Cluster reconfiguration:** the Raft cluster must consist of a static set of nodes available via static IP addresses. It is not possible to resize the cluster without a full cluster restart.
 
<a href="#h0-1-10" id="h0-1-10" class="d">-* **Single node processing:** all operations (both reads and writes) are processed by a single Raft thread on a single node (the master), and the system consists of a single Raft cluster, preventing horizontal scalability and efficient resource utilization.
</a><a href="#h0-1-11" id="h0-1-11" class="i">+* **Single-threaded state:** all state machine operations are processed by a single thread on a single node, preventing horizontal scalability.
</a> 
<a href="#h0-1-13" id="h0-1-13" class="d">-* **Client call retries:** there is currently no retries of client-submitted operations, and if a node processing or proxying an operation changes role then the call is dropped.
</a><a href="#h0-1-14" id="h0-1-14" class="d">-
</a><a href="#h0-1-15" id="h0-1-15" class="d">-* **Log replication optimization:** currently only the simplest version of the Raft log replication protocol is implemented, without snapshots or rapid log replay (i.e. replication of old log entries is retried one by one until a common base entry is found).
</a><a href="#h0-1-16" id="h0-1-16" class="i">+* **Log replication:** only the simplest form of Raft log replication is implemented, without snapshots or rapid log replay.
</a> 
 ### Storage
 
<a href="#h0-2" id="h0-2" class="h">@@ -118,7 +116,7 @@ The primary goal is to build a minimally functional yet correct distributed data
</a> 
 * **Single database:** only a single, unnamed database is supported per ToyDB cluster.
 
<a href="#h0-2-3" id="h0-2-3" class="d">-* **Schema changes:** schema changes other than creating or dropping tables and indexes is not supported, i.e. there is no `ALTER TABLE`.
</a><a href="#h0-2-4" id="h0-2-4" class="i">+* **Schema changes:** schema changes other than creating or dropping tables is not supported.
</a> 
 ### Query Engine
 
<b>diff --git a/<a id="h1" href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a> b/<a href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -26,7 +26,8 @@ async fn main() -&gt; Result&lt;(), toydb::Error&gt; {
</a>     }
     simplelog::SimpleLogger::init(loglevel, logconfig.build())?;
 
<a href="#h1-0-3" id="h1-0-3" class="d">-    Server::new(&amp;cfg.id, cfg.peers, &amp;cfg.data_dir)?
</a><a href="#h1-0-4" id="h1-0-4" class="i">+    Server::new(&amp;cfg.id, cfg.peers, &amp;cfg.data_dir)
</a><a href="#h1-0-5" id="h1-0-5" class="i">+        .await?
</a>         .listen(&amp;cfg.listen_sql, &amp;cfg.listen_raft)
         .await?
         .serve()
<b>diff --git a/<a id="h2" href="../file/src/client.rs.html">src/client.rs</a> b/<a href="../file/src/client.rs.html">src/client.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -16,9 +16,9 @@ use tokio_util::codec::{Framed, LengthDelimitedCodec};
</a> 
 type Connection = tokio_serde::Framed&lt;
     Framed&lt;TcpStream, LengthDelimitedCodec&gt;,
<a href="#h2-0-3" id="h2-0-3" class="d">-    Response,
</a><a href="#h2-0-4" id="h2-0-4" class="i">+    Result&lt;Response, Error&gt;,
</a>     Request,
<a href="#h2-0-6" id="h2-0-6" class="d">-    tokio_serde::formats::Cbor&lt;Response, Request&gt;,
</a><a href="#h2-0-7" id="h2-0-7" class="i">+    tokio_serde::formats::Cbor&lt;Result&lt;Response, Error&gt;, Request&gt;,
</a> &gt;;
 
 /// A ToyDB client
<a href="#h2-1" id="h2-1" class="h">@@ -53,8 +53,7 @@ impl Client {
</a>     ) -&gt; Result&lt;Response, Error&gt; {
         conn.send(request).await?;
         match conn.try_next().await? {
<a href="#h2-1-3" id="h2-1-3" class="d">-            Some(Response::Error(err)) =&gt; Err(err),
</a><a href="#h2-1-4" id="h2-1-4" class="d">-            Some(response) =&gt; Ok(response),
</a><a href="#h2-1-5" id="h2-1-5" class="i">+            Some(result) =&gt; result,
</a>             None =&gt; Err(Error::Internal(&quot;Server disconnected&quot;.into())),
         }
     }
<a href="#h2-2" id="h2-2" class="h">@@ -70,11 +69,10 @@ impl Client {
</a>         if let ResultSet::Query { ref mut relation } = &amp;mut resultset {
             // FIXME We buffer rows for now to avoid lifetime hassles
             let mut rows = Vec::new();
<a href="#h2-2-3" id="h2-2-3" class="d">-            while let Some(response) = conn.try_next().await? {
</a><a href="#h2-2-4" id="h2-2-4" class="d">-                match response {
</a><a href="#h2-2-5" id="h2-2-5" class="i">+            while let Some(result) = conn.try_next().await? {
</a><a href="#h2-2-6" id="h2-2-6" class="i">+                match result? {
</a>                     Response::Row(Some(row)) =&gt; rows.push(row),
                     Response::Row(None) =&gt; break,
<a href="#h2-2-9" id="h2-2-9" class="d">-                    Response::Error(error) =&gt; return Err(error),
</a>                     response =&gt; {
                         return Err(Error::Internal(format!(&quot;Unexpected response {:?}&quot;, response)))
                     }
<b>diff --git a/<a id="h3" href="../file/src/error.rs.html">src/error.rs</a> b/<a href="../file/src/error.rs.html">src/error.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -3,6 +3,7 @@ use serde_derive::{Deserialize, Serialize};
</a> /// Errors, all except Internal are considered user-facing
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Error {
<a href="#h3-0-3" id="h3-0-3" class="i">+    Abort,
</a>     Config(String),
     Internal(String),
     Parse(String),
<a href="#h3-1" id="h3-1" class="h">@@ -17,6 +18,7 @@ impl std::fmt::Display for Error {
</a>             Error::Config(s) | Error::Internal(s) | Error::Parse(s) | Error::Value(s) =&gt; {
                 write!(f, &quot;{}&quot;, s)
             }
<a href="#h3-1-3" id="h3-1-3" class="i">+            Error::Abort =&gt; write!(f, &quot;Operation aborted&quot;),
</a>             Error::Serialization =&gt; write!(f, &quot;Serialization failure, retry transaction&quot;),
             Error::ReadOnly =&gt; write!(f, &quot;Read-only transaction&quot;),
         }
<a href="#h3-2" id="h3-2" class="h">@@ -118,3 +120,9 @@ impl&lt;T&gt; From&lt;tokio::sync::mpsc::error::SendError&lt;T&gt;&gt; for Error {
</a>         Error::Internal(err.to_string())
     }
 }
<a href="#h3-2-3" id="h3-2-3" class="i">+
</a><a href="#h3-2-4" id="h3-2-4" class="i">+impl&lt;T&gt; From&lt;tokio::sync::mpsc::error::TrySendError&lt;T&gt;&gt; for Error {
</a><a href="#h3-2-5" id="h3-2-5" class="i">+    fn from(err: tokio::sync::mpsc::error::TrySendError&lt;T&gt;) -&gt; Self {
</a><a href="#h3-2-6" id="h3-2-6" class="i">+        Error::Internal(err.to_string())
</a><a href="#h3-2-7" id="h3-2-7" class="i">+    }
</a><a href="#h3-2-8" id="h3-2-8" class="i">+}
</a><b>diff --git a/<a id="h4" href="../file/src/kv/mvcc.rs.html">src/kv/mvcc.rs</a> b/<a href="../file/src/kv/mvcc.rs.html">src/kv/mvcc.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -42,6 +42,18 @@ impl&lt;S: Storage&gt; MVCC&lt;S&gt; {
</a>     pub fn resume(&amp;self, id: u64) -&gt; Result&lt;Transaction&lt;S&gt;, Error&gt; {
         Transaction::resume(self.storage.clone(), id)
     }
<a href="#h4-0-3" id="h4-0-3" class="i">+
</a><a href="#h4-0-4" id="h4-0-4" class="i">+    /// Fetches an unversioned metadata value
</a><a href="#h4-0-5" id="h4-0-5" class="i">+    pub fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h4-0-6" id="h4-0-6" class="i">+        let session = self.storage.read()?;
</a><a href="#h4-0-7" id="h4-0-7" class="i">+        session.read(key)
</a><a href="#h4-0-8" id="h4-0-8" class="i">+    }
</a><a href="#h4-0-9" id="h4-0-9" class="i">+
</a><a href="#h4-0-10" id="h4-0-10" class="i">+    /// Sets an unversioned metadata value
</a><a href="#h4-0-11" id="h4-0-11" class="i">+    pub fn set_metadata(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h4-0-12" id="h4-0-12" class="i">+        let mut session = self.storage.write()?;
</a><a href="#h4-0-13" id="h4-0-13" class="i">+        session.write(key, value)
</a><a href="#h4-0-14" id="h4-0-14" class="i">+    }
</a> }
 
 /// An MVCC transaction.
<a href="#h4-1" id="h4-1" class="h">@@ -303,6 +315,8 @@ enum Key {
</a>     TxnUpdate(u64, Vec&lt;u8&gt;),
     /// A record for a key/version pair.
     Record(Vec&lt;u8&gt;, u64),
<a href="#h4-1-3" id="h4-1-3" class="i">+    /// Arbitrary unversioned metadata.
</a><a href="#h4-1-4" id="h4-1-4" class="i">+    Metadata(Vec&lt;u8&gt;),
</a> }
 
 impl Key {
<a href="#h4-2" id="h4-2" class="h">@@ -314,6 +328,7 @@ impl Key {
</a>             Some(0x02) =&gt; Ok(Key::TxnActive(Self::decode_u64(&amp;mut iter)?)),
             Some(0x03) =&gt; Ok(Key::TxnSnapshot(Self::decode_u64(&amp;mut iter)?)),
             Some(0x04) =&gt; Ok(Key::TxnUpdate(Self::decode_u64(&amp;mut iter)?, iter.cloned().collect())),
<a href="#h4-2-3" id="h4-2-3" class="i">+            Some(0x05) =&gt; Ok(Key::Metadata(Self::decode_bytes(&amp;mut iter)?)),
</a>             Some(0xff) =&gt; {
                 Ok(Self::Record(Self::decode_bytes(&amp;mut iter)?, Self::decode_u64(&amp;mut iter)?))
             }
<a href="#h4-3" id="h4-3" class="h">@@ -356,6 +371,7 @@ impl Key {
</a>             Self::TxnActive(id) =&gt; [vec![0x02], Self::encode_u64(id)].concat(),
             Self::TxnSnapshot(version) =&gt; [vec![0x03], Self::encode_u64(version)].concat(),
             Self::TxnUpdate(id, key) =&gt; [vec![0x04], Self::encode_u64(id), key].concat(),
<a href="#h4-3-3" id="h4-3-3" class="i">+            Self::Metadata(key) =&gt; [vec![0x05], Self::encode_bytes(key)].concat(),
</a>             Self::Record(key, version) =&gt; {
                 [vec![0xff], Self::encode_bytes(key), Self::encode_u64(version)].concat()
             }
<a href="#h4-4" id="h4-4" class="h">@@ -1109,4 +1125,18 @@ pub mod tests {
</a> 
         Ok(())
     }*/
<a href="#h4-4-3" id="h4-4-3" class="i">+
</a><a href="#h4-4-4" id="h4-4-4" class="i">+    #[test]
</a><a href="#h4-4-5" id="h4-4-5" class="i">+    fn test_metadata() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h4-4-6" id="h4-4-6" class="i">+        let mvcc = setup();
</a><a href="#h4-4-7" id="h4-4-7" class="i">+
</a><a href="#h4-4-8" id="h4-4-8" class="i">+        mvcc.set_metadata(b&quot;foo&quot;, b&quot;bar&quot;.to_vec())?;
</a><a href="#h4-4-9" id="h4-4-9" class="i">+        assert_eq!(Some(b&quot;bar&quot;.to_vec()), mvcc.get_metadata(b&quot;foo&quot;)?);
</a><a href="#h4-4-10" id="h4-4-10" class="i">+
</a><a href="#h4-4-11" id="h4-4-11" class="i">+        assert_eq!(None, mvcc.get_metadata(b&quot;x&quot;)?);
</a><a href="#h4-4-12" id="h4-4-12" class="i">+
</a><a href="#h4-4-13" id="h4-4-13" class="i">+        mvcc.set_metadata(b&quot;foo&quot;, b&quot;baz&quot;.to_vec())?;
</a><a href="#h4-4-14" id="h4-4-14" class="i">+        assert_eq!(Some(b&quot;baz&quot;.to_vec()), mvcc.get_metadata(b&quot;foo&quot;)?);
</a><a href="#h4-4-15" id="h4-4-15" class="i">+        Ok(())
</a><a href="#h4-4-16" id="h4-4-16" class="i">+    }
</a> }
<b>diff --git a/<a id="h5" href="../file/src/raft/client.rs.html">src/raft/client.rs</a> b/<a href="../file/src/raft/client.rs.html">src/raft/client.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,48 +1,27 @@
</a><a href="#h5-0-0" id="h5-0-0" class="d">-use super::Status;
</a><a href="#h5-0-1" id="h5-0-1" class="i">+use super::{Request, Response, Status};
</a> use crate::Error;
 
<a href="#h5-0-4" id="h5-0-4" class="d">-use tokio::runtime;
</a> use tokio::sync::{mpsc, oneshot};
 
<a href="#h5-0-7" id="h5-0-7" class="d">-/// A client request.
</a><a href="#h5-0-8" id="h5-0-8" class="d">-#[derive(Debug)]
</a><a href="#h5-0-9" id="h5-0-9" class="d">-pub enum Request {
</a><a href="#h5-0-10" id="h5-0-10" class="d">-    Query(Vec&lt;u8&gt;),
</a><a href="#h5-0-11" id="h5-0-11" class="d">-    Mutate(Vec&lt;u8&gt;),
</a><a href="#h5-0-12" id="h5-0-12" class="d">-    Status,
</a><a href="#h5-0-13" id="h5-0-13" class="d">-}
</a><a href="#h5-0-14" id="h5-0-14" class="d">-
</a><a href="#h5-0-15" id="h5-0-15" class="d">-/// A client response.
</a><a href="#h5-0-16" id="h5-0-16" class="d">-#[derive(Debug)]
</a><a href="#h5-0-17" id="h5-0-17" class="d">-pub enum Response {
</a><a href="#h5-0-18" id="h5-0-18" class="d">-    State(Vec&lt;u8&gt;),
</a><a href="#h5-0-19" id="h5-0-19" class="d">-    Status(Status),
</a><a href="#h5-0-20" id="h5-0-20" class="d">-    Error(Error),
</a><a href="#h5-0-21" id="h5-0-21" class="d">-}
</a><a href="#h5-0-22" id="h5-0-22" class="d">-
</a> /// A client for a local Raft server.
 #[derive(Clone)]
 pub struct Client {
<a href="#h5-0-26" id="h5-0-26" class="d">-    request_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Response&gt;)&gt;,
</a><a href="#h5-0-27" id="h5-0-27" class="d">-    runtime: runtime::Handle,
</a><a href="#h5-0-28" id="h5-0-28" class="i">+    request_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;)&gt;,
</a> }
 
 impl Client {
     /// Creates a new Raft client.
<a href="#h5-0-33" id="h5-0-33" class="d">-    pub async fn new(
</a><a href="#h5-0-34" id="h5-0-34" class="d">-        request_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Response&gt;)&gt;,
</a><a href="#h5-0-35" id="h5-0-35" class="i">+    pub fn new(
</a><a href="#h5-0-36" id="h5-0-36" class="i">+        request_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;)&gt;,
</a>     ) -&gt; Self {
<a href="#h5-0-38" id="h5-0-38" class="d">-        Self { request_tx, runtime: runtime::Handle::current() }
</a><a href="#h5-0-39" id="h5-0-39" class="i">+        Self { request_tx }
</a>     }
 
     /// Executes a request against the Raft cluster.
     async fn request(&amp;self, request: Request) -&gt; Result&lt;Response, Error&gt; {
         let (response_tx, response_rx) = oneshot::channel();
         self.request_tx.send((request, response_tx))?;
<a href="#h5-0-46" id="h5-0-46" class="d">-        match response_rx.await? {
</a><a href="#h5-0-47" id="h5-0-47" class="d">-            Response::Error(error) =&gt; Err(error),
</a><a href="#h5-0-48" id="h5-0-48" class="d">-            response =&gt; Ok(response),
</a><a href="#h5-0-49" id="h5-0-49" class="d">-        }
</a><a href="#h5-0-50" id="h5-0-50" class="i">+        response_rx.await?
</a>     }
 
     /// Mutates the Raft state machine.
<a href="#h5-1" id="h5-1" class="h">@@ -53,11 +32,6 @@ impl Client {
</a>         }
     }
 
<a href="#h5-1-3" id="h5-1-3" class="d">-    /// Mutates the Raft machine synchronously.
</a><a href="#h5-1-4" id="h5-1-4" class="d">-    pub fn mutate_sync(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h5-1-5" id="h5-1-5" class="d">-        self.runtime.enter(|| futures::executor::block_on(self.mutate(command)))
</a><a href="#h5-1-6" id="h5-1-6" class="d">-    }
</a><a href="#h5-1-7" id="h5-1-7" class="d">-
</a>     /// Queries the Raft state machine.
     pub async fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
         match self.request(Request::Query(command)).await? {
<a href="#h5-2" id="h5-2" class="h">@@ -66,11 +40,6 @@ impl Client {
</a>         }
     }
 
<a href="#h5-2-3" id="h5-2-3" class="d">-    /// Queries the Raft state machine synchronously.
</a><a href="#h5-2-4" id="h5-2-4" class="d">-    pub fn query_sync(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h5-2-5" id="h5-2-5" class="d">-        self.runtime.enter(|| futures::executor::block_on(self.query(command)))
</a><a href="#h5-2-6" id="h5-2-6" class="d">-    }
</a><a href="#h5-2-7" id="h5-2-7" class="d">-
</a>     /// Fetches Raft node status.
     pub async fn status(&amp;self) -&gt; Result&lt;Status, Error&gt; {
         match self.request(Request::Status).await? {
<a href="#h5-3" id="h5-3" class="h">@@ -78,9 +47,4 @@ impl Client {
</a>             resp =&gt; Err(Error::Internal(format!(&quot;Unexpected Raft status response {:?}&quot;, resp))),
         }
     }
<a href="#h5-3-3" id="h5-3-3" class="d">-
</a><a href="#h5-3-4" id="h5-3-4" class="d">-    /// Fetches Raft node status synchronously.
</a><a href="#h5-3-5" id="h5-3-5" class="d">-    pub fn status_sync(&amp;self) -&gt; Result&lt;Status, Error&gt; {
</a><a href="#h5-3-6" id="h5-3-6" class="d">-        self.runtime.enter(|| futures::executor::block_on(self.status()))
</a><a href="#h5-3-7" id="h5-3-7" class="d">-    }
</a> }
<b>diff --git a/<a id="h6" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,5 +1,5 @@
</a><a href="#h6-0-0" id="h6-0-0" class="d">-use super::State;
</a> use crate::kv;
<a href="#h6-0-2" id="h6-0-2" class="i">+use crate::kv::storage::Storage;
</a> use crate::utility::{deserialize, serialize};
 use crate::Error;
 
<a href="#h6-1" id="h6-1" class="h">@@ -9,47 +9,52 @@ use serde_derive::{Deserialize, Serialize};
</a> /// A replicated log entry
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub struct Entry {
<a href="#h6-1-3" id="h6-1-3" class="d">-    /// The term in which the entry was added
</a><a href="#h6-1-4" id="h6-1-4" class="i">+    /// The index of the entry.
</a><a href="#h6-1-5" id="h6-1-5" class="i">+    pub index: u64,
</a><a href="#h6-1-6" id="h6-1-6" class="i">+    /// The term in which the entry was added.
</a>     pub term: u64,
     /// The state machine command. None is used to commit noops during leader election.
     pub command: Option&lt;Vec&lt;u8&gt;&gt;,
 }
 
 /// The replicated Raft log
<a href="#h6-1-13" id="h6-1-13" class="d">-pub struct Log&lt;S: kv::storage::Storage&gt; {
</a><a href="#h6-1-14" id="h6-1-14" class="i">+pub struct Log&lt;S: Storage&gt; {
</a>     /// The underlying key-value store
     kv: kv::Simple&lt;S&gt;,
     /// The index of the last stored entry.
     last_index: u64,
     /// The term of the last stored entry.
     last_term: u64,
<a href="#h6-1-21" id="h6-1-21" class="d">-    /// The last entry known to be committed. Not persisted,
</a><a href="#h6-1-22" id="h6-1-22" class="d">-    /// since leaders will determine this when they&#39;re elected.
</a><a href="#h6-1-23" id="h6-1-23" class="i">+    /// The last entry known to be committed.
</a>     commit_index: u64,
     /// The term of the last committed entry.
     commit_term: u64,
<a href="#h6-1-27" id="h6-1-27" class="d">-    /// The last entry applied to the state machine. This is
</a><a href="#h6-1-28" id="h6-1-28" class="d">-    /// persisted, since the state machine is also persisted.
</a><a href="#h6-1-29" id="h6-1-29" class="d">-    apply_index: u64,
</a><a href="#h6-1-30" id="h6-1-30" class="d">-    /// The term of the last applied entry.
</a><a href="#h6-1-31" id="h6-1-31" class="d">-    apply_term: u64,
</a> }
 
<a href="#h6-1-34" id="h6-1-34" class="d">-impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a><a href="#h6-1-35" id="h6-1-35" class="i">+impl&lt;S: Storage&gt; Log&lt;S&gt; {
</a>     /// Creates a new log, using a kv::Store for storage.
     pub fn new(store: kv::Simple&lt;S&gt;) -&gt; Result&lt;Self, Error&gt; {
<a href="#h6-1-38" id="h6-1-38" class="d">-        let apply_index = match store.get(b&quot;apply_index&quot;)? {
</a><a href="#h6-1-39" id="h6-1-39" class="d">-            Some(v) =&gt; deserialize(&amp;v)?,
</a><a href="#h6-1-40" id="h6-1-40" class="d">-            None =&gt; 0,
</a><a href="#h6-1-41" id="h6-1-41" class="d">-        };
</a><a href="#h6-1-42" id="h6-1-42" class="d">-        let (commit_index, commit_term) = match store.get(&amp;apply_index.to_string().as_bytes())? {
</a><a href="#h6-1-43" id="h6-1-43" class="d">-            Some(raw_entry) =&gt; (apply_index, deserialize::&lt;Entry&gt;(&amp;raw_entry)?.term),
</a><a href="#h6-1-44" id="h6-1-44" class="d">-            None if apply_index == 0 =&gt; (0, 0),
</a><a href="#h6-1-45" id="h6-1-45" class="d">-            None =&gt; {
</a><a href="#h6-1-46" id="h6-1-46" class="d">-                return Err(Error::Internal(format!(&quot;Applied entry {} not found&quot;, apply_index)))
</a><a href="#h6-1-47" id="h6-1-47" class="i">+        let (mut commit_index, mut commit_term) = (0, 0);
</a><a href="#h6-1-48" id="h6-1-48" class="i">+        if let Some(index) =
</a><a href="#h6-1-49" id="h6-1-49" class="i">+            store.get(b&quot;commit_index&quot;)?.map(|v| deserialize::&lt;u64&gt;(&amp;v)).transpose()?
</a><a href="#h6-1-50" id="h6-1-50" class="i">+        {
</a><a href="#h6-1-51" id="h6-1-51" class="i">+            match store
</a><a href="#h6-1-52" id="h6-1-52" class="i">+                .get(&amp;index.to_string().as_bytes())?
</a><a href="#h6-1-53" id="h6-1-53" class="i">+                .map(|v| deserialize::&lt;Entry&gt;(&amp;v))
</a><a href="#h6-1-54" id="h6-1-54" class="i">+                .transpose()?
</a><a href="#h6-1-55" id="h6-1-55" class="i">+            {
</a><a href="#h6-1-56" id="h6-1-56" class="i">+                Some(Entry { term, .. }) =&gt; {
</a><a href="#h6-1-57" id="h6-1-57" class="i">+                    commit_index = index;
</a><a href="#h6-1-58" id="h6-1-58" class="i">+                    commit_term = term;
</a><a href="#h6-1-59" id="h6-1-59" class="i">+                }
</a><a href="#h6-1-60" id="h6-1-60" class="i">+                e =&gt; {
</a><a href="#h6-1-61" id="h6-1-61" class="i">+                    return Err(Error::Internal(format!(
</a><a href="#h6-1-62" id="h6-1-62" class="i">+                        &quot;Failed to load committed entry {}, got {:?}&quot;,
</a><a href="#h6-1-63" id="h6-1-63" class="i">+                        index, e
</a><a href="#h6-1-64" id="h6-1-64" class="i">+                    )))
</a><a href="#h6-1-65" id="h6-1-65" class="i">+                }
</a>             }
<a href="#h6-1-67" id="h6-1-67" class="d">-        };
</a><a href="#h6-1-68" id="h6-1-68" class="d">-        let apply_term = commit_term;
</a><a href="#h6-1-69" id="h6-1-69" class="i">+        }
</a>         // FIXME This really needs to be done in a better way.
         let (mut last_index, mut last_term) = (0, 0);
         for i in 1..std::u64::MAX {
<a href="#h6-2" id="h6-2" class="h">@@ -61,55 +66,17 @@ impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a>                 break;
             }
         }
<a href="#h6-2-3" id="h6-2-3" class="d">-        Ok(Self {
</a><a href="#h6-2-4" id="h6-2-4" class="d">-            kv: store,
</a><a href="#h6-2-5" id="h6-2-5" class="d">-            last_index,
</a><a href="#h6-2-6" id="h6-2-6" class="d">-            last_term,
</a><a href="#h6-2-7" id="h6-2-7" class="d">-            commit_index,
</a><a href="#h6-2-8" id="h6-2-8" class="d">-            commit_term,
</a><a href="#h6-2-9" id="h6-2-9" class="d">-            apply_index,
</a><a href="#h6-2-10" id="h6-2-10" class="d">-            apply_term,
</a><a href="#h6-2-11" id="h6-2-11" class="d">-        })
</a><a href="#h6-2-12" id="h6-2-12" class="d">-    }
</a><a href="#h6-2-13" id="h6-2-13" class="d">-
</a><a href="#h6-2-14" id="h6-2-14" class="d">-    /// Appends an entry to the log
</a><a href="#h6-2-15" id="h6-2-15" class="d">-    pub fn append(&amp;mut self, entry: Entry) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h6-2-16" id="h6-2-16" class="d">-        debug!(&quot;Appending log entry {}: {:?}&quot;, self.last_index + 1, entry);
</a><a href="#h6-2-17" id="h6-2-17" class="d">-        let index = self.last_index + 1;
</a><a href="#h6-2-18" id="h6-2-18" class="d">-        self.last_index = index;
</a><a href="#h6-2-19" id="h6-2-19" class="d">-        self.last_term = entry.term;
</a><a href="#h6-2-20" id="h6-2-20" class="d">-        self.kv.set(&amp;index.to_string().as_bytes(), serialize(&amp;entry)?)?;
</a><a href="#h6-2-21" id="h6-2-21" class="d">-        Ok(index)
</a><a href="#h6-2-22" id="h6-2-22" class="i">+        Ok(Self { kv: store, last_index, last_term, commit_index, commit_term })
</a>     }
 
<a href="#h6-2-25" id="h6-2-25" class="d">-    /// Applies the next committed entry to the state machine, if any. Returns the applied entry
</a><a href="#h6-2-26" id="h6-2-26" class="d">-    /// index and its result, or None if no entry. If the state machine returns Error::Internal, the
</a><a href="#h6-2-27" id="h6-2-27" class="d">-    /// entry is not applied and the error is propagated. If the state machine returns any other
</a><a href="#h6-2-28" id="h6-2-28" class="d">-    /// error, the entry is applied and the error returned to the caller.
</a><a href="#h6-2-29" id="h6-2-29" class="d">-    #[allow(clippy::borrowed_box)] // Currently this is correct
</a><a href="#h6-2-30" id="h6-2-30" class="d">-    #[allow(clippy::type_complexity)]
</a><a href="#h6-2-31" id="h6-2-31" class="d">-    pub fn apply(
</a><a href="#h6-2-32" id="h6-2-32" class="d">-        &amp;mut self,
</a><a href="#h6-2-33" id="h6-2-33" class="d">-        state: &amp;mut impl State,
</a><a href="#h6-2-34" id="h6-2-34" class="d">-    ) -&gt; Result&lt;Option&lt;(u64, Result&lt;Vec&lt;u8&gt;, Error&gt;)&gt;, Error&gt; {
</a><a href="#h6-2-35" id="h6-2-35" class="d">-        if self.apply_index &gt;= self.commit_index {
</a><a href="#h6-2-36" id="h6-2-36" class="d">-            return Ok(None);
</a><a href="#h6-2-37" id="h6-2-37" class="d">-        }
</a><a href="#h6-2-38" id="h6-2-38" class="d">-
</a><a href="#h6-2-39" id="h6-2-39" class="d">-        let mut output = Ok(vec![]);
</a><a href="#h6-2-40" id="h6-2-40" class="d">-        if let Some(entry) = self.get(self.apply_index + 1)? {
</a><a href="#h6-2-41" id="h6-2-41" class="d">-            debug!(&quot;Applying log entry {}: {:?}&quot;, self.apply_index + 1, entry);
</a><a href="#h6-2-42" id="h6-2-42" class="d">-            if let Some(command) = entry.command {
</a><a href="#h6-2-43" id="h6-2-43" class="d">-                output = match state.mutate(command) {
</a><a href="#h6-2-44" id="h6-2-44" class="d">-                    Err(err @ Error::Internal(_)) =&gt; return Err(err),
</a><a href="#h6-2-45" id="h6-2-45" class="d">-                    o =&gt; o,
</a><a href="#h6-2-46" id="h6-2-46" class="d">-                }
</a><a href="#h6-2-47" id="h6-2-47" class="d">-            }
</a><a href="#h6-2-48" id="h6-2-48" class="d">-            self.apply_index += 1;
</a><a href="#h6-2-49" id="h6-2-49" class="d">-            self.apply_term = entry.term;
</a><a href="#h6-2-50" id="h6-2-50" class="d">-        }
</a><a href="#h6-2-51" id="h6-2-51" class="d">-        self.kv.set(b&quot;apply_index&quot;, serialize(&amp;self.apply_index)?)?;
</a><a href="#h6-2-52" id="h6-2-52" class="d">-        Ok(Some((self.apply_index, output)))
</a><a href="#h6-2-53" id="h6-2-53" class="i">+    /// Appends a command to the log, returning the entry.
</a><a href="#h6-2-54" id="h6-2-54" class="i">+    pub fn append(&amp;mut self, term: u64, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;Entry, Error&gt; {
</a><a href="#h6-2-55" id="h6-2-55" class="i">+        let entry = Entry { index: self.last_index + 1, term, command };
</a><a href="#h6-2-56" id="h6-2-56" class="i">+        debug!(&quot;Appending log entry {}: {:?}&quot;, entry.index, entry);
</a><a href="#h6-2-57" id="h6-2-57" class="i">+        self.kv.set(&amp;entry.index.to_string().as_bytes(), serialize(&amp;entry)?)?;
</a><a href="#h6-2-58" id="h6-2-58" class="i">+        self.last_index = entry.index;
</a><a href="#h6-2-59" id="h6-2-59" class="i">+        self.last_term = entry.term;
</a><a href="#h6-2-60" id="h6-2-60" class="i">+        Ok(entry)
</a>     }
 
     /// Commits entries up to and including an index
<a href="#h6-3" id="h6-3" class="h">@@ -122,6 +89,7 @@ impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a>                 self.kv.flush()?;
                 self.commit_index = index;
                 self.commit_term = entry.term;
<a href="#h6-3-3" id="h6-3-3" class="i">+                self.kv.set(b&quot;commit_index&quot;, serialize(&amp;index)?)?;
</a>             } else {
                 return Err(Error::Internal(format!(
                     &quot;Entry at commit index {} does not exist&quot;,
<a href="#h6-4" id="h6-4" class="h">@@ -141,11 +109,6 @@ impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a>         }
     }
 
<a href="#h6-4-3" id="h6-4-3" class="d">-    /// Fetches the last applied index and term
</a><a href="#h6-4-4" id="h6-4-4" class="d">-    pub fn get_applied(&amp;self) -&gt; (u64, u64) {
</a><a href="#h6-4-5" id="h6-4-5" class="d">-        (self.apply_index, self.apply_term)
</a><a href="#h6-4-6" id="h6-4-6" class="d">-    }
</a><a href="#h6-4-7" id="h6-4-7" class="d">-
</a>     /// Fetches the last committed index and term
     pub fn get_committed(&amp;self) -&gt; (u64, u64) {
         (self.commit_index, self.commit_term)
<a href="#h6-5" id="h6-5" class="h">@@ -180,26 +143,26 @@ impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a>         Ok(entries)
     }
 
<a href="#h6-5-3" id="h6-5-3" class="d">-    /// Splices a set of entries onto an offset, with Raft-specific semantics:
</a><a href="#h6-5-4" id="h6-5-4" class="d">-    ///
</a><a href="#h6-5-5" id="h6-5-5" class="d">-    /// * If the base and base term does not match an existing entry, return error
</a><a href="#h6-5-6" id="h6-5-6" class="d">-    /// * If no existing entry exists at an index, append it
</a><a href="#h6-5-7" id="h6-5-7" class="d">-    /// * If the existing entry has a different term, replace it and following entries
</a><a href="#h6-5-8" id="h6-5-8" class="d">-    /// * If the existing entry has the same term, assume entry is equal and skip it
</a><a href="#h6-5-9" id="h6-5-9" class="d">-    ///
</a><a href="#h6-5-10" id="h6-5-10" class="d">-    /// The caller must have checked that the base is valid first (i.e. that it exists
</a><a href="#h6-5-11" id="h6-5-11" class="d">-    /// and has the correct term).
</a><a href="#h6-5-12" id="h6-5-12" class="d">-    //
</a><a href="#h6-5-13" id="h6-5-13" class="d">-    // FIXME Should be atomic
</a><a href="#h6-5-14" id="h6-5-14" class="d">-    pub fn splice(&amp;mut self, base: u64, entries: Vec&lt;Entry&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h6-5-15" id="h6-5-15" class="d">-        for (i, entry) in entries.into_iter().enumerate() {
</a><a href="#h6-5-16" id="h6-5-16" class="d">-            if let Some(ref current) = self.get(base + i as u64 + 1)? {
</a><a href="#h6-5-17" id="h6-5-17" class="i">+    /// Splices a set of entries onto an offset. The entries must be contiguous, and the first entry
</a><a href="#h6-5-18" id="h6-5-18" class="i">+    /// must be at most last_index+1. If an entry does not exist, append it. If an existing entry
</a><a href="#h6-5-19" id="h6-5-19" class="i">+    /// has a term mismatch, replace it and all following entries.
</a><a href="#h6-5-20" id="h6-5-20" class="i">+    pub fn splice(&amp;mut self, entries: Vec&lt;Entry&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h6-5-21" id="h6-5-21" class="i">+        for i in 0..entries.len() {
</a><a href="#h6-5-22" id="h6-5-22" class="i">+            if i == 0 &amp;&amp; entries.get(i).unwrap().index &gt; self.last_index + 1 {
</a><a href="#h6-5-23" id="h6-5-23" class="i">+                return Err(Error::Internal(&quot;Spliced entries cannot begin past last index&quot;.into()));
</a><a href="#h6-5-24" id="h6-5-24" class="i">+            }
</a><a href="#h6-5-25" id="h6-5-25" class="i">+            if entries.get(i).unwrap().index != entries.get(0).unwrap().index + i as u64 {
</a><a href="#h6-5-26" id="h6-5-26" class="i">+                return Err(Error::Internal(&quot;Spliced entries must be contiguous&quot;.into()));
</a><a href="#h6-5-27" id="h6-5-27" class="i">+            }
</a><a href="#h6-5-28" id="h6-5-28" class="i">+        }
</a><a href="#h6-5-29" id="h6-5-29" class="i">+        for entry in entries {
</a><a href="#h6-5-30" id="h6-5-30" class="i">+            if let Some(ref current) = self.get(entry.index)? {
</a>                 if current.term == entry.term {
                     continue;
                 }
<a href="#h6-5-34" id="h6-5-34" class="d">-                self.truncate(base + i as u64)?;
</a><a href="#h6-5-35" id="h6-5-35" class="i">+                self.truncate(entry.index - 1)?;
</a>             }
<a href="#h6-5-37" id="h6-5-37" class="d">-            self.append(entry)?;
</a><a href="#h6-5-38" id="h6-5-38" class="i">+            self.append(entry.term, entry.command)?;
</a>         }
         Ok(self.last_index)
     }
<a href="#h6-6" id="h6-6" class="h">@@ -208,9 +171,7 @@ impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a>     /// Refuses to remove entries that have been applied or committed.
     pub fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
         debug!(&quot;Truncating log from entry {}&quot;, index);
<a href="#h6-6-3" id="h6-6-3" class="d">-        if index &lt; self.apply_index {
</a><a href="#h6-6-4" id="h6-6-4" class="d">-            return Err(Error::Value(&quot;Cannot remove applied log entry&quot;.into()));
</a><a href="#h6-6-5" id="h6-6-5" class="d">-        } else if index &lt; self.commit_index {
</a><a href="#h6-6-6" id="h6-6-6" class="i">+        if index &lt; self.commit_index {
</a>             return Err(Error::Value(&quot;Cannot remove committed log entry&quot;.into()));
         }
 
<a href="#h6-7" id="h6-7" class="h">@@ -223,9 +184,8 @@ impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a>         Ok(self.last_index)
     }
 
<a href="#h6-7-3" id="h6-7-3" class="d">-    /// Loads information about the most recent term known by the log,
</a><a href="#h6-7-4" id="h6-7-4" class="d">-    /// containing the term number (0 if none) and candidate voted for
</a><a href="#h6-7-5" id="h6-7-5" class="d">-    /// in current term (if any).
</a><a href="#h6-7-6" id="h6-7-6" class="i">+    /// Loads information about the most recent term known by the log, containing the term number (0
</a><a href="#h6-7-7" id="h6-7-7" class="i">+    /// if none) and candidate voted for in current term (if any).
</a>     pub fn load_term(&amp;self) -&gt; Result&lt;(u64, Option&lt;String&gt;), Error&gt; {
         let term = if let Some(value) = self.kv.get(b&quot;term&quot;)? { deserialize(&amp;value)? } else { 0 };
         let voted_for = if let Some(value) = self.kv.get(b&quot;voted_for&quot;)? {
<a href="#h6-8" id="h6-8" class="h">@@ -238,7 +198,6 @@ impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a>     }
 
     /// Saves information about the most recent term.
<a href="#h6-8-3" id="h6-8-3" class="d">-    // FIXME Should be transactional.
</a>     pub fn save_term(&amp;mut self, term: u64, voted_for: Option&lt;&amp;str&gt;) -&gt; Result&lt;(), Error&gt; {
         if term &gt; 0 {
             self.kv.set(b&quot;term&quot;, serialize(&amp;term)?)?
<a href="#h6-9" id="h6-9" class="h">@@ -258,8 +217,8 @@ impl&lt;S: kv::storage::Storage&gt; Log&lt;S&gt; {
</a> 
 #[cfg(test)]
 mod tests {
<a href="#h6-9-3" id="h6-9-3" class="d">-    use super::super::state::tests::TestState;
</a>     use super::*;
<a href="#h6-9-5" id="h6-9-5" class="i">+    use pretty_assertions::assert_eq;
</a> 
     fn setup() -&gt; Result&lt;(Log&lt;kv::storage::Test&gt;, kv::Simple&lt;kv::storage::Test&gt;), Error&gt; {
         let backend = kv::storage::Test::new();
<a href="#h6-10" id="h6-10" class="h">@@ -273,7 +232,6 @@ mod tests {
</a>         let (l, _) = setup()?;
         assert_eq!((0, 0), l.get_last());
         assert_eq!((0, 0), l.get_committed());
<a href="#h6-10-3" id="h6-10-3" class="d">-        assert_eq!((0, 0), l.get_applied());
</a>         assert_eq!(None, l.get(1)?);
         Ok(())
     }
<a href="#h6-11" id="h6-11" class="h">@@ -283,168 +241,76 @@ mod tests {
</a>         let (mut l, _) = setup()?;
         assert_eq!(Ok(None), l.get(1));
 
<a href="#h6-11-3" id="h6-11-3" class="d">-        assert_eq!(1, l.append(Entry { term: 3, command: Some(vec![0x01]) })?);
</a><a href="#h6-11-4" id="h6-11-4" class="d">-        assert_eq!(Some(Entry { term: 3, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-11-5" id="h6-11-5" class="i">+        assert_eq!(
</a><a href="#h6-11-6" id="h6-11-6" class="i">+            Entry { index: 1, term: 3, command: Some(vec![0x01]) },
</a><a href="#h6-11-7" id="h6-11-7" class="i">+            l.append(3, Some(vec![0x01]))?
</a><a href="#h6-11-8" id="h6-11-8" class="i">+        );
</a><a href="#h6-11-9" id="h6-11-9" class="i">+        assert_eq!(Some(Entry { index: 1, term: 3, command: Some(vec![0x01]) }), l.get(1)?);
</a>         assert_eq!(None, l.get(2)?);
 
         assert_eq!((1, 3), l.get_last());
         assert_eq!((0, 0), l.get_committed());
<a href="#h6-11-14" id="h6-11-14" class="d">-        assert_eq!((0, 0), l.get_applied());
</a>         Ok(())
     }
 
     #[test]
<a href="#h6-11-19" id="h6-11-19" class="d">-    fn append_none_command() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h6-11-20" id="h6-11-20" class="i">+    fn append_none() -&gt; Result&lt;(), Error&gt; {
</a>         let (mut l, _) = setup()?;
<a href="#h6-11-22" id="h6-11-22" class="d">-        assert_eq!(1, l.append(Entry { term: 3, command: None })?);
</a><a href="#h6-11-23" id="h6-11-23" class="d">-        assert_eq!(Some(Entry { term: 3, command: None }), l.get(1)?);
</a><a href="#h6-11-24" id="h6-11-24" class="i">+        assert_eq!(Entry { index: 1, term: 3, command: None }, l.append(3, None)?);
</a><a href="#h6-11-25" id="h6-11-25" class="i">+        assert_eq!(Some(Entry { index: 1, term: 3, command: None }), l.get(1)?);
</a>         Ok(())
     }
 
     #[test]
     fn append_persistence() -&gt; Result&lt;(), Error&gt; {
         let (mut l, store) = setup()?;
<a href="#h6-11-32" id="h6-11-32" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-11-33" id="h6-11-33" class="d">-        l.append(Entry { term: 2, command: None })?;
</a><a href="#h6-11-34" id="h6-11-34" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h6-11-35" id="h6-11-35" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-11-36" id="h6-11-36" class="i">+        l.append(2, None)?;
</a><a href="#h6-11-37" id="h6-11-37" class="i">+        l.append(2, Some(vec![0x03]))?;
</a> 
         let l = Log::new(store)?;
<a href="#h6-11-40" id="h6-11-40" class="d">-        assert_eq!(Some(Entry { term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-11-41" id="h6-11-41" class="d">-        assert_eq!(Some(Entry { term: 2, command: None }), l.get(2)?);
</a><a href="#h6-11-42" id="h6-11-42" class="d">-        assert_eq!(Some(Entry { term: 2, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h6-11-43" id="h6-11-43" class="d">-        Ok(())
</a><a href="#h6-11-44" id="h6-11-44" class="d">-    }
</a><a href="#h6-11-45" id="h6-11-45" class="d">-
</a><a href="#h6-11-46" id="h6-11-46" class="d">-    #[test]
</a><a href="#h6-11-47" id="h6-11-47" class="d">-    fn apply() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h6-11-48" id="h6-11-48" class="d">-        let (mut l, store) = setup()?;
</a><a href="#h6-11-49" id="h6-11-49" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-11-50" id="h6-11-50" class="d">-        l.append(Entry { term: 2, command: None })?;
</a><a href="#h6-11-51" id="h6-11-51" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h6-11-52" id="h6-11-52" class="d">-        l.commit(3).unwrap();
</a><a href="#h6-11-53" id="h6-11-53" class="d">-
</a><a href="#h6-11-54" id="h6-11-54" class="d">-        let mut state = TestState::new();
</a><a href="#h6-11-55" id="h6-11-55" class="d">-        assert_eq!(Some((1, Ok(vec![0xff, 0x01]))), l.apply(&amp;mut state)?);
</a><a href="#h6-11-56" id="h6-11-56" class="d">-        assert_eq!((1, 1), l.get_applied());
</a><a href="#h6-11-57" id="h6-11-57" class="d">-        assert_eq!(vec![vec![0x01],], state.list());
</a><a href="#h6-11-58" id="h6-11-58" class="d">-
</a><a href="#h6-11-59" id="h6-11-59" class="d">-        assert_eq!(Some((2, Ok(vec![]))), l.apply(&amp;mut state)?);
</a><a href="#h6-11-60" id="h6-11-60" class="d">-        assert_eq!((2, 2), l.get_applied());
</a><a href="#h6-11-61" id="h6-11-61" class="d">-        assert_eq!(vec![vec![0x01],], state.list());
</a><a href="#h6-11-62" id="h6-11-62" class="d">-
</a><a href="#h6-11-63" id="h6-11-63" class="d">-        assert_eq!(Some((3, Ok(vec![0xff, 0x03]))), l.apply(&amp;mut state)?);
</a><a href="#h6-11-64" id="h6-11-64" class="d">-        assert_eq!((3, 2), l.get_applied());
</a><a href="#h6-11-65" id="h6-11-65" class="d">-        assert_eq!(vec![vec![0x01], vec![0x03]], state.list());
</a><a href="#h6-11-66" id="h6-11-66" class="d">-
</a><a href="#h6-11-67" id="h6-11-67" class="d">-        assert_eq!(None, l.apply(&amp;mut state)?);
</a><a href="#h6-11-68" id="h6-11-68" class="d">-        assert_eq!((3, 2), l.get_applied());
</a><a href="#h6-11-69" id="h6-11-69" class="d">-        assert_eq!(vec![vec![0x01], vec![0x03]], state.list());
</a><a href="#h6-11-70" id="h6-11-70" class="d">-
</a><a href="#h6-11-71" id="h6-11-71" class="d">-        // The last applied entry should be persisted, and also used for last committed
</a><a href="#h6-11-72" id="h6-11-72" class="d">-        let l = Log::new(store)?;
</a><a href="#h6-11-73" id="h6-11-73" class="d">-        assert_eq!((3, 2), l.get_last());
</a><a href="#h6-11-74" id="h6-11-74" class="d">-        assert_eq!((3, 2), l.get_committed());
</a><a href="#h6-11-75" id="h6-11-75" class="d">-        assert_eq!((3, 2), l.get_applied());
</a><a href="#h6-11-76" id="h6-11-76" class="d">-        Ok(())
</a><a href="#h6-11-77" id="h6-11-77" class="d">-    }
</a><a href="#h6-11-78" id="h6-11-78" class="d">-
</a><a href="#h6-11-79" id="h6-11-79" class="d">-    #[test]
</a><a href="#h6-11-80" id="h6-11-80" class="d">-    fn apply_committed_only() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h6-11-81" id="h6-11-81" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h6-11-82" id="h6-11-82" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-11-83" id="h6-11-83" class="d">-        l.append(Entry { term: 2, command: None })?;
</a><a href="#h6-11-84" id="h6-11-84" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h6-11-85" id="h6-11-85" class="d">-        l.commit(1).unwrap();
</a><a href="#h6-11-86" id="h6-11-86" class="d">-
</a><a href="#h6-11-87" id="h6-11-87" class="d">-        let mut state = TestState::new();
</a><a href="#h6-11-88" id="h6-11-88" class="d">-        assert_eq!(Some((1, Ok(vec![0xff, 0x01]))), l.apply(&amp;mut state)?);
</a><a href="#h6-11-89" id="h6-11-89" class="d">-        assert_eq!((1, 1), l.get_applied());
</a><a href="#h6-11-90" id="h6-11-90" class="d">-        assert_eq!(vec![vec![0x01],], state.list());
</a><a href="#h6-11-91" id="h6-11-91" class="d">-
</a><a href="#h6-11-92" id="h6-11-92" class="d">-        assert_eq!(None, l.apply(&amp;mut state)?);
</a><a href="#h6-11-93" id="h6-11-93" class="d">-        assert_eq!((1, 1), l.get_applied());
</a><a href="#h6-11-94" id="h6-11-94" class="d">-        assert_eq!(vec![vec![0x01],], state.list());
</a><a href="#h6-11-95" id="h6-11-95" class="d">-        Ok(())
</a><a href="#h6-11-96" id="h6-11-96" class="d">-    }
</a><a href="#h6-11-97" id="h6-11-97" class="d">-
</a><a href="#h6-11-98" id="h6-11-98" class="d">-    #[test]
</a><a href="#h6-11-99" id="h6-11-99" class="d">-    fn apply_errors() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h6-11-100" id="h6-11-100" class="d">-        let (mut l, store) = setup()?;
</a><a href="#h6-11-101" id="h6-11-101" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-11-102" id="h6-11-102" class="d">-        l.append(Entry { term: 1, command: Some(vec![0xff]) })?; // Error::Value
</a><a href="#h6-11-103" id="h6-11-103" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x03]) })?;
</a><a href="#h6-11-104" id="h6-11-104" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x04, 0x04]) })?; // Error::Internal
</a><a href="#h6-11-105" id="h6-11-105" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x05]) })?;
</a><a href="#h6-11-106" id="h6-11-106" class="d">-        l.commit(5)?;
</a><a href="#h6-11-107" id="h6-11-107" class="d">-        assert_eq!((5, 1), l.get_committed(), &quot;committed entry&quot;);
</a><a href="#h6-11-108" id="h6-11-108" class="d">-
</a><a href="#h6-11-109" id="h6-11-109" class="d">-        let mut state = TestState::new();
</a><a href="#h6-11-110" id="h6-11-110" class="d">-        assert_eq!(Some((1, Ok(vec![0xff, 0x01]))), l.apply(&amp;mut state)?);
</a><a href="#h6-11-111" id="h6-11-111" class="d">-        assert_eq!((1, 1), l.get_applied());
</a><a href="#h6-11-112" id="h6-11-112" class="d">-        assert_eq!(vec![vec![0x01],], state.list());
</a><a href="#h6-11-113" id="h6-11-113" class="d">-
</a><a href="#h6-11-114" id="h6-11-114" class="d">-        assert_eq!(
</a><a href="#h6-11-115" id="h6-11-115" class="d">-            Some((2, Err(Error::Value(&quot;Command cannot be 0xff&quot;.into())))),
</a><a href="#h6-11-116" id="h6-11-116" class="d">-            l.apply(&amp;mut state)?
</a><a href="#h6-11-117" id="h6-11-117" class="d">-        );
</a><a href="#h6-11-118" id="h6-11-118" class="d">-        assert_eq!((2, 1), l.get_applied());
</a><a href="#h6-11-119" id="h6-11-119" class="d">-        assert_eq!(vec![vec![0x01],], state.list());
</a><a href="#h6-11-120" id="h6-11-120" class="d">-
</a><a href="#h6-11-121" id="h6-11-121" class="d">-        assert_eq!(Some((3, Ok(vec![0xff, 0x03]))), l.apply(&amp;mut state)?);
</a><a href="#h6-11-122" id="h6-11-122" class="d">-        assert_eq!((3, 1), l.get_applied());
</a><a href="#h6-11-123" id="h6-11-123" class="d">-        assert_eq!(vec![vec![0x01], vec![0x03]], state.list());
</a><a href="#h6-11-124" id="h6-11-124" class="d">-
</a><a href="#h6-11-125" id="h6-11-125" class="d">-        assert_eq!(Err(Error::Internal(&quot;Command must be 1 byte&quot;.into())), l.apply(&amp;mut state));
</a><a href="#h6-11-126" id="h6-11-126" class="d">-        assert_eq!((3, 1), l.get_applied());
</a><a href="#h6-11-127" id="h6-11-127" class="d">-        assert_eq!(vec![vec![0x01], vec![0x03]], state.list());
</a><a href="#h6-11-128" id="h6-11-128" class="d">-
</a><a href="#h6-11-129" id="h6-11-129" class="d">-        assert_eq!(Err(Error::Internal(&quot;Command must be 1 byte&quot;.into())), l.apply(&amp;mut state));
</a><a href="#h6-11-130" id="h6-11-130" class="d">-        assert_eq!((3, 1), l.get_applied());
</a><a href="#h6-11-131" id="h6-11-131" class="d">-        assert_eq!(vec![vec![0x01], vec![0x03]], state.list());
</a><a href="#h6-11-132" id="h6-11-132" class="d">-
</a><a href="#h6-11-133" id="h6-11-133" class="d">-        // The last applied entry should be persisted, and also used for last committed,
</a><a href="#h6-11-134" id="h6-11-134" class="d">-        // and the erroring log entry should still be there.
</a><a href="#h6-11-135" id="h6-11-135" class="d">-        let mut l = Log::new(store)?;
</a><a href="#h6-11-136" id="h6-11-136" class="d">-        assert_eq!((5, 1), l.get_last(), &quot;last entry&quot;);
</a><a href="#h6-11-137" id="h6-11-137" class="d">-        assert_eq!((3, 1), l.get_committed(), &quot;committed entry&quot;);
</a><a href="#h6-11-138" id="h6-11-138" class="d">-        assert_eq!((3, 1), l.get_applied(), &quot;applied entry&quot;);
</a><a href="#h6-11-139" id="h6-11-139" class="d">-        l.commit(4)?;
</a><a href="#h6-11-140" id="h6-11-140" class="d">-        assert_eq!(Err(Error::Internal(&quot;Command must be 1 byte&quot;.into())), l.apply(&amp;mut state));
</a><a href="#h6-11-141" id="h6-11-141" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-11-142" id="h6-11-142" class="i">+        assert_eq!(Some(Entry { index: 2, term: 2, command: None }), l.get(2)?);
</a><a href="#h6-11-143" id="h6-11-143" class="i">+        assert_eq!(Some(Entry { index: 3, term: 2, command: Some(vec![0x03]) }), l.get(3)?);
</a>         Ok(())
     }
 
     #[test]
     fn commit() -&gt; Result&lt;(), Error&gt; {
         let (mut l, store) = setup()?;
<a href="#h6-11-150" id="h6-11-150" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-11-151" id="h6-11-151" class="d">-        l.append(Entry { term: 2, command: None })?;
</a><a href="#h6-11-152" id="h6-11-152" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h6-11-153" id="h6-11-153" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-11-154" id="h6-11-154" class="i">+        l.append(2, None)?;
</a><a href="#h6-11-155" id="h6-11-155" class="i">+        l.append(2, Some(vec![0x03]))?;
</a>         assert_eq!(3, l.commit(3)?);
         assert_eq!((3, 2), l.get_committed());
 
<a href="#h6-11-159" id="h6-11-159" class="d">-        // The last committed entry should not be persisted
</a><a href="#h6-11-160" id="h6-11-160" class="i">+        // The last committed entry must be persisted, to sync with state machine
</a>         let l = Log::new(store)?;
<a href="#h6-11-162" id="h6-11-162" class="d">-        assert_eq!((0, 0), l.get_committed());
</a><a href="#h6-11-163" id="h6-11-163" class="i">+        assert_eq!((3, 2), l.get_committed());
</a>         Ok(())
     }
 
     #[test]
     fn commit_beyond() -&gt; Result&lt;(), Error&gt; {
<a href="#h6-11-169" id="h6-11-169" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h6-11-170" id="h6-11-170" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-11-171" id="h6-11-171" class="d">-        l.append(Entry { term: 2, command: None })?;
</a><a href="#h6-11-172" id="h6-11-172" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h6-11-173" id="h6-11-173" class="i">+        let (mut l, store) = setup()?;
</a><a href="#h6-11-174" id="h6-11-174" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-11-175" id="h6-11-175" class="i">+        l.append(2, None)?;
</a><a href="#h6-11-176" id="h6-11-176" class="i">+        l.append(2, Some(vec![0x03]))?;
</a>         assert_eq!(3, l.commit(4)?);
         assert_eq!((3, 2), l.get_committed());
<a href="#h6-11-179" id="h6-11-179" class="i">+
</a><a href="#h6-11-180" id="h6-11-180" class="i">+        // The last committed entry must be persisted, to sync with state machine
</a><a href="#h6-11-181" id="h6-11-181" class="i">+        let l = Log::new(store)?;
</a><a href="#h6-11-182" id="h6-11-182" class="i">+        assert_eq!((3, 2), l.get_committed());
</a>         Ok(())
     }
 
     #[test]
     fn commit_partial() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-11-189" id="h6-11-189" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-11-190" id="h6-11-190" class="d">-        l.append(Entry { term: 2, command: None })?;
</a><a href="#h6-11-191" id="h6-11-191" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h6-11-192" id="h6-11-192" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-11-193" id="h6-11-193" class="i">+        l.append(2, None)?;
</a><a href="#h6-11-194" id="h6-11-194" class="i">+        l.append(2, Some(vec![0x03]))?;
</a>         assert_eq!(2, l.commit(2)?);
         assert_eq!((2, 2), l.get_committed());
         Ok(())
<a href="#h6-12" id="h6-12" class="h">@@ -453,9 +319,9 @@ mod tests {
</a>     #[test]
     fn commit_reduce() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-12-3" id="h6-12-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-12-4" id="h6-12-4" class="d">-        l.append(Entry { term: 2, command: None })?;
</a><a href="#h6-12-5" id="h6-12-5" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h6-12-6" id="h6-12-6" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-12-7" id="h6-12-7" class="i">+        l.append(2, None)?;
</a><a href="#h6-12-8" id="h6-12-8" class="i">+        l.append(2, Some(vec![0x03]))?;
</a>         assert_eq!(2, l.commit(2)?);
         assert_eq!((2, 2), l.get_committed());
 
<a href="#h6-13" id="h6-13" class="h">@@ -469,8 +335,8 @@ mod tests {
</a>         let (mut l, _) = setup()?;
         assert_eq!(None, l.get(1)?);
 
<a href="#h6-13-3" id="h6-13-3" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x01]) })?;
</a><a href="#h6-13-4" id="h6-13-4" class="d">-        assert_eq!(Some(Entry { term: 3, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-13-5" id="h6-13-5" class="i">+        l.append(3, Some(vec![0x01]))?;
</a><a href="#h6-13-6" id="h6-13-6" class="i">+        assert_eq!(Some(Entry { index: 1, term: 3, command: Some(vec![0x01]) }), l.get(1)?);
</a>         assert_eq!(None, l.get(2)?);
         Ok(())
     }
<a href="#h6-14" id="h6-14" class="h">@@ -478,7 +344,7 @@ mod tests {
</a>     #[test]
     fn has() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-14-3" id="h6-14-3" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x01]) })?;
</a><a href="#h6-14-4" id="h6-14-4" class="i">+        l.append(2, Some(vec![0x01]))?;
</a> 
         assert_eq!(true, l.has(1, 2)?);
         assert_eq!(true, l.has(0, 0)?);
<a href="#h6-15" id="h6-15" class="h">@@ -493,22 +359,22 @@ mod tests {
</a>     #[test]
     fn range() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-15-3" id="h6-15-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-15-4" id="h6-15-4" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x02]) })?;
</a><a href="#h6-15-5" id="h6-15-5" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x03]) })?;
</a><a href="#h6-15-6" id="h6-15-6" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-15-7" id="h6-15-7" class="i">+        l.append(1, Some(vec![0x02]))?;
</a><a href="#h6-15-8" id="h6-15-8" class="i">+        l.append(1, Some(vec![0x03]))?;
</a> 
         assert_eq!(
             vec![
<a href="#h6-15-12" id="h6-15-12" class="d">-                Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h6-15-13" id="h6-15-13" class="d">-                Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h6-15-14" id="h6-15-14" class="d">-                Entry { term: 1, command: Some(vec![0x03]) },
</a><a href="#h6-15-15" id="h6-15-15" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h6-15-16" id="h6-15-16" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h6-15-17" id="h6-15-17" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a>             ],
             l.range(0..)?
         );
         assert_eq!(
             vec![
<a href="#h6-15-23" id="h6-15-23" class="d">-                Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h6-15-24" id="h6-15-24" class="d">-                Entry { term: 1, command: Some(vec![0x03]) },
</a><a href="#h6-15-25" id="h6-15-25" class="i">+                Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h6-15-26" id="h6-15-26" class="i">+                Entry { index: 3, term: 1, command: Some(vec![0x03]) },
</a>             ],
             l.range(2..)?
         );
<a href="#h6-16" id="h6-16" class="h">@@ -540,24 +406,21 @@ mod tests {
</a>     #[test]
     fn splice() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-16-3" id="h6-16-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-16-4" id="h6-16-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-16-5" id="h6-16-5" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x03]) })?;
</a><a href="#h6-16-6" id="h6-16-6" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-16-7" id="h6-16-7" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-16-8" id="h6-16-8" class="i">+        l.append(3, Some(vec![0x03]))?;
</a> 
         assert_eq!(
             4,
<a href="#h6-16-12" id="h6-16-12" class="d">-            l.splice(
</a><a href="#h6-16-13" id="h6-16-13" class="d">-                2,
</a><a href="#h6-16-14" id="h6-16-14" class="d">-                vec![
</a><a href="#h6-16-15" id="h6-16-15" class="d">-                    Entry { term: 3, command: Some(vec![0x03]) },
</a><a href="#h6-16-16" id="h6-16-16" class="d">-                    Entry { term: 4, command: Some(vec![0x04]) },
</a><a href="#h6-16-17" id="h6-16-17" class="d">-                ]
</a><a href="#h6-16-18" id="h6-16-18" class="d">-            )?
</a><a href="#h6-16-19" id="h6-16-19" class="i">+            l.splice(vec![
</a><a href="#h6-16-20" id="h6-16-20" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h6-16-21" id="h6-16-21" class="i">+                Entry { index: 4, term: 4, command: Some(vec![0x04]) },
</a><a href="#h6-16-22" id="h6-16-22" class="i">+            ])?
</a>         );
<a href="#h6-16-24" id="h6-16-24" class="d">-        assert_eq!(Some(Entry { term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-16-25" id="h6-16-25" class="d">-        assert_eq!(Some(Entry { term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-16-26" id="h6-16-26" class="d">-        assert_eq!(Some(Entry { term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h6-16-27" id="h6-16-27" class="d">-        assert_eq!(Some(Entry { term: 4, command: Some(vec![0x04]) }), l.get(4)?);
</a><a href="#h6-16-28" id="h6-16-28" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-16-29" id="h6-16-29" class="i">+        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-16-30" id="h6-16-30" class="i">+        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h6-16-31" id="h6-16-31" class="i">+        assert_eq!(Some(Entry { index: 4, term: 4, command: Some(vec![0x04]) }), l.get(4)?);
</a>         assert_eq!((4, 4), l.get_last());
         Ok(())
     }
<a href="#h6-17" id="h6-17" class="h">@@ -565,22 +428,19 @@ mod tests {
</a>     #[test]
     fn splice_all() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-17-3" id="h6-17-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-17-4" id="h6-17-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-17-5" id="h6-17-5" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x03]) })?;
</a><a href="#h6-17-6" id="h6-17-6" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-17-7" id="h6-17-7" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-17-8" id="h6-17-8" class="i">+        l.append(3, Some(vec![0x03]))?;
</a> 
         assert_eq!(
             2,
<a href="#h6-17-12" id="h6-17-12" class="d">-            l.splice(
</a><a href="#h6-17-13" id="h6-17-13" class="d">-                0,
</a><a href="#h6-17-14" id="h6-17-14" class="d">-                vec![
</a><a href="#h6-17-15" id="h6-17-15" class="d">-                    Entry { term: 4, command: Some(vec![0x0a]) },
</a><a href="#h6-17-16" id="h6-17-16" class="d">-                    Entry { term: 4, command: Some(vec![0x0b]) },
</a><a href="#h6-17-17" id="h6-17-17" class="d">-                ]
</a><a href="#h6-17-18" id="h6-17-18" class="d">-            )?
</a><a href="#h6-17-19" id="h6-17-19" class="i">+            l.splice(vec![
</a><a href="#h6-17-20" id="h6-17-20" class="i">+                Entry { index: 1, term: 4, command: Some(vec![0x0a]) },
</a><a href="#h6-17-21" id="h6-17-21" class="i">+                Entry { index: 2, term: 4, command: Some(vec![0x0b]) },
</a><a href="#h6-17-22" id="h6-17-22" class="i">+            ])?
</a>         );
<a href="#h6-17-24" id="h6-17-24" class="d">-        assert_eq!(Some(Entry { term: 4, command: Some(vec![0x0a]) }), l.get(1)?);
</a><a href="#h6-17-25" id="h6-17-25" class="d">-        assert_eq!(Some(Entry { term: 4, command: Some(vec![0x0b]) }), l.get(2)?);
</a><a href="#h6-17-26" id="h6-17-26" class="i">+        assert_eq!(Some(Entry { index: 1, term: 4, command: Some(vec![0x0a]) }), l.get(1)?);
</a><a href="#h6-17-27" id="h6-17-27" class="i">+        assert_eq!(Some(Entry { index: 2, term: 4, command: Some(vec![0x0b]) }), l.get(2)?);
</a>         assert_eq!((2, 4), l.get_last());
         Ok(())
     }
<a href="#h6-18" id="h6-18" class="h">@@ -588,23 +448,20 @@ mod tests {
</a>     #[test]
     fn splice_append() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-18-3" id="h6-18-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-18-4" id="h6-18-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-18-5" id="h6-18-5" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-18-6" id="h6-18-6" class="i">+        l.append(2, Some(vec![0x02]))?;
</a> 
         assert_eq!(
             4,
<a href="#h6-18-10" id="h6-18-10" class="d">-            l.splice(
</a><a href="#h6-18-11" id="h6-18-11" class="d">-                2,
</a><a href="#h6-18-12" id="h6-18-12" class="d">-                vec![
</a><a href="#h6-18-13" id="h6-18-13" class="d">-                    Entry { term: 3, command: Some(vec![0x03]) },
</a><a href="#h6-18-14" id="h6-18-14" class="d">-                    Entry { term: 4, command: Some(vec![0x04]) },
</a><a href="#h6-18-15" id="h6-18-15" class="d">-                ]
</a><a href="#h6-18-16" id="h6-18-16" class="d">-            )?
</a><a href="#h6-18-17" id="h6-18-17" class="i">+            l.splice(vec![
</a><a href="#h6-18-18" id="h6-18-18" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h6-18-19" id="h6-18-19" class="i">+                Entry { index: 4, term: 4, command: Some(vec![0x04]) },
</a><a href="#h6-18-20" id="h6-18-20" class="i">+            ])?
</a>         );
<a href="#h6-18-22" id="h6-18-22" class="d">-        assert_eq!(Some(Entry { term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-18-23" id="h6-18-23" class="d">-        assert_eq!(Some(Entry { term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-18-24" id="h6-18-24" class="d">-        assert_eq!(Some(Entry { term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h6-18-25" id="h6-18-25" class="d">-        assert_eq!(Some(Entry { term: 4, command: Some(vec![0x04]) }), l.get(4)?);
</a><a href="#h6-18-26" id="h6-18-26" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-18-27" id="h6-18-27" class="i">+        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-18-28" id="h6-18-28" class="i">+        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h6-18-29" id="h6-18-29" class="i">+        assert_eq!(Some(Entry { index: 4, term: 4, command: Some(vec![0x04]) }), l.get(4)?);
</a>         assert_eq!((4, 4), l.get_last());
         Ok(())
     }
<a href="#h6-19" id="h6-19" class="h">@@ -612,24 +469,65 @@ mod tests {
</a>     #[test]
     fn splice_conflict_term() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-19-3" id="h6-19-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-19-4" id="h6-19-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-19-5" id="h6-19-5" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x03]) })?;
</a><a href="#h6-19-6" id="h6-19-6" class="d">-        l.append(Entry { term: 4, command: Some(vec![0x04]) })?;
</a><a href="#h6-19-7" id="h6-19-7" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-19-8" id="h6-19-8" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-19-9" id="h6-19-9" class="i">+        l.append(3, Some(vec![0x03]))?;
</a><a href="#h6-19-10" id="h6-19-10" class="i">+        l.append(4, Some(vec![0x04]))?;
</a> 
         assert_eq!(
             3,
<a href="#h6-19-14" id="h6-19-14" class="d">-            l.splice(
</a><a href="#h6-19-15" id="h6-19-15" class="d">-                1,
</a><a href="#h6-19-16" id="h6-19-16" class="d">-                vec![
</a><a href="#h6-19-17" id="h6-19-17" class="d">-                    Entry { term: 3, command: Some(vec![0x0b]) },
</a><a href="#h6-19-18" id="h6-19-18" class="d">-                    Entry { term: 3, command: Some(vec![0x0c]) }
</a><a href="#h6-19-19" id="h6-19-19" class="d">-                ]
</a><a href="#h6-19-20" id="h6-19-20" class="d">-            )?
</a><a href="#h6-19-21" id="h6-19-21" class="i">+            l.splice(vec![
</a><a href="#h6-19-22" id="h6-19-22" class="i">+                Entry { index: 2, term: 3, command: Some(vec![0x0b]) },
</a><a href="#h6-19-23" id="h6-19-23" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x0c]) }
</a><a href="#h6-19-24" id="h6-19-24" class="i">+            ])?
</a><a href="#h6-19-25" id="h6-19-25" class="i">+        );
</a><a href="#h6-19-26" id="h6-19-26" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-19-27" id="h6-19-27" class="i">+        assert_eq!(Some(Entry { index: 2, term: 3, command: Some(vec![0x0b]) }), l.get(2)?);
</a><a href="#h6-19-28" id="h6-19-28" class="i">+        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x0c]) }), l.get(3)?);
</a><a href="#h6-19-29" id="h6-19-29" class="i">+        assert_eq!((3, 3), l.get_last());
</a><a href="#h6-19-30" id="h6-19-30" class="i">+        Ok(())
</a><a href="#h6-19-31" id="h6-19-31" class="i">+    }
</a><a href="#h6-19-32" id="h6-19-32" class="i">+
</a><a href="#h6-19-33" id="h6-19-33" class="i">+    #[test]
</a><a href="#h6-19-34" id="h6-19-34" class="i">+    fn splice_error_noncontiguous() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h6-19-35" id="h6-19-35" class="i">+        let (mut l, _) = setup()?;
</a><a href="#h6-19-36" id="h6-19-36" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-19-37" id="h6-19-37" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-19-38" id="h6-19-38" class="i">+        l.append(3, Some(vec![0x03]))?;
</a><a href="#h6-19-39" id="h6-19-39" class="i">+
</a><a href="#h6-19-40" id="h6-19-40" class="i">+        assert_eq!(
</a><a href="#h6-19-41" id="h6-19-41" class="i">+            Err(Error::Internal(&quot;Spliced entries must be contiguous&quot;.into())),
</a><a href="#h6-19-42" id="h6-19-42" class="i">+            l.splice(vec![
</a><a href="#h6-19-43" id="h6-19-43" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h6-19-44" id="h6-19-44" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h6-19-45" id="h6-19-45" class="i">+            ])
</a><a href="#h6-19-46" id="h6-19-46" class="i">+        );
</a><a href="#h6-19-47" id="h6-19-47" class="i">+        // FIXME Use range for these assertions
</a><a href="#h6-19-48" id="h6-19-48" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-19-49" id="h6-19-49" class="i">+        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-19-50" id="h6-19-50" class="i">+        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h6-19-51" id="h6-19-51" class="i">+        assert_eq!((3, 3), l.get_last());
</a><a href="#h6-19-52" id="h6-19-52" class="i">+        Ok(())
</a><a href="#h6-19-53" id="h6-19-53" class="i">+    }
</a><a href="#h6-19-54" id="h6-19-54" class="i">+
</a><a href="#h6-19-55" id="h6-19-55" class="i">+    #[test]
</a><a href="#h6-19-56" id="h6-19-56" class="i">+    fn splice_error_beyond_last() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h6-19-57" id="h6-19-57" class="i">+        let (mut l, _) = setup()?;
</a><a href="#h6-19-58" id="h6-19-58" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-19-59" id="h6-19-59" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-19-60" id="h6-19-60" class="i">+        l.append(3, Some(vec![0x03]))?;
</a><a href="#h6-19-61" id="h6-19-61" class="i">+
</a><a href="#h6-19-62" id="h6-19-62" class="i">+        assert_eq!(
</a><a href="#h6-19-63" id="h6-19-63" class="i">+            Err(Error::Internal(&quot;Spliced entries cannot begin past last index&quot;.into())),
</a><a href="#h6-19-64" id="h6-19-64" class="i">+            l.splice(vec![
</a><a href="#h6-19-65" id="h6-19-65" class="i">+                Entry { index: 5, term: 3, command: Some(vec![0x05]) },
</a><a href="#h6-19-66" id="h6-19-66" class="i">+                Entry { index: 6, term: 3, command: Some(vec![0x06]) },
</a><a href="#h6-19-67" id="h6-19-67" class="i">+            ])
</a>         );
<a href="#h6-19-69" id="h6-19-69" class="d">-        assert_eq!(Some(Entry { term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-19-70" id="h6-19-70" class="d">-        assert_eq!(Some(Entry { term: 3, command: Some(vec![0x0b]) }), l.get(2)?);
</a><a href="#h6-19-71" id="h6-19-71" class="d">-        assert_eq!(Some(Entry { term: 3, command: Some(vec![0x0c]) }), l.get(3)?);
</a><a href="#h6-19-72" id="h6-19-72" class="i">+        // FIXME Use range for these assertions
</a><a href="#h6-19-73" id="h6-19-73" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-19-74" id="h6-19-74" class="i">+        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-19-75" id="h6-19-75" class="i">+        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a>         assert_eq!((3, 3), l.get_last());
         Ok(())
     }
<a href="#h6-20" id="h6-20" class="h">@@ -637,14 +535,14 @@ mod tests {
</a>     #[test]
     fn splice_overlap_inside() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-20-3" id="h6-20-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-20-4" id="h6-20-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-20-5" id="h6-20-5" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x03]) })?;
</a><a href="#h6-20-6" id="h6-20-6" class="d">-
</a><a href="#h6-20-7" id="h6-20-7" class="d">-        assert_eq!(3, l.splice(1, vec![Entry { term: 2, command: Some(vec![0x02]) },])?);
</a><a href="#h6-20-8" id="h6-20-8" class="d">-        assert_eq!(Some(Entry { term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-20-9" id="h6-20-9" class="d">-        assert_eq!(Some(Entry { term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-20-10" id="h6-20-10" class="d">-        assert_eq!(Some(Entry { term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h6-20-11" id="h6-20-11" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-20-12" id="h6-20-12" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-20-13" id="h6-20-13" class="i">+        l.append(3, Some(vec![0x03]))?;
</a><a href="#h6-20-14" id="h6-20-14" class="i">+
</a><a href="#h6-20-15" id="h6-20-15" class="i">+        assert_eq!(3, l.splice(vec![Entry { index: 2, term: 2, command: Some(vec![0x02]) },])?);
</a><a href="#h6-20-16" id="h6-20-16" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-20-17" id="h6-20-17" class="i">+        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-20-18" id="h6-20-18" class="i">+        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a>         assert_eq!((3, 3), l.get_last());
         Ok(())
     }
<a href="#h6-21" id="h6-21" class="h">@@ -652,13 +550,13 @@ mod tests {
</a>     #[test]
     fn truncate() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-21-3" id="h6-21-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-21-4" id="h6-21-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-21-5" id="h6-21-5" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x03]) })?;
</a><a href="#h6-21-6" id="h6-21-6" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-21-7" id="h6-21-7" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-21-8" id="h6-21-8" class="i">+        l.append(3, Some(vec![0x03]))?;
</a> 
         assert_eq!(2, l.truncate(2)?);
<a href="#h6-21-11" id="h6-21-11" class="d">-        assert_eq!(Some(Entry { term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-21-12" id="h6-21-12" class="d">-        assert_eq!(Some(Entry { term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-21-13" id="h6-21-13" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-21-14" id="h6-21-14" class="i">+        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a>         assert_eq!(None, l.get(3)?);
         assert_eq!((2, 2), l.get_last());
         Ok(())
<a href="#h6-22" id="h6-22" class="h">@@ -667,14 +565,14 @@ mod tests {
</a>     #[test]
     fn truncate_beyond() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-22-3" id="h6-22-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-22-4" id="h6-22-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-22-5" id="h6-22-5" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x03]) })?;
</a><a href="#h6-22-6" id="h6-22-6" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-22-7" id="h6-22-7" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-22-8" id="h6-22-8" class="i">+        l.append(3, Some(vec![0x03]))?;
</a> 
         assert_eq!(3, l.truncate(4)?);
<a href="#h6-22-11" id="h6-22-11" class="d">-        assert_eq!(Some(Entry { term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-22-12" id="h6-22-12" class="d">-        assert_eq!(Some(Entry { term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-22-13" id="h6-22-13" class="d">-        assert_eq!(Some(Entry { term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h6-22-14" id="h6-22-14" class="i">+        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h6-22-15" id="h6-22-15" class="i">+        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h6-22-16" id="h6-22-16" class="i">+        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a>         assert_eq!(None, l.get(4)?);
         assert_eq!((3, 3), l.get_last());
         Ok(())
<a href="#h6-23" id="h6-23" class="h">@@ -683,9 +581,9 @@ mod tests {
</a>     #[test]
     fn truncate_committed() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-23-3" id="h6-23-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-23-4" id="h6-23-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-23-5" id="h6-23-5" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x03]) })?;
</a><a href="#h6-23-6" id="h6-23-6" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-23-7" id="h6-23-7" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-23-8" id="h6-23-8" class="i">+        l.append(3, Some(vec![0x03]))?;
</a>         l.commit(2)?;
 
         assert_eq!(l.truncate(1), Err(Error::Value(&quot;Cannot remove committed log entry&quot;.into())));
<a href="#h6-24" id="h6-24" class="h">@@ -696,9 +594,9 @@ mod tests {
</a>     #[test]
     fn truncate_zero() -&gt; Result&lt;(), Error&gt; {
         let (mut l, _) = setup()?;
<a href="#h6-24-3" id="h6-24-3" class="d">-        l.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h6-24-4" id="h6-24-4" class="d">-        l.append(Entry { term: 2, command: Some(vec![0x02]) })?;
</a><a href="#h6-24-5" id="h6-24-5" class="d">-        l.append(Entry { term: 3, command: Some(vec![0x03]) })?;
</a><a href="#h6-24-6" id="h6-24-6" class="i">+        l.append(1, Some(vec![0x01]))?;
</a><a href="#h6-24-7" id="h6-24-7" class="i">+        l.append(2, Some(vec![0x02]))?;
</a><a href="#h6-24-8" id="h6-24-8" class="i">+        l.append(3, Some(vec![0x03]))?;
</a> 
         assert_eq!(0, l.truncate(0)?);
         assert_eq!(None, l.get(1)?);
<b>diff --git a/<a id="h7" href="../file/src/raft/message.rs.html">src/raft/message.rs</a> b/<a href="../file/src/raft/message.rs.html">src/raft/message.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -1,59 +1,34 @@
</a><a href="#h7-0-0" id="h7-0-0" class="d">-use super::Entry;
</a><a href="#h7-0-1" id="h7-0-1" class="i">+use super::{Entry, Status};
</a> use crate::Error;
 
 use serde_derive::{Deserialize, Serialize};
 
<a href="#h7-0-6" id="h7-0-6" class="i">+/// A message address.
</a><a href="#h7-0-7" id="h7-0-7" class="i">+#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize)]
</a><a href="#h7-0-8" id="h7-0-8" class="i">+pub enum Address {
</a><a href="#h7-0-9" id="h7-0-9" class="i">+    /// Broadcast to all peers.
</a><a href="#h7-0-10" id="h7-0-10" class="i">+    Peers,
</a><a href="#h7-0-11" id="h7-0-11" class="i">+    /// A remote peer.
</a><a href="#h7-0-12" id="h7-0-12" class="i">+    Peer(String),
</a><a href="#h7-0-13" id="h7-0-13" class="i">+    /// The local node.
</a><a href="#h7-0-14" id="h7-0-14" class="i">+    Local,
</a><a href="#h7-0-15" id="h7-0-15" class="i">+    /// A local client.
</a><a href="#h7-0-16" id="h7-0-16" class="i">+    Client,
</a><a href="#h7-0-17" id="h7-0-17" class="i">+}
</a><a href="#h7-0-18" id="h7-0-18" class="i">+
</a> /// A message passed between Raft nodes.
<a href="#h7-0-20" id="h7-0-20" class="d">-#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h7-0-21" id="h7-0-21" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a> pub struct Message {
     /// The current term of the sender.
     pub term: u64,
<a href="#h7-0-25" id="h7-0-25" class="d">-    /// The ID of the sending node, or None if local sender.
</a><a href="#h7-0-26" id="h7-0-26" class="d">-    pub from: Option&lt;String&gt;,
</a><a href="#h7-0-27" id="h7-0-27" class="d">-    /// The ID of the receiving node, or None if local receiver.
</a><a href="#h7-0-28" id="h7-0-28" class="d">-    pub to: Option&lt;String&gt;,
</a><a href="#h7-0-29" id="h7-0-29" class="i">+    /// The sender address.
</a><a href="#h7-0-30" id="h7-0-30" class="i">+    pub from: Address,
</a><a href="#h7-0-31" id="h7-0-31" class="i">+    /// The recipient address.
</a><a href="#h7-0-32" id="h7-0-32" class="i">+    pub to: Address,
</a>     /// The message event.
     pub event: Event,
 }
 
<a href="#h7-0-37" id="h7-0-37" class="d">-impl Message {
</a><a href="#h7-0-38" id="h7-0-38" class="d">-    /// Normalizes a message by setting to and term for local messages.
</a><a href="#h7-0-39" id="h7-0-39" class="d">-    pub fn normalize(&amp;mut self, node_id: &amp;str, term: u64) {
</a><a href="#h7-0-40" id="h7-0-40" class="d">-        if self.from.is_none() &amp;&amp; self.to.is_none() {
</a><a href="#h7-0-41" id="h7-0-41" class="d">-            self.to = Some(node_id.to_owned());
</a><a href="#h7-0-42" id="h7-0-42" class="d">-            if self.term == 0 {
</a><a href="#h7-0-43" id="h7-0-43" class="d">-                self.term = term;
</a><a href="#h7-0-44" id="h7-0-44" class="d">-            }
</a><a href="#h7-0-45" id="h7-0-45" class="d">-        }
</a><a href="#h7-0-46" id="h7-0-46" class="d">-    }
</a><a href="#h7-0-47" id="h7-0-47" class="d">-
</a><a href="#h7-0-48" id="h7-0-48" class="d">-    /// Validates a message against the receiving node.
</a><a href="#h7-0-49" id="h7-0-49" class="d">-    pub fn validate(&amp;self, node_id: &amp;str, term: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h7-0-50" id="h7-0-50" class="d">-        // Don&#39;t allow local messages without call ID
</a><a href="#h7-0-51" id="h7-0-51" class="d">-        if self.from.is_none() &amp;&amp; self.event.call_id().is_none() {
</a><a href="#h7-0-52" id="h7-0-52" class="d">-            return Err(Error::Internal(format!(
</a><a href="#h7-0-53" id="h7-0-53" class="d">-                &quot;Received local non-call event: {:?}&quot;,
</a><a href="#h7-0-54" id="h7-0-54" class="d">-                self.event
</a><a href="#h7-0-55" id="h7-0-55" class="d">-            )));
</a><a href="#h7-0-56" id="h7-0-56" class="d">-        }
</a><a href="#h7-0-57" id="h7-0-57" class="d">-
</a><a href="#h7-0-58" id="h7-0-58" class="d">-        // Ignore messages from past term
</a><a href="#h7-0-59" id="h7-0-59" class="d">-        if self.term &lt; term {
</a><a href="#h7-0-60" id="h7-0-60" class="d">-            return Err(Error::Internal(format!(&quot;Ignoring message from stale term {}&quot;, self.term)));
</a><a href="#h7-0-61" id="h7-0-61" class="d">-        }
</a><a href="#h7-0-62" id="h7-0-62" class="d">-
</a><a href="#h7-0-63" id="h7-0-63" class="d">-        // Ignore messages addressed to peers or local client
</a><a href="#h7-0-64" id="h7-0-64" class="d">-        if let Some(to) = &amp;self.to {
</a><a href="#h7-0-65" id="h7-0-65" class="d">-            if to != node_id {
</a><a href="#h7-0-66" id="h7-0-66" class="d">-                return Err(Error::Internal(format!(&quot;Ignoring message for other node {}&quot;, to)));
</a><a href="#h7-0-67" id="h7-0-67" class="d">-            }
</a><a href="#h7-0-68" id="h7-0-68" class="d">-        } else {
</a><a href="#h7-0-69" id="h7-0-69" class="d">-            return Err(Error::Internal(&quot;Ignoring message for local client&quot;.into()));
</a><a href="#h7-0-70" id="h7-0-70" class="d">-        }
</a><a href="#h7-0-71" id="h7-0-71" class="d">-        Ok(())
</a><a href="#h7-0-72" id="h7-0-72" class="d">-    }
</a><a href="#h7-0-73" id="h7-0-73" class="d">-}
</a><a href="#h7-0-74" id="h7-0-74" class="d">-
</a> /// An event contained within messages.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Event {
<a href="#h7-1" id="h7-1" class="h">@@ -98,115 +73,33 @@ pub enum Event {
</a>     },
     /// Followers may also reject a set of log entries from a leader.
     RejectEntries,
<a href="#h7-1-3" id="h7-1-3" class="d">-    /// Queries the state machine.
</a><a href="#h7-1-4" id="h7-1-4" class="d">-    QueryState {
</a><a href="#h7-1-5" id="h7-1-5" class="d">-        /// The call ID.
</a><a href="#h7-1-6" id="h7-1-6" class="d">-        call_id: Vec&lt;u8&gt;,
</a><a href="#h7-1-7" id="h7-1-7" class="d">-        /// The state machine command.
</a><a href="#h7-1-8" id="h7-1-8" class="d">-        command: Vec&lt;u8&gt;,
</a><a href="#h7-1-9" id="h7-1-9" class="d">-    },
</a><a href="#h7-1-10" id="h7-1-10" class="d">-    /// Mutates the state machine.
</a><a href="#h7-1-11" id="h7-1-11" class="d">-    MutateState {
</a><a href="#h7-1-12" id="h7-1-12" class="d">-        /// The call ID.
</a><a href="#h7-1-13" id="h7-1-13" class="d">-        call_id: Vec&lt;u8&gt;,
</a><a href="#h7-1-14" id="h7-1-14" class="d">-        /// The state machine command.
</a><a href="#h7-1-15" id="h7-1-15" class="d">-        command: Vec&lt;u8&gt;,
</a><a href="#h7-1-16" id="h7-1-16" class="i">+    /// A client request.
</a><a href="#h7-1-17" id="h7-1-17" class="i">+    ClientRequest {
</a><a href="#h7-1-18" id="h7-1-18" class="i">+        /// The request ID.
</a><a href="#h7-1-19" id="h7-1-19" class="i">+        id: Vec&lt;u8&gt;,
</a><a href="#h7-1-20" id="h7-1-20" class="i">+        /// The request.
</a><a href="#h7-1-21" id="h7-1-21" class="i">+        request: Request,
</a>     },
<a href="#h7-1-23" id="h7-1-23" class="d">-    /// The response of a state machine command.
</a><a href="#h7-1-24" id="h7-1-24" class="d">-    RespondState {
</a><a href="#h7-1-25" id="h7-1-25" class="d">-        /// The call ID.
</a><a href="#h7-1-26" id="h7-1-26" class="d">-        call_id: Vec&lt;u8&gt;,
</a><a href="#h7-1-27" id="h7-1-27" class="d">-        /// The command output.
</a><a href="#h7-1-28" id="h7-1-28" class="d">-        response: Vec&lt;u8&gt;,
</a><a href="#h7-1-29" id="h7-1-29" class="d">-    },
</a><a href="#h7-1-30" id="h7-1-30" class="d">-    /// An error response
</a><a href="#h7-1-31" id="h7-1-31" class="d">-    RespondError {
</a><a href="#h7-1-32" id="h7-1-32" class="d">-        /// The call ID.
</a><a href="#h7-1-33" id="h7-1-33" class="d">-        call_id: Vec&lt;u8&gt;,
</a><a href="#h7-1-34" id="h7-1-34" class="d">-        /// The error.
</a><a href="#h7-1-35" id="h7-1-35" class="d">-        error: Error,
</a><a href="#h7-1-36" id="h7-1-36" class="i">+    /// A client response.
</a><a href="#h7-1-37" id="h7-1-37" class="i">+    ClientResponse {
</a><a href="#h7-1-38" id="h7-1-38" class="i">+        /// The response ID.
</a><a href="#h7-1-39" id="h7-1-39" class="i">+        id: Vec&lt;u8&gt;,
</a><a href="#h7-1-40" id="h7-1-40" class="i">+        /// The response.
</a><a href="#h7-1-41" id="h7-1-41" class="i">+        response: Result&lt;Response, Error&gt;,
</a>     },
 }
 
<a href="#h7-1-45" id="h7-1-45" class="d">-impl Event {
</a><a href="#h7-1-46" id="h7-1-46" class="d">-    /// Returns the call ID for the event, if any
</a><a href="#h7-1-47" id="h7-1-47" class="d">-    pub fn call_id(&amp;self) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h7-1-48" id="h7-1-48" class="d">-        match self {
</a><a href="#h7-1-49" id="h7-1-49" class="d">-            Event::QueryState { call_id, .. }
</a><a href="#h7-1-50" id="h7-1-50" class="d">-            | Event::MutateState { call_id, .. }
</a><a href="#h7-1-51" id="h7-1-51" class="d">-            | Event::RespondState { call_id, .. }
</a><a href="#h7-1-52" id="h7-1-52" class="d">-            | Event::RespondError { call_id, .. } =&gt; Some(call_id.clone()),
</a><a href="#h7-1-53" id="h7-1-53" class="d">-            _ =&gt; None,
</a><a href="#h7-1-54" id="h7-1-54" class="d">-        }
</a><a href="#h7-1-55" id="h7-1-55" class="d">-    }
</a><a href="#h7-1-56" id="h7-1-56" class="i">+/// A client request.
</a><a href="#h7-1-57" id="h7-1-57" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h7-1-58" id="h7-1-58" class="i">+pub enum Request {
</a><a href="#h7-1-59" id="h7-1-59" class="i">+    Query(Vec&lt;u8&gt;),
</a><a href="#h7-1-60" id="h7-1-60" class="i">+    Mutate(Vec&lt;u8&gt;),
</a><a href="#h7-1-61" id="h7-1-61" class="i">+    Status,
</a> }
 
<a href="#h7-1-64" id="h7-1-64" class="d">-#[cfg(test)]
</a><a href="#h7-1-65" id="h7-1-65" class="d">-mod tests {
</a><a href="#h7-1-66" id="h7-1-66" class="d">-    use super::*;
</a><a href="#h7-1-67" id="h7-1-67" class="d">-
</a><a href="#h7-1-68" id="h7-1-68" class="d">-    #[test]
</a><a href="#h7-1-69" id="h7-1-69" class="d">-    fn normalize() {
</a><a href="#h7-1-70" id="h7-1-70" class="d">-        let mut msg = Message {
</a><a href="#h7-1-71" id="h7-1-71" class="d">-            from: None,
</a><a href="#h7-1-72" id="h7-1-72" class="d">-            to: None,
</a><a href="#h7-1-73" id="h7-1-73" class="d">-            term: 0,
</a><a href="#h7-1-74" id="h7-1-74" class="d">-            event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
</a><a href="#h7-1-75" id="h7-1-75" class="d">-        };
</a><a href="#h7-1-76" id="h7-1-76" class="d">-        msg.normalize(&quot;to&quot;, 3);
</a><a href="#h7-1-77" id="h7-1-77" class="d">-        assert_eq!(
</a><a href="#h7-1-78" id="h7-1-78" class="d">-            msg,
</a><a href="#h7-1-79" id="h7-1-79" class="d">-            Message {
</a><a href="#h7-1-80" id="h7-1-80" class="d">-                from: None,
</a><a href="#h7-1-81" id="h7-1-81" class="d">-                to: Some(&quot;to&quot;.into()),
</a><a href="#h7-1-82" id="h7-1-82" class="d">-                term: 3,
</a><a href="#h7-1-83" id="h7-1-83" class="d">-                event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
</a><a href="#h7-1-84" id="h7-1-84" class="d">-            }
</a><a href="#h7-1-85" id="h7-1-85" class="d">-        )
</a><a href="#h7-1-86" id="h7-1-86" class="d">-    }
</a><a href="#h7-1-87" id="h7-1-87" class="d">-
</a><a href="#h7-1-88" id="h7-1-88" class="d">-    #[test]
</a><a href="#h7-1-89" id="h7-1-89" class="d">-    fn normalize_peer() {
</a><a href="#h7-1-90" id="h7-1-90" class="d">-        let mut msg = Message {
</a><a href="#h7-1-91" id="h7-1-91" class="d">-            from: Some(&quot;from&quot;.into()),
</a><a href="#h7-1-92" id="h7-1-92" class="d">-            to: Some(&quot;to&quot;.into()),
</a><a href="#h7-1-93" id="h7-1-93" class="d">-            term: 3,
</a><a href="#h7-1-94" id="h7-1-94" class="d">-            event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
</a><a href="#h7-1-95" id="h7-1-95" class="d">-        };
</a><a href="#h7-1-96" id="h7-1-96" class="d">-        msg.normalize(&quot;other&quot;, 7);
</a><a href="#h7-1-97" id="h7-1-97" class="d">-        assert_eq!(
</a><a href="#h7-1-98" id="h7-1-98" class="d">-            msg,
</a><a href="#h7-1-99" id="h7-1-99" class="d">-            Message {
</a><a href="#h7-1-100" id="h7-1-100" class="d">-                from: Some(&quot;from&quot;.into()),
</a><a href="#h7-1-101" id="h7-1-101" class="d">-                to: Some(&quot;to&quot;.into()),
</a><a href="#h7-1-102" id="h7-1-102" class="d">-                term: 3,
</a><a href="#h7-1-103" id="h7-1-103" class="d">-                event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
</a><a href="#h7-1-104" id="h7-1-104" class="d">-            }
</a><a href="#h7-1-105" id="h7-1-105" class="d">-        )
</a><a href="#h7-1-106" id="h7-1-106" class="d">-    }
</a><a href="#h7-1-107" id="h7-1-107" class="d">-
</a><a href="#h7-1-108" id="h7-1-108" class="d">-    #[test]
</a><a href="#h7-1-109" id="h7-1-109" class="d">-    fn validate() {
</a><a href="#h7-1-110" id="h7-1-110" class="d">-        let event = Event::Heartbeat { commit_index: 1, commit_term: 1 };
</a><a href="#h7-1-111" id="h7-1-111" class="d">-
</a><a href="#h7-1-112" id="h7-1-112" class="d">-        // Errors on stale term
</a><a href="#h7-1-113" id="h7-1-113" class="d">-        assert!(Message {
</a><a href="#h7-1-114" id="h7-1-114" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h7-1-115" id="h7-1-115" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h7-1-116" id="h7-1-116" class="d">-            term: 2,
</a><a href="#h7-1-117" id="h7-1-117" class="d">-            event: event.clone(),
</a><a href="#h7-1-118" id="h7-1-118" class="d">-        }
</a><a href="#h7-1-119" id="h7-1-119" class="d">-        .validate(&quot;a&quot;, 3)
</a><a href="#h7-1-120" id="h7-1-120" class="d">-        .is_err());
</a><a href="#h7-1-121" id="h7-1-121" class="d">-
</a><a href="#h7-1-122" id="h7-1-122" class="d">-        // Errors on no receiver
</a><a href="#h7-1-123" id="h7-1-123" class="d">-        assert!(Message { from: Some(&quot;b&quot;.into()), to: None, term: 3, event: event.clone() }
</a><a href="#h7-1-124" id="h7-1-124" class="d">-            .validate(&quot;a&quot;, 3)
</a><a href="#h7-1-125" id="h7-1-125" class="d">-            .is_err());
</a><a href="#h7-1-126" id="h7-1-126" class="d">-
</a><a href="#h7-1-127" id="h7-1-127" class="d">-        // Errors on other receiver
</a><a href="#h7-1-128" id="h7-1-128" class="d">-        assert!(Message { from: Some(&quot;b&quot;.into()), to: Some(&quot;c&quot;.into()), term: 3, event: event }
</a><a href="#h7-1-129" id="h7-1-129" class="d">-            .validate(&quot;a&quot;, 3)
</a><a href="#h7-1-130" id="h7-1-130" class="d">-            .is_err());
</a><a href="#h7-1-131" id="h7-1-131" class="d">-    }
</a><a href="#h7-1-132" id="h7-1-132" class="i">+/// A client response.
</a><a href="#h7-1-133" id="h7-1-133" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h7-1-134" id="h7-1-134" class="i">+pub enum Response {
</a><a href="#h7-1-135" id="h7-1-135" class="i">+    State(Vec&lt;u8&gt;),
</a><a href="#h7-1-136" id="h7-1-136" class="i">+    Status(Status),
</a> }
<b>diff --git a/<a id="h8" href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a> b/<a href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -6,8 +6,8 @@ mod server;
</a> mod state;
 
 pub use self::log::{Entry, Log};
<a href="#h8-0-3" id="h8-0-3" class="d">-pub use client::{Client, Request, Response};
</a><a href="#h8-0-4" id="h8-0-4" class="d">-pub use message::{Event, Message};
</a><a href="#h8-0-5" id="h8-0-5" class="i">+pub use client::Client;
</a><a href="#h8-0-6" id="h8-0-6" class="i">+pub use message::{Address, Event, Message, Request, Response};
</a> pub use node::{Node, Status};
 pub use server::Server;
<a href="#h8-0-9" id="h8-0-9" class="d">-pub use state::State;
</a><a href="#h8-0-10" id="h8-0-10" class="i">+pub use state::{Driver, Instruction, State};
</a><b>diff --git a/<a id="h9" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,9 +1,9 @@
</a><a href="#h9-0-0" id="h9-0-0" class="d">-use super::super::{Event, Message, State};
</a><a href="#h9-0-1" id="h9-0-1" class="i">+use super::super::{Address, Event, Message, Response};
</a> use super::{Follower, Leader, Node, RoleNode, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
 use crate::kv::storage::Storage;
 use crate::Error;
 
<a href="#h9-0-6" id="h9-0-6" class="d">-use log::{debug, info};
</a><a href="#h9-0-7" id="h9-0-7" class="i">+use log::{debug, info, warn};
</a> use rand::Rng as _;
 
 /// A candidate is campaigning to become a leader.
<a href="#h9-1" id="h9-1" class="h">@@ -21,80 +21,94 @@ impl Candidate {
</a>     /// Creates a new candidate role.
     pub fn new() -&gt; Self {
         Self {
<a href="#h9-1-3" id="h9-1-3" class="i">+            votes: 1, // We always start with a vote for ourselves.
</a>             election_ticks: 0,
             election_timeout: rand::thread_rng()
                 .gen_range(ELECTION_TIMEOUT_MIN, ELECTION_TIMEOUT_MAX),
<a href="#h9-1-7" id="h9-1-7" class="d">-            // We always start with a vote for ourselves.
</a><a href="#h9-1-8" id="h9-1-8" class="d">-            votes: 1,
</a>         }
     }
 }
 
<a href="#h9-1-13" id="h9-1-13" class="d">-impl&lt;L: Storage, S: State&gt; RoleNode&lt;Candidate, L, S&gt; {
</a><a href="#h9-1-14" id="h9-1-14" class="i">+impl&lt;L: Storage&gt; RoleNode&lt;Candidate, L&gt; {
</a>     /// Transition to follower role.
<a href="#h9-1-16" id="h9-1-16" class="d">-    fn become_follower(
</a><a href="#h9-1-17" id="h9-1-17" class="d">-        mut self,
</a><a href="#h9-1-18" id="h9-1-18" class="d">-        term: u64,
</a><a href="#h9-1-19" id="h9-1-19" class="d">-        leader: &amp;str,
</a><a href="#h9-1-20" id="h9-1-20" class="d">-    ) -&gt; Result&lt;RoleNode&lt;Follower, L, S&gt;, Error&gt; {
</a><a href="#h9-1-21" id="h9-1-21" class="i">+    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;, Error&gt; {
</a>         info!(&quot;Discovered leader {} for term {}, following&quot;, leader, term);
         self.save_term(term, None)?;
<a href="#h9-1-24" id="h9-1-24" class="d">-        self.become_role(Follower::new(Some(leader), None))
</a><a href="#h9-1-25" id="h9-1-25" class="i">+        let mut node = self.become_role(Follower::new(Some(leader), None))?;
</a><a href="#h9-1-26" id="h9-1-26" class="i">+        node.abort_proxied()?;
</a><a href="#h9-1-27" id="h9-1-27" class="i">+        node.forward_queued(Address::Peer(leader.to_string()))?;
</a><a href="#h9-1-28" id="h9-1-28" class="i">+        Ok(node)
</a>     }
 
     /// Transition to leader role.
<a href="#h9-1-32" id="h9-1-32" class="d">-    fn become_leader(self) -&gt; Result&lt;RoleNode&lt;Leader, L, S&gt;, Error&gt; {
</a><a href="#h9-1-33" id="h9-1-33" class="i">+    fn become_leader(self) -&gt; Result&lt;RoleNode&lt;Leader, L&gt;, Error&gt; {
</a>         info!(&quot;Won election for term {}, becoming leader&quot;, self.term);
         let peers = self.peers.clone();
         let (last_index, _) = self.log.get_last();
         let (commit_index, commit_term) = self.log.get_committed();
         let mut node = self.become_role(Leader::new(peers, last_index))?;
<a href="#h9-1-39" id="h9-1-39" class="d">-        node.broadcast(Event::Heartbeat { commit_index, commit_term })?;
</a><a href="#h9-1-40" id="h9-1-40" class="i">+        node.send(Address::Peers, Event::Heartbeat { commit_index, commit_term })?;
</a>         node.append(None)?;
<a href="#h9-1-42" id="h9-1-42" class="i">+        node.abort_proxied()?;
</a>         Ok(node)
     }
 
     /// Processes a message.
<a href="#h9-1-47" id="h9-1-47" class="d">-    pub fn step(mut self, mut msg: Message) -&gt; Result&lt;Node&lt;L, S&gt;, Error&gt; {
</a><a href="#h9-1-48" id="h9-1-48" class="d">-        if !self.normalize_message(&amp;mut msg) {
</a><a href="#h9-1-49" id="h9-1-49" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h9-1-50" id="h9-1-50" class="i">+        if let Err(err) = self.validate(&amp;msg) {
</a><a href="#h9-1-51" id="h9-1-51" class="i">+            warn!(&quot;Ignoring invalid message: {}&quot;, err);
</a>             return Ok(self.into());
         }
         if msg.term &gt; self.term {
<a href="#h9-1-55" id="h9-1-55" class="d">-            if let Some(from) = &amp;msg.from {
</a><a href="#h9-1-56" id="h9-1-56" class="i">+            if let Address::Peer(from) = &amp;msg.from {
</a>                 return self.become_follower(msg.term, from)?.step(msg);
             }
         }
 
         match msg.event {
             Event::Heartbeat { .. } =&gt; {
<a href="#h9-1-63" id="h9-1-63" class="d">-                if let Some(from) = &amp;msg.from {
</a><a href="#h9-1-64" id="h9-1-64" class="i">+                if let Address::Peer(from) = &amp;msg.from {
</a>                     return self.become_follower(msg.term, from)?.step(msg);
                 }
             }
<a href="#h9-1-68" id="h9-1-68" class="i">+
</a>             Event::GrantVote =&gt; {
                 debug!(&quot;Received term {} vote from {:?}&quot;, self.term, msg.from);
                 self.role.votes += 1;
                 if self.role.votes &gt;= self.quorum() {
<a href="#h9-1-73" id="h9-1-73" class="d">-                    return Ok(self.become_leader()?.into());
</a><a href="#h9-1-74" id="h9-1-74" class="i">+                    let queued = std::mem::replace(&amp;mut self.queued_reqs, Vec::new());
</a><a href="#h9-1-75" id="h9-1-75" class="i">+                    let mut node: Node&lt;_&gt; = self.become_leader()?.into();
</a><a href="#h9-1-76" id="h9-1-76" class="i">+                    for (from, event) in queued {
</a><a href="#h9-1-77" id="h9-1-77" class="i">+                        node = node.step(Message { from, to: Address::Local, term: 0, event })?;
</a><a href="#h9-1-78" id="h9-1-78" class="i">+                    }
</a><a href="#h9-1-79" id="h9-1-79" class="i">+                    return Ok(node);
</a>                 }
             }
<a href="#h9-1-82" id="h9-1-82" class="d">-            Event::ConfirmLeader { .. } =&gt; {}
</a><a href="#h9-1-83" id="h9-1-83" class="i">+
</a><a href="#h9-1-84" id="h9-1-84" class="i">+            Event::ClientRequest { .. } =&gt; self.queued_reqs.push((msg.from, msg.event)),
</a><a href="#h9-1-85" id="h9-1-85" class="i">+
</a><a href="#h9-1-86" id="h9-1-86" class="i">+            Event::ClientResponse { id, mut response } =&gt; {
</a><a href="#h9-1-87" id="h9-1-87" class="i">+                if let Ok(Response::Status(ref mut status)) = response {
</a><a href="#h9-1-88" id="h9-1-88" class="i">+                    status.id = self.id.clone();
</a><a href="#h9-1-89" id="h9-1-89" class="i">+                    status.role = &quot;candidate&quot;.into();
</a><a href="#h9-1-90" id="h9-1-90" class="i">+                }
</a><a href="#h9-1-91" id="h9-1-91" class="i">+                self.proxied_reqs.remove(&amp;id);
</a><a href="#h9-1-92" id="h9-1-92" class="i">+                self.send(Address::Client, Event::ClientResponse { id, response })?;
</a><a href="#h9-1-93" id="h9-1-93" class="i">+            }
</a><a href="#h9-1-94" id="h9-1-94" class="i">+
</a><a href="#h9-1-95" id="h9-1-95" class="i">+            // Ignore other candidates when we&#39;re also campaigning
</a>             Event::SolicitVote { .. } =&gt; {}
<a href="#h9-1-97" id="h9-1-97" class="d">-            Event::ReplicateEntries { .. } =&gt; {}
</a><a href="#h9-1-98" id="h9-1-98" class="d">-            Event::AcceptEntries { .. } =&gt; {}
</a><a href="#h9-1-99" id="h9-1-99" class="d">-            Event::RejectEntries { .. } =&gt; {}
</a><a href="#h9-1-100" id="h9-1-100" class="d">-            // FIXME These should be queued or something
</a><a href="#h9-1-101" id="h9-1-101" class="d">-            Event::QueryState { .. } =&gt; {}
</a><a href="#h9-1-102" id="h9-1-102" class="d">-            Event::MutateState { .. } =&gt; {}
</a><a href="#h9-1-103" id="h9-1-103" class="d">-            Event::RespondState { .. } =&gt; {}
</a><a href="#h9-1-104" id="h9-1-104" class="d">-            Event::RespondError { .. } =&gt; {}
</a><a href="#h9-1-105" id="h9-1-105" class="i">+
</a><a href="#h9-1-106" id="h9-1-106" class="i">+            Event::ConfirmLeader { .. }
</a><a href="#h9-1-107" id="h9-1-107" class="i">+            | Event::ReplicateEntries { .. }
</a><a href="#h9-1-108" id="h9-1-108" class="i">+            | Event::AcceptEntries { .. }
</a><a href="#h9-1-109" id="h9-1-109" class="i">+            | Event::RejectEntries { .. } =&gt; warn!(&quot;Received unexpected message {:?}&quot;, msg),
</a>         }
         Ok(self.into())
     }
 
     /// Processes a logical clock tick.
<a href="#h9-1-115" id="h9-1-115" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L, S&gt;, Error&gt; {
</a><a href="#h9-1-116" id="h9-1-116" class="d">-        while let Some(_) = self.log.apply(&amp;mut self.state)? {}
</a><a href="#h9-1-117" id="h9-1-117" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a>         // If the election times out, start a new one for the next term.
         self.role.election_ticks += 1;
         if self.role.election_ticks &gt;= self.role.election_timeout {
<a href="#h9-2" id="h9-2" class="h">@@ -102,7 +116,7 @@ impl&lt;L: Storage, S: State&gt; RoleNode&lt;Candidate, L, S&gt; {
</a>             self.save_term(self.term + 1, None)?;
             self.role = Candidate::new();
             let (last_index, last_term) = self.log.get_last();
<a href="#h9-2-3" id="h9-2-3" class="d">-            self.broadcast(Event::SolicitVote { last_index, last_term })?;
</a><a href="#h9-2-4" id="h9-2-4" class="i">+            self.send(Address::Peers, Event::SolicitVote { last_index, last_term })?;
</a>         }
         Ok(self.into())
     }
<a href="#h9-3" id="h9-3" class="h">@@ -110,182 +124,244 @@ impl&lt;L: Storage, S: State&gt; RoleNode&lt;Candidate, L, S&gt; {
</a> 
 #[cfg(test)]
 mod tests {
<a href="#h9-3-3" id="h9-3-3" class="d">-    use super::super::super::{Entry, Log};
</a><a href="#h9-3-4" id="h9-3-4" class="d">-    use super::super::tests::{assert_messages, assert_node, TestState};
</a><a href="#h9-3-5" id="h9-3-5" class="i">+    use super::super::super::{Entry, Instruction, Log, Request};
</a><a href="#h9-3-6" id="h9-3-6" class="i">+    use super::super::tests::{assert_messages, assert_node};
</a>     use super::*;
     use crate::kv;
<a href="#h9-3-9" id="h9-3-9" class="i">+    use std::collections::HashMap;
</a>     use tokio::sync::mpsc;
 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;
<a href="#h9-3-14" id="h9-3-14" class="d">-        (RoleNode&lt;Candidate, kv::storage::Test, TestState&gt;, mpsc::UnboundedReceiver&lt;Message&gt;),
</a><a href="#h9-3-15" id="h9-3-15" class="i">+        (
</a><a href="#h9-3-16" id="h9-3-16" class="i">+            RoleNode&lt;Candidate, kv::storage::Test&gt;,
</a><a href="#h9-3-17" id="h9-3-17" class="i">+            mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h9-3-18" id="h9-3-18" class="i">+            mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h9-3-19" id="h9-3-19" class="i">+        ),
</a>         Error,
     &gt; {
<a href="#h9-3-22" id="h9-3-22" class="d">-        let (sender, receiver) = mpsc::unbounded_channel();
</a><a href="#h9-3-23" id="h9-3-23" class="d">-        let mut state = TestState::new();
</a><a href="#h9-3-24" id="h9-3-24" class="i">+        let (node_tx, mut node_rx) = mpsc::unbounded_channel();
</a><a href="#h9-3-25" id="h9-3-25" class="i">+        let (state_tx, state_rx) = mpsc::unbounded_channel();
</a>         let mut log = Log::new(kv::Simple::new(kv::storage::Test::new()))?;
<a href="#h9-3-27" id="h9-3-27" class="d">-        log.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h9-3-28" id="h9-3-28" class="d">-        log.append(Entry { term: 1, command: Some(vec![0x02]) })?;
</a><a href="#h9-3-29" id="h9-3-29" class="d">-        log.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h9-3-30" id="h9-3-30" class="i">+        log.append(1, Some(vec![0x01]))?;
</a><a href="#h9-3-31" id="h9-3-31" class="i">+        log.append(1, Some(vec![0x02]))?;
</a><a href="#h9-3-32" id="h9-3-32" class="i">+        log.append(2, Some(vec![0x03]))?;
</a>         log.commit(2)?;
<a href="#h9-3-34" id="h9-3-34" class="d">-        log.apply(&amp;mut state)?;
</a> 
         let mut node = RoleNode {
             id: &quot;a&quot;.into(),
             peers: vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()],
             term: 3,
             log,
<a href="#h9-3-41" id="h9-3-41" class="d">-            state,
</a><a href="#h9-3-42" id="h9-3-42" class="d">-            sender,
</a><a href="#h9-3-43" id="h9-3-43" class="i">+            node_tx,
</a><a href="#h9-3-44" id="h9-3-44" class="i">+            state_tx,
</a><a href="#h9-3-45" id="h9-3-45" class="i">+            queued_reqs: Vec::new(),
</a><a href="#h9-3-46" id="h9-3-46" class="i">+            proxied_reqs: HashMap::new(),
</a>             role: Candidate::new(),
         };
         node.save_term(3, None)?;
<a href="#h9-3-50" id="h9-3-50" class="d">-        Ok((node, receiver))
</a><a href="#h9-3-51" id="h9-3-51" class="i">+        node = match node.step(Message {
</a><a href="#h9-3-52" id="h9-3-52" class="i">+            from: Address::Client,
</a><a href="#h9-3-53" id="h9-3-53" class="i">+            to: Address::Local,
</a><a href="#h9-3-54" id="h9-3-54" class="i">+            term: 0,
</a><a href="#h9-3-55" id="h9-3-55" class="i">+            event: Event::ClientRequest { id: vec![0xaf], request: Request::Query(vec![0xf0]) },
</a><a href="#h9-3-56" id="h9-3-56" class="i">+        })? {
</a><a href="#h9-3-57" id="h9-3-57" class="i">+            Node::Candidate(c) =&gt; c,
</a><a href="#h9-3-58" id="h9-3-58" class="i">+            _ =&gt; panic!(&quot;Unexpected node type&quot;),
</a><a href="#h9-3-59" id="h9-3-59" class="i">+        };
</a><a href="#h9-3-60" id="h9-3-60" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h9-3-61" id="h9-3-61" class="i">+        Ok((node, node_rx, state_rx))
</a>     }
 
     #[test]
<a href="#h9-3-65" id="h9-3-65" class="d">-    // Heartbeat for current term converts to follower and emits ConfirmLeader event
</a><a href="#h9-3-66" id="h9-3-66" class="i">+    // Heartbeat for current term converts to follower, forwards the queued request from setup(),
</a><a href="#h9-3-67" id="h9-3-67" class="i">+    // and emits ConfirmLeader.
</a>     fn step_heartbeat_current_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h9-3-69" id="h9-3-69" class="d">-        let (candidate, mut rx) = setup()?;
</a><a href="#h9-3-70" id="h9-3-70" class="i">+        let (candidate, mut node_rx, mut state_rx) = setup()?;
</a>         let node = candidate.step(Message {
<a href="#h9-3-72" id="h9-3-72" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h9-3-73" id="h9-3-73" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-74" id="h9-3-74" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h9-3-75" id="h9-3-75" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
         })?;
         assert_node(&amp;node).is_follower().term(3);
         assert_messages(
<a href="#h9-3-81" id="h9-3-81" class="d">-            &amp;mut rx,
</a><a href="#h9-3-82" id="h9-3-82" class="d">-            vec![Message {
</a><a href="#h9-3-83" id="h9-3-83" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-84" id="h9-3-84" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h9-3-85" id="h9-3-85" class="d">-                term: 3,
</a><a href="#h9-3-86" id="h9-3-86" class="d">-                event: Event::ConfirmLeader { commit_index: 1, has_committed: true },
</a><a href="#h9-3-87" id="h9-3-87" class="d">-            }],
</a><a href="#h9-3-88" id="h9-3-88" class="i">+            &amp;mut node_rx,
</a><a href="#h9-3-89" id="h9-3-89" class="i">+            vec![
</a><a href="#h9-3-90" id="h9-3-90" class="i">+                Message {
</a><a href="#h9-3-91" id="h9-3-91" class="i">+                    from: Address::Local,
</a><a href="#h9-3-92" id="h9-3-92" class="i">+                    to: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h9-3-93" id="h9-3-93" class="i">+                    term: 0,
</a><a href="#h9-3-94" id="h9-3-94" class="i">+                    event: Event::ClientRequest {
</a><a href="#h9-3-95" id="h9-3-95" class="i">+                        id: vec![0xaf],
</a><a href="#h9-3-96" id="h9-3-96" class="i">+                        request: Request::Query(vec![0xf0]),
</a><a href="#h9-3-97" id="h9-3-97" class="i">+                    },
</a><a href="#h9-3-98" id="h9-3-98" class="i">+                },
</a><a href="#h9-3-99" id="h9-3-99" class="i">+                Message {
</a><a href="#h9-3-100" id="h9-3-100" class="i">+                    from: Address::Local,
</a><a href="#h9-3-101" id="h9-3-101" class="i">+                    to: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h9-3-102" id="h9-3-102" class="i">+                    term: 3,
</a><a href="#h9-3-103" id="h9-3-103" class="i">+                    event: Event::ConfirmLeader { commit_index: 1, has_committed: true },
</a><a href="#h9-3-104" id="h9-3-104" class="i">+                },
</a><a href="#h9-3-105" id="h9-3-105" class="i">+            ],
</a>         );
<a href="#h9-3-107" id="h9-3-107" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
<a href="#h9-3-112" id="h9-3-112" class="d">-    // Heartbeat for future term converts to follower and emits ConfirmLeader event
</a><a href="#h9-3-113" id="h9-3-113" class="i">+    // Heartbeat for future term converts to follower, forwards queued request, and emits
</a><a href="#h9-3-114" id="h9-3-114" class="i">+    // ConfirmLeader event
</a>     fn step_heartbeat_future_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h9-3-116" id="h9-3-116" class="d">-        let (candidate, mut rx) = setup()?;
</a><a href="#h9-3-117" id="h9-3-117" class="i">+        let (candidate, mut node_rx, mut state_rx) = setup()?;
</a>         let node = candidate.step(Message {
<a href="#h9-3-119" id="h9-3-119" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h9-3-120" id="h9-3-120" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-121" id="h9-3-121" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h9-3-122" id="h9-3-122" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 4,
             event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
         })?;
         assert_node(&amp;node).is_follower().term(4);
         assert_messages(
<a href="#h9-3-128" id="h9-3-128" class="d">-            &amp;mut rx,
</a><a href="#h9-3-129" id="h9-3-129" class="d">-            vec![Message {
</a><a href="#h9-3-130" id="h9-3-130" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-131" id="h9-3-131" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h9-3-132" id="h9-3-132" class="d">-                term: 4,
</a><a href="#h9-3-133" id="h9-3-133" class="d">-                event: Event::ConfirmLeader { commit_index: 1, has_committed: true },
</a><a href="#h9-3-134" id="h9-3-134" class="d">-            }],
</a><a href="#h9-3-135" id="h9-3-135" class="i">+            &amp;mut node_rx,
</a><a href="#h9-3-136" id="h9-3-136" class="i">+            vec![
</a><a href="#h9-3-137" id="h9-3-137" class="i">+                Message {
</a><a href="#h9-3-138" id="h9-3-138" class="i">+                    from: Address::Local,
</a><a href="#h9-3-139" id="h9-3-139" class="i">+                    to: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h9-3-140" id="h9-3-140" class="i">+                    term: 0,
</a><a href="#h9-3-141" id="h9-3-141" class="i">+                    event: Event::ClientRequest {
</a><a href="#h9-3-142" id="h9-3-142" class="i">+                        id: vec![0xaf],
</a><a href="#h9-3-143" id="h9-3-143" class="i">+                        request: Request::Query(vec![0xf0]),
</a><a href="#h9-3-144" id="h9-3-144" class="i">+                    },
</a><a href="#h9-3-145" id="h9-3-145" class="i">+                },
</a><a href="#h9-3-146" id="h9-3-146" class="i">+                Message {
</a><a href="#h9-3-147" id="h9-3-147" class="i">+                    from: Address::Local,
</a><a href="#h9-3-148" id="h9-3-148" class="i">+                    to: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h9-3-149" id="h9-3-149" class="i">+                    term: 4,
</a><a href="#h9-3-150" id="h9-3-150" class="i">+                    event: Event::ConfirmLeader { commit_index: 1, has_committed: true },
</a><a href="#h9-3-151" id="h9-3-151" class="i">+                },
</a><a href="#h9-3-152" id="h9-3-152" class="i">+            ],
</a>         );
<a href="#h9-3-154" id="h9-3-154" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // Heartbeat for past term is ignored
     fn step_heartbeat_past_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h9-3-161" id="h9-3-161" class="d">-        let (candidate, mut rx) = setup()?;
</a><a href="#h9-3-162" id="h9-3-162" class="i">+        let (candidate, mut node_rx, mut state_rx) = setup()?;
</a>         let node = candidate.step(Message {
<a href="#h9-3-164" id="h9-3-164" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h9-3-165" id="h9-3-165" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-166" id="h9-3-166" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h9-3-167" id="h9-3-167" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 2,
             event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
         })?;
         assert_node(&amp;node).is_candidate().term(3);
<a href="#h9-3-172" id="h9-3-172" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h9-3-173" id="h9-3-173" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h9-3-174" id="h9-3-174" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     fn step_grantvote() -&gt; Result&lt;(), Error&gt; {
<a href="#h9-3-180" id="h9-3-180" class="d">-        let (candidate, mut rx) = setup()?;
</a><a href="#h9-3-181" id="h9-3-181" class="i">+        let (candidate, mut node_rx, mut state_rx) = setup()?;
</a>         let peers = candidate.peers.clone();
         let mut node = Node::Candidate(candidate);
 
         // The first vote is not sufficient for a quorum (3 votes including self)
         node = node.step(Message {
<a href="#h9-3-187" id="h9-3-187" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h9-3-188" id="h9-3-188" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-189" id="h9-3-189" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h9-3-190" id="h9-3-190" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::GrantVote,
         })?;
         assert_node(&amp;node).is_candidate().term(3);
<a href="#h9-3-195" id="h9-3-195" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h9-3-196" id="h9-3-196" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h9-3-197" id="h9-3-197" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a> 
         // However, the second external vote makes us leader
         node = node.step(Message {
<a href="#h9-3-201" id="h9-3-201" class="d">-            from: Some(&quot;e&quot;.into()),
</a><a href="#h9-3-202" id="h9-3-202" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-203" id="h9-3-203" class="i">+            from: Address::Peer(&quot;e&quot;.into()),
</a><a href="#h9-3-204" id="h9-3-204" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::GrantVote,
         })?;
         assert_node(&amp;node).is_leader().term(3);
 
<a href="#h9-3-210" id="h9-3-210" class="d">-        for to in peers.iter().cloned() {
</a><a href="#h9-3-211" id="h9-3-211" class="d">-            assert_eq!(
</a><a href="#h9-3-212" id="h9-3-212" class="d">-                rx.try_recv()?,
</a><a href="#h9-3-213" id="h9-3-213" class="d">-                Message {
</a><a href="#h9-3-214" id="h9-3-214" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-215" id="h9-3-215" class="d">-                    to: Some(to),
</a><a href="#h9-3-216" id="h9-3-216" class="d">-                    term: 3,
</a><a href="#h9-3-217" id="h9-3-217" class="d">-                    event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
</a><a href="#h9-3-218" id="h9-3-218" class="d">-                }
</a><a href="#h9-3-219" id="h9-3-219" class="d">-            )
</a><a href="#h9-3-220" id="h9-3-220" class="d">-        }
</a><a href="#h9-3-221" id="h9-3-221" class="i">+        assert_eq!(
</a><a href="#h9-3-222" id="h9-3-222" class="i">+            node_rx.try_recv()?,
</a><a href="#h9-3-223" id="h9-3-223" class="i">+            Message {
</a><a href="#h9-3-224" id="h9-3-224" class="i">+                from: Address::Local,
</a><a href="#h9-3-225" id="h9-3-225" class="i">+                to: Address::Peers,
</a><a href="#h9-3-226" id="h9-3-226" class="i">+                term: 3,
</a><a href="#h9-3-227" id="h9-3-227" class="i">+                event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
</a><a href="#h9-3-228" id="h9-3-228" class="i">+            },
</a><a href="#h9-3-229" id="h9-3-229" class="i">+        );
</a> 
         for to in peers.iter().cloned() {
             assert_eq!(
<a href="#h9-3-233" id="h9-3-233" class="d">-                rx.try_recv()?,
</a><a href="#h9-3-234" id="h9-3-234" class="i">+                node_rx.try_recv()?,
</a>                 Message {
<a href="#h9-3-236" id="h9-3-236" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-237" id="h9-3-237" class="d">-                    to: Some(to),
</a><a href="#h9-3-238" id="h9-3-238" class="i">+                    from: Address::Local,
</a><a href="#h9-3-239" id="h9-3-239" class="i">+                    to: Address::Peer(to),
</a>                     term: 3,
                     event: Event::ReplicateEntries {
                         base_index: 3,
                         base_term: 2,
<a href="#h9-3-244" id="h9-3-244" class="d">-                        entries: vec![Entry { term: 3, command: None }],
</a><a href="#h9-3-245" id="h9-3-245" class="i">+                        entries: vec![Entry { index: 4, term: 3, command: None }],
</a>                     },
                 }
             )
         }
 
<a href="#h9-3-251" id="h9-3-251" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h9-3-252" id="h9-3-252" class="i">+        // Now that we&#39;re leader, we process the queued request
</a><a href="#h9-3-253" id="h9-3-253" class="i">+        assert_messages(
</a><a href="#h9-3-254" id="h9-3-254" class="i">+            &amp;mut node_rx,
</a><a href="#h9-3-255" id="h9-3-255" class="i">+            vec![Message {
</a><a href="#h9-3-256" id="h9-3-256" class="i">+                from: Address::Local,
</a><a href="#h9-3-257" id="h9-3-257" class="i">+                to: Address::Peers,
</a><a href="#h9-3-258" id="h9-3-258" class="i">+                term: 3,
</a><a href="#h9-3-259" id="h9-3-259" class="i">+                event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
</a><a href="#h9-3-260" id="h9-3-260" class="i">+            }],
</a><a href="#h9-3-261" id="h9-3-261" class="i">+        );
</a><a href="#h9-3-262" id="h9-3-262" class="i">+        assert_messages(
</a><a href="#h9-3-263" id="h9-3-263" class="i">+            &amp;mut state_rx,
</a><a href="#h9-3-264" id="h9-3-264" class="i">+            vec![
</a><a href="#h9-3-265" id="h9-3-265" class="i">+                Instruction::Query {
</a><a href="#h9-3-266" id="h9-3-266" class="i">+                    id: vec![0xaf],
</a><a href="#h9-3-267" id="h9-3-267" class="i">+                    address: Address::Client,
</a><a href="#h9-3-268" id="h9-3-268" class="i">+                    command: vec![0xf0],
</a><a href="#h9-3-269" id="h9-3-269" class="i">+                    index: 2,
</a><a href="#h9-3-270" id="h9-3-270" class="i">+                    quorum: 3,
</a><a href="#h9-3-271" id="h9-3-271" class="i">+                },
</a><a href="#h9-3-272" id="h9-3-272" class="i">+                Instruction::Vote { index: 2, address: Address::Local },
</a><a href="#h9-3-273" id="h9-3-273" class="i">+            ],
</a><a href="#h9-3-274" id="h9-3-274" class="i">+        );
</a>         Ok(())
     }
 
     #[test]
     fn tick() -&gt; Result&lt;(), Error&gt; {
<a href="#h9-3-280" id="h9-3-280" class="d">-        let (candidate, mut rx) = setup()?;
</a><a href="#h9-3-281" id="h9-3-281" class="i">+        let (candidate, mut node_rx, mut state_rx) = setup()?;
</a>         let timeout = candidate.role.election_timeout;
<a href="#h9-3-283" id="h9-3-283" class="d">-        let peers = candidate.peers.clone();
</a>         let mut node = Node::Candidate(candidate);
 
         assert!(timeout &gt; 0);
<a href="#h9-3-287" id="h9-3-287" class="d">-        for i in 0..timeout {
</a><a href="#h9-3-288" id="h9-3-288" class="d">-            assert_node(&amp;node).is_candidate().term(3).applied(if i &gt; 0 { 2 } else { 1 });
</a><a href="#h9-3-289" id="h9-3-289" class="i">+        for _ in 0..timeout {
</a><a href="#h9-3-290" id="h9-3-290" class="i">+            assert_node(&amp;node).is_candidate().term(3);
</a>             node = node.tick()?;
         }
         assert_node(&amp;node).is_candidate().term(4);
 
<a href="#h9-3-295" id="h9-3-295" class="d">-        for to in peers.into_iter() {
</a><a href="#h9-3-296" id="h9-3-296" class="d">-            assert_eq!(
</a><a href="#h9-3-297" id="h9-3-297" class="d">-                rx.try_recv()?,
</a><a href="#h9-3-298" id="h9-3-298" class="d">-                Message {
</a><a href="#h9-3-299" id="h9-3-299" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h9-3-300" id="h9-3-300" class="d">-                    to: Some(to),
</a><a href="#h9-3-301" id="h9-3-301" class="d">-                    term: 4,
</a><a href="#h9-3-302" id="h9-3-302" class="d">-                    event: Event::SolicitVote { last_index: 3, last_term: 2 },
</a><a href="#h9-3-303" id="h9-3-303" class="d">-                }
</a><a href="#h9-3-304" id="h9-3-304" class="d">-            )
</a><a href="#h9-3-305" id="h9-3-305" class="d">-        }
</a><a href="#h9-3-306" id="h9-3-306" class="i">+        assert_messages(
</a><a href="#h9-3-307" id="h9-3-307" class="i">+            &amp;mut node_rx,
</a><a href="#h9-3-308" id="h9-3-308" class="i">+            vec![Message {
</a><a href="#h9-3-309" id="h9-3-309" class="i">+                from: Address::Local,
</a><a href="#h9-3-310" id="h9-3-310" class="i">+                to: Address::Peers,
</a><a href="#h9-3-311" id="h9-3-311" class="i">+                term: 4,
</a><a href="#h9-3-312" id="h9-3-312" class="i">+                event: Event::SolicitVote { last_index: 3, last_term: 2 },
</a><a href="#h9-3-313" id="h9-3-313" class="i">+            }],
</a><a href="#h9-3-314" id="h9-3-314" class="i">+        );
</a><a href="#h9-3-315" id="h9-3-315" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 }
<b>diff --git a/<a id="h10" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -1,101 +1,109 @@
</a><a href="#h10-0-0" id="h10-0-0" class="d">-use super::super::{Event, Message, State};
</a><a href="#h10-0-1" id="h10-0-1" class="i">+use super::super::{Address, Event, Instruction, Message, Response};
</a> use super::{Candidate, Node, RoleNode, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
 use crate::kv::storage::Storage;
 use crate::Error;
 
<a href="#h10-0-6" id="h10-0-6" class="d">-use log::{debug, info};
</a><a href="#h10-0-7" id="h10-0-7" class="i">+use log::{debug, info, warn};
</a> use rand::Rng as _;
<a href="#h10-0-9" id="h10-0-9" class="d">-use std::collections::HashMap;
</a> 
 // A follower replicates state from a leader.
 #[derive(Debug)]
 pub struct Follower {
     /// The leader, or None if just initialized.
<a href="#h10-0-15" id="h10-0-15" class="d">-    pub leader: Option&lt;String&gt;,
</a><a href="#h10-0-16" id="h10-0-16" class="i">+    leader: Option&lt;String&gt;,
</a>     /// The number of ticks since the last message from the leader.
     leader_seen_ticks: u64,
     /// The timeout before triggering an election.
     leader_seen_timeout: u64,
     /// The node we voted for in the current term, if any.
     voted_for: Option&lt;String&gt;,
<a href="#h10-0-23" id="h10-0-23" class="d">-    /// Keeps track of any proxied calls to the leader (call ID to message sender).
</a><a href="#h10-0-24" id="h10-0-24" class="d">-    proxy_calls: HashMap&lt;Vec&lt;u8&gt;, Option&lt;String&gt;&gt;,
</a> }
 
 impl Follower {
     /// Creates a new follower role.
     pub fn new(leader: Option&lt;&amp;str&gt;, voted_for: Option&lt;&amp;str&gt;) -&gt; Self {
         Self {
<a href="#h10-0-31" id="h10-0-31" class="d">-            leader: leader.map(str::to_owned),
</a><a href="#h10-0-32" id="h10-0-32" class="d">-            voted_for: voted_for.map(str::to_owned),
</a><a href="#h10-0-33" id="h10-0-33" class="i">+            leader: leader.map(String::from),
</a><a href="#h10-0-34" id="h10-0-34" class="i">+            voted_for: voted_for.map(String::from),
</a>             leader_seen_ticks: 0,
             leader_seen_timeout: rand::thread_rng()
                 .gen_range(ELECTION_TIMEOUT_MIN, ELECTION_TIMEOUT_MAX),
<a href="#h10-0-38" id="h10-0-38" class="d">-            proxy_calls: HashMap::new(),
</a>         }
     }
 }
 
<a href="#h10-0-43" id="h10-0-43" class="d">-impl&lt;L: Storage, S: State&gt; RoleNode&lt;Follower, L, S&gt; {
</a><a href="#h10-0-44" id="h10-0-44" class="i">+impl&lt;L: Storage&gt; RoleNode&lt;Follower, L&gt; {
</a>     /// Transforms the node into a candidate.
<a href="#h10-0-46" id="h10-0-46" class="d">-    fn become_candidate(self) -&gt; Result&lt;RoleNode&lt;Candidate, L, S&gt;, Error&gt; {
</a><a href="#h10-0-47" id="h10-0-47" class="i">+    fn become_candidate(self) -&gt; Result&lt;RoleNode&lt;Candidate, L&gt;, Error&gt; {
</a>         info!(&quot;Starting election for term {}&quot;, self.term + 1);
         let mut node = self.become_role(Candidate::new())?;
         node.save_term(node.term + 1, None)?;
         let (last_index, last_term) = node.log.get_last();
<a href="#h10-0-52" id="h10-0-52" class="d">-        node.broadcast(Event::SolicitVote { last_index, last_term })?;
</a><a href="#h10-0-53" id="h10-0-53" class="i">+        node.send(Address::Peers, Event::SolicitVote { last_index, last_term })?;
</a>         Ok(node)
     }
 
<a href="#h10-0-57" id="h10-0-57" class="d">-    /// Checks if the message sender is the current leader
</a><a href="#h10-0-58" id="h10-0-58" class="d">-    fn is_leader(&amp;self, from: Option&lt;&amp;str&gt;) -&gt; bool {
</a><a href="#h10-0-59" id="h10-0-59" class="d">-        if let Some(leader) = self.role.leader.as_deref() {
</a><a href="#h10-0-60" id="h10-0-60" class="d">-            if let Some(claimant) = from {
</a><a href="#h10-0-61" id="h10-0-61" class="d">-                return claimant == leader;
</a><a href="#h10-0-62" id="h10-0-62" class="d">-            }
</a><a href="#h10-0-63" id="h10-0-63" class="i">+    /// Transforms the node into a follower for a new leader.
</a><a href="#h10-0-64" id="h10-0-64" class="i">+    fn become_follower(mut self, leader: &amp;str, term: u64) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;, Error&gt; {
</a><a href="#h10-0-65" id="h10-0-65" class="i">+        let mut voted_for = None;
</a><a href="#h10-0-66" id="h10-0-66" class="i">+        if term &gt; self.term {
</a><a href="#h10-0-67" id="h10-0-67" class="i">+            info!(&quot;Discovered new term {}, following leader {}&quot;, term, leader);
</a><a href="#h10-0-68" id="h10-0-68" class="i">+            self.save_term(term, None)?;
</a><a href="#h10-0-69" id="h10-0-69" class="i">+        } else {
</a><a href="#h10-0-70" id="h10-0-70" class="i">+            info!(&quot;Discovered leader {}, following&quot;, leader);
</a><a href="#h10-0-71" id="h10-0-71" class="i">+            voted_for = self.role.voted_for;
</a>         };
<a href="#h10-0-73" id="h10-0-73" class="d">-        false
</a><a href="#h10-0-74" id="h10-0-74" class="i">+        self.role = Follower::new(Some(leader), voted_for.as_deref());
</a><a href="#h10-0-75" id="h10-0-75" class="i">+        self.abort_proxied()?;
</a><a href="#h10-0-76" id="h10-0-76" class="i">+        self.forward_queued(Address::Peer(leader.to_string()))?;
</a><a href="#h10-0-77" id="h10-0-77" class="i">+        Ok(self)
</a><a href="#h10-0-78" id="h10-0-78" class="i">+    }
</a><a href="#h10-0-79" id="h10-0-79" class="i">+
</a><a href="#h10-0-80" id="h10-0-80" class="i">+    /// Checks if an address is the current leader
</a><a href="#h10-0-81" id="h10-0-81" class="i">+    fn is_leader(&amp;self, from: &amp;Address) -&gt; bool {
</a><a href="#h10-0-82" id="h10-0-82" class="i">+        match (&amp;self.role.leader, from) {
</a><a href="#h10-0-83" id="h10-0-83" class="i">+            (Some(leader), Address::Peer(from)) if leader == from =&gt; true,
</a><a href="#h10-0-84" id="h10-0-84" class="i">+            _ =&gt; false,
</a><a href="#h10-0-85" id="h10-0-85" class="i">+        }
</a>     }
 
     /// Processes a message.
<a href="#h10-0-89" id="h10-0-89" class="d">-    pub fn step(mut self, mut msg: Message) -&gt; Result&lt;Node&lt;L, S&gt;, Error&gt; {
</a><a href="#h10-0-90" id="h10-0-90" class="d">-        if !self.normalize_message(&amp;mut msg) {
</a><a href="#h10-0-91" id="h10-0-91" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h10-0-92" id="h10-0-92" class="i">+        if let Err(err) = self.validate(&amp;msg) {
</a><a href="#h10-0-93" id="h10-0-93" class="i">+            warn!(&quot;Ignoring invalid message: {}&quot;, err);
</a>             return Ok(self.into());
         }
<a href="#h10-0-96" id="h10-0-96" class="d">-        if let Some(from) = &amp;msg.from {
</a><a href="#h10-0-97" id="h10-0-97" class="d">-            if msg.term &gt; self.term {
</a><a href="#h10-0-98" id="h10-0-98" class="d">-                info!(&quot;Discovered new term {}, following leader {}&quot;, msg.term, from);
</a><a href="#h10-0-99" id="h10-0-99" class="d">-                self.save_term(msg.term, None)?;
</a><a href="#h10-0-100" id="h10-0-100" class="d">-                self.role = Follower::new(Some(from), None);
</a><a href="#h10-0-101" id="h10-0-101" class="d">-            }
</a><a href="#h10-0-102" id="h10-0-102" class="d">-            if self.role.leader.is_none() {
</a><a href="#h10-0-103" id="h10-0-103" class="d">-                info!(&quot;Discovered leader {} in current term {}, following&quot;, from, self.term);
</a><a href="#h10-0-104" id="h10-0-104" class="d">-                self.role = Follower::new(Some(from), self.role.voted_for.as_deref());
</a><a href="#h10-0-105" id="h10-0-105" class="i">+        if let Address::Peer(from) = &amp;msg.from {
</a><a href="#h10-0-106" id="h10-0-106" class="i">+            if msg.term &gt; self.term || self.role.leader.is_none() {
</a><a href="#h10-0-107" id="h10-0-107" class="i">+                return self.become_follower(from, msg.term)?.step(msg);
</a>             }
         }
<a href="#h10-0-110" id="h10-0-110" class="d">-        if self.is_leader(msg.from.as_deref()) {
</a><a href="#h10-0-111" id="h10-0-111" class="i">+        if self.is_leader(&amp;msg.from) {
</a>             self.role.leader_seen_ticks = 0
         }
 
         match msg.event {
             Event::Heartbeat { commit_index, commit_term } =&gt; {
<a href="#h10-0-117" id="h10-0-117" class="d">-                if self.is_leader(msg.from.as_deref()) {
</a><a href="#h10-0-118" id="h10-0-118" class="i">+                if self.is_leader(&amp;msg.from) {
</a><a href="#h10-0-119" id="h10-0-119" class="i">+                    let (prev_commit_index, _) = self.log.get_committed();
</a>                     let has_committed = self.log.has(commit_index, commit_term)?;
                     if has_committed {
                         self.log.commit(commit_index)?;
<a href="#h10-0-123" id="h10-0-123" class="i">+                        // FIXME This should use a range scan
</a><a href="#h10-0-124" id="h10-0-124" class="i">+                        for index in (prev_commit_index + 1)..=commit_index {
</a><a href="#h10-0-125" id="h10-0-125" class="i">+                            if let Some(entry) = self.log.get(index)? {
</a><a href="#h10-0-126" id="h10-0-126" class="i">+                                self.state_tx.send(Instruction::Apply { entry })?
</a><a href="#h10-0-127" id="h10-0-127" class="i">+                            }
</a><a href="#h10-0-128" id="h10-0-128" class="i">+                        }
</a>                     }
<a href="#h10-0-130" id="h10-0-130" class="d">-                    self.send(
</a><a href="#h10-0-131" id="h10-0-131" class="d">-                        msg.from.as_deref(),
</a><a href="#h10-0-132" id="h10-0-132" class="d">-                        Event::ConfirmLeader { commit_index, has_committed },
</a><a href="#h10-0-133" id="h10-0-133" class="d">-                    )?;
</a><a href="#h10-0-134" id="h10-0-134" class="i">+                    self.send(msg.from, Event::ConfirmLeader { commit_index, has_committed })?;
</a>                 }
             }
<a href="#h10-0-137" id="h10-0-137" class="i">+
</a>             Event::SolicitVote { last_index, last_term } =&gt; {
                 if let Some(voted_for) = &amp;self.role.voted_for {
<a href="#h10-0-140" id="h10-0-140" class="d">-                    if let Some(from) = &amp;msg.from {
</a><a href="#h10-0-141" id="h10-0-141" class="d">-                        if voted_for != from {
</a><a href="#h10-0-142" id="h10-0-142" class="d">-                            return Ok(self.into());
</a><a href="#h10-0-143" id="h10-0-143" class="d">-                        }
</a><a href="#h10-0-144" id="h10-0-144" class="i">+                    if msg.from != Address::Peer(voted_for.clone()) {
</a><a href="#h10-0-145" id="h10-0-145" class="i">+                        return Ok(self.into());
</a>                     }
                 }
                 let (local_last_index, local_last_term) = self.log.get_last();
<a href="#h10-1" id="h10-1" class="h">@@ -105,44 +113,56 @@ impl&lt;L: Storage, S: State&gt; RoleNode&lt;Follower, L, S&gt; {
</a>                 if last_term == local_last_term &amp;&amp; last_index &lt; local_last_index {
                     return Ok(self.into());
                 }
<a href="#h10-1-3" id="h10-1-3" class="d">-                if let Some(from) = msg.from {
</a><a href="#h10-1-4" id="h10-1-4" class="d">-                    info!(&quot;Voting for {} in term {} election&quot;, &amp;from, self.term);
</a><a href="#h10-1-5" id="h10-1-5" class="d">-                    self.send(Some(&amp;from), Event::GrantVote)?;
</a><a href="#h10-1-6" id="h10-1-6" class="i">+                if let Address::Peer(from) = msg.from {
</a><a href="#h10-1-7" id="h10-1-7" class="i">+                    info!(&quot;Voting for {} in term {} election&quot;, from, self.term);
</a><a href="#h10-1-8" id="h10-1-8" class="i">+                    self.send(Address::Peer(from.clone()), Event::GrantVote)?;
</a>                     self.save_term(self.term, Some(&amp;from))?;
                     self.role.voted_for = Some(from);
                 }
             }
<a href="#h10-1-13" id="h10-1-13" class="i">+
</a>             Event::ReplicateEntries { base_index, base_term, entries } =&gt; {
<a href="#h10-1-15" id="h10-1-15" class="d">-                if self.is_leader(msg.from.as_deref()) {
</a><a href="#h10-1-16" id="h10-1-16" class="i">+                if self.is_leader(&amp;msg.from) {
</a>                     if base_index &gt; 0 &amp;&amp; !self.log.has(base_index, base_term)? {
                         debug!(&quot;Rejecting log entries at base {}&quot;, base_index);
<a href="#h10-1-19" id="h10-1-19" class="d">-                        self.send(msg.from.as_deref(), Event::RejectEntries)?
</a><a href="#h10-1-20" id="h10-1-20" class="i">+                        self.send(msg.from, Event::RejectEntries)?
</a>                     } else {
<a href="#h10-1-22" id="h10-1-22" class="d">-                        let last_index = self.log.splice(base_index, entries)?;
</a><a href="#h10-1-23" id="h10-1-23" class="d">-                        self.send(msg.from.as_deref(), Event::AcceptEntries { last_index })?
</a><a href="#h10-1-24" id="h10-1-24" class="i">+                        let last_index = self.log.splice(entries)?;
</a><a href="#h10-1-25" id="h10-1-25" class="i">+                        self.send(msg.from, Event::AcceptEntries { last_index })?
</a>                     }
                 }
             }
<a href="#h10-1-29" id="h10-1-29" class="d">-            Event::QueryState { ref call_id, .. } | Event::MutateState { ref call_id, .. } =&gt; {
</a><a href="#h10-1-30" id="h10-1-30" class="d">-                self.role.proxy_calls.insert(call_id.clone(), msg.from);
</a><a href="#h10-1-31" id="h10-1-31" class="d">-                self.send(self.role.leader.as_deref(), msg.event)?;
</a><a href="#h10-1-32" id="h10-1-32" class="i">+
</a><a href="#h10-1-33" id="h10-1-33" class="i">+            Event::ClientRequest { ref id, .. } =&gt; {
</a><a href="#h10-1-34" id="h10-1-34" class="i">+                if let Some(leader) = self.role.leader.as_deref() {
</a><a href="#h10-1-35" id="h10-1-35" class="i">+                    self.proxied_reqs.insert(id.clone(), msg.from);
</a><a href="#h10-1-36" id="h10-1-36" class="i">+                    self.send(Address::Peer(leader.to_string()), msg.event)?
</a><a href="#h10-1-37" id="h10-1-37" class="i">+                } else {
</a><a href="#h10-1-38" id="h10-1-38" class="i">+                    self.queued_reqs.push((msg.from, msg.event));
</a><a href="#h10-1-39" id="h10-1-39" class="i">+                }
</a>             }
<a href="#h10-1-41" id="h10-1-41" class="d">-            Event::RespondState { ref call_id, .. } | Event::RespondError { ref call_id, .. } =&gt; {
</a><a href="#h10-1-42" id="h10-1-42" class="d">-                if let Some(to) = self.role.proxy_calls.remove(call_id) {
</a><a href="#h10-1-43" id="h10-1-43" class="d">-                    self.send(to.as_deref(), msg.event)?
</a><a href="#h10-1-44" id="h10-1-44" class="i">+
</a><a href="#h10-1-45" id="h10-1-45" class="i">+            Event::ClientResponse { id, mut response } =&gt; {
</a><a href="#h10-1-46" id="h10-1-46" class="i">+                if let Ok(Response::Status(ref mut status)) = response {
</a><a href="#h10-1-47" id="h10-1-47" class="i">+                    status.id = self.id.clone();
</a><a href="#h10-1-48" id="h10-1-48" class="i">+                    status.role = &quot;follower&quot;.into();
</a>                 }
<a href="#h10-1-50" id="h10-1-50" class="i">+                self.proxied_reqs.remove(&amp;id);
</a><a href="#h10-1-51" id="h10-1-51" class="i">+                self.send(Address::Client, Event::ClientResponse { id, response })?;
</a>             }
<a href="#h10-1-53" id="h10-1-53" class="d">-            Event::ConfirmLeader { .. } =&gt; {}
</a><a href="#h10-1-54" id="h10-1-54" class="i">+
</a><a href="#h10-1-55" id="h10-1-55" class="i">+            // Ignore votes which are usually strays from the previous election that we lost.
</a>             Event::GrantVote =&gt; {}
<a href="#h10-1-57" id="h10-1-57" class="d">-            Event::AcceptEntries { .. } =&gt; {}
</a><a href="#h10-1-58" id="h10-1-58" class="d">-            Event::RejectEntries { .. } =&gt; {}
</a><a href="#h10-1-59" id="h10-1-59" class="i">+
</a><a href="#h10-1-60" id="h10-1-60" class="i">+            Event::ConfirmLeader { .. }
</a><a href="#h10-1-61" id="h10-1-61" class="i">+            | Event::AcceptEntries { .. }
</a><a href="#h10-1-62" id="h10-1-62" class="i">+            | Event::RejectEntries { .. } =&gt; warn!(&quot;Received unexpected message {:?}&quot;, msg),
</a>         };
         Ok(self.into())
     }
 
     /// Processes a logical clock tick.
<a href="#h10-1-68" id="h10-1-68" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L, S&gt;, Error&gt; {
</a><a href="#h10-1-69" id="h10-1-69" class="d">-        while let Some(_) = self.log.apply(&amp;mut self.state)? {}
</a><a href="#h10-1-70" id="h10-1-70" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a>         self.role.leader_seen_ticks += 1;
         if self.role.leader_seen_ticks &gt;= self.role.leader_seen_timeout {
             Ok(self.become_candidate()?.into())
<a href="#h10-2" id="h10-2" class="h">@@ -154,674 +174,802 @@ impl&lt;L: Storage, S: State&gt; RoleNode&lt;Follower, L, S&gt; {
</a> 
 #[cfg(test)]
 pub mod tests {
<a href="#h10-2-3" id="h10-2-3" class="d">-    use super::super::super::{Entry, Log};
</a><a href="#h10-2-4" id="h10-2-4" class="d">-    use super::super::tests::{assert_messages, assert_node, TestState};
</a><a href="#h10-2-5" id="h10-2-5" class="i">+    use super::super::super::{Entry, Log, Request};
</a><a href="#h10-2-6" id="h10-2-6" class="i">+    use super::super::tests::{assert_messages, assert_node};
</a>     use super::*;
     use crate::kv;
<a href="#h10-2-9" id="h10-2-9" class="d">-    use tokio::stream::StreamExt as _;
</a><a href="#h10-2-10" id="h10-2-10" class="d">-    use tokio::sync::mpsc::UnboundedReceiver;
</a><a href="#h10-2-11" id="h10-2-11" class="i">+    use std::collections::HashMap;
</a><a href="#h10-2-12" id="h10-2-12" class="i">+    use tokio::sync::mpsc;
</a> 
<a href="#h10-2-14" id="h10-2-14" class="d">-    pub fn follower_leader&lt;L: Storage, S: State&gt;(
</a><a href="#h10-2-15" id="h10-2-15" class="d">-        node: &amp;RoleNode&lt;Follower, L, S&gt;,
</a><a href="#h10-2-16" id="h10-2-16" class="d">-    ) -&gt; Option&lt;String&gt; {
</a><a href="#h10-2-17" id="h10-2-17" class="i">+    pub fn follower_leader&lt;L: Storage&gt;(node: &amp;RoleNode&lt;Follower, L&gt;) -&gt; Option&lt;String&gt; {
</a>         node.role.leader.clone()
     }
 
<a href="#h10-2-21" id="h10-2-21" class="d">-    pub fn follower_voted_for&lt;L: Storage, S: State&gt;(
</a><a href="#h10-2-22" id="h10-2-22" class="d">-        node: &amp;RoleNode&lt;Follower, L, S&gt;,
</a><a href="#h10-2-23" id="h10-2-23" class="d">-    ) -&gt; Option&lt;String&gt; {
</a><a href="#h10-2-24" id="h10-2-24" class="i">+    pub fn follower_voted_for&lt;L: Storage&gt;(node: &amp;RoleNode&lt;Follower, L&gt;) -&gt; Option&lt;String&gt; {
</a>         node.role.voted_for.clone()
     }
 
     #[allow(clippy::type_complexity)]
<a href="#h10-2-29" id="h10-2-29" class="d">-    fn setup(
</a><a href="#h10-2-30" id="h10-2-30" class="d">-    ) -&gt; Result&lt;(RoleNode&lt;Follower, kv::storage::Test, TestState&gt;, UnboundedReceiver&lt;Message&gt;), Error&gt;
</a><a href="#h10-2-31" id="h10-2-31" class="d">-    {
</a><a href="#h10-2-32" id="h10-2-32" class="d">-        let (sender, receiver) = tokio::sync::mpsc::unbounded_channel();
</a><a href="#h10-2-33" id="h10-2-33" class="d">-        let mut state = TestState::new();
</a><a href="#h10-2-34" id="h10-2-34" class="i">+    fn setup() -&gt; Result&lt;
</a><a href="#h10-2-35" id="h10-2-35" class="i">+        (
</a><a href="#h10-2-36" id="h10-2-36" class="i">+            RoleNode&lt;Follower, kv::storage::Test&gt;,
</a><a href="#h10-2-37" id="h10-2-37" class="i">+            mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h10-2-38" id="h10-2-38" class="i">+            mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h10-2-39" id="h10-2-39" class="i">+        ),
</a><a href="#h10-2-40" id="h10-2-40" class="i">+        Error,
</a><a href="#h10-2-41" id="h10-2-41" class="i">+    &gt; {
</a><a href="#h10-2-42" id="h10-2-42" class="i">+        let (node_tx, node_rx) = mpsc::unbounded_channel();
</a><a href="#h10-2-43" id="h10-2-43" class="i">+        let (state_tx, state_rx) = mpsc::unbounded_channel();
</a>         let mut log = Log::new(kv::Simple::new(kv::storage::Test::new()))?;
<a href="#h10-2-45" id="h10-2-45" class="d">-        log.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h10-2-46" id="h10-2-46" class="d">-        log.append(Entry { term: 1, command: Some(vec![0x02]) })?;
</a><a href="#h10-2-47" id="h10-2-47" class="d">-        log.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h10-2-48" id="h10-2-48" class="i">+        log.append(1, Some(vec![0x01]))?;
</a><a href="#h10-2-49" id="h10-2-49" class="i">+        log.append(1, Some(vec![0x02]))?;
</a><a href="#h10-2-50" id="h10-2-50" class="i">+        log.append(2, Some(vec![0x03]))?;
</a>         log.commit(2)?;
<a href="#h10-2-52" id="h10-2-52" class="d">-        log.apply(&amp;mut state)?;
</a> 
         let mut node = RoleNode {
             id: &quot;a&quot;.into(),
             peers: vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()],
             term: 3,
             log,
<a href="#h10-2-59" id="h10-2-59" class="d">-            state,
</a><a href="#h10-2-60" id="h10-2-60" class="d">-            sender,
</a><a href="#h10-2-61" id="h10-2-61" class="i">+            node_tx,
</a><a href="#h10-2-62" id="h10-2-62" class="i">+            state_tx,
</a><a href="#h10-2-63" id="h10-2-63" class="i">+            proxied_reqs: HashMap::new(),
</a><a href="#h10-2-64" id="h10-2-64" class="i">+            queued_reqs: Vec::new(),
</a>             role: Follower::new(Some(&quot;b&quot;), None),
         };
         node.save_term(3, None)?;
<a href="#h10-2-68" id="h10-2-68" class="d">-        Ok((node, receiver))
</a><a href="#h10-2-69" id="h10-2-69" class="i">+        Ok((node, node_rx, state_rx))
</a>     }
 
     #[test]
<a href="#h10-2-73" id="h10-2-73" class="d">-    // Heartbeat from current leader
</a><a href="#h10-2-74" id="h10-2-74" class="i">+    // Heartbeat from current leader should commit and apply
</a>     fn step_heartbeat() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-76" id="h10-2-76" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-77" id="h10-2-77" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-79" id="h10-2-79" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-80" id="h10-2-80" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-81" id="h10-2-81" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-82" id="h10-2-82" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h10-2-86" id="h10-2-86" class="d">-        assert_node(&amp;node)
</a><a href="#h10-2-87" id="h10-2-87" class="d">-            .is_follower()
</a><a href="#h10-2-88" id="h10-2-88" class="d">-            .term(3)
</a><a href="#h10-2-89" id="h10-2-89" class="d">-            .leader(Some(&quot;b&quot;))
</a><a href="#h10-2-90" id="h10-2-90" class="d">-            .voted_for(None)
</a><a href="#h10-2-91" id="h10-2-91" class="d">-            .committed(3)
</a><a href="#h10-2-92" id="h10-2-92" class="d">-            .applied(1);
</a><a href="#h10-2-93" id="h10-2-93" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(3);
</a>         assert_messages(
<a href="#h10-2-95" id="h10-2-95" class="d">-            &amp;mut rx,
</a><a href="#h10-2-96" id="h10-2-96" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-98" id="h10-2-98" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-99" id="h10-2-99" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-100" id="h10-2-100" class="i">+                from: Address::Local,
</a><a href="#h10-2-101" id="h10-2-101" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::ConfirmLeader { commit_index: 3, has_committed: true },
             }],
         );
<a href="#h10-2-106" id="h10-2-106" class="i">+        assert_messages(
</a><a href="#h10-2-107" id="h10-2-107" class="i">+            &amp;mut state_rx,
</a><a href="#h10-2-108" id="h10-2-108" class="i">+            vec![Instruction::Apply {
</a><a href="#h10-2-109" id="h10-2-109" class="i">+                entry: Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-110" id="h10-2-110" class="i">+            }],
</a><a href="#h10-2-111" id="h10-2-111" class="i">+        );
</a>         Ok(())
     }
 
     #[test]
     // Heartbeat from current leader with conflicting commit_term
     fn step_heartbeat_conflict_commit_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-118" id="h10-2-118" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-119" id="h10-2-119" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-121" id="h10-2-121" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-122" id="h10-2-122" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-123" id="h10-2-123" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-124" id="h10-2-124" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 3, commit_term: 3 },
         })?;
<a href="#h10-2-128" id="h10-2-128" class="d">-        assert_node(&amp;node)
</a><a href="#h10-2-129" id="h10-2-129" class="d">-            .is_follower()
</a><a href="#h10-2-130" id="h10-2-130" class="d">-            .term(3)
</a><a href="#h10-2-131" id="h10-2-131" class="d">-            .leader(Some(&quot;b&quot;))
</a><a href="#h10-2-132" id="h10-2-132" class="d">-            .voted_for(None)
</a><a href="#h10-2-133" id="h10-2-133" class="d">-            .committed(2)
</a><a href="#h10-2-134" id="h10-2-134" class="d">-            .applied(1);
</a><a href="#h10-2-135" id="h10-2-135" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a>         assert_messages(
<a href="#h10-2-137" id="h10-2-137" class="d">-            &amp;mut rx,
</a><a href="#h10-2-138" id="h10-2-138" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-140" id="h10-2-140" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-141" id="h10-2-141" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-142" id="h10-2-142" class="i">+                from: Address::Local,
</a><a href="#h10-2-143" id="h10-2-143" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::ConfirmLeader { commit_index: 3, has_committed: false },
             }],
         );
<a href="#h10-2-148" id="h10-2-148" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // Heartbeat from current leader with a missing commit_index
     fn step_heartbeat_missing_commit_entry() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-155" id="h10-2-155" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-156" id="h10-2-156" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-158" id="h10-2-158" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-159" id="h10-2-159" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-160" id="h10-2-160" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-161" id="h10-2-161" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
         })?;
<a href="#h10-2-165" id="h10-2-165" class="d">-        assert_node(&amp;node)
</a><a href="#h10-2-166" id="h10-2-166" class="d">-            .is_follower()
</a><a href="#h10-2-167" id="h10-2-167" class="d">-            .term(3)
</a><a href="#h10-2-168" id="h10-2-168" class="d">-            .leader(Some(&quot;b&quot;))
</a><a href="#h10-2-169" id="h10-2-169" class="d">-            .voted_for(None)
</a><a href="#h10-2-170" id="h10-2-170" class="d">-            .committed(2)
</a><a href="#h10-2-171" id="h10-2-171" class="d">-            .applied(1);
</a><a href="#h10-2-172" id="h10-2-172" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a>         assert_messages(
<a href="#h10-2-174" id="h10-2-174" class="d">-            &amp;mut rx,
</a><a href="#h10-2-175" id="h10-2-175" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-177" id="h10-2-177" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-178" id="h10-2-178" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-179" id="h10-2-179" class="i">+                from: Address::Local,
</a><a href="#h10-2-180" id="h10-2-180" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::ConfirmLeader { commit_index: 5, has_committed: false },
             }],
         );
<a href="#h10-2-185" id="h10-2-185" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // Heartbeat from fake leader
     fn step_heartbeat_fake_leader() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-192" id="h10-2-192" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-193" id="h10-2-193" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-195" id="h10-2-195" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-196" id="h10-2-196" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-197" id="h10-2-197" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-198" id="h10-2-198" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
         })?;
<a href="#h10-2-202" id="h10-2-202" class="d">-        assert_node(&amp;node)
</a><a href="#h10-2-203" id="h10-2-203" class="d">-            .is_follower()
</a><a href="#h10-2-204" id="h10-2-204" class="d">-            .term(3)
</a><a href="#h10-2-205" id="h10-2-205" class="d">-            .leader(Some(&quot;b&quot;))
</a><a href="#h10-2-206" id="h10-2-206" class="d">-            .voted_for(None)
</a><a href="#h10-2-207" id="h10-2-207" class="d">-            .committed(2)
</a><a href="#h10-2-208" id="h10-2-208" class="d">-            .applied(1);
</a><a href="#h10-2-209" id="h10-2-209" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h10-2-210" id="h10-2-210" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a><a href="#h10-2-211" id="h10-2-211" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h10-2-212" id="h10-2-212" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
<a href="#h10-2-217" id="h10-2-217" class="d">-    // Heartbeat when no current leader
</a><a href="#h10-2-218" id="h10-2-218" class="i">+    // Heartbeat when no current leader makes us follow the leader
</a>     fn step_heartbeat_no_leader() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-220" id="h10-2-220" class="d">-        let (mut follower, mut rx) = setup()?;
</a><a href="#h10-2-221" id="h10-2-221" class="i">+        let (mut follower, mut node_rx, mut state_rx) = setup()?;
</a>         follower.role = Follower::new(None, None);
         let node = follower.step(Message {
<a href="#h10-2-224" id="h10-2-224" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-225" id="h10-2-225" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-226" id="h10-2-226" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-227" id="h10-2-227" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h10-2-231" id="h10-2-231" class="d">-        assert_node(&amp;node)
</a><a href="#h10-2-232" id="h10-2-232" class="d">-            .is_follower()
</a><a href="#h10-2-233" id="h10-2-233" class="d">-            .term(3)
</a><a href="#h10-2-234" id="h10-2-234" class="d">-            .leader(Some(&quot;c&quot;))
</a><a href="#h10-2-235" id="h10-2-235" class="d">-            .voted_for(None)
</a><a href="#h10-2-236" id="h10-2-236" class="d">-            .committed(3)
</a><a href="#h10-2-237" id="h10-2-237" class="d">-            .applied(1);
</a><a href="#h10-2-238" id="h10-2-238" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;c&quot;)).voted_for(None).committed(3);
</a>         assert_messages(
<a href="#h10-2-240" id="h10-2-240" class="d">-            &amp;mut rx,
</a><a href="#h10-2-241" id="h10-2-241" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-243" id="h10-2-243" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-244" id="h10-2-244" class="d">-                to: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-245" id="h10-2-245" class="i">+                from: Address::Local,
</a><a href="#h10-2-246" id="h10-2-246" class="i">+                to: Address::Peer(&quot;c&quot;.into()),
</a>                 term: 3,
                 event: Event::ConfirmLeader { commit_index: 3, has_committed: true },
             }],
         );
<a href="#h10-2-251" id="h10-2-251" class="i">+        assert_messages(
</a><a href="#h10-2-252" id="h10-2-252" class="i">+            &amp;mut state_rx,
</a><a href="#h10-2-253" id="h10-2-253" class="i">+            vec![Instruction::Apply {
</a><a href="#h10-2-254" id="h10-2-254" class="i">+                entry: Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-255" id="h10-2-255" class="i">+            }],
</a><a href="#h10-2-256" id="h10-2-256" class="i">+        );
</a>         Ok(())
     }
 
     #[test]
     // Heartbeat from current leader with old commit_index
     fn step_heartbeat_old_commit_index() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-263" id="h10-2-263" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-264" id="h10-2-264" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-266" id="h10-2-266" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-267" id="h10-2-267" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-268" id="h10-2-268" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-269" id="h10-2-269" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
         })?;
<a href="#h10-2-273" id="h10-2-273" class="d">-        assert_node(&amp;node)
</a><a href="#h10-2-274" id="h10-2-274" class="d">-            .is_follower()
</a><a href="#h10-2-275" id="h10-2-275" class="d">-            .term(3)
</a><a href="#h10-2-276" id="h10-2-276" class="d">-            .leader(Some(&quot;b&quot;))
</a><a href="#h10-2-277" id="h10-2-277" class="d">-            .voted_for(None)
</a><a href="#h10-2-278" id="h10-2-278" class="d">-            .committed(2)
</a><a href="#h10-2-279" id="h10-2-279" class="d">-            .applied(1);
</a><a href="#h10-2-280" id="h10-2-280" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a>         assert_messages(
<a href="#h10-2-282" id="h10-2-282" class="d">-            &amp;mut rx,
</a><a href="#h10-2-283" id="h10-2-283" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-285" id="h10-2-285" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-286" id="h10-2-286" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-287" id="h10-2-287" class="i">+                from: Address::Local,
</a><a href="#h10-2-288" id="h10-2-288" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::ConfirmLeader { commit_index: 1, has_committed: true },
             }],
         );
<a href="#h10-2-293" id="h10-2-293" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // Heartbeat for future term with other leader changes leader
     fn step_heartbeat_future_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-300" id="h10-2-300" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-301" id="h10-2-301" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-303" id="h10-2-303" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-304" id="h10-2-304" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-305" id="h10-2-305" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-306" id="h10-2-306" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 4,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
         assert_node(&amp;node).is_follower().term(4).leader(Some(&quot;c&quot;)).voted_for(None);
         assert_messages(
<a href="#h10-2-312" id="h10-2-312" class="d">-            &amp;mut rx,
</a><a href="#h10-2-313" id="h10-2-313" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-315" id="h10-2-315" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-316" id="h10-2-316" class="d">-                to: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-317" id="h10-2-317" class="i">+                from: Address::Local,
</a><a href="#h10-2-318" id="h10-2-318" class="i">+                to: Address::Peer(&quot;c&quot;.into()),
</a>                 term: 4,
                 event: Event::ConfirmLeader { commit_index: 3, has_committed: true },
             }],
         );
<a href="#h10-2-323" id="h10-2-323" class="i">+        assert_messages(
</a><a href="#h10-2-324" id="h10-2-324" class="i">+            &amp;mut state_rx,
</a><a href="#h10-2-325" id="h10-2-325" class="i">+            vec![Instruction::Apply {
</a><a href="#h10-2-326" id="h10-2-326" class="i">+                entry: Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-327" id="h10-2-327" class="i">+            }],
</a><a href="#h10-2-328" id="h10-2-328" class="i">+        );
</a>         Ok(())
     }
 
     #[test]
     // Heartbeat from past term
     fn step_heartbeat_past_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-335" id="h10-2-335" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-336" id="h10-2-336" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-338" id="h10-2-338" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-339" id="h10-2-339" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-340" id="h10-2-340" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-341" id="h10-2-341" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 2,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h10-2-345" id="h10-2-345" class="d">-        assert_node(&amp;node)
</a><a href="#h10-2-346" id="h10-2-346" class="d">-            .is_follower()
</a><a href="#h10-2-347" id="h10-2-347" class="d">-            .term(3)
</a><a href="#h10-2-348" id="h10-2-348" class="d">-            .leader(Some(&quot;b&quot;))
</a><a href="#h10-2-349" id="h10-2-349" class="d">-            .voted_for(None)
</a><a href="#h10-2-350" id="h10-2-350" class="d">-            .committed(2)
</a><a href="#h10-2-351" id="h10-2-351" class="d">-            .applied(1);
</a><a href="#h10-2-352" id="h10-2-352" class="d">-        std::mem::drop(node);
</a><a href="#h10-2-353" id="h10-2-353" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h10-2-354" id="h10-2-354" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None).committed(2);
</a><a href="#h10-2-355" id="h10-2-355" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h10-2-356" id="h10-2-356" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // SolicitVote is granted for the first solicitor, otherwise ignored.
     fn step_solicitvote() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-363" id="h10-2-363" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-364" id="h10-2-364" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a> 
         // The first vote request in this term yields a vote response.
         let mut node = follower.step(Message {
<a href="#h10-2-368" id="h10-2-368" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-369" id="h10-2-369" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-370" id="h10-2-370" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-371" id="h10-2-371" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::SolicitVote { last_index: 3, last_term: 2 },
         })?;
         assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
         assert_messages(
<a href="#h10-2-377" id="h10-2-377" class="d">-            &amp;mut rx,
</a><a href="#h10-2-378" id="h10-2-378" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-380" id="h10-2-380" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-381" id="h10-2-381" class="d">-                to: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-382" id="h10-2-382" class="i">+                from: Address::Local,
</a><a href="#h10-2-383" id="h10-2-383" class="i">+                to: Address::Peer(&quot;c&quot;.into()),
</a>                 term: 3,
                 event: Event::GrantVote,
             }],
         );
<a href="#h10-2-388" id="h10-2-388" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a> 
         // Another vote request from the same sender is granted.
         node = node.step(Message {
<a href="#h10-2-392" id="h10-2-392" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-393" id="h10-2-393" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-394" id="h10-2-394" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-395" id="h10-2-395" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::SolicitVote { last_index: 3, last_term: 2 },
         })?;
         assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
         assert_messages(
<a href="#h10-2-401" id="h10-2-401" class="d">-            &amp;mut rx,
</a><a href="#h10-2-402" id="h10-2-402" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-404" id="h10-2-404" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-405" id="h10-2-405" class="d">-                to: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-406" id="h10-2-406" class="i">+                from: Address::Local,
</a><a href="#h10-2-407" id="h10-2-407" class="i">+                to: Address::Peer(&quot;c&quot;.into()),
</a>                 term: 3,
                 event: Event::GrantVote,
             }],
         );
<a href="#h10-2-412" id="h10-2-412" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a> 
         // But a vote request from a different node is ignored.
         node = node.step(Message {
<a href="#h10-2-416" id="h10-2-416" class="d">-            from: Some(&quot;d&quot;.into()),
</a><a href="#h10-2-417" id="h10-2-417" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-418" id="h10-2-418" class="i">+            from: Address::Peer(&quot;d&quot;.into()),
</a><a href="#h10-2-419" id="h10-2-419" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::SolicitVote { last_index: 3, last_term: 2 },
         })?;
         assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(Some(&quot;c&quot;));
<a href="#h10-2-424" id="h10-2-424" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h10-2-425" id="h10-2-425" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h10-2-426" id="h10-2-426" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // GrantVote messages are ignored
     fn step_grantvote_noop() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-433" id="h10-2-433" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-434" id="h10-2-434" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-436" id="h10-2-436" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-437" id="h10-2-437" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-438" id="h10-2-438" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-439" id="h10-2-439" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::GrantVote,
         })?;
         assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;));
<a href="#h10-2-444" id="h10-2-444" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h10-2-445" id="h10-2-445" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h10-2-446" id="h10-2-446" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // SolicitVote is rejected if last_term is outdated.
     fn step_solicitvote_last_index_outdated() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-453" id="h10-2-453" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-454" id="h10-2-454" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-456" id="h10-2-456" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-457" id="h10-2-457" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-458" id="h10-2-458" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-459" id="h10-2-459" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::SolicitVote { last_index: 2, last_term: 2 },
         })?;
         assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None);
<a href="#h10-2-464" id="h10-2-464" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h10-2-465" id="h10-2-465" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h10-2-466" id="h10-2-466" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // SolicitVote is rejected if last_term is outdated.
     fn step_solicitvote_last_term_outdated() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-473" id="h10-2-473" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-474" id="h10-2-474" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-476" id="h10-2-476" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h10-2-477" id="h10-2-477" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-478" id="h10-2-478" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-479" id="h10-2-479" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::SolicitVote { last_index: 3, last_term: 1 },
         })?;
         assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).voted_for(None);
<a href="#h10-2-484" id="h10-2-484" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h10-2-485" id="h10-2-485" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h10-2-486" id="h10-2-486" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // ReplicateEntries accepts some entries at base 0 without changes
     fn step_replicateentries_base0() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-493" id="h10-2-493" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-494" id="h10-2-494" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-496" id="h10-2-496" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-497" id="h10-2-497" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-498" id="h10-2-498" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-499" id="h10-2-499" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ReplicateEntries {
                 base_index: 0,
                 base_term: 0,
                 entries: vec![
<a href="#h10-2-505" id="h10-2-505" class="d">-                    Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-506" id="h10-2-506" class="d">-                    Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-507" id="h10-2-507" class="i">+                    Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-508" id="h10-2-508" class="i">+                    Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a>                 ],
             },
         })?;
         assert_node(&amp;node).is_follower().term(3).entries(vec![
<a href="#h10-2-513" id="h10-2-513" class="d">-            Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-514" id="h10-2-514" class="d">-            Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-515" id="h10-2-515" class="d">-            Entry { term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-516" id="h10-2-516" class="i">+            Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-517" id="h10-2-517" class="i">+            Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-518" id="h10-2-518" class="i">+            Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a>         ]);
         assert_messages(
<a href="#h10-2-521" id="h10-2-521" class="d">-            &amp;mut rx,
</a><a href="#h10-2-522" id="h10-2-522" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-524" id="h10-2-524" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-525" id="h10-2-525" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-526" id="h10-2-526" class="i">+                from: Address::Local,
</a><a href="#h10-2-527" id="h10-2-527" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 3 },
             }],
         );
<a href="#h10-2-532" id="h10-2-532" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
<a href="#h10-2-537" id="h10-2-537" class="d">-    // ReplicateEntries appends entries
</a><a href="#h10-2-538" id="h10-2-538" class="i">+    // ReplicateEntries appends entries but does not commit them
</a>     fn step_replicateentries_append() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-540" id="h10-2-540" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-541" id="h10-2-541" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-543" id="h10-2-543" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-544" id="h10-2-544" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-545" id="h10-2-545" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-546" id="h10-2-546" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ReplicateEntries {
                 base_index: 3,
                 base_term: 2,
                 entries: vec![
<a href="#h10-2-552" id="h10-2-552" class="d">-                    Entry { term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-553" id="h10-2-553" class="d">-                    Entry { term: 3, command: Some(vec![0x05]) },
</a><a href="#h10-2-554" id="h10-2-554" class="i">+                    Entry { index: 4, term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-555" id="h10-2-555" class="i">+                    Entry { index: 5, term: 3, command: Some(vec![0x05]) },
</a>                 ],
             },
         })?;
         assert_node(&amp;node).is_follower().term(3).entries(vec![
<a href="#h10-2-560" id="h10-2-560" class="d">-            Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-561" id="h10-2-561" class="d">-            Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-562" id="h10-2-562" class="d">-            Entry { term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-563" id="h10-2-563" class="d">-            Entry { term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-564" id="h10-2-564" class="d">-            Entry { term: 3, command: Some(vec![0x05]) },
</a><a href="#h10-2-565" id="h10-2-565" class="i">+            Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-566" id="h10-2-566" class="i">+            Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-567" id="h10-2-567" class="i">+            Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-568" id="h10-2-568" class="i">+            Entry { index: 4, term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-569" id="h10-2-569" class="i">+            Entry { index: 5, term: 3, command: Some(vec![0x05]) },
</a>         ]);
         assert_messages(
<a href="#h10-2-572" id="h10-2-572" class="d">-            &amp;mut rx,
</a><a href="#h10-2-573" id="h10-2-573" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-575" id="h10-2-575" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-576" id="h10-2-576" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-577" id="h10-2-577" class="i">+                from: Address::Local,
</a><a href="#h10-2-578" id="h10-2-578" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 5 },
             }],
         );
<a href="#h10-2-583" id="h10-2-583" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // ReplicateEntries accepts partially overlapping entries
     fn step_replicateentries_partial_overlap() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-590" id="h10-2-590" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-591" id="h10-2-591" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-593" id="h10-2-593" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-594" id="h10-2-594" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-595" id="h10-2-595" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-596" id="h10-2-596" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ReplicateEntries {
                 base_index: 1,
                 base_term: 1,
                 entries: vec![
<a href="#h10-2-602" id="h10-2-602" class="d">-                    Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-603" id="h10-2-603" class="d">-                    Entry { term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-604" id="h10-2-604" class="d">-                    Entry { term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-605" id="h10-2-605" class="i">+                    Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-606" id="h10-2-606" class="i">+                    Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-607" id="h10-2-607" class="i">+                    Entry { index: 4, term: 3, command: Some(vec![0x04]) },
</a>                 ],
             },
         })?;
         assert_node(&amp;node).is_follower().term(3).entries(vec![
<a href="#h10-2-612" id="h10-2-612" class="d">-            Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-613" id="h10-2-613" class="d">-            Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-614" id="h10-2-614" class="d">-            Entry { term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-615" id="h10-2-615" class="d">-            Entry { term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-616" id="h10-2-616" class="i">+            Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-617" id="h10-2-617" class="i">+            Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-618" id="h10-2-618" class="i">+            Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-619" id="h10-2-619" class="i">+            Entry { index: 4, term: 3, command: Some(vec![0x04]) },
</a>         ]);
         assert_messages(
<a href="#h10-2-622" id="h10-2-622" class="d">-            &amp;mut rx,
</a><a href="#h10-2-623" id="h10-2-623" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-625" id="h10-2-625" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-626" id="h10-2-626" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-627" id="h10-2-627" class="i">+                from: Address::Local,
</a><a href="#h10-2-628" id="h10-2-628" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 4 },
             }],
         );
<a href="#h10-2-633" id="h10-2-633" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // ReplicateEntries replaces conflicting entries
     fn step_replicateentries_replace() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-640" id="h10-2-640" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-641" id="h10-2-641" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-643" id="h10-2-643" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-644" id="h10-2-644" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-645" id="h10-2-645" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-646" id="h10-2-646" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ReplicateEntries {
                 base_index: 2,
                 base_term: 1,
                 entries: vec![
<a href="#h10-2-652" id="h10-2-652" class="d">-                    Entry { term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-653" id="h10-2-653" class="d">-                    Entry { term: 3, command: Some(vec![0x05]) },
</a><a href="#h10-2-654" id="h10-2-654" class="i">+                    Entry { index: 3, term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-655" id="h10-2-655" class="i">+                    Entry { index: 4, term: 3, command: Some(vec![0x05]) },
</a>                 ],
             },
         })?;
         assert_node(&amp;node).is_follower().term(3).entries(vec![
<a href="#h10-2-660" id="h10-2-660" class="d">-            Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-661" id="h10-2-661" class="d">-            Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-662" id="h10-2-662" class="d">-            Entry { term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-663" id="h10-2-663" class="d">-            Entry { term: 3, command: Some(vec![0x05]) },
</a><a href="#h10-2-664" id="h10-2-664" class="i">+            Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-665" id="h10-2-665" class="i">+            Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-666" id="h10-2-666" class="i">+            Entry { index: 3, term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-667" id="h10-2-667" class="i">+            Entry { index: 4, term: 3, command: Some(vec![0x05]) },
</a>         ]);
         assert_messages(
<a href="#h10-2-670" id="h10-2-670" class="d">-            &amp;mut rx,
</a><a href="#h10-2-671" id="h10-2-671" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-673" id="h10-2-673" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-674" id="h10-2-674" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-675" id="h10-2-675" class="i">+                from: Address::Local,
</a><a href="#h10-2-676" id="h10-2-676" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 4 },
             }],
         );
<a href="#h10-2-681" id="h10-2-681" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // ReplicateEntries replaces partially conflicting entries
     fn step_replicateentries_replace_partial() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-688" id="h10-2-688" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-689" id="h10-2-689" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-691" id="h10-2-691" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-692" id="h10-2-692" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-693" id="h10-2-693" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-694" id="h10-2-694" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ReplicateEntries {
                 base_index: 2,
                 base_term: 1,
                 entries: vec![
<a href="#h10-2-700" id="h10-2-700" class="d">-                    Entry { term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-701" id="h10-2-701" class="d">-                    Entry { term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-702" id="h10-2-702" class="i">+                    Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-703" id="h10-2-703" class="i">+                    Entry { index: 4, term: 3, command: Some(vec![0x04]) },
</a>                 ],
             },
         })?;
         assert_node(&amp;node).is_follower().term(3).entries(vec![
<a href="#h10-2-708" id="h10-2-708" class="d">-            Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-709" id="h10-2-709" class="d">-            Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-710" id="h10-2-710" class="d">-            Entry { term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-711" id="h10-2-711" class="d">-            Entry { term: 3, command: Some(vec![0x04]) },
</a><a href="#h10-2-712" id="h10-2-712" class="i">+            Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-713" id="h10-2-713" class="i">+            Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-714" id="h10-2-714" class="i">+            Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-715" id="h10-2-715" class="i">+            Entry { index: 4, term: 3, command: Some(vec![0x04]) },
</a>         ]);
         assert_messages(
<a href="#h10-2-718" id="h10-2-718" class="d">-            &amp;mut rx,
</a><a href="#h10-2-719" id="h10-2-719" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-721" id="h10-2-721" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-722" id="h10-2-722" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-723" id="h10-2-723" class="i">+                from: Address::Local,
</a><a href="#h10-2-724" id="h10-2-724" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 4 },
             }],
         );
<a href="#h10-2-729" id="h10-2-729" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // ReplicateEntries rejects missing base index
     fn step_replicateentries_reject_missing_base_index() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-736" id="h10-2-736" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-737" id="h10-2-737" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-739" id="h10-2-739" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-740" id="h10-2-740" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-741" id="h10-2-741" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-742" id="h10-2-742" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ReplicateEntries {
                 base_index: 5,
                 base_term: 2,
<a href="#h10-2-747" id="h10-2-747" class="d">-                entries: vec![Entry { term: 3, command: Some(vec![0x04]) }],
</a><a href="#h10-2-748" id="h10-2-748" class="i">+                entries: vec![Entry { index: 6, term: 3, command: Some(vec![0x04]) }],
</a>             },
         })?;
         assert_node(&amp;node).is_follower().term(3).entries(vec![
<a href="#h10-2-752" id="h10-2-752" class="d">-            Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-753" id="h10-2-753" class="d">-            Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-754" id="h10-2-754" class="d">-            Entry { term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-755" id="h10-2-755" class="i">+            Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-756" id="h10-2-756" class="i">+            Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-757" id="h10-2-757" class="i">+            Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a>         ]);
         assert_messages(
<a href="#h10-2-760" id="h10-2-760" class="d">-            &amp;mut rx,
</a><a href="#h10-2-761" id="h10-2-761" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-763" id="h10-2-763" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-764" id="h10-2-764" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-765" id="h10-2-765" class="i">+                from: Address::Local,
</a><a href="#h10-2-766" id="h10-2-766" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::RejectEntries,
             }],
         );
<a href="#h10-2-771" id="h10-2-771" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // ReplicateEntries rejects conflicting base term
     fn step_replicateentries_reject_missing_base_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-778" id="h10-2-778" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-779" id="h10-2-779" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let node = follower.step(Message {
<a href="#h10-2-781" id="h10-2-781" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-782" id="h10-2-782" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-783" id="h10-2-783" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-784" id="h10-2-784" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ReplicateEntries {
                 base_index: 1,
                 base_term: 2,
<a href="#h10-2-789" id="h10-2-789" class="d">-                entries: vec![Entry { term: 3, command: Some(vec![0x04]) }],
</a><a href="#h10-2-790" id="h10-2-790" class="i">+                entries: vec![Entry { index: 2, term: 3, command: Some(vec![0x04]) }],
</a>             },
         })?;
         assert_node(&amp;node).is_follower().term(3).entries(vec![
<a href="#h10-2-794" id="h10-2-794" class="d">-            Entry { term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-795" id="h10-2-795" class="d">-            Entry { term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-796" id="h10-2-796" class="d">-            Entry { term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-797" id="h10-2-797" class="i">+            Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h10-2-798" id="h10-2-798" class="i">+            Entry { index: 2, term: 1, command: Some(vec![0x02]) },
</a><a href="#h10-2-799" id="h10-2-799" class="i">+            Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a>         ]);
         assert_messages(
<a href="#h10-2-802" id="h10-2-802" class="d">-            &amp;mut rx,
</a><a href="#h10-2-803" id="h10-2-803" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h10-2-805" id="h10-2-805" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-806" id="h10-2-806" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-807" id="h10-2-807" class="i">+                from: Address::Local,
</a><a href="#h10-2-808" id="h10-2-808" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::RejectEntries,
             }],
         );
<a href="#h10-2-813" id="h10-2-813" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
<a href="#h10-2-818" id="h10-2-818" class="d">-    // ReadState and MutateState are proxied, as are the responses
</a><a href="#h10-2-819" id="h10-2-819" class="d">-    fn step_readstate_mutatestate_respond() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-2-820" id="h10-2-820" class="d">-        let calls = vec![
</a><a href="#h10-2-821" id="h10-2-821" class="d">-            Event::MutateState { call_id: vec![0x02], command: vec![0x02] },
</a><a href="#h10-2-822" id="h10-2-822" class="d">-            Event::QueryState { call_id: vec![0x01], command: vec![0x01] },
</a><a href="#h10-2-823" id="h10-2-823" class="d">-        ];
</a><a href="#h10-2-824" id="h10-2-824" class="d">-        let responses = vec![
</a><a href="#h10-2-825" id="h10-2-825" class="d">-            Event::RespondError { call_id: vec![], error: Error::Internal(&quot;b00m&quot;.into()) },
</a><a href="#h10-2-826" id="h10-2-826" class="d">-            Event::RespondState { call_id: vec![], response: vec![0xaf] },
</a><a href="#h10-2-827" id="h10-2-827" class="d">-        ];
</a><a href="#h10-2-828" id="h10-2-828" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-829" id="h10-2-829" class="i">+    // ClientRequest is proxied, as is the response.
</a><a href="#h10-2-830" id="h10-2-830" class="i">+    fn step_clientrequest_clientresponse() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-2-831" id="h10-2-831" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let mut node = Node::Follower(follower);
<a href="#h10-2-833" id="h10-2-833" class="d">-        for call in calls.into_iter() {
</a><a href="#h10-2-834" id="h10-2-834" class="d">-            for mut response in responses.clone().into_iter() {
</a><a href="#h10-2-835" id="h10-2-835" class="d">-                node = node.step(Message { from: None, to: None, term: 0, event: call.clone() })?;
</a><a href="#h10-2-836" id="h10-2-836" class="d">-                assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;));
</a><a href="#h10-2-837" id="h10-2-837" class="d">-                assert_messages(
</a><a href="#h10-2-838" id="h10-2-838" class="d">-                    &amp;mut rx,
</a><a href="#h10-2-839" id="h10-2-839" class="d">-                    vec![Message {
</a><a href="#h10-2-840" id="h10-2-840" class="d">-                        from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-841" id="h10-2-841" class="d">-                        to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-842" id="h10-2-842" class="d">-                        term: 3,
</a><a href="#h10-2-843" id="h10-2-843" class="d">-                        event: call.clone(),
</a><a href="#h10-2-844" id="h10-2-844" class="d">-                    }],
</a><a href="#h10-2-845" id="h10-2-845" class="d">-                );
</a><a href="#h10-2-846" id="h10-2-846" class="d">-                match response {
</a><a href="#h10-2-847" id="h10-2-847" class="d">-                    Event::RespondError { ref mut call_id, .. }
</a><a href="#h10-2-848" id="h10-2-848" class="d">-                    | Event::RespondState { ref mut call_id, .. } =&gt; {
</a><a href="#h10-2-849" id="h10-2-849" class="d">-                        *call_id = call.call_id().unwrap()
</a><a href="#h10-2-850" id="h10-2-850" class="d">-                    }
</a><a href="#h10-2-851" id="h10-2-851" class="d">-                    _ =&gt; {}
</a><a href="#h10-2-852" id="h10-2-852" class="d">-                }
</a><a href="#h10-2-853" id="h10-2-853" class="d">-                // Multiple responses should only be proxied once.
</a><a href="#h10-2-854" id="h10-2-854" class="d">-                for _ in 0..3 {
</a><a href="#h10-2-855" id="h10-2-855" class="d">-                    node = node.step(Message {
</a><a href="#h10-2-856" id="h10-2-856" class="d">-                        from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-857" id="h10-2-857" class="d">-                        to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-858" id="h10-2-858" class="d">-                        term: 3,
</a><a href="#h10-2-859" id="h10-2-859" class="d">-                        event: response.clone(),
</a><a href="#h10-2-860" id="h10-2-860" class="d">-                    })?;
</a><a href="#h10-2-861" id="h10-2-861" class="d">-                }
</a><a href="#h10-2-862" id="h10-2-862" class="d">-                assert_messages(
</a><a href="#h10-2-863" id="h10-2-863" class="d">-                    &amp;mut rx,
</a><a href="#h10-2-864" id="h10-2-864" class="d">-                    vec![Message { from: Some(&quot;a&quot;.into()), to: None, term: 3, event: response }],
</a><a href="#h10-2-865" id="h10-2-865" class="d">-                );
</a><a href="#h10-2-866" id="h10-2-866" class="d">-            }
</a><a href="#h10-2-867" id="h10-2-867" class="d">-        }
</a><a href="#h10-2-868" id="h10-2-868" class="i">+
</a><a href="#h10-2-869" id="h10-2-869" class="i">+        node = node.step(Message {
</a><a href="#h10-2-870" id="h10-2-870" class="i">+            from: Address::Client,
</a><a href="#h10-2-871" id="h10-2-871" class="i">+            to: Address::Local,
</a><a href="#h10-2-872" id="h10-2-872" class="i">+            term: 0,
</a><a href="#h10-2-873" id="h10-2-873" class="i">+            event: Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
</a><a href="#h10-2-874" id="h10-2-874" class="i">+        })?;
</a><a href="#h10-2-875" id="h10-2-875" class="i">+        assert_node(&amp;node)
</a><a href="#h10-2-876" id="h10-2-876" class="i">+            .is_follower()
</a><a href="#h10-2-877" id="h10-2-877" class="i">+            .term(3)
</a><a href="#h10-2-878" id="h10-2-878" class="i">+            .leader(Some(&quot;b&quot;))
</a><a href="#h10-2-879" id="h10-2-879" class="i">+            .proxied(vec![(vec![0x01], Address::Client)])
</a><a href="#h10-2-880" id="h10-2-880" class="i">+            .queued(vec![]);
</a><a href="#h10-2-881" id="h10-2-881" class="i">+        assert_messages(
</a><a href="#h10-2-882" id="h10-2-882" class="i">+            &amp;mut node_rx,
</a><a href="#h10-2-883" id="h10-2-883" class="i">+            vec![Message {
</a><a href="#h10-2-884" id="h10-2-884" class="i">+                from: Address::Local,
</a><a href="#h10-2-885" id="h10-2-885" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-886" id="h10-2-886" class="i">+                term: 3,
</a><a href="#h10-2-887" id="h10-2-887" class="i">+                event: Event::ClientRequest {
</a><a href="#h10-2-888" id="h10-2-888" class="i">+                    id: vec![0x01],
</a><a href="#h10-2-889" id="h10-2-889" class="i">+                    request: Request::Mutate(vec![0xaf]),
</a><a href="#h10-2-890" id="h10-2-890" class="i">+                },
</a><a href="#h10-2-891" id="h10-2-891" class="i">+            }],
</a><a href="#h10-2-892" id="h10-2-892" class="i">+        );
</a><a href="#h10-2-893" id="h10-2-893" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a><a href="#h10-2-894" id="h10-2-894" class="i">+
</a><a href="#h10-2-895" id="h10-2-895" class="i">+        node = node.step(Message {
</a><a href="#h10-2-896" id="h10-2-896" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-897" id="h10-2-897" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a><a href="#h10-2-898" id="h10-2-898" class="i">+            term: 3,
</a><a href="#h10-2-899" id="h10-2-899" class="i">+            event: Event::ClientResponse {
</a><a href="#h10-2-900" id="h10-2-900" class="i">+                id: vec![0x01],
</a><a href="#h10-2-901" id="h10-2-901" class="i">+                response: Ok(Response::State(vec![0xaf])),
</a><a href="#h10-2-902" id="h10-2-902" class="i">+            },
</a><a href="#h10-2-903" id="h10-2-903" class="i">+        })?;
</a><a href="#h10-2-904" id="h10-2-904" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).proxied(vec![]).queued(vec![]);
</a><a href="#h10-2-905" id="h10-2-905" class="i">+        assert_messages(
</a><a href="#h10-2-906" id="h10-2-906" class="i">+            &amp;mut node_rx,
</a><a href="#h10-2-907" id="h10-2-907" class="i">+            vec![Message {
</a><a href="#h10-2-908" id="h10-2-908" class="i">+                from: Address::Local,
</a><a href="#h10-2-909" id="h10-2-909" class="i">+                to: Address::Client,
</a><a href="#h10-2-910" id="h10-2-910" class="i">+                term: 3,
</a><a href="#h10-2-911" id="h10-2-911" class="i">+                event: Event::ClientResponse {
</a><a href="#h10-2-912" id="h10-2-912" class="i">+                    id: vec![0x01],
</a><a href="#h10-2-913" id="h10-2-913" class="i">+                    response: Ok(Response::State(vec![0xaf])),
</a><a href="#h10-2-914" id="h10-2-914" class="i">+                },
</a><a href="#h10-2-915" id="h10-2-915" class="i">+            }],
</a><a href="#h10-2-916" id="h10-2-916" class="i">+        );
</a><a href="#h10-2-917" id="h10-2-917" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a><a href="#h10-2-918" id="h10-2-918" class="i">+        Ok(())
</a><a href="#h10-2-919" id="h10-2-919" class="i">+    }
</a><a href="#h10-2-920" id="h10-2-920" class="i">+
</a><a href="#h10-2-921" id="h10-2-921" class="i">+    #[test]
</a><a href="#h10-2-922" id="h10-2-922" class="i">+    // ClientRequest is queued when there is no leader, and forwarded when a leader appears.
</a><a href="#h10-2-923" id="h10-2-923" class="i">+    fn step_clientrequest_queued() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-2-924" id="h10-2-924" class="i">+        let (mut follower, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h10-2-925" id="h10-2-925" class="i">+        follower.role = Follower::new(None, None);
</a><a href="#h10-2-926" id="h10-2-926" class="i">+        let mut node = Node::Follower(follower);
</a><a href="#h10-2-927" id="h10-2-927" class="i">+
</a><a href="#h10-2-928" id="h10-2-928" class="i">+        node = node.step(Message {
</a><a href="#h10-2-929" id="h10-2-929" class="i">+            from: Address::Client,
</a><a href="#h10-2-930" id="h10-2-930" class="i">+            to: Address::Local,
</a><a href="#h10-2-931" id="h10-2-931" class="i">+            term: 0,
</a><a href="#h10-2-932" id="h10-2-932" class="i">+            event: Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
</a><a href="#h10-2-933" id="h10-2-933" class="i">+        })?;
</a><a href="#h10-2-934" id="h10-2-934" class="i">+        assert_node(&amp;node).is_follower().term(3).leader(None).proxied(vec![]).queued(vec![(
</a><a href="#h10-2-935" id="h10-2-935" class="i">+            Address::Client,
</a><a href="#h10-2-936" id="h10-2-936" class="i">+            Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
</a><a href="#h10-2-937" id="h10-2-937" class="i">+        )]);
</a><a href="#h10-2-938" id="h10-2-938" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h10-2-939" id="h10-2-939" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a><a href="#h10-2-940" id="h10-2-940" class="i">+
</a><a href="#h10-2-941" id="h10-2-941" class="i">+        // When a leader appears, we will proxy the queued request to them.
</a><a href="#h10-2-942" id="h10-2-942" class="i">+        node = node.step(Message {
</a><a href="#h10-2-943" id="h10-2-943" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-944" id="h10-2-944" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a><a href="#h10-2-945" id="h10-2-945" class="i">+            term: 3,
</a><a href="#h10-2-946" id="h10-2-946" class="i">+            event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
</a><a href="#h10-2-947" id="h10-2-947" class="i">+        })?;
</a><a href="#h10-2-948" id="h10-2-948" class="i">+        assert_node(&amp;node)
</a><a href="#h10-2-949" id="h10-2-949" class="i">+            .is_follower()
</a><a href="#h10-2-950" id="h10-2-950" class="i">+            .term(3)
</a><a href="#h10-2-951" id="h10-2-951" class="i">+            .leader(Some(&quot;c&quot;))
</a><a href="#h10-2-952" id="h10-2-952" class="i">+            .proxied(vec![(vec![0x01], Address::Client)])
</a><a href="#h10-2-953" id="h10-2-953" class="i">+            .queued(vec![]);
</a><a href="#h10-2-954" id="h10-2-954" class="i">+        assert_messages(
</a><a href="#h10-2-955" id="h10-2-955" class="i">+            &amp;mut node_rx,
</a><a href="#h10-2-956" id="h10-2-956" class="i">+            vec![
</a><a href="#h10-2-957" id="h10-2-957" class="i">+                Message {
</a><a href="#h10-2-958" id="h10-2-958" class="i">+                    from: Address::Local,
</a><a href="#h10-2-959" id="h10-2-959" class="i">+                    to: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-960" id="h10-2-960" class="i">+                    term: 0,
</a><a href="#h10-2-961" id="h10-2-961" class="i">+                    event: Event::ClientRequest {
</a><a href="#h10-2-962" id="h10-2-962" class="i">+                        id: vec![0x01],
</a><a href="#h10-2-963" id="h10-2-963" class="i">+                        request: Request::Mutate(vec![0xaf]),
</a><a href="#h10-2-964" id="h10-2-964" class="i">+                    },
</a><a href="#h10-2-965" id="h10-2-965" class="i">+                },
</a><a href="#h10-2-966" id="h10-2-966" class="i">+                Message {
</a><a href="#h10-2-967" id="h10-2-967" class="i">+                    from: Address::Local,
</a><a href="#h10-2-968" id="h10-2-968" class="i">+                    to: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-969" id="h10-2-969" class="i">+                    term: 3,
</a><a href="#h10-2-970" id="h10-2-970" class="i">+                    event: Event::ConfirmLeader { commit_index: 3, has_committed: true },
</a><a href="#h10-2-971" id="h10-2-971" class="i">+                },
</a><a href="#h10-2-972" id="h10-2-972" class="i">+            ],
</a><a href="#h10-2-973" id="h10-2-973" class="i">+        );
</a><a href="#h10-2-974" id="h10-2-974" class="i">+        assert_messages(
</a><a href="#h10-2-975" id="h10-2-975" class="i">+            &amp;mut state_rx,
</a><a href="#h10-2-976" id="h10-2-976" class="i">+            vec![Instruction::Apply {
</a><a href="#h10-2-977" id="h10-2-977" class="i">+                entry: Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-978" id="h10-2-978" class="i">+            }],
</a><a href="#h10-2-979" id="h10-2-979" class="i">+        );
</a><a href="#h10-2-980" id="h10-2-980" class="i">+        Ok(())
</a><a href="#h10-2-981" id="h10-2-981" class="i">+    }
</a><a href="#h10-2-982" id="h10-2-982" class="i">+
</a><a href="#h10-2-983" id="h10-2-983" class="i">+    // ClientRequest is proxied, but aborted when a new leader appears.
</a><a href="#h10-2-984" id="h10-2-984" class="i">+    #[test]
</a><a href="#h10-2-985" id="h10-2-985" class="i">+    fn step_clientrequest_aborted() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-2-986" id="h10-2-986" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h10-2-987" id="h10-2-987" class="i">+        let mut node = Node::Follower(follower);
</a><a href="#h10-2-988" id="h10-2-988" class="i">+
</a><a href="#h10-2-989" id="h10-2-989" class="i">+        node = node.step(Message {
</a><a href="#h10-2-990" id="h10-2-990" class="i">+            from: Address::Client,
</a><a href="#h10-2-991" id="h10-2-991" class="i">+            to: Address::Local,
</a><a href="#h10-2-992" id="h10-2-992" class="i">+            term: 0,
</a><a href="#h10-2-993" id="h10-2-993" class="i">+            event: Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
</a><a href="#h10-2-994" id="h10-2-994" class="i">+        })?;
</a><a href="#h10-2-995" id="h10-2-995" class="i">+        assert_node(&amp;node)
</a><a href="#h10-2-996" id="h10-2-996" class="i">+            .is_follower()
</a><a href="#h10-2-997" id="h10-2-997" class="i">+            .term(3)
</a><a href="#h10-2-998" id="h10-2-998" class="i">+            .leader(Some(&quot;b&quot;))
</a><a href="#h10-2-999" id="h10-2-999" class="i">+            .proxied(vec![(vec![0x01], Address::Client)])
</a><a href="#h10-2-1000" id="h10-2-1000" class="i">+            .queued(vec![]);
</a><a href="#h10-2-1001" id="h10-2-1001" class="i">+        assert_messages(
</a><a href="#h10-2-1002" id="h10-2-1002" class="i">+            &amp;mut node_rx,
</a><a href="#h10-2-1003" id="h10-2-1003" class="i">+            vec![Message {
</a><a href="#h10-2-1004" id="h10-2-1004" class="i">+                from: Address::Local,
</a><a href="#h10-2-1005" id="h10-2-1005" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-1006" id="h10-2-1006" class="i">+                term: 3,
</a><a href="#h10-2-1007" id="h10-2-1007" class="i">+                event: Event::ClientRequest {
</a><a href="#h10-2-1008" id="h10-2-1008" class="i">+                    id: vec![0x01],
</a><a href="#h10-2-1009" id="h10-2-1009" class="i">+                    request: Request::Mutate(vec![0xaf]),
</a><a href="#h10-2-1010" id="h10-2-1010" class="i">+                },
</a><a href="#h10-2-1011" id="h10-2-1011" class="i">+            }],
</a><a href="#h10-2-1012" id="h10-2-1012" class="i">+        );
</a><a href="#h10-2-1013" id="h10-2-1013" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a><a href="#h10-2-1014" id="h10-2-1014" class="i">+
</a><a href="#h10-2-1015" id="h10-2-1015" class="i">+        // When a new leader appears, the proxied request is aborted.
</a><a href="#h10-2-1016" id="h10-2-1016" class="i">+        node = node.step(Message {
</a><a href="#h10-2-1017" id="h10-2-1017" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-1018" id="h10-2-1018" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a><a href="#h10-2-1019" id="h10-2-1019" class="i">+            term: 4,
</a><a href="#h10-2-1020" id="h10-2-1020" class="i">+            event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
</a><a href="#h10-2-1021" id="h10-2-1021" class="i">+        })?;
</a><a href="#h10-2-1022" id="h10-2-1022" class="i">+        assert_node(&amp;node).is_follower().term(4).leader(Some(&quot;c&quot;)).proxied(vec![]).queued(vec![]);
</a><a href="#h10-2-1023" id="h10-2-1023" class="i">+        assert_messages(
</a><a href="#h10-2-1024" id="h10-2-1024" class="i">+            &amp;mut node_rx,
</a><a href="#h10-2-1025" id="h10-2-1025" class="i">+            vec![
</a><a href="#h10-2-1026" id="h10-2-1026" class="i">+                Message {
</a><a href="#h10-2-1027" id="h10-2-1027" class="i">+                    from: Address::Local,
</a><a href="#h10-2-1028" id="h10-2-1028" class="i">+                    to: Address::Client,
</a><a href="#h10-2-1029" id="h10-2-1029" class="i">+                    term: 4,
</a><a href="#h10-2-1030" id="h10-2-1030" class="i">+                    event: Event::ClientResponse { id: vec![0x01], response: Err(Error::Abort) },
</a><a href="#h10-2-1031" id="h10-2-1031" class="i">+                },
</a><a href="#h10-2-1032" id="h10-2-1032" class="i">+                Message {
</a><a href="#h10-2-1033" id="h10-2-1033" class="i">+                    from: Address::Local,
</a><a href="#h10-2-1034" id="h10-2-1034" class="i">+                    to: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h10-2-1035" id="h10-2-1035" class="i">+                    term: 4,
</a><a href="#h10-2-1036" id="h10-2-1036" class="i">+                    event: Event::ConfirmLeader { commit_index: 3, has_committed: true },
</a><a href="#h10-2-1037" id="h10-2-1037" class="i">+                },
</a><a href="#h10-2-1038" id="h10-2-1038" class="i">+            ],
</a><a href="#h10-2-1039" id="h10-2-1039" class="i">+        );
</a><a href="#h10-2-1040" id="h10-2-1040" class="i">+        assert_messages(
</a><a href="#h10-2-1041" id="h10-2-1041" class="i">+            &amp;mut state_rx,
</a><a href="#h10-2-1042" id="h10-2-1042" class="i">+            vec![Instruction::Apply {
</a><a href="#h10-2-1043" id="h10-2-1043" class="i">+                entry: Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h10-2-1044" id="h10-2-1044" class="i">+            }],
</a><a href="#h10-2-1045" id="h10-2-1045" class="i">+        );
</a>         Ok(())
     }
 
     #[test]
     fn tick() -&gt; Result&lt;(), Error&gt; {
<a href="#h10-2-1051" id="h10-2-1051" class="d">-        let (follower, mut rx) = setup()?;
</a><a href="#h10-2-1052" id="h10-2-1052" class="i">+        let (follower, mut node_rx, mut state_rx) = setup()?;
</a>         let timeout = follower.role.leader_seen_timeout;
<a href="#h10-2-1054" id="h10-2-1054" class="d">-        let peers = follower.peers.clone();
</a>         let mut node = Node::Follower(follower);
 
         // Make sure heartbeats reset election timeout
         assert!(timeout &gt; 0);
<a href="#h10-2-1059" id="h10-2-1059" class="d">-        for i in 0..(3 * timeout) {
</a><a href="#h10-2-1060" id="h10-2-1060" class="d">-            let applied = if i &gt; 0 { 2 } else { 1 };
</a><a href="#h10-2-1061" id="h10-2-1061" class="d">-            assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;)).applied(applied);
</a><a href="#h10-2-1062" id="h10-2-1062" class="i">+        for _ in 0..(3 * timeout) {
</a><a href="#h10-2-1063" id="h10-2-1063" class="i">+            assert_node(&amp;node).is_follower().term(3).leader(Some(&quot;b&quot;));
</a>             node = node.tick()?;
             node = node.step(Message {
<a href="#h10-2-1066" id="h10-2-1066" class="d">-                from: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-1067" id="h10-2-1067" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-1068" id="h10-2-1068" class="i">+                from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h10-2-1069" id="h10-2-1069" class="i">+                to: Address::Peer(&quot;a&quot;.into()),
</a>                 term: 3,
                 event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
             })?;
             assert_messages(
<a href="#h10-2-1074" id="h10-2-1074" class="d">-                &amp;mut rx,
</a><a href="#h10-2-1075" id="h10-2-1075" class="i">+                &amp;mut node_rx,
</a>                 vec![Message {
<a href="#h10-2-1077" id="h10-2-1077" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h10-2-1078" id="h10-2-1078" class="d">-                    to: Some(&quot;b&quot;.into()),
</a><a href="#h10-2-1079" id="h10-2-1079" class="i">+                    from: Address::Local,
</a><a href="#h10-2-1080" id="h10-2-1080" class="i">+                    to: Address::Peer(&quot;b&quot;.into()),
</a>                     term: 3,
                     event: Event::ConfirmLeader { commit_index: 2, has_committed: true },
                 }],
<a href="#h10-3" id="h10-3" class="h">@@ -834,17 +982,16 @@ pub mod tests {
</a>         }
         assert_node(&amp;node).is_candidate().term(4);
 
<a href="#h10-3-3" id="h10-3-3" class="d">-        for to in peers.into_iter() {
</a><a href="#h10-3-4" id="h10-3-4" class="d">-            assert_eq!(
</a><a href="#h10-3-5" id="h10-3-5" class="d">-                futures::executor::block_on(rx.next()),
</a><a href="#h10-3-6" id="h10-3-6" class="d">-                Some(Message {
</a><a href="#h10-3-7" id="h10-3-7" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h10-3-8" id="h10-3-8" class="d">-                    to: Some(to),
</a><a href="#h10-3-9" id="h10-3-9" class="d">-                    term: 4,
</a><a href="#h10-3-10" id="h10-3-10" class="d">-                    event: Event::SolicitVote { last_index: 3, last_term: 2 },
</a><a href="#h10-3-11" id="h10-3-11" class="d">-                })
</a><a href="#h10-3-12" id="h10-3-12" class="d">-            )
</a><a href="#h10-3-13" id="h10-3-13" class="d">-        }
</a><a href="#h10-3-14" id="h10-3-14" class="i">+        assert_messages(
</a><a href="#h10-3-15" id="h10-3-15" class="i">+            &amp;mut node_rx,
</a><a href="#h10-3-16" id="h10-3-16" class="i">+            vec![Message {
</a><a href="#h10-3-17" id="h10-3-17" class="i">+                from: Address::Local,
</a><a href="#h10-3-18" id="h10-3-18" class="i">+                to: Address::Peers,
</a><a href="#h10-3-19" id="h10-3-19" class="i">+                term: 4,
</a><a href="#h10-3-20" id="h10-3-20" class="i">+                event: Event::SolicitVote { last_index: 3, last_term: 2 },
</a><a href="#h10-3-21" id="h10-3-21" class="i">+            }],
</a><a href="#h10-3-22" id="h10-3-22" class="i">+        );
</a><a href="#h10-3-23" id="h10-3-23" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 }
<b>diff --git a/<a id="h11" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -1,10 +1,10 @@
</a><a href="#h11-0-0" id="h11-0-0" class="d">-use super::super::{Entry, Event, Message, State};
</a><a href="#h11-0-1" id="h11-0-1" class="i">+use super::super::{Address, Event, Instruction, Message, Request, Response, Status};
</a> use super::{Follower, Node, RoleNode, HEARTBEAT_INTERVAL};
 use crate::kv::storage::Storage;
 use crate::Error;
 
<a href="#h11-0-6" id="h11-0-6" class="d">-use log::{debug, info};
</a><a href="#h11-0-7" id="h11-0-7" class="d">-use std::collections::{HashMap, HashSet};
</a><a href="#h11-0-8" id="h11-0-8" class="i">+use log::{debug, info, warn};
</a><a href="#h11-0-9" id="h11-0-9" class="i">+use std::collections::HashMap;
</a> 
 // A leader serves requests and replicates the log to followers.
 #[derive(Debug)]
<a href="#h11-1" id="h11-1" class="h">@@ -15,8 +15,6 @@ pub struct Leader {
</a>     peer_next_index: HashMap&lt;String, u64&gt;,
     /// The last index known to be replicated on a peer.
     peer_last_index: HashMap&lt;String, u64&gt;,
<a href="#h11-1-3" id="h11-1-3" class="d">-    /// Any client calls being processed.
</a><a href="#h11-1-4" id="h11-1-4" class="d">-    calls: Calls,
</a> }
 
 impl Leader {
<a href="#h11-2" id="h11-2" class="h">@@ -26,7 +24,6 @@ impl Leader {
</a>             heartbeat_ticks: 0,
             peer_next_index: HashMap::new(),
             peer_last_index: HashMap::new(),
<a href="#h11-2-3" id="h11-2-3" class="d">-            calls: Calls::new(),
</a>         };
         for peer in peers {
             leader.peer_next_index.insert(peer.clone(), last_index + 1);
<a href="#h11-3" id="h11-3" class="h">@@ -36,43 +33,22 @@ impl Leader {
</a>     }
 }
 
<a href="#h11-3-3" id="h11-3-3" class="d">-impl&lt;L: Storage, S: State&gt; RoleNode&lt;Leader, L, S&gt; {
</a><a href="#h11-3-4" id="h11-3-4" class="i">+impl&lt;L: Storage&gt; RoleNode&lt;Leader, L&gt; {
</a>     /// Transforms the leader into a follower
<a href="#h11-3-6" id="h11-3-6" class="d">-    fn become_follower(
</a><a href="#h11-3-7" id="h11-3-7" class="d">-        mut self,
</a><a href="#h11-3-8" id="h11-3-8" class="d">-        term: u64,
</a><a href="#h11-3-9" id="h11-3-9" class="d">-        leader: &amp;str,
</a><a href="#h11-3-10" id="h11-3-10" class="d">-    ) -&gt; Result&lt;RoleNode&lt;Follower, L, S&gt;, Error&gt; {
</a><a href="#h11-3-11" id="h11-3-11" class="i">+    fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;, Error&gt; {
</a>         info!(&quot;Discovered new leader {} for term {}, following&quot;, leader, term);
         self.save_term(term, None)?;
<a href="#h11-3-14" id="h11-3-14" class="i">+        self.state_tx.send(Instruction::Abort)?;
</a>         self.become_role(Follower::new(Some(leader), None))
     }
 
     /// Appends an entry to the log and replicates it to peers.
     pub fn append(&amp;mut self, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;u64, Error&gt; {
<a href="#h11-3-20" id="h11-3-20" class="d">-        let index = self.log.append(Entry { term: self.term, command })?;
</a><a href="#h11-3-21" id="h11-3-21" class="i">+        let entry = self.log.append(self.term, command)?;
</a>         for peer in self.peers.iter() {
             self.replicate(peer)?;
         }
<a href="#h11-3-25" id="h11-3-25" class="d">-        Ok(index)
</a><a href="#h11-3-26" id="h11-3-26" class="d">-    }
</a><a href="#h11-3-27" id="h11-3-27" class="d">-
</a><a href="#h11-3-28" id="h11-3-28" class="d">-    /// Applies any pending log entries.
</a><a href="#h11-3-29" id="h11-3-29" class="d">-    fn apply(&amp;mut self) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h11-3-30" id="h11-3-30" class="d">-        let (mut index, _) = self.log.get_applied();
</a><a href="#h11-3-31" id="h11-3-31" class="d">-        while let Some((i, output)) = self.log.apply(&amp;mut self.state)? {
</a><a href="#h11-3-32" id="h11-3-32" class="d">-            index = i;
</a><a href="#h11-3-33" id="h11-3-33" class="d">-            if let Some(call) = self.role.calls.log_applied(index) {
</a><a href="#h11-3-34" id="h11-3-34" class="d">-                self.send(
</a><a href="#h11-3-35" id="h11-3-35" class="d">-                    call.from.as_deref(),
</a><a href="#h11-3-36" id="h11-3-36" class="d">-                    match output {
</a><a href="#h11-3-37" id="h11-3-37" class="d">-                        Ok(resp) =&gt; Event::RespondState { call_id: call.id, response: resp },
</a><a href="#h11-3-38" id="h11-3-38" class="d">-                        Err(err) =&gt; Event::RespondError { call_id: call.id, error: err },
</a><a href="#h11-3-39" id="h11-3-39" class="d">-                    },
</a><a href="#h11-3-40" id="h11-3-40" class="d">-                )?
</a><a href="#h11-3-41" id="h11-3-41" class="d">-            }
</a><a href="#h11-3-42" id="h11-3-42" class="d">-        }
</a><a href="#h11-3-43" id="h11-3-43" class="d">-        Ok(index)
</a><a href="#h11-3-44" id="h11-3-44" class="i">+        Ok(entry.index)
</a>     }
 
     /// Commits any pending log entries.
<a href="#h11-4" id="h11-4" class="h">@@ -89,10 +65,17 @@ impl&lt;L: Storage, S: State&gt; RoleNode&lt;Leader, L, S&gt; {
</a>         }
         // We can only safely commit up to an entry from our own term, see
         // figure 8 in Raft paper for background.
<a href="#h11-4-3" id="h11-4-3" class="d">-        match self.log.get(quorum_index)? {
</a><a href="#h11-4-4" id="h11-4-4" class="d">-            Some(ref entry) if entry.term == self.term =&gt; self.log.commit(quorum_index),
</a><a href="#h11-4-5" id="h11-4-5" class="d">-            _ =&gt; Ok(commit_index),
</a><a href="#h11-4-6" id="h11-4-6" class="i">+        let committed_index = match self.log.get(quorum_index)? {
</a><a href="#h11-4-7" id="h11-4-7" class="i">+            Some(entry) if entry.term == self.term =&gt; self.log.commit(quorum_index)?,
</a><a href="#h11-4-8" id="h11-4-8" class="i">+            _ =&gt; commit_index,
</a><a href="#h11-4-9" id="h11-4-9" class="i">+        };
</a><a href="#h11-4-10" id="h11-4-10" class="i">+        // FIXME Log should handle range scans
</a><a href="#h11-4-11" id="h11-4-11" class="i">+        for index in (commit_index + 1)..=committed_index {
</a><a href="#h11-4-12" id="h11-4-12" class="i">+            if let Some(entry) = self.log.get(index)? {
</a><a href="#h11-4-13" id="h11-4-13" class="i">+                self.state_tx.send(Instruction::Apply { entry })?
</a><a href="#h11-4-14" id="h11-4-14" class="i">+            }
</a>         }
<a href="#h11-4-16" id="h11-4-16" class="i">+        Ok(committed_index)
</a>     }
 
     /// Replicates the log to a peer.
<a href="#h11-5" id="h11-5" class="h">@@ -111,57 +94,46 @@ impl&lt;L: Storage, S: State&gt; RoleNode&lt;Leader, L, S&gt; {
</a>         };
         let entries = self.log.range(peer_next..)?;
         debug!(&quot;Replicating {} entries at base {} to {}&quot;, entries.len(), base_index, peer);
<a href="#h11-5-3" id="h11-5-3" class="d">-        self.send(Some(peer), Event::ReplicateEntries { base_index, base_term, entries })?;
</a><a href="#h11-5-4" id="h11-5-4" class="d">-        Ok(())
</a><a href="#h11-5-5" id="h11-5-5" class="d">-    }
</a><a href="#h11-5-6" id="h11-5-6" class="d">-
</a><a href="#h11-5-7" id="h11-5-7" class="d">-    /// Registers a vote for quorum-based client calls.
</a><a href="#h11-5-8" id="h11-5-8" class="d">-    fn vote_call(&amp;mut self, from: &amp;str, commit_index: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-5-9" id="h11-5-9" class="d">-        for call in self.role.calls.quorum_vote(from, commit_index) {
</a><a href="#h11-5-10" id="h11-5-10" class="d">-            match call.operation {
</a><a href="#h11-5-11" id="h11-5-11" class="d">-                Operation::ReadState { command, .. } =&gt; self.send(
</a><a href="#h11-5-12" id="h11-5-12" class="d">-                    call.from.as_deref(),
</a><a href="#h11-5-13" id="h11-5-13" class="d">-                    match self.state.query(command) {
</a><a href="#h11-5-14" id="h11-5-14" class="d">-                        Ok(response) =&gt; Event::RespondState { call_id: call.id, response },
</a><a href="#h11-5-15" id="h11-5-15" class="d">-                        Err(err) =&gt; Event::RespondError { call_id: call.id, error: err },
</a><a href="#h11-5-16" id="h11-5-16" class="d">-                    },
</a><a href="#h11-5-17" id="h11-5-17" class="d">-                )?,
</a><a href="#h11-5-18" id="h11-5-18" class="d">-                _ =&gt; return Err(Error::Internal(format!(&quot;Unsupported call {:?}&quot;, call))),
</a><a href="#h11-5-19" id="h11-5-19" class="d">-            }
</a><a href="#h11-5-20" id="h11-5-20" class="d">-        }
</a><a href="#h11-5-21" id="h11-5-21" class="i">+        self.send(
</a><a href="#h11-5-22" id="h11-5-22" class="i">+            Address::Peer(peer.to_string()),
</a><a href="#h11-5-23" id="h11-5-23" class="i">+            Event::ReplicateEntries { base_index, base_term, entries },
</a><a href="#h11-5-24" id="h11-5-24" class="i">+        )?;
</a>         Ok(())
     }
 
     /// Processes a message.
<a href="#h11-5-29" id="h11-5-29" class="d">-    pub fn step(mut self, mut msg: Message) -&gt; Result&lt;Node&lt;L, S&gt;, Error&gt; {
</a><a href="#h11-5-30" id="h11-5-30" class="d">-        if !self.normalize_message(&amp;mut msg) {
</a><a href="#h11-5-31" id="h11-5-31" class="i">+    pub fn step(mut self, msg: Message) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h11-5-32" id="h11-5-32" class="i">+        if let Err(err) = self.validate(&amp;msg) {
</a><a href="#h11-5-33" id="h11-5-33" class="i">+            warn!(&quot;Ignoring invalid message: {}&quot;, err);
</a>             return Ok(self.into());
         }
         if msg.term &gt; self.term {
<a href="#h11-5-37" id="h11-5-37" class="d">-            if let Some(from) = &amp;msg.from {
</a><a href="#h11-5-38" id="h11-5-38" class="i">+            if let Address::Peer(from) = &amp;msg.from {
</a>                 return self.become_follower(msg.term, from)?.step(msg);
             }
         }
 
         match msg.event {
             Event::ConfirmLeader { commit_index, has_committed } =&gt; {
<a href="#h11-5-45" id="h11-5-45" class="d">-                if let Some(from) = &amp;msg.from {
</a><a href="#h11-5-46" id="h11-5-46" class="d">-                    self.vote_call(from, commit_index)?;
</a><a href="#h11-5-47" id="h11-5-47" class="i">+                if let Address::Peer(from) = msg.from.clone() {
</a><a href="#h11-5-48" id="h11-5-48" class="i">+                    self.state_tx
</a><a href="#h11-5-49" id="h11-5-49" class="i">+                        .send(Instruction::Vote { index: commit_index, address: msg.from })?;
</a>                     if !has_committed {
<a href="#h11-5-51" id="h11-5-51" class="d">-                        self.replicate(from)?;
</a><a href="#h11-5-52" id="h11-5-52" class="i">+                        self.replicate(&amp;from)?;
</a>                     }
                 }
             }
<a href="#h11-5-56" id="h11-5-56" class="i">+
</a>             Event::AcceptEntries { last_index } =&gt; {
<a href="#h11-5-58" id="h11-5-58" class="d">-                if let Some(from) = msg.from {
</a><a href="#h11-5-59" id="h11-5-59" class="i">+                if let Address::Peer(from) = msg.from {
</a>                     self.role.peer_last_index.insert(from.clone(), last_index);
                     self.role.peer_next_index.insert(from, last_index + 1);
                 }
                 self.commit()?;
<a href="#h11-5-64" id="h11-5-64" class="d">-                self.apply()?;
</a>             }
<a href="#h11-5-66" id="h11-5-66" class="i">+
</a>             Event::RejectEntries =&gt; {
<a href="#h11-5-68" id="h11-5-68" class="d">-                if let Some(from) = msg.from {
</a><a href="#h11-5-69" id="h11-5-69" class="i">+                if let Address::Peer(from) = msg.from {
</a>                     self.role.peer_next_index.entry(from.clone()).and_modify(|i| {
                         if *i &gt; 1 {
                             *i -= 1
<a href="#h11-6" id="h11-6" class="h">@@ -170,149 +142,111 @@ impl&lt;L: Storage, S: State&gt; RoleNode&lt;Leader, L, S&gt; {
</a>                     self.replicate(&amp;from)?;
                 }
             }
<a href="#h11-6-3" id="h11-6-3" class="d">-            Event::QueryState { call_id, command } =&gt; {
</a><a href="#h11-6-4" id="h11-6-4" class="i">+
</a><a href="#h11-6-5" id="h11-6-5" class="i">+            Event::ClientRequest { id, request: Request::Query(command) } =&gt; {
</a><a href="#h11-6-6" id="h11-6-6" class="i">+                // FIXME This needs to wait until the first entry from out term has been
</a><a href="#h11-6-7" id="h11-6-7" class="i">+                // committed, see: https://stackoverflow.com/questions/37207682/raft-some-questions-about-read-only-queries
</a>                 let (commit_index, commit_term) = self.log.get_committed();
<a href="#h11-6-9" id="h11-6-9" class="d">-                self.role.calls.register(Call {
</a><a href="#h11-6-10" id="h11-6-10" class="d">-                    id: call_id,
</a><a href="#h11-6-11" id="h11-6-11" class="d">-                    from: msg.from,
</a><a href="#h11-6-12" id="h11-6-12" class="d">-                    operation: Operation::ReadState {
</a><a href="#h11-6-13" id="h11-6-13" class="d">-                        command,
</a><a href="#h11-6-14" id="h11-6-14" class="d">-                        commit_index,
</a><a href="#h11-6-15" id="h11-6-15" class="d">-                        quorum: self.quorum(),
</a><a href="#h11-6-16" id="h11-6-16" class="d">-                        votes: HashSet::new(),
</a><a href="#h11-6-17" id="h11-6-17" class="d">-                    },
</a><a href="#h11-6-18" id="h11-6-18" class="d">-                });
</a><a href="#h11-6-19" id="h11-6-19" class="d">-                self.vote_call(self.id.clone().as_ref(), commit_index)?;
</a><a href="#h11-6-20" id="h11-6-20" class="d">-                // Send heartbeats immediately, so we don&#39;t have to wait for the next tick
</a><a href="#h11-6-21" id="h11-6-21" class="d">-                self.broadcast(Event::Heartbeat { commit_index, commit_term })?;
</a><a href="#h11-6-22" id="h11-6-22" class="i">+                self.state_tx.send(Instruction::Query {
</a><a href="#h11-6-23" id="h11-6-23" class="i">+                    id,
</a><a href="#h11-6-24" id="h11-6-24" class="i">+                    address: msg.from,
</a><a href="#h11-6-25" id="h11-6-25" class="i">+                    command,
</a><a href="#h11-6-26" id="h11-6-26" class="i">+                    index: commit_index,
</a><a href="#h11-6-27" id="h11-6-27" class="i">+                    quorum: self.quorum(),
</a><a href="#h11-6-28" id="h11-6-28" class="i">+                })?;
</a><a href="#h11-6-29" id="h11-6-29" class="i">+                self.state_tx
</a><a href="#h11-6-30" id="h11-6-30" class="i">+                    .send(Instruction::Vote { index: commit_index, address: Address::Local })?;
</a><a href="#h11-6-31" id="h11-6-31" class="i">+                if !self.peers.is_empty() {
</a><a href="#h11-6-32" id="h11-6-32" class="i">+                    self.send(Address::Peers, Event::Heartbeat { commit_index, commit_term })?;
</a><a href="#h11-6-33" id="h11-6-33" class="i">+                }
</a>             }
<a href="#h11-6-35" id="h11-6-35" class="d">-            Event::MutateState { call_id, command } =&gt; {
</a><a href="#h11-6-36" id="h11-6-36" class="i">+
</a><a href="#h11-6-37" id="h11-6-37" class="i">+            Event::ClientRequest { id, request: Request::Mutate(command) } =&gt; {
</a>                 let index = self.append(Some(command))?;
<a href="#h11-6-39" id="h11-6-39" class="d">-                self.role.calls.register(Call {
</a><a href="#h11-6-40" id="h11-6-40" class="d">-                    id: call_id,
</a><a href="#h11-6-41" id="h11-6-41" class="d">-                    from: msg.from,
</a><a href="#h11-6-42" id="h11-6-42" class="d">-                    operation: Operation::MutateState { log_index: index },
</a><a href="#h11-6-43" id="h11-6-43" class="d">-                });
</a><a href="#h11-6-44" id="h11-6-44" class="i">+                self.state_tx.send(Instruction::Notify { id, address: msg.from, index })?;
</a>                 if self.peers.is_empty() {
                     self.commit()?;
<a href="#h11-6-47" id="h11-6-47" class="d">-                    self.apply()?;
</a>                 }
             }
<a href="#h11-6-50" id="h11-6-50" class="d">-            Event::Heartbeat { .. } =&gt; {}
</a><a href="#h11-6-51" id="h11-6-51" class="d">-            Event::SolicitVote { .. } =&gt; {}
</a><a href="#h11-6-52" id="h11-6-52" class="d">-            Event::GrantVote =&gt; {}
</a><a href="#h11-6-53" id="h11-6-53" class="d">-            Event::ReplicateEntries { .. } =&gt; {}
</a><a href="#h11-6-54" id="h11-6-54" class="d">-            // FIXME We may want to handle these
</a><a href="#h11-6-55" id="h11-6-55" class="d">-            Event::RespondState { .. } =&gt; {}
</a><a href="#h11-6-56" id="h11-6-56" class="d">-            Event::RespondError { .. } =&gt; {}
</a><a href="#h11-6-57" id="h11-6-57" class="d">-        }
</a> 
<a href="#h11-6-59" id="h11-6-59" class="d">-        Ok(self.into())
</a><a href="#h11-6-60" id="h11-6-60" class="d">-    }
</a><a href="#h11-6-61" id="h11-6-61" class="d">-
</a><a href="#h11-6-62" id="h11-6-62" class="d">-    /// Processes a logical clock tick.
</a><a href="#h11-6-63" id="h11-6-63" class="d">-    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L, S&gt;, Error&gt; {
</a><a href="#h11-6-64" id="h11-6-64" class="d">-        self.apply()?;
</a><a href="#h11-6-65" id="h11-6-65" class="d">-        self.role.heartbeat_ticks += 1;
</a><a href="#h11-6-66" id="h11-6-66" class="d">-        if self.role.heartbeat_ticks &gt;= HEARTBEAT_INTERVAL {
</a><a href="#h11-6-67" id="h11-6-67" class="d">-            self.role.heartbeat_ticks = 0;
</a><a href="#h11-6-68" id="h11-6-68" class="d">-            let (commit_index, commit_term) = self.log.get_committed();
</a><a href="#h11-6-69" id="h11-6-69" class="d">-            self.broadcast(Event::Heartbeat { commit_index, commit_term })?;
</a><a href="#h11-6-70" id="h11-6-70" class="d">-        }
</a><a href="#h11-6-71" id="h11-6-71" class="d">-        Ok(self.into())
</a><a href="#h11-6-72" id="h11-6-72" class="d">-    }
</a><a href="#h11-6-73" id="h11-6-73" class="d">-}
</a><a href="#h11-6-74" id="h11-6-74" class="d">-
</a><a href="#h11-6-75" id="h11-6-75" class="d">-/// A client call processed by the leader.
</a><a href="#h11-6-76" id="h11-6-76" class="d">-#[derive(Clone, Debug, PartialEq)]
</a><a href="#h11-6-77" id="h11-6-77" class="d">-struct Call {
</a><a href="#h11-6-78" id="h11-6-78" class="d">-    id: Vec&lt;u8&gt;,
</a><a href="#h11-6-79" id="h11-6-79" class="d">-    from: Option&lt;String&gt;,
</a><a href="#h11-6-80" id="h11-6-80" class="d">-    operation: Operation,
</a><a href="#h11-6-81" id="h11-6-81" class="d">-}
</a><a href="#h11-6-82" id="h11-6-82" class="d">-
</a><a href="#h11-6-83" id="h11-6-83" class="d">-/// An operation performed by a call.
</a><a href="#h11-6-84" id="h11-6-84" class="d">-#[derive(Clone, Debug, PartialEq)]
</a><a href="#h11-6-85" id="h11-6-85" class="d">-enum Operation {
</a><a href="#h11-6-86" id="h11-6-86" class="d">-    /// A mutation submitted to the Raft log.
</a><a href="#h11-6-87" id="h11-6-87" class="d">-    MutateState { log_index: u64 },
</a><a href="#h11-6-88" id="h11-6-88" class="d">-    /// A state machine read requiring a quorum.
</a><a href="#h11-6-89" id="h11-6-89" class="d">-    ReadState { command: Vec&lt;u8&gt;, commit_index: u64, quorum: u64, votes: HashSet&lt;String&gt; },
</a><a href="#h11-6-90" id="h11-6-90" class="d">-}
</a><a href="#h11-6-91" id="h11-6-91" class="i">+            Event::ClientRequest { id, request: Request::Status } =&gt; {
</a><a href="#h11-6-92" id="h11-6-92" class="i">+                self.state_tx.send(Instruction::Status {
</a><a href="#h11-6-93" id="h11-6-93" class="i">+                    id,
</a><a href="#h11-6-94" id="h11-6-94" class="i">+                    address: msg.from,
</a><a href="#h11-6-95" id="h11-6-95" class="i">+                    status: Status {
</a><a href="#h11-6-96" id="h11-6-96" class="i">+                        id: self.id.clone(),
</a><a href="#h11-6-97" id="h11-6-97" class="i">+                        role: &quot;leader&quot;.into(),
</a><a href="#h11-6-98" id="h11-6-98" class="i">+                        leader: self.id.clone(),
</a><a href="#h11-6-99" id="h11-6-99" class="i">+                        nodes: self.peers.len() as u64 + 1,
</a><a href="#h11-6-100" id="h11-6-100" class="i">+                        term: self.term,
</a><a href="#h11-6-101" id="h11-6-101" class="i">+                        entries: self.log.get_last().0,
</a><a href="#h11-6-102" id="h11-6-102" class="i">+                        committed: self.log.get_committed().0,
</a><a href="#h11-6-103" id="h11-6-103" class="i">+                        applied: 0,
</a><a href="#h11-6-104" id="h11-6-104" class="i">+                    },
</a><a href="#h11-6-105" id="h11-6-105" class="i">+                })?
</a><a href="#h11-6-106" id="h11-6-106" class="i">+            }
</a> 
<a href="#h11-6-108" id="h11-6-108" class="d">-/// A set of calls
</a><a href="#h11-6-109" id="h11-6-109" class="d">-#[derive(Clone, Debug)]
</a><a href="#h11-6-110" id="h11-6-110" class="d">-struct Calls {
</a><a href="#h11-6-111" id="h11-6-111" class="d">-    calls: Vec&lt;Call&gt;,
</a><a href="#h11-6-112" id="h11-6-112" class="d">-}
</a><a href="#h11-6-113" id="h11-6-113" class="i">+            Event::ClientResponse { id, mut response } =&gt; {
</a><a href="#h11-6-114" id="h11-6-114" class="i">+                if let Ok(Response::Status(ref mut status)) = response {
</a><a href="#h11-6-115" id="h11-6-115" class="i">+                    status.id = self.id.clone();
</a><a href="#h11-6-116" id="h11-6-116" class="i">+                    status.role = &quot;leader&quot;.into();
</a><a href="#h11-6-117" id="h11-6-117" class="i">+                }
</a><a href="#h11-6-118" id="h11-6-118" class="i">+                self.send(Address::Client, Event::ClientResponse { id, response })?;
</a><a href="#h11-6-119" id="h11-6-119" class="i">+            }
</a> 
<a href="#h11-6-121" id="h11-6-121" class="d">-impl Calls {
</a><a href="#h11-6-122" id="h11-6-122" class="d">-    /// Creates a new Calls
</a><a href="#h11-6-123" id="h11-6-123" class="d">-    fn new() -&gt; Self {
</a><a href="#h11-6-124" id="h11-6-124" class="d">-        Self { calls: Vec::new() }
</a><a href="#h11-6-125" id="h11-6-125" class="d">-    }
</a><a href="#h11-6-126" id="h11-6-126" class="i">+            // We ignore these messages, since they are typically additional votes from the previous
</a><a href="#h11-6-127" id="h11-6-127" class="i">+            // election that we won after a quorum.
</a><a href="#h11-6-128" id="h11-6-128" class="i">+            Event::SolicitVote { .. } | Event::GrantVote =&gt; {}
</a> 
<a href="#h11-6-130" id="h11-6-130" class="d">-    /// Registers a call
</a><a href="#h11-6-131" id="h11-6-131" class="d">-    fn register(&amp;mut self, call: Call) {
</a><a href="#h11-6-132" id="h11-6-132" class="d">-        self.calls.push(call);
</a><a href="#h11-6-133" id="h11-6-133" class="d">-    }
</a><a href="#h11-6-134" id="h11-6-134" class="i">+            Event::Heartbeat { .. } | Event::ReplicateEntries { .. } =&gt; {
</a><a href="#h11-6-135" id="h11-6-135" class="i">+                warn!(&quot;Received unexpected message {:?}&quot;, msg)
</a><a href="#h11-6-136" id="h11-6-136" class="i">+            }
</a><a href="#h11-6-137" id="h11-6-137" class="i">+        }
</a> 
<a href="#h11-6-139" id="h11-6-139" class="d">-    /// Signals application of the log entry with the given index, removes and
</a><a href="#h11-6-140" id="h11-6-140" class="d">-    /// returns the call tracking the entry (if any).
</a><a href="#h11-6-141" id="h11-6-141" class="d">-    fn log_applied(&amp;mut self, index: u64) -&gt; Option&lt;Call&gt; {
</a><a href="#h11-6-142" id="h11-6-142" class="d">-        self.calls
</a><a href="#h11-6-143" id="h11-6-143" class="d">-            .iter()
</a><a href="#h11-6-144" id="h11-6-144" class="d">-            .position(|call| match call.operation {
</a><a href="#h11-6-145" id="h11-6-145" class="d">-                Operation::MutateState { log_index } =&gt; log_index == index,
</a><a href="#h11-6-146" id="h11-6-146" class="d">-                Operation::ReadState { .. } =&gt; false,
</a><a href="#h11-6-147" id="h11-6-147" class="d">-            })
</a><a href="#h11-6-148" id="h11-6-148" class="d">-            .map(|i| self.calls.remove(i))
</a><a href="#h11-6-149" id="h11-6-149" class="i">+        Ok(self.into())
</a>     }
 
<a href="#h11-6-152" id="h11-6-152" class="d">-    /// Signals a leadership vote by a peer for a given commit index, removes and
</a><a href="#h11-6-153" id="h11-6-153" class="d">-    /// returns any calls which have received votes from a quorum.
</a><a href="#h11-6-154" id="h11-6-154" class="d">-    fn quorum_vote(&amp;mut self, voter: &amp;str, index: u64) -&gt; Vec&lt;Call&gt; {
</a><a href="#h11-6-155" id="h11-6-155" class="d">-        let mut indexes = Vec::new();
</a><a href="#h11-6-156" id="h11-6-156" class="d">-        for (i, call) in self.calls.iter_mut().enumerate() {
</a><a href="#h11-6-157" id="h11-6-157" class="d">-            match call.operation {
</a><a href="#h11-6-158" id="h11-6-158" class="d">-                Operation::MutateState { .. } =&gt; {}
</a><a href="#h11-6-159" id="h11-6-159" class="d">-                Operation::ReadState { commit_index, ref mut votes, quorum, .. } =&gt; {
</a><a href="#h11-6-160" id="h11-6-160" class="d">-                    if index &gt;= commit_index {
</a><a href="#h11-6-161" id="h11-6-161" class="d">-                        votes.insert(voter.to_owned());
</a><a href="#h11-6-162" id="h11-6-162" class="d">-                        if votes.len() as u64 &gt;= quorum {
</a><a href="#h11-6-163" id="h11-6-163" class="d">-                            indexes.push(i)
</a><a href="#h11-6-164" id="h11-6-164" class="d">-                        }
</a><a href="#h11-6-165" id="h11-6-165" class="d">-                    }
</a><a href="#h11-6-166" id="h11-6-166" class="d">-                }
</a><a href="#h11-6-167" id="h11-6-167" class="i">+    /// Processes a logical clock tick.
</a><a href="#h11-6-168" id="h11-6-168" class="i">+    pub fn tick(mut self) -&gt; Result&lt;Node&lt;L&gt;, Error&gt; {
</a><a href="#h11-6-169" id="h11-6-169" class="i">+        if !self.peers.is_empty() {
</a><a href="#h11-6-170" id="h11-6-170" class="i">+            self.role.heartbeat_ticks += 1;
</a><a href="#h11-6-171" id="h11-6-171" class="i">+            if self.role.heartbeat_ticks &gt;= HEARTBEAT_INTERVAL {
</a><a href="#h11-6-172" id="h11-6-172" class="i">+                self.role.heartbeat_ticks = 0;
</a><a href="#h11-6-173" id="h11-6-173" class="i">+                let (commit_index, commit_term) = self.log.get_committed();
</a><a href="#h11-6-174" id="h11-6-174" class="i">+                self.send(Address::Peers, Event::Heartbeat { commit_index, commit_term })?;
</a>             }
         }
<a href="#h11-6-177" id="h11-6-177" class="d">-        indexes.into_iter().enumerate().map(|(j, i)| self.calls.remove(i - j)).collect()
</a><a href="#h11-6-178" id="h11-6-178" class="i">+        Ok(self.into())
</a>     }
 }
 
 #[cfg(test)]
 mod tests {
     use super::super::super::{Entry, Log};
<a href="#h11-6-185" id="h11-6-185" class="d">-    use super::super::tests::{assert_messages, assert_node, TestState};
</a><a href="#h11-6-186" id="h11-6-186" class="i">+    use super::super::tests::{assert_messages, assert_node};
</a>     use super::*;
     use crate::kv;
<a href="#h11-6-189" id="h11-6-189" class="i">+    use pretty_assertions::assert_eq;
</a>     use tokio::sync::mpsc;
 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;
<a href="#h11-6-194" id="h11-6-194" class="d">-        (RoleNode&lt;Leader, kv::storage::Test, TestState&gt;, mpsc::UnboundedReceiver&lt;Message&gt;),
</a><a href="#h11-6-195" id="h11-6-195" class="i">+        (
</a><a href="#h11-6-196" id="h11-6-196" class="i">+            RoleNode&lt;Leader, kv::storage::Test&gt;,
</a><a href="#h11-6-197" id="h11-6-197" class="i">+            mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h11-6-198" id="h11-6-198" class="i">+            mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h11-6-199" id="h11-6-199" class="i">+        ),
</a>         Error,
     &gt; {
<a href="#h11-6-202" id="h11-6-202" class="d">-        let (sender, receiver) = mpsc::unbounded_channel();
</a><a href="#h11-6-203" id="h11-6-203" class="d">-        let mut state = TestState::new();
</a><a href="#h11-6-204" id="h11-6-204" class="i">+        let (node_tx, node_rx) = mpsc::unbounded_channel();
</a><a href="#h11-6-205" id="h11-6-205" class="i">+        let (state_tx, state_rx) = mpsc::unbounded_channel();
</a>         let mut log = Log::new(kv::Simple::new(kv::storage::Test::new()))?;
<a href="#h11-6-207" id="h11-6-207" class="d">-        log.append(Entry { term: 1, command: Some(vec![0x01]) })?;
</a><a href="#h11-6-208" id="h11-6-208" class="d">-        log.append(Entry { term: 1, command: Some(vec![0x02]) })?;
</a><a href="#h11-6-209" id="h11-6-209" class="d">-        log.append(Entry { term: 2, command: Some(vec![0x03]) })?;
</a><a href="#h11-6-210" id="h11-6-210" class="d">-        log.append(Entry { term: 3, command: Some(vec![0x04]) })?;
</a><a href="#h11-6-211" id="h11-6-211" class="d">-        log.append(Entry { term: 3, command: Some(vec![0x05]) })?;
</a><a href="#h11-6-212" id="h11-6-212" class="i">+        log.append(1, Some(vec![0x01]))?;
</a><a href="#h11-6-213" id="h11-6-213" class="i">+        log.append(1, Some(vec![0x02]))?;
</a><a href="#h11-6-214" id="h11-6-214" class="i">+        log.append(2, Some(vec![0x03]))?;
</a><a href="#h11-6-215" id="h11-6-215" class="i">+        log.append(3, Some(vec![0x04]))?;
</a><a href="#h11-6-216" id="h11-6-216" class="i">+        log.append(3, Some(vec![0x05]))?;
</a>         log.commit(2)?;
<a href="#h11-6-218" id="h11-6-218" class="d">-        log.apply(&amp;mut state)?;
</a> 
         let peers = vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()];
         let (last_index, _) = log.get_last();
<a href="#h11-7" id="h11-7" class="h">@@ -322,146 +256,177 @@ mod tests {
</a>             peers: peers.clone(),
             term: 3,
             log,
<a href="#h11-7-3" id="h11-7-3" class="d">-            state,
</a><a href="#h11-7-4" id="h11-7-4" class="d">-            sender,
</a><a href="#h11-7-5" id="h11-7-5" class="i">+            node_tx,
</a><a href="#h11-7-6" id="h11-7-6" class="i">+            state_tx,
</a><a href="#h11-7-7" id="h11-7-7" class="i">+            proxied_reqs: HashMap::new(),
</a><a href="#h11-7-8" id="h11-7-8" class="i">+            queued_reqs: Vec::new(),
</a>             role: Leader::new(peers, last_index),
         };
         node.save_term(3, None)?;
<a href="#h11-7-12" id="h11-7-12" class="d">-        Ok((node, receiver))
</a><a href="#h11-7-13" id="h11-7-13" class="i">+        Ok((node, node_rx, state_rx))
</a>     }
 
     #[test]
<a href="#h11-7-17" id="h11-7-17" class="d">-    // ConfirmLeader with has_committed has no effect without any calls
</a><a href="#h11-7-18" id="h11-7-18" class="d">-    fn step_confirmleader() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-7-19" id="h11-7-19" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-7-20" id="h11-7-20" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-7-21" id="h11-7-21" class="i">+    // ConfirmLeader triggers vote
</a><a href="#h11-7-22" id="h11-7-22" class="i">+    fn step_confirmleader_vote() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-7-23" id="h11-7-23" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-7-24" id="h11-7-24" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         node = node.step(Message {
<a href="#h11-7-27" id="h11-7-27" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h11-7-28" id="h11-7-28" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-29" id="h11-7-29" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h11-7-30" id="h11-7-30" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ConfirmLeader { commit_index: 2, has_committed: true },
         })?;
<a href="#h11-7-34" id="h11-7-34" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2).applied(1);
</a><a href="#h11-7-35" id="h11-7-35" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-7-36" id="h11-7-36" class="i">+        assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h11-7-37" id="h11-7-37" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-7-38" id="h11-7-38" class="i">+        assert_messages(
</a><a href="#h11-7-39" id="h11-7-39" class="i">+            &amp;mut state_rx,
</a><a href="#h11-7-40" id="h11-7-40" class="i">+            vec![Instruction::Vote { index: 2, address: Address::Peer(&quot;b&quot;.into()) }],
</a><a href="#h11-7-41" id="h11-7-41" class="i">+        );
</a>         Ok(())
     }
 
     #[test]
     // ConfirmLeader without has_committed triggers replication
<a href="#h11-7-47" id="h11-7-47" class="d">-    fn step_confirmleader_without_has_committed() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-7-48" id="h11-7-48" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-7-49" id="h11-7-49" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-7-50" id="h11-7-50" class="i">+    fn step_confirmleader_replicate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-7-51" id="h11-7-51" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-7-52" id="h11-7-52" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         node = node.step(Message {
<a href="#h11-7-55" id="h11-7-55" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h11-7-56" id="h11-7-56" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-57" id="h11-7-57" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h11-7-58" id="h11-7-58" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::ConfirmLeader { commit_index: 2, has_committed: false },
         })?;
<a href="#h11-7-62" id="h11-7-62" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2).applied(1);
</a><a href="#h11-7-63" id="h11-7-63" class="i">+        assert_node(&amp;node).is_leader().term(3).committed(2);
</a>         assert_messages(
<a href="#h11-7-65" id="h11-7-65" class="d">-            &amp;mut rx,
</a><a href="#h11-7-66" id="h11-7-66" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h11-7-68" id="h11-7-68" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-69" id="h11-7-69" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h11-7-70" id="h11-7-70" class="i">+                from: Address::Local,
</a><a href="#h11-7-71" id="h11-7-71" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 3,
                 event: Event::ReplicateEntries { base_index: 5, base_term: 3, entries: vec![] },
             }],
         );
<a href="#h11-7-76" id="h11-7-76" class="i">+        assert_messages(
</a><a href="#h11-7-77" id="h11-7-77" class="i">+            &amp;mut state_rx,
</a><a href="#h11-7-78" id="h11-7-78" class="i">+            vec![Instruction::Vote { index: 2, address: Address::Peer(&quot;b&quot;.into()) }],
</a><a href="#h11-7-79" id="h11-7-79" class="i">+        );
</a>         Ok(())
     }
 
     #[test]
     // Heartbeats from other leaders in current term are ignored.
     fn step_heartbeat_current_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-7-86" id="h11-7-86" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-7-87" id="h11-7-87" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-7-88" id="h11-7-88" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-7-89" id="h11-7-89" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         node = node.step(Message {
<a href="#h11-7-92" id="h11-7-92" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h11-7-93" id="h11-7-93" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-94" id="h11-7-94" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h11-7-95" id="h11-7-95" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::Heartbeat { commit_index: 5, commit_term: 3 },
         })?;
<a href="#h11-7-99" id="h11-7-99" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2).applied(1);
</a><a href="#h11-7-100" id="h11-7-100" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-7-101" id="h11-7-101" class="i">+        assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h11-7-102" id="h11-7-102" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-7-103" id="h11-7-103" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     // Heartbeats from other leaders in future term converts to follower and steps.
     fn step_heartbeat_future_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-7-110" id="h11-7-110" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-7-111" id="h11-7-111" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-7-112" id="h11-7-112" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-7-113" id="h11-7-113" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         node = node.step(Message {
<a href="#h11-7-116" id="h11-7-116" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h11-7-117" id="h11-7-117" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-118" id="h11-7-118" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h11-7-119" id="h11-7-119" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 4,
             event: Event::Heartbeat { commit_index: 7, commit_term: 4 },
         })?;
<a href="#h11-7-123" id="h11-7-123" class="d">-        assert_node(&amp;node).is_follower().term(4).leader(Some(&quot;b&quot;)).committed(2).applied(1);
</a><a href="#h11-7-124" id="h11-7-124" class="i">+        assert_node(&amp;node).is_follower().term(4).leader(Some(&quot;b&quot;)).committed(2);
</a>         assert_messages(
<a href="#h11-7-126" id="h11-7-126" class="d">-            &amp;mut rx,
</a><a href="#h11-7-127" id="h11-7-127" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h11-7-129" id="h11-7-129" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-130" id="h11-7-130" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h11-7-131" id="h11-7-131" class="i">+                from: Address::Local,
</a><a href="#h11-7-132" id="h11-7-132" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 4,
                 event: Event::ConfirmLeader { commit_index: 7, has_committed: false },
             }],
         );
<a href="#h11-7-137" id="h11-7-137" class="i">+        assert_messages(&amp;mut state_rx, vec![Instruction::Abort]);
</a>         Ok(())
     }
 
     #[test]
     // Heartbeats from other leaders in past terms are ignored.
     fn step_heartbeat_past_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-7-144" id="h11-7-144" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-7-145" id="h11-7-145" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-7-146" id="h11-7-146" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-7-147" id="h11-7-147" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         node = node.step(Message {
<a href="#h11-7-150" id="h11-7-150" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h11-7-151" id="h11-7-151" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-152" id="h11-7-152" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h11-7-153" id="h11-7-153" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 2,
             event: Event::Heartbeat { commit_index: 3, commit_term: 2 },
         })?;
<a href="#h11-7-157" id="h11-7-157" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(2).applied(1);
</a><a href="#h11-7-158" id="h11-7-158" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-7-159" id="h11-7-159" class="i">+        assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h11-7-160" id="h11-7-160" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-7-161" id="h11-7-161" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a>         Ok(())
     }
 
     #[test]
     fn step_acceptentries() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-7-167" id="h11-7-167" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-7-168" id="h11-7-168" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-7-169" id="h11-7-169" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-7-170" id="h11-7-170" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         node = node.step(Message {
<a href="#h11-7-173" id="h11-7-173" class="d">-            from: Some(&quot;b&quot;.into()),
</a><a href="#h11-7-174" id="h11-7-174" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-175" id="h11-7-175" class="i">+            from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h11-7-176" id="h11-7-176" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::AcceptEntries { last_index: 4 },
         })?;
<a href="#h11-7-180" id="h11-7-180" class="d">-        assert_node(&amp;node).committed(2).applied(2);
</a><a href="#h11-7-181" id="h11-7-181" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-7-182" id="h11-7-182" class="i">+        assert_node(&amp;node).committed(2);
</a><a href="#h11-7-183" id="h11-7-183" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-7-184" id="h11-7-184" class="i">+        assert_messages(&amp;mut state_rx, vec![]);
</a> 
         node = node.step(Message {
<a href="#h11-7-187" id="h11-7-187" class="d">-            from: Some(&quot;c&quot;.into()),
</a><a href="#h11-7-188" id="h11-7-188" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-189" id="h11-7-189" class="i">+            from: Address::Peer(&quot;c&quot;.into()),
</a><a href="#h11-7-190" id="h11-7-190" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::AcceptEntries { last_index: 5 },
         })?;
<a href="#h11-7-194" id="h11-7-194" class="d">-        assert_node(&amp;node).committed(4).applied(4);
</a><a href="#h11-7-195" id="h11-7-195" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-7-196" id="h11-7-196" class="i">+        assert_node(&amp;node).committed(4);
</a><a href="#h11-7-197" id="h11-7-197" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-7-198" id="h11-7-198" class="i">+        assert_messages(
</a><a href="#h11-7-199" id="h11-7-199" class="i">+            &amp;mut state_rx,
</a><a href="#h11-7-200" id="h11-7-200" class="i">+            vec![
</a><a href="#h11-7-201" id="h11-7-201" class="i">+                Instruction::Apply {
</a><a href="#h11-7-202" id="h11-7-202" class="i">+                    entry: Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h11-7-203" id="h11-7-203" class="i">+                },
</a><a href="#h11-7-204" id="h11-7-204" class="i">+                Instruction::Apply {
</a><a href="#h11-7-205" id="h11-7-205" class="i">+                    entry: Entry { index: 4, term: 3, command: Some(vec![0x04]) },
</a><a href="#h11-7-206" id="h11-7-206" class="i">+                },
</a><a href="#h11-7-207" id="h11-7-207" class="i">+            ],
</a><a href="#h11-7-208" id="h11-7-208" class="i">+        );
</a> 
         node = node.step(Message {
<a href="#h11-7-211" id="h11-7-211" class="d">-            from: Some(&quot;d&quot;.into()),
</a><a href="#h11-7-212" id="h11-7-212" class="d">-            to: Some(&quot;a&quot;.into()),
</a><a href="#h11-7-213" id="h11-7-213" class="i">+            from: Address::Peer(&quot;d&quot;.into()),
</a><a href="#h11-7-214" id="h11-7-214" class="i">+            to: Address::Peer(&quot;a&quot;.into()),
</a>             term: 3,
             event: Event::AcceptEntries { last_index: 5 },
         })?;
<a href="#h11-7-218" id="h11-7-218" class="d">-        assert_node(&amp;node).committed(5).applied(5);
</a><a href="#h11-7-219" id="h11-7-219" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-7-220" id="h11-7-220" class="i">+        assert_node(&amp;node).committed(5);
</a><a href="#h11-7-221" id="h11-7-221" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-7-222" id="h11-7-222" class="i">+        assert_messages(
</a><a href="#h11-7-223" id="h11-7-223" class="i">+            &amp;mut state_rx,
</a><a href="#h11-7-224" id="h11-7-224" class="i">+            vec![Instruction::Apply {
</a><a href="#h11-7-225" id="h11-7-225" class="i">+                entry: Entry { index: 5, term: 3, command: Some(vec![0x05]) },
</a><a href="#h11-7-226" id="h11-7-226" class="i">+            }],
</a><a href="#h11-7-227" id="h11-7-227" class="i">+        );
</a> 
         assert_node(&amp;node).is_leader().term(3);
         Ok(())
<a href="#h11-8" id="h11-8" class="h">@@ -470,18 +435,19 @@ mod tests {
</a>     #[test]
     // Duplicate AcceptEntries from single node should not trigger commit.
     fn step_acceptentries_duplicate() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-8-3" id="h11-8-3" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-8-4" id="h11-8-4" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-8-5" id="h11-8-5" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-8-6" id="h11-8-6" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         for _ in 0..5 {
             node = node.step(Message {
<a href="#h11-8-10" id="h11-8-10" class="d">-                from: Some(&quot;b&quot;.into()),
</a><a href="#h11-8-11" id="h11-8-11" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-8-12" id="h11-8-12" class="i">+                from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h11-8-13" id="h11-8-13" class="i">+                to: Address::Peer(&quot;a&quot;.into()),
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 5 },
             })?;
<a href="#h11-8-17" id="h11-8-17" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(2).applied(2);
</a><a href="#h11-8-18" id="h11-8-18" class="d">-            assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-8-19" id="h11-8-19" class="i">+            assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h11-8-20" id="h11-8-20" class="i">+            assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-8-21" id="h11-8-21" class="i">+            assert_messages(&amp;mut state_rx, vec![]);
</a>         }
         Ok(())
     }
<a href="#h11-9" id="h11-9" class="h">@@ -489,19 +455,20 @@ mod tests {
</a>     #[test]
     // AcceptEntries quorum for entry in past term should not trigger commit
     fn step_acceptentries_past_term() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-9-3" id="h11-9-3" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-9-4" id="h11-9-4" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a>         let peers = leader.peers.clone();
<a href="#h11-9-6" id="h11-9-6" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-9-7" id="h11-9-7" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         for peer in peers.into_iter() {
             node = node.step(Message {
<a href="#h11-9-11" id="h11-9-11" class="d">-                from: Some(peer),
</a><a href="#h11-9-12" id="h11-9-12" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-9-13" id="h11-9-13" class="i">+                from: Address::Peer(peer),
</a><a href="#h11-9-14" id="h11-9-14" class="i">+                to: Address::Peer(&quot;a&quot;.into()),
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 3 },
             })?;
<a href="#h11-9-18" id="h11-9-18" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(2).applied(2);
</a><a href="#h11-9-19" id="h11-9-19" class="d">-            assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-9-20" id="h11-9-20" class="i">+            assert_node(&amp;node).is_leader().term(3).committed(2);
</a><a href="#h11-9-21" id="h11-9-21" class="i">+            assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-9-22" id="h11-9-22" class="i">+            assert_messages(&amp;mut state_rx, vec![]);
</a>         }
         Ok(())
     }
<a href="#h11-10" id="h11-10" class="h">@@ -509,48 +476,65 @@ mod tests {
</a>     #[test]
     // AcceptEntries quorum for missing future entry
     fn step_acceptentries_future_index() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-10-3" id="h11-10-3" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-10-4" id="h11-10-4" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a>         let peers = leader.peers.clone();
<a href="#h11-10-6" id="h11-10-6" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-10-7" id="h11-10-7" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         for (i, peer) in peers.into_iter().enumerate() {
             node = node.step(Message {
<a href="#h11-10-11" id="h11-10-11" class="d">-                from: Some(peer),
</a><a href="#h11-10-12" id="h11-10-12" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-10-13" id="h11-10-13" class="i">+                from: Address::Peer(peer),
</a><a href="#h11-10-14" id="h11-10-14" class="i">+                to: Address::Peer(&quot;a&quot;.into()),
</a>                 term: 3,
                 event: Event::AcceptEntries { last_index: 7 },
             })?;
<a href="#h11-10-18" id="h11-10-18" class="d">-            // The local leader will cast a vote to commit 5, thus
</a><a href="#h11-10-19" id="h11-10-19" class="d">-            // when we have votes 2x7, 1x5, 2x0 we will commit index 5.
</a><a href="#h11-10-20" id="h11-10-20" class="d">-            // However, we will correctly ignore the following votes for 7.
</a><a href="#h11-10-21" id="h11-10-21" class="i">+            // The local leader will cast a vote to commit 5, thus when we have votes 2x7, 1x5, 2x0
</a><a href="#h11-10-22" id="h11-10-22" class="i">+            // we will commit index 5. However, we will correctly ignore the following votes for7.
</a>             let c = if i == 0 { 2 } else { 5 };
<a href="#h11-10-24" id="h11-10-24" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(c).applied(c).last(5);
</a><a href="#h11-10-25" id="h11-10-25" class="d">-            assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-10-26" id="h11-10-26" class="i">+            assert_node(&amp;node).is_leader().term(3).committed(c).last(5);
</a><a href="#h11-10-27" id="h11-10-27" class="i">+            assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-10-28" id="h11-10-28" class="i">+            if i == 1 {
</a><a href="#h11-10-29" id="h11-10-29" class="i">+                assert_messages(
</a><a href="#h11-10-30" id="h11-10-30" class="i">+                    &amp;mut state_rx,
</a><a href="#h11-10-31" id="h11-10-31" class="i">+                    vec![
</a><a href="#h11-10-32" id="h11-10-32" class="i">+                        Instruction::Apply {
</a><a href="#h11-10-33" id="h11-10-33" class="i">+                            entry: Entry { index: 3, term: 2, command: Some(vec![0x03]) },
</a><a href="#h11-10-34" id="h11-10-34" class="i">+                        },
</a><a href="#h11-10-35" id="h11-10-35" class="i">+                        Instruction::Apply {
</a><a href="#h11-10-36" id="h11-10-36" class="i">+                            entry: Entry { index: 4, term: 3, command: Some(vec![0x04]) },
</a><a href="#h11-10-37" id="h11-10-37" class="i">+                        },
</a><a href="#h11-10-38" id="h11-10-38" class="i">+                        Instruction::Apply {
</a><a href="#h11-10-39" id="h11-10-39" class="i">+                            entry: Entry { index: 5, term: 3, command: Some(vec![0x05]) },
</a><a href="#h11-10-40" id="h11-10-40" class="i">+                        },
</a><a href="#h11-10-41" id="h11-10-41" class="i">+                    ],
</a><a href="#h11-10-42" id="h11-10-42" class="i">+                );
</a><a href="#h11-10-43" id="h11-10-43" class="i">+            } else {
</a><a href="#h11-10-44" id="h11-10-44" class="i">+                assert_messages(&amp;mut state_rx, vec![]);
</a><a href="#h11-10-45" id="h11-10-45" class="i">+            }
</a>         }
         Ok(())
     }
 
     #[test]
     fn step_rejectentries() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-10-52" id="h11-10-52" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-10-53" id="h11-10-53" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a>         let entries = leader.log.range(0..)?;
<a href="#h11-10-55" id="h11-10-55" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-10-56" id="h11-10-56" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
         for i in 0..(entries.len() + 3) {
             node = node.step(Message {
<a href="#h11-10-60" id="h11-10-60" class="d">-                from: Some(&quot;b&quot;.into()),
</a><a href="#h11-10-61" id="h11-10-61" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-10-62" id="h11-10-62" class="i">+                from: Address::Peer(&quot;b&quot;.into()),
</a><a href="#h11-10-63" id="h11-10-63" class="i">+                to: Address::Peer(&quot;a&quot;.into()),
</a>                 term: 3,
                 event: Event::RejectEntries,
             })?;
<a href="#h11-10-67" id="h11-10-67" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(2).applied(1);
</a><a href="#h11-10-68" id="h11-10-68" class="i">+            assert_node(&amp;node).is_leader().term(3).committed(2);
</a>             let index = if i &gt;= entries.len() { 0 } else { entries.len() - i - 1 };
             let replicate = entries.get(index..).unwrap().to_vec();
             assert_messages(
<a href="#h11-10-72" id="h11-10-72" class="d">-                &amp;mut rx,
</a><a href="#h11-10-73" id="h11-10-73" class="i">+                &amp;mut node_rx,
</a>                 vec![Message {
<a href="#h11-10-75" id="h11-10-75" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h11-10-76" id="h11-10-76" class="d">-                    to: Some(&quot;b&quot;.into()),
</a><a href="#h11-10-77" id="h11-10-77" class="i">+                    from: Address::Local,
</a><a href="#h11-10-78" id="h11-10-78" class="i">+                    to: Address::Peer(&quot;b&quot;.into()),
</a>                     term: 3,
                     event: Event::ReplicateEntries {
                         base_index: index as u64,
<a href="#h11-11" id="h11-11" class="h">@@ -563,306 +547,147 @@ mod tests {
</a>                     },
                 }],
             );
<a href="#h11-11-3" id="h11-11-3" class="i">+            assert_messages(&amp;mut state_rx, vec![]);
</a>         }
         Ok(())
     }
 
     #[test]
<a href="#h11-11-9" id="h11-11-9" class="d">-    fn step_mutatestate_readstate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-10" id="h11-11-10" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-11-11" id="h11-11-11" class="d">-        let peers = leader.peers.clone();
</a><a href="#h11-11-12" id="h11-11-12" class="i">+    // Sending a client query request will pass it to the state machine and trigger heartbeats.
</a><a href="#h11-11-13" id="h11-11-13" class="i">+    fn step_clientrequest_query() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-14" id="h11-11-14" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a>         let quorum = leader.quorum();
<a href="#h11-11-16" id="h11-11-16" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-11-17" id="h11-11-17" class="d">-
</a><a href="#h11-11-18" id="h11-11-18" class="d">-        // Submit the mutate call from local sender, and observe it being
</a><a href="#h11-11-19" id="h11-11-19" class="d">-        // appended to log and replicated to peers. The mutate command will be
</a><a href="#h11-11-20" id="h11-11-20" class="d">-        // appended to the internal commands list of TestState and returned with
</a><a href="#h11-11-21" id="h11-11-21" class="d">-        // a 0xff prefix, and a subsequent read command can read back the
</a><a href="#h11-11-22" id="h11-11-22" class="d">-        // command at the index given by the command with the result prefixed
</a><a href="#h11-11-23" id="h11-11-23" class="d">-        // with 0xbb.
</a><a href="#h11-11-24" id="h11-11-24" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a>         node = node.step(Message {
<a href="#h11-11-26" id="h11-11-26" class="d">-            from: None,
</a><a href="#h11-11-27" id="h11-11-27" class="d">-            to: None,
</a><a href="#h11-11-28" id="h11-11-28" class="i">+            from: Address::Client,
</a><a href="#h11-11-29" id="h11-11-29" class="i">+            to: Address::Local,
</a>             term: 0,
<a href="#h11-11-31" id="h11-11-31" class="d">-            event: Event::MutateState { call_id: vec![0x01], command: vec![0xaf] },
</a><a href="#h11-11-32" id="h11-11-32" class="i">+            event: Event::ClientRequest { id: vec![0x01], request: Request::Query(vec![0xaf]) },
</a>         })?;
<a href="#h11-11-34" id="h11-11-34" class="d">-        assert_node(&amp;node)
</a><a href="#h11-11-35" id="h11-11-35" class="d">-            .is_leader()
</a><a href="#h11-11-36" id="h11-11-36" class="d">-            .term(3)
</a><a href="#h11-11-37" id="h11-11-37" class="d">-            .committed(2)
</a><a href="#h11-11-38" id="h11-11-38" class="d">-            .applied(1)
</a><a href="#h11-11-39" id="h11-11-39" class="d">-            .last(6)
</a><a href="#h11-11-40" id="h11-11-40" class="d">-            .entry(6, Entry { term: 3, command: Some(vec![0xaf]) });
</a><a href="#h11-11-41" id="h11-11-41" class="d">-        for peer in peers.iter().cloned() {
</a><a href="#h11-11-42" id="h11-11-42" class="d">-            assert_eq!(
</a><a href="#h11-11-43" id="h11-11-43" class="d">-                rx.try_recv()?,
</a><a href="#h11-11-44" id="h11-11-44" class="d">-                Message {
</a><a href="#h11-11-45" id="h11-11-45" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-46" id="h11-11-46" class="d">-                    to: Some(peer),
</a><a href="#h11-11-47" id="h11-11-47" class="d">-                    term: 3,
</a><a href="#h11-11-48" id="h11-11-48" class="d">-                    event: Event::ReplicateEntries {
</a><a href="#h11-11-49" id="h11-11-49" class="d">-                        base_index: 5,
</a><a href="#h11-11-50" id="h11-11-50" class="d">-                        base_term: 3,
</a><a href="#h11-11-51" id="h11-11-51" class="d">-                        entries: vec![Entry { term: 3, command: Some(vec![0xaf]) },]
</a><a href="#h11-11-52" id="h11-11-52" class="d">-                    },
</a><a href="#h11-11-53" id="h11-11-53" class="d">-                }
</a><a href="#h11-11-54" id="h11-11-54" class="d">-            )
</a><a href="#h11-11-55" id="h11-11-55" class="d">-        }
</a><a href="#h11-11-56" id="h11-11-56" class="d">-
</a><a href="#h11-11-57" id="h11-11-57" class="d">-        // Receive some ConfirmLeader messages from peers, to make sure
</a><a href="#h11-11-58" id="h11-11-58" class="d">-        // they do not affect mutation calls at all.
</a><a href="#h11-11-59" id="h11-11-59" class="d">-        for peer in peers.iter().cloned() {
</a><a href="#h11-11-60" id="h11-11-60" class="d">-            node = node.step(Message {
</a><a href="#h11-11-61" id="h11-11-61" class="d">-                from: Some(peer),
</a><a href="#h11-11-62" id="h11-11-62" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-63" id="h11-11-63" class="d">-                term: 3,
</a><a href="#h11-11-64" id="h11-11-64" class="d">-                event: Event::ConfirmLeader { commit_index: 6, has_committed: true },
</a><a href="#h11-11-65" id="h11-11-65" class="d">-            })?;
</a><a href="#h11-11-66" id="h11-11-66" class="d">-            assert_node(&amp;node).committed(2).applied(1).last(6);
</a><a href="#h11-11-67" id="h11-11-67" class="d">-        }
</a><a href="#h11-11-68" id="h11-11-68" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-11-69" id="h11-11-69" class="d">-
</a><a href="#h11-11-70" id="h11-11-70" class="d">-        // Receive AcceptEntries calls from peers, which after a quorum
</a><a href="#h11-11-71" id="h11-11-71" class="d">-        // will commit and apply the entries and return a call response.
</a><a href="#h11-11-72" id="h11-11-72" class="d">-        for (i, peer) in peers.iter().cloned().enumerate() {
</a><a href="#h11-11-73" id="h11-11-73" class="d">-            node = node.step(Message {
</a><a href="#h11-11-74" id="h11-11-74" class="d">-                from: Some(peer),
</a><a href="#h11-11-75" id="h11-11-75" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-76" id="h11-11-76" class="d">-                term: 3,
</a><a href="#h11-11-77" id="h11-11-77" class="d">-                event: Event::AcceptEntries { last_index: 6 },
</a><a href="#h11-11-78" id="h11-11-78" class="d">-            })?;
</a><a href="#h11-11-79" id="h11-11-79" class="d">-            if (i as u64 + 2) &lt; quorum {
</a><a href="#h11-11-80" id="h11-11-80" class="d">-                assert_node(&amp;node).committed(2).applied(2).last(6);
</a><a href="#h11-11-81" id="h11-11-81" class="d">-                assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-11-82" id="h11-11-82" class="d">-            } else {
</a><a href="#h11-11-83" id="h11-11-83" class="d">-                assert_node(&amp;node).committed(6).applied(6).last(6);
</a><a href="#h11-11-84" id="h11-11-84" class="d">-            }
</a><a href="#h11-11-85" id="h11-11-85" class="d">-        }
</a><a href="#h11-11-86" id="h11-11-86" class="i">+        assert_node(&amp;node).is_leader().term(3).committed(2).last(5);
</a>         assert_messages(
<a href="#h11-11-88" id="h11-11-88" class="d">-            &amp;mut rx,
</a><a href="#h11-11-89" id="h11-11-89" class="i">+            &amp;mut node_rx,
</a>             vec![Message {
<a href="#h11-11-91" id="h11-11-91" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-92" id="h11-11-92" class="d">-                to: None,
</a><a href="#h11-11-93" id="h11-11-93" class="i">+                from: Address::Local,
</a><a href="#h11-11-94" id="h11-11-94" class="i">+                to: Address::Peers,
</a>                 term: 3,
<a href="#h11-11-96" id="h11-11-96" class="d">-                event: Event::RespondState { call_id: vec![0x01], response: vec![0xff, 0xaf] },
</a><a href="#h11-11-97" id="h11-11-97" class="i">+                event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
</a>             }],
         );
<a href="#h11-11-100" id="h11-11-100" class="i">+        assert_messages(
</a><a href="#h11-11-101" id="h11-11-101" class="i">+            &amp;mut state_rx,
</a><a href="#h11-11-102" id="h11-11-102" class="i">+            vec![
</a><a href="#h11-11-103" id="h11-11-103" class="i">+                Instruction::Query {
</a><a href="#h11-11-104" id="h11-11-104" class="i">+                    id: vec![0x01],
</a><a href="#h11-11-105" id="h11-11-105" class="i">+                    address: Address::Client,
</a><a href="#h11-11-106" id="h11-11-106" class="i">+                    command: vec![0xaf],
</a><a href="#h11-11-107" id="h11-11-107" class="i">+                    index: 2,
</a><a href="#h11-11-108" id="h11-11-108" class="i">+                    quorum,
</a><a href="#h11-11-109" id="h11-11-109" class="i">+                },
</a><a href="#h11-11-110" id="h11-11-110" class="i">+                Instruction::Vote { index: 2, address: Address::Local },
</a><a href="#h11-11-111" id="h11-11-111" class="i">+            ],
</a><a href="#h11-11-112" id="h11-11-112" class="i">+        );
</a><a href="#h11-11-113" id="h11-11-113" class="i">+        Ok(())
</a><a href="#h11-11-114" id="h11-11-114" class="i">+    }
</a><a href="#h11-11-115" id="h11-11-115" class="i">+
</a><a href="#h11-11-116" id="h11-11-116" class="i">+    #[test]
</a><a href="#h11-11-117" id="h11-11-117" class="i">+    // Sending a mutate request should append it to log, replicate it to peers, and register notification.
</a><a href="#h11-11-118" id="h11-11-118" class="i">+    fn step_clientrequest_mutate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-119" id="h11-11-119" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-11-120" id="h11-11-120" class="i">+        let peers = leader.peers.clone();
</a><a href="#h11-11-121" id="h11-11-121" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a> 
<a href="#h11-11-123" id="h11-11-123" class="d">-        // Submit a read call to read back our entry, which will immediately
</a><a href="#h11-11-124" id="h11-11-124" class="d">-        // send heartbeats to all peers to confirm that we&#39;re still the leader.
</a>         node = node.step(Message {
<a href="#h11-11-126" id="h11-11-126" class="d">-            from: None,
</a><a href="#h11-11-127" id="h11-11-127" class="d">-            to: None,
</a><a href="#h11-11-128" id="h11-11-128" class="i">+            from: Address::Client,
</a><a href="#h11-11-129" id="h11-11-129" class="i">+            to: Address::Local,
</a>             term: 0,
<a href="#h11-11-131" id="h11-11-131" class="d">-            event: Event::QueryState { call_id: vec![0x02], command: vec![0x06] },
</a><a href="#h11-11-132" id="h11-11-132" class="i">+            event: Event::ClientRequest { id: vec![0x01], request: Request::Mutate(vec![0xaf]) },
</a>         })?;
<a href="#h11-11-134" id="h11-11-134" class="d">-        assert_node(&amp;node).is_leader().term(3);
</a><a href="#h11-11-135" id="h11-11-135" class="i">+        assert_node(&amp;node).is_leader().term(3).committed(2).last(6).entry(Entry {
</a><a href="#h11-11-136" id="h11-11-136" class="i">+            index: 6,
</a><a href="#h11-11-137" id="h11-11-137" class="i">+            term: 3,
</a><a href="#h11-11-138" id="h11-11-138" class="i">+            command: Some(vec![0xaf]),
</a><a href="#h11-11-139" id="h11-11-139" class="i">+        });
</a>         for peer in peers.iter().cloned() {
             assert_eq!(
<a href="#h11-11-142" id="h11-11-142" class="d">-                rx.try_recv()?,
</a><a href="#h11-11-143" id="h11-11-143" class="i">+                node_rx.try_recv()?,
</a>                 Message {
<a href="#h11-11-145" id="h11-11-145" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-146" id="h11-11-146" class="d">-                    to: Some(peer),
</a><a href="#h11-11-147" id="h11-11-147" class="i">+                    from: Address::Local,
</a><a href="#h11-11-148" id="h11-11-148" class="i">+                    to: Address::Peer(peer),
</a>                     term: 3,
<a href="#h11-11-150" id="h11-11-150" class="d">-                    event: Event::Heartbeat { commit_index: 6, commit_term: 3 },
</a><a href="#h11-11-151" id="h11-11-151" class="i">+                    event: Event::ReplicateEntries {
</a><a href="#h11-11-152" id="h11-11-152" class="i">+                        base_index: 5,
</a><a href="#h11-11-153" id="h11-11-153" class="i">+                        base_term: 3,
</a><a href="#h11-11-154" id="h11-11-154" class="i">+                        entries: vec![Entry { index: 6, term: 3, command: Some(vec![0xaf]) },]
</a><a href="#h11-11-155" id="h11-11-155" class="i">+                    },
</a>                 }
             )
         }
<a href="#h11-11-159" id="h11-11-159" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-11-160" id="h11-11-160" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-11-161" id="h11-11-161" class="i">+        assert_messages(
</a><a href="#h11-11-162" id="h11-11-162" class="i">+            &amp;mut state_rx,
</a><a href="#h11-11-163" id="h11-11-163" class="i">+            vec![Instruction::Notify { id: vec![0x01], address: Address::Client, index: 6 }],
</a><a href="#h11-11-164" id="h11-11-164" class="i">+        );
</a> 
<a href="#h11-11-166" id="h11-11-166" class="d">-        // Check that ConfirmLeader calls for an old commit_index as well as
</a><a href="#h11-11-167" id="h11-11-167" class="d">-        // AcceptEntries calls for the current last_index do not trigger a
</a><a href="#h11-11-168" id="h11-11-168" class="d">-        // read response.
</a><a href="#h11-11-169" id="h11-11-169" class="d">-        for peer in peers.iter().cloned() {
</a><a href="#h11-11-170" id="h11-11-170" class="d">-            node = node.step(Message {
</a><a href="#h11-11-171" id="h11-11-171" class="d">-                from: Some(peer.clone()),
</a><a href="#h11-11-172" id="h11-11-172" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-173" id="h11-11-173" class="d">-                term: 3,
</a><a href="#h11-11-174" id="h11-11-174" class="d">-                event: Event::ConfirmLeader { commit_index: 5, has_committed: true },
</a><a href="#h11-11-175" id="h11-11-175" class="d">-            })?;
</a><a href="#h11-11-176" id="h11-11-176" class="d">-            node = node.step(Message {
</a><a href="#h11-11-177" id="h11-11-177" class="d">-                from: Some(peer),
</a><a href="#h11-11-178" id="h11-11-178" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-179" id="h11-11-179" class="d">-                term: 3,
</a><a href="#h11-11-180" id="h11-11-180" class="d">-                event: Event::AcceptEntries { last_index: 6 },
</a><a href="#h11-11-181" id="h11-11-181" class="d">-            })?;
</a><a href="#h11-11-182" id="h11-11-182" class="d">-            assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-11-183" id="h11-11-183" class="d">-        }
</a><a href="#h11-11-184" id="h11-11-184" class="i">+        Ok(())
</a><a href="#h11-11-185" id="h11-11-185" class="i">+    }
</a> 
<a href="#h11-11-187" id="h11-11-187" class="d">-        // After we receive leadership confirmation from a quorum of
</a><a href="#h11-11-188" id="h11-11-188" class="d">-        // votes, the read response is returned.
</a><a href="#h11-11-189" id="h11-11-189" class="d">-        for (i, peer) in peers.iter().cloned().enumerate() {
</a><a href="#h11-11-190" id="h11-11-190" class="d">-            node = node.step(Message {
</a><a href="#h11-11-191" id="h11-11-191" class="d">-                from: Some(peer.clone()),
</a><a href="#h11-11-192" id="h11-11-192" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-193" id="h11-11-193" class="d">-                term: 3,
</a><a href="#h11-11-194" id="h11-11-194" class="d">-                event: Event::ConfirmLeader { commit_index: 6, has_committed: true },
</a><a href="#h11-11-195" id="h11-11-195" class="d">-            })?;
</a><a href="#h11-11-196" id="h11-11-196" class="d">-            assert_node(&amp;node).is_leader().term(3).committed(6).applied(6).last(6);
</a><a href="#h11-11-197" id="h11-11-197" class="d">-            if (i as u64 + 2) &lt; quorum {
</a><a href="#h11-11-198" id="h11-11-198" class="d">-                assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-11-199" id="h11-11-199" class="d">-            }
</a><a href="#h11-11-200" id="h11-11-200" class="d">-        }
</a><a href="#h11-11-201" id="h11-11-201" class="i">+    #[test]
</a><a href="#h11-11-202" id="h11-11-202" class="i">+    // Sending a status request should pass it on to state machine, to add status.
</a><a href="#h11-11-203" id="h11-11-203" class="i">+    fn step_clientrequest_status() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-204" id="h11-11-204" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-11-205" id="h11-11-205" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a><a href="#h11-11-206" id="h11-11-206" class="i">+
</a><a href="#h11-11-207" id="h11-11-207" class="i">+        node = node.step(Message {
</a><a href="#h11-11-208" id="h11-11-208" class="i">+            from: Address::Client,
</a><a href="#h11-11-209" id="h11-11-209" class="i">+            to: Address::Local,
</a><a href="#h11-11-210" id="h11-11-210" class="i">+            term: 0,
</a><a href="#h11-11-211" id="h11-11-211" class="i">+            event: Event::ClientRequest { id: vec![0x01], request: Request::Status },
</a><a href="#h11-11-212" id="h11-11-212" class="i">+        })?;
</a><a href="#h11-11-213" id="h11-11-213" class="i">+        assert_node(&amp;node).is_leader().term(3).committed(2).last(5);
</a><a href="#h11-11-214" id="h11-11-214" class="i">+        assert_messages(&amp;mut node_rx, vec![]);
</a>         assert_messages(
<a href="#h11-11-216" id="h11-11-216" class="d">-            &amp;mut rx,
</a><a href="#h11-11-217" id="h11-11-217" class="d">-            vec![Message {
</a><a href="#h11-11-218" id="h11-11-218" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-219" id="h11-11-219" class="d">-                to: None,
</a><a href="#h11-11-220" id="h11-11-220" class="d">-                term: 3,
</a><a href="#h11-11-221" id="h11-11-221" class="d">-                event: Event::RespondState { call_id: vec![0x02], response: vec![0xbb, 0xaf] },
</a><a href="#h11-11-222" id="h11-11-222" class="i">+            &amp;mut state_rx,
</a><a href="#h11-11-223" id="h11-11-223" class="i">+            vec![Instruction::Status {
</a><a href="#h11-11-224" id="h11-11-224" class="i">+                id: vec![0x01],
</a><a href="#h11-11-225" id="h11-11-225" class="i">+                address: Address::Client,
</a><a href="#h11-11-226" id="h11-11-226" class="i">+                status: Status {
</a><a href="#h11-11-227" id="h11-11-227" class="i">+                    id: &quot;a&quot;.into(),
</a><a href="#h11-11-228" id="h11-11-228" class="i">+                    role: &quot;leader&quot;.into(),
</a><a href="#h11-11-229" id="h11-11-229" class="i">+                    leader: &quot;a&quot;.into(),
</a><a href="#h11-11-230" id="h11-11-230" class="i">+                    nodes: 5,
</a><a href="#h11-11-231" id="h11-11-231" class="i">+                    term: 3,
</a><a href="#h11-11-232" id="h11-11-232" class="i">+                    entries: 5,
</a><a href="#h11-11-233" id="h11-11-233" class="i">+                    committed: 2,
</a><a href="#h11-11-234" id="h11-11-234" class="i">+                    applied: 0,
</a><a href="#h11-11-235" id="h11-11-235" class="i">+                },
</a>             }],
         );
 
<a href="#h11-11-239" id="h11-11-239" class="d">-        // Further leadership confirmation messages should not trigger messages.
</a><a href="#h11-11-240" id="h11-11-240" class="d">-        for peer in peers.iter().cloned() {
</a><a href="#h11-11-241" id="h11-11-241" class="d">-            node = node.step(Message {
</a><a href="#h11-11-242" id="h11-11-242" class="d">-                from: Some(peer.clone()),
</a><a href="#h11-11-243" id="h11-11-243" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-244" id="h11-11-244" class="d">-                term: 3,
</a><a href="#h11-11-245" id="h11-11-245" class="d">-                event: Event::ConfirmLeader { commit_index: 6, has_committed: true },
</a><a href="#h11-11-246" id="h11-11-246" class="d">-            })?;
</a><a href="#h11-11-247" id="h11-11-247" class="d">-            assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-11-248" id="h11-11-248" class="d">-        }
</a><a href="#h11-11-249" id="h11-11-249" class="d">-        assert_node(&amp;node).is_leader().term(3).committed(6).applied(6).last(6);
</a>         Ok(())
     }
 
     #[test]
     fn tick() -&gt; Result&lt;(), Error&gt; {
<a href="#h11-11-255" id="h11-11-255" class="d">-        let (leader, mut rx) = setup()?;
</a><a href="#h11-11-256" id="h11-11-256" class="d">-        let peers = leader.peers.clone();
</a><a href="#h11-11-257" id="h11-11-257" class="d">-        let mut node: Node&lt;_, _&gt; = leader.into();
</a><a href="#h11-11-258" id="h11-11-258" class="i">+        let (leader, mut node_rx, mut state_rx) = setup()?;
</a><a href="#h11-11-259" id="h11-11-259" class="i">+        let mut node: Node&lt;_&gt; = leader.into();
</a>         for _ in 0..5 {
             for _ in 0..HEARTBEAT_INTERVAL {
<a href="#h11-11-262" id="h11-11-262" class="d">-                assert_messages(&amp;mut rx, vec![]);
</a><a href="#h11-11-263" id="h11-11-263" class="i">+                assert_messages(&amp;mut node_rx, vec![]);
</a><a href="#h11-11-264" id="h11-11-264" class="i">+                assert_messages(&amp;mut state_rx, vec![]);
</a>                 node = node.tick()?;
<a href="#h11-11-266" id="h11-11-266" class="d">-                assert_node(&amp;node).is_leader().term(3).committed(2).applied(2);
</a><a href="#h11-11-267" id="h11-11-267" class="d">-            }
</a><a href="#h11-11-268" id="h11-11-268" class="d">-            for peer in peers.iter() {
</a><a href="#h11-11-269" id="h11-11-269" class="d">-                assert_eq!(
</a><a href="#h11-11-270" id="h11-11-270" class="d">-                    rx.try_recv()?,
</a><a href="#h11-11-271" id="h11-11-271" class="d">-                    Message {
</a><a href="#h11-11-272" id="h11-11-272" class="d">-                        from: Some(&quot;a&quot;.into()),
</a><a href="#h11-11-273" id="h11-11-273" class="d">-                        to: Some(peer.into()),
</a><a href="#h11-11-274" id="h11-11-274" class="d">-                        term: 3,
</a><a href="#h11-11-275" id="h11-11-275" class="d">-                        event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
</a><a href="#h11-11-276" id="h11-11-276" class="d">-                    }
</a><a href="#h11-11-277" id="h11-11-277" class="d">-                );
</a><a href="#h11-11-278" id="h11-11-278" class="i">+                assert_node(&amp;node).is_leader().term(3).committed(2);
</a>             }
<a href="#h11-11-280" id="h11-11-280" class="i">+            assert_eq!(
</a><a href="#h11-11-281" id="h11-11-281" class="i">+                node_rx.try_recv()?,
</a><a href="#h11-11-282" id="h11-11-282" class="i">+                Message {
</a><a href="#h11-11-283" id="h11-11-283" class="i">+                    from: Address::Local,
</a><a href="#h11-11-284" id="h11-11-284" class="i">+                    to: Address::Peers,
</a><a href="#h11-11-285" id="h11-11-285" class="i">+                    term: 3,
</a><a href="#h11-11-286" id="h11-11-286" class="i">+                    event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
</a><a href="#h11-11-287" id="h11-11-287" class="i">+                }
</a><a href="#h11-11-288" id="h11-11-288" class="i">+            );
</a>         }
         Ok(())
     }
<a href="#h11-11-292" id="h11-11-292" class="d">-
</a><a href="#h11-11-293" id="h11-11-293" class="d">-    fn setup_calls() -&gt; Calls {
</a><a href="#h11-11-294" id="h11-11-294" class="d">-        let mut calls = Calls::new();
</a><a href="#h11-11-295" id="h11-11-295" class="d">-        calls.register(Call {
</a><a href="#h11-11-296" id="h11-11-296" class="d">-            id: vec![0xa0],
</a><a href="#h11-11-297" id="h11-11-297" class="d">-            from: None,
</a><a href="#h11-11-298" id="h11-11-298" class="d">-            operation: Operation::MutateState { log_index: 1 },
</a><a href="#h11-11-299" id="h11-11-299" class="d">-        });
</a><a href="#h11-11-300" id="h11-11-300" class="d">-        calls.register(Call {
</a><a href="#h11-11-301" id="h11-11-301" class="d">-            id: vec![0xa2],
</a><a href="#h11-11-302" id="h11-11-302" class="d">-            from: None,
</a><a href="#h11-11-303" id="h11-11-303" class="d">-            operation: Operation::MutateState { log_index: 2 },
</a><a href="#h11-11-304" id="h11-11-304" class="d">-        });
</a><a href="#h11-11-305" id="h11-11-305" class="d">-        calls.register(Call {
</a><a href="#h11-11-306" id="h11-11-306" class="d">-            id: vec![0xa3],
</a><a href="#h11-11-307" id="h11-11-307" class="d">-            from: None,
</a><a href="#h11-11-308" id="h11-11-308" class="d">-            operation: Operation::MutateState { log_index: 3 },
</a><a href="#h11-11-309" id="h11-11-309" class="d">-        });
</a><a href="#h11-11-310" id="h11-11-310" class="d">-
</a><a href="#h11-11-311" id="h11-11-311" class="d">-        calls.register(Call {
</a><a href="#h11-11-312" id="h11-11-312" class="d">-            id: vec![0xb0],
</a><a href="#h11-11-313" id="h11-11-313" class="d">-            from: None,
</a><a href="#h11-11-314" id="h11-11-314" class="d">-            operation: Operation::ReadState {
</a><a href="#h11-11-315" id="h11-11-315" class="d">-                command: vec![0x01],
</a><a href="#h11-11-316" id="h11-11-316" class="d">-                commit_index: 1,
</a><a href="#h11-11-317" id="h11-11-317" class="d">-                quorum: 3,
</a><a href="#h11-11-318" id="h11-11-318" class="d">-                votes: HashSet::new(),
</a><a href="#h11-11-319" id="h11-11-319" class="d">-            },
</a><a href="#h11-11-320" id="h11-11-320" class="d">-        });
</a><a href="#h11-11-321" id="h11-11-321" class="d">-        calls.register(Call {
</a><a href="#h11-11-322" id="h11-11-322" class="d">-            id: vec![0xb1],
</a><a href="#h11-11-323" id="h11-11-323" class="d">-            from: None,
</a><a href="#h11-11-324" id="h11-11-324" class="d">-            operation: Operation::ReadState {
</a><a href="#h11-11-325" id="h11-11-325" class="d">-                command: vec![0x02],
</a><a href="#h11-11-326" id="h11-11-326" class="d">-                commit_index: 2,
</a><a href="#h11-11-327" id="h11-11-327" class="d">-                quorum: 3,
</a><a href="#h11-11-328" id="h11-11-328" class="d">-                votes: HashSet::new(),
</a><a href="#h11-11-329" id="h11-11-329" class="d">-            },
</a><a href="#h11-11-330" id="h11-11-330" class="d">-        });
</a><a href="#h11-11-331" id="h11-11-331" class="d">-        calls.register(Call {
</a><a href="#h11-11-332" id="h11-11-332" class="d">-            id: vec![0xb2],
</a><a href="#h11-11-333" id="h11-11-333" class="d">-            from: None,
</a><a href="#h11-11-334" id="h11-11-334" class="d">-            operation: Operation::ReadState {
</a><a href="#h11-11-335" id="h11-11-335" class="d">-                command: vec![0x02],
</a><a href="#h11-11-336" id="h11-11-336" class="d">-                commit_index: 3,
</a><a href="#h11-11-337" id="h11-11-337" class="d">-                quorum: 3,
</a><a href="#h11-11-338" id="h11-11-338" class="d">-                votes: HashSet::new(),
</a><a href="#h11-11-339" id="h11-11-339" class="d">-            },
</a><a href="#h11-11-340" id="h11-11-340" class="d">-        });
</a><a href="#h11-11-341" id="h11-11-341" class="d">-        calls
</a><a href="#h11-11-342" id="h11-11-342" class="d">-    }
</a><a href="#h11-11-343" id="h11-11-343" class="d">-
</a><a href="#h11-11-344" id="h11-11-344" class="d">-    #[test]
</a><a href="#h11-11-345" id="h11-11-345" class="d">-    fn calls_log_applied() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-346" id="h11-11-346" class="d">-        let mut calls = setup_calls();
</a><a href="#h11-11-347" id="h11-11-347" class="d">-        assert_eq!(calls.log_applied(2).unwrap().id, vec![0xa2]);
</a><a href="#h11-11-348" id="h11-11-348" class="d">-        assert_eq!(calls.log_applied(2), None);
</a><a href="#h11-11-349" id="h11-11-349" class="d">-        assert_eq!(calls.log_applied(9), None);
</a><a href="#h11-11-350" id="h11-11-350" class="d">-        Ok(())
</a><a href="#h11-11-351" id="h11-11-351" class="d">-    }
</a><a href="#h11-11-352" id="h11-11-352" class="d">-
</a><a href="#h11-11-353" id="h11-11-353" class="d">-    #[test]
</a><a href="#h11-11-354" id="h11-11-354" class="d">-    fn calls_quorum_vote() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-355" id="h11-11-355" class="d">-        let mut calls = setup_calls();
</a><a href="#h11-11-356" id="h11-11-356" class="d">-        // 0xb0=1 0xb1=1 0xb2=1
</a><a href="#h11-11-357" id="h11-11-357" class="d">-        assert_eq!(calls.quorum_vote(&quot;a&quot;, 3), vec![]);
</a><a href="#h11-11-358" id="h11-11-358" class="d">-        // 0xb0=2 0xb1=1 0xb2=1
</a><a href="#h11-11-359" id="h11-11-359" class="d">-        assert_eq!(calls.quorum_vote(&quot;b&quot;, 1), vec![]);
</a><a href="#h11-11-360" id="h11-11-360" class="d">-        // 0xb0=3 0xb1=2 0xb2=1
</a><a href="#h11-11-361" id="h11-11-361" class="d">-        assert_eq!(
</a><a href="#h11-11-362" id="h11-11-362" class="d">-            calls.quorum_vote(&quot;c&quot;, 2).into_iter().map(|c| c.id).collect::&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;(),
</a><a href="#h11-11-363" id="h11-11-363" class="d">-            vec![vec![0xb0_u8]]
</a><a href="#h11-11-364" id="h11-11-364" class="d">-        );
</a><a href="#h11-11-365" id="h11-11-365" class="d">-        // 0xb1=3 0xb2=2
</a><a href="#h11-11-366" id="h11-11-366" class="d">-        assert_eq!(
</a><a href="#h11-11-367" id="h11-11-367" class="d">-            calls.quorum_vote(&quot;d&quot;, 4).into_iter().map(|c| c.id).collect::&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;(),
</a><a href="#h11-11-368" id="h11-11-368" class="d">-            vec![vec![0xb1_u8]]
</a><a href="#h11-11-369" id="h11-11-369" class="d">-        );
</a><a href="#h11-11-370" id="h11-11-370" class="d">-        // 0xb2=3
</a><a href="#h11-11-371" id="h11-11-371" class="d">-        assert_eq!(
</a><a href="#h11-11-372" id="h11-11-372" class="d">-            calls.quorum_vote(&quot;e&quot;, 3).into_iter().map(|c| c.id).collect::&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;(),
</a><a href="#h11-11-373" id="h11-11-373" class="d">-            vec![vec![0xb2_u8]]
</a><a href="#h11-11-374" id="h11-11-374" class="d">-        );
</a><a href="#h11-11-375" id="h11-11-375" class="d">-        Ok(())
</a><a href="#h11-11-376" id="h11-11-376" class="d">-    }
</a><a href="#h11-11-377" id="h11-11-377" class="d">-
</a><a href="#h11-11-378" id="h11-11-378" class="d">-    #[test]
</a><a href="#h11-11-379" id="h11-11-379" class="d">-    fn calls_quorum_vote_multiple() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-380" id="h11-11-380" class="d">-        let mut calls = setup_calls();
</a><a href="#h11-11-381" id="h11-11-381" class="d">-        assert_eq!(calls.quorum_vote(&quot;a&quot;, 3), vec![]);
</a><a href="#h11-11-382" id="h11-11-382" class="d">-        assert_eq!(calls.quorum_vote(&quot;b&quot;, 3), vec![]);
</a><a href="#h11-11-383" id="h11-11-383" class="d">-        assert_eq!(
</a><a href="#h11-11-384" id="h11-11-384" class="d">-            calls.quorum_vote(&quot;c&quot;, 3).into_iter().map(|c| c.id).collect::&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;(),
</a><a href="#h11-11-385" id="h11-11-385" class="d">-            vec![vec![0xb0_u8], vec![0xb1_u8], vec![0xb2_u8]]
</a><a href="#h11-11-386" id="h11-11-386" class="d">-        );
</a><a href="#h11-11-387" id="h11-11-387" class="d">-        Ok(())
</a><a href="#h11-11-388" id="h11-11-388" class="d">-    }
</a><a href="#h11-11-389" id="h11-11-389" class="d">-
</a><a href="#h11-11-390" id="h11-11-390" class="d">-    #[test]
</a><a href="#h11-11-391" id="h11-11-391" class="d">-    fn calls_quorum_vote_same_voter_ignored() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h11-11-392" id="h11-11-392" class="d">-        let mut calls = setup_calls();
</a><a href="#h11-11-393" id="h11-11-393" class="d">-        assert_eq!(calls.quorum_vote(&quot;a&quot;, 1), vec![]);
</a><a href="#h11-11-394" id="h11-11-394" class="d">-        assert_eq!(calls.quorum_vote(&quot;a&quot;, 1), vec![]);
</a><a href="#h11-11-395" id="h11-11-395" class="d">-        assert_eq!(calls.quorum_vote(&quot;a&quot;, 1), vec![]);
</a><a href="#h11-11-396" id="h11-11-396" class="d">-        assert_eq!(calls.quorum_vote(&quot;b&quot;, 1), vec![]);
</a><a href="#h11-11-397" id="h11-11-397" class="d">-        assert_eq!(calls.quorum_vote(&quot;b&quot;, 1), vec![]);
</a><a href="#h11-11-398" id="h11-11-398" class="d">-        assert_eq!(calls.quorum_vote(&quot;b&quot;, 1), vec![]);
</a><a href="#h11-11-399" id="h11-11-399" class="d">-        assert_eq!(
</a><a href="#h11-11-400" id="h11-11-400" class="d">-            calls.quorum_vote(&quot;c&quot;, 1).into_iter().map(|c| c.id).collect::&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;(),
</a><a href="#h11-11-401" id="h11-11-401" class="d">-            vec![vec![0xb0_u8]]
</a><a href="#h11-11-402" id="h11-11-402" class="d">-        );
</a><a href="#h11-11-403" id="h11-11-403" class="d">-        Ok(())
</a><a href="#h11-11-404" id="h11-11-404" class="d">-    }
</a> }
<b>diff --git a/<a id="h12" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -2,16 +2,17 @@ mod candidate;
</a> mod follower;
 mod leader;
 
<a href="#h12-0-3" id="h12-0-3" class="d">-use super::{Event, Log, Message, State};
</a><a href="#h12-0-4" id="h12-0-4" class="i">+use super::{Address, Driver, Event, Instruction, Log, Message, State};
</a> use crate::kv::storage::Storage;
 use crate::Error;
 use candidate::Candidate;
 use follower::Follower;
 use leader::Leader;
 
<a href="#h12-0-11" id="h12-0-11" class="d">-use log::{debug, info, warn};
</a><a href="#h12-0-12" id="h12-0-12" class="i">+use log::{debug, info};
</a> use serde_derive::{Deserialize, Serialize};
<a href="#h12-0-14" id="h12-0-14" class="d">-use tokio::sync::mpsc::UnboundedSender;
</a><a href="#h12-0-15" id="h12-0-15" class="i">+use std::collections::HashMap;
</a><a href="#h12-0-16" id="h12-0-16" class="i">+use tokio::sync::mpsc;
</a> 
 /// The interval between leader heartbeats, in ticks.
 const HEARTBEAT_INTERVAL: u64 = 1;
<a href="#h12-1" id="h12-1" class="h">@@ -23,11 +24,11 @@ const ELECTION_TIMEOUT_MIN: u64 = 8 * HEARTBEAT_INTERVAL;
</a> const ELECTION_TIMEOUT_MAX: u64 = 15 * HEARTBEAT_INTERVAL;
 
 /// Node status
<a href="#h12-1-3" id="h12-1-3" class="d">-#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h12-1-4" id="h12-1-4" class="i">+#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
</a> pub struct Status {
     pub id: String,
     pub role: String,
<a href="#h12-1-8" id="h12-1-8" class="d">-    pub leader: Option&lt;String&gt;,
</a><a href="#h12-1-9" id="h12-1-9" class="i">+    pub leader: String,
</a>     pub nodes: u64,
     pub term: u64,
     pub entries: u64,
<a href="#h12-2" id="h12-2" class="h">@@ -36,29 +37,47 @@ pub struct Status {
</a> }
 
 /// The local Raft node state machine.
<a href="#h12-2-3" id="h12-2-3" class="d">-pub enum Node&lt;L: Storage, S: State&gt; {
</a><a href="#h12-2-4" id="h12-2-4" class="d">-    Candidate(RoleNode&lt;Candidate, L, S&gt;),
</a><a href="#h12-2-5" id="h12-2-5" class="d">-    Follower(RoleNode&lt;Follower, L, S&gt;),
</a><a href="#h12-2-6" id="h12-2-6" class="d">-    Leader(RoleNode&lt;Leader, L, S&gt;),
</a><a href="#h12-2-7" id="h12-2-7" class="i">+pub enum Node&lt;L: Storage&gt; {
</a><a href="#h12-2-8" id="h12-2-8" class="i">+    Candidate(RoleNode&lt;Candidate, L&gt;),
</a><a href="#h12-2-9" id="h12-2-9" class="i">+    Follower(RoleNode&lt;Follower, L&gt;),
</a><a href="#h12-2-10" id="h12-2-10" class="i">+    Leader(RoleNode&lt;Leader, L&gt;),
</a> }
 
<a href="#h12-2-13" id="h12-2-13" class="d">-impl&lt;L: Storage, S: State&gt; Node&lt;L, S&gt; {
</a><a href="#h12-2-14" id="h12-2-14" class="i">+impl&lt;L: Storage&gt; Node&lt;L&gt; {
</a>     /// Creates a new Raft node, starting as a follower, or leader if no peers.
<a href="#h12-2-16" id="h12-2-16" class="d">-    pub fn new(
</a><a href="#h12-2-17" id="h12-2-17" class="i">+    pub async fn new&lt;S: State + Send + &#39;static&gt;(
</a>         id: &amp;str,
         peers: Vec&lt;String&gt;,
         log: Log&lt;L&gt;,
         state: S,
<a href="#h12-2-22" id="h12-2-22" class="d">-        sender: UnboundedSender&lt;Message&gt;,
</a><a href="#h12-2-23" id="h12-2-23" class="i">+        node_tx: mpsc::UnboundedSender&lt;Message&gt;,
</a>     ) -&gt; Result&lt;Self, Error&gt; {
<a href="#h12-2-25" id="h12-2-25" class="i">+        let (state_tx, state_rx) = mpsc::unbounded_channel();
</a><a href="#h12-2-26" id="h12-2-26" class="i">+        let (committed_index, _) = log.get_committed();
</a><a href="#h12-2-27" id="h12-2-27" class="i">+        let applied_index = state.applied_index();
</a><a href="#h12-2-28" id="h12-2-28" class="i">+        if applied_index &gt; committed_index {
</a><a href="#h12-2-29" id="h12-2-29" class="i">+            return Err(Error::Internal(format!(
</a><a href="#h12-2-30" id="h12-2-30" class="i">+                &quot;State machine applied index {} greater than log committed index {}&quot;,
</a><a href="#h12-2-31" id="h12-2-31" class="i">+                applied_index, committed_index
</a><a href="#h12-2-32" id="h12-2-32" class="i">+            )));
</a><a href="#h12-2-33" id="h12-2-33" class="i">+        }
</a><a href="#h12-2-34" id="h12-2-34" class="i">+        tokio::spawn(Driver::new(state_rx, node_tx.clone()).drive(state));
</a><a href="#h12-2-35" id="h12-2-35" class="i">+        for index in applied_index..=committed_index {
</a><a href="#h12-2-36" id="h12-2-36" class="i">+            if let Some(entry) = log.get(index)? {
</a><a href="#h12-2-37" id="h12-2-37" class="i">+                state_tx.send(Instruction::Apply { entry })?;
</a><a href="#h12-2-38" id="h12-2-38" class="i">+            }
</a><a href="#h12-2-39" id="h12-2-39" class="i">+        }
</a><a href="#h12-2-40" id="h12-2-40" class="i">+
</a>         let (term, voted_for) = log.load_term()?;
         let node = RoleNode {
             id: id.to_owned(),
             peers,
             term,
             log,
<a href="#h12-2-47" id="h12-2-47" class="d">-            state,
</a><a href="#h12-2-48" id="h12-2-48" class="d">-            sender,
</a><a href="#h12-2-49" id="h12-2-49" class="i">+            node_tx,
</a><a href="#h12-2-50" id="h12-2-50" class="i">+            state_tx,
</a><a href="#h12-2-51" id="h12-2-51" class="i">+            queued_reqs: Vec::new(),
</a><a href="#h12-2-52" id="h12-2-52" class="i">+            proxied_reqs: HashMap::new(),
</a>             role: Follower::new(None, voted_for.as_deref()),
         };
         if node.peers.is_empty() {
<a href="#h12-3" id="h12-3" class="h">@@ -70,24 +89,13 @@ impl&lt;L: Storage, S: State&gt; Node&lt;L, S&gt; {
</a>         }
     }
 
<a href="#h12-3-3" id="h12-3-3" class="d">-    /// Returns node status.
</a><a href="#h12-3-4" id="h12-3-4" class="d">-    pub fn status(&amp;self) -&gt; Result&lt;Status, Error&gt; {
</a><a href="#h12-3-5" id="h12-3-5" class="d">-        let mut status = match self {
</a><a href="#h12-3-6" id="h12-3-6" class="d">-            Node::Candidate(n) =&gt; n.status(),
</a><a href="#h12-3-7" id="h12-3-7" class="d">-            Node::Follower(n) =&gt; n.status(),
</a><a href="#h12-3-8" id="h12-3-8" class="d">-            Node::Leader(n) =&gt; n.status(),
</a><a href="#h12-3-9" id="h12-3-9" class="d">-        }?;
</a><a href="#h12-3-10" id="h12-3-10" class="d">-        status.role = match self {
</a><a href="#h12-3-11" id="h12-3-11" class="d">-            Node::Candidate(_) =&gt; &quot;candidate&quot;.into(),
</a><a href="#h12-3-12" id="h12-3-12" class="d">-            Node::Follower(_) =&gt; &quot;follower&quot;.into(),
</a><a href="#h12-3-13" id="h12-3-13" class="d">-            Node::Leader(_) =&gt; &quot;leader&quot;.into(),
</a><a href="#h12-3-14" id="h12-3-14" class="d">-        };
</a><a href="#h12-3-15" id="h12-3-15" class="d">-        status.leader = match self {
</a><a href="#h12-3-16" id="h12-3-16" class="d">-            Node::Candidate(_) =&gt; None,
</a><a href="#h12-3-17" id="h12-3-17" class="d">-            Node::Follower(n) =&gt; n.role.leader.clone(),
</a><a href="#h12-3-18" id="h12-3-18" class="d">-            Node::Leader(n) =&gt; Some(n.id.clone()),
</a><a href="#h12-3-19" id="h12-3-19" class="d">-        };
</a><a href="#h12-3-20" id="h12-3-20" class="d">-        Ok(status)
</a><a href="#h12-3-21" id="h12-3-21" class="i">+    /// Returns the node ID.
</a><a href="#h12-3-22" id="h12-3-22" class="i">+    pub fn id(&amp;self) -&gt; String {
</a><a href="#h12-3-23" id="h12-3-23" class="i">+        match self {
</a><a href="#h12-3-24" id="h12-3-24" class="i">+            Node::Candidate(n) =&gt; n.id.clone(),
</a><a href="#h12-3-25" id="h12-3-25" class="i">+            Node::Follower(n) =&gt; n.id.clone(),
</a><a href="#h12-3-26" id="h12-3-26" class="i">+            Node::Leader(n) =&gt; n.id.clone(),
</a><a href="#h12-3-27" id="h12-3-27" class="i">+        }
</a>     }
 
     /// Processes a message.
<a href="#h12-4" id="h12-4" class="h">@@ -110,68 +118,80 @@ impl&lt;L: Storage, S: State&gt; Node&lt;L, S&gt; {
</a>     }
 }
 
<a href="#h12-4-3" id="h12-4-3" class="d">-impl&lt;L: Storage, S: State&gt; From&lt;RoleNode&lt;Candidate, L, S&gt;&gt; for Node&lt;L, S&gt; {
</a><a href="#h12-4-4" id="h12-4-4" class="d">-    fn from(rn: RoleNode&lt;Candidate, L, S&gt;) -&gt; Self {
</a><a href="#h12-4-5" id="h12-4-5" class="i">+impl&lt;L: Storage&gt; From&lt;RoleNode&lt;Candidate, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h12-4-6" id="h12-4-6" class="i">+    fn from(rn: RoleNode&lt;Candidate, L&gt;) -&gt; Self {
</a>         Node::Candidate(rn)
     }
 }
 
<a href="#h12-4-11" id="h12-4-11" class="d">-impl&lt;L: Storage, S: State&gt; From&lt;RoleNode&lt;Follower, L, S&gt;&gt; for Node&lt;L, S&gt; {
</a><a href="#h12-4-12" id="h12-4-12" class="d">-    fn from(rn: RoleNode&lt;Follower, L, S&gt;) -&gt; Self {
</a><a href="#h12-4-13" id="h12-4-13" class="i">+impl&lt;L: Storage&gt; From&lt;RoleNode&lt;Follower, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h12-4-14" id="h12-4-14" class="i">+    fn from(rn: RoleNode&lt;Follower, L&gt;) -&gt; Self {
</a>         Node::Follower(rn)
     }
 }
 
<a href="#h12-4-19" id="h12-4-19" class="d">-impl&lt;L: Storage, S: State&gt; From&lt;RoleNode&lt;Leader, L, S&gt;&gt; for Node&lt;L, S&gt; {
</a><a href="#h12-4-20" id="h12-4-20" class="d">-    fn from(rn: RoleNode&lt;Leader, L, S&gt;) -&gt; Self {
</a><a href="#h12-4-21" id="h12-4-21" class="i">+impl&lt;L: Storage&gt; From&lt;RoleNode&lt;Leader, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h12-4-22" id="h12-4-22" class="i">+    fn from(rn: RoleNode&lt;Leader, L&gt;) -&gt; Self {
</a>         Node::Leader(rn)
     }
 }
 
 // A Raft node with role R
<a href="#h12-4-28" id="h12-4-28" class="d">-pub struct RoleNode&lt;R, L: Storage, S: State&gt; {
</a><a href="#h12-4-29" id="h12-4-29" class="i">+pub struct RoleNode&lt;R, L: Storage&gt; {
</a>     id: String,
     peers: Vec&lt;String&gt;,
     term: u64,
     log: Log&lt;L&gt;,
<a href="#h12-4-34" id="h12-4-34" class="d">-    state: S,
</a><a href="#h12-4-35" id="h12-4-35" class="d">-    sender: UnboundedSender&lt;Message&gt;,
</a><a href="#h12-4-36" id="h12-4-36" class="i">+    node_tx: mpsc::UnboundedSender&lt;Message&gt;,
</a><a href="#h12-4-37" id="h12-4-37" class="i">+    state_tx: mpsc::UnboundedSender&lt;Instruction&gt;,
</a><a href="#h12-4-38" id="h12-4-38" class="i">+    /// Keeps track of queued client requests received e.g. during elections.
</a><a href="#h12-4-39" id="h12-4-39" class="i">+    queued_reqs: Vec&lt;(Address, Event)&gt;,
</a><a href="#h12-4-40" id="h12-4-40" class="i">+    /// Keeps track of proxied client requests, to abort on new leader election.
</a><a href="#h12-4-41" id="h12-4-41" class="i">+    proxied_reqs: HashMap&lt;Vec&lt;u8&gt;, Address&gt;,
</a>     role: R,
 }
 
<a href="#h12-4-45" id="h12-4-45" class="d">-impl&lt;R, L: Storage, S: State&gt; RoleNode&lt;R, L, S&gt; {
</a><a href="#h12-4-46" id="h12-4-46" class="i">+impl&lt;R, L: Storage&gt; RoleNode&lt;R, L&gt; {
</a>     /// Transforms the node into another role.
<a href="#h12-4-48" id="h12-4-48" class="d">-    fn become_role&lt;T&gt;(self, role: T) -&gt; Result&lt;RoleNode&lt;T, L, S&gt;, Error&gt; {
</a><a href="#h12-4-49" id="h12-4-49" class="i">+    fn become_role&lt;T&gt;(self, role: T) -&gt; Result&lt;RoleNode&lt;T, L&gt;, Error&gt; {
</a>         Ok(RoleNode {
             id: self.id,
             peers: self.peers,
             term: self.term,
             log: self.log,
<a href="#h12-4-55" id="h12-4-55" class="d">-            state: self.state,
</a><a href="#h12-4-56" id="h12-4-56" class="d">-            sender: self.sender,
</a><a href="#h12-4-57" id="h12-4-57" class="i">+            node_tx: self.node_tx,
</a><a href="#h12-4-58" id="h12-4-58" class="i">+            state_tx: self.state_tx,
</a><a href="#h12-4-59" id="h12-4-59" class="i">+            queued_reqs: self.queued_reqs,
</a><a href="#h12-4-60" id="h12-4-60" class="i">+            proxied_reqs: self.proxied_reqs,
</a>             role,
         })
     }
 
<a href="#h12-4-65" id="h12-4-65" class="d">-    /// Broadcasts an event to all peers.
</a><a href="#h12-4-66" id="h12-4-66" class="d">-    fn broadcast(&amp;self, event: Event) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-4-67" id="h12-4-67" class="d">-        for peer in self.peers.iter() {
</a><a href="#h12-4-68" id="h12-4-68" class="d">-            self.send(Some(peer), event.clone())?
</a><a href="#h12-4-69" id="h12-4-69" class="i">+    /// Aborts any proxied requests.
</a><a href="#h12-4-70" id="h12-4-70" class="i">+    fn abort_proxied(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-4-71" id="h12-4-71" class="i">+        for (id, address) in std::mem::replace(&amp;mut self.proxied_reqs, HashMap::new()) {
</a><a href="#h12-4-72" id="h12-4-72" class="i">+            self.send(address, Event::ClientResponse { id, response: Err(Error::Abort) })?;
</a>         }
         Ok(())
     }
 
<a href="#h12-4-77" id="h12-4-77" class="d">-    /// Normalizes and validates a message, ensuring it is addressed
</a><a href="#h12-4-78" id="h12-4-78" class="d">-    /// to the local node and term. On any errors it emits a warning and
</a><a href="#h12-4-79" id="h12-4-79" class="d">-    /// returns false.
</a><a href="#h12-4-80" id="h12-4-80" class="d">-    fn normalize_message(&amp;self, msg: &amp;mut Message) -&gt; bool {
</a><a href="#h12-4-81" id="h12-4-81" class="d">-        msg.normalize(&amp;self.id, self.term);
</a><a href="#h12-4-82" id="h12-4-82" class="d">-        if let Err(err) = msg.validate(&amp;self.id, self.term) {
</a><a href="#h12-4-83" id="h12-4-83" class="d">-            warn!(&quot;{}&quot;, err);
</a><a href="#h12-4-84" id="h12-4-84" class="d">-            false
</a><a href="#h12-4-85" id="h12-4-85" class="d">-        } else {
</a><a href="#h12-4-86" id="h12-4-86" class="d">-            true
</a><a href="#h12-4-87" id="h12-4-87" class="i">+    /// Sends any queued requests to the given leader.
</a><a href="#h12-4-88" id="h12-4-88" class="i">+    fn forward_queued(&amp;mut self, leader: Address) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-4-89" id="h12-4-89" class="i">+        for (from, event) in std::mem::replace(&amp;mut self.queued_reqs, Vec::new()) {
</a><a href="#h12-4-90" id="h12-4-90" class="i">+            if let Event::ClientRequest { id, .. } = &amp;event {
</a><a href="#h12-4-91" id="h12-4-91" class="i">+                self.proxied_reqs.insert(id.clone(), from.clone());
</a><a href="#h12-4-92" id="h12-4-92" class="i">+                self.node_tx.send(Message {
</a><a href="#h12-4-93" id="h12-4-93" class="i">+                    from: match from {
</a><a href="#h12-4-94" id="h12-4-94" class="i">+                        Address::Client =&gt; Address::Local,
</a><a href="#h12-4-95" id="h12-4-95" class="i">+                        address =&gt; address,
</a><a href="#h12-4-96" id="h12-4-96" class="i">+                    },
</a><a href="#h12-4-97" id="h12-4-97" class="i">+                    to: leader.clone(),
</a><a href="#h12-4-98" id="h12-4-98" class="i">+                    term: 0,
</a><a href="#h12-4-99" id="h12-4-99" class="i">+                    event,
</a><a href="#h12-4-100" id="h12-4-100" class="i">+                })?;
</a><a href="#h12-4-101" id="h12-4-101" class="i">+            }
</a>         }
<a href="#h12-4-103" id="h12-4-103" class="i">+        Ok(())
</a>     }
 
     /// Returns the quorum size of the cluster.
<a href="#h12-5" id="h12-5" class="h">@@ -186,34 +206,40 @@ impl&lt;R, L: Storage, S: State&gt; RoleNode&lt;R, L, S&gt; {
</a>         Ok(())
     }
 
<a href="#h12-5-3" id="h12-5-3" class="d">-    /// Sends an event to a peer, or local caller if None
</a><a href="#h12-5-4" id="h12-5-4" class="d">-    fn send(&amp;self, to: Option&lt;&amp;str&gt;, event: Event) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-5-5" id="h12-5-5" class="d">-        let msg = Message {
</a><a href="#h12-5-6" id="h12-5-6" class="d">-            term: self.term,
</a><a href="#h12-5-7" id="h12-5-7" class="d">-            from: Some(self.id.clone()),
</a><a href="#h12-5-8" id="h12-5-8" class="d">-            to: to.map(str::to_owned),
</a><a href="#h12-5-9" id="h12-5-9" class="d">-            event,
</a><a href="#h12-5-10" id="h12-5-10" class="d">-        };
</a><a href="#h12-5-11" id="h12-5-11" class="i">+    /// Sends an event
</a><a href="#h12-5-12" id="h12-5-12" class="i">+    fn send(&amp;self, to: Address, event: Event) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-5-13" id="h12-5-13" class="i">+        let msg = Message { term: self.term, from: Address::Local, to, event };
</a>         debug!(&quot;Sending {:?}&quot;, msg);
<a href="#h12-5-15" id="h12-5-15" class="d">-        Ok(self.sender.send(msg)?)
</a><a href="#h12-5-16" id="h12-5-16" class="i">+        Ok(self.node_tx.send(msg)?)
</a>     }
 
<a href="#h12-5-19" id="h12-5-19" class="d">-    /// Returns the node status.
</a><a href="#h12-5-20" id="h12-5-20" class="d">-    fn status(&amp;self) -&gt; Result&lt;Status, Error&gt; {
</a><a href="#h12-5-21" id="h12-5-21" class="d">-        let (entries, _) = self.log.get_last();
</a><a href="#h12-5-22" id="h12-5-22" class="d">-        let (committed, _) = self.log.get_committed();
</a><a href="#h12-5-23" id="h12-5-23" class="d">-        let (applied, _) = self.log.get_applied();
</a><a href="#h12-5-24" id="h12-5-24" class="d">-
</a><a href="#h12-5-25" id="h12-5-25" class="d">-        Ok(Status {
</a><a href="#h12-5-26" id="h12-5-26" class="d">-            id: self.id.clone(),
</a><a href="#h12-5-27" id="h12-5-27" class="d">-            role: &quot;&quot;.into(),
</a><a href="#h12-5-28" id="h12-5-28" class="d">-            leader: None,
</a><a href="#h12-5-29" id="h12-5-29" class="d">-            nodes: self.peers.len() as u64 + 1,
</a><a href="#h12-5-30" id="h12-5-30" class="d">-            term: self.term,
</a><a href="#h12-5-31" id="h12-5-31" class="d">-            entries,
</a><a href="#h12-5-32" id="h12-5-32" class="d">-            committed,
</a><a href="#h12-5-33" id="h12-5-33" class="d">-            applied,
</a><a href="#h12-5-34" id="h12-5-34" class="d">-        })
</a><a href="#h12-5-35" id="h12-5-35" class="i">+    /// Validates a message
</a><a href="#h12-5-36" id="h12-5-36" class="i">+    fn validate(&amp;self, msg: &amp;Message) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-5-37" id="h12-5-37" class="i">+        match msg.from {
</a><a href="#h12-5-38" id="h12-5-38" class="i">+            Address::Peers =&gt; return Err(Error::Internal(&quot;Message from broadcast address&quot;.into())),
</a><a href="#h12-5-39" id="h12-5-39" class="i">+            Address::Local =&gt; return Err(Error::Internal(&quot;Message from local node&quot;.into())),
</a><a href="#h12-5-40" id="h12-5-40" class="i">+            Address::Client if !matches!(msg.event, Event::ClientRequest{..}) =&gt; {
</a><a href="#h12-5-41" id="h12-5-41" class="i">+                return Err(Error::Internal(&quot;Non-request message from client&quot;.into()));
</a><a href="#h12-5-42" id="h12-5-42" class="i">+            }
</a><a href="#h12-5-43" id="h12-5-43" class="i">+            _ =&gt; {}
</a><a href="#h12-5-44" id="h12-5-44" class="i">+        }
</a><a href="#h12-5-45" id="h12-5-45" class="i">+
</a><a href="#h12-5-46" id="h12-5-46" class="i">+        // Allowing requests and responses form past terms is fine, since they don&#39;t rely on it
</a><a href="#h12-5-47" id="h12-5-47" class="i">+        if msg.term &lt; self.term
</a><a href="#h12-5-48" id="h12-5-48" class="i">+            &amp;&amp; !matches!(msg.event, Event::ClientRequest{..} | Event::ClientResponse{..})
</a><a href="#h12-5-49" id="h12-5-49" class="i">+        {
</a><a href="#h12-5-50" id="h12-5-50" class="i">+            return Err(Error::Internal(format!(&quot;Message from past term {}&quot;, self.term)));
</a><a href="#h12-5-51" id="h12-5-51" class="i">+        }
</a><a href="#h12-5-52" id="h12-5-52" class="i">+
</a><a href="#h12-5-53" id="h12-5-53" class="i">+        match &amp;msg.to {
</a><a href="#h12-5-54" id="h12-5-54" class="i">+            Address::Peer(id) if id == &amp;self.id =&gt; Ok(()),
</a><a href="#h12-5-55" id="h12-5-55" class="i">+            Address::Local =&gt; Ok(()),
</a><a href="#h12-5-56" id="h12-5-56" class="i">+            Address::Peers =&gt; Ok(()),
</a><a href="#h12-5-57" id="h12-5-57" class="i">+            Address::Peer(id) =&gt; {
</a><a href="#h12-5-58" id="h12-5-58" class="i">+                Err(Error::Internal(format!(&quot;Received message for other node {}&quot;, id)))
</a><a href="#h12-5-59" id="h12-5-59" class="i">+            }
</a><a href="#h12-5-60" id="h12-5-60" class="i">+            Address::Client =&gt; Err(Error::Internal(&quot;Received message for client&quot;.into())),
</a><a href="#h12-5-61" id="h12-5-61" class="i">+        }
</a>     }
 }
 
<a href="#h12-6" id="h12-6" class="h">@@ -224,9 +250,13 @@ mod tests {
</a>     use super::follower::tests::{follower_leader, follower_voted_for};
     use super::*;
     use crate::kv;
<a href="#h12-6-3" id="h12-6-3" class="d">-    use tokio::sync::mpsc::UnboundedReceiver;
</a><a href="#h12-6-4" id="h12-6-4" class="i">+    use pretty_assertions::assert_eq;
</a><a href="#h12-6-5" id="h12-6-5" class="i">+    use tokio::sync::mpsc;
</a> 
<a href="#h12-6-7" id="h12-6-7" class="d">-    pub fn assert_messages(rx: &amp;mut UnboundedReceiver&lt;Message&gt;, msgs: Vec&lt;Message&gt;) {
</a><a href="#h12-6-8" id="h12-6-8" class="i">+    pub fn assert_messages&lt;T: std::fmt::Debug + PartialEq&gt;(
</a><a href="#h12-6-9" id="h12-6-9" class="i">+        rx: &amp;mut mpsc::UnboundedReceiver&lt;T&gt;,
</a><a href="#h12-6-10" id="h12-6-10" class="i">+        msgs: Vec&lt;T&gt;,
</a><a href="#h12-6-11" id="h12-6-11" class="i">+    ) {
</a>         let mut actual = Vec::new();
         while let Ok(message) = rx.try_recv() {
             actual.push(message)
<a href="#h12-7" id="h12-7" class="h">@@ -234,12 +264,12 @@ mod tests {
</a>         assert_eq!(msgs, actual);
     }
 
<a href="#h12-7-3" id="h12-7-3" class="d">-    pub struct NodeAsserter&lt;&#39;a, L: Storage, S: State&gt; {
</a><a href="#h12-7-4" id="h12-7-4" class="d">-        node: &amp;&#39;a Node&lt;L, S&gt;,
</a><a href="#h12-7-5" id="h12-7-5" class="i">+    pub struct NodeAsserter&lt;&#39;a, L: Storage&gt; {
</a><a href="#h12-7-6" id="h12-7-6" class="i">+        node: &amp;&#39;a Node&lt;L&gt;,
</a>     }
 
<a href="#h12-7-9" id="h12-7-9" class="d">-    impl&lt;&#39;a, L: Storage, S: State&gt; NodeAsserter&lt;&#39;a, L, S&gt; {
</a><a href="#h12-7-10" id="h12-7-10" class="d">-        pub fn new(node: &amp;&#39;a Node&lt;L, S&gt;) -&gt; Self {
</a><a href="#h12-7-11" id="h12-7-11" class="i">+    impl&lt;&#39;a, L: Storage&gt; NodeAsserter&lt;&#39;a, L&gt; {
</a><a href="#h12-7-12" id="h12-7-12" class="i">+        pub fn new(node: &amp;&#39;a Node&lt;L&gt;) -&gt; Self {
</a>             Self { node }
         }
 
<a href="#h12-8" id="h12-8" class="h">@@ -251,12 +281,6 @@ mod tests {
</a>             }
         }
 
<a href="#h12-8-3" id="h12-8-3" class="d">-        pub fn applied(self, index: u64) -&gt; Self {
</a><a href="#h12-8-4" id="h12-8-4" class="d">-            let (apply_index, _) = self.log().get_applied();
</a><a href="#h12-8-5" id="h12-8-5" class="d">-            assert_eq!(index, apply_index, &quot;Unexpected applied index&quot;);
</a><a href="#h12-8-6" id="h12-8-6" class="d">-            self
</a><a href="#h12-8-7" id="h12-8-7" class="d">-        }
</a><a href="#h12-8-8" id="h12-8-8" class="d">-
</a>         pub fn committed(self, index: u64) -&gt; Self {
             let (commit_index, _) = self.log().get_committed();
             assert_eq!(index, commit_index, &quot;Unexpected committed index&quot;);
<a href="#h12-9" id="h12-9" class="h">@@ -269,10 +293,10 @@ mod tests {
</a>             self
         }
 
<a href="#h12-9-3" id="h12-9-3" class="d">-        pub fn entry(self, index: u64, entry: Entry) -&gt; Self {
</a><a href="#h12-9-4" id="h12-9-4" class="i">+        pub fn entry(self, entry: Entry) -&gt; Self {
</a>             let (last_index, _) = self.log().get_last();
<a href="#h12-9-6" id="h12-9-6" class="d">-            assert!(index &lt;= last_index, &quot;Index beyond last entry&quot;);
</a><a href="#h12-9-7" id="h12-9-7" class="d">-            assert_eq!(entry, self.log().get(index).unwrap().unwrap());
</a><a href="#h12-9-8" id="h12-9-8" class="i">+            assert!(entry.index &lt;= last_index, &quot;Index beyond last entry&quot;);
</a><a href="#h12-9-9" id="h12-9-9" class="i">+            assert_eq!(entry, self.log().get(entry.index).unwrap().unwrap());
</a>             self
         }
 
<a href="#h12-10" id="h12-10" class="h">@@ -321,6 +345,30 @@ mod tests {
</a>             self
         }
 
<a href="#h12-10-3" id="h12-10-3" class="i">+        pub fn proxied(self, proxied: Vec&lt;(Vec&lt;u8&gt;, Address)&gt;) -&gt; Self {
</a><a href="#h12-10-4" id="h12-10-4" class="i">+            assert_eq!(
</a><a href="#h12-10-5" id="h12-10-5" class="i">+                &amp;proxied.into_iter().collect::&lt;HashMap&lt;Vec&lt;u8&gt;, Address&gt;&gt;(),
</a><a href="#h12-10-6" id="h12-10-6" class="i">+                match self.node {
</a><a href="#h12-10-7" id="h12-10-7" class="i">+                    Node::Candidate(n) =&gt; &amp;n.proxied_reqs,
</a><a href="#h12-10-8" id="h12-10-8" class="i">+                    Node::Follower(n) =&gt; &amp;n.proxied_reqs,
</a><a href="#h12-10-9" id="h12-10-9" class="i">+                    Node::Leader(n) =&gt; &amp;n.proxied_reqs,
</a><a href="#h12-10-10" id="h12-10-10" class="i">+                }
</a><a href="#h12-10-11" id="h12-10-11" class="i">+            );
</a><a href="#h12-10-12" id="h12-10-12" class="i">+            self
</a><a href="#h12-10-13" id="h12-10-13" class="i">+        }
</a><a href="#h12-10-14" id="h12-10-14" class="i">+
</a><a href="#h12-10-15" id="h12-10-15" class="i">+        pub fn queued(self, queued: Vec&lt;(Address, Event)&gt;) -&gt; Self {
</a><a href="#h12-10-16" id="h12-10-16" class="i">+            assert_eq!(
</a><a href="#h12-10-17" id="h12-10-17" class="i">+                &amp;queued,
</a><a href="#h12-10-18" id="h12-10-18" class="i">+                match self.node {
</a><a href="#h12-10-19" id="h12-10-19" class="i">+                    Node::Candidate(n) =&gt; &amp;n.queued_reqs,
</a><a href="#h12-10-20" id="h12-10-20" class="i">+                    Node::Follower(n) =&gt; &amp;n.queued_reqs,
</a><a href="#h12-10-21" id="h12-10-21" class="i">+                    Node::Leader(n) =&gt; &amp;n.queued_reqs,
</a><a href="#h12-10-22" id="h12-10-22" class="i">+                }
</a><a href="#h12-10-23" id="h12-10-23" class="i">+            );
</a><a href="#h12-10-24" id="h12-10-24" class="i">+            self
</a><a href="#h12-10-25" id="h12-10-25" class="i">+        }
</a><a href="#h12-10-26" id="h12-10-26" class="i">+
</a>         pub fn term(self, term: u64) -&gt; Self {
             assert_eq!(
                 term,
<a href="#h12-11" id="h12-11" class="h">@@ -361,45 +409,47 @@ mod tests {
</a>         }
     }
 
<a href="#h12-11-3" id="h12-11-3" class="d">-    pub fn assert_node&lt;L: Storage, S: State&gt;(node: &amp;Node&lt;L, S&gt;) -&gt; NodeAsserter&lt;L, S&gt; {
</a><a href="#h12-11-4" id="h12-11-4" class="i">+    pub fn assert_node&lt;L: Storage&gt;(node: &amp;Node&lt;L&gt;) -&gt; NodeAsserter&lt;L&gt; {
</a>         NodeAsserter::new(node)
     }
 
     #[allow(clippy::type_complexity)]
     fn setup_rolenode(
<a href="#h12-11-10" id="h12-11-10" class="d">-    ) -&gt; Result&lt;(RoleNode&lt;(), kv::storage::Test, TestState&gt;, UnboundedReceiver&lt;Message&gt;), Error&gt;
</a><a href="#h12-11-11" id="h12-11-11" class="d">-    {
</a><a href="#h12-11-12" id="h12-11-12" class="i">+    ) -&gt; Result&lt;(RoleNode&lt;(), kv::storage::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;), Error&gt; {
</a>         setup_rolenode_peers(vec![&quot;b&quot;.into(), &quot;c&quot;.into()])
     }
 
     #[allow(clippy::type_complexity)]
     fn setup_rolenode_peers(
         peers: Vec&lt;String&gt;,
<a href="#h12-11-19" id="h12-11-19" class="d">-    ) -&gt; Result&lt;(RoleNode&lt;(), kv::storage::Test, TestState&gt;, UnboundedReceiver&lt;Message&gt;), Error&gt;
</a><a href="#h12-11-20" id="h12-11-20" class="d">-    {
</a><a href="#h12-11-21" id="h12-11-21" class="d">-        let (sender, receiver) = tokio::sync::mpsc::unbounded_channel();
</a><a href="#h12-11-22" id="h12-11-22" class="i">+    ) -&gt; Result&lt;(RoleNode&lt;(), kv::storage::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;), Error&gt; {
</a><a href="#h12-11-23" id="h12-11-23" class="i">+        let (node_tx, node_rx) = mpsc::unbounded_channel();
</a><a href="#h12-11-24" id="h12-11-24" class="i">+        let (state_tx, _) = mpsc::unbounded_channel();
</a>         let node = RoleNode {
             role: (),
             id: &quot;a&quot;.into(),
             peers,
             term: 1,
             log: Log::new(kv::Simple::new(kv::storage::Test::new()))?,
<a href="#h12-11-31" id="h12-11-31" class="d">-            state: TestState::new(),
</a><a href="#h12-11-32" id="h12-11-32" class="d">-            sender,
</a><a href="#h12-11-33" id="h12-11-33" class="i">+            node_tx,
</a><a href="#h12-11-34" id="h12-11-34" class="i">+            state_tx,
</a><a href="#h12-11-35" id="h12-11-35" class="i">+            proxied_reqs: HashMap::new(),
</a><a href="#h12-11-36" id="h12-11-36" class="i">+            queued_reqs: Vec::new(),
</a>         };
<a href="#h12-11-38" id="h12-11-38" class="d">-        Ok((node, receiver))
</a><a href="#h12-11-39" id="h12-11-39" class="i">+        Ok((node, node_rx))
</a>     }
 
<a href="#h12-11-42" id="h12-11-42" class="d">-    #[test]
</a><a href="#h12-11-43" id="h12-11-43" class="d">-    fn new() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-11-44" id="h12-11-44" class="d">-        let (sender, _) = tokio::sync::mpsc::unbounded_channel();
</a><a href="#h12-11-45" id="h12-11-45" class="i">+    #[tokio::test]
</a><a href="#h12-11-46" id="h12-11-46" class="i">+    async fn new() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-11-47" id="h12-11-47" class="i">+        let (node_tx, _) = mpsc::unbounded_channel();
</a>         let node = Node::new(
             &quot;a&quot;,
             vec![&quot;b&quot;.into(), &quot;c&quot;.into()],
             Log::new(kv::Simple::new(kv::storage::Test::new()))?,
<a href="#h12-11-52" id="h12-11-52" class="d">-            TestState::new(),
</a><a href="#h12-11-53" id="h12-11-53" class="d">-            sender,
</a><a href="#h12-11-54" id="h12-11-54" class="d">-        )?;
</a><a href="#h12-11-55" id="h12-11-55" class="i">+            TestState::new(0),
</a><a href="#h12-11-56" id="h12-11-56" class="i">+            node_tx,
</a><a href="#h12-11-57" id="h12-11-57" class="i">+        )
</a><a href="#h12-11-58" id="h12-11-58" class="i">+        .await?;
</a>         match node {
             Node::Follower(rolenode) =&gt; {
                 assert_eq!(rolenode.id, &quot;a&quot;.to_owned());
<a href="#h12-12" id="h12-12" class="h">@@ -411,18 +461,19 @@ mod tests {
</a>         Ok(())
     }
 
<a href="#h12-12-3" id="h12-12-3" class="d">-    #[test]
</a><a href="#h12-12-4" id="h12-12-4" class="d">-    fn new_loads_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-12-5" id="h12-12-5" class="d">-        let (sender, _) = tokio::sync::mpsc::unbounded_channel();
</a><a href="#h12-12-6" id="h12-12-6" class="i">+    #[tokio::test]
</a><a href="#h12-12-7" id="h12-12-7" class="i">+    async fn new_loads_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-12-8" id="h12-12-8" class="i">+        let (node_tx, _) = mpsc::unbounded_channel();
</a>         let storage = kv::storage::Test::new();
         Log::new(kv::Simple::new(storage.clone()))?.save_term(3, Some(&quot;c&quot;))?;
         let node = Node::new(
             &quot;a&quot;,
             vec![&quot;b&quot;.into(), &quot;c&quot;.into()],
             Log::new(kv::Simple::new(storage))?,
<a href="#h12-12-15" id="h12-12-15" class="d">-            TestState::new(),
</a><a href="#h12-12-16" id="h12-12-16" class="d">-            sender,
</a><a href="#h12-12-17" id="h12-12-17" class="d">-        )?;
</a><a href="#h12-12-18" id="h12-12-18" class="i">+            TestState::new(0),
</a><a href="#h12-12-19" id="h12-12-19" class="i">+            node_tx,
</a><a href="#h12-12-20" id="h12-12-20" class="i">+        )
</a><a href="#h12-12-21" id="h12-12-21" class="i">+        .await?;
</a>         match node {
             Node::Follower(rolenode) =&gt; assert_eq!(rolenode.term, 3),
             _ =&gt; panic!(&quot;Expected node to start as follower&quot;),
<a href="#h12-13" id="h12-13" class="h">@@ -430,16 +481,73 @@ mod tests {
</a>         Ok(())
     }
 
<a href="#h12-13-3" id="h12-13-3" class="d">-    #[test]
</a><a href="#h12-13-4" id="h12-13-4" class="d">-    fn new_single() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-13-5" id="h12-13-5" class="d">-        let (sender, _) = tokio::sync::mpsc::unbounded_channel();
</a><a href="#h12-13-6" id="h12-13-6" class="i">+    #[tokio::test(core_threads = 2)]
</a><a href="#h12-13-7" id="h12-13-7" class="i">+    async fn new_state_apply_all() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-13-8" id="h12-13-8" class="i">+        let (node_tx, _) = mpsc::unbounded_channel();
</a><a href="#h12-13-9" id="h12-13-9" class="i">+        let mut log = Log::new(kv::Simple::new(kv::storage::Test::new()))?;
</a><a href="#h12-13-10" id="h12-13-10" class="i">+        log.append(1, Some(vec![0x01]))?;
</a><a href="#h12-13-11" id="h12-13-11" class="i">+        log.append(2, None)?;
</a><a href="#h12-13-12" id="h12-13-12" class="i">+        log.append(2, Some(vec![0x02]))?;
</a><a href="#h12-13-13" id="h12-13-13" class="i">+        log.commit(3)?;
</a><a href="#h12-13-14" id="h12-13-14" class="i">+        log.append(2, Some(vec![0x03]))?;
</a><a href="#h12-13-15" id="h12-13-15" class="i">+        let state = TestState::new(0);
</a><a href="#h12-13-16" id="h12-13-16" class="i">+
</a><a href="#h12-13-17" id="h12-13-17" class="i">+        Node::new(&quot;a&quot;, vec![&quot;b&quot;.into(), &quot;c&quot;.into()], log, state.clone(), node_tx).await?;
</a><a href="#h12-13-18" id="h12-13-18" class="i">+        tokio::time::delay_for(std::time::Duration::from_millis(100)).await;
</a><a href="#h12-13-19" id="h12-13-19" class="i">+        assert_eq!(state.list(), vec![vec![0x01], vec![0x02]]);
</a><a href="#h12-13-20" id="h12-13-20" class="i">+        assert_eq!(state.applied_index(), 3);
</a><a href="#h12-13-21" id="h12-13-21" class="i">+        Ok(())
</a><a href="#h12-13-22" id="h12-13-22" class="i">+    }
</a><a href="#h12-13-23" id="h12-13-23" class="i">+
</a><a href="#h12-13-24" id="h12-13-24" class="i">+    #[tokio::test(core_threads = 2)]
</a><a href="#h12-13-25" id="h12-13-25" class="i">+    async fn new_state_apply_partial() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-13-26" id="h12-13-26" class="i">+        let (node_tx, _) = mpsc::unbounded_channel();
</a><a href="#h12-13-27" id="h12-13-27" class="i">+        let mut log = Log::new(kv::Simple::new(kv::storage::Test::new()))?;
</a><a href="#h12-13-28" id="h12-13-28" class="i">+        log.append(1, Some(vec![0x01]))?;
</a><a href="#h12-13-29" id="h12-13-29" class="i">+        log.append(2, None)?;
</a><a href="#h12-13-30" id="h12-13-30" class="i">+        log.append(2, Some(vec![0x02]))?;
</a><a href="#h12-13-31" id="h12-13-31" class="i">+        log.commit(3)?;
</a><a href="#h12-13-32" id="h12-13-32" class="i">+        log.append(2, Some(vec![0x03]))?;
</a><a href="#h12-13-33" id="h12-13-33" class="i">+        let state = TestState::new(2);
</a><a href="#h12-13-34" id="h12-13-34" class="i">+
</a><a href="#h12-13-35" id="h12-13-35" class="i">+        Node::new(&quot;a&quot;, vec![&quot;b&quot;.into(), &quot;c&quot;.into()], log, state.clone(), node_tx).await?;
</a><a href="#h12-13-36" id="h12-13-36" class="i">+        tokio::time::delay_for(std::time::Duration::from_millis(100)).await;
</a><a href="#h12-13-37" id="h12-13-37" class="i">+        assert_eq!(state.list(), vec![vec![0x02]]);
</a><a href="#h12-13-38" id="h12-13-38" class="i">+        assert_eq!(state.applied_index(), 3);
</a><a href="#h12-13-39" id="h12-13-39" class="i">+        Ok(())
</a><a href="#h12-13-40" id="h12-13-40" class="i">+    }
</a><a href="#h12-13-41" id="h12-13-41" class="i">+
</a><a href="#h12-13-42" id="h12-13-42" class="i">+    #[tokio::test(core_threads = 2)]
</a><a href="#h12-13-43" id="h12-13-43" class="i">+    async fn new_state_apply_missing() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-13-44" id="h12-13-44" class="i">+        let (node_tx, _) = mpsc::unbounded_channel();
</a><a href="#h12-13-45" id="h12-13-45" class="i">+        let mut log = Log::new(kv::Simple::new(kv::storage::Test::new()))?;
</a><a href="#h12-13-46" id="h12-13-46" class="i">+        log.append(1, Some(vec![0x01]))?;
</a><a href="#h12-13-47" id="h12-13-47" class="i">+        log.append(2, None)?;
</a><a href="#h12-13-48" id="h12-13-48" class="i">+        log.append(2, Some(vec![0x02]))?;
</a><a href="#h12-13-49" id="h12-13-49" class="i">+        log.commit(3)?;
</a><a href="#h12-13-50" id="h12-13-50" class="i">+        log.append(2, Some(vec![0x03]))?;
</a><a href="#h12-13-51" id="h12-13-51" class="i">+        let state = TestState::new(4);
</a><a href="#h12-13-52" id="h12-13-52" class="i">+
</a><a href="#h12-13-53" id="h12-13-53" class="i">+        assert_eq!(
</a><a href="#h12-13-54" id="h12-13-54" class="i">+            Node::new(&quot;a&quot;, vec![&quot;b&quot;.into(), &quot;c&quot;.into()], log, state.clone(), node_tx).await.err(),
</a><a href="#h12-13-55" id="h12-13-55" class="i">+            Some(Error::Internal(
</a><a href="#h12-13-56" id="h12-13-56" class="i">+                &quot;State machine applied index 4 greater than log committed index 3&quot;.into()
</a><a href="#h12-13-57" id="h12-13-57" class="i">+            ))
</a><a href="#h12-13-58" id="h12-13-58" class="i">+        );
</a><a href="#h12-13-59" id="h12-13-59" class="i">+        Ok(())
</a><a href="#h12-13-60" id="h12-13-60" class="i">+    }
</a><a href="#h12-13-61" id="h12-13-61" class="i">+
</a><a href="#h12-13-62" id="h12-13-62" class="i">+    #[tokio::test]
</a><a href="#h12-13-63" id="h12-13-63" class="i">+    async fn new_single() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-13-64" id="h12-13-64" class="i">+        let (node_tx, _) = mpsc::unbounded_channel();
</a>         let node = Node::new(
             &quot;a&quot;,
             vec![],
             Log::new(kv::Simple::new(kv::storage::Test::new()))?,
<a href="#h12-13-69" id="h12-13-69" class="d">-            TestState::new(),
</a><a href="#h12-13-70" id="h12-13-70" class="d">-            sender,
</a><a href="#h12-13-71" id="h12-13-71" class="d">-        )?;
</a><a href="#h12-13-72" id="h12-13-72" class="i">+            TestState::new(0),
</a><a href="#h12-13-73" id="h12-13-73" class="i">+            node_tx,
</a><a href="#h12-13-74" id="h12-13-74" class="i">+        )
</a><a href="#h12-13-75" id="h12-13-75" class="i">+        .await?;
</a>         match node {
             Node::Leader(rolenode) =&gt; {
                 assert_eq!(rolenode.id, &quot;a&quot;.to_owned());
<a href="#h12-14" id="h12-14" class="h">@@ -463,51 +571,6 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h12-14-3" id="h12-14-3" class="d">-    fn broadcast() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-14-4" id="h12-14-4" class="d">-        let (node, mut rx) = setup_rolenode()?;
</a><a href="#h12-14-5" id="h12-14-5" class="d">-        node.broadcast(Event::Heartbeat { commit_index: 1, commit_term: 1 })?;
</a><a href="#h12-14-6" id="h12-14-6" class="d">-
</a><a href="#h12-14-7" id="h12-14-7" class="d">-        for to in [&quot;b&quot;, &quot;c&quot;].iter().cloned() {
</a><a href="#h12-14-8" id="h12-14-8" class="d">-            assert_eq!(
</a><a href="#h12-14-9" id="h12-14-9" class="d">-                rx.try_recv()?,
</a><a href="#h12-14-10" id="h12-14-10" class="d">-                Message {
</a><a href="#h12-14-11" id="h12-14-11" class="d">-                    from: Some(&quot;a&quot;.into()),
</a><a href="#h12-14-12" id="h12-14-12" class="d">-                    to: Some(to.into()),
</a><a href="#h12-14-13" id="h12-14-13" class="d">-                    term: 1,
</a><a href="#h12-14-14" id="h12-14-14" class="d">-                    event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
</a><a href="#h12-14-15" id="h12-14-15" class="d">-                },
</a><a href="#h12-14-16" id="h12-14-16" class="d">-            )
</a><a href="#h12-14-17" id="h12-14-17" class="d">-        }
</a><a href="#h12-14-18" id="h12-14-18" class="d">-        assert_messages(&amp;mut rx, vec![]);
</a><a href="#h12-14-19" id="h12-14-19" class="d">-        Ok(())
</a><a href="#h12-14-20" id="h12-14-20" class="d">-    }
</a><a href="#h12-14-21" id="h12-14-21" class="d">-
</a><a href="#h12-14-22" id="h12-14-22" class="d">-    #[test]
</a><a href="#h12-14-23" id="h12-14-23" class="d">-    fn normalize_message() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-14-24" id="h12-14-24" class="d">-        let (node, _) = setup_rolenode()?;
</a><a href="#h12-14-25" id="h12-14-25" class="d">-        let mut msg = Message {
</a><a href="#h12-14-26" id="h12-14-26" class="d">-            from: None,
</a><a href="#h12-14-27" id="h12-14-27" class="d">-            to: None,
</a><a href="#h12-14-28" id="h12-14-28" class="d">-            term: 0,
</a><a href="#h12-14-29" id="h12-14-29" class="d">-            event: Event::QueryState { call_id: vec![], command: vec![] },
</a><a href="#h12-14-30" id="h12-14-30" class="d">-        };
</a><a href="#h12-14-31" id="h12-14-31" class="d">-        assert!(node.normalize_message(&amp;mut msg));
</a><a href="#h12-14-32" id="h12-14-32" class="d">-        assert_eq!(
</a><a href="#h12-14-33" id="h12-14-33" class="d">-            msg,
</a><a href="#h12-14-34" id="h12-14-34" class="d">-            Message {
</a><a href="#h12-14-35" id="h12-14-35" class="d">-                from: None,
</a><a href="#h12-14-36" id="h12-14-36" class="d">-                to: Some(&quot;a&quot;.into()),
</a><a href="#h12-14-37" id="h12-14-37" class="d">-                term: 1,
</a><a href="#h12-14-38" id="h12-14-38" class="d">-                event: Event::QueryState { call_id: vec![], command: vec![] },
</a><a href="#h12-14-39" id="h12-14-39" class="d">-            }
</a><a href="#h12-14-40" id="h12-14-40" class="d">-        );
</a><a href="#h12-14-41" id="h12-14-41" class="d">-
</a><a href="#h12-14-42" id="h12-14-42" class="d">-        msg.to = Some(&quot;c&quot;.into());
</a><a href="#h12-14-43" id="h12-14-43" class="d">-        assert!(!node.normalize_message(&amp;mut msg));
</a><a href="#h12-14-44" id="h12-14-44" class="d">-        Ok(())
</a><a href="#h12-14-45" id="h12-14-45" class="d">-    }
</a><a href="#h12-14-46" id="h12-14-46" class="d">-
</a><a href="#h12-14-47" id="h12-14-47" class="d">-    #[test]
</a>     fn quorum() -&gt; Result&lt;(), Error&gt; {
         let quorums = vec![(1, 1), (2, 2), (3, 2), (4, 3), (5, 3), (6, 4), (7, 4), (8, 5)];
         for (size, quorum) in quorums.into_iter() {
<a href="#h12-15" id="h12-15" class="h">@@ -523,12 +586,12 @@ mod tests {
</a>     #[test]
     fn send() -&gt; Result&lt;(), Error&gt; {
         let (node, mut rx) = setup_rolenode()?;
<a href="#h12-15-3" id="h12-15-3" class="d">-        node.send(Some(&quot;b&quot;), Event::Heartbeat { commit_index: 1, commit_term: 1 })?;
</a><a href="#h12-15-4" id="h12-15-4" class="i">+        node.send(Address::Peer(&quot;b&quot;.into()), Event::Heartbeat { commit_index: 1, commit_term: 1 })?;
</a>         assert_messages(
             &amp;mut rx,
             vec![Message {
<a href="#h12-15-8" id="h12-15-8" class="d">-                from: Some(&quot;a&quot;.into()),
</a><a href="#h12-15-9" id="h12-15-9" class="d">-                to: Some(&quot;b&quot;.into()),
</a><a href="#h12-15-10" id="h12-15-10" class="i">+                from: Address::Local,
</a><a href="#h12-15-11" id="h12-15-11" class="i">+                to: Address::Peer(&quot;b&quot;.into()),
</a>                 term: 1,
                 event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
             }],
<b>diff --git a/<a id="h13" href="../file/src/raft/server.rs.html">src/raft/server.rs</a> b/<a href="../file/src/raft/server.rs.html">src/raft/server.rs</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h13-0-0" id="h13-0-0" class="d">-use super::{Client, Event, Log, Message, Node, Request, Response, State};
</a><a href="#h13-0-1" id="h13-0-1" class="i">+use super::{Address, Event, Log, Message, Node, Request, Response, State};
</a> use crate::kv::storage::Storage;
 use crate::Error;
 
<a href="#h13-1" id="h13-1" class="h">@@ -16,29 +16,21 @@ use uuid::Uuid;
</a> const TICK: Duration = Duration::from_millis(100);
 
 /// A Raft server.
<a href="#h13-1-3" id="h13-1-3" class="d">-pub struct Server&lt;L: Storage, S: State&gt; {
</a><a href="#h13-1-4" id="h13-1-4" class="d">-    /// The local Raft node.
</a><a href="#h13-1-5" id="h13-1-5" class="d">-    node: Node&lt;L, S&gt;,
</a><a href="#h13-1-6" id="h13-1-6" class="d">-    /// Raft peers (node ID and network address).
</a><a href="#h13-1-7" id="h13-1-7" class="i">+pub struct Server&lt;L: Storage&gt; {
</a><a href="#h13-1-8" id="h13-1-8" class="i">+    node: Node&lt;L&gt;,
</a>     peers: HashMap&lt;String, String&gt;,
<a href="#h13-1-10" id="h13-1-10" class="d">-    /// Outbound messages from local node.
</a>     node_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
<a href="#h13-1-12" id="h13-1-12" class="d">-    /// Clients send requests via this endpoint.
</a><a href="#h13-1-13" id="h13-1-13" class="d">-    client_tx: mpsc::UnboundedSender&lt;(Request, oneshot::Sender&lt;Response&gt;)&gt;,
</a><a href="#h13-1-14" id="h13-1-14" class="d">-    /// Cluster receives client requests via this endpoint.
</a><a href="#h13-1-15" id="h13-1-15" class="d">-    client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Response&gt;)&gt;,
</a> }
 
<a href="#h13-1-18" id="h13-1-18" class="d">-impl&lt;L: Storage + Send + &#39;static, S: State + Send + &#39;static&gt; Server&lt;L, S&gt; {
</a><a href="#h13-1-19" id="h13-1-19" class="i">+impl&lt;L: Storage + Send + &#39;static&gt; Server&lt;L&gt; {
</a>     /// Creates a new Raft cluster
<a href="#h13-1-21" id="h13-1-21" class="d">-    pub fn new(
</a><a href="#h13-1-22" id="h13-1-22" class="i">+    pub async fn new&lt;S: State + Send + &#39;static&gt;(
</a>         id: &amp;str,
         peers: HashMap&lt;String, String&gt;,
         log: Log&lt;L&gt;,
         state: S,
     ) -&gt; Result&lt;Self, Error&gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
<a href="#h13-1-29" id="h13-1-29" class="d">-        let (client_tx, client_rx) = mpsc::unbounded_channel();
</a>         Ok(Self {
             node: Node::new(
                 id,
<a href="#h13-2" id="h13-2" class="h">@@ -46,29 +38,28 @@ impl&lt;L: Storage + Send + &#39;static, S: State + Send + &#39;static&gt; Server&lt;L, S&gt; {
</a>                 log,
                 state,
                 node_tx,
<a href="#h13-2-3" id="h13-2-3" class="d">-            )?,
</a><a href="#h13-2-4" id="h13-2-4" class="i">+            )
</a><a href="#h13-2-5" id="h13-2-5" class="i">+            .await?,
</a>             peers,
             node_rx,
<a href="#h13-2-8" id="h13-2-8" class="d">-            client_tx,
</a><a href="#h13-2-9" id="h13-2-9" class="d">-            client_rx,
</a>         })
     }
 
<a href="#h13-2-13" id="h13-2-13" class="d">-    /// Returns a client for this Raft cluster.
</a><a href="#h13-2-14" id="h13-2-14" class="d">-    pub async fn client(&amp;self) -&gt; Client {
</a><a href="#h13-2-15" id="h13-2-15" class="d">-        Client::new(self.client_tx.clone()).await
</a><a href="#h13-2-16" id="h13-2-16" class="d">-    }
</a><a href="#h13-2-17" id="h13-2-17" class="d">-
</a>     /// Connects to peers and serves requests.
<a href="#h13-2-19" id="h13-2-19" class="d">-    pub async fn serve(self, listener: TcpListener) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h13-2-20" id="h13-2-20" class="d">-        let (tcp_in_tx, tcp_in_rx) = mpsc::channel::&lt;Message&gt;(100);
</a><a href="#h13-2-21" id="h13-2-21" class="d">-        let (tcp_out_tx, tcp_out_rx) = mpsc::channel::&lt;Message&gt;(100);
</a><a href="#h13-2-22" id="h13-2-22" class="i">+    pub async fn serve(
</a><a href="#h13-2-23" id="h13-2-23" class="i">+        self,
</a><a href="#h13-2-24" id="h13-2-24" class="i">+        listener: TcpListener,
</a><a href="#h13-2-25" id="h13-2-25" class="i">+        client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;)&gt;,
</a><a href="#h13-2-26" id="h13-2-26" class="i">+    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h13-2-27" id="h13-2-27" class="i">+        let (tcp_in_tx, tcp_in_rx) = mpsc::unbounded_channel::&lt;Message&gt;();
</a><a href="#h13-2-28" id="h13-2-28" class="i">+        let (tcp_out_tx, tcp_out_rx) = mpsc::unbounded_channel::&lt;Message&gt;();
</a>         let (task, tcp_receiver) = Self::tcp_receive(listener, tcp_in_tx).remote_handle();
         tokio::spawn(task);
<a href="#h13-2-31" id="h13-2-31" class="d">-        let (task, tcp_sender) = Self::tcp_send(self.peers, tcp_out_rx).remote_handle();
</a><a href="#h13-2-32" id="h13-2-32" class="i">+        let (task, tcp_sender) =
</a><a href="#h13-2-33" id="h13-2-33" class="i">+            Self::tcp_send(self.node.id(), self.peers, tcp_out_rx).remote_handle();
</a>         tokio::spawn(task);
         let (task, eventloop) =
<a href="#h13-2-36" id="h13-2-36" class="d">-            Self::eventloop(self.node, self.node_rx, self.client_rx, tcp_in_rx, tcp_out_tx)
</a><a href="#h13-2-37" id="h13-2-37" class="i">+            Self::eventloop(self.node, self.node_rx, client_rx, tcp_in_rx, tcp_out_tx)
</a>                 .remote_handle();
         tokio::spawn(task);
 
<a href="#h13-3" id="h13-3" class="h">@@ -78,52 +69,44 @@ impl&lt;L: Storage + Send + &#39;static, S: State + Send + &#39;static&gt; Server&lt;L, S&gt; {
</a> 
     /// Runs the event loop.
     async fn eventloop(
<a href="#h13-3-3" id="h13-3-3" class="d">-        mut node: Node&lt;L, S&gt;,
</a><a href="#h13-3-4" id="h13-3-4" class="i">+        mut node: Node&lt;L&gt;,
</a>         mut node_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
<a href="#h13-3-6" id="h13-3-6" class="d">-        mut client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Response&gt;)&gt;,
</a><a href="#h13-3-7" id="h13-3-7" class="d">-        mut tcp_rx: mpsc::Receiver&lt;Message&gt;,
</a><a href="#h13-3-8" id="h13-3-8" class="d">-        mut tcp_tx: mpsc::Sender&lt;Message&gt;,
</a><a href="#h13-3-9" id="h13-3-9" class="i">+        mut client_rx: mpsc::UnboundedReceiver&lt;(Request, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;)&gt;,
</a><a href="#h13-3-10" id="h13-3-10" class="i">+        mut tcp_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
</a><a href="#h13-3-11" id="h13-3-11" class="i">+        tcp_tx: mpsc::UnboundedSender&lt;Message&gt;,
</a>     ) -&gt; Result&lt;(), Error&gt; {
         let mut ticker = tokio::time::interval(TICK);
<a href="#h13-3-14" id="h13-3-14" class="d">-        let mut requests = HashMap::&lt;Vec&lt;u8&gt;, oneshot::Sender&lt;Response&gt;&gt;::new();
</a><a href="#h13-3-15" id="h13-3-15" class="i">+        let mut requests = HashMap::&lt;Vec&lt;u8&gt;, oneshot::Sender&lt;Result&lt;Response, Error&gt;&gt;&gt;::new();
</a>         loop {
<a href="#h13-3-17" id="h13-3-17" class="d">-            // FIXME Node.step() is blocking
</a>             tokio::select! {
                 _ = ticker.tick() =&gt; node = node.tick()?,
 
                 Some(msg) = tcp_rx.next() =&gt; node = node.step(msg)?,
 
                 Some(msg) = node_rx.next() =&gt; {
<a href="#h13-3-24" id="h13-3-24" class="d">-                    if msg.to.is_some() {
</a><a href="#h13-3-25" id="h13-3-25" class="d">-                        tcp_tx.send(msg).await?
</a><a href="#h13-3-26" id="h13-3-26" class="d">-                    } else if let Some(call_id) = msg.event.call_id() {
</a><a href="#h13-3-27" id="h13-3-27" class="d">-                        if let Some(response_tx) = requests.remove(&amp;call_id) {
</a><a href="#h13-3-28" id="h13-3-28" class="d">-                            let response = match msg.event {
</a><a href="#h13-3-29" id="h13-3-29" class="d">-                                Event::RespondState{response, ..} =&gt; Response::State(response),
</a><a href="#h13-3-30" id="h13-3-30" class="d">-                                Event::RespondError{error, ..} =&gt; Response::Error(error),
</a><a href="#h13-3-31" id="h13-3-31" class="d">-                                e =&gt; return Err(Error::Internal(format!(&quot;Unexpected Raft response {:?}&quot;, e))),
</a><a href="#h13-3-32" id="h13-3-32" class="d">-                            };
</a><a href="#h13-3-33" id="h13-3-33" class="d">-                            response_tx
</a><a href="#h13-3-34" id="h13-3-34" class="d">-                                .send(response)
</a><a href="#h13-3-35" id="h13-3-35" class="d">-                                .map_err(|e| Error::Internal(format!(&quot;Failed to send response {:?}&quot;, e)))?;
</a><a href="#h13-3-36" id="h13-3-36" class="i">+                    match msg {
</a><a href="#h13-3-37" id="h13-3-37" class="i">+                        Message{to: Address::Peer(_), ..} =&gt; tcp_tx.send(msg)?,
</a><a href="#h13-3-38" id="h13-3-38" class="i">+                        Message{to: Address::Peers, ..} =&gt; tcp_tx.send(msg)?,
</a><a href="#h13-3-39" id="h13-3-39" class="i">+                        Message{to: Address::Client, event: Event::ClientResponse{ id, response }, ..} =&gt; {
</a><a href="#h13-3-40" id="h13-3-40" class="i">+                            if let Some(response_tx) = requests.remove(&amp;id) {
</a><a href="#h13-3-41" id="h13-3-41" class="i">+                                response_tx
</a><a href="#h13-3-42" id="h13-3-42" class="i">+                                    .send(response)
</a><a href="#h13-3-43" id="h13-3-43" class="i">+                                    .map_err(|e| Error::Internal(format!(&quot;Failed to send response {:?}&quot;, e)))?;
</a><a href="#h13-3-44" id="h13-3-44" class="i">+                            }
</a>                         }
<a href="#h13-3-46" id="h13-3-46" class="i">+                        _ =&gt; return Err(Error::Internal(format!(&quot;Unexpected message {:?}&quot;, msg))),
</a>                     }
                 }
 
                 Some((request, response_tx)) = client_rx.next() =&gt; {
<a href="#h13-3-51" id="h13-3-51" class="d">-                    if let Request::Status = request {
</a><a href="#h13-3-52" id="h13-3-52" class="d">-                        response_tx.send(Response::Status(node.status()?))
</a><a href="#h13-3-53" id="h13-3-53" class="d">-                            .map_err(|e| Error::Internal(format!(&quot;Failed to send response {:?}&quot;, e)))?;
</a><a href="#h13-3-54" id="h13-3-54" class="d">-                        continue
</a><a href="#h13-3-55" id="h13-3-55" class="d">-                    }
</a><a href="#h13-3-56" id="h13-3-56" class="d">-                    let call_id = Uuid::new_v4().as_bytes().to_vec();
</a><a href="#h13-3-57" id="h13-3-57" class="d">-                    requests.insert(call_id.clone(), response_tx);
</a><a href="#h13-3-58" id="h13-3-58" class="d">-                    let event = match request {
</a><a href="#h13-3-59" id="h13-3-59" class="d">-                        Request::Mutate(command) =&gt; Event::MutateState{call_id, command},
</a><a href="#h13-3-60" id="h13-3-60" class="d">-                        Request::Query(command) =&gt; Event::QueryState{call_id, command},
</a><a href="#h13-3-61" id="h13-3-61" class="d">-                        Request::Status =&gt; panic!(&quot;unexpected status request&quot;),
</a><a href="#h13-3-62" id="h13-3-62" class="d">-                    };
</a><a href="#h13-3-63" id="h13-3-63" class="d">-                    node = node.step(Message{from: None, to: None, term: 0, event})?;
</a><a href="#h13-3-64" id="h13-3-64" class="i">+                    let id = Uuid::new_v4().as_bytes().to_vec();
</a><a href="#h13-3-65" id="h13-3-65" class="i">+                    requests.insert(id.clone(), response_tx);
</a><a href="#h13-3-66" id="h13-3-66" class="i">+                    node = node.step(Message{
</a><a href="#h13-3-67" id="h13-3-67" class="i">+                        from: Address::Client,
</a><a href="#h13-3-68" id="h13-3-68" class="i">+                        to: Address::Local,
</a><a href="#h13-3-69" id="h13-3-69" class="i">+                        term: 0,
</a><a href="#h13-3-70" id="h13-3-70" class="i">+                        event: Event::ClientRequest{id, request},
</a><a href="#h13-3-71" id="h13-3-71" class="i">+                    })?;
</a>                 }
             }
         }
<a href="#h13-4" id="h13-4" class="h">@@ -132,7 +115,7 @@ impl&lt;L: Storage + Send + &#39;static, S: State + Send + &#39;static&gt; Server&lt;L, S&gt; {
</a>     /// Receives inbound messages from peers via TCP.
     async fn tcp_receive(
         mut listener: TcpListener,
<a href="#h13-4-3" id="h13-4-3" class="d">-        in_tx: mpsc::Sender&lt;Message&gt;,
</a><a href="#h13-4-4" id="h13-4-4" class="i">+        in_tx: mpsc::UnboundedSender&lt;Message&gt;,
</a>     ) -&gt; Result&lt;(), Error&gt; {
         while let Some(socket) = listener.try_next().await? {
             let peer = socket.peer_addr()?;
<a href="#h13-5" id="h13-5" class="h">@@ -151,36 +134,55 @@ impl&lt;L: Storage + Send + &#39;static, S: State + Send + &#39;static&gt; Server&lt;L, S&gt; {
</a>     /// Receives inbound messages from a peer via TCP.
     async fn tcp_receive_peer(
         socket: TcpStream,
<a href="#h13-5-3" id="h13-5-3" class="d">-        mut in_tx: mpsc::Sender&lt;Message&gt;,
</a><a href="#h13-5-4" id="h13-5-4" class="i">+        in_tx: mpsc::UnboundedSender&lt;Message&gt;,
</a>     ) -&gt; Result&lt;(), Error&gt; {
         let mut stream = tokio_serde::SymmetricallyFramed::&lt;_, Message, _&gt;::new(
             Framed::new(socket, LengthDelimitedCodec::new()),
             tokio_serde::formats::SymmetricalCbor::&lt;Message&gt;::default(),
         );
         while let Some(message) = stream.try_next().await? {
<a href="#h13-5-11" id="h13-5-11" class="d">-            in_tx.send(message).await?;
</a><a href="#h13-5-12" id="h13-5-12" class="i">+            in_tx.send(message)?;
</a>         }
         Ok(())
     }
 
     /// Sends outbound messages to peers via TCP.
     async fn tcp_send(
<a href="#h13-5-19" id="h13-5-19" class="i">+        node_id: String,
</a>         peers: HashMap&lt;String, String&gt;,
<a href="#h13-5-21" id="h13-5-21" class="d">-        mut out_rx: mpsc::Receiver&lt;Message&gt;,
</a><a href="#h13-5-22" id="h13-5-22" class="i">+        mut out_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
</a>     ) -&gt; Result&lt;(), Error&gt; {
         let mut peer_txs: HashMap&lt;String, mpsc::Sender&lt;Message&gt;&gt; = HashMap::new();
<a href="#h13-5-25" id="h13-5-25" class="i">+
</a>         for (id, addr) in peers.into_iter() {
<a href="#h13-5-27" id="h13-5-27" class="d">-            let (tx, rx) = mpsc::channel::&lt;Message&gt;(100);
</a><a href="#h13-5-28" id="h13-5-28" class="i">+            let (tx, rx) = mpsc::channel::&lt;Message&gt;(1000);
</a>             peer_txs.insert(id, tx);
             tokio::spawn(Self::tcp_send_peer(addr, rx));
         }
<a href="#h13-5-32" id="h13-5-32" class="d">-        while let Some(message) = out_rx.next().await {
</a><a href="#h13-5-33" id="h13-5-33" class="d">-            match message.to {
</a><a href="#h13-5-34" id="h13-5-34" class="d">-                None =&gt; error!(&quot;Received outbound message with no recipient&quot;),
</a><a href="#h13-5-35" id="h13-5-35" class="d">-                Some(ref to) =&gt; match peer_txs.get_mut(to) {
</a><a href="#h13-5-36" id="h13-5-36" class="d">-                    Some(ref mut tx) =&gt; tx.send(message).await?,
</a><a href="#h13-5-37" id="h13-5-37" class="d">-                    None =&gt; error!(&quot;Received outbound message for unknown peer {}&quot;, to),
</a><a href="#h13-5-38" id="h13-5-38" class="d">-                },
</a><a href="#h13-5-39" id="h13-5-39" class="i">+
</a><a href="#h13-5-40" id="h13-5-40" class="i">+        while let Some(mut message) = out_rx.next().await {
</a><a href="#h13-5-41" id="h13-5-41" class="i">+            if message.from == Address::Local {
</a><a href="#h13-5-42" id="h13-5-42" class="i">+                message.from = Address::Peer(node_id.clone())
</a><a href="#h13-5-43" id="h13-5-43" class="i">+            }
</a><a href="#h13-5-44" id="h13-5-44" class="i">+            let to = match &amp;message.to {
</a><a href="#h13-5-45" id="h13-5-45" class="i">+                Address::Peers =&gt; peer_txs.keys().cloned().collect(),
</a><a href="#h13-5-46" id="h13-5-46" class="i">+                Address::Peer(peer) =&gt; vec![peer.to_string()],
</a><a href="#h13-5-47" id="h13-5-47" class="i">+                addr =&gt; {
</a><a href="#h13-5-48" id="h13-5-48" class="i">+                    error!(&quot;Received outbound message for non-TCP address {:?}&quot;, addr);
</a><a href="#h13-5-49" id="h13-5-49" class="i">+                    continue;
</a><a href="#h13-5-50" id="h13-5-50" class="i">+                }
</a><a href="#h13-5-51" id="h13-5-51" class="i">+            };
</a><a href="#h13-5-52" id="h13-5-52" class="i">+            for id in to {
</a><a href="#h13-5-53" id="h13-5-53" class="i">+                match peer_txs.get_mut(&amp;id) {
</a><a href="#h13-5-54" id="h13-5-54" class="i">+                    Some(tx) =&gt; match tx.try_send(message.clone()) {
</a><a href="#h13-5-55" id="h13-5-55" class="i">+                        Ok(()) =&gt; {}
</a><a href="#h13-5-56" id="h13-5-56" class="i">+                        Err(mpsc::error::TrySendError::Full(_)) =&gt; {
</a><a href="#h13-5-57" id="h13-5-57" class="i">+                            debug!(&quot;Full send buffer for peer {}, discarding message&quot;, id)
</a><a href="#h13-5-58" id="h13-5-58" class="i">+                        }
</a><a href="#h13-5-59" id="h13-5-59" class="i">+                        Err(error) =&gt; return Err(error.into()),
</a><a href="#h13-5-60" id="h13-5-60" class="i">+                    },
</a><a href="#h13-5-61" id="h13-5-61" class="i">+                    None =&gt; error!(&quot;Received outbound message for unknown peer {}&quot;, id),
</a><a href="#h13-5-62" id="h13-5-62" class="i">+                }
</a>             }
         }
         Ok(())
<a href="#h13-6" id="h13-6" class="h">@@ -197,7 +199,7 @@ impl&lt;L: Storage + Send + &#39;static, S: State + Send + &#39;static&gt; Server&lt;L, S&gt; {
</a>                         Err(err) =&gt; error!(&quot;Failed sending to Raft peer {}: {}&quot;, addr, err),
                     }
                 }
<a href="#h13-6-3" id="h13-6-3" class="d">-                Err(err) =&gt; error!(&quot;Failed to connect to Raft peer {}: {}&quot;, addr, err),
</a><a href="#h13-6-4" id="h13-6-4" class="i">+                Err(err) =&gt; error!(&quot;Failed connecting to Raft peer {}: {}&quot;, addr, err),
</a>             }
             tokio::time::delay_for(Duration::from_millis(1000)).await;
         }
<b>diff --git a/<a id="h14" href="../file/src/raft/state.rs.html">src/raft/state.rs</a> b/<a href="../file/src/raft/state.rs.html">src/raft/state.rs</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -1,28 +1,240 @@
</a><a href="#h14-0-0" id="h14-0-0" class="i">+use super::{Address, Entry, Event, Message, Response, Status};
</a> use crate::Error;
 
<a href="#h14-0-3" id="h14-0-3" class="i">+use log::{debug, error};
</a><a href="#h14-0-4" id="h14-0-4" class="i">+use std::collections::{BTreeMap, HashMap, HashSet};
</a><a href="#h14-0-5" id="h14-0-5" class="i">+use tokio::stream::StreamExt as _;
</a><a href="#h14-0-6" id="h14-0-6" class="i">+use tokio::sync::mpsc;
</a><a href="#h14-0-7" id="h14-0-7" class="i">+
</a> /// A Raft-managed state machine.
 pub trait State {
<a href="#h14-0-10" id="h14-0-10" class="i">+    /// Returns the last applied index from the state machine, used when initializing the driver.
</a><a href="#h14-0-11" id="h14-0-11" class="i">+    fn applied_index(&amp;self) -&gt; u64;
</a><a href="#h14-0-12" id="h14-0-12" class="i">+
</a>     /// Mutates the state machine. If the state machine returns Error::Internal, the Raft node
     /// halts. For any other error, the state is applied and the error propagated to the caller.
<a href="#h14-0-15" id="h14-0-15" class="d">-    fn mutate(&amp;mut self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
</a><a href="#h14-0-16" id="h14-0-16" class="i">+    fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
</a> 
     /// Queries the state machine. All errors are propagated to the caller.
     fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt;;
 }
 
<a href="#h14-0-22" id="h14-0-22" class="i">+#[derive(Debug, PartialEq)]
</a><a href="#h14-0-23" id="h14-0-23" class="i">+/// A driver instruction.
</a><a href="#h14-0-24" id="h14-0-24" class="i">+pub enum Instruction {
</a><a href="#h14-0-25" id="h14-0-25" class="i">+    /// Abort all pending operations, e.g. due to leader change.
</a><a href="#h14-0-26" id="h14-0-26" class="i">+    Abort,
</a><a href="#h14-0-27" id="h14-0-27" class="i">+    /// Apply a log entry.
</a><a href="#h14-0-28" id="h14-0-28" class="i">+    Apply { entry: Entry },
</a><a href="#h14-0-29" id="h14-0-29" class="i">+    /// Notify the given address with the result of applying the entry at the given index.
</a><a href="#h14-0-30" id="h14-0-30" class="i">+    Notify { id: Vec&lt;u8&gt;, address: Address, index: u64 },
</a><a href="#h14-0-31" id="h14-0-31" class="i">+    /// Query the state machine when the given index has been confirmed by vote.
</a><a href="#h14-0-32" id="h14-0-32" class="i">+    Query { id: Vec&lt;u8&gt;, address: Address, command: Vec&lt;u8&gt;, index: u64, quorum: u64 },
</a><a href="#h14-0-33" id="h14-0-33" class="i">+    /// Extend the given server status and return it to the given address.
</a><a href="#h14-0-34" id="h14-0-34" class="i">+    Status { id: Vec&lt;u8&gt;, address: Address, status: Status },
</a><a href="#h14-0-35" id="h14-0-35" class="i">+    /// Votes for queries at the given commit index.
</a><a href="#h14-0-36" id="h14-0-36" class="i">+    Vote { index: u64, address: Address },
</a><a href="#h14-0-37" id="h14-0-37" class="i">+}
</a><a href="#h14-0-38" id="h14-0-38" class="i">+
</a><a href="#h14-0-39" id="h14-0-39" class="i">+/// A driver query.
</a><a href="#h14-0-40" id="h14-0-40" class="i">+struct Query {
</a><a href="#h14-0-41" id="h14-0-41" class="i">+    id: Vec&lt;u8&gt;,
</a><a href="#h14-0-42" id="h14-0-42" class="i">+    address: Address,
</a><a href="#h14-0-43" id="h14-0-43" class="i">+    command: Vec&lt;u8&gt;,
</a><a href="#h14-0-44" id="h14-0-44" class="i">+    quorum: u64,
</a><a href="#h14-0-45" id="h14-0-45" class="i">+    votes: HashSet&lt;Address&gt;,
</a><a href="#h14-0-46" id="h14-0-46" class="i">+}
</a><a href="#h14-0-47" id="h14-0-47" class="i">+
</a><a href="#h14-0-48" id="h14-0-48" class="i">+/// Drives a state machine, taking operations from state_rx and sending results via node_tx.
</a><a href="#h14-0-49" id="h14-0-49" class="i">+pub struct Driver {
</a><a href="#h14-0-50" id="h14-0-50" class="i">+    state_rx: mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h14-0-51" id="h14-0-51" class="i">+    node_tx: mpsc::UnboundedSender&lt;Message&gt;,
</a><a href="#h14-0-52" id="h14-0-52" class="i">+    /// Notify clients when their mutation is applied. &lt;index, (client, id)&gt;
</a><a href="#h14-0-53" id="h14-0-53" class="i">+    notify: HashMap&lt;u64, (Address, Vec&lt;u8&gt;)&gt;,
</a><a href="#h14-0-54" id="h14-0-54" class="i">+    /// Execute client queries when they receive a quorum. &lt;index, &lt;id, query&gt;&gt;
</a><a href="#h14-0-55" id="h14-0-55" class="i">+    queries: BTreeMap&lt;u64, BTreeMap&lt;Vec&lt;u8&gt;, Query&gt;&gt;,
</a><a href="#h14-0-56" id="h14-0-56" class="i">+}
</a><a href="#h14-0-57" id="h14-0-57" class="i">+
</a><a href="#h14-0-58" id="h14-0-58" class="i">+impl Driver {
</a><a href="#h14-0-59" id="h14-0-59" class="i">+    /// Creates a new state machine driver.
</a><a href="#h14-0-60" id="h14-0-60" class="i">+    pub fn new(
</a><a href="#h14-0-61" id="h14-0-61" class="i">+        state_rx: mpsc::UnboundedReceiver&lt;Instruction&gt;,
</a><a href="#h14-0-62" id="h14-0-62" class="i">+        node_tx: mpsc::UnboundedSender&lt;Message&gt;,
</a><a href="#h14-0-63" id="h14-0-63" class="i">+    ) -&gt; Self {
</a><a href="#h14-0-64" id="h14-0-64" class="i">+        Self { state_rx, node_tx, notify: HashMap::new(), queries: BTreeMap::new() }
</a><a href="#h14-0-65" id="h14-0-65" class="i">+    }
</a><a href="#h14-0-66" id="h14-0-66" class="i">+
</a><a href="#h14-0-67" id="h14-0-67" class="i">+    /// Drives a state machine.
</a><a href="#h14-0-68" id="h14-0-68" class="i">+    pub async fn drive&lt;S: State&gt;(mut self, mut state: S) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-69" id="h14-0-69" class="i">+        debug!(&quot;Starting state machine driver&quot;);
</a><a href="#h14-0-70" id="h14-0-70" class="i">+        while let Some(instruction) = self.state_rx.next().await {
</a><a href="#h14-0-71" id="h14-0-71" class="i">+            if let Err(error) = self.execute(instruction, &amp;mut state).await {
</a><a href="#h14-0-72" id="h14-0-72" class="i">+                error!(&quot;Halting state machine due to error: {}&quot;, error);
</a><a href="#h14-0-73" id="h14-0-73" class="i">+                return Err(error);
</a><a href="#h14-0-74" id="h14-0-74" class="i">+            }
</a><a href="#h14-0-75" id="h14-0-75" class="i">+        }
</a><a href="#h14-0-76" id="h14-0-76" class="i">+        debug!(&quot;Stopping state machine driver&quot;);
</a><a href="#h14-0-77" id="h14-0-77" class="i">+        Ok(())
</a><a href="#h14-0-78" id="h14-0-78" class="i">+    }
</a><a href="#h14-0-79" id="h14-0-79" class="i">+
</a><a href="#h14-0-80" id="h14-0-80" class="i">+    /// Executes a state machine instruction.
</a><a href="#h14-0-81" id="h14-0-81" class="i">+    pub async fn execute&lt;S: State&gt;(&amp;mut self, i: Instruction, state: &amp;mut S) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-82" id="h14-0-82" class="i">+        debug!(&quot;Executing {:?}&quot;, i);
</a><a href="#h14-0-83" id="h14-0-83" class="i">+        match i {
</a><a href="#h14-0-84" id="h14-0-84" class="i">+            Instruction::Abort =&gt; {
</a><a href="#h14-0-85" id="h14-0-85" class="i">+                self.notify_abort()?;
</a><a href="#h14-0-86" id="h14-0-86" class="i">+                self.query_abort()?;
</a><a href="#h14-0-87" id="h14-0-87" class="i">+            }
</a><a href="#h14-0-88" id="h14-0-88" class="i">+
</a><a href="#h14-0-89" id="h14-0-89" class="i">+            Instruction::Apply { entry: Entry { index, command: Some(command), .. } } =&gt; {
</a><a href="#h14-0-90" id="h14-0-90" class="i">+                debug!(&quot;Applying state machine command {}: {:?}&quot;, index, command);
</a><a href="#h14-0-91" id="h14-0-91" class="i">+                match tokio::task::block_in_place(|| state.mutate(index, command)) {
</a><a href="#h14-0-92" id="h14-0-92" class="i">+                    Err(error @ Error::Internal(_)) =&gt; return Err(error),
</a><a href="#h14-0-93" id="h14-0-93" class="i">+                    result =&gt; self.notify_applied(index, result)?,
</a><a href="#h14-0-94" id="h14-0-94" class="i">+                };
</a><a href="#h14-0-95" id="h14-0-95" class="i">+                // Try to execute any pending queries, since they may have been submitted for
</a><a href="#h14-0-96" id="h14-0-96" class="i">+                // a commit_index which hadn&#39;t been applied yet.
</a><a href="#h14-0-97" id="h14-0-97" class="i">+                self.query_execute(state)?;
</a><a href="#h14-0-98" id="h14-0-98" class="i">+            }
</a><a href="#h14-0-99" id="h14-0-99" class="i">+
</a><a href="#h14-0-100" id="h14-0-100" class="i">+            Instruction::Apply { entry: Entry { command: None, .. }, .. } =&gt; {}
</a><a href="#h14-0-101" id="h14-0-101" class="i">+
</a><a href="#h14-0-102" id="h14-0-102" class="i">+            Instruction::Notify { id, address, index } =&gt; {
</a><a href="#h14-0-103" id="h14-0-103" class="i">+                if index &gt; state.applied_index() {
</a><a href="#h14-0-104" id="h14-0-104" class="i">+                    self.notify.insert(index, (address, id));
</a><a href="#h14-0-105" id="h14-0-105" class="i">+                } else {
</a><a href="#h14-0-106" id="h14-0-106" class="i">+                    self.send(address, Event::ClientResponse { id, response: Err(Error::Abort) })?;
</a><a href="#h14-0-107" id="h14-0-107" class="i">+                }
</a><a href="#h14-0-108" id="h14-0-108" class="i">+            }
</a><a href="#h14-0-109" id="h14-0-109" class="i">+
</a><a href="#h14-0-110" id="h14-0-110" class="i">+            Instruction::Query { id, address, command, index, quorum } =&gt; {
</a><a href="#h14-0-111" id="h14-0-111" class="i">+                self.queries.entry(index).or_default().insert(
</a><a href="#h14-0-112" id="h14-0-112" class="i">+                    id.clone(),
</a><a href="#h14-0-113" id="h14-0-113" class="i">+                    Query { id, address, command, quorum, votes: HashSet::new() },
</a><a href="#h14-0-114" id="h14-0-114" class="i">+                );
</a><a href="#h14-0-115" id="h14-0-115" class="i">+            }
</a><a href="#h14-0-116" id="h14-0-116" class="i">+
</a><a href="#h14-0-117" id="h14-0-117" class="i">+            Instruction::Status { id, address, mut status } =&gt; {
</a><a href="#h14-0-118" id="h14-0-118" class="i">+                status.applied = state.applied_index();
</a><a href="#h14-0-119" id="h14-0-119" class="i">+                self.send(
</a><a href="#h14-0-120" id="h14-0-120" class="i">+                    address,
</a><a href="#h14-0-121" id="h14-0-121" class="i">+                    Event::ClientResponse { id, response: Ok(Response::Status(status)) },
</a><a href="#h14-0-122" id="h14-0-122" class="i">+                )?;
</a><a href="#h14-0-123" id="h14-0-123" class="i">+            }
</a><a href="#h14-0-124" id="h14-0-124" class="i">+
</a><a href="#h14-0-125" id="h14-0-125" class="i">+            Instruction::Vote { index, address } =&gt; {
</a><a href="#h14-0-126" id="h14-0-126" class="i">+                self.query_vote(index, address);
</a><a href="#h14-0-127" id="h14-0-127" class="i">+                self.query_execute(state)?;
</a><a href="#h14-0-128" id="h14-0-128" class="i">+            }
</a><a href="#h14-0-129" id="h14-0-129" class="i">+        }
</a><a href="#h14-0-130" id="h14-0-130" class="i">+        Ok(())
</a><a href="#h14-0-131" id="h14-0-131" class="i">+    }
</a><a href="#h14-0-132" id="h14-0-132" class="i">+
</a><a href="#h14-0-133" id="h14-0-133" class="i">+    /// Aborts all pending notifications.
</a><a href="#h14-0-134" id="h14-0-134" class="i">+    fn notify_abort(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-135" id="h14-0-135" class="i">+        for (_, (address, id)) in std::mem::replace(&amp;mut self.notify, HashMap::new()) {
</a><a href="#h14-0-136" id="h14-0-136" class="i">+            self.send(address, Event::ClientResponse { id, response: Err(Error::Abort) })?;
</a><a href="#h14-0-137" id="h14-0-137" class="i">+        }
</a><a href="#h14-0-138" id="h14-0-138" class="i">+        Ok(())
</a><a href="#h14-0-139" id="h14-0-139" class="i">+    }
</a><a href="#h14-0-140" id="h14-0-140" class="i">+
</a><a href="#h14-0-141" id="h14-0-141" class="i">+    /// Notifies a client about an applied log entry, if any.
</a><a href="#h14-0-142" id="h14-0-142" class="i">+    fn notify_applied(&amp;mut self, index: u64, result: Result&lt;Vec&lt;u8&gt;, Error&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-143" id="h14-0-143" class="i">+        if let Some((to, id)) = self.notify.remove(&amp;index) {
</a><a href="#h14-0-144" id="h14-0-144" class="i">+            self.send(to, Event::ClientResponse { id, response: result.map(Response::State) })?;
</a><a href="#h14-0-145" id="h14-0-145" class="i">+        }
</a><a href="#h14-0-146" id="h14-0-146" class="i">+        Ok(())
</a><a href="#h14-0-147" id="h14-0-147" class="i">+    }
</a><a href="#h14-0-148" id="h14-0-148" class="i">+
</a><a href="#h14-0-149" id="h14-0-149" class="i">+    /// Aborts all pending queries.
</a><a href="#h14-0-150" id="h14-0-150" class="i">+    fn query_abort(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-151" id="h14-0-151" class="i">+        for (_, queries) in std::mem::replace(&amp;mut self.queries, BTreeMap::new()) {
</a><a href="#h14-0-152" id="h14-0-152" class="i">+            for (id, query) in queries {
</a><a href="#h14-0-153" id="h14-0-153" class="i">+                self.send(
</a><a href="#h14-0-154" id="h14-0-154" class="i">+                    query.address,
</a><a href="#h14-0-155" id="h14-0-155" class="i">+                    Event::ClientResponse { id, response: Err(Error::Abort) },
</a><a href="#h14-0-156" id="h14-0-156" class="i">+                )?;
</a><a href="#h14-0-157" id="h14-0-157" class="i">+            }
</a><a href="#h14-0-158" id="h14-0-158" class="i">+        }
</a><a href="#h14-0-159" id="h14-0-159" class="i">+        Ok(())
</a><a href="#h14-0-160" id="h14-0-160" class="i">+    }
</a><a href="#h14-0-161" id="h14-0-161" class="i">+
</a><a href="#h14-0-162" id="h14-0-162" class="i">+    /// Executes any queries that are ready.
</a><a href="#h14-0-163" id="h14-0-163" class="i">+    fn query_execute&lt;S: State&gt;(&amp;mut self, state: &amp;mut S) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-164" id="h14-0-164" class="i">+        for query in self.query_ready(state.applied_index()) {
</a><a href="#h14-0-165" id="h14-0-165" class="i">+            let result = state.query(query.command);
</a><a href="#h14-0-166" id="h14-0-166" class="i">+            if let Err(error @ Error::Internal(_)) = result {
</a><a href="#h14-0-167" id="h14-0-167" class="i">+                return Err(error);
</a><a href="#h14-0-168" id="h14-0-168" class="i">+            }
</a><a href="#h14-0-169" id="h14-0-169" class="i">+            self.send(
</a><a href="#h14-0-170" id="h14-0-170" class="i">+                query.address,
</a><a href="#h14-0-171" id="h14-0-171" class="i">+                Event::ClientResponse { id: query.id, response: result.map(Response::State) },
</a><a href="#h14-0-172" id="h14-0-172" class="i">+            )?
</a><a href="#h14-0-173" id="h14-0-173" class="i">+        }
</a><a href="#h14-0-174" id="h14-0-174" class="i">+        Ok(())
</a><a href="#h14-0-175" id="h14-0-175" class="i">+    }
</a><a href="#h14-0-176" id="h14-0-176" class="i">+
</a><a href="#h14-0-177" id="h14-0-177" class="i">+    /// Fetches and removes any ready queries, where index &lt;= applied_index.
</a><a href="#h14-0-178" id="h14-0-178" class="i">+    fn query_ready(&amp;mut self, applied_index: u64) -&gt; Vec&lt;Query&gt; {
</a><a href="#h14-0-179" id="h14-0-179" class="i">+        let mut ready = Vec::new();
</a><a href="#h14-0-180" id="h14-0-180" class="i">+        let mut empty = Vec::new();
</a><a href="#h14-0-181" id="h14-0-181" class="i">+        for (index, queries) in self.queries.range_mut(..=applied_index) {
</a><a href="#h14-0-182" id="h14-0-182" class="i">+            let mut ready_ids = Vec::new();
</a><a href="#h14-0-183" id="h14-0-183" class="i">+            for (id, query) in queries.iter_mut() {
</a><a href="#h14-0-184" id="h14-0-184" class="i">+                if query.votes.len() as u64 &gt;= query.quorum {
</a><a href="#h14-0-185" id="h14-0-185" class="i">+                    ready_ids.push(id.clone());
</a><a href="#h14-0-186" id="h14-0-186" class="i">+                }
</a><a href="#h14-0-187" id="h14-0-187" class="i">+            }
</a><a href="#h14-0-188" id="h14-0-188" class="i">+            for id in ready_ids {
</a><a href="#h14-0-189" id="h14-0-189" class="i">+                if let Some(query) = queries.remove(&amp;id) {
</a><a href="#h14-0-190" id="h14-0-190" class="i">+                    ready.push(query)
</a><a href="#h14-0-191" id="h14-0-191" class="i">+                }
</a><a href="#h14-0-192" id="h14-0-192" class="i">+            }
</a><a href="#h14-0-193" id="h14-0-193" class="i">+            if queries.is_empty() {
</a><a href="#h14-0-194" id="h14-0-194" class="i">+                empty.push(*index)
</a><a href="#h14-0-195" id="h14-0-195" class="i">+            }
</a><a href="#h14-0-196" id="h14-0-196" class="i">+        }
</a><a href="#h14-0-197" id="h14-0-197" class="i">+        for index in empty {
</a><a href="#h14-0-198" id="h14-0-198" class="i">+            self.queries.remove(&amp;index);
</a><a href="#h14-0-199" id="h14-0-199" class="i">+        }
</a><a href="#h14-0-200" id="h14-0-200" class="i">+        ready
</a><a href="#h14-0-201" id="h14-0-201" class="i">+    }
</a><a href="#h14-0-202" id="h14-0-202" class="i">+
</a><a href="#h14-0-203" id="h14-0-203" class="i">+    /// Votes for queries up to and including a given commit index by an address.
</a><a href="#h14-0-204" id="h14-0-204" class="i">+    fn query_vote(&amp;mut self, commit_index: u64, address: Address) {
</a><a href="#h14-0-205" id="h14-0-205" class="i">+        for (_, queries) in self.queries.range_mut(..=commit_index) {
</a><a href="#h14-0-206" id="h14-0-206" class="i">+            for (_, query) in queries.iter_mut() {
</a><a href="#h14-0-207" id="h14-0-207" class="i">+                query.votes.insert(address.clone());
</a><a href="#h14-0-208" id="h14-0-208" class="i">+            }
</a><a href="#h14-0-209" id="h14-0-209" class="i">+        }
</a><a href="#h14-0-210" id="h14-0-210" class="i">+    }
</a><a href="#h14-0-211" id="h14-0-211" class="i">+
</a><a href="#h14-0-212" id="h14-0-212" class="i">+    /// Sends a message.
</a><a href="#h14-0-213" id="h14-0-213" class="i">+    fn send(&amp;self, to: Address, event: Event) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-214" id="h14-0-214" class="i">+        let msg = Message { from: Address::Local, to, term: 0, event };
</a><a href="#h14-0-215" id="h14-0-215" class="i">+        debug!(&quot;Sending {:?}&quot;, msg);
</a><a href="#h14-0-216" id="h14-0-216" class="i">+        Ok(self.node_tx.send(msg)?)
</a><a href="#h14-0-217" id="h14-0-217" class="i">+    }
</a><a href="#h14-0-218" id="h14-0-218" class="i">+}
</a><a href="#h14-0-219" id="h14-0-219" class="i">+
</a> #[cfg(test)]
 pub mod tests {
     use super::*;
<a href="#h14-0-223" id="h14-0-223" class="i">+    use pretty_assertions::assert_eq;
</a>     use std::sync::{Arc, Mutex};
 
     #[derive(Clone, Debug)]
     pub struct TestState {
         commands: Arc&lt;Mutex&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;&gt;,
<a href="#h14-0-229" id="h14-0-229" class="i">+        applied_index: Arc&lt;Mutex&lt;u64&gt;&gt;,
</a>     }
 
     impl TestState {
<a href="#h14-0-233" id="h14-0-233" class="d">-        pub fn new() -&gt; Self {
</a><a href="#h14-0-234" id="h14-0-234" class="d">-            Self { commands: Arc::new(Mutex::new(Vec::new())) }
</a><a href="#h14-0-235" id="h14-0-235" class="i">+        pub fn new(applied_index: u64) -&gt; Self {
</a><a href="#h14-0-236" id="h14-0-236" class="i">+            Self {
</a><a href="#h14-0-237" id="h14-0-237" class="i">+                commands: Arc::new(Mutex::new(Vec::new())),
</a><a href="#h14-0-238" id="h14-0-238" class="i">+                applied_index: Arc::new(Mutex::new(applied_index)),
</a><a href="#h14-0-239" id="h14-0-239" class="i">+            }
</a>         }
 
         pub fn list(&amp;self) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {
<a href="#h14-1" id="h14-1" class="h">@@ -31,29 +243,163 @@ pub mod tests {
</a>     }
 
     impl State for TestState {
<a href="#h14-1-3" id="h14-1-3" class="d">-        // Appends the command to the internal commands list, and returns the command prefixed with
</a><a href="#h14-1-4" id="h14-1-4" class="d">-        // a 0xff byte. Returns Error::Internal if the payload is != 1 byte, and Error::Value if
</a><a href="#h14-1-5" id="h14-1-5" class="d">-        // the value is 0xff.
</a><a href="#h14-1-6" id="h14-1-6" class="d">-        fn mutate(&amp;mut self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h14-1-7" id="h14-1-7" class="d">-            if command.len() != 1 {
</a><a href="#h14-1-8" id="h14-1-8" class="d">-                return Err(Error::Internal(&quot;Command must be 1 byte&quot;.into()));
</a><a href="#h14-1-9" id="h14-1-9" class="d">-            }
</a><a href="#h14-1-10" id="h14-1-10" class="d">-            if command[0] == 0xff {
</a><a href="#h14-1-11" id="h14-1-11" class="d">-                return Err(Error::Value(&quot;Command cannot be 0xff&quot;.into()));
</a><a href="#h14-1-12" id="h14-1-12" class="d">-            }
</a><a href="#h14-1-13" id="h14-1-13" class="i">+        fn applied_index(&amp;self) -&gt; u64 {
</a><a href="#h14-1-14" id="h14-1-14" class="i">+            *self.applied_index.lock().unwrap()
</a><a href="#h14-1-15" id="h14-1-15" class="i">+        }
</a><a href="#h14-1-16" id="h14-1-16" class="i">+
</a><a href="#h14-1-17" id="h14-1-17" class="i">+        // Appends the command to the internal commands list.
</a><a href="#h14-1-18" id="h14-1-18" class="i">+        fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a>             self.commands.lock()?.push(command.clone());
<a href="#h14-1-20" id="h14-1-20" class="d">-            Ok(vec![0xff, command[0]])
</a><a href="#h14-1-21" id="h14-1-21" class="i">+            *self.applied_index.lock()? = index;
</a><a href="#h14-1-22" id="h14-1-22" class="i">+            Ok(command)
</a>         }
 
<a href="#h14-1-25" id="h14-1-25" class="d">-        // Reads the command in the internal commands list at the index
</a><a href="#h14-1-26" id="h14-1-26" class="d">-        // given by the query command (1-based). Returns the stored command prefixed by
</a><a href="#h14-1-27" id="h14-1-27" class="d">-        // 0xbb, or 0xbb 0x00 if not found.
</a><a href="#h14-1-28" id="h14-1-28" class="i">+        // Appends the command to the internal commands list.
</a>         fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
<a href="#h14-1-30" id="h14-1-30" class="d">-            if command.len() != 1 {
</a><a href="#h14-1-31" id="h14-1-31" class="d">-                return Err(Error::Value(&quot;Query payload must be 1 byte&quot;.into()));
</a><a href="#h14-1-32" id="h14-1-32" class="d">-            }
</a><a href="#h14-1-33" id="h14-1-33" class="d">-            let index = command[0] as usize;
</a><a href="#h14-1-34" id="h14-1-34" class="d">-            Ok(vec![0xbb, self.commands.lock()?.get(index - 1).map(|c| c[0]).unwrap_or(0x00)])
</a><a href="#h14-1-35" id="h14-1-35" class="i">+            self.commands.lock()?.push(command.clone());
</a><a href="#h14-1-36" id="h14-1-36" class="i">+            Ok(command)
</a>         }
     }
<a href="#h14-1-39" id="h14-1-39" class="i">+
</a><a href="#h14-1-40" id="h14-1-40" class="i">+    async fn setup() -&gt; Result&lt;
</a><a href="#h14-1-41" id="h14-1-41" class="i">+        (TestState, mpsc::UnboundedSender&lt;Instruction&gt;, mpsc::UnboundedReceiver&lt;Message&gt;),
</a><a href="#h14-1-42" id="h14-1-42" class="i">+        Error,
</a><a href="#h14-1-43" id="h14-1-43" class="i">+    &gt; {
</a><a href="#h14-1-44" id="h14-1-44" class="i">+        let state = TestState::new(0);
</a><a href="#h14-1-45" id="h14-1-45" class="i">+        let (state_tx, state_rx) = mpsc::unbounded_channel();
</a><a href="#h14-1-46" id="h14-1-46" class="i">+        let (node_tx, node_rx) = mpsc::unbounded_channel();
</a><a href="#h14-1-47" id="h14-1-47" class="i">+        tokio::spawn(Driver::new(state_rx, node_tx).drive(state.clone()));
</a><a href="#h14-1-48" id="h14-1-48" class="i">+        Ok((state, state_tx, node_rx))
</a><a href="#h14-1-49" id="h14-1-49" class="i">+    }
</a><a href="#h14-1-50" id="h14-1-50" class="i">+
</a><a href="#h14-1-51" id="h14-1-51" class="i">+    #[tokio::test(core_threads = 2)]
</a><a href="#h14-1-52" id="h14-1-52" class="i">+    async fn driver_abort() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-1-53" id="h14-1-53" class="i">+        let (state, state_tx, node_rx) = setup().await?;
</a><a href="#h14-1-54" id="h14-1-54" class="i">+
</a><a href="#h14-1-55" id="h14-1-55" class="i">+        state_tx.send(Instruction::Notify {
</a><a href="#h14-1-56" id="h14-1-56" class="i">+            id: vec![0x01],
</a><a href="#h14-1-57" id="h14-1-57" class="i">+            index: 1,
</a><a href="#h14-1-58" id="h14-1-58" class="i">+            address: Address::Peer(&quot;a&quot;.into()),
</a><a href="#h14-1-59" id="h14-1-59" class="i">+        })?;
</a><a href="#h14-1-60" id="h14-1-60" class="i">+        state_tx.send(Instruction::Query {
</a><a href="#h14-1-61" id="h14-1-61" class="i">+            id: vec![0x02],
</a><a href="#h14-1-62" id="h14-1-62" class="i">+            address: Address::Client,
</a><a href="#h14-1-63" id="h14-1-63" class="i">+            command: vec![0xf0],
</a><a href="#h14-1-64" id="h14-1-64" class="i">+            index: 1,
</a><a href="#h14-1-65" id="h14-1-65" class="i">+            quorum: 2,
</a><a href="#h14-1-66" id="h14-1-66" class="i">+        })?;
</a><a href="#h14-1-67" id="h14-1-67" class="i">+        state_tx.send(Instruction::Vote { index: 1, address: Address::Local })?;
</a><a href="#h14-1-68" id="h14-1-68" class="i">+        state_tx.send(Instruction::Abort)?;
</a><a href="#h14-1-69" id="h14-1-69" class="i">+        std::mem::drop(state_tx);
</a><a href="#h14-1-70" id="h14-1-70" class="i">+
</a><a href="#h14-1-71" id="h14-1-71" class="i">+        assert_eq!(
</a><a href="#h14-1-72" id="h14-1-72" class="i">+            node_rx.collect::&lt;Vec&lt;_&gt;&gt;().await,
</a><a href="#h14-1-73" id="h14-1-73" class="i">+            vec![
</a><a href="#h14-1-74" id="h14-1-74" class="i">+                Message {
</a><a href="#h14-1-75" id="h14-1-75" class="i">+                    from: Address::Local,
</a><a href="#h14-1-76" id="h14-1-76" class="i">+                    to: Address::Peer(&quot;a&quot;.into()),
</a><a href="#h14-1-77" id="h14-1-77" class="i">+                    term: 0,
</a><a href="#h14-1-78" id="h14-1-78" class="i">+                    event: Event::ClientResponse { id: vec![0x01], response: Err(Error::Abort) }
</a><a href="#h14-1-79" id="h14-1-79" class="i">+                },
</a><a href="#h14-1-80" id="h14-1-80" class="i">+                Message {
</a><a href="#h14-1-81" id="h14-1-81" class="i">+                    from: Address::Local,
</a><a href="#h14-1-82" id="h14-1-82" class="i">+                    to: Address::Client,
</a><a href="#h14-1-83" id="h14-1-83" class="i">+                    term: 0,
</a><a href="#h14-1-84" id="h14-1-84" class="i">+                    event: Event::ClientResponse { id: vec![0x02], response: Err(Error::Abort) }
</a><a href="#h14-1-85" id="h14-1-85" class="i">+                }
</a><a href="#h14-1-86" id="h14-1-86" class="i">+            ]
</a><a href="#h14-1-87" id="h14-1-87" class="i">+        );
</a><a href="#h14-1-88" id="h14-1-88" class="i">+        assert_eq!(state.list(), Vec::&lt;Vec&lt;u8&gt;&gt;::new());
</a><a href="#h14-1-89" id="h14-1-89" class="i">+        assert_eq!(state.applied_index(), 0);
</a><a href="#h14-1-90" id="h14-1-90" class="i">+
</a><a href="#h14-1-91" id="h14-1-91" class="i">+        Ok(())
</a><a href="#h14-1-92" id="h14-1-92" class="i">+    }
</a><a href="#h14-1-93" id="h14-1-93" class="i">+
</a><a href="#h14-1-94" id="h14-1-94" class="i">+    #[tokio::test(core_threads = 2)]
</a><a href="#h14-1-95" id="h14-1-95" class="i">+    async fn driver_apply() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-1-96" id="h14-1-96" class="i">+        let (state, state_tx, node_rx) = setup().await?;
</a><a href="#h14-1-97" id="h14-1-97" class="i">+
</a><a href="#h14-1-98" id="h14-1-98" class="i">+        state_tx.send(Instruction::Notify {
</a><a href="#h14-1-99" id="h14-1-99" class="i">+            id: vec![0x01],
</a><a href="#h14-1-100" id="h14-1-100" class="i">+            index: 2,
</a><a href="#h14-1-101" id="h14-1-101" class="i">+            address: Address::Client,
</a><a href="#h14-1-102" id="h14-1-102" class="i">+        })?;
</a><a href="#h14-1-103" id="h14-1-103" class="i">+        state_tx.send(Instruction::Apply { entry: Entry { index: 1, term: 1, command: None } })?;
</a><a href="#h14-1-104" id="h14-1-104" class="i">+        state_tx.send(Instruction::Apply {
</a><a href="#h14-1-105" id="h14-1-105" class="i">+            entry: Entry { index: 2, term: 1, command: Some(vec![0xaf]) },
</a><a href="#h14-1-106" id="h14-1-106" class="i">+        })?;
</a><a href="#h14-1-107" id="h14-1-107" class="i">+        std::mem::drop(state_tx);
</a><a href="#h14-1-108" id="h14-1-108" class="i">+        assert_eq!(
</a><a href="#h14-1-109" id="h14-1-109" class="i">+            node_rx.collect::&lt;Vec&lt;_&gt;&gt;().await,
</a><a href="#h14-1-110" id="h14-1-110" class="i">+            vec![Message {
</a><a href="#h14-1-111" id="h14-1-111" class="i">+                from: Address::Local,
</a><a href="#h14-1-112" id="h14-1-112" class="i">+                to: Address::Client,
</a><a href="#h14-1-113" id="h14-1-113" class="i">+                term: 0,
</a><a href="#h14-1-114" id="h14-1-114" class="i">+                event: Event::ClientResponse {
</a><a href="#h14-1-115" id="h14-1-115" class="i">+                    id: vec![0x01],
</a><a href="#h14-1-116" id="h14-1-116" class="i">+                    response: Ok(Response::State(vec![0xaf]))
</a><a href="#h14-1-117" id="h14-1-117" class="i">+                }
</a><a href="#h14-1-118" id="h14-1-118" class="i">+            }]
</a><a href="#h14-1-119" id="h14-1-119" class="i">+        );
</a><a href="#h14-1-120" id="h14-1-120" class="i">+        assert_eq!(state.list(), vec![vec![0xaf]]);
</a><a href="#h14-1-121" id="h14-1-121" class="i">+        assert_eq!(state.applied_index(), 2);
</a><a href="#h14-1-122" id="h14-1-122" class="i">+
</a><a href="#h14-1-123" id="h14-1-123" class="i">+        Ok(())
</a><a href="#h14-1-124" id="h14-1-124" class="i">+    }
</a><a href="#h14-1-125" id="h14-1-125" class="i">+
</a><a href="#h14-1-126" id="h14-1-126" class="i">+    #[tokio::test(core_threads = 2)]
</a><a href="#h14-1-127" id="h14-1-127" class="i">+    async fn driver_query() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-1-128" id="h14-1-128" class="i">+        let (_, state_tx, node_rx) = setup().await?;
</a><a href="#h14-1-129" id="h14-1-129" class="i">+
</a><a href="#h14-1-130" id="h14-1-130" class="i">+        state_tx.send(Instruction::Query {
</a><a href="#h14-1-131" id="h14-1-131" class="i">+            id: vec![0x01],
</a><a href="#h14-1-132" id="h14-1-132" class="i">+            address: Address::Client,
</a><a href="#h14-1-133" id="h14-1-133" class="i">+            command: vec![0xf0],
</a><a href="#h14-1-134" id="h14-1-134" class="i">+            index: 1,
</a><a href="#h14-1-135" id="h14-1-135" class="i">+            quorum: 2,
</a><a href="#h14-1-136" id="h14-1-136" class="i">+        })?;
</a><a href="#h14-1-137" id="h14-1-137" class="i">+        state_tx.send(Instruction::Apply {
</a><a href="#h14-1-138" id="h14-1-138" class="i">+            entry: Entry { index: 1, term: 1, command: Some(vec![0xaf]) },
</a><a href="#h14-1-139" id="h14-1-139" class="i">+        })?;
</a><a href="#h14-1-140" id="h14-1-140" class="i">+        state_tx.send(Instruction::Vote { index: 1, address: Address::Local })?;
</a><a href="#h14-1-141" id="h14-1-141" class="i">+        state_tx.send(Instruction::Vote { index: 1, address: Address::Peer(&quot;a&quot;.into()) })?;
</a><a href="#h14-1-142" id="h14-1-142" class="i">+        std::mem::drop(state_tx);
</a><a href="#h14-1-143" id="h14-1-143" class="i">+
</a><a href="#h14-1-144" id="h14-1-144" class="i">+        assert_eq!(
</a><a href="#h14-1-145" id="h14-1-145" class="i">+            node_rx.collect::&lt;Vec&lt;_&gt;&gt;().await,
</a><a href="#h14-1-146" id="h14-1-146" class="i">+            vec![Message {
</a><a href="#h14-1-147" id="h14-1-147" class="i">+                from: Address::Local,
</a><a href="#h14-1-148" id="h14-1-148" class="i">+                to: Address::Client,
</a><a href="#h14-1-149" id="h14-1-149" class="i">+                term: 0,
</a><a href="#h14-1-150" id="h14-1-150" class="i">+                event: Event::ClientResponse {
</a><a href="#h14-1-151" id="h14-1-151" class="i">+                    id: vec![0x01],
</a><a href="#h14-1-152" id="h14-1-152" class="i">+                    response: Ok(Response::State(vec![0xf0]))
</a><a href="#h14-1-153" id="h14-1-153" class="i">+                }
</a><a href="#h14-1-154" id="h14-1-154" class="i">+            }]
</a><a href="#h14-1-155" id="h14-1-155" class="i">+        );
</a><a href="#h14-1-156" id="h14-1-156" class="i">+
</a><a href="#h14-1-157" id="h14-1-157" class="i">+        Ok(())
</a><a href="#h14-1-158" id="h14-1-158" class="i">+    }
</a><a href="#h14-1-159" id="h14-1-159" class="i">+
</a><a href="#h14-1-160" id="h14-1-160" class="i">+    #[tokio::test(core_threads = 2)]
</a><a href="#h14-1-161" id="h14-1-161" class="i">+    async fn driver_query_noquorum() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-1-162" id="h14-1-162" class="i">+        let (_, state_tx, node_rx) = setup().await?;
</a><a href="#h14-1-163" id="h14-1-163" class="i">+
</a><a href="#h14-1-164" id="h14-1-164" class="i">+        state_tx.send(Instruction::Query {
</a><a href="#h14-1-165" id="h14-1-165" class="i">+            id: vec![0x01],
</a><a href="#h14-1-166" id="h14-1-166" class="i">+            address: Address::Client,
</a><a href="#h14-1-167" id="h14-1-167" class="i">+            command: vec![0xf0],
</a><a href="#h14-1-168" id="h14-1-168" class="i">+            index: 1,
</a><a href="#h14-1-169" id="h14-1-169" class="i">+            quorum: 2,
</a><a href="#h14-1-170" id="h14-1-170" class="i">+        })?;
</a><a href="#h14-1-171" id="h14-1-171" class="i">+        state_tx.send(Instruction::Apply {
</a><a href="#h14-1-172" id="h14-1-172" class="i">+            entry: Entry { index: 1, term: 1, command: Some(vec![0xaf]) },
</a><a href="#h14-1-173" id="h14-1-173" class="i">+        })?;
</a><a href="#h14-1-174" id="h14-1-174" class="i">+        state_tx.send(Instruction::Vote { index: 1, address: Address::Local })?;
</a><a href="#h14-1-175" id="h14-1-175" class="i">+        std::mem::drop(state_tx);
</a><a href="#h14-1-176" id="h14-1-176" class="i">+
</a><a href="#h14-1-177" id="h14-1-177" class="i">+        assert_eq!(node_rx.collect::&lt;Vec&lt;_&gt;&gt;().await, vec![]);
</a><a href="#h14-1-178" id="h14-1-178" class="i">+
</a><a href="#h14-1-179" id="h14-1-179" class="i">+        Ok(())
</a><a href="#h14-1-180" id="h14-1-180" class="i">+    }
</a> }
<b>diff --git a/<a id="h15" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -15,18 +15,19 @@ use std::fs;
</a> use std::path::Path;
 use tokio::net::{TcpListener, TcpStream};
 use tokio::stream::StreamExt as _;
<a href="#h15-0-3" id="h15-0-3" class="i">+use tokio::sync::mpsc;
</a> use tokio_util::codec::{Framed, LengthDelimitedCodec};
 
 /// A ToyDB server.
 pub struct Server {
<a href="#h15-0-8" id="h15-0-8" class="d">-    raft: raft::Server&lt;kv::storage::BLog, sql::engine::raft::State&lt;kv::storage::File&gt;&gt;,
</a><a href="#h15-0-9" id="h15-0-9" class="i">+    raft: raft::Server&lt;kv::storage::BLog&gt;,
</a>     raft_listener: Option&lt;TcpListener&gt;,
     sql_listener: Option&lt;TcpListener&gt;,
 }
 
 impl Server {
     /// Creates a new ToyDB server.
<a href="#h15-0-16" id="h15-0-16" class="d">-    pub fn new(id: &amp;str, peers: HashMap&lt;String, String&gt;, dir: &amp;str) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h15-0-17" id="h15-0-17" class="i">+    pub async fn new(id: &amp;str, peers: HashMap&lt;String, String&gt;, dir: &amp;str) -&gt; Result&lt;Self, Error&gt; {
</a>         let path = Path::new(dir);
         fs::create_dir_all(path)?;
         Ok(Server {
<a href="#h15-1" id="h15-1" class="h">@@ -46,8 +47,9 @@ impl Server {
</a>                         .write(true)
                         .create(true)
                         .open(path.join(&quot;state&quot;))?,
<a href="#h15-1-3" id="h15-1-3" class="d">-                )?)),
</a><a href="#h15-1-4" id="h15-1-4" class="d">-            )?,
</a><a href="#h15-1-5" id="h15-1-5" class="i">+                )?))?,
</a><a href="#h15-1-6" id="h15-1-6" class="i">+            )
</a><a href="#h15-1-7" id="h15-1-7" class="i">+            .await?,
</a>             raft_listener: None,
             sql_listener: None,
         })
<a href="#h15-2" id="h15-2" class="h">@@ -71,10 +73,11 @@ impl Server {
</a>         let raft_listener = self
             .raft_listener
             .ok_or_else(|| Error::Internal(&quot;Must listen before serving&quot;.into()))?;
<a href="#h15-2-3" id="h15-2-3" class="d">-        let sql_engine = sql::engine::Raft::new(self.raft.client().await);
</a><a href="#h15-2-4" id="h15-2-4" class="i">+        let (raft_tx, raft_rx) = mpsc::unbounded_channel();
</a><a href="#h15-2-5" id="h15-2-5" class="i">+        let sql_engine = sql::engine::Raft::new(raft::Client::new(raft_tx));
</a> 
         tokio::try_join!(
<a href="#h15-2-8" id="h15-2-8" class="d">-            self.raft.serve(raft_listener),
</a><a href="#h15-2-9" id="h15-2-9" class="i">+            self.raft.serve(raft_listener, raft_rx),
</a>             Self::serve_sql(sql_listener, sql_engine),
         )?;
         Ok(())
<a href="#h15-3" id="h15-3" class="h">@@ -109,7 +112,6 @@ pub enum Request {
</a> /// A server response.
 #[derive(Debug, Serialize, Deserialize)]
 pub enum Response {
<a href="#h15-3-3" id="h15-3-3" class="d">-    Error(Error),
</a>     Execute(ResultSet),
     Row(Option&lt;Row&gt;),
     GetTable(Table),
<a href="#h15-4" id="h15-4" class="h">@@ -136,24 +138,22 @@ impl Session {
</a>             tokio_serde::formats::Cbor::default(),
         );
         while let Some(request) = stream.try_next().await? {
<a href="#h15-4-3" id="h15-4-3" class="d">-            let mut response = self.request(request).await;
</a><a href="#h15-4-4" id="h15-4-4" class="d">-            let mut rows: Box&lt;dyn Iterator&lt;Item = Response&gt; + Send&gt; = Box::new(std::iter::empty());
</a><a href="#h15-4-5" id="h15-4-5" class="d">-            if let Response::Execute(ResultSet::Query { ref mut relation }) = &amp;mut response {
</a><a href="#h15-4-6" id="h15-4-6" class="i">+            let mut response = tokio::task::block_in_place(|| self.request(request));
</a><a href="#h15-4-7" id="h15-4-7" class="i">+            let mut rows: Box&lt;dyn Iterator&lt;Item = Result&lt;Response, Error&gt;&gt; + Send&gt; =
</a><a href="#h15-4-8" id="h15-4-8" class="i">+                Box::new(std::iter::empty());
</a><a href="#h15-4-9" id="h15-4-9" class="i">+            if let Ok(Response::Execute(ResultSet::Query { ref mut relation })) = &amp;mut response {
</a>                 rows = Box::new(
                     relation
                         .rows
                         .take()
                         .unwrap_or_else(|| Box::new(std::iter::empty()))
<a href="#h15-4-15" id="h15-4-15" class="d">-                        .map(|result| match result {
</a><a href="#h15-4-16" id="h15-4-16" class="d">-                            Ok(row) =&gt; Response::Row(Some(row)),
</a><a href="#h15-4-17" id="h15-4-17" class="d">-                            Err(error) =&gt; Response::Error(error),
</a><a href="#h15-4-18" id="h15-4-18" class="d">-                        })
</a><a href="#h15-4-19" id="h15-4-19" class="d">-                        .chain(std::iter::once(Response::Row(None)))
</a><a href="#h15-4-20" id="h15-4-20" class="i">+                        .map(|result| result.map(|row| Response::Row(Some(row))))
</a><a href="#h15-4-21" id="h15-4-21" class="i">+                        .chain(std::iter::once(Ok(Response::Row(None))))
</a>                         .scan(false, |err_sent, response| match (&amp;err_sent, &amp;response) {
                             (true, _) =&gt; None,
<a href="#h15-4-24" id="h15-4-24" class="d">-                            (_, Response::Error(_)) =&gt; {
</a><a href="#h15-4-25" id="h15-4-25" class="i">+                            (_, Err(error)) =&gt; {
</a>                                 *err_sent = true;
<a href="#h15-4-27" id="h15-4-27" class="d">-                                Some(response)
</a><a href="#h15-4-28" id="h15-4-28" class="i">+                                Some(Err(error.clone()))
</a>                             }
                             _ =&gt; Some(response),
                         })
<a href="#h15-5" id="h15-5" class="h">@@ -166,17 +166,8 @@ impl Session {
</a>         Ok(())
     }
 
<a href="#h15-5-3" id="h15-5-3" class="d">-    /// Runs a request, returning errors as Response::Error.
</a><a href="#h15-5-4" id="h15-5-4" class="d">-    /// FIXME Blocks the thread, since the SQL engine is not async.
</a><a href="#h15-5-5" id="h15-5-5" class="d">-    async fn request(&amp;mut self, request: Request) -&gt; Response {
</a><a href="#h15-5-6" id="h15-5-6" class="d">-        match tokio::task::block_in_place(|| self.call(request)) {
</a><a href="#h15-5-7" id="h15-5-7" class="d">-            Ok(response) =&gt; response,
</a><a href="#h15-5-8" id="h15-5-8" class="d">-            Err(error) =&gt; Response::Error(error),
</a><a href="#h15-5-9" id="h15-5-9" class="d">-        }
</a><a href="#h15-5-10" id="h15-5-10" class="d">-    }
</a><a href="#h15-5-11" id="h15-5-11" class="d">-
</a><a href="#h15-5-12" id="h15-5-12" class="d">-    /// Executes a simple request/response call, without error handling.
</a><a href="#h15-5-13" id="h15-5-13" class="d">-    fn call(&amp;mut self, request: Request) -&gt; Result&lt;Response, Error&gt; {
</a><a href="#h15-5-14" id="h15-5-14" class="i">+    /// Executes a request.
</a><a href="#h15-5-15" id="h15-5-15" class="i">+    pub fn request(&amp;mut self, request: Request) -&gt; Result&lt;Response, Error&gt; {
</a>         Ok(match request {
             Request::Execute(query) =&gt; Response::Execute(self.sql.execute(&amp;query)?),
             Request::GetTable(table) =&gt; Response::GetTable(
<b>diff --git a/<a id="h16" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -2,32 +2,43 @@ use super::super::schema::{Catalog, Table, Tables};
</a> use super::super::types::{Expression, Row, Value};
 use super::Transaction as _;
 use crate::kv;
<a href="#h16-0-3" id="h16-0-3" class="i">+use crate::kv::storage::Storage;
</a> use crate::utility::{deserialize, serialize};
 use crate::Error;
 
 use std::collections::HashSet;
 
 /// A SQL engine based on an underlying MVCC key/value store
<a href="#h16-0-10" id="h16-0-10" class="d">-pub struct KV&lt;S: kv::storage::Storage&gt; {
</a><a href="#h16-0-11" id="h16-0-11" class="i">+pub struct KV&lt;S: Storage&gt; {
</a>     /// The underlying key/value store
     kv: kv::MVCC&lt;S&gt;,
 }
 
 // FIXME Implement Clone manually due to https://github.com/rust-lang/rust/issues/26925
<a href="#h16-0-17" id="h16-0-17" class="d">-impl&lt;S: kv::storage::Storage&gt; std::clone::Clone for KV&lt;S&gt; {
</a><a href="#h16-0-18" id="h16-0-18" class="i">+impl&lt;S: Storage&gt; std::clone::Clone for KV&lt;S&gt; {
</a>     fn clone(&amp;self) -&gt; Self {
         KV::new(self.kv.clone())
     }
 }
 
<a href="#h16-0-24" id="h16-0-24" class="d">-impl&lt;S: kv::storage::Storage&gt; KV&lt;S&gt; {
</a><a href="#h16-0-25" id="h16-0-25" class="i">+impl&lt;S: Storage&gt; KV&lt;S&gt; {
</a>     /// Creates a new key/value-based SQL engine
     pub fn new(kv: kv::MVCC&lt;S&gt;) -&gt; Self {
         Self { kv }
     }
<a href="#h16-0-30" id="h16-0-30" class="i">+
</a><a href="#h16-0-31" id="h16-0-31" class="i">+    /// Fetches an unversioned metadata value
</a><a href="#h16-0-32" id="h16-0-32" class="i">+    pub fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h16-0-33" id="h16-0-33" class="i">+        self.kv.get_metadata(key)
</a><a href="#h16-0-34" id="h16-0-34" class="i">+    }
</a><a href="#h16-0-35" id="h16-0-35" class="i">+
</a><a href="#h16-0-36" id="h16-0-36" class="i">+    /// Sets an unversioned metadata value
</a><a href="#h16-0-37" id="h16-0-37" class="i">+    pub fn set_metadata(&amp;self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-0-38" id="h16-0-38" class="i">+        self.kv.set_metadata(key, value)
</a><a href="#h16-0-39" id="h16-0-39" class="i">+    }
</a> }
 
<a href="#h16-0-42" id="h16-0-42" class="d">-impl&lt;S: kv::storage::Storage&gt; super::Engine for KV&lt;S&gt; {
</a><a href="#h16-0-43" id="h16-0-43" class="i">+impl&lt;S: Storage&gt; super::Engine for KV&lt;S&gt; {
</a>     type Transaction = Transaction&lt;S&gt;;
 
     fn begin(&amp;self, mode: super::Mode) -&gt; Result&lt;Self::Transaction, Error&gt; {
<a href="#h16-1" id="h16-1" class="h">@@ -40,11 +51,11 @@ impl&lt;S: kv::storage::Storage&gt; super::Engine for KV&lt;S&gt; {
</a> }
 
 /// An SQL transaction based on an MVCC key/value transaction
<a href="#h16-1-3" id="h16-1-3" class="d">-pub struct Transaction&lt;S: kv::storage::Storage&gt; {
</a><a href="#h16-1-4" id="h16-1-4" class="i">+pub struct Transaction&lt;S: Storage&gt; {
</a>     txn: kv::Transaction&lt;S&gt;,
 }
 
<a href="#h16-1-8" id="h16-1-8" class="d">-impl&lt;S: kv::storage::Storage&gt; Transaction&lt;S&gt; {
</a><a href="#h16-1-9" id="h16-1-9" class="i">+impl&lt;S: Storage&gt; Transaction&lt;S&gt; {
</a>     /// Creates a new SQL transaction from an MVCC transaction
     fn new(txn: kv::Transaction&lt;S&gt;) -&gt; Self {
         Self { txn }
<a href="#h16-2" id="h16-2" class="h">@@ -85,7 +96,7 @@ impl&lt;S: kv::storage::Storage&gt; Transaction&lt;S&gt; {
</a>     }
 }
 
<a href="#h16-2-3" id="h16-2-3" class="d">-impl&lt;S: kv::storage::Storage&gt; super::Transaction for Transaction&lt;S&gt; {
</a><a href="#h16-2-4" id="h16-2-4" class="i">+impl&lt;S: Storage&gt; super::Transaction for Transaction&lt;S&gt; {
</a>     fn id(&amp;self) -&gt; u64 {
         self.txn.id()
     }
<a href="#h16-3" id="h16-3" class="h">@@ -233,7 +244,7 @@ impl&lt;S: kv::storage::Storage&gt; super::Transaction for Transaction&lt;S&gt; {
</a>     }
 }
 
<a href="#h16-3-3" id="h16-3-3" class="d">-impl&lt;S: kv::storage::Storage&gt; Catalog for Transaction&lt;S&gt; {
</a><a href="#h16-3-4" id="h16-3-4" class="i">+impl&lt;S: Storage&gt; Catalog for Transaction&lt;S&gt; {
</a>     fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;(), Error&gt; {
         if self.read_table(&amp;table.name)?.is_some() {
             return Err(Error::Value(format!(&quot;Table {} already exists&quot;, table.name)));
<b>diff --git a/<a id="h17" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -2,6 +2,7 @@ use super::super::schema::{Catalog, Table, Tables};
</a> use super::super::types::{Expression, Row, Value};
 use super::{Engine as _, IndexScan, Mode, Scan, Transaction as _};
 use crate::kv;
<a href="#h17-0-3" id="h17-0-3" class="i">+use crate::kv::storage::Storage;
</a> use crate::raft;
 use crate::utility::{deserialize, serialize};
 use crate::Error;
<a href="#h17-1" id="h17-1" class="h">@@ -66,13 +67,13 @@ impl Raft {
</a>     }
 
     /// Creates an underlying state machine for a Raft engine.
<a href="#h17-1-3" id="h17-1-3" class="d">-    pub fn new_state&lt;S: kv::storage::Storage&gt;(kv: kv::MVCC&lt;S&gt;) -&gt; State&lt;S&gt; {
</a><a href="#h17-1-4" id="h17-1-4" class="i">+    pub fn new_state&lt;S: Storage&gt;(kv: kv::MVCC&lt;S&gt;) -&gt; Result&lt;State&lt;S&gt;, Error&gt; {
</a>         State::new(kv)
     }
 
     /// Returns engine status, for now just the Raft status.
     pub fn status(&amp;self) -&gt; Result&lt;raft::Status, Error&gt; {
<a href="#h17-1-10" id="h17-1-10" class="d">-        self.client.status_sync()
</a><a href="#h17-1-11" id="h17-1-11" class="i">+        futures::executor::block_on(self.client.status())
</a>     }
 }
 
<a href="#h17-2" id="h17-2" class="h">@@ -102,15 +103,29 @@ pub struct Transaction {
</a> impl Transaction {
     /// Starts a transaction in the given mode
     fn begin(client: raft::Client, mode: Mode) -&gt; Result&lt;Self, Error&gt; {
<a href="#h17-2-3" id="h17-2-3" class="d">-        let id = deserialize(&amp;client.mutate_sync(serialize(&amp;Mutation::Begin(mode))?)?)?;
</a><a href="#h17-2-4" id="h17-2-4" class="i">+        let id = deserialize(&amp;futures::executor::block_on(
</a><a href="#h17-2-5" id="h17-2-5" class="i">+            client.mutate(serialize(&amp;Mutation::Begin(mode))?),
</a><a href="#h17-2-6" id="h17-2-6" class="i">+        )?)?;
</a>         Ok(Self { client, id, mode })
     }
 
     /// Resumes an active transaction
     fn resume(client: raft::Client, id: u64) -&gt; Result&lt;Self, Error&gt; {
<a href="#h17-2-12" id="h17-2-12" class="d">-        let (id, mode) = deserialize(&amp;client.query_sync(serialize(&amp;Query::Resume(id))?)?)?;
</a><a href="#h17-2-13" id="h17-2-13" class="i">+        let (id, mode) = deserialize(&amp;futures::executor::block_on(
</a><a href="#h17-2-14" id="h17-2-14" class="i">+            client.query(serialize(&amp;Query::Resume(id))?),
</a><a href="#h17-2-15" id="h17-2-15" class="i">+        )?)?;
</a>         Ok(Self { client, id, mode })
     }
<a href="#h17-2-18" id="h17-2-18" class="i">+
</a><a href="#h17-2-19" id="h17-2-19" class="i">+    /// Executes a mutation
</a><a href="#h17-2-20" id="h17-2-20" class="i">+    fn mutate(&amp;self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h17-2-21" id="h17-2-21" class="i">+        futures::executor::block_on(self.client.mutate(serialize(&amp;mutation)?))
</a><a href="#h17-2-22" id="h17-2-22" class="i">+    }
</a><a href="#h17-2-23" id="h17-2-23" class="i">+
</a><a href="#h17-2-24" id="h17-2-24" class="i">+    /// Executes a query
</a><a href="#h17-2-25" id="h17-2-25" class="i">+    fn query(&amp;self, query: Query) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h17-2-26" id="h17-2-26" class="i">+        futures::executor::block_on(self.client.query(serialize(&amp;query)?))
</a><a href="#h17-2-27" id="h17-2-27" class="i">+    }
</a> }
 
 impl super::Transaction for Transaction {
<a href="#h17-3" id="h17-3" class="h">@@ -123,35 +138,35 @@ impl super::Transaction for Transaction {
</a>     }
 
     fn commit(self) -&gt; Result&lt;(), Error&gt; {
<a href="#h17-3-3" id="h17-3-3" class="d">-        deserialize(&amp;self.client.mutate_sync(serialize(&amp;Mutation::Commit(self.id))?)?)
</a><a href="#h17-3-4" id="h17-3-4" class="i">+        deserialize(&amp;self.mutate(Mutation::Commit(self.id))?)
</a>     }
 
     fn rollback(self) -&gt; Result&lt;(), Error&gt; {
<a href="#h17-3-8" id="h17-3-8" class="d">-        deserialize(&amp;self.client.mutate_sync(serialize(&amp;Mutation::Rollback(self.id))?)?)
</a><a href="#h17-3-9" id="h17-3-9" class="i">+        deserialize(&amp;self.mutate(Mutation::Rollback(self.id))?)
</a>     }
 
     fn create(&amp;mut self, table: &amp;str, row: Row) -&gt; Result&lt;(), Error&gt; {
<a href="#h17-3-13" id="h17-3-13" class="d">-        deserialize(&amp;self.client.mutate_sync(serialize(&amp;Mutation::Create {
</a><a href="#h17-3-14" id="h17-3-14" class="i">+        deserialize(&amp;self.mutate(Mutation::Create {
</a>             txn_id: self.id,
             table: table.to_string(),
             row,
<a href="#h17-3-18" id="h17-3-18" class="d">-        })?)?)
</a><a href="#h17-3-19" id="h17-3-19" class="i">+        })?)
</a>     }
 
     fn delete(&amp;mut self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;(), Error&gt; {
<a href="#h17-3-23" id="h17-3-23" class="d">-        deserialize(&amp;self.client.mutate_sync(serialize(&amp;Mutation::Delete {
</a><a href="#h17-3-24" id="h17-3-24" class="i">+        deserialize(&amp;self.mutate(Mutation::Delete {
</a>             txn_id: self.id,
             table: table.to_string(),
             id: id.clone(),
<a href="#h17-3-28" id="h17-3-28" class="d">-        })?)?)
</a><a href="#h17-3-29" id="h17-3-29" class="i">+        })?)
</a>     }
 
     fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;, Error&gt; {
<a href="#h17-3-33" id="h17-3-33" class="d">-        deserialize(&amp;self.client.query_sync(serialize(&amp;Query::Read {
</a><a href="#h17-3-34" id="h17-3-34" class="i">+        deserialize(&amp;self.query(Query::Read {
</a>             txn_id: self.id,
             table: table.to_string(),
             id: id.clone(),
<a href="#h17-3-38" id="h17-3-38" class="d">-        })?)?)
</a><a href="#h17-3-39" id="h17-3-39" class="i">+        })?)
</a>     }
 
     fn read_index(
<a href="#h17-4" id="h17-4" class="h">@@ -160,21 +175,21 @@ impl super::Transaction for Transaction {
</a>         column: &amp;str,
         value: &amp;Value,
     ) -&gt; Result&lt;HashSet&lt;Value&gt;, Error&gt; {
<a href="#h17-4-3" id="h17-4-3" class="d">-        deserialize(&amp;self.client.query_sync(serialize(&amp;Query::ReadIndex {
</a><a href="#h17-4-4" id="h17-4-4" class="i">+        deserialize(&amp;self.query(Query::ReadIndex {
</a>             txn_id: self.id,
             table: table.to_string(),
             column: column.to_string(),
             value: value.clone(),
<a href="#h17-4-9" id="h17-4-9" class="d">-        })?)?)
</a><a href="#h17-4-10" id="h17-4-10" class="i">+        })?)
</a>     }
 
     fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Scan, Error&gt; {
         Ok(Box::new(
<a href="#h17-4-15" id="h17-4-15" class="d">-            deserialize::&lt;Vec&lt;_&gt;&gt;(&amp;self.client.query_sync(serialize(&amp;Query::Scan {
</a><a href="#h17-4-16" id="h17-4-16" class="i">+            deserialize::&lt;Vec&lt;_&gt;&gt;(&amp;self.query(Query::Scan {
</a>                 txn_id: self.id,
                 table: table.to_string(),
                 filter,
<a href="#h17-4-20" id="h17-4-20" class="d">-            })?)?)?
</a><a href="#h17-4-21" id="h17-4-21" class="i">+            })?)?
</a>             .into_iter()
             .map(Ok),
         ))
<a href="#h17-5" id="h17-5" class="h">@@ -182,74 +197,68 @@ impl super::Transaction for Transaction {
</a> 
     fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;IndexScan, Error&gt; {
         Ok(Box::new(
<a href="#h17-5-3" id="h17-5-3" class="d">-            deserialize::&lt;Vec&lt;_&gt;&gt;(&amp;self.client.query_sync(serialize(&amp;Query::ScanIndex {
</a><a href="#h17-5-4" id="h17-5-4" class="i">+            deserialize::&lt;Vec&lt;_&gt;&gt;(&amp;self.query(Query::ScanIndex {
</a>                 txn_id: self.id,
                 table: table.to_string(),
                 column: column.to_string(),
<a href="#h17-5-8" id="h17-5-8" class="d">-            })?)?)?
</a><a href="#h17-5-9" id="h17-5-9" class="i">+            })?)?
</a>             .into_iter()
             .map(Ok),
         ))
     }
 
     fn update(&amp;mut self, table: &amp;str, id: &amp;Value, row: Row) -&gt; Result&lt;(), Error&gt; {
<a href="#h17-5-16" id="h17-5-16" class="d">-        deserialize(&amp;self.client.mutate_sync(serialize(&amp;Mutation::Update {
</a><a href="#h17-5-17" id="h17-5-17" class="i">+        deserialize(&amp;self.mutate(Mutation::Update {
</a>             txn_id: self.id,
             table: table.to_string(),
             id: id.clone(),
             row,
<a href="#h17-5-22" id="h17-5-22" class="d">-        })?)?)
</a><a href="#h17-5-23" id="h17-5-23" class="i">+        })?)
</a>     }
 }
 
 impl Catalog for Transaction {
     fn create_table(&amp;mut self, table: &amp;Table) -&gt; Result&lt;(), Error&gt; {
<a href="#h17-5-29" id="h17-5-29" class="d">-        deserialize(&amp;self.client.mutate_sync(serialize(&amp;Mutation::CreateTable {
</a><a href="#h17-5-30" id="h17-5-30" class="d">-            txn_id: self.id,
</a><a href="#h17-5-31" id="h17-5-31" class="d">-            schema: table.clone(),
</a><a href="#h17-5-32" id="h17-5-32" class="d">-        })?)?)
</a><a href="#h17-5-33" id="h17-5-33" class="i">+        deserialize(&amp;self.mutate(Mutation::CreateTable { txn_id: self.id, schema: table.clone() })?)
</a>     }
 
     fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;(), Error&gt; {
<a href="#h17-5-37" id="h17-5-37" class="d">-        deserialize(&amp;self.client.mutate_sync(serialize(&amp;Mutation::DeleteTable {
</a><a href="#h17-5-38" id="h17-5-38" class="d">-            txn_id: self.id,
</a><a href="#h17-5-39" id="h17-5-39" class="d">-            table: table.to_string(),
</a><a href="#h17-5-40" id="h17-5-40" class="d">-        })?)?)
</a><a href="#h17-5-41" id="h17-5-41" class="i">+        deserialize(
</a><a href="#h17-5-42" id="h17-5-42" class="i">+            &amp;self.mutate(Mutation::DeleteTable { txn_id: self.id, table: table.to_string() })?,
</a><a href="#h17-5-43" id="h17-5-43" class="i">+        )
</a>     }
 
     fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;, Error&gt; {
<a href="#h17-5-47" id="h17-5-47" class="d">-        deserialize(&amp;self.client.query_sync(serialize(&amp;Query::ReadTable {
</a><a href="#h17-5-48" id="h17-5-48" class="d">-            txn_id: self.id,
</a><a href="#h17-5-49" id="h17-5-49" class="d">-            table: table.to_string(),
</a><a href="#h17-5-50" id="h17-5-50" class="d">-        })?)?)
</a><a href="#h17-5-51" id="h17-5-51" class="i">+        deserialize(&amp;self.query(Query::ReadTable { txn_id: self.id, table: table.to_string() })?)
</a>     }
 
     fn scan_tables(&amp;self) -&gt; Result&lt;Tables, Error&gt; {
         Ok(Box::new(
<a href="#h17-5-56" id="h17-5-56" class="d">-            deserialize::&lt;Vec&lt;_&gt;&gt;(
</a><a href="#h17-5-57" id="h17-5-57" class="d">-                &amp;self.client.query_sync(serialize(&amp;Query::ScanTables { txn_id: self.id })?)?,
</a><a href="#h17-5-58" id="h17-5-58" class="d">-            )?
</a><a href="#h17-5-59" id="h17-5-59" class="d">-            .into_iter(),
</a><a href="#h17-5-60" id="h17-5-60" class="i">+            deserialize::&lt;Vec&lt;_&gt;&gt;(&amp;self.query(Query::ScanTables { txn_id: self.id })?)?.into_iter(),
</a>         ))
     }
 }
 
 /// The Raft state machine for the Raft-based SQL engine, using a KV SQL engine
<a href="#h17-5-66" id="h17-5-66" class="d">-pub struct State&lt;S: kv::storage::Storage&gt; {
</a><a href="#h17-5-67" id="h17-5-67" class="i">+pub struct State&lt;S: Storage&gt; {
</a>     /// The underlying KV SQL engine
     engine: super::KV&lt;S&gt;,
<a href="#h17-5-70" id="h17-5-70" class="i">+    /// The last applied index
</a><a href="#h17-5-71" id="h17-5-71" class="i">+    applied_index: u64,
</a> }
 
<a href="#h17-5-74" id="h17-5-74" class="d">-impl&lt;S: kv::storage::Storage&gt; State&lt;S&gt; {
</a><a href="#h17-5-75" id="h17-5-75" class="i">+impl&lt;S: Storage&gt; State&lt;S&gt; {
</a>     /// Creates a new Raft state maching using the given MVCC key/value store
<a href="#h17-5-77" id="h17-5-77" class="d">-    pub fn new(store: kv::MVCC&lt;S&gt;) -&gt; Self {
</a><a href="#h17-5-78" id="h17-5-78" class="d">-        State { engine: super::KV::new(store) }
</a><a href="#h17-5-79" id="h17-5-79" class="i">+    pub fn new(store: kv::MVCC&lt;S&gt;) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h17-5-80" id="h17-5-80" class="i">+        let engine = super::KV::new(store);
</a><a href="#h17-5-81" id="h17-5-81" class="i">+        let applied_index =
</a><a href="#h17-5-82" id="h17-5-82" class="i">+            engine.get_metadata(b&quot;applied_index&quot;)?.map(|b| deserialize(&amp;b)).unwrap_or(Ok(0))?;
</a><a href="#h17-5-83" id="h17-5-83" class="i">+        Ok(State { engine, applied_index })
</a>     }
<a href="#h17-5-85" id="h17-5-85" class="d">-}
</a> 
<a href="#h17-5-87" id="h17-5-87" class="d">-impl&lt;S: kv::storage::Storage&gt; raft::State for State&lt;S&gt; {
</a><a href="#h17-5-88" id="h17-5-88" class="d">-    fn mutate(&amp;mut self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h17-5-89" id="h17-5-89" class="d">-        match deserialize(&amp;command)? {
</a><a href="#h17-5-90" id="h17-5-90" class="i">+    /// Applies a state machine mutation
</a><a href="#h17-5-91" id="h17-5-91" class="i">+    fn apply(&amp;mut self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h17-5-92" id="h17-5-92" class="i">+        match mutation {
</a>             Mutation::Begin(mode) =&gt; serialize(&amp;self.engine.begin(mode)?.id()),
             Mutation::Commit(txn_id) =&gt; serialize(&amp;self.engine.resume(txn_id)?.commit()?),
             Mutation::Rollback(txn_id) =&gt; serialize(&amp;self.engine.resume(txn_id)?.rollback()?),
<a href="#h17-6" id="h17-6" class="h">@@ -272,6 +281,25 @@ impl&lt;S: kv::storage::Storage&gt; raft::State for State&lt;S&gt; {
</a>             }
         }
     }
<a href="#h17-6-3" id="h17-6-3" class="i">+}
</a><a href="#h17-6-4" id="h17-6-4" class="i">+
</a><a href="#h17-6-5" id="h17-6-5" class="i">+impl&lt;S: Storage&gt; raft::State for State&lt;S&gt; {
</a><a href="#h17-6-6" id="h17-6-6" class="i">+    fn applied_index(&amp;self) -&gt; u64 {
</a><a href="#h17-6-7" id="h17-6-7" class="i">+        self.applied_index
</a><a href="#h17-6-8" id="h17-6-8" class="i">+    }
</a><a href="#h17-6-9" id="h17-6-9" class="i">+
</a><a href="#h17-6-10" id="h17-6-10" class="i">+    fn mutate(&amp;mut self, index: u64, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h17-6-11" id="h17-6-11" class="i">+        // We don&#39;t check that index == applied_index + 1, since the Raft log commits no-op
</a><a href="#h17-6-12" id="h17-6-12" class="i">+        // entries during leader election which we need to ignore.
</a><a href="#h17-6-13" id="h17-6-13" class="i">+        match self.apply(deserialize(&amp;command)?) {
</a><a href="#h17-6-14" id="h17-6-14" class="i">+            error @ Err(Error::Internal(_)) =&gt; error,
</a><a href="#h17-6-15" id="h17-6-15" class="i">+            result =&gt; {
</a><a href="#h17-6-16" id="h17-6-16" class="i">+                self.engine.set_metadata(b&quot;applied_index&quot;, serialize(&amp;(index))?)?;
</a><a href="#h17-6-17" id="h17-6-17" class="i">+                self.applied_index = index;
</a><a href="#h17-6-18" id="h17-6-18" class="i">+                result
</a><a href="#h17-6-19" id="h17-6-19" class="i">+            }
</a><a href="#h17-6-20" id="h17-6-20" class="i">+        }
</a><a href="#h17-6-21" id="h17-6-21" class="i">+    }
</a> 
     fn query(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
         match deserialize(&amp;command)? {
<b>diff --git a/<a id="h18" href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a> b/<a href="../file/tests/client/mod.rs.html">tests/client/mod.rs</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -121,7 +121,7 @@ async fn status() -&gt; Result&lt;(), Error&gt; {
</a>         Status {
             id: &quot;test&quot;.into(),
             role: &quot;leader&quot;.into(),
<a href="#h18-0-3" id="h18-0-3" class="d">-            leader: Some(&quot;test&quot;.into()),
</a><a href="#h18-0-4" id="h18-0-4" class="i">+            leader: &quot;test&quot;.into(),
</a>             nodes: 1,
             term: 0,
             entries: 26,
<b>diff --git a/<a id="h19" href="../file/tests/setup.rs.html">tests/setup.rs</a> b/<a href="../file/tests/setup.rs.html">tests/setup.rs</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -75,7 +75,7 @@ pub async fn server(
</a>     peers: HashMap&lt;String, String&gt;,
 ) -&gt; Result&lt;Teardown, Error&gt; {
     let dir = TempDir::new(&quot;toydb&quot;)?;
<a href="#h19-0-3" id="h19-0-3" class="d">-    let mut srv = Server::new(id, peers, &amp;dir.path().to_string_lossy())?;
</a><a href="#h19-0-4" id="h19-0-4" class="i">+    let mut srv = Server::new(id, peers, &amp;dir.path().to_string_lossy()).await?;
</a> 
     srv = srv.listen(addr_sql, addr_raft).await?;
     let (task, abort) = srv.serve().remote_handle();
<a href="#h19-1" id="h19-1" class="h">@@ -136,9 +136,6 @@ pub async fn cluster_with_clients(
</a>         clients.push(client);
     }
 
<a href="#h19-1-3" id="h19-1-3" class="d">-    // FIXME Wait for cluster to stabilize, see: https://github.com/erikgrinaker/toydb/issues/19
</a><a href="#h19-1-4" id="h19-1-4" class="d">-    tokio::time::delay_for(std::time::Duration::from_millis(2000)).await;
</a><a href="#h19-1-5" id="h19-1-5" class="d">-
</a>     if !queries.is_empty() {
         let c = clients.get_mut(0).unwrap();
         c.execute(&quot;BEGIN&quot;).await?;
<a href="#h19-2" id="h19-2" class="h">@@ -167,9 +164,7 @@ pub async fn cluster_with_pool(
</a>     let teardown = cluster(nodes.clone()).await?;
 
     let pool = Pool::new(nodes.into_iter().map(|(_, (addr, _))| addr).collect(), pool_size).await?;
<a href="#h19-2-3" id="h19-2-3" class="d">-
</a><a href="#h19-2-4" id="h19-2-4" class="d">-    // FIXME Wait for cluster to stabilize, see: https://github.com/erikgrinaker/toydb/issues/19
</a><a href="#h19-2-5" id="h19-2-5" class="d">-    tokio::time::delay_for(std::time::Duration::from_millis(2000)).await;
</a><a href="#h19-2-6" id="h19-2-6" class="i">+    pool.get().await.status().await?;
</a> 
     if !queries.is_empty() {
         let c = pool.get().await;
</pre>
</div>
</body>
</html>
