<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>server: clean up code - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/431e91e826e129ae3f2c705cb9a2901d15508639.html">431e91e826e129ae3f2c705cb9a2901d15508639</a>
<b>parent</b> <a href="../commit/7681346717791df4a75d9f28ada750d7a90c1a76.html">7681346717791df4a75d9f28ada750d7a90c1a76</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Fri, 12 Apr 2024 13:26:16 +0200

server: clean up code

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/message.rs</a></td><td> | </td><td class="num">6</td><td><span class="i"></span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/raft/mod.rs</a></td><td> | </td><td class="num">20</td><td><span class="i">++++++++++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/node/leader.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">+++++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/node/mod.rs</a></td><td> | </td><td class="num">15</td><td><span class="i">+</span><span class="d">--------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/server.rs</a></td><td> | </td><td class="num">276</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">7</td><td><span class="i">++++</span><span class="d">---</span></td></tr>
</table></pre><pre>6 files changed, 172 insertions(+), 160 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/message.rs.html">src/raft/message.rs</a> b/<a href="../file/src/raft/message.rs.html">src/raft/message.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -5,12 +5,6 @@ use crate::storage;
</a> use serde_derive::{Deserialize, Serialize};
 use std::collections::HashMap;
 
<a href="#h0-0-3" id="h0-0-3" class="d">-// TODO: simplify these types and move them elsewhere.
</a><a href="#h0-0-4" id="h0-0-4" class="d">-pub type ClientSender =
</a><a href="#h0-0-5" id="h0-0-5" class="d">-    crossbeam::channel::Sender&lt;(Request, crossbeam::channel::Sender&lt;Result&lt;Response&gt;&gt;)&gt;;
</a><a href="#h0-0-6" id="h0-0-6" class="d">-pub type ClientReceiver =
</a><a href="#h0-0-7" id="h0-0-7" class="d">-    crossbeam::channel::Receiver&lt;(Request, crossbeam::channel::Sender&lt;Result&lt;Response&gt;&gt;)&gt;;
</a><a href="#h0-0-8" id="h0-0-8" class="d">-
</a> /// A message passed between Raft nodes.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub struct Message {
<b>diff --git a/<a id="h1" href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a> b/<a href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -3,10 +3,18 @@ mod message;
</a> mod node;
 mod state;
 
<a href="#h1-0-3" id="h1-0-3" class="d">-pub use self::log::{Entry, Index, Log};
</a><a href="#h1-0-4" id="h1-0-4" class="d">-pub use message::{
</a><a href="#h1-0-5" id="h1-0-5" class="d">-    ClientReceiver, ClientSender, Event, Message, ReadSequence, Request, RequestID, Response,
</a><a href="#h1-0-6" id="h1-0-6" class="d">-    Status,
</a><a href="#h1-0-7" id="h1-0-7" class="d">-};
</a><a href="#h1-0-8" id="h1-0-8" class="d">-pub use node::{Node, NodeID, Term, TICK_INTERVAL};
</a><a href="#h1-0-9" id="h1-0-9" class="i">+pub use log::{Entry, Index, Log};
</a><a href="#h1-0-10" id="h1-0-10" class="i">+pub use message::{Event, Message, ReadSequence, Request, RequestID, Response, Status};
</a><a href="#h1-0-11" id="h1-0-11" class="i">+pub use node::{Node, NodeID, Term, Ticks};
</a> pub use state::State;
<a href="#h1-0-13" id="h1-0-13" class="i">+
</a><a href="#h1-0-14" id="h1-0-14" class="i">+/// The interval between Raft ticks. This is the unit of time for heartbeats and
</a><a href="#h1-0-15" id="h1-0-15" class="i">+/// elections.
</a><a href="#h1-0-16" id="h1-0-16" class="i">+pub const TICK_INTERVAL: std::time::Duration = std::time::Duration::from_millis(100);
</a><a href="#h1-0-17" id="h1-0-17" class="i">+
</a><a href="#h1-0-18" id="h1-0-18" class="i">+/// The interval between leader heartbeats, in ticks.
</a><a href="#h1-0-19" id="h1-0-19" class="i">+pub const HEARTBEAT_INTERVAL: Ticks = 3;
</a><a href="#h1-0-20" id="h1-0-20" class="i">+
</a><a href="#h1-0-21" id="h1-0-21" class="i">+/// The election timeout range, in ticks. This is randomized per node in this
</a><a href="#h1-0-22" id="h1-0-22" class="i">+/// interval, to avoid ties.
</a><a href="#h1-0-23" id="h1-0-23" class="i">+const ELECTION_TIMEOUT_RANGE: std::ops::Range&lt;Ticks&gt; = 10..20;
</a><b>diff --git a/<a id="h2" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,8 +1,10 @@
</a><a href="#h2-0-0" id="h2-0-0" class="d">-use super::super::{Event, Index, Message, ReadSequence, Request, RequestID, Response, Status};
</a><a href="#h2-0-1" id="h2-0-1" class="d">-use super::{Follower, Node, NodeID, RawNode, Role, Term, Ticks, HEARTBEAT_INTERVAL};
</a><a href="#h2-0-2" id="h2-0-2" class="i">+use super::super::{
</a><a href="#h2-0-3" id="h2-0-3" class="i">+    Event, Index, Message, ReadSequence, Request, RequestID, Response, Status, HEARTBEAT_INTERVAL,
</a><a href="#h2-0-4" id="h2-0-4" class="i">+};
</a><a href="#h2-0-5" id="h2-0-5" class="i">+use super::{Follower, Node, NodeID, RawNode, Role, Term, Ticks};
</a> use crate::error::{Error, Result};
 
<a href="#h2-0-8" id="h2-0-8" class="d">-use ::log::{debug, info};
</a><a href="#h2-0-9" id="h2-0-9" class="i">+use log::{debug, info};
</a> use std::collections::{HashMap, HashSet, VecDeque};
 
 /// Peer replication progress.
<b>diff --git a/<a id="h3" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -2,7 +2,7 @@ mod candidate;
</a> mod follower;
 mod leader;
 
<a href="#h3-0-3" id="h3-0-3" class="d">-use super::{Event, Index, Log, Message, State};
</a><a href="#h3-0-4" id="h3-0-4" class="i">+use super::{Event, Index, Log, Message, State, ELECTION_TIMEOUT_RANGE};
</a> use crate::error::{Error, Result};
 use candidate::Candidate;
 use follower::Follower;
<a href="#h3-1" id="h3-1" class="h">@@ -22,19 +22,6 @@ pub type Term = u64;
</a> /// A logical clock interval as number of ticks.
 pub type Ticks = u8;
 
<a href="#h3-1-3" id="h3-1-3" class="d">-/// The interval between leader heartbeats, in ticks.
</a><a href="#h3-1-4" id="h3-1-4" class="d">-const HEARTBEAT_INTERVAL: Ticks = 3;
</a><a href="#h3-1-5" id="h3-1-5" class="d">-
</a><a href="#h3-1-6" id="h3-1-6" class="d">-/// The interval between Raft ticks, the unit of time for e.g. heartbeats and
</a><a href="#h3-1-7" id="h3-1-7" class="d">-/// elections.
</a><a href="#h3-1-8" id="h3-1-8" class="d">-///
</a><a href="#h3-1-9" id="h3-1-9" class="d">-/// TODO: consider moving this and other options elsewhere.
</a><a href="#h3-1-10" id="h3-1-10" class="d">-pub const TICK_INTERVAL: std::time::Duration = std::time::Duration::from_millis(100);
</a><a href="#h3-1-11" id="h3-1-11" class="d">-
</a><a href="#h3-1-12" id="h3-1-12" class="d">-/// The randomized election timeout range (min-max), in ticks. This is
</a><a href="#h3-1-13" id="h3-1-13" class="d">-/// randomized per node to avoid ties.
</a><a href="#h3-1-14" id="h3-1-14" class="d">-const ELECTION_TIMEOUT_RANGE: std::ops::Range&lt;u8&gt; = 10..20;
</a><a href="#h3-1-15" id="h3-1-15" class="d">-
</a> /// Generates a randomized election timeout.
 fn rand_election_timeout() -&gt; Ticks {
     rand::thread_rng().gen_range(ELECTION_TIMEOUT_RANGE)
<b>diff --git a/<a id="h4" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -7,14 +7,35 @@ use crate::sql::execution::ResultSet;
</a> use crate::sql::schema::{Catalog as _, Table};
 use crate::sql::types::Row;
 
<a href="#h4-0-3" id="h4-0-3" class="i">+use crossbeam::channel::{Receiver, Sender};
</a> use log::{debug, error, info};
 use serde_derive::{Deserialize, Serialize};
 use std::collections::HashMap;
<a href="#h4-0-7" id="h4-0-7" class="i">+use std::net::{TcpListener, TcpStream, ToSocketAddrs};
</a> 
<a href="#h4-0-9" id="h4-0-9" class="d">-/// A toyDB server.
</a><a href="#h4-0-10" id="h4-0-10" class="i">+/// The outbound Raft peer channel capacity. This buffers messages when a Raft
</a><a href="#h4-0-11" id="h4-0-11" class="i">+/// peer is slow or unavailable. Beyond this, messages will be dropped.
</a><a href="#h4-0-12" id="h4-0-12" class="i">+const RAFT_PEER_CHANNEL_CAPACITY: usize = 1000;
</a><a href="#h4-0-13" id="h4-0-13" class="i">+
</a><a href="#h4-0-14" id="h4-0-14" class="i">+/// The retry interval when connecting to a Raft peer.
</a><a href="#h4-0-15" id="h4-0-15" class="i">+const RAFT_PEER_RETRY_INTERVAL: std::time::Duration = std::time::Duration::from_secs(1);
</a><a href="#h4-0-16" id="h4-0-16" class="i">+
</a><a href="#h4-0-17" id="h4-0-17" class="i">+/// A toyDB server. Routes messages to/from an inner Raft node.
</a><a href="#h4-0-18" id="h4-0-18" class="i">+///
</a><a href="#h4-0-19" id="h4-0-19" class="i">+/// - Listens for inbound Raft connections via TCP and passes messages to the
</a><a href="#h4-0-20" id="h4-0-20" class="i">+///   local Raft node.
</a><a href="#h4-0-21" id="h4-0-21" class="i">+///
</a><a href="#h4-0-22" id="h4-0-22" class="i">+/// - Connects to Raft peers via TCP and sends outbound messages from the
</a><a href="#h4-0-23" id="h4-0-23" class="i">+///   local Raft node.
</a><a href="#h4-0-24" id="h4-0-24" class="i">+///
</a><a href="#h4-0-25" id="h4-0-25" class="i">+/// - Listens for inbound SQL connections via TCP and passes requests to
</a><a href="#h4-0-26" id="h4-0-26" class="i">+///   the local Raft node.
</a> pub struct Server {
<a href="#h4-0-28" id="h4-0-28" class="i">+    /// The inner Raft node.
</a>     node: raft::Node,
<a href="#h4-0-30" id="h4-0-30" class="d">-    node_rx: crossbeam::channel::Receiver&lt;raft::Message&gt;,
</a><a href="#h4-0-31" id="h4-0-31" class="i">+    /// Outbound messages from the Raft node.
</a><a href="#h4-0-32" id="h4-0-32" class="i">+    node_rx: Receiver&lt;raft::Message&gt;,
</a><a href="#h4-0-33" id="h4-0-33" class="i">+    /// Raft peer IDs and addresses.
</a>     peers: HashMap&lt;raft::NodeID, String&gt;,
 }
 
<a href="#h4-1" id="h4-1" class="h">@@ -41,13 +62,9 @@ impl Server {
</a>     }
 
     /// Serves Raft and SQL requests indefinitely. Consumes the server.
<a href="#h4-1-3" id="h4-1-3" class="d">-    pub fn serve(
</a><a href="#h4-1-4" id="h4-1-4" class="d">-        self,
</a><a href="#h4-1-5" id="h4-1-5" class="d">-        raft_addr: impl std::net::ToSocketAddrs,
</a><a href="#h4-1-6" id="h4-1-6" class="d">-        sql_addr: impl std::net::ToSocketAddrs,
</a><a href="#h4-1-7" id="h4-1-7" class="d">-    ) -&gt; Result&lt;()&gt; {
</a><a href="#h4-1-8" id="h4-1-8" class="d">-        let raft_listener = std::net::TcpListener::bind(raft_addr)?;
</a><a href="#h4-1-9" id="h4-1-9" class="d">-        let sql_listener = std::net::TcpListener::bind(sql_addr)?;
</a><a href="#h4-1-10" id="h4-1-10" class="i">+    pub fn serve(self, raft_addr: impl ToSocketAddrs, sql_addr: impl ToSocketAddrs) -&gt; Result&lt;()&gt; {
</a><a href="#h4-1-11" id="h4-1-11" class="i">+        let raft_listener = TcpListener::bind(raft_addr)?;
</a><a href="#h4-1-12" id="h4-1-12" class="i">+        let sql_listener = TcpListener::bind(sql_addr)?;
</a>         info!(
             &quot;Listening on {} (SQL) and {} (Raft)&quot;,
             sql_listener.local_addr()?,
<a href="#h4-2" id="h4-2" class="h">@@ -55,19 +72,18 @@ impl Server {
</a>         );
 
         std::thread::scope(move |s| {
<a href="#h4-2-3" id="h4-2-3" class="d">-            let (raft_client_tx, raft_client_rx) = crossbeam::channel::unbounded();
</a><a href="#h4-2-4" id="h4-2-4" class="i">+            let (raft_request_tx, raft_request_rx) = crossbeam::channel::unbounded();
</a>             let (raft_step_tx, raft_step_rx) = crossbeam::channel::unbounded();
 
             // Serve inbound Raft connections.
             s.spawn(move || Self::raft_accept(raft_listener, raft_step_tx));
 
             // Establish outbound Raft connections.
<a href="#h4-2-11" id="h4-2-11" class="d">-            let mut raft_peers_tx =
</a><a href="#h4-2-12" id="h4-2-12" class="d">-                HashMap::&lt;raft::NodeID, crossbeam::channel::Sender&lt;raft::Message&gt;&gt;::new();
</a><a href="#h4-2-13" id="h4-2-13" class="i">+            let mut raft_peers_tx = HashMap::new();
</a> 
             for (id, addr) in self.peers.into_iter() {
                 let (raft_peer_tx, raft_peer_rx) =
<a href="#h4-2-17" id="h4-2-17" class="d">-                    crossbeam::channel::bounded::&lt;raft::Message&gt;(1000); // TODO: const.
</a><a href="#h4-2-18" id="h4-2-18" class="i">+                    crossbeam::channel::bounded(RAFT_PEER_CHANNEL_CAPACITY);
</a>                 raft_peers_tx.insert(id, raft_peer_tx);
                 s.spawn(move || Self::raft_send_peer(addr, raft_peer_rx));
             }
<a href="#h4-3" id="h4-3" class="h">@@ -77,105 +93,27 @@ impl Server {
</a>                 Self::raft_route(
                     self.node,
                     self.node_rx,
<a href="#h4-3-3" id="h4-3-3" class="d">-                    raft_client_rx,
</a>                     raft_step_rx,
                     raft_peers_tx,
<a href="#h4-3-6" id="h4-3-6" class="i">+                    raft_request_rx,
</a>                 )
<a href="#h4-3-8" id="h4-3-8" class="d">-                .expect(&quot;raft processing failed&quot;)
</a>             });
 
             // Serve inbound SQL connections.
<a href="#h4-3-12" id="h4-3-12" class="d">-            s.spawn(move || Self::sql_accept(sql_listener, raft_client_tx));
</a><a href="#h4-3-13" id="h4-3-13" class="i">+            s.spawn(move || Self::sql_accept(sql_listener, raft_request_tx));
</a>         });
 
         Ok(())
     }
 
<a href="#h4-3-19" id="h4-3-19" class="d">-    /// Accepts new SQL client connections and spawns session threads for them.
</a><a href="#h4-3-20" id="h4-3-20" class="d">-    fn sql_accept(listener: std::net::TcpListener, raft_client_tx: raft::ClientSender) {
</a><a href="#h4-3-21" id="h4-3-21" class="d">-        std::thread::scope(|s| loop {
</a><a href="#h4-3-22" id="h4-3-22" class="d">-            let (socket, peer) = match listener.accept() {
</a><a href="#h4-3-23" id="h4-3-23" class="d">-                Ok(r) =&gt; r,
</a><a href="#h4-3-24" id="h4-3-24" class="d">-                Err(err) =&gt; {
</a><a href="#h4-3-25" id="h4-3-25" class="d">-                    error!(&quot;Accept failed: {err}&quot;);
</a><a href="#h4-3-26" id="h4-3-26" class="d">-                    continue;
</a><a href="#h4-3-27" id="h4-3-27" class="d">-                }
</a><a href="#h4-3-28" id="h4-3-28" class="d">-            };
</a><a href="#h4-3-29" id="h4-3-29" class="d">-            let raft_client_tx = raft_client_tx.clone();
</a><a href="#h4-3-30" id="h4-3-30" class="d">-            s.spawn(move || {
</a><a href="#h4-3-31" id="h4-3-31" class="d">-                debug!(&quot;Client {peer} connected&quot;);
</a><a href="#h4-3-32" id="h4-3-32" class="d">-                match Self::sql_session(socket, raft_client_tx) {
</a><a href="#h4-3-33" id="h4-3-33" class="d">-                    Ok(()) =&gt; debug!(&quot;Client {peer} disconnected&quot;),
</a><a href="#h4-3-34" id="h4-3-34" class="d">-                    Err(err) =&gt; error!(&quot;Client {peer} error: {err}&quot;),
</a><a href="#h4-3-35" id="h4-3-35" class="d">-                }
</a><a href="#h4-3-36" id="h4-3-36" class="d">-            });
</a><a href="#h4-3-37" id="h4-3-37" class="d">-        })
</a><a href="#h4-3-38" id="h4-3-38" class="d">-    }
</a><a href="#h4-3-39" id="h4-3-39" class="d">-
</a><a href="#h4-3-40" id="h4-3-40" class="d">-    /// Processes a client SQL session, by executing SQL statements against the
</a><a href="#h4-3-41" id="h4-3-41" class="d">-    /// Raft node.
</a><a href="#h4-3-42" id="h4-3-42" class="d">-    fn sql_session(
</a><a href="#h4-3-43" id="h4-3-43" class="d">-        mut socket: std::net::TcpStream,
</a><a href="#h4-3-44" id="h4-3-44" class="d">-        raft_client_tx: raft::ClientSender,
</a><a href="#h4-3-45" id="h4-3-45" class="d">-    ) -&gt; Result&lt;()&gt; {
</a><a href="#h4-3-46" id="h4-3-46" class="d">-        let mut session = sql::engine::Raft::new(raft_client_tx).session();
</a><a href="#h4-3-47" id="h4-3-47" class="d">-        while let Some(request) = bincode::maybe_deserialize_from(&amp;mut socket)? {
</a><a href="#h4-3-48" id="h4-3-48" class="d">-            // Execute request.
</a><a href="#h4-3-49" id="h4-3-49" class="d">-            debug!(&quot;Received request {request:?}&quot;);
</a><a href="#h4-3-50" id="h4-3-50" class="d">-            let mut response = match request {
</a><a href="#h4-3-51" id="h4-3-51" class="d">-                Request::Execute(query) =&gt; session.execute(&amp;query).map(Response::Execute),
</a><a href="#h4-3-52" id="h4-3-52" class="d">-                Request::Status =&gt; session.status().map(Response::Status),
</a><a href="#h4-3-53" id="h4-3-53" class="d">-                Request::GetTable(table) =&gt; session
</a><a href="#h4-3-54" id="h4-3-54" class="d">-                    .with_txn_read_only(|txn| txn.must_read_table(&amp;table))
</a><a href="#h4-3-55" id="h4-3-55" class="d">-                    .map(Response::GetTable),
</a><a href="#h4-3-56" id="h4-3-56" class="d">-                Request::ListTables =&gt; session
</a><a href="#h4-3-57" id="h4-3-57" class="d">-                    .with_txn_read_only(|txn| Ok(txn.scan_tables()?.map(|t| t.name).collect()))
</a><a href="#h4-3-58" id="h4-3-58" class="d">-                    .map(Response::ListTables),
</a><a href="#h4-3-59" id="h4-3-59" class="d">-            };
</a><a href="#h4-3-60" id="h4-3-60" class="d">-
</a><a href="#h4-3-61" id="h4-3-61" class="d">-            // Process response.
</a><a href="#h4-3-62" id="h4-3-62" class="d">-            debug!(&quot;Returning response {response:?}&quot;);
</a><a href="#h4-3-63" id="h4-3-63" class="d">-            let mut rows: Box&lt;dyn Iterator&lt;Item = Result&lt;Response&gt;&gt; + Send&gt; =
</a><a href="#h4-3-64" id="h4-3-64" class="d">-                Box::new(std::iter::empty());
</a><a href="#h4-3-65" id="h4-3-65" class="d">-            if let Ok(Response::Execute(ResultSet::Query { rows: ref mut resultrows, .. })) =
</a><a href="#h4-3-66" id="h4-3-66" class="d">-                &amp;mut response
</a><a href="#h4-3-67" id="h4-3-67" class="d">-            {
</a><a href="#h4-3-68" id="h4-3-68" class="d">-                // TODO: don&#39;t stream results, for simplicity.
</a><a href="#h4-3-69" id="h4-3-69" class="d">-                rows = Box::new(
</a><a href="#h4-3-70" id="h4-3-70" class="d">-                    std::mem::replace(resultrows, Box::new(std::iter::empty()))
</a><a href="#h4-3-71" id="h4-3-71" class="d">-                        .map(|result| result.map(|row| Response::Row(Some(row))))
</a><a href="#h4-3-72" id="h4-3-72" class="d">-                        .chain(std::iter::once(Ok(Response::Row(None))))
</a><a href="#h4-3-73" id="h4-3-73" class="d">-                        .scan(false, |err_sent, response| match (&amp;err_sent, &amp;response) {
</a><a href="#h4-3-74" id="h4-3-74" class="d">-                            (true, _) =&gt; None,
</a><a href="#h4-3-75" id="h4-3-75" class="d">-                            (_, Err(error)) =&gt; {
</a><a href="#h4-3-76" id="h4-3-76" class="d">-                                *err_sent = true;
</a><a href="#h4-3-77" id="h4-3-77" class="d">-                                Some(Err(error.clone()))
</a><a href="#h4-3-78" id="h4-3-78" class="d">-                            }
</a><a href="#h4-3-79" id="h4-3-79" class="d">-                            _ =&gt; Some(response),
</a><a href="#h4-3-80" id="h4-3-80" class="d">-                        })
</a><a href="#h4-3-81" id="h4-3-81" class="d">-                        .fuse(),
</a><a href="#h4-3-82" id="h4-3-82" class="d">-                );
</a><a href="#h4-3-83" id="h4-3-83" class="d">-            }
</a><a href="#h4-3-84" id="h4-3-84" class="d">-
</a><a href="#h4-3-85" id="h4-3-85" class="d">-            bincode::serialize_into(&amp;mut socket, &amp;response)?;
</a><a href="#h4-3-86" id="h4-3-86" class="d">-            for row in rows {
</a><a href="#h4-3-87" id="h4-3-87" class="d">-                bincode::serialize_into(&amp;mut socket, &amp;row)?;
</a><a href="#h4-3-88" id="h4-3-88" class="d">-            }
</a><a href="#h4-3-89" id="h4-3-89" class="d">-        }
</a><a href="#h4-3-90" id="h4-3-90" class="d">-        Ok(())
</a><a href="#h4-3-91" id="h4-3-91" class="d">-    }
</a><a href="#h4-3-92" id="h4-3-92" class="d">-
</a>     /// Accepts new inbound Raft connections from peers and spawns threads
     /// routing inbound messages to the local Raft node.
<a href="#h4-3-95" id="h4-3-95" class="d">-    fn raft_accept(
</a><a href="#h4-3-96" id="h4-3-96" class="d">-        listener: std::net::TcpListener,
</a><a href="#h4-3-97" id="h4-3-97" class="d">-        raft_step_tx: crossbeam::channel::Sender&lt;raft::Message&gt;,
</a><a href="#h4-3-98" id="h4-3-98" class="d">-    ) {
</a><a href="#h4-3-99" id="h4-3-99" class="i">+    fn raft_accept(listener: TcpListener, raft_step_tx: Sender&lt;raft::Message&gt;) {
</a>         std::thread::scope(|s| loop {
             let (socket, peer) = match listener.accept() {
<a href="#h4-3-102" id="h4-3-102" class="d">-                Ok(r) =&gt; r,
</a><a href="#h4-3-103" id="h4-3-103" class="i">+                Ok(sp) =&gt; sp,
</a>                 Err(err) =&gt; {
<a href="#h4-3-105" id="h4-3-105" class="d">-                    error!(&quot;Accept failed: {err}&quot;);
</a><a href="#h4-3-106" id="h4-3-106" class="i">+                    error!(&quot;Raft peer accept failed: {err}&quot;);
</a>                     continue;
                 }
             };
<a href="#h4-4" id="h4-4" class="h">@@ -192,32 +130,31 @@ impl Server {
</a> 
     /// Receives inbound messages from a peer via TCP, and queues them for
     /// stepping into the Raft node.
<a href="#h4-4-3" id="h4-4-3" class="d">-    fn raft_receive_peer(
</a><a href="#h4-4-4" id="h4-4-4" class="d">-        mut socket: std::net::TcpStream,
</a><a href="#h4-4-5" id="h4-4-5" class="d">-        raft_step_tx: crossbeam::channel::Sender&lt;raft::Message&gt;,
</a><a href="#h4-4-6" id="h4-4-6" class="d">-    ) -&gt; Result&lt;()&gt; {
</a><a href="#h4-4-7" id="h4-4-7" class="i">+    fn raft_receive_peer(mut socket: TcpStream, raft_step_tx: Sender&lt;raft::Message&gt;) -&gt; Result&lt;()&gt; {
</a>         while let Some(message) = bincode::maybe_deserialize_from(&amp;mut socket)? {
             raft_step_tx.send(message)?;
         }
         Ok(())
     }
 
<a href="#h4-4-14" id="h4-4-14" class="d">-    /// Sends outbound messages to a peer via TCP.
</a><a href="#h4-4-15" id="h4-4-15" class="d">-    fn raft_send_peer(addr: String, rx: crossbeam::channel::Receiver&lt;raft::Message&gt;) {
</a><a href="#h4-4-16" id="h4-4-16" class="i">+    /// Sends outbound messages to a peer via TCP. Retries indefinitely if the
</a><a href="#h4-4-17" id="h4-4-17" class="i">+    /// connection fails.
</a><a href="#h4-4-18" id="h4-4-18" class="i">+    fn raft_send_peer(addr: String, raft_node_rx: Receiver&lt;raft::Message&gt;) {
</a>         loop {
<a href="#h4-4-20" id="h4-4-20" class="d">-            match std::net::TcpStream::connect(&amp;addr) {
</a><a href="#h4-4-21" id="h4-4-21" class="d">-                Ok(mut socket) =&gt; {
</a><a href="#h4-4-22" id="h4-4-22" class="d">-                    debug!(&quot;Connected to Raft peer {addr}&quot;);
</a><a href="#h4-4-23" id="h4-4-23" class="d">-                    while let Ok(message) = rx.recv() {
</a><a href="#h4-4-24" id="h4-4-24" class="d">-                        if let Err(err) = bincode::serialize_into(&amp;mut socket, &amp;message) {
</a><a href="#h4-4-25" id="h4-4-25" class="d">-                            error!(&quot;Failed sending to Raft peer {addr}: {err}&quot;);
</a><a href="#h4-4-26" id="h4-4-26" class="d">-                            break;
</a><a href="#h4-4-27" id="h4-4-27" class="d">-                        }
</a><a href="#h4-4-28" id="h4-4-28" class="d">-                    }
</a><a href="#h4-4-29" id="h4-4-29" class="i">+            let mut socket = match TcpStream::connect(&amp;addr) {
</a><a href="#h4-4-30" id="h4-4-30" class="i">+                Ok(s) =&gt; s,
</a><a href="#h4-4-31" id="h4-4-31" class="i">+                Err(err) =&gt; {
</a><a href="#h4-4-32" id="h4-4-32" class="i">+                    error!(&quot;Failed connecting to Raft peer {addr}: {err}&quot;);
</a><a href="#h4-4-33" id="h4-4-33" class="i">+                    std::thread::sleep(RAFT_PEER_RETRY_INTERVAL);
</a><a href="#h4-4-34" id="h4-4-34" class="i">+                    continue;
</a><a href="#h4-4-35" id="h4-4-35" class="i">+                }
</a><a href="#h4-4-36" id="h4-4-36" class="i">+            };
</a><a href="#h4-4-37" id="h4-4-37" class="i">+            while let Ok(message) = raft_node_rx.recv() {
</a><a href="#h4-4-38" id="h4-4-38" class="i">+                if let Err(err) = bincode::serialize_into(&amp;mut socket, &amp;message) {
</a><a href="#h4-4-39" id="h4-4-39" class="i">+                    error!(&quot;Failed sending to Raft peer {addr}: {err}&quot;);
</a><a href="#h4-4-40" id="h4-4-40" class="i">+                    break;
</a>                 }
<a href="#h4-4-42" id="h4-4-42" class="d">-                Err(err) =&gt; error!(&quot;Failed connecting to Raft peer {addr}: {err}&quot;),
</a>             }
<a href="#h4-4-44" id="h4-4-44" class="d">-            std::thread::sleep(std::time::Duration::from_millis(1000)); // TODO: const.
</a>             debug!(&quot;Disconnected from Raft peer {addr}&quot;);
         }
     }
<a href="#h4-5" id="h4-5" class="h">@@ -236,59 +173,142 @@ impl Server {
</a>     ///
     /// - peers_tx: outbound per-peer channels sent via TCP connections.
     ///   Messages from the local node&#39;s node_rx are sent here.
<a href="#h4-5-3" id="h4-5-3" class="i">+    ///
</a><a href="#h4-5-4" id="h4-5-4" class="i">+    /// Panics on any errors, since the Raft node can&#39;t recover from failed
</a><a href="#h4-5-5" id="h4-5-5" class="i">+    /// state transitions.
</a>     fn raft_route(
         mut node: raft::Node,
<a href="#h4-5-8" id="h4-5-8" class="d">-        node_rx: crossbeam::channel::Receiver&lt;raft::Message&gt;,
</a><a href="#h4-5-9" id="h4-5-9" class="d">-        request_rx: raft::ClientReceiver,
</a><a href="#h4-5-10" id="h4-5-10" class="d">-        peers_rx: crossbeam::channel::Receiver&lt;raft::Message&gt;,
</a><a href="#h4-5-11" id="h4-5-11" class="d">-        mut peers_tx: HashMap&lt;raft::NodeID, crossbeam::channel::Sender&lt;raft::Message&gt;&gt;,
</a><a href="#h4-5-12" id="h4-5-12" class="d">-    ) -&gt; Result&lt;()&gt; {
</a><a href="#h4-5-13" id="h4-5-13" class="i">+        node_rx: Receiver&lt;raft::Message&gt;,
</a><a href="#h4-5-14" id="h4-5-14" class="i">+        peers_rx: Receiver&lt;raft::Message&gt;,
</a><a href="#h4-5-15" id="h4-5-15" class="i">+        mut peers_tx: HashMap&lt;raft::NodeID, Sender&lt;raft::Message&gt;&gt;,
</a><a href="#h4-5-16" id="h4-5-16" class="i">+        request_rx: Receiver&lt;(raft::Request, Sender&lt;Result&lt;raft::Response&gt;&gt;)&gt;,
</a><a href="#h4-5-17" id="h4-5-17" class="i">+    ) {
</a>         // Track response channels by request ID. The Raft node will emit
         // ClientResponse messages that we forward to the response channel.
<a href="#h4-5-20" id="h4-5-20" class="d">-        let mut response_txs =
</a><a href="#h4-5-21" id="h4-5-21" class="d">-            HashMap::&lt;raft::RequestID, crossbeam::channel::Sender&lt;Result&lt;raft::Response&gt;&gt;&gt;::new();
</a><a href="#h4-5-22" id="h4-5-22" class="i">+        let mut response_txs = HashMap::&lt;raft::RequestID, Sender&lt;Result&lt;raft::Response&gt;&gt;&gt;::new();
</a> 
         let ticker = crossbeam::channel::tick(raft::TICK_INTERVAL);
         loop {
             crossbeam::select! {
                 // Periodically tick the node.
<a href="#h4-5-28" id="h4-5-28" class="d">-                recv(ticker) -&gt; _ =&gt; node = node.tick()?,
</a><a href="#h4-5-29" id="h4-5-29" class="i">+                recv(ticker) -&gt; _ =&gt; node = node.tick().expect(&quot;tick failed&quot;),
</a> 
                 // Step messages from peers into the node.
<a href="#h4-5-32" id="h4-5-32" class="d">-                recv(peers_rx) -&gt; msg =&gt; node = node.step(msg?)?,
</a><a href="#h4-5-33" id="h4-5-33" class="i">+                recv(peers_rx) -&gt; result =&gt; {
</a><a href="#h4-5-34" id="h4-5-34" class="i">+                    let msg = result.expect(&quot;peers_rx disconnected&quot;);
</a><a href="#h4-5-35" id="h4-5-35" class="i">+                    node = node.step(msg).expect(&quot;step failed&quot;);
</a><a href="#h4-5-36" id="h4-5-36" class="i">+                },
</a> 
                 // Send outbound messages from the node to the appropriate peer.
                 // If we receive a client response addressed to the local node,
                 // forward it to the waiting client via the response channel.
                 recv(node_rx) -&gt; result =&gt; {
<a href="#h4-5-42" id="h4-5-42" class="d">-                    let msg = result?;
</a><a href="#h4-5-43" id="h4-5-43" class="i">+                    let msg = result.expect(&quot;node_rx disconnected&quot;);
</a>                     if msg.to == node.id() {
                         if let raft::Event::ClientResponse{ id, response } = msg.event {
                             if let Some(response_tx) = response_txs.remove(&amp;id) {
<a href="#h4-5-47" id="h4-5-47" class="d">-                                response_tx.send(response)?;
</a><a href="#h4-5-48" id="h4-5-48" class="i">+                                response_tx.send(response).expect(&quot;response_tx disconnected&quot;);
</a>                             }
                             continue
                         }
                     }
<a href="#h4-5-53" id="h4-5-53" class="d">-                    peers_tx.get_mut(&amp;msg.to).expect(&quot;unknown peer&quot;).send(msg)?;
</a><a href="#h4-5-54" id="h4-5-54" class="i">+                    let peer_tx = peers_tx.get_mut(&amp;msg.to).expect(&quot;unknown peer&quot;);
</a><a href="#h4-5-55" id="h4-5-55" class="i">+                    peer_tx.send(msg).expect(&quot;peer_tx disconnected&quot;);
</a>                 }
 
                 // Track inbound client requests and step them into the node.
                 recv(request_rx) -&gt; result =&gt; {
<a href="#h4-5-60" id="h4-5-60" class="d">-                    let (request, response_tx) = result?;
</a><a href="#h4-5-61" id="h4-5-61" class="d">-                    let id = uuid::Uuid::new_v4().as_bytes().to_vec();
</a><a href="#h4-5-62" id="h4-5-62" class="i">+                    let (request, response_tx) = result.expect(&quot;request_rx disconnected&quot;);
</a><a href="#h4-5-63" id="h4-5-63" class="i">+                    let id = uuid::Uuid::new_v4().into_bytes().to_vec();
</a>                     let msg = raft::Message{
                         from: node.id(),
                         to: node.id(),
                         term: node.term(),
                         event: raft::Event::ClientRequest{id: id.clone(), request},
                     };
<a href="#h4-5-70" id="h4-5-70" class="d">-                    node = node.step(msg)?;
</a><a href="#h4-5-71" id="h4-5-71" class="i">+                    node = node.step(msg).expect(&quot;step failed&quot;);
</a>                     response_txs.insert(id, response_tx);
                 }
             }
         }
     }
<a href="#h4-5-77" id="h4-5-77" class="i">+
</a><a href="#h4-5-78" id="h4-5-78" class="i">+    /// Accepts new SQL client connections and spawns session threads for them.
</a><a href="#h4-5-79" id="h4-5-79" class="i">+    fn sql_accept(
</a><a href="#h4-5-80" id="h4-5-80" class="i">+        listener: TcpListener,
</a><a href="#h4-5-81" id="h4-5-81" class="i">+        raft_request_tx: Sender&lt;(raft::Request, Sender&lt;Result&lt;raft::Response&gt;&gt;)&gt;,
</a><a href="#h4-5-82" id="h4-5-82" class="i">+    ) {
</a><a href="#h4-5-83" id="h4-5-83" class="i">+        std::thread::scope(|s| loop {
</a><a href="#h4-5-84" id="h4-5-84" class="i">+            let (socket, peer) = match listener.accept() {
</a><a href="#h4-5-85" id="h4-5-85" class="i">+                Ok(sp) =&gt; sp,
</a><a href="#h4-5-86" id="h4-5-86" class="i">+                Err(err) =&gt; {
</a><a href="#h4-5-87" id="h4-5-87" class="i">+                    error!(&quot;Client accept failed: {err}&quot;);
</a><a href="#h4-5-88" id="h4-5-88" class="i">+                    continue;
</a><a href="#h4-5-89" id="h4-5-89" class="i">+                }
</a><a href="#h4-5-90" id="h4-5-90" class="i">+            };
</a><a href="#h4-5-91" id="h4-5-91" class="i">+            let raft_request_tx = raft_request_tx.clone();
</a><a href="#h4-5-92" id="h4-5-92" class="i">+            s.spawn(move || {
</a><a href="#h4-5-93" id="h4-5-93" class="i">+                debug!(&quot;Client {peer} connected&quot;);
</a><a href="#h4-5-94" id="h4-5-94" class="i">+                match Self::sql_session(socket, raft_request_tx) {
</a><a href="#h4-5-95" id="h4-5-95" class="i">+                    Ok(()) =&gt; debug!(&quot;Client {peer} disconnected&quot;),
</a><a href="#h4-5-96" id="h4-5-96" class="i">+                    Err(err) =&gt; error!(&quot;Client {peer} error: {err}&quot;),
</a><a href="#h4-5-97" id="h4-5-97" class="i">+                }
</a><a href="#h4-5-98" id="h4-5-98" class="i">+            });
</a><a href="#h4-5-99" id="h4-5-99" class="i">+        })
</a><a href="#h4-5-100" id="h4-5-100" class="i">+    }
</a><a href="#h4-5-101" id="h4-5-101" class="i">+
</a><a href="#h4-5-102" id="h4-5-102" class="i">+    /// Processes a client SQL session, by executing SQL statements against the
</a><a href="#h4-5-103" id="h4-5-103" class="i">+    /// Raft node.
</a><a href="#h4-5-104" id="h4-5-104" class="i">+    fn sql_session(
</a><a href="#h4-5-105" id="h4-5-105" class="i">+        mut socket: TcpStream,
</a><a href="#h4-5-106" id="h4-5-106" class="i">+        raft_request_tx: Sender&lt;(raft::Request, Sender&lt;Result&lt;raft::Response&gt;&gt;)&gt;,
</a><a href="#h4-5-107" id="h4-5-107" class="i">+    ) -&gt; Result&lt;()&gt; {
</a><a href="#h4-5-108" id="h4-5-108" class="i">+        let mut session = sql::engine::Raft::new(raft_request_tx).session();
</a><a href="#h4-5-109" id="h4-5-109" class="i">+        while let Some(request) = bincode::maybe_deserialize_from(&amp;mut socket)? {
</a><a href="#h4-5-110" id="h4-5-110" class="i">+            // Execute request.
</a><a href="#h4-5-111" id="h4-5-111" class="i">+            debug!(&quot;Received request {request:?}&quot;);
</a><a href="#h4-5-112" id="h4-5-112" class="i">+            let mut response = match request {
</a><a href="#h4-5-113" id="h4-5-113" class="i">+                Request::Execute(query) =&gt; session.execute(&amp;query).map(Response::Execute),
</a><a href="#h4-5-114" id="h4-5-114" class="i">+                Request::Status =&gt; session.status().map(Response::Status),
</a><a href="#h4-5-115" id="h4-5-115" class="i">+                Request::GetTable(table) =&gt; session
</a><a href="#h4-5-116" id="h4-5-116" class="i">+                    .with_txn_read_only(|txn| txn.must_read_table(&amp;table))
</a><a href="#h4-5-117" id="h4-5-117" class="i">+                    .map(Response::GetTable),
</a><a href="#h4-5-118" id="h4-5-118" class="i">+                Request::ListTables =&gt; session
</a><a href="#h4-5-119" id="h4-5-119" class="i">+                    .with_txn_read_only(|txn| Ok(txn.scan_tables()?.map(|t| t.name).collect()))
</a><a href="#h4-5-120" id="h4-5-120" class="i">+                    .map(Response::ListTables),
</a><a href="#h4-5-121" id="h4-5-121" class="i">+            };
</a><a href="#h4-5-122" id="h4-5-122" class="i">+
</a><a href="#h4-5-123" id="h4-5-123" class="i">+            // Process response.
</a><a href="#h4-5-124" id="h4-5-124" class="i">+            debug!(&quot;Returning response {response:?}&quot;);
</a><a href="#h4-5-125" id="h4-5-125" class="i">+            let mut rows: Box&lt;dyn Iterator&lt;Item = Result&lt;Response&gt;&gt; + Send&gt; =
</a><a href="#h4-5-126" id="h4-5-126" class="i">+                Box::new(std::iter::empty());
</a><a href="#h4-5-127" id="h4-5-127" class="i">+            if let Ok(Response::Execute(ResultSet::Query { rows: ref mut resultrows, .. })) =
</a><a href="#h4-5-128" id="h4-5-128" class="i">+                &amp;mut response
</a><a href="#h4-5-129" id="h4-5-129" class="i">+            {
</a><a href="#h4-5-130" id="h4-5-130" class="i">+                // TODO: don&#39;t stream results, for simplicity.
</a><a href="#h4-5-131" id="h4-5-131" class="i">+                rows = Box::new(
</a><a href="#h4-5-132" id="h4-5-132" class="i">+                    std::mem::replace(resultrows, Box::new(std::iter::empty()))
</a><a href="#h4-5-133" id="h4-5-133" class="i">+                        .map(|result| result.map(|row| Response::Row(Some(row))))
</a><a href="#h4-5-134" id="h4-5-134" class="i">+                        .chain(std::iter::once(Ok(Response::Row(None))))
</a><a href="#h4-5-135" id="h4-5-135" class="i">+                        .scan(false, |err_sent, response| match (&amp;err_sent, &amp;response) {
</a><a href="#h4-5-136" id="h4-5-136" class="i">+                            (true, _) =&gt; None,
</a><a href="#h4-5-137" id="h4-5-137" class="i">+                            (_, Err(error)) =&gt; {
</a><a href="#h4-5-138" id="h4-5-138" class="i">+                                *err_sent = true;
</a><a href="#h4-5-139" id="h4-5-139" class="i">+                                Some(Err(error.clone()))
</a><a href="#h4-5-140" id="h4-5-140" class="i">+                            }
</a><a href="#h4-5-141" id="h4-5-141" class="i">+                            _ =&gt; Some(response),
</a><a href="#h4-5-142" id="h4-5-142" class="i">+                        })
</a><a href="#h4-5-143" id="h4-5-143" class="i">+                        .fuse(),
</a><a href="#h4-5-144" id="h4-5-144" class="i">+                );
</a><a href="#h4-5-145" id="h4-5-145" class="i">+            }
</a><a href="#h4-5-146" id="h4-5-146" class="i">+
</a><a href="#h4-5-147" id="h4-5-147" class="i">+            bincode::serialize_into(&amp;mut socket, &amp;response)?;
</a><a href="#h4-5-148" id="h4-5-148" class="i">+            for row in rows {
</a><a href="#h4-5-149" id="h4-5-149" class="i">+                bincode::serialize_into(&amp;mut socket, &amp;row)?;
</a><a href="#h4-5-150" id="h4-5-150" class="i">+            }
</a><a href="#h4-5-151" id="h4-5-151" class="i">+        }
</a><a href="#h4-5-152" id="h4-5-152" class="i">+        Ok(())
</a><a href="#h4-5-153" id="h4-5-153" class="i">+    }
</a> }
 
 /// A SQL client request.
<b>diff --git a/<a id="h5" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -6,6 +6,7 @@ use crate::error::{Error, Result};
</a> use crate::raft::{self, Entry};
 use crate::storage::{self, mvcc::TransactionState};
 
<a href="#h5-0-3" id="h5-0-3" class="i">+use crossbeam::channel::Sender;
</a> use serde::{de::DeserializeOwned, Deserialize, Serialize};
 use std::collections::HashSet;
 
<a href="#h5-1" id="h5-1" class="h">@@ -67,12 +68,12 @@ pub struct Status {
</a> /// A client for the local Raft node.
 #[derive(Clone)]
 struct Client {
<a href="#h5-1-3" id="h5-1-3" class="d">-    tx: raft::ClientSender,
</a><a href="#h5-1-4" id="h5-1-4" class="i">+    tx: Sender&lt;(raft::Request, Sender&lt;Result&lt;raft::Response&gt;&gt;)&gt;,
</a> }
 
 impl Client {
     /// Creates a new Raft client.
<a href="#h5-1-9" id="h5-1-9" class="d">-    fn new(tx: raft::ClientSender) -&gt; Self {
</a><a href="#h5-1-10" id="h5-1-10" class="i">+    fn new(tx: Sender&lt;(raft::Request, Sender&lt;Result&lt;raft::Response&gt;&gt;)&gt;) -&gt; Self {
</a>         Self { tx }
     }
 
<a href="#h5-2" id="h5-2" class="h">@@ -118,7 +119,7 @@ pub struct Raft {
</a> 
 impl Raft {
     /// Creates a new Raft-based SQL engine.
<a href="#h5-2-3" id="h5-2-3" class="d">-    pub fn new(tx: raft::ClientSender) -&gt; Self {
</a><a href="#h5-2-4" id="h5-2-4" class="i">+    pub fn new(tx: Sender&lt;(raft::Request, Sender&lt;Result&lt;raft::Response&gt;&gt;)&gt;) -&gt; Self {
</a>         Self { client: Client::new(tx) }
     }
 
</pre>
</div>
</body>
</html>
