<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Added initial SQL parser and query engine skeleton. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/d49075427bfb85f7c23f82c0e61595a1805ea5ba.html">d49075427bfb85f7c23f82c0e61595a1805ea5ba</a>
<b>parent</b> <a href="../commit/5ed78fca277623753a76a22ed7e600bebb914e22.html">5ed78fca277623753a76a22ed7e600bebb914e22</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 25 Aug 2019 11:03:39 +0200

Added initial SQL parser and query engine skeleton.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">README.md</a></td><td> | </td><td class="num">17</td><td><span class="i">+++++++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/client.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">+++++++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/error.rs</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/server/toydb.rs</a></td><td> | </td><td class="num">19</td><td><span class="i">+++++++++</span><span class="d">----------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/sql/mod.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h5">src/sql/parser/ast.rs</a></td><td> | </td><td class="num">60</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/parser/lexer.rs</a></td><td> | </td><td class="num">18</td><td><span class="i"></span><span class="d">------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/parser/mod.rs</a></td><td> | </td><td class="num">291</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h8">src/sql/plan/expression.rs</a></td><td> | </td><td class="num">90</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h9">src/sql/plan/mod.rs</a></td><td> | </td><td class="num">34</td><td><span class="i">++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h10">src/sql/plan/node.rs</a></td><td> | </td><td class="num">33</td><td><span class="i">+++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h11">src/sql/plan/planner.rs</a></td><td> | </td><td class="num">89</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">src/sql/types.rs</a></td><td> | </td><td class="num">40</td><td><span class="i">+++++++++++++++++++++++++++++++++</span><span class="d">-------</span></td></tr>
</table></pre><pre>13 files changed, 673 insertions(+), 42 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/README.md.html">README.md</a> b/<a href="../file/README.md.html">README.md</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -30,15 +30,16 @@ $ grpcurl -plaintext -proto protobuf/toydb.proto localhost:9605 ToyDB/Status
</a> 
 - [x] **Data Types:** Support for nulls, booleans, 64-bit integers, 64-bit floats, and UTF-8 strings up to 1 KB.
 
<a href="#h0-0-3" id="h0-0-3" class="d">-- [ ] **Constraints:** Compulsory singluar primary keys, unique indexes, and foreign keys.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+- [ ] **Schemas:** Compulsory singluar primary keys, unique indexes, and foreign keys.
</a> 
 - [ ] **Transactions:** MVCC-based serializable snapshot isolation.
 
<a href="#h0-0-8" id="h0-0-8" class="d">-- [ ] **Query Engine:** Simple heuristic-based planner and optimizer supporting expressions, functions, and inner joins.
</a><a href="#h0-0-9" id="h0-0-9" class="i">+- [ ] **Query Engine:** Self-written iterator-based engine with simple heuristic optimizer.
</a> 
<a href="#h0-0-11" id="h0-0-11" class="d">-- [ ] **Language:** Basic SQL support:
</a><a href="#h0-0-12" id="h0-0-12" class="i">+- [ ] **Language:** Self-written SQL parser with support for:
</a> 
<a href="#h0-0-14" id="h0-0-14" class="d">-  * `[CREATE|DROP] TABLE ...` and `[CREATE|DROP] INDEX ...`
</a><a href="#h0-0-15" id="h0-0-15" class="i">+  * `[CREATE|DROP] TABLE ...`
</a><a href="#h0-0-16" id="h0-0-16" class="i">+  * `[CREATE|DROP] INDEX ...`
</a>   * `BEGIN`, `COMMIT`, and `ROLLBACK`
   * `INSERT INTO ... (...) VALUES (...)`
   * `UPDATE ... SET ... WHERE ...`
<a href="#h0-1" id="h0-1" class="h">@@ -68,4 +69,8 @@ Below is an incomplete list of known issues preventing this from being a &quot;real&quot; 
</a> 
 * **State machine errors:** errors during state machine mutations currently crash the node - it may be beneficial to support user errors which simply skip the erroring log entry.
 
<a href="#h0-1-3" id="h0-1-3" class="d">-* **Log replication optimization:** currently only the simplest version of the Raft log replication protocol is implemented, without snapshots or rapid log replay (i.e. replication of old log entries is retried one by one until a common base entry is found).
</a><a href="#h0-1-4" id="h0-1-4" class="d">-\ No newline at end of file
</a><a href="#h0-1-5" id="h0-1-5" class="i">+* **Log replication optimization:** currently only the simplest version of the Raft log replication protocol is implemented, without snapshots or rapid log replay (i.e. replication of old log entries is retried one by one until a common base entry is found).
</a><a href="#h0-1-6" id="h0-1-6" class="i">+
</a><a href="#h0-1-7" id="h0-1-7" class="i">+### Query Engine
</a><a href="#h0-1-8" id="h0-1-8" class="i">+
</a><a href="#h0-1-9" id="h0-1-9" class="i">+* **Type checking:** query type checking (e.g. `SELECT a + b` must receive two numbers) is done at query evaluation time, not at query compile time.
</a><a href="#h0-1-10" id="h0-1-10" class="i">+\ No newline at end of file
</a><b>diff --git a/<a id="h1" href="../file/src/client.rs.html">src/client.rs</a> b/<a href="../file/src/client.rs.html">src/client.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -53,7 +53,13 @@ impl ResultSet {
</a>         metadata: grpc::Metadata,
         rows: Box&lt;dyn std::iter::Iterator&lt;Item = Result&lt;service::Row, grpc::Error&gt;&gt;&gt;,
     ) -&gt; Result&lt;Self, Error&gt; {
<a href="#h1-0-3" id="h1-0-3" class="d">-        Ok(Self { columns: Self::deserialize(metadata.get(&quot;columns&quot;).unwrap().to_vec())?, rows })
</a><a href="#h1-0-4" id="h1-0-4" class="i">+        let columns = Self::deserialize(
</a><a href="#h1-0-5" id="h1-0-5" class="i">+            metadata
</a><a href="#h1-0-6" id="h1-0-6" class="i">+                .get(&quot;columns&quot;)
</a><a href="#h1-0-7" id="h1-0-7" class="i">+                .map(|c| c.to_vec())
</a><a href="#h1-0-8" id="h1-0-8" class="i">+                .ok_or_else(|| Error::Network(&quot;Columns not found in gRPC result&quot;.into()))?,
</a><a href="#h1-0-9" id="h1-0-9" class="i">+        )?;
</a><a href="#h1-0-10" id="h1-0-10" class="i">+        Ok(Self { columns, rows })
</a>     }
 
     pub fn columns(&amp;self) -&gt; Vec&lt;String&gt; {
<b>diff --git a/<a id="h2" href="../file/src/error.rs.html">src/error.rs</a> b/<a href="../file/src/error.rs.html">src/error.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -103,6 +103,18 @@ impl From&lt;std::net::AddrParseError&gt; for Error {
</a>     }
 }
 
<a href="#h2-0-3" id="h2-0-3" class="i">+impl From&lt;std::num::ParseFloatError&gt; for Error {
</a><a href="#h2-0-4" id="h2-0-4" class="i">+    fn from(err: std::num::ParseFloatError) -&gt; Self {
</a><a href="#h2-0-5" id="h2-0-5" class="i">+        Error::Parse(err.to_string())
</a><a href="#h2-0-6" id="h2-0-6" class="i">+    }
</a><a href="#h2-0-7" id="h2-0-7" class="i">+}
</a><a href="#h2-0-8" id="h2-0-8" class="i">+
</a><a href="#h2-0-9" id="h2-0-9" class="i">+impl From&lt;std::num::ParseIntError&gt; for Error {
</a><a href="#h2-0-10" id="h2-0-10" class="i">+    fn from(err: std::num::ParseIntError) -&gt; Self {
</a><a href="#h2-0-11" id="h2-0-11" class="i">+        Error::Parse(err.to_string())
</a><a href="#h2-0-12" id="h2-0-12" class="i">+    }
</a><a href="#h2-0-13" id="h2-0-13" class="i">+}
</a><a href="#h2-0-14" id="h2-0-14" class="i">+
</a> impl&lt;T&gt; From&lt;std::sync::PoisonError&lt;T&gt;&gt; for Error {
     fn from(err: std::sync::PoisonError&lt;T&gt;) -&gt; Self {
         Error::Internal(err.to_string())
<b>diff --git a/<a id="h3" href="../file/src/server/toydb.rs.html">src/server/toydb.rs</a> b/<a href="../file/src/server/toydb.rs.html">src/server/toydb.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,6 +1,7 @@
</a> use crate::raft::Raft;
 use crate::service;
 use crate::sql::types::{Row, Value};
<a href="#h3-0-3" id="h3-0-3" class="i">+use crate::sql::{Parser, Plan};
</a> use crate::state;
 use crate::Error;
 
<a href="#h3-1" id="h3-1" class="h">@@ -13,21 +14,19 @@ impl service::ToyDB for ToyDB {
</a>     fn query(
         &amp;self,
         _: grpc::RequestOptions,
<a href="#h3-1-3" id="h3-1-3" class="d">-        _req: service::QueryRequest,
</a><a href="#h3-1-4" id="h3-1-4" class="i">+        req: service::QueryRequest,
</a>     ) -&gt; grpc::StreamingResponse&lt;service::Row&gt; {
<a href="#h3-1-6" id="h3-1-6" class="i">+        let plan = Plan::build(Parser::new(&amp;req.query).parse().unwrap()).unwrap();
</a>         let mut metadata = grpc::Metadata::new();
         metadata.add(
             grpc::MetadataKey::from(&quot;columns&quot;),
<a href="#h3-1-10" id="h3-1-10" class="d">-            Self::serialize(vec![&quot;null&quot;, &quot;boolean&quot;, &quot;integer&quot;, &quot;float&quot;, &quot;string&quot;]).unwrap().into(),
</a><a href="#h3-1-11" id="h3-1-11" class="i">+            Self::serialize(&amp;plan.columns).unwrap().into(),
</a>         );
<a href="#h3-1-13" id="h3-1-13" class="d">-        let rows = vec![Self::row_to_protobuf(vec![
</a><a href="#h3-1-14" id="h3-1-14" class="d">-            Value::Null,
</a><a href="#h3-1-15" id="h3-1-15" class="d">-            Value::Boolean(true),
</a><a href="#h3-1-16" id="h3-1-16" class="d">-            Value::Integer(7),
</a><a href="#h3-1-17" id="h3-1-17" class="d">-            Value::Float(1.23),
</a><a href="#h3-1-18" id="h3-1-18" class="d">-            Value::String(&quot;Hi! ðŸ‘‹&quot;.into()),
</a><a href="#h3-1-19" id="h3-1-19" class="d">-        ])];
</a><a href="#h3-1-20" id="h3-1-20" class="d">-        grpc::StreamingResponse::iter_with_metadata(metadata, rows.into_iter())
</a><a href="#h3-1-21" id="h3-1-21" class="i">+        // FIXME This needs to handle errors
</a><a href="#h3-1-22" id="h3-1-22" class="i">+        grpc::StreamingResponse::iter_with_metadata(
</a><a href="#h3-1-23" id="h3-1-23" class="i">+            metadata,
</a><a href="#h3-1-24" id="h3-1-24" class="i">+            plan.map(|row| Self::row_to_protobuf(row.unwrap())),
</a><a href="#h3-1-25" id="h3-1-25" class="i">+        )
</a>     }
 
     fn get(
<b>diff --git a/<a id="h4" href="../file/src/sql/mod.rs.html">src/sql/mod.rs</a> b/<a href="../file/src/sql/mod.rs.html">src/sql/mod.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -1,2 +1,6 @@
</a> mod parser;
<a href="#h4-0-1" id="h4-0-1" class="i">+mod plan;
</a> pub mod types;
<a href="#h4-0-3" id="h4-0-3" class="i">+
</a><a href="#h4-0-4" id="h4-0-4" class="i">+pub use parser::{ast, Parser};
</a><a href="#h4-0-5" id="h4-0-5" class="i">+pub use plan::Plan;
</a><b>diff --git a/<a id="h5" href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a> b/<a href="../file/src/sql/parser/ast.rs.html">src/sql/parser/ast.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -0,0 +1,60 @@
</a><a href="#h5-0-0" id="h5-0-0" class="i">+/// Statements
</a><a href="#h5-0-1" id="h5-0-1" class="i">+#[derive(Debug, PartialEq)]
</a><a href="#h5-0-2" id="h5-0-2" class="i">+pub enum Statement {
</a><a href="#h5-0-3" id="h5-0-3" class="i">+    /// A SELECT statement
</a><a href="#h5-0-4" id="h5-0-4" class="i">+    Select {
</a><a href="#h5-0-5" id="h5-0-5" class="i">+        /// The select clause
</a><a href="#h5-0-6" id="h5-0-6" class="i">+        select: SelectClause,
</a><a href="#h5-0-7" id="h5-0-7" class="i">+    },
</a><a href="#h5-0-8" id="h5-0-8" class="i">+}
</a><a href="#h5-0-9" id="h5-0-9" class="i">+
</a><a href="#h5-0-10" id="h5-0-10" class="i">+/// A SELECT clause
</a><a href="#h5-0-11" id="h5-0-11" class="i">+#[derive(Debug, PartialEq)]
</a><a href="#h5-0-12" id="h5-0-12" class="i">+pub struct SelectClause {
</a><a href="#h5-0-13" id="h5-0-13" class="i">+    /// The expressions to select
</a><a href="#h5-0-14" id="h5-0-14" class="i">+    pub expressions: Vec&lt;Expression&gt;,
</a><a href="#h5-0-15" id="h5-0-15" class="i">+    /// The expression labels, if any
</a><a href="#h5-0-16" id="h5-0-16" class="i">+    pub labels: Vec&lt;Option&lt;String&gt;&gt;,
</a><a href="#h5-0-17" id="h5-0-17" class="i">+}
</a><a href="#h5-0-18" id="h5-0-18" class="i">+
</a><a href="#h5-0-19" id="h5-0-19" class="i">+/// Expressions
</a><a href="#h5-0-20" id="h5-0-20" class="i">+#[derive(Debug, PartialEq)]
</a><a href="#h5-0-21" id="h5-0-21" class="i">+pub enum Expression {
</a><a href="#h5-0-22" id="h5-0-22" class="i">+    Literal(Literal),
</a><a href="#h5-0-23" id="h5-0-23" class="i">+    Operation(Operation),
</a><a href="#h5-0-24" id="h5-0-24" class="i">+}
</a><a href="#h5-0-25" id="h5-0-25" class="i">+
</a><a href="#h5-0-26" id="h5-0-26" class="i">+impl From&lt;Literal&gt; for Expression {
</a><a href="#h5-0-27" id="h5-0-27" class="i">+    fn from(literal: Literal) -&gt; Self {
</a><a href="#h5-0-28" id="h5-0-28" class="i">+        Self::Literal(literal)
</a><a href="#h5-0-29" id="h5-0-29" class="i">+    }
</a><a href="#h5-0-30" id="h5-0-30" class="i">+}
</a><a href="#h5-0-31" id="h5-0-31" class="i">+
</a><a href="#h5-0-32" id="h5-0-32" class="i">+impl From&lt;Operation&gt; for Expression {
</a><a href="#h5-0-33" id="h5-0-33" class="i">+    fn from(op: Operation) -&gt; Self {
</a><a href="#h5-0-34" id="h5-0-34" class="i">+        Self::Operation(op)
</a><a href="#h5-0-35" id="h5-0-35" class="i">+    }
</a><a href="#h5-0-36" id="h5-0-36" class="i">+}
</a><a href="#h5-0-37" id="h5-0-37" class="i">+
</a><a href="#h5-0-38" id="h5-0-38" class="i">+/// Literals
</a><a href="#h5-0-39" id="h5-0-39" class="i">+#[derive(Debug, PartialEq)]
</a><a href="#h5-0-40" id="h5-0-40" class="i">+pub enum Literal {
</a><a href="#h5-0-41" id="h5-0-41" class="i">+    Null,
</a><a href="#h5-0-42" id="h5-0-42" class="i">+    Boolean(bool),
</a><a href="#h5-0-43" id="h5-0-43" class="i">+    Integer(i64),
</a><a href="#h5-0-44" id="h5-0-44" class="i">+    Float(f64),
</a><a href="#h5-0-45" id="h5-0-45" class="i">+    String(String),
</a><a href="#h5-0-46" id="h5-0-46" class="i">+}
</a><a href="#h5-0-47" id="h5-0-47" class="i">+
</a><a href="#h5-0-48" id="h5-0-48" class="i">+/// Operations (done by operators)
</a><a href="#h5-0-49" id="h5-0-49" class="i">+#[derive(Debug, PartialEq)]
</a><a href="#h5-0-50" id="h5-0-50" class="i">+pub enum Operation {
</a><a href="#h5-0-51" id="h5-0-51" class="i">+    Add(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h5-0-52" id="h5-0-52" class="i">+    Divide(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h5-0-53" id="h5-0-53" class="i">+    Exponentiate(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h5-0-54" id="h5-0-54" class="i">+    Factorial(Box&lt;Expression&gt;),
</a><a href="#h5-0-55" id="h5-0-55" class="i">+    Modulo(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h5-0-56" id="h5-0-56" class="i">+    Multiply(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h5-0-57" id="h5-0-57" class="i">+    Negate(Box&lt;Expression&gt;),
</a><a href="#h5-0-58" id="h5-0-58" class="i">+    Subtract(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h5-0-59" id="h5-0-59" class="i">+}
</a><b>diff --git a/<a id="h6" href="../file/src/sql/parser/lexer.rs.html">src/sql/parser/lexer.rs</a> b/<a href="../file/src/sql/parser/lexer.rs.html">src/sql/parser/lexer.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -5,41 +5,23 @@ use std::str::Chars;
</a> // A lexer token
 #[derive(Clone, Debug, PartialEq)]
 pub enum Token {
<a href="#h6-0-3" id="h6-0-3" class="d">-    /// A number literal
</a>     Number(String),
<a href="#h6-0-5" id="h6-0-5" class="d">-    /// A string literal
</a>     String(String),
<a href="#h6-0-7" id="h6-0-7" class="d">-    /// A textual identifier
</a>     Ident(String),
<a href="#h6-0-9" id="h6-0-9" class="d">-    /// The period symbol .
</a>     Period,
<a href="#h6-0-11" id="h6-0-11" class="d">-    /// The equals symbol =
</a>     Equals,
<a href="#h6-0-13" id="h6-0-13" class="d">-    /// The greater-than symbol &gt;
</a>     GreaterThan,
<a href="#h6-0-15" id="h6-0-15" class="d">-    /// The less-than symbol &lt;
</a>     LessThan,
<a href="#h6-0-17" id="h6-0-17" class="d">-    /// The addition symbol +
</a>     Plus,
<a href="#h6-0-19" id="h6-0-19" class="d">-    /// The subtraction symbol -
</a>     Minus,
<a href="#h6-0-21" id="h6-0-21" class="d">-    /// The multiplication symbol *
</a>     Asterisk,
<a href="#h6-0-23" id="h6-0-23" class="d">-    /// The division symbol /
</a>     Slash,
<a href="#h6-0-25" id="h6-0-25" class="d">-    /// The exponentiation symbol ^
</a>     Caret,
<a href="#h6-0-27" id="h6-0-27" class="d">-    /// The modulo symbol %
</a>     Percent,
<a href="#h6-0-29" id="h6-0-29" class="d">-    /// The factorial or not symbol !
</a>     Exclamation,
<a href="#h6-0-31" id="h6-0-31" class="d">-    /// The query parameter marker ?
</a>     Question,
<a href="#h6-0-33" id="h6-0-33" class="d">-    /// An opening parenthesis
</a>     OpenParen,
<a href="#h6-0-35" id="h6-0-35" class="d">-    /// A closing parenthesis
</a>     CloseParen,
<a href="#h6-0-37" id="h6-0-37" class="d">-    /// An expression separator ,
</a>     Comma,
 }
 
<b>diff --git a/<a id="h7" href="../file/src/sql/parser/mod.rs.html">src/sql/parser/mod.rs</a> b/<a href="../file/src/sql/parser/mod.rs.html">src/sql/parser/mod.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -1 +1,292 @@
</a><a href="#h7-0-0" id="h7-0-0" class="i">+pub mod ast;
</a> mod lexer;
<a href="#h7-0-2" id="h7-0-2" class="i">+
</a><a href="#h7-0-3" id="h7-0-3" class="i">+use crate::Error;
</a><a href="#h7-0-4" id="h7-0-4" class="i">+use lexer::{Lexer, Token};
</a><a href="#h7-0-5" id="h7-0-5" class="i">+
</a><a href="#h7-0-6" id="h7-0-6" class="i">+/// An SQL parser
</a><a href="#h7-0-7" id="h7-0-7" class="i">+pub struct Parser&lt;&#39;a&gt; {
</a><a href="#h7-0-8" id="h7-0-8" class="i">+    lexer: std::iter::Peekable&lt;Lexer&lt;&#39;a&gt;&gt;,
</a><a href="#h7-0-9" id="h7-0-9" class="i">+}
</a><a href="#h7-0-10" id="h7-0-10" class="i">+
</a><a href="#h7-0-11" id="h7-0-11" class="i">+impl&lt;&#39;a&gt; Parser&lt;&#39;a&gt; {
</a><a href="#h7-0-12" id="h7-0-12" class="i">+    /// Creates a new parser for the given string input
</a><a href="#h7-0-13" id="h7-0-13" class="i">+    pub fn new(query: &amp;str) -&gt; Parser {
</a><a href="#h7-0-14" id="h7-0-14" class="i">+        Parser { lexer: Lexer::new(query).peekable() }
</a><a href="#h7-0-15" id="h7-0-15" class="i">+    }
</a><a href="#h7-0-16" id="h7-0-16" class="i">+
</a><a href="#h7-0-17" id="h7-0-17" class="i">+    /// Parses the input string into an AST statement
</a><a href="#h7-0-18" id="h7-0-18" class="i">+    pub fn parse(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h7-0-19" id="h7-0-19" class="i">+        let statement = self.parse_statement()?;
</a><a href="#h7-0-20" id="h7-0-20" class="i">+        self.next_expect(None)?;
</a><a href="#h7-0-21" id="h7-0-21" class="i">+        Ok(statement)
</a><a href="#h7-0-22" id="h7-0-22" class="i">+    }
</a><a href="#h7-0-23" id="h7-0-23" class="i">+
</a><a href="#h7-0-24" id="h7-0-24" class="i">+    /// Grabs the next lexer token, or throws an error if none is found.
</a><a href="#h7-0-25" id="h7-0-25" class="i">+    fn next(&amp;mut self) -&gt; Result&lt;Token, Error&gt; {
</a><a href="#h7-0-26" id="h7-0-26" class="i">+        self.lexer.next().unwrap_or_else(|| Err(Error::Parse(&quot;Unexpected end of input&quot;.into())))
</a><a href="#h7-0-27" id="h7-0-27" class="i">+    }
</a><a href="#h7-0-28" id="h7-0-28" class="i">+
</a><a href="#h7-0-29" id="h7-0-29" class="i">+    /// Grabs the next lexer token, and returns it if it was expected or
</a><a href="#h7-0-30" id="h7-0-30" class="i">+    /// otherwise throws an error.
</a><a href="#h7-0-31" id="h7-0-31" class="i">+    fn next_expect(&amp;mut self, expect: Option&lt;Token&gt;) -&gt; Result&lt;Option&lt;Token&gt;, Error&gt; {
</a><a href="#h7-0-32" id="h7-0-32" class="i">+        if let Some(t) = expect {
</a><a href="#h7-0-33" id="h7-0-33" class="i">+            let token = self.next()?;
</a><a href="#h7-0-34" id="h7-0-34" class="i">+            if token == t {
</a><a href="#h7-0-35" id="h7-0-35" class="i">+                Ok(Some(token))
</a><a href="#h7-0-36" id="h7-0-36" class="i">+            } else {
</a><a href="#h7-0-37" id="h7-0-37" class="i">+                Err(Error::Parse(format!(&quot;Expected token {}, found {}&quot;, t, token)))
</a><a href="#h7-0-38" id="h7-0-38" class="i">+            }
</a><a href="#h7-0-39" id="h7-0-39" class="i">+        } else if let Some(token) = self.peek()? {
</a><a href="#h7-0-40" id="h7-0-40" class="i">+            Err(Error::Parse(format!(&quot;Unexpected token {}&quot;, token)))
</a><a href="#h7-0-41" id="h7-0-41" class="i">+        } else {
</a><a href="#h7-0-42" id="h7-0-42" class="i">+            Ok(None)
</a><a href="#h7-0-43" id="h7-0-43" class="i">+        }
</a><a href="#h7-0-44" id="h7-0-44" class="i">+    }
</a><a href="#h7-0-45" id="h7-0-45" class="i">+
</a><a href="#h7-0-46" id="h7-0-46" class="i">+    /// Grabs the next lexer token if it satisfies the predicate function
</a><a href="#h7-0-47" id="h7-0-47" class="i">+    fn next_if&lt;F: Fn(&amp;Token) -&gt; bool&gt;(&amp;mut self, predicate: F) -&gt; Option&lt;Token&gt; {
</a><a href="#h7-0-48" id="h7-0-48" class="i">+        self.peek().unwrap_or(None).filter(|t| predicate(&amp;t))?;
</a><a href="#h7-0-49" id="h7-0-49" class="i">+        self.next().ok()
</a><a href="#h7-0-50" id="h7-0-50" class="i">+    }
</a><a href="#h7-0-51" id="h7-0-51" class="i">+
</a><a href="#h7-0-52" id="h7-0-52" class="i">+    /// Grabs the next lexer token if it is a given keyword
</a><a href="#h7-0-53" id="h7-0-53" class="i">+    fn next_if_keyword(&amp;mut self, keyword: &amp;str) -&gt; Option&lt;Token&gt; {
</a><a href="#h7-0-54" id="h7-0-54" class="i">+        self.next_if(|t| match t {
</a><a href="#h7-0-55" id="h7-0-55" class="i">+            Token::Ident(ref ident) if ident.to_lowercase() == keyword.to_lowercase() =&gt; true,
</a><a href="#h7-0-56" id="h7-0-56" class="i">+            _ =&gt; false,
</a><a href="#h7-0-57" id="h7-0-57" class="i">+        })
</a><a href="#h7-0-58" id="h7-0-58" class="i">+    }
</a><a href="#h7-0-59" id="h7-0-59" class="i">+
</a><a href="#h7-0-60" id="h7-0-60" class="i">+    /// Grabs the next operator if it satisfies the type and precedence
</a><a href="#h7-0-61" id="h7-0-61" class="i">+    fn next_if_operator&lt;O: Operator&gt;(&amp;mut self, min_prec: u8) -&gt; Option&lt;O&gt; {
</a><a href="#h7-0-62" id="h7-0-62" class="i">+        let operator = self
</a><a href="#h7-0-63" id="h7-0-63" class="i">+            .peek()
</a><a href="#h7-0-64" id="h7-0-64" class="i">+            .unwrap_or(None)
</a><a href="#h7-0-65" id="h7-0-65" class="i">+            .and_then(|token| O::from(&amp;token))
</a><a href="#h7-0-66" id="h7-0-66" class="i">+            .filter(|op| op.prec() &gt;= min_prec)?;
</a><a href="#h7-0-67" id="h7-0-67" class="i">+        self.next().ok();
</a><a href="#h7-0-68" id="h7-0-68" class="i">+        Some(operator)
</a><a href="#h7-0-69" id="h7-0-69" class="i">+    }
</a><a href="#h7-0-70" id="h7-0-70" class="i">+
</a><a href="#h7-0-71" id="h7-0-71" class="i">+    /// Grabs the next lexer token if it is a given token
</a><a href="#h7-0-72" id="h7-0-72" class="i">+    fn next_if_token(&amp;mut self, token: Token) -&gt; Option&lt;Token&gt; {
</a><a href="#h7-0-73" id="h7-0-73" class="i">+        self.next_if(|t| t == &amp;token)
</a><a href="#h7-0-74" id="h7-0-74" class="i">+    }
</a><a href="#h7-0-75" id="h7-0-75" class="i">+
</a><a href="#h7-0-76" id="h7-0-76" class="i">+    /// Peeks the next lexer token if any, but converts it from
</a><a href="#h7-0-77" id="h7-0-77" class="i">+    /// Option&lt;Result&lt;Token, Error&gt;&gt; to Result&lt;Option&lt;Token&gt;, Error&gt; which is
</a><a href="#h7-0-78" id="h7-0-78" class="i">+    /// more convenient to work with (the Iterator trait requires Option&lt;T&gt;).
</a><a href="#h7-0-79" id="h7-0-79" class="i">+    fn peek(&amp;mut self) -&gt; Result&lt;Option&lt;Token&gt;, Error&gt; {
</a><a href="#h7-0-80" id="h7-0-80" class="i">+        self.lexer.peek().cloned().transpose()
</a><a href="#h7-0-81" id="h7-0-81" class="i">+    }
</a><a href="#h7-0-82" id="h7-0-82" class="i">+
</a><a href="#h7-0-83" id="h7-0-83" class="i">+    /// Parses an SQL statement
</a><a href="#h7-0-84" id="h7-0-84" class="i">+    fn parse_statement(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h7-0-85" id="h7-0-85" class="i">+        match self.peek()? {
</a><a href="#h7-0-86" id="h7-0-86" class="i">+            Some(Token::Ident(ref ident)) =&gt; match ident.to_lowercase().as_ref() {
</a><a href="#h7-0-87" id="h7-0-87" class="i">+                &quot;select&quot; =&gt; self.parse_statement_select(),
</a><a href="#h7-0-88" id="h7-0-88" class="i">+                ident =&gt; Err(Error::Parse(format!(&quot;Unexpected statement start {}&quot;, ident))),
</a><a href="#h7-0-89" id="h7-0-89" class="i">+            },
</a><a href="#h7-0-90" id="h7-0-90" class="i">+            Some(token) =&gt; Err(Error::Parse(format!(&quot;Unexpected token {}&quot;, token))),
</a><a href="#h7-0-91" id="h7-0-91" class="i">+            None =&gt; Err(Error::Parse(&quot;Unexpected end of input&quot;.into())),
</a><a href="#h7-0-92" id="h7-0-92" class="i">+        }
</a><a href="#h7-0-93" id="h7-0-93" class="i">+    }
</a><a href="#h7-0-94" id="h7-0-94" class="i">+
</a><a href="#h7-0-95" id="h7-0-95" class="i">+    /// Parses a select statement
</a><a href="#h7-0-96" id="h7-0-96" class="i">+    fn parse_statement_select(&amp;mut self) -&gt; Result&lt;ast::Statement, Error&gt; {
</a><a href="#h7-0-97" id="h7-0-97" class="i">+        Ok(ast::Statement::Select { select: self.parse_clause_select()?.unwrap() })
</a><a href="#h7-0-98" id="h7-0-98" class="i">+    }
</a><a href="#h7-0-99" id="h7-0-99" class="i">+
</a><a href="#h7-0-100" id="h7-0-100" class="i">+    /// Parses a select clause
</a><a href="#h7-0-101" id="h7-0-101" class="i">+    fn parse_clause_select(&amp;mut self) -&gt; Result&lt;Option&lt;ast::SelectClause&gt;, Error&gt; {
</a><a href="#h7-0-102" id="h7-0-102" class="i">+        if self.next_if_keyword(&quot;select&quot;).is_none() {
</a><a href="#h7-0-103" id="h7-0-103" class="i">+            return Ok(None);
</a><a href="#h7-0-104" id="h7-0-104" class="i">+        }
</a><a href="#h7-0-105" id="h7-0-105" class="i">+        let mut clause = ast::SelectClause { expressions: Vec::new(), labels: Vec::new() };
</a><a href="#h7-0-106" id="h7-0-106" class="i">+        loop {
</a><a href="#h7-0-107" id="h7-0-107" class="i">+            clause.expressions.push(self.parse_expression(0)?);
</a><a href="#h7-0-108" id="h7-0-108" class="i">+            clause.labels.push(if self.next_if_keyword(&quot;as&quot;).is_some() {
</a><a href="#h7-0-109" id="h7-0-109" class="i">+                match self.next()? {
</a><a href="#h7-0-110" id="h7-0-110" class="i">+                    Token::Ident(label) =&gt; Some(label),
</a><a href="#h7-0-111" id="h7-0-111" class="i">+                    token =&gt; {
</a><a href="#h7-0-112" id="h7-0-112" class="i">+                        return Err(Error::Parse(format!(&quot;Expected label, found token {}&quot;, token)))
</a><a href="#h7-0-113" id="h7-0-113" class="i">+                    }
</a><a href="#h7-0-114" id="h7-0-114" class="i">+                }
</a><a href="#h7-0-115" id="h7-0-115" class="i">+            } else {
</a><a href="#h7-0-116" id="h7-0-116" class="i">+                None
</a><a href="#h7-0-117" id="h7-0-117" class="i">+            });
</a><a href="#h7-0-118" id="h7-0-118" class="i">+            if self.next_if_token(Token::Comma).is_none() {
</a><a href="#h7-0-119" id="h7-0-119" class="i">+                break;
</a><a href="#h7-0-120" id="h7-0-120" class="i">+            }
</a><a href="#h7-0-121" id="h7-0-121" class="i">+        }
</a><a href="#h7-0-122" id="h7-0-122" class="i">+        Ok(Some(clause))
</a><a href="#h7-0-123" id="h7-0-123" class="i">+    }
</a><a href="#h7-0-124" id="h7-0-124" class="i">+
</a><a href="#h7-0-125" id="h7-0-125" class="i">+    /// Parses an expression consisting of at least one atom operated on by any
</a><a href="#h7-0-126" id="h7-0-126" class="i">+    /// number of operators, using the precedence climbing algorithm.
</a><a href="#h7-0-127" id="h7-0-127" class="i">+    fn parse_expression(&amp;mut self, min_prec: u8) -&gt; Result&lt;ast::Expression, Error&gt; {
</a><a href="#h7-0-128" id="h7-0-128" class="i">+        let mut lhs = if let Some(prefix) = self.next_if_operator::&lt;PrefixOperator&gt;(min_prec) {
</a><a href="#h7-0-129" id="h7-0-129" class="i">+            prefix.build(self.parse_expression(prefix.prec() + prefix.assoc())?)
</a><a href="#h7-0-130" id="h7-0-130" class="i">+        } else {
</a><a href="#h7-0-131" id="h7-0-131" class="i">+            self.parse_expression_atom()?
</a><a href="#h7-0-132" id="h7-0-132" class="i">+        };
</a><a href="#h7-0-133" id="h7-0-133" class="i">+        while let Some(postfix) = self.next_if_operator::&lt;PostfixOperator&gt;(min_prec) {
</a><a href="#h7-0-134" id="h7-0-134" class="i">+            lhs = postfix.build(lhs)
</a><a href="#h7-0-135" id="h7-0-135" class="i">+        }
</a><a href="#h7-0-136" id="h7-0-136" class="i">+        while let Some(infix) = self.next_if_operator::&lt;InfixOperator&gt;(min_prec) {
</a><a href="#h7-0-137" id="h7-0-137" class="i">+            lhs = infix.build(lhs, self.parse_expression(infix.prec() + infix.assoc())?)
</a><a href="#h7-0-138" id="h7-0-138" class="i">+        }
</a><a href="#h7-0-139" id="h7-0-139" class="i">+        Ok(lhs)
</a><a href="#h7-0-140" id="h7-0-140" class="i">+    }
</a><a href="#h7-0-141" id="h7-0-141" class="i">+
</a><a href="#h7-0-142" id="h7-0-142" class="i">+    /// Parses an expression atom
</a><a href="#h7-0-143" id="h7-0-143" class="i">+    fn parse_expression_atom(&amp;mut self) -&gt; Result&lt;ast::Expression, Error&gt; {
</a><a href="#h7-0-144" id="h7-0-144" class="i">+        match self.next()? {
</a><a href="#h7-0-145" id="h7-0-145" class="i">+            Token::Number(n) =&gt; {
</a><a href="#h7-0-146" id="h7-0-146" class="i">+                if n.chars().all(|c| c.is_digit(10)) {
</a><a href="#h7-0-147" id="h7-0-147" class="i">+                    Ok(ast::Literal::Integer(n.parse()?).into())
</a><a href="#h7-0-148" id="h7-0-148" class="i">+                } else {
</a><a href="#h7-0-149" id="h7-0-149" class="i">+                    Ok(ast::Literal::Float(n.parse()?).into())
</a><a href="#h7-0-150" id="h7-0-150" class="i">+                }
</a><a href="#h7-0-151" id="h7-0-151" class="i">+            }
</a><a href="#h7-0-152" id="h7-0-152" class="i">+            Token::String(s) =&gt; Ok(ast::Literal::String(s).into()),
</a><a href="#h7-0-153" id="h7-0-153" class="i">+            Token::Ident(i) =&gt; match i.to_lowercase().as_ref() {
</a><a href="#h7-0-154" id="h7-0-154" class="i">+                &quot;true&quot; =&gt; Ok(ast::Literal::Boolean(true).into()),
</a><a href="#h7-0-155" id="h7-0-155" class="i">+                &quot;false&quot; =&gt; Ok(ast::Literal::Boolean(false).into()),
</a><a href="#h7-0-156" id="h7-0-156" class="i">+                &quot;null&quot; =&gt; Ok(ast::Literal::Null.into()),
</a><a href="#h7-0-157" id="h7-0-157" class="i">+                _ =&gt; panic!(&quot;Not implemented&quot;),
</a><a href="#h7-0-158" id="h7-0-158" class="i">+            },
</a><a href="#h7-0-159" id="h7-0-159" class="i">+            t =&gt; Err(Error::Parse(format!(&quot;Expected expression atom, found {}&quot;, t))),
</a><a href="#h7-0-160" id="h7-0-160" class="i">+        }
</a><a href="#h7-0-161" id="h7-0-161" class="i">+    }
</a><a href="#h7-0-162" id="h7-0-162" class="i">+}
</a><a href="#h7-0-163" id="h7-0-163" class="i">+
</a><a href="#h7-0-164" id="h7-0-164" class="i">+/// An operator trait, to help with parsing of operators
</a><a href="#h7-0-165" id="h7-0-165" class="i">+trait Operator: Sized {
</a><a href="#h7-0-166" id="h7-0-166" class="i">+    /// Looks up the corresponding operator for a token, if one exists
</a><a href="#h7-0-167" id="h7-0-167" class="i">+    fn from(token: &amp;Token) -&gt; Option&lt;Self&gt;;
</a><a href="#h7-0-168" id="h7-0-168" class="i">+    /// Returns the operator&#39;s associativity
</a><a href="#h7-0-169" id="h7-0-169" class="i">+    fn assoc(&amp;self) -&gt; u8;
</a><a href="#h7-0-170" id="h7-0-170" class="i">+    /// Returns the operator&#39;s precedence
</a><a href="#h7-0-171" id="h7-0-171" class="i">+    fn prec(&amp;self) -&gt; u8;
</a><a href="#h7-0-172" id="h7-0-172" class="i">+}
</a><a href="#h7-0-173" id="h7-0-173" class="i">+
</a><a href="#h7-0-174" id="h7-0-174" class="i">+const ASSOC_LEFT: u8 = 1;
</a><a href="#h7-0-175" id="h7-0-175" class="i">+const ASSOC_RIGHT: u8 = 0;
</a><a href="#h7-0-176" id="h7-0-176" class="i">+
</a><a href="#h7-0-177" id="h7-0-177" class="i">+/// Prefix operators
</a><a href="#h7-0-178" id="h7-0-178" class="i">+enum PrefixOperator {
</a><a href="#h7-0-179" id="h7-0-179" class="i">+    Plus,
</a><a href="#h7-0-180" id="h7-0-180" class="i">+    Minus,
</a><a href="#h7-0-181" id="h7-0-181" class="i">+}
</a><a href="#h7-0-182" id="h7-0-182" class="i">+
</a><a href="#h7-0-183" id="h7-0-183" class="i">+impl PrefixOperator {
</a><a href="#h7-0-184" id="h7-0-184" class="i">+    fn build(&amp;self, rhs: ast::Expression) -&gt; ast::Expression {
</a><a href="#h7-0-185" id="h7-0-185" class="i">+        match self {
</a><a href="#h7-0-186" id="h7-0-186" class="i">+            Self::Plus =&gt; rhs,
</a><a href="#h7-0-187" id="h7-0-187" class="i">+            Self::Minus =&gt; ast::Operation::Negate(Box::new(rhs)).into(),
</a><a href="#h7-0-188" id="h7-0-188" class="i">+        }
</a><a href="#h7-0-189" id="h7-0-189" class="i">+    }
</a><a href="#h7-0-190" id="h7-0-190" class="i">+}
</a><a href="#h7-0-191" id="h7-0-191" class="i">+
</a><a href="#h7-0-192" id="h7-0-192" class="i">+impl Operator for PrefixOperator {
</a><a href="#h7-0-193" id="h7-0-193" class="i">+    fn from(token: &amp;Token) -&gt; Option&lt;Self&gt; {
</a><a href="#h7-0-194" id="h7-0-194" class="i">+        match token {
</a><a href="#h7-0-195" id="h7-0-195" class="i">+            Token::Minus =&gt; Some(Self::Minus),
</a><a href="#h7-0-196" id="h7-0-196" class="i">+            Token::Plus =&gt; Some(Self::Plus),
</a><a href="#h7-0-197" id="h7-0-197" class="i">+            _ =&gt; None,
</a><a href="#h7-0-198" id="h7-0-198" class="i">+        }
</a><a href="#h7-0-199" id="h7-0-199" class="i">+    }
</a><a href="#h7-0-200" id="h7-0-200" class="i">+
</a><a href="#h7-0-201" id="h7-0-201" class="i">+    fn assoc(&amp;self) -&gt; u8 {
</a><a href="#h7-0-202" id="h7-0-202" class="i">+        ASSOC_RIGHT
</a><a href="#h7-0-203" id="h7-0-203" class="i">+    }
</a><a href="#h7-0-204" id="h7-0-204" class="i">+
</a><a href="#h7-0-205" id="h7-0-205" class="i">+    fn prec(&amp;self) -&gt; u8 {
</a><a href="#h7-0-206" id="h7-0-206" class="i">+        5
</a><a href="#h7-0-207" id="h7-0-207" class="i">+    }
</a><a href="#h7-0-208" id="h7-0-208" class="i">+}
</a><a href="#h7-0-209" id="h7-0-209" class="i">+
</a><a href="#h7-0-210" id="h7-0-210" class="i">+enum InfixOperator {
</a><a href="#h7-0-211" id="h7-0-211" class="i">+    Add,
</a><a href="#h7-0-212" id="h7-0-212" class="i">+    Divide,
</a><a href="#h7-0-213" id="h7-0-213" class="i">+    Exponentiate,
</a><a href="#h7-0-214" id="h7-0-214" class="i">+    Modulo,
</a><a href="#h7-0-215" id="h7-0-215" class="i">+    Multiply,
</a><a href="#h7-0-216" id="h7-0-216" class="i">+    Subtract,
</a><a href="#h7-0-217" id="h7-0-217" class="i">+}
</a><a href="#h7-0-218" id="h7-0-218" class="i">+
</a><a href="#h7-0-219" id="h7-0-219" class="i">+impl InfixOperator {
</a><a href="#h7-0-220" id="h7-0-220" class="i">+    fn build(&amp;self, lhs: ast::Expression, rhs: ast::Expression) -&gt; ast::Expression {
</a><a href="#h7-0-221" id="h7-0-221" class="i">+        let (lhs, rhs) = (Box::new(lhs), Box::new(rhs));
</a><a href="#h7-0-222" id="h7-0-222" class="i">+        match self {
</a><a href="#h7-0-223" id="h7-0-223" class="i">+            Self::Add =&gt; ast::Operation::Add(lhs, rhs),
</a><a href="#h7-0-224" id="h7-0-224" class="i">+            Self::Divide =&gt; ast::Operation::Divide(lhs, rhs),
</a><a href="#h7-0-225" id="h7-0-225" class="i">+            Self::Exponentiate =&gt; ast::Operation::Exponentiate(lhs, rhs),
</a><a href="#h7-0-226" id="h7-0-226" class="i">+            Self::Modulo =&gt; ast::Operation::Modulo(lhs, rhs),
</a><a href="#h7-0-227" id="h7-0-227" class="i">+            Self::Multiply =&gt; ast::Operation::Multiply(lhs, rhs),
</a><a href="#h7-0-228" id="h7-0-228" class="i">+            Self::Subtract =&gt; ast::Operation::Subtract(lhs, rhs),
</a><a href="#h7-0-229" id="h7-0-229" class="i">+        }
</a><a href="#h7-0-230" id="h7-0-230" class="i">+        .into()
</a><a href="#h7-0-231" id="h7-0-231" class="i">+    }
</a><a href="#h7-0-232" id="h7-0-232" class="i">+}
</a><a href="#h7-0-233" id="h7-0-233" class="i">+
</a><a href="#h7-0-234" id="h7-0-234" class="i">+impl Operator for InfixOperator {
</a><a href="#h7-0-235" id="h7-0-235" class="i">+    fn from(token: &amp;Token) -&gt; Option&lt;Self&gt; {
</a><a href="#h7-0-236" id="h7-0-236" class="i">+        match token {
</a><a href="#h7-0-237" id="h7-0-237" class="i">+            Token::Plus =&gt; Some(Self::Add),
</a><a href="#h7-0-238" id="h7-0-238" class="i">+            Token::Minus =&gt; Some(Self::Subtract),
</a><a href="#h7-0-239" id="h7-0-239" class="i">+            Token::Asterisk =&gt; Some(Self::Multiply),
</a><a href="#h7-0-240" id="h7-0-240" class="i">+            Token::Slash =&gt; Some(Self::Divide),
</a><a href="#h7-0-241" id="h7-0-241" class="i">+            Token::Percent =&gt; Some(Self::Modulo),
</a><a href="#h7-0-242" id="h7-0-242" class="i">+            Token::Caret =&gt; Some(Self::Exponentiate),
</a><a href="#h7-0-243" id="h7-0-243" class="i">+            _ =&gt; None,
</a><a href="#h7-0-244" id="h7-0-244" class="i">+        }
</a><a href="#h7-0-245" id="h7-0-245" class="i">+    }
</a><a href="#h7-0-246" id="h7-0-246" class="i">+
</a><a href="#h7-0-247" id="h7-0-247" class="i">+    fn assoc(&amp;self) -&gt; u8 {
</a><a href="#h7-0-248" id="h7-0-248" class="i">+        match self {
</a><a href="#h7-0-249" id="h7-0-249" class="i">+            Self::Exponentiate =&gt; ASSOC_RIGHT,
</a><a href="#h7-0-250" id="h7-0-250" class="i">+            _ =&gt; ASSOC_LEFT,
</a><a href="#h7-0-251" id="h7-0-251" class="i">+        }
</a><a href="#h7-0-252" id="h7-0-252" class="i">+    }
</a><a href="#h7-0-253" id="h7-0-253" class="i">+
</a><a href="#h7-0-254" id="h7-0-254" class="i">+    fn prec(&amp;self) -&gt; u8 {
</a><a href="#h7-0-255" id="h7-0-255" class="i">+        match self {
</a><a href="#h7-0-256" id="h7-0-256" class="i">+            Self::Add | Self::Subtract =&gt; 1,
</a><a href="#h7-0-257" id="h7-0-257" class="i">+            Self::Multiply | Self::Divide | Self::Modulo =&gt; 2,
</a><a href="#h7-0-258" id="h7-0-258" class="i">+            Self::Exponentiate =&gt; 3,
</a><a href="#h7-0-259" id="h7-0-259" class="i">+        }
</a><a href="#h7-0-260" id="h7-0-260" class="i">+    }
</a><a href="#h7-0-261" id="h7-0-261" class="i">+}
</a><a href="#h7-0-262" id="h7-0-262" class="i">+
</a><a href="#h7-0-263" id="h7-0-263" class="i">+enum PostfixOperator {
</a><a href="#h7-0-264" id="h7-0-264" class="i">+    Factorial,
</a><a href="#h7-0-265" id="h7-0-265" class="i">+}
</a><a href="#h7-0-266" id="h7-0-266" class="i">+
</a><a href="#h7-0-267" id="h7-0-267" class="i">+impl PostfixOperator {
</a><a href="#h7-0-268" id="h7-0-268" class="i">+    fn build(&amp;self, lhs: ast::Expression) -&gt; ast::Expression {
</a><a href="#h7-0-269" id="h7-0-269" class="i">+        match self {
</a><a href="#h7-0-270" id="h7-0-270" class="i">+            Self::Factorial =&gt; ast::Operation::Factorial(Box::new(lhs)),
</a><a href="#h7-0-271" id="h7-0-271" class="i">+        }
</a><a href="#h7-0-272" id="h7-0-272" class="i">+        .into()
</a><a href="#h7-0-273" id="h7-0-273" class="i">+    }
</a><a href="#h7-0-274" id="h7-0-274" class="i">+}
</a><a href="#h7-0-275" id="h7-0-275" class="i">+
</a><a href="#h7-0-276" id="h7-0-276" class="i">+impl Operator for PostfixOperator {
</a><a href="#h7-0-277" id="h7-0-277" class="i">+    fn from(token: &amp;Token) -&gt; Option&lt;Self&gt; {
</a><a href="#h7-0-278" id="h7-0-278" class="i">+        match token {
</a><a href="#h7-0-279" id="h7-0-279" class="i">+            Token::Exclamation =&gt; Some(Self::Factorial),
</a><a href="#h7-0-280" id="h7-0-280" class="i">+            _ =&gt; None,
</a><a href="#h7-0-281" id="h7-0-281" class="i">+        }
</a><a href="#h7-0-282" id="h7-0-282" class="i">+    }
</a><a href="#h7-0-283" id="h7-0-283" class="i">+
</a><a href="#h7-0-284" id="h7-0-284" class="i">+    fn assoc(&amp;self) -&gt; u8 {
</a><a href="#h7-0-285" id="h7-0-285" class="i">+        ASSOC_LEFT
</a><a href="#h7-0-286" id="h7-0-286" class="i">+    }
</a><a href="#h7-0-287" id="h7-0-287" class="i">+
</a><a href="#h7-0-288" id="h7-0-288" class="i">+    fn prec(&amp;self) -&gt; u8 {
</a><a href="#h7-0-289" id="h7-0-289" class="i">+        4
</a><a href="#h7-0-290" id="h7-0-290" class="i">+    }
</a><a href="#h7-0-291" id="h7-0-291" class="i">+}
</a><b>diff --git a/<a id="h8" href="../file/src/sql/plan/expression.rs.html">src/sql/plan/expression.rs</a> b/<a href="../file/src/sql/plan/expression.rs.html">src/sql/plan/expression.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -0,0 +1,90 @@
</a><a href="#h8-0-0" id="h8-0-0" class="i">+use super::super::types::Value;
</a><a href="#h8-0-1" id="h8-0-1" class="i">+use crate::Error;
</a><a href="#h8-0-2" id="h8-0-2" class="i">+
</a><a href="#h8-0-3" id="h8-0-3" class="i">+/// An expression
</a><a href="#h8-0-4" id="h8-0-4" class="i">+pub enum Expression {
</a><a href="#h8-0-5" id="h8-0-5" class="i">+    Constant(Value),
</a><a href="#h8-0-6" id="h8-0-6" class="i">+    Add(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h8-0-7" id="h8-0-7" class="i">+    Divide(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h8-0-8" id="h8-0-8" class="i">+    Exponentiate(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h8-0-9" id="h8-0-9" class="i">+    Factorial(Box&lt;Expression&gt;),
</a><a href="#h8-0-10" id="h8-0-10" class="i">+    Modulo(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h8-0-11" id="h8-0-11" class="i">+    Multiply(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h8-0-12" id="h8-0-12" class="i">+    Negate(Box&lt;Expression&gt;),
</a><a href="#h8-0-13" id="h8-0-13" class="i">+    Subtract(Box&lt;Expression&gt;, Box&lt;Expression&gt;),
</a><a href="#h8-0-14" id="h8-0-14" class="i">+}
</a><a href="#h8-0-15" id="h8-0-15" class="i">+
</a><a href="#h8-0-16" id="h8-0-16" class="i">+impl Expression {
</a><a href="#h8-0-17" id="h8-0-17" class="i">+    /// Evaluates an expression to a value
</a><a href="#h8-0-18" id="h8-0-18" class="i">+    pub fn evaluate(&amp;self) -&gt; Result&lt;Value, Error&gt; {
</a><a href="#h8-0-19" id="h8-0-19" class="i">+        use Value::*;
</a><a href="#h8-0-20" id="h8-0-20" class="i">+        Ok(match self {
</a><a href="#h8-0-21" id="h8-0-21" class="i">+            Expression::Add(lhs, rhs) =&gt; match (lhs.evaluate()?, rhs.evaluate()?) {
</a><a href="#h8-0-22" id="h8-0-22" class="i">+                (Integer(lhs), Integer(rhs)) =&gt; Integer(lhs + rhs),
</a><a href="#h8-0-23" id="h8-0-23" class="i">+                (Integer(lhs), Float(rhs)) =&gt; Float(lhs as f64 + rhs),
</a><a href="#h8-0-24" id="h8-0-24" class="i">+                (Float(lhs), Integer(rhs)) =&gt; Float(lhs + rhs as f64),
</a><a href="#h8-0-25" id="h8-0-25" class="i">+                (Float(lhs), Float(rhs)) =&gt; Float(lhs + rhs),
</a><a href="#h8-0-26" id="h8-0-26" class="i">+                (lhs, rhs) =&gt; return Err(Error::Value(format!(&quot;Can&#39;t add {} and {}&quot;, lhs, rhs))),
</a><a href="#h8-0-27" id="h8-0-27" class="i">+            },
</a><a href="#h8-0-28" id="h8-0-28" class="i">+            Expression::Divide(lhs, rhs) =&gt; match (lhs.evaluate()?, rhs.evaluate()?) {
</a><a href="#h8-0-29" id="h8-0-29" class="i">+                (Integer(lhs), Integer(rhs)) =&gt; Integer(lhs / rhs),
</a><a href="#h8-0-30" id="h8-0-30" class="i">+                (Integer(lhs), Float(rhs)) =&gt; Float(lhs as f64 / rhs),
</a><a href="#h8-0-31" id="h8-0-31" class="i">+                (Float(lhs), Integer(rhs)) =&gt; Float(lhs / rhs as f64),
</a><a href="#h8-0-32" id="h8-0-32" class="i">+                (Float(lhs), Float(rhs)) =&gt; Float(lhs / rhs),
</a><a href="#h8-0-33" id="h8-0-33" class="i">+                (lhs, rhs) =&gt; {
</a><a href="#h8-0-34" id="h8-0-34" class="i">+                    return Err(Error::Value(format!(&quot;Can&#39;t divide {} and {}&quot;, lhs, rhs)))
</a><a href="#h8-0-35" id="h8-0-35" class="i">+                }
</a><a href="#h8-0-36" id="h8-0-36" class="i">+            },
</a><a href="#h8-0-37" id="h8-0-37" class="i">+            Expression::Exponentiate(lhs, rhs) =&gt; match (lhs.evaluate()?, rhs.evaluate()?) {
</a><a href="#h8-0-38" id="h8-0-38" class="i">+                // FIXME Handle overflow
</a><a href="#h8-0-39" id="h8-0-39" class="i">+                (Integer(lhs), Integer(rhs)) =&gt; Integer(lhs.pow(rhs as u32)),
</a><a href="#h8-0-40" id="h8-0-40" class="i">+                (Integer(lhs), Float(rhs)) =&gt; Float((lhs as f64).powi(rhs as i32)),
</a><a href="#h8-0-41" id="h8-0-41" class="i">+                (Float(lhs), Integer(rhs)) =&gt; Float((lhs).powi(rhs as i32)),
</a><a href="#h8-0-42" id="h8-0-42" class="i">+                (Float(lhs), Float(rhs)) =&gt; Float((lhs).powf(rhs)),
</a><a href="#h8-0-43" id="h8-0-43" class="i">+                (lhs, rhs) =&gt; {
</a><a href="#h8-0-44" id="h8-0-44" class="i">+                    return Err(Error::Value(format!(&quot;Can&#39;t exponentiate {} and {}&quot;, lhs, rhs)))
</a><a href="#h8-0-45" id="h8-0-45" class="i">+                }
</a><a href="#h8-0-46" id="h8-0-46" class="i">+            },
</a><a href="#h8-0-47" id="h8-0-47" class="i">+            Expression::Factorial(v) =&gt; match v.evaluate()? {
</a><a href="#h8-0-48" id="h8-0-48" class="i">+                Integer(v) =&gt; Integer((1..=v).fold(1, |a, b| a * b as i64)),
</a><a href="#h8-0-49" id="h8-0-49" class="i">+                v =&gt; return Err(Error::Value(format!(&quot;Can&#39;t take factorial of {}&quot;, v))),
</a><a href="#h8-0-50" id="h8-0-50" class="i">+            },
</a><a href="#h8-0-51" id="h8-0-51" class="i">+            Expression::Modulo(lhs, rhs) =&gt; match (lhs.evaluate()?, rhs.evaluate()?) {
</a><a href="#h8-0-52" id="h8-0-52" class="i">+                // The % operator in Rust is remainder, not modulo, so we have to do a bit of
</a><a href="#h8-0-53" id="h8-0-53" class="i">+                // acrobatics to make it work right
</a><a href="#h8-0-54" id="h8-0-54" class="i">+                (Integer(lhs), Integer(rhs)) =&gt; Integer(((lhs % rhs) + rhs) % rhs),
</a><a href="#h8-0-55" id="h8-0-55" class="i">+                (Integer(lhs), Float(rhs)) =&gt; Float(((lhs as f64 % rhs) + rhs) % rhs),
</a><a href="#h8-0-56" id="h8-0-56" class="i">+                (Float(lhs), Integer(rhs)) =&gt; Float(((lhs % rhs as f64) + rhs as f64) % rhs as f64),
</a><a href="#h8-0-57" id="h8-0-57" class="i">+                (Float(lhs), Float(rhs)) =&gt; Float(((lhs % rhs) + rhs) % rhs),
</a><a href="#h8-0-58" id="h8-0-58" class="i">+                (lhs, rhs) =&gt; {
</a><a href="#h8-0-59" id="h8-0-59" class="i">+                    return Err(Error::Value(format!(&quot;Can&#39;t take modulo of {} and {}&quot;, lhs, rhs)))
</a><a href="#h8-0-60" id="h8-0-60" class="i">+                }
</a><a href="#h8-0-61" id="h8-0-61" class="i">+            },
</a><a href="#h8-0-62" id="h8-0-62" class="i">+            Expression::Multiply(lhs, rhs) =&gt; match (lhs.evaluate()?, rhs.evaluate()?) {
</a><a href="#h8-0-63" id="h8-0-63" class="i">+                (Integer(lhs), Integer(rhs)) =&gt; Integer(lhs * rhs),
</a><a href="#h8-0-64" id="h8-0-64" class="i">+                (Integer(lhs), Float(rhs)) =&gt; Float(lhs as f64 * rhs),
</a><a href="#h8-0-65" id="h8-0-65" class="i">+                (Float(lhs), Integer(rhs)) =&gt; Float(lhs * rhs as f64),
</a><a href="#h8-0-66" id="h8-0-66" class="i">+                (Float(lhs), Float(rhs)) =&gt; Float(lhs * rhs),
</a><a href="#h8-0-67" id="h8-0-67" class="i">+                (lhs, rhs) =&gt; {
</a><a href="#h8-0-68" id="h8-0-68" class="i">+                    return Err(Error::Value(format!(&quot;Can&#39;t multiply {} and {}&quot;, lhs, rhs)))
</a><a href="#h8-0-69" id="h8-0-69" class="i">+                }
</a><a href="#h8-0-70" id="h8-0-70" class="i">+            },
</a><a href="#h8-0-71" id="h8-0-71" class="i">+            Expression::Negate(expr) =&gt; match expr.evaluate()? {
</a><a href="#h8-0-72" id="h8-0-72" class="i">+                Integer(v) =&gt; Integer(-v),
</a><a href="#h8-0-73" id="h8-0-73" class="i">+                Float(v) =&gt; Float(-v),
</a><a href="#h8-0-74" id="h8-0-74" class="i">+                v =&gt; return Err(Error::Value(format!(&quot;Can&#39;t negate {}&quot;, v))),
</a><a href="#h8-0-75" id="h8-0-75" class="i">+            },
</a><a href="#h8-0-76" id="h8-0-76" class="i">+            Expression::Subtract(lhs, rhs) =&gt; match (lhs.evaluate()?, rhs.evaluate()?) {
</a><a href="#h8-0-77" id="h8-0-77" class="i">+                (Integer(lhs), Integer(rhs)) =&gt; Integer(lhs - rhs),
</a><a href="#h8-0-78" id="h8-0-78" class="i">+                (Integer(lhs), Float(rhs)) =&gt; Float(lhs as f64 - rhs),
</a><a href="#h8-0-79" id="h8-0-79" class="i">+                (Float(lhs), Integer(rhs)) =&gt; Float(lhs - rhs as f64),
</a><a href="#h8-0-80" id="h8-0-80" class="i">+                (Float(lhs), Float(rhs)) =&gt; Float(lhs - rhs),
</a><a href="#h8-0-81" id="h8-0-81" class="i">+                (lhs, rhs) =&gt; {
</a><a href="#h8-0-82" id="h8-0-82" class="i">+                    return Err(Error::Value(format!(&quot;Can&#39;t subtract {} and {}&quot;, lhs, rhs)))
</a><a href="#h8-0-83" id="h8-0-83" class="i">+                }
</a><a href="#h8-0-84" id="h8-0-84" class="i">+            },
</a><a href="#h8-0-85" id="h8-0-85" class="i">+
</a><a href="#h8-0-86" id="h8-0-86" class="i">+            Expression::Constant(v) =&gt; v.clone(),
</a><a href="#h8-0-87" id="h8-0-87" class="i">+        })
</a><a href="#h8-0-88" id="h8-0-88" class="i">+    }
</a><a href="#h8-0-89" id="h8-0-89" class="i">+}
</a><b>diff --git a/<a id="h9" href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a> b/<a href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -0,0 +1,34 @@
</a><a href="#h9-0-0" id="h9-0-0" class="i">+mod expression;
</a><a href="#h9-0-1" id="h9-0-1" class="i">+mod node;
</a><a href="#h9-0-2" id="h9-0-2" class="i">+mod planner;
</a><a href="#h9-0-3" id="h9-0-3" class="i">+
</a><a href="#h9-0-4" id="h9-0-4" class="i">+pub use node::Node;
</a><a href="#h9-0-5" id="h9-0-5" class="i">+
</a><a href="#h9-0-6" id="h9-0-6" class="i">+use super::parser::ast;
</a><a href="#h9-0-7" id="h9-0-7" class="i">+use super::types::Row;
</a><a href="#h9-0-8" id="h9-0-8" class="i">+use crate::Error;
</a><a href="#h9-0-9" id="h9-0-9" class="i">+use planner::Planner;
</a><a href="#h9-0-10" id="h9-0-10" class="i">+
</a><a href="#h9-0-11" id="h9-0-11" class="i">+/// A plan
</a><a href="#h9-0-12" id="h9-0-12" class="i">+pub struct Plan {
</a><a href="#h9-0-13" id="h9-0-13" class="i">+    /// The plan column names
</a><a href="#h9-0-14" id="h9-0-14" class="i">+    pub columns: Vec&lt;String&gt;,
</a><a href="#h9-0-15" id="h9-0-15" class="i">+
</a><a href="#h9-0-16" id="h9-0-16" class="i">+    /// The plan root
</a><a href="#h9-0-17" id="h9-0-17" class="i">+    pub root: Node,
</a><a href="#h9-0-18" id="h9-0-18" class="i">+}
</a><a href="#h9-0-19" id="h9-0-19" class="i">+
</a><a href="#h9-0-20" id="h9-0-20" class="i">+impl Iterator for Plan {
</a><a href="#h9-0-21" id="h9-0-21" class="i">+    type Item = Result&lt;Row, Error&gt;;
</a><a href="#h9-0-22" id="h9-0-22" class="i">+
</a><a href="#h9-0-23" id="h9-0-23" class="i">+    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;Row, Error&gt;&gt; {
</a><a href="#h9-0-24" id="h9-0-24" class="i">+        self.root.next()
</a><a href="#h9-0-25" id="h9-0-25" class="i">+    }
</a><a href="#h9-0-26" id="h9-0-26" class="i">+}
</a><a href="#h9-0-27" id="h9-0-27" class="i">+
</a><a href="#h9-0-28" id="h9-0-28" class="i">+impl Plan {
</a><a href="#h9-0-29" id="h9-0-29" class="i">+    /// Builds a plan from a statement AST
</a><a href="#h9-0-30" id="h9-0-30" class="i">+    pub fn build(statement: ast::Statement) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h9-0-31" id="h9-0-31" class="i">+        Planner::new().build(statement)
</a><a href="#h9-0-32" id="h9-0-32" class="i">+    }
</a><a href="#h9-0-33" id="h9-0-33" class="i">+}
</a><b>diff --git a/<a id="h10" href="../file/src/sql/plan/node.rs.html">src/sql/plan/node.rs</a> b/<a href="../file/src/sql/plan/node.rs.html">src/sql/plan/node.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -0,0 +1,33 @@
</a><a href="#h10-0-0" id="h10-0-0" class="i">+use super::super::types::Row;
</a><a href="#h10-0-1" id="h10-0-1" class="i">+use super::expression::Expression;
</a><a href="#h10-0-2" id="h10-0-2" class="i">+use crate::Error;
</a><a href="#h10-0-3" id="h10-0-3" class="i">+
</a><a href="#h10-0-4" id="h10-0-4" class="i">+/// A plan node
</a><a href="#h10-0-5" id="h10-0-5" class="i">+pub enum Node {
</a><a href="#h10-0-6" id="h10-0-6" class="i">+    Projection { labels: Vec&lt;String&gt;, source: Box&lt;Node&gt;, expressions: Vec&lt;Expression&gt; },
</a><a href="#h10-0-7" id="h10-0-7" class="i">+    Nothing { done: bool },
</a><a href="#h10-0-8" id="h10-0-8" class="i">+}
</a><a href="#h10-0-9" id="h10-0-9" class="i">+
</a><a href="#h10-0-10" id="h10-0-10" class="i">+impl Iterator for Node {
</a><a href="#h10-0-11" id="h10-0-11" class="i">+    type Item = Result&lt;Row, Error&gt;;
</a><a href="#h10-0-12" id="h10-0-12" class="i">+
</a><a href="#h10-0-13" id="h10-0-13" class="i">+    fn next(&amp;mut self) -&gt; Option&lt;Result&lt;Row, Error&gt;&gt; {
</a><a href="#h10-0-14" id="h10-0-14" class="i">+        match self {
</a><a href="#h10-0-15" id="h10-0-15" class="i">+            Node::Projection { source, expressions, .. } =&gt; {
</a><a href="#h10-0-16" id="h10-0-16" class="i">+                if let Err(err) = source.next()? {
</a><a href="#h10-0-17" id="h10-0-17" class="i">+                    Some(Err(err))
</a><a href="#h10-0-18" id="h10-0-18" class="i">+                } else {
</a><a href="#h10-0-19" id="h10-0-19" class="i">+                    Some(expressions.iter().map(|e| e.evaluate()).collect())
</a><a href="#h10-0-20" id="h10-0-20" class="i">+                }
</a><a href="#h10-0-21" id="h10-0-21" class="i">+            }
</a><a href="#h10-0-22" id="h10-0-22" class="i">+            Node::Nothing { ref mut done } =&gt; {
</a><a href="#h10-0-23" id="h10-0-23" class="i">+                if !*done {
</a><a href="#h10-0-24" id="h10-0-24" class="i">+                    *done = true;
</a><a href="#h10-0-25" id="h10-0-25" class="i">+                    Some(Ok(vec![]))
</a><a href="#h10-0-26" id="h10-0-26" class="i">+                } else {
</a><a href="#h10-0-27" id="h10-0-27" class="i">+                    None
</a><a href="#h10-0-28" id="h10-0-28" class="i">+                }
</a><a href="#h10-0-29" id="h10-0-29" class="i">+            }
</a><a href="#h10-0-30" id="h10-0-30" class="i">+        }
</a><a href="#h10-0-31" id="h10-0-31" class="i">+    }
</a><a href="#h10-0-32" id="h10-0-32" class="i">+}
</a><b>diff --git a/<a id="h11" href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a> b/<a href="../file/src/sql/plan/planner.rs.html">src/sql/plan/planner.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -0,0 +1,89 @@
</a><a href="#h11-0-0" id="h11-0-0" class="i">+use super::super::parser::ast;
</a><a href="#h11-0-1" id="h11-0-1" class="i">+use super::super::types::Value;
</a><a href="#h11-0-2" id="h11-0-2" class="i">+use super::expression::Expression;
</a><a href="#h11-0-3" id="h11-0-3" class="i">+use super::node::Node;
</a><a href="#h11-0-4" id="h11-0-4" class="i">+use super::Plan;
</a><a href="#h11-0-5" id="h11-0-5" class="i">+use crate::Error;
</a><a href="#h11-0-6" id="h11-0-6" class="i">+
</a><a href="#h11-0-7" id="h11-0-7" class="i">+pub struct Planner {}
</a><a href="#h11-0-8" id="h11-0-8" class="i">+
</a><a href="#h11-0-9" id="h11-0-9" class="i">+impl Planner {
</a><a href="#h11-0-10" id="h11-0-10" class="i">+    /// Creates a new planner
</a><a href="#h11-0-11" id="h11-0-11" class="i">+    pub fn new() -&gt; Self {
</a><a href="#h11-0-12" id="h11-0-12" class="i">+        Self {}
</a><a href="#h11-0-13" id="h11-0-13" class="i">+    }
</a><a href="#h11-0-14" id="h11-0-14" class="i">+
</a><a href="#h11-0-15" id="h11-0-15" class="i">+    /// Builds a plan tree for an AST statement
</a><a href="#h11-0-16" id="h11-0-16" class="i">+    pub fn build(&amp;self, statement: ast::Statement) -&gt; Result&lt;Plan, Error&gt; {
</a><a href="#h11-0-17" id="h11-0-17" class="i">+        let root = self.build_statement(statement)?;
</a><a href="#h11-0-18" id="h11-0-18" class="i">+        Ok(Plan {
</a><a href="#h11-0-19" id="h11-0-19" class="i">+            columns: match &amp;root {
</a><a href="#h11-0-20" id="h11-0-20" class="i">+                Node::Projection { labels, .. } =&gt; labels.clone(),
</a><a href="#h11-0-21" id="h11-0-21" class="i">+                _ =&gt; panic!(&quot;Not implemented&quot;),
</a><a href="#h11-0-22" id="h11-0-22" class="i">+            },
</a><a href="#h11-0-23" id="h11-0-23" class="i">+            root,
</a><a href="#h11-0-24" id="h11-0-24" class="i">+        })
</a><a href="#h11-0-25" id="h11-0-25" class="i">+    }
</a><a href="#h11-0-26" id="h11-0-26" class="i">+
</a><a href="#h11-0-27" id="h11-0-27" class="i">+    /// Builds a plan node for a statement
</a><a href="#h11-0-28" id="h11-0-28" class="i">+    fn build_statement(&amp;self, statement: ast::Statement) -&gt; Result&lt;Node, Error&gt; {
</a><a href="#h11-0-29" id="h11-0-29" class="i">+        Ok(match statement {
</a><a href="#h11-0-30" id="h11-0-30" class="i">+            ast::Statement::Select { select } =&gt; Node::Projection {
</a><a href="#h11-0-31" id="h11-0-31" class="i">+                labels: select
</a><a href="#h11-0-32" id="h11-0-32" class="i">+                    .labels
</a><a href="#h11-0-33" id="h11-0-33" class="i">+                    .into_iter()
</a><a href="#h11-0-34" id="h11-0-34" class="i">+                    .map(|l| l.unwrap_or_else(|| &quot;?&quot;.into()))
</a><a href="#h11-0-35" id="h11-0-35" class="i">+                    .collect(),
</a><a href="#h11-0-36" id="h11-0-36" class="i">+                expressions: self.build_expressions(select.expressions)?,
</a><a href="#h11-0-37" id="h11-0-37" class="i">+                source: Box::new(Node::Nothing { done: false }),
</a><a href="#h11-0-38" id="h11-0-38" class="i">+            },
</a><a href="#h11-0-39" id="h11-0-39" class="i">+        })
</a><a href="#h11-0-40" id="h11-0-40" class="i">+    }
</a><a href="#h11-0-41" id="h11-0-41" class="i">+
</a><a href="#h11-0-42" id="h11-0-42" class="i">+    /// Builds a plan expression from an AST expression
</a><a href="#h11-0-43" id="h11-0-43" class="i">+    fn build_expression(&amp;self, expr: ast::Expression) -&gt; Result&lt;Expression, Error&gt; {
</a><a href="#h11-0-44" id="h11-0-44" class="i">+        Ok(expr.into())
</a><a href="#h11-0-45" id="h11-0-45" class="i">+    }
</a><a href="#h11-0-46" id="h11-0-46" class="i">+
</a><a href="#h11-0-47" id="h11-0-47" class="i">+    /// Builds an array of plan expressions from AST expressions
</a><a href="#h11-0-48" id="h11-0-48" class="i">+    fn build_expressions(&amp;self, exprs: Vec&lt;ast::Expression&gt;) -&gt; Result&lt;Vec&lt;Expression&gt;, Error&gt; {
</a><a href="#h11-0-49" id="h11-0-49" class="i">+        exprs.into_iter().map(|e| self.build_expression(e)).collect()
</a><a href="#h11-0-50" id="h11-0-50" class="i">+    }
</a><a href="#h11-0-51" id="h11-0-51" class="i">+}
</a><a href="#h11-0-52" id="h11-0-52" class="i">+
</a><a href="#h11-0-53" id="h11-0-53" class="i">+/// Helpers to convert AST expressions into plan expressions
</a><a href="#h11-0-54" id="h11-0-54" class="i">+impl From&lt;ast::Expression&gt; for Expression {
</a><a href="#h11-0-55" id="h11-0-55" class="i">+    fn from(expr: ast::Expression) -&gt; Self {
</a><a href="#h11-0-56" id="h11-0-56" class="i">+        match expr {
</a><a href="#h11-0-57" id="h11-0-57" class="i">+            ast::Expression::Literal(l) =&gt; Expression::Constant(l.into()),
</a><a href="#h11-0-58" id="h11-0-58" class="i">+            ast::Expression::Operation(op) =&gt; match op {
</a><a href="#h11-0-59" id="h11-0-59" class="i">+                ast::Operation::Add(lhs, rhs) =&gt; Self::Add(lhs.into(), rhs.into()),
</a><a href="#h11-0-60" id="h11-0-60" class="i">+                ast::Operation::Divide(lhs, rhs) =&gt; Self::Divide(lhs.into(), rhs.into()),
</a><a href="#h11-0-61" id="h11-0-61" class="i">+                ast::Operation::Exponentiate(lhs, rhs) =&gt; Self::Exponentiate(lhs.into(), rhs.into()),
</a><a href="#h11-0-62" id="h11-0-62" class="i">+                ast::Operation::Factorial(e) =&gt; Self::Factorial(e.into()),
</a><a href="#h11-0-63" id="h11-0-63" class="i">+                ast::Operation::Modulo(lhs, rhs) =&gt; Self::Modulo(lhs.into(), rhs.into()),
</a><a href="#h11-0-64" id="h11-0-64" class="i">+                ast::Operation::Multiply(lhs, rhs) =&gt; Self::Multiply(lhs.into(), rhs.into()),
</a><a href="#h11-0-65" id="h11-0-65" class="i">+                ast::Operation::Negate(e) =&gt; Self::Negate(e.into()),
</a><a href="#h11-0-66" id="h11-0-66" class="i">+                ast::Operation::Subtract(lhs, rhs) =&gt; Self::Subtract(lhs.into(), rhs.into()),
</a><a href="#h11-0-67" id="h11-0-67" class="i">+            },
</a><a href="#h11-0-68" id="h11-0-68" class="i">+        }
</a><a href="#h11-0-69" id="h11-0-69" class="i">+    }
</a><a href="#h11-0-70" id="h11-0-70" class="i">+}
</a><a href="#h11-0-71" id="h11-0-71" class="i">+
</a><a href="#h11-0-72" id="h11-0-72" class="i">+impl From&lt;Box&lt;ast::Expression&gt;&gt; for Box&lt;Expression&gt; {
</a><a href="#h11-0-73" id="h11-0-73" class="i">+    fn from(expr: Box&lt;ast::Expression&gt;) -&gt; Self {
</a><a href="#h11-0-74" id="h11-0-74" class="i">+        Box::new((*expr).into())
</a><a href="#h11-0-75" id="h11-0-75" class="i">+    }
</a><a href="#h11-0-76" id="h11-0-76" class="i">+}
</a><a href="#h11-0-77" id="h11-0-77" class="i">+
</a><a href="#h11-0-78" id="h11-0-78" class="i">+impl From&lt;ast::Literal&gt; for Value {
</a><a href="#h11-0-79" id="h11-0-79" class="i">+    fn from(literal: ast::Literal) -&gt; Self {
</a><a href="#h11-0-80" id="h11-0-80" class="i">+        match literal {
</a><a href="#h11-0-81" id="h11-0-81" class="i">+            ast::Literal::Null =&gt; Value::Null,
</a><a href="#h11-0-82" id="h11-0-82" class="i">+            ast::Literal::Boolean(b) =&gt; b.into(),
</a><a href="#h11-0-83" id="h11-0-83" class="i">+            ast::Literal::Float(f) =&gt; f.into(),
</a><a href="#h11-0-84" id="h11-0-84" class="i">+            ast::Literal::Integer(i) =&gt; i.into(),
</a><a href="#h11-0-85" id="h11-0-85" class="i">+            ast::Literal::String(s) =&gt; s.into(),
</a><a href="#h11-0-86" id="h11-0-86" class="i">+        }
</a><a href="#h11-0-87" id="h11-0-87" class="i">+    }
</a><a href="#h11-0-88" id="h11-0-88" class="i">+}
</a><b>diff --git a/<a id="h12" href="../file/src/sql/types.rs.html">src/sql/types.rs</a> b/<a href="../file/src/sql/types.rs.html">src/sql/types.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -1,4 +1,5 @@
</a> /// A value
<a href="#h12-0-1" id="h12-0-1" class="i">+#[derive(Clone, Debug, PartialEq, PartialOrd)]
</a> pub enum Value {
     /// An unknown value
     Null,
<a href="#h12-1" id="h12-1" class="h">@@ -17,13 +18,8 @@ impl std::fmt::Display for Value {
</a>         f.write_str(
             match self {
                 Value::Null =&gt; &quot;NULL&quot;.to_string(),
<a href="#h12-1-3" id="h12-1-3" class="d">-                Value::Boolean(b) =&gt; {
</a><a href="#h12-1-4" id="h12-1-4" class="d">-                    if *b {
</a><a href="#h12-1-5" id="h12-1-5" class="d">-                        &quot;TRUE&quot;.to_string()
</a><a href="#h12-1-6" id="h12-1-6" class="d">-                    } else {
</a><a href="#h12-1-7" id="h12-1-7" class="d">-                        &quot;FALSE&quot;.to_string()
</a><a href="#h12-1-8" id="h12-1-8" class="d">-                    }
</a><a href="#h12-1-9" id="h12-1-9" class="d">-                }
</a><a href="#h12-1-10" id="h12-1-10" class="i">+                Value::Boolean(b) if *b =&gt; &quot;TRUE&quot;.to_string(),
</a><a href="#h12-1-11" id="h12-1-11" class="i">+                Value::Boolean(_) =&gt; &quot;FALSE&quot;.to_string(),
</a>                 Value::Integer(i) =&gt; i.to_string(),
                 Value::Float(f) =&gt; f.to_string(),
                 Value::String(s) =&gt; s.clone(),
<a href="#h12-2" id="h12-2" class="h">@@ -33,5 +29,35 @@ impl std::fmt::Display for Value {
</a>     }
 }
 
<a href="#h12-2-3" id="h12-2-3" class="i">+impl From&lt;bool&gt; for Value {
</a><a href="#h12-2-4" id="h12-2-4" class="i">+    fn from(v: bool) -&gt; Self {
</a><a href="#h12-2-5" id="h12-2-5" class="i">+        Value::Boolean(v)
</a><a href="#h12-2-6" id="h12-2-6" class="i">+    }
</a><a href="#h12-2-7" id="h12-2-7" class="i">+}
</a><a href="#h12-2-8" id="h12-2-8" class="i">+
</a><a href="#h12-2-9" id="h12-2-9" class="i">+impl From&lt;f64&gt; for Value {
</a><a href="#h12-2-10" id="h12-2-10" class="i">+    fn from(v: f64) -&gt; Self {
</a><a href="#h12-2-11" id="h12-2-11" class="i">+        Value::Float(v)
</a><a href="#h12-2-12" id="h12-2-12" class="i">+    }
</a><a href="#h12-2-13" id="h12-2-13" class="i">+}
</a><a href="#h12-2-14" id="h12-2-14" class="i">+
</a><a href="#h12-2-15" id="h12-2-15" class="i">+impl From&lt;i64&gt; for Value {
</a><a href="#h12-2-16" id="h12-2-16" class="i">+    fn from(v: i64) -&gt; Self {
</a><a href="#h12-2-17" id="h12-2-17" class="i">+        Value::Integer(v)
</a><a href="#h12-2-18" id="h12-2-18" class="i">+    }
</a><a href="#h12-2-19" id="h12-2-19" class="i">+}
</a><a href="#h12-2-20" id="h12-2-20" class="i">+
</a><a href="#h12-2-21" id="h12-2-21" class="i">+impl From&lt;String&gt; for Value {
</a><a href="#h12-2-22" id="h12-2-22" class="i">+    fn from(v: String) -&gt; Self {
</a><a href="#h12-2-23" id="h12-2-23" class="i">+        Value::String(v)
</a><a href="#h12-2-24" id="h12-2-24" class="i">+    }
</a><a href="#h12-2-25" id="h12-2-25" class="i">+}
</a><a href="#h12-2-26" id="h12-2-26" class="i">+
</a><a href="#h12-2-27" id="h12-2-27" class="i">+impl From&lt;&amp;str&gt; for Value {
</a><a href="#h12-2-28" id="h12-2-28" class="i">+    fn from(v: &amp;str) -&gt; Self {
</a><a href="#h12-2-29" id="h12-2-29" class="i">+        Value::String(v.to_owned())
</a><a href="#h12-2-30" id="h12-2-30" class="i">+    }
</a><a href="#h12-2-31" id="h12-2-31" class="i">+}
</a><a href="#h12-2-32" id="h12-2-32" class="i">+
</a> /// A row of values
 pub type Row = Vec&lt;Value&gt;;
</pre>
</div>
</body>
</html>
