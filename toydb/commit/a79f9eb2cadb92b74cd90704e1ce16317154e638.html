<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>storage: use a channel for `Debug` engine write logs - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/a79f9eb2cadb92b74cd90704e1ce16317154e638.html">a79f9eb2cadb92b74cd90704e1ce16317154e638</a>
<b>parent</b> <a href="../commit/cf6d48b0ffa218996ee6798fe0263e86e65afaf7.html">cf6d48b0ffa218996ee6798fe0263e86e65afaf7</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Thu, 30 May 2024 18:34:05 +0200

storage: use a channel for `Debug` engine write logs

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/storage/debug.rs</a></td><td> | </td><td class="num">35</td><td><span class="i">+++++++++++++++++++++++</span><span class="d">------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/storage/mvcc.rs</a></td><td> | </td><td class="num">25</td><td><span class="i">+++++++++++++++++</span><span class="d">--------</span></td></tr>
</table></pre><pre>2 files changed, 40 insertions(+), 20 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/storage/debug.rs.html">src/storage/debug.rs</a> b/<a href="../file/src/storage/debug.rs.html">src/storage/debug.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -2,6 +2,8 @@
</a> 
 use std::collections::HashSet;
 
<a href="#h0-0-3" id="h0-0-3" class="i">+use crossbeam::channel::{Receiver, Sender};
</a><a href="#h0-0-4" id="h0-0-4" class="i">+
</a> use super::engine::{self, ScanIterator, Status};
 use super::mvcc::{self, TransactionState};
 use crate::encoding::bincode;
<a href="#h0-1" id="h0-1" class="h">@@ -91,12 +93,14 @@ pub fn format_key_value(key: &amp;[u8], value: &amp;Option&lt;Vec&lt;u8&gt;&gt;) -&gt; (String, Option&lt;
</a>     (fkey, fvalue)
 }
 
<a href="#h0-1-3" id="h0-1-3" class="d">-/// A debug storage engine, which wraps another engine and logs mutations.
</a><a href="#h0-1-4" id="h0-1-4" class="i">+/// A debug storage engine, which wraps another engine and emits events.
</a> pub struct Engine&lt;E: engine::Engine&gt; {
     /// The wrapped engine.
     inner: E,
<a href="#h0-1-8" id="h0-1-8" class="d">-    /// Write log as key/value tuples. Value is None for deletes.
</a><a href="#h0-1-9" id="h0-1-9" class="d">-    write_log: Vec&lt;(Vec&lt;u8&gt;, Option&lt;Vec&lt;u8&gt;&gt;)&gt;,
</a><a href="#h0-1-10" id="h0-1-10" class="i">+    /// Sends engine operations.
</a><a href="#h0-1-11" id="h0-1-11" class="i">+    op_tx: Sender&lt;Operation&gt;,
</a><a href="#h0-1-12" id="h0-1-12" class="i">+    /// Receives engine operations.
</a><a href="#h0-1-13" id="h0-1-13" class="i">+    op_rx: Receiver&lt;Operation&gt;,
</a> }
 
 impl&lt;E: engine::Engine&gt; std::fmt::Display for Engine&lt;E&gt; {
<a href="#h0-2" id="h0-2" class="h">@@ -107,14 +111,12 @@ impl&lt;E: engine::Engine&gt; std::fmt::Display for Engine&lt;E&gt; {
</a> 
 impl&lt;E: engine::Engine&gt; Engine&lt;E&gt; {
     pub fn new(inner: E) -&gt; Self {
<a href="#h0-2-3" id="h0-2-3" class="d">-        Self { inner, write_log: Vec::new() }
</a><a href="#h0-2-4" id="h0-2-4" class="i">+        let (op_tx, op_rx) = crossbeam::channel::unbounded();
</a><a href="#h0-2-5" id="h0-2-5" class="i">+        Self { inner, op_tx, op_rx }
</a>     }
 
<a href="#h0-2-8" id="h0-2-8" class="d">-    /// Returns and resets the write log. The next call only returns new writes.
</a><a href="#h0-2-9" id="h0-2-9" class="d">-    pub fn take_write_log(&amp;mut self) -&gt; Vec&lt;(Vec&lt;u8&gt;, Option&lt;Vec&lt;u8&gt;&gt;)&gt; {
</a><a href="#h0-2-10" id="h0-2-10" class="d">-        let mut write_log = Vec::new();
</a><a href="#h0-2-11" id="h0-2-11" class="d">-        std::mem::swap(&amp;mut write_log, &amp;mut self.write_log);
</a><a href="#h0-2-12" id="h0-2-12" class="d">-        write_log
</a><a href="#h0-2-13" id="h0-2-13" class="i">+    pub fn op_rx(&amp;self) -&gt; Receiver&lt;Operation&gt; {
</a><a href="#h0-2-14" id="h0-2-14" class="i">+        self.op_rx.clone()
</a>     }
 }
 
<a href="#h0-3" id="h0-3" class="h">@@ -122,12 +124,14 @@ impl&lt;E: engine::Engine&gt; engine::Engine for Engine&lt;E&gt; {
</a>     type ScanIterator&lt;&#39;a&gt; = E::ScanIterator&lt;&#39;a&gt; where E: &#39;a;
 
     fn flush(&amp;mut self) -&gt; Result&lt;()&gt; {
<a href="#h0-3-3" id="h0-3-3" class="d">-        self.inner.flush()
</a><a href="#h0-3-4" id="h0-3-4" class="i">+        self.inner.flush()?;
</a><a href="#h0-3-5" id="h0-3-5" class="i">+        self.op_tx.send(Operation::Flush)?;
</a><a href="#h0-3-6" id="h0-3-6" class="i">+        Ok(())
</a>     }
 
     fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;()&gt; {
         self.inner.delete(key)?;
<a href="#h0-3-11" id="h0-3-11" class="d">-        self.write_log.push((key.to_vec(), None));
</a><a href="#h0-3-12" id="h0-3-12" class="i">+        self.op_tx.send(Operation::Delete(key.to_vec()))?;
</a>         Ok(())
     }
 
<a href="#h0-4" id="h0-4" class="h">@@ -148,7 +152,7 @@ impl&lt;E: engine::Engine&gt; engine::Engine for Engine&lt;E&gt; {
</a> 
     fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
         self.inner.set(key, value.clone())?;
<a href="#h0-4-3" id="h0-4-3" class="d">-        self.write_log.push((key.to_vec(), Some(value)));
</a><a href="#h0-4-4" id="h0-4-4" class="i">+        self.op_tx.send(Operation::Set(key.to_vec(), value))?;
</a>         Ok(())
     }
 
<a href="#h0-5" id="h0-5" class="h">@@ -156,3 +160,10 @@ impl&lt;E: engine::Engine&gt; engine::Engine for Engine&lt;E&gt; {
</a>         self.inner.status()
     }
 }
<a href="#h0-5-3" id="h0-5-3" class="i">+
</a><a href="#h0-5-4" id="h0-5-4" class="i">+/// An engine operation, emitted by the debug engine.
</a><a href="#h0-5-5" id="h0-5-5" class="i">+pub enum Operation {
</a><a href="#h0-5-6" id="h0-5-6" class="i">+    Delete(Vec&lt;u8&gt;),
</a><a href="#h0-5-7" id="h0-5-7" class="i">+    Flush,
</a><a href="#h0-5-8" id="h0-5-8" class="i">+    Set(Vec&lt;u8&gt;, Vec&lt;u8&gt;),
</a><a href="#h0-5-9" id="h0-5-9" class="i">+}
</a><b>diff --git a/<a id="h1" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -462,6 +462,9 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// Commits the transaction, by removing it from the active set. This will
     /// immediately make its writes visible to subsequent transactions. Also
     /// removes its TxnWrite records, which are no longer needed.
<a href="#h1-0-3" id="h1-0-3" class="i">+    ///
</a><a href="#h1-0-4" id="h1-0-4" class="i">+    /// NB: commit does not flush writes to durable storage, since we rely on
</a><a href="#h1-0-5" id="h1-0-5" class="i">+    /// the Raft log for persistence.
</a>     pub fn commit(self) -&gt; Result&lt;()&gt; {
         if self.st.read_only {
             return Ok(());
<a href="#h1-1" id="h1-1" class="h">@@ -795,6 +798,7 @@ pub mod tests {
</a>     const GOLDEN_DIR: &amp;str = &quot;src/storage/golden/mvcc&quot;;
 
     /// An MVCC wrapper that records transaction schedules to golden masters.
<a href="#h1-1-3" id="h1-1-3" class="i">+    /// TODO: migrate this to goldenscript.
</a>     struct Schedule {
         mvcc: MVCC&lt;Debug&lt;Memory&gt;&gt;,
         mint: goldenfile::Mint,
<a href="#h1-2" id="h1-2" class="h">@@ -838,7 +842,7 @@ pub mod tests {
</a>                 txn.commit()?;
             }
             // Flush the write log, but dump the engine contents.
<a href="#h1-2-3" id="h1-2-3" class="d">-            self.mvcc.engine.lock()?.take_write_log();
</a><a href="#h1-2-4" id="h1-2-4" class="i">+            while self.mvcc.engine.lock()?.op_rx().try_recv().is_ok() {}
</a>             self.print_engine()?;
             writeln!(&amp;mut self.file.lock()?)?;
             Ok(())
<a href="#h1-3" id="h1-3" class="h">@@ -895,13 +899,18 @@ pub mod tests {
</a>             f: &amp;mut MutexGuard&lt;&#39;_, std::fs::File&gt;,
             engine: &amp;mut MutexGuard&lt;&#39;_, Debug&lt;Memory&gt;&gt;,
         ) -&gt; Result&lt;()&gt; {
<a href="#h1-3-3" id="h1-3-3" class="d">-            let writes = engine.take_write_log();
</a><a href="#h1-3-4" id="h1-3-4" class="d">-            for (key, value) in &amp;writes {
</a><a href="#h1-3-5" id="h1-3-5" class="d">-                let (fkey, fvalue) = debug::format_key_value(key, value);
</a><a href="#h1-3-6" id="h1-3-6" class="d">-                match fvalue {
</a><a href="#h1-3-7" id="h1-3-7" class="d">-                    Some(fvalue) =&gt; writeln!(f, &quot;    set {} = {}&quot;, fkey, fvalue)?,
</a><a href="#h1-3-8" id="h1-3-8" class="d">-                    None =&gt; writeln!(f, &quot;    del {}&quot;, fkey)?,
</a><a href="#h1-3-9" id="h1-3-9" class="d">-                }
</a><a href="#h1-3-10" id="h1-3-10" class="i">+            while let Ok(op) = engine.op_rx().try_recv() {
</a><a href="#h1-3-11" id="h1-3-11" class="i">+                match op {
</a><a href="#h1-3-12" id="h1-3-12" class="i">+                    debug::Operation::Delete(key) =&gt; {
</a><a href="#h1-3-13" id="h1-3-13" class="i">+                        let (fkey, _) = debug::format_key_value(&amp;key, &amp;None);
</a><a href="#h1-3-14" id="h1-3-14" class="i">+                        writeln!(f, &quot;    del {fkey}&quot;)
</a><a href="#h1-3-15" id="h1-3-15" class="i">+                    }
</a><a href="#h1-3-16" id="h1-3-16" class="i">+                    debug::Operation::Flush =&gt; writeln!(f, &quot;    flush&quot;),
</a><a href="#h1-3-17" id="h1-3-17" class="i">+                    debug::Operation::Set(key, value) =&gt; {
</a><a href="#h1-3-18" id="h1-3-18" class="i">+                        let (fkey, fvalue) = debug::format_key_value(&amp;key, &amp;Some(value));
</a><a href="#h1-3-19" id="h1-3-19" class="i">+                        writeln!(f, &quot;    set {} = {}&quot;, fkey, fvalue.unwrap())
</a><a href="#h1-3-20" id="h1-3-20" class="i">+                    }
</a><a href="#h1-3-21" id="h1-3-21" class="i">+                }?;
</a>             }
             Ok(())
         }
</pre>
</div>
</body>
</html>
