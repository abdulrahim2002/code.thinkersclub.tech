<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: reorganize execution module - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/62f66d205944667ea930f915c31d156fd2c11745.html">62f66d205944667ea930f915c31d156fd2c11745</a>
<b>parent</b> <a href="../commit/931330396adcb442a70d803fe175e51735fc5130.html">931330396adcb442a70d803fe175e51735fc5130</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 31 May 2020 12:00:03 +0200

sql: reorganize execution module

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/execution/aggregation.rs</a></td><td> | </td><td class="num">3</td><td><span class="i"></span><span class="d">---</span></td></tr>
<tr><td class="D">D</td><td><a href="#h1">src/sql/execution/create_table.rs</a></td><td> | </td><td class="num">23</td><td><span class="i"></span><span class="d">-----------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h2">src/sql/execution/delete.rs</a></td><td> | </td><td class="num">34</td><td><span class="i"></span><span class="d">----------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h3">src/sql/execution/drop_table.rs</a></td><td> | </td><td class="num">22</td><td><span class="i"></span><span class="d">----------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h4">src/sql/execution/filter.rs</a></td><td> | </td><td class="num">45</td><td><span class="i"></span><span class="d">---------------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h5">src/sql/execution/index_lookup.rs</a></td><td> | </td><td class="num">44</td><td><span class="i"></span><span class="d">--------------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h6">src/sql/execution/insert.rs</a></td><td> | </td><td class="num">39</td><td><span class="i"></span><span class="d">---------------------------------------</span></td></tr>
<tr><td class="R">R</td><td><a href="#h7">src/sql/execution/nested_loop_join.rs -&gt; src/sql/execution/join.rs</a></td><td> | </td><td class="num">0</td><td><span class="i"></span><span class="d"></span></td></tr>
<tr><td class="D">D</td><td><a href="#h8">src/sql/execution/key_lookup.rs</a></td><td> | </td><td class="num">36</td><td><span class="i"></span><span class="d">------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h9">src/sql/execution/limit.rs</a></td><td> | </td><td class="num">27</td><td><span class="i"></span><span class="d">---------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/sql/execution/mod.rs</a></td><td> | </td><td class="num">44</td><td><span class="i">++++++++++++</span><span class="d">--------------------------------</span></td></tr>
<tr><td class="A">A</td><td><a href="#h11">src/sql/execution/mutation.rs</a></td><td> | </td><td class="num">118</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="D">D</td><td><a href="#h12">src/sql/execution/nothing.rs</a></td><td> | </td><td class="num">22</td><td><span class="i"></span><span class="d">----------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h13">src/sql/execution/offset.rs</a></td><td> | </td><td class="num">27</td><td><span class="i"></span><span class="d">---------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h14">src/sql/execution/order.rs</a></td><td> | </td><td class="num">66</td><td><span class="i"></span><span class="d">------------------------------------------------------------------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h15">src/sql/execution/projection.rs</a></td><td> | </td><td class="num">49</td><td><span class="i"></span><span class="d">-------------------------------------------------</span></td></tr>
<tr><td class="A">A</td><td><a href="#h16">src/sql/execution/query.rs</a></td><td> | </td><td class="num">191</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="D">D</td><td><a href="#h17">src/sql/execution/scan.rs</a></td><td> | </td><td class="num">26</td><td><span class="i"></span><span class="d">--------------------------</span></td></tr>
<tr><td class="A">A</td><td><a href="#h18">src/sql/execution/schema.rs</a></td><td> | </td><td class="num">40</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h19">src/sql/execution/source.rs</a></td><td> | </td><td class="num">111</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="D">D</td><td><a href="#h20">src/sql/execution/update.rs</a></td><td> | </td><td class="num">60</td><td><span class="i"></span><span class="d">------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h21">src/sql/plan/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h22">src/sql/plan/optimizer.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h23">tests/sql/query/where_index_lookup</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
</table></pre><pre>24 files changed, 475 insertions(+), 558 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/execution/aggregation.rs.html">src/sql/execution/aggregation.rs</a> b/<a href="../file/src/sql/execution/aggregation.rs.html">src/sql/execution/aggregation.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -9,11 +9,8 @@ use std::collections::HashMap;
</a> 
 /// An aggregation executor
 pub struct Aggregation&lt;T: Transaction&gt; {
<a href="#h0-0-3" id="h0-0-3" class="d">-    /// The source of rows to filter
</a>     source: Box&lt;dyn Executor&lt;T&gt;&gt;,
<a href="#h0-0-5" id="h0-0-5" class="d">-    /// Aggregates to apply
</a>     aggregates: Vec&lt;Aggregate&gt;,
<a href="#h0-0-7" id="h0-0-7" class="d">-    /// The bucketed accumulators
</a>     accumulators: HashMap&lt;Vec&lt;Value&gt;, Vec&lt;Box&lt;dyn Accumulator&gt;&gt;&gt;,
 }
 
<b>diff --git a/<a id="h1" href="../file/src/sql/execution/create_table.rs.html">src/sql/execution/create_table.rs</a> b/<a href="../file/src/sql/execution/create_table.rs.html">src/sql/execution/create_table.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,23 +0,0 @@
</a><a href="#h1-0-0" id="h1-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h1-0-1" id="h1-0-1" class="d">-use super::super::schema::Table;
</a><a href="#h1-0-2" id="h1-0-2" class="d">-use super::{Executor, ResultSet};
</a><a href="#h1-0-3" id="h1-0-3" class="d">-use crate::error::Result;
</a><a href="#h1-0-4" id="h1-0-4" class="d">-
</a><a href="#h1-0-5" id="h1-0-5" class="d">-/// A CREATE TABLE executor
</a><a href="#h1-0-6" id="h1-0-6" class="d">-pub struct CreateTable {
</a><a href="#h1-0-7" id="h1-0-7" class="d">-    /// The table schema
</a><a href="#h1-0-8" id="h1-0-8" class="d">-    table: Table,
</a><a href="#h1-0-9" id="h1-0-9" class="d">-}
</a><a href="#h1-0-10" id="h1-0-10" class="d">-
</a><a href="#h1-0-11" id="h1-0-11" class="d">-impl CreateTable {
</a><a href="#h1-0-12" id="h1-0-12" class="d">-    pub fn new(table: Table) -&gt; Box&lt;Self&gt; {
</a><a href="#h1-0-13" id="h1-0-13" class="d">-        Box::new(Self { table })
</a><a href="#h1-0-14" id="h1-0-14" class="d">-    }
</a><a href="#h1-0-15" id="h1-0-15" class="d">-}
</a><a href="#h1-0-16" id="h1-0-16" class="d">-
</a><a href="#h1-0-17" id="h1-0-17" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for CreateTable {
</a><a href="#h1-0-18" id="h1-0-18" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h1-0-19" id="h1-0-19" class="d">-        txn.create_table(&amp;self.table)?;
</a><a href="#h1-0-20" id="h1-0-20" class="d">-        Ok(ResultSet::CreateTable { name: self.table.name })
</a><a href="#h1-0-21" id="h1-0-21" class="d">-    }
</a><a href="#h1-0-22" id="h1-0-22" class="d">-}
</a><b>diff --git a/<a id="h2" href="../file/src/sql/execution/delete.rs.html">src/sql/execution/delete.rs</a> b/<a href="../file/src/sql/execution/delete.rs.html">src/sql/execution/delete.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,34 +0,0 @@
</a><a href="#h2-0-0" id="h2-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h2-0-1" id="h2-0-1" class="d">-use super::{Executor, ResultSet};
</a><a href="#h2-0-2" id="h2-0-2" class="d">-use crate::error::{Error, Result};
</a><a href="#h2-0-3" id="h2-0-3" class="d">-
</a><a href="#h2-0-4" id="h2-0-4" class="d">-/// A DELETE executor
</a><a href="#h2-0-5" id="h2-0-5" class="d">-pub struct Delete&lt;T: Transaction&gt; {
</a><a href="#h2-0-6" id="h2-0-6" class="d">-    /// Table name to delete from
</a><a href="#h2-0-7" id="h2-0-7" class="d">-    table: String,
</a><a href="#h2-0-8" id="h2-0-8" class="d">-    /// Source of rows to delete (must be complete rows from the table)
</a><a href="#h2-0-9" id="h2-0-9" class="d">-    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h2-0-10" id="h2-0-10" class="d">-}
</a><a href="#h2-0-11" id="h2-0-11" class="d">-
</a><a href="#h2-0-12" id="h2-0-12" class="d">-impl&lt;T: Transaction&gt; Delete&lt;T&gt; {
</a><a href="#h2-0-13" id="h2-0-13" class="d">-    pub fn new(table: String, source: Box&lt;dyn Executor&lt;T&gt;&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h2-0-14" id="h2-0-14" class="d">-        Box::new(Self { table, source })
</a><a href="#h2-0-15" id="h2-0-15" class="d">-    }
</a><a href="#h2-0-16" id="h2-0-16" class="d">-}
</a><a href="#h2-0-17" id="h2-0-17" class="d">-
</a><a href="#h2-0-18" id="h2-0-18" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Delete&lt;T&gt; {
</a><a href="#h2-0-19" id="h2-0-19" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h2-0-20" id="h2-0-20" class="d">-        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h2-0-21" id="h2-0-21" class="d">-        let mut count = 0;
</a><a href="#h2-0-22" id="h2-0-22" class="d">-        match self.source.execute(txn)? {
</a><a href="#h2-0-23" id="h2-0-23" class="d">-            ResultSet::Query { mut rows, .. } =&gt; {
</a><a href="#h2-0-24" id="h2-0-24" class="d">-                while let Some(row) = rows.next().transpose()? {
</a><a href="#h2-0-25" id="h2-0-25" class="d">-                    txn.delete(&amp;table.name, &amp;table.get_row_key(&amp;row)?)?;
</a><a href="#h2-0-26" id="h2-0-26" class="d">-                    count += 1
</a><a href="#h2-0-27" id="h2-0-27" class="d">-                }
</a><a href="#h2-0-28" id="h2-0-28" class="d">-                Ok(ResultSet::Delete { count })
</a><a href="#h2-0-29" id="h2-0-29" class="d">-            }
</a><a href="#h2-0-30" id="h2-0-30" class="d">-            r =&gt; Err(Error::Internal(format!(&quot;Unexpected result {:?}&quot;, r))),
</a><a href="#h2-0-31" id="h2-0-31" class="d">-        }
</a><a href="#h2-0-32" id="h2-0-32" class="d">-    }
</a><a href="#h2-0-33" id="h2-0-33" class="d">-}
</a><b>diff --git a/<a id="h3" href="../file/src/sql/execution/drop_table.rs.html">src/sql/execution/drop_table.rs</a> b/<a href="../file/src/sql/execution/drop_table.rs.html">src/sql/execution/drop_table.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,22 +0,0 @@
</a><a href="#h3-0-0" id="h3-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h3-0-1" id="h3-0-1" class="d">-use super::{Executor, ResultSet};
</a><a href="#h3-0-2" id="h3-0-2" class="d">-use crate::error::Result;
</a><a href="#h3-0-3" id="h3-0-3" class="d">-
</a><a href="#h3-0-4" id="h3-0-4" class="d">-/// A DROP TABLE executor
</a><a href="#h3-0-5" id="h3-0-5" class="d">-pub struct DropTable {
</a><a href="#h3-0-6" id="h3-0-6" class="d">-    /// Table name to drop
</a><a href="#h3-0-7" id="h3-0-7" class="d">-    table: String,
</a><a href="#h3-0-8" id="h3-0-8" class="d">-}
</a><a href="#h3-0-9" id="h3-0-9" class="d">-
</a><a href="#h3-0-10" id="h3-0-10" class="d">-impl DropTable {
</a><a href="#h3-0-11" id="h3-0-11" class="d">-    pub fn new(table: String) -&gt; Box&lt;Self&gt; {
</a><a href="#h3-0-12" id="h3-0-12" class="d">-        Box::new(Self { table })
</a><a href="#h3-0-13" id="h3-0-13" class="d">-    }
</a><a href="#h3-0-14" id="h3-0-14" class="d">-}
</a><a href="#h3-0-15" id="h3-0-15" class="d">-
</a><a href="#h3-0-16" id="h3-0-16" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for DropTable {
</a><a href="#h3-0-17" id="h3-0-17" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h3-0-18" id="h3-0-18" class="d">-        txn.delete_table(&amp;self.table)?;
</a><a href="#h3-0-19" id="h3-0-19" class="d">-        Ok(ResultSet::DropTable { name: self.table })
</a><a href="#h3-0-20" id="h3-0-20" class="d">-    }
</a><a href="#h3-0-21" id="h3-0-21" class="d">-}
</a><b>diff --git a/<a id="h4" href="../file/src/sql/execution/filter.rs.html">src/sql/execution/filter.rs</a> b/<a href="../file/src/sql/execution/filter.rs.html">src/sql/execution/filter.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -1,45 +0,0 @@
</a><a href="#h4-0-0" id="h4-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h4-0-1" id="h4-0-1" class="d">-use super::super::types::Expression;
</a><a href="#h4-0-2" id="h4-0-2" class="d">-use super::super::types::Value;
</a><a href="#h4-0-3" id="h4-0-3" class="d">-use super::{Executor, ResultSet};
</a><a href="#h4-0-4" id="h4-0-4" class="d">-use crate::error::{Error, Result};
</a><a href="#h4-0-5" id="h4-0-5" class="d">-
</a><a href="#h4-0-6" id="h4-0-6" class="d">-/// A filter executor
</a><a href="#h4-0-7" id="h4-0-7" class="d">-pub struct Filter&lt;T: Transaction&gt; {
</a><a href="#h4-0-8" id="h4-0-8" class="d">-    /// The source of rows to filter
</a><a href="#h4-0-9" id="h4-0-9" class="d">-    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h4-0-10" id="h4-0-10" class="d">-    /// The predicate to filter by
</a><a href="#h4-0-11" id="h4-0-11" class="d">-    predicate: Expression,
</a><a href="#h4-0-12" id="h4-0-12" class="d">-}
</a><a href="#h4-0-13" id="h4-0-13" class="d">-
</a><a href="#h4-0-14" id="h4-0-14" class="d">-impl&lt;T: Transaction&gt; Filter&lt;T&gt; {
</a><a href="#h4-0-15" id="h4-0-15" class="d">-    pub fn new(source: Box&lt;dyn Executor&lt;T&gt;&gt;, predicate: Expression) -&gt; Box&lt;Self&gt; {
</a><a href="#h4-0-16" id="h4-0-16" class="d">-        Box::new(Self { source, predicate })
</a><a href="#h4-0-17" id="h4-0-17" class="d">-    }
</a><a href="#h4-0-18" id="h4-0-18" class="d">-}
</a><a href="#h4-0-19" id="h4-0-19" class="d">-
</a><a href="#h4-0-20" id="h4-0-20" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Filter&lt;T&gt; {
</a><a href="#h4-0-21" id="h4-0-21" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h4-0-22" id="h4-0-22" class="d">-        let result = self.source.execute(txn)?;
</a><a href="#h4-0-23" id="h4-0-23" class="d">-        if let ResultSet::Query { columns, rows } = result {
</a><a href="#h4-0-24" id="h4-0-24" class="d">-            let predicate = self.predicate;
</a><a href="#h4-0-25" id="h4-0-25" class="d">-            Ok(ResultSet::Query {
</a><a href="#h4-0-26" id="h4-0-26" class="d">-                columns,
</a><a href="#h4-0-27" id="h4-0-27" class="d">-                rows: Box::new(rows.filter_map(move |r| {
</a><a href="#h4-0-28" id="h4-0-28" class="d">-                    r.and_then(|row| match predicate.evaluate(Some(&amp;row))? {
</a><a href="#h4-0-29" id="h4-0-29" class="d">-                        Value::Boolean(true) =&gt; Ok(Some(row)),
</a><a href="#h4-0-30" id="h4-0-30" class="d">-                        Value::Boolean(false) =&gt; Ok(None),
</a><a href="#h4-0-31" id="h4-0-31" class="d">-                        Value::Null =&gt; Ok(None),
</a><a href="#h4-0-32" id="h4-0-32" class="d">-                        value =&gt; Err(Error::Value(format!(
</a><a href="#h4-0-33" id="h4-0-33" class="d">-                            &quot;Filter returned {}, expected boolean&quot;,
</a><a href="#h4-0-34" id="h4-0-34" class="d">-                            value
</a><a href="#h4-0-35" id="h4-0-35" class="d">-                        ))),
</a><a href="#h4-0-36" id="h4-0-36" class="d">-                    })
</a><a href="#h4-0-37" id="h4-0-37" class="d">-                    .transpose()
</a><a href="#h4-0-38" id="h4-0-38" class="d">-                })),
</a><a href="#h4-0-39" id="h4-0-39" class="d">-            })
</a><a href="#h4-0-40" id="h4-0-40" class="d">-        } else {
</a><a href="#h4-0-41" id="h4-0-41" class="d">-            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a><a href="#h4-0-42" id="h4-0-42" class="d">-        }
</a><a href="#h4-0-43" id="h4-0-43" class="d">-    }
</a><a href="#h4-0-44" id="h4-0-44" class="d">-}
</a><b>diff --git a/<a id="h5" href="../file/src/sql/execution/index_lookup.rs.html">src/sql/execution/index_lookup.rs</a> b/<a href="../file/src/sql/execution/index_lookup.rs.html">src/sql/execution/index_lookup.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,44 +0,0 @@
</a><a href="#h5-0-0" id="h5-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h5-0-1" id="h5-0-1" class="d">-use super::super::types::{Column, Row, Value};
</a><a href="#h5-0-2" id="h5-0-2" class="d">-use super::{Executor, ResultSet};
</a><a href="#h5-0-3" id="h5-0-3" class="d">-use crate::error::Result;
</a><a href="#h5-0-4" id="h5-0-4" class="d">-
</a><a href="#h5-0-5" id="h5-0-5" class="d">-use std::collections::HashSet;
</a><a href="#h5-0-6" id="h5-0-6" class="d">-
</a><a href="#h5-0-7" id="h5-0-7" class="d">-/// A primary key lookup executor
</a><a href="#h5-0-8" id="h5-0-8" class="d">-pub struct IndexLookup {
</a><a href="#h5-0-9" id="h5-0-9" class="d">-    /// The table to look up
</a><a href="#h5-0-10" id="h5-0-10" class="d">-    table: String,
</a><a href="#h5-0-11" id="h5-0-11" class="d">-    /// The column index to use
</a><a href="#h5-0-12" id="h5-0-12" class="d">-    column: String,
</a><a href="#h5-0-13" id="h5-0-13" class="d">-    /// The index values to look up
</a><a href="#h5-0-14" id="h5-0-14" class="d">-    keys: Vec&lt;Value&gt;,
</a><a href="#h5-0-15" id="h5-0-15" class="d">-}
</a><a href="#h5-0-16" id="h5-0-16" class="d">-
</a><a href="#h5-0-17" id="h5-0-17" class="d">-impl IndexLookup {
</a><a href="#h5-0-18" id="h5-0-18" class="d">-    pub fn new(table: String, column: String, keys: Vec&lt;Value&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h5-0-19" id="h5-0-19" class="d">-        Box::new(Self { table, column, keys })
</a><a href="#h5-0-20" id="h5-0-20" class="d">-    }
</a><a href="#h5-0-21" id="h5-0-21" class="d">-}
</a><a href="#h5-0-22" id="h5-0-22" class="d">-
</a><a href="#h5-0-23" id="h5-0-23" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for IndexLookup {
</a><a href="#h5-0-24" id="h5-0-24" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h5-0-25" id="h5-0-25" class="d">-        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h5-0-26" id="h5-0-26" class="d">-
</a><a href="#h5-0-27" id="h5-0-27" class="d">-        let mut pks: HashSet&lt;Value&gt; = HashSet::new();
</a><a href="#h5-0-28" id="h5-0-28" class="d">-        for key in self.keys {
</a><a href="#h5-0-29" id="h5-0-29" class="d">-            pks.extend(txn.read_index(&amp;self.table, &amp;self.column, &amp;key)?);
</a><a href="#h5-0-30" id="h5-0-30" class="d">-        }
</a><a href="#h5-0-31" id="h5-0-31" class="d">-
</a><a href="#h5-0-32" id="h5-0-32" class="d">-        // FIXME Is there a way to pass the txn into an iterator closure instead?
</a><a href="#h5-0-33" id="h5-0-33" class="d">-        let rows = pks
</a><a href="#h5-0-34" id="h5-0-34" class="d">-            .into_iter()
</a><a href="#h5-0-35" id="h5-0-35" class="d">-            .filter_map(|pk| txn.read(&amp;table.name, &amp;pk).transpose())
</a><a href="#h5-0-36" id="h5-0-36" class="d">-            .collect::&lt;Result&lt;Vec&lt;Row&gt;&gt;&gt;()?;
</a><a href="#h5-0-37" id="h5-0-37" class="d">-
</a><a href="#h5-0-38" id="h5-0-38" class="d">-        Ok(ResultSet::Query {
</a><a href="#h5-0-39" id="h5-0-39" class="d">-            columns: table.columns.iter().map(|c| Column { name: Some(c.name.clone()) }).collect(),
</a><a href="#h5-0-40" id="h5-0-40" class="d">-            rows: Box::new(rows.into_iter().map(Ok)),
</a><a href="#h5-0-41" id="h5-0-41" class="d">-        })
</a><a href="#h5-0-42" id="h5-0-42" class="d">-    }
</a><a href="#h5-0-43" id="h5-0-43" class="d">-}
</a><b>diff --git a/<a id="h6" href="../file/src/sql/execution/insert.rs.html">src/sql/execution/insert.rs</a> b/<a href="../file/src/sql/execution/insert.rs.html">src/sql/execution/insert.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,39 +0,0 @@
</a><a href="#h6-0-0" id="h6-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h6-0-1" id="h6-0-1" class="d">-use super::super::types::Expression;
</a><a href="#h6-0-2" id="h6-0-2" class="d">-use super::{Executor, ResultSet};
</a><a href="#h6-0-3" id="h6-0-3" class="d">-use crate::error::Result;
</a><a href="#h6-0-4" id="h6-0-4" class="d">-
</a><a href="#h6-0-5" id="h6-0-5" class="d">-/// An INSERT executor
</a><a href="#h6-0-6" id="h6-0-6" class="d">-pub struct Insert {
</a><a href="#h6-0-7" id="h6-0-7" class="d">-    /// The table to insert into
</a><a href="#h6-0-8" id="h6-0-8" class="d">-    table: String,
</a><a href="#h6-0-9" id="h6-0-9" class="d">-    /// The columns to insert into
</a><a href="#h6-0-10" id="h6-0-10" class="d">-    columns: Vec&lt;String&gt;,
</a><a href="#h6-0-11" id="h6-0-11" class="d">-    /// The row expressions to insert
</a><a href="#h6-0-12" id="h6-0-12" class="d">-    rows: Vec&lt;Vec&lt;Expression&gt;&gt;,
</a><a href="#h6-0-13" id="h6-0-13" class="d">-}
</a><a href="#h6-0-14" id="h6-0-14" class="d">-
</a><a href="#h6-0-15" id="h6-0-15" class="d">-impl Insert {
</a><a href="#h6-0-16" id="h6-0-16" class="d">-    pub fn new(table: String, columns: Vec&lt;String&gt;, rows: Vec&lt;Vec&lt;Expression&gt;&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h6-0-17" id="h6-0-17" class="d">-        Box::new(Self { table, columns, rows })
</a><a href="#h6-0-18" id="h6-0-18" class="d">-    }
</a><a href="#h6-0-19" id="h6-0-19" class="d">-}
</a><a href="#h6-0-20" id="h6-0-20" class="d">-
</a><a href="#h6-0-21" id="h6-0-21" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Insert {
</a><a href="#h6-0-22" id="h6-0-22" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h6-0-23" id="h6-0-23" class="d">-        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h6-0-24" id="h6-0-24" class="d">-        let mut count = 0;
</a><a href="#h6-0-25" id="h6-0-25" class="d">-        for expressions in self.rows {
</a><a href="#h6-0-26" id="h6-0-26" class="d">-            let mut row =
</a><a href="#h6-0-27" id="h6-0-27" class="d">-                expressions.into_iter().map(|expr| expr.evaluate(None)).collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h6-0-28" id="h6-0-28" class="d">-            if self.columns.is_empty() {
</a><a href="#h6-0-29" id="h6-0-29" class="d">-                row = table.pad_row(row)?;
</a><a href="#h6-0-30" id="h6-0-30" class="d">-            } else {
</a><a href="#h6-0-31" id="h6-0-31" class="d">-                row = table.make_row(&amp;self.columns, row)?;
</a><a href="#h6-0-32" id="h6-0-32" class="d">-            }
</a><a href="#h6-0-33" id="h6-0-33" class="d">-            txn.create(&amp;table.name, row)?;
</a><a href="#h6-0-34" id="h6-0-34" class="d">-            count += 1;
</a><a href="#h6-0-35" id="h6-0-35" class="d">-        }
</a><a href="#h6-0-36" id="h6-0-36" class="d">-        Ok(ResultSet::Create { count })
</a><a href="#h6-0-37" id="h6-0-37" class="d">-    }
</a><a href="#h6-0-38" id="h6-0-38" class="d">-}
</a><b>diff --git a/<a id="h7" href="../file/src/sql/execution/nested_loop_join.rs.html">src/sql/execution/nested_loop_join.rs</a> b/<a href="../file/src/sql/execution/join.rs.html">src/sql/execution/join.rs</a></b>
<b>diff --git a/<a id="h8" href="../file/src/sql/execution/key_lookup.rs.html">src/sql/execution/key_lookup.rs</a> b/<a href="../file/src/sql/execution/key_lookup.rs.html">src/sql/execution/key_lookup.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -1,36 +0,0 @@
</a><a href="#h8-0-0" id="h8-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h8-0-1" id="h8-0-1" class="d">-use super::super::types::{Column, Row, Value};
</a><a href="#h8-0-2" id="h8-0-2" class="d">-use super::{Executor, ResultSet};
</a><a href="#h8-0-3" id="h8-0-3" class="d">-use crate::error::Result;
</a><a href="#h8-0-4" id="h8-0-4" class="d">-
</a><a href="#h8-0-5" id="h8-0-5" class="d">-/// A primary key lookup executor
</a><a href="#h8-0-6" id="h8-0-6" class="d">-pub struct KeyLookup {
</a><a href="#h8-0-7" id="h8-0-7" class="d">-    /// The table to look up
</a><a href="#h8-0-8" id="h8-0-8" class="d">-    table: String,
</a><a href="#h8-0-9" id="h8-0-9" class="d">-    /// The primary keys to look up
</a><a href="#h8-0-10" id="h8-0-10" class="d">-    keys: Vec&lt;Value&gt;,
</a><a href="#h8-0-11" id="h8-0-11" class="d">-}
</a><a href="#h8-0-12" id="h8-0-12" class="d">-
</a><a href="#h8-0-13" id="h8-0-13" class="d">-impl KeyLookup {
</a><a href="#h8-0-14" id="h8-0-14" class="d">-    pub fn new(table: String, keys: Vec&lt;Value&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h8-0-15" id="h8-0-15" class="d">-        Box::new(Self { table, keys })
</a><a href="#h8-0-16" id="h8-0-16" class="d">-    }
</a><a href="#h8-0-17" id="h8-0-17" class="d">-}
</a><a href="#h8-0-18" id="h8-0-18" class="d">-
</a><a href="#h8-0-19" id="h8-0-19" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for KeyLookup {
</a><a href="#h8-0-20" id="h8-0-20" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h8-0-21" id="h8-0-21" class="d">-        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h8-0-22" id="h8-0-22" class="d">-
</a><a href="#h8-0-23" id="h8-0-23" class="d">-        // FIXME Is there a way to pass the txn into an iterator closure instead?
</a><a href="#h8-0-24" id="h8-0-24" class="d">-        let rows = self
</a><a href="#h8-0-25" id="h8-0-25" class="d">-            .keys
</a><a href="#h8-0-26" id="h8-0-26" class="d">-            .into_iter()
</a><a href="#h8-0-27" id="h8-0-27" class="d">-            .filter_map(|key| txn.read(&amp;table.name, &amp;key).transpose())
</a><a href="#h8-0-28" id="h8-0-28" class="d">-            .collect::&lt;Result&lt;Vec&lt;Row&gt;&gt;&gt;()?;
</a><a href="#h8-0-29" id="h8-0-29" class="d">-
</a><a href="#h8-0-30" id="h8-0-30" class="d">-        Ok(ResultSet::Query {
</a><a href="#h8-0-31" id="h8-0-31" class="d">-            columns: table.columns.iter().map(|c| Column { name: Some(c.name.clone()) }).collect(),
</a><a href="#h8-0-32" id="h8-0-32" class="d">-            rows: Box::new(rows.into_iter().map(Ok)),
</a><a href="#h8-0-33" id="h8-0-33" class="d">-        })
</a><a href="#h8-0-34" id="h8-0-34" class="d">-    }
</a><a href="#h8-0-35" id="h8-0-35" class="d">-}
</a><b>diff --git a/<a id="h9" href="../file/src/sql/execution/limit.rs.html">src/sql/execution/limit.rs</a> b/<a href="../file/src/sql/execution/limit.rs.html">src/sql/execution/limit.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,27 +0,0 @@
</a><a href="#h9-0-0" id="h9-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h9-0-1" id="h9-0-1" class="d">-use super::{Executor, ResultSet};
</a><a href="#h9-0-2" id="h9-0-2" class="d">-use crate::error::{Error, Result};
</a><a href="#h9-0-3" id="h9-0-3" class="d">-
</a><a href="#h9-0-4" id="h9-0-4" class="d">-/// A LIMIT executor
</a><a href="#h9-0-5" id="h9-0-5" class="d">-pub struct Limit&lt;T: Transaction&gt; {
</a><a href="#h9-0-6" id="h9-0-6" class="d">-    /// The source of rows to limit
</a><a href="#h9-0-7" id="h9-0-7" class="d">-    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h9-0-8" id="h9-0-8" class="d">-    /// The number of rows to limit results to
</a><a href="#h9-0-9" id="h9-0-9" class="d">-    limit: u64,
</a><a href="#h9-0-10" id="h9-0-10" class="d">-}
</a><a href="#h9-0-11" id="h9-0-11" class="d">-
</a><a href="#h9-0-12" id="h9-0-12" class="d">-impl&lt;T: Transaction&gt; Limit&lt;T&gt; {
</a><a href="#h9-0-13" id="h9-0-13" class="d">-    pub fn new(source: Box&lt;dyn Executor&lt;T&gt;&gt;, limit: u64) -&gt; Box&lt;Self&gt; {
</a><a href="#h9-0-14" id="h9-0-14" class="d">-        Box::new(Self { source, limit })
</a><a href="#h9-0-15" id="h9-0-15" class="d">-    }
</a><a href="#h9-0-16" id="h9-0-16" class="d">-}
</a><a href="#h9-0-17" id="h9-0-17" class="d">-
</a><a href="#h9-0-18" id="h9-0-18" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Limit&lt;T&gt; {
</a><a href="#h9-0-19" id="h9-0-19" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h9-0-20" id="h9-0-20" class="d">-        if let ResultSet::Query { columns, rows } = self.source.execute(txn)? {
</a><a href="#h9-0-21" id="h9-0-21" class="d">-            Ok(ResultSet::Query { columns, rows: Box::new(rows.take(self.limit as usize)) })
</a><a href="#h9-0-22" id="h9-0-22" class="d">-        } else {
</a><a href="#h9-0-23" id="h9-0-23" class="d">-            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a><a href="#h9-0-24" id="h9-0-24" class="d">-        }
</a><a href="#h9-0-25" id="h9-0-25" class="d">-    }
</a><a href="#h9-0-26" id="h9-0-26" class="d">-}
</a><b>diff --git a/<a id="h10" href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a> b/<a href="../file/src/sql/execution/mod.rs.html">src/sql/execution/mod.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -1,36 +1,16 @@
</a> mod aggregation;
<a href="#h10-0-1" id="h10-0-1" class="d">-mod create_table;
</a><a href="#h10-0-2" id="h10-0-2" class="d">-mod delete;
</a><a href="#h10-0-3" id="h10-0-3" class="d">-mod drop_table;
</a><a href="#h10-0-4" id="h10-0-4" class="d">-mod filter;
</a><a href="#h10-0-5" id="h10-0-5" class="d">-mod index_lookup;
</a><a href="#h10-0-6" id="h10-0-6" class="d">-mod insert;
</a><a href="#h10-0-7" id="h10-0-7" class="d">-mod key_lookup;
</a><a href="#h10-0-8" id="h10-0-8" class="d">-mod limit;
</a><a href="#h10-0-9" id="h10-0-9" class="d">-mod nested_loop_join;
</a><a href="#h10-0-10" id="h10-0-10" class="d">-mod nothing;
</a><a href="#h10-0-11" id="h10-0-11" class="d">-mod offset;
</a><a href="#h10-0-12" id="h10-0-12" class="d">-mod order;
</a><a href="#h10-0-13" id="h10-0-13" class="d">-mod projection;
</a><a href="#h10-0-14" id="h10-0-14" class="d">-mod scan;
</a><a href="#h10-0-15" id="h10-0-15" class="d">-mod update;
</a><a href="#h10-0-16" id="h10-0-16" class="i">+mod join;
</a><a href="#h10-0-17" id="h10-0-17" class="i">+mod mutation;
</a><a href="#h10-0-18" id="h10-0-18" class="i">+mod query;
</a><a href="#h10-0-19" id="h10-0-19" class="i">+mod schema;
</a><a href="#h10-0-20" id="h10-0-20" class="i">+mod source;
</a> 
 use aggregation::Aggregation;
<a href="#h10-0-23" id="h10-0-23" class="d">-use create_table::CreateTable;
</a><a href="#h10-0-24" id="h10-0-24" class="d">-use delete::Delete;
</a><a href="#h10-0-25" id="h10-0-25" class="d">-use drop_table::DropTable;
</a><a href="#h10-0-26" id="h10-0-26" class="d">-use filter::Filter;
</a><a href="#h10-0-27" id="h10-0-27" class="d">-use index_lookup::IndexLookup;
</a><a href="#h10-0-28" id="h10-0-28" class="d">-use insert::Insert;
</a><a href="#h10-0-29" id="h10-0-29" class="d">-use key_lookup::KeyLookup;
</a><a href="#h10-0-30" id="h10-0-30" class="d">-use limit::Limit;
</a><a href="#h10-0-31" id="h10-0-31" class="d">-use nested_loop_join::NestedLoopJoin;
</a><a href="#h10-0-32" id="h10-0-32" class="d">-use nothing::Nothing;
</a><a href="#h10-0-33" id="h10-0-33" class="d">-use offset::Offset;
</a><a href="#h10-0-34" id="h10-0-34" class="d">-use order::Order;
</a><a href="#h10-0-35" id="h10-0-35" class="d">-use projection::Projection;
</a><a href="#h10-0-36" id="h10-0-36" class="d">-use scan::Scan;
</a><a href="#h10-0-37" id="h10-0-37" class="d">-use update::Update;
</a><a href="#h10-0-38" id="h10-0-38" class="i">+use join::NestedLoopJoin;
</a><a href="#h10-0-39" id="h10-0-39" class="i">+use mutation::{Delete, Insert, Update};
</a><a href="#h10-0-40" id="h10-0-40" class="i">+use query::{Filter, Limit, Offset, Order, Projection};
</a><a href="#h10-0-41" id="h10-0-41" class="i">+use schema::{CreateTable, DropTable};
</a><a href="#h10-0-42" id="h10-0-42" class="i">+use source::{IndexLookup, KeyLookup, Nothing, Scan};
</a> 
 use super::engine::{Mode, Transaction};
 use super::plan::Node;
<a href="#h10-1" id="h10-1" class="h">@@ -57,8 +37,8 @@ impl&lt;T: Transaction + &#39;static&gt; dyn Executor&lt;T&gt; {
</a>             Node::Delete { table, source } =&gt; Delete::new(table, Self::build(*source)),
             Node::DropTable { table } =&gt; DropTable::new(table),
             Node::Filter { source, predicate } =&gt; Filter::new(Self::build(*source), predicate),
<a href="#h10-1-3" id="h10-1-3" class="d">-            Node::IndexLookup { table, alias: _, column, keys } =&gt; {
</a><a href="#h10-1-4" id="h10-1-4" class="d">-                IndexLookup::new(table, column, keys)
</a><a href="#h10-1-5" id="h10-1-5" class="i">+            Node::IndexLookup { table, alias: _, column, values } =&gt; {
</a><a href="#h10-1-6" id="h10-1-6" class="i">+                IndexLookup::new(table, column, values)
</a>             }
             Node::Insert { table, columns, expressions } =&gt; {
                 Insert::new(table, columns, expressions)
<b>diff --git a/<a id="h11" href="../file/src/sql/execution/mutation.rs.html">src/sql/execution/mutation.rs</a> b/<a href="../file/src/sql/execution/mutation.rs.html">src/sql/execution/mutation.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -0,0 +1,118 @@
</a><a href="#h11-0-0" id="h11-0-0" class="i">+use super::super::engine::Transaction;
</a><a href="#h11-0-1" id="h11-0-1" class="i">+use super::super::types::Expression;
</a><a href="#h11-0-2" id="h11-0-2" class="i">+use super::{Executor, ResultSet};
</a><a href="#h11-0-3" id="h11-0-3" class="i">+use crate::error::{Error, Result};
</a><a href="#h11-0-4" id="h11-0-4" class="i">+
</a><a href="#h11-0-5" id="h11-0-5" class="i">+/// An INSERT executor
</a><a href="#h11-0-6" id="h11-0-6" class="i">+pub struct Insert {
</a><a href="#h11-0-7" id="h11-0-7" class="i">+    table: String,
</a><a href="#h11-0-8" id="h11-0-8" class="i">+    columns: Vec&lt;String&gt;,
</a><a href="#h11-0-9" id="h11-0-9" class="i">+    rows: Vec&lt;Vec&lt;Expression&gt;&gt;,
</a><a href="#h11-0-10" id="h11-0-10" class="i">+}
</a><a href="#h11-0-11" id="h11-0-11" class="i">+
</a><a href="#h11-0-12" id="h11-0-12" class="i">+impl Insert {
</a><a href="#h11-0-13" id="h11-0-13" class="i">+    pub fn new(table: String, columns: Vec&lt;String&gt;, rows: Vec&lt;Vec&lt;Expression&gt;&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h11-0-14" id="h11-0-14" class="i">+        Box::new(Self { table, columns, rows })
</a><a href="#h11-0-15" id="h11-0-15" class="i">+    }
</a><a href="#h11-0-16" id="h11-0-16" class="i">+}
</a><a href="#h11-0-17" id="h11-0-17" class="i">+
</a><a href="#h11-0-18" id="h11-0-18" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Insert {
</a><a href="#h11-0-19" id="h11-0-19" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h11-0-20" id="h11-0-20" class="i">+        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h11-0-21" id="h11-0-21" class="i">+        let mut count = 0;
</a><a href="#h11-0-22" id="h11-0-22" class="i">+        for expressions in self.rows {
</a><a href="#h11-0-23" id="h11-0-23" class="i">+            let mut row =
</a><a href="#h11-0-24" id="h11-0-24" class="i">+                expressions.into_iter().map(|expr| expr.evaluate(None)).collect::&lt;Result&lt;_&gt;&gt;()?;
</a><a href="#h11-0-25" id="h11-0-25" class="i">+            if self.columns.is_empty() {
</a><a href="#h11-0-26" id="h11-0-26" class="i">+                row = table.pad_row(row)?;
</a><a href="#h11-0-27" id="h11-0-27" class="i">+            } else {
</a><a href="#h11-0-28" id="h11-0-28" class="i">+                row = table.make_row(&amp;self.columns, row)?;
</a><a href="#h11-0-29" id="h11-0-29" class="i">+            }
</a><a href="#h11-0-30" id="h11-0-30" class="i">+            txn.create(&amp;table.name, row)?;
</a><a href="#h11-0-31" id="h11-0-31" class="i">+            count += 1;
</a><a href="#h11-0-32" id="h11-0-32" class="i">+        }
</a><a href="#h11-0-33" id="h11-0-33" class="i">+        Ok(ResultSet::Create { count })
</a><a href="#h11-0-34" id="h11-0-34" class="i">+    }
</a><a href="#h11-0-35" id="h11-0-35" class="i">+}
</a><a href="#h11-0-36" id="h11-0-36" class="i">+
</a><a href="#h11-0-37" id="h11-0-37" class="i">+use std::collections::{BTreeMap, HashSet};
</a><a href="#h11-0-38" id="h11-0-38" class="i">+
</a><a href="#h11-0-39" id="h11-0-39" class="i">+/// An UPDATE executor
</a><a href="#h11-0-40" id="h11-0-40" class="i">+pub struct Update&lt;T: Transaction&gt; {
</a><a href="#h11-0-41" id="h11-0-41" class="i">+    table: String,
</a><a href="#h11-0-42" id="h11-0-42" class="i">+    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h11-0-43" id="h11-0-43" class="i">+    /// FIXME Uses BTreeMap instead of HashMap for test stability
</a><a href="#h11-0-44" id="h11-0-44" class="i">+    expressions: BTreeMap&lt;String, Expression&gt;,
</a><a href="#h11-0-45" id="h11-0-45" class="i">+}
</a><a href="#h11-0-46" id="h11-0-46" class="i">+
</a><a href="#h11-0-47" id="h11-0-47" class="i">+impl&lt;T: Transaction&gt; Update&lt;T&gt; {
</a><a href="#h11-0-48" id="h11-0-48" class="i">+    pub fn new(
</a><a href="#h11-0-49" id="h11-0-49" class="i">+        table: String,
</a><a href="#h11-0-50" id="h11-0-50" class="i">+        source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h11-0-51" id="h11-0-51" class="i">+        expressions: BTreeMap&lt;String, Expression&gt;,
</a><a href="#h11-0-52" id="h11-0-52" class="i">+    ) -&gt; Box&lt;Self&gt; {
</a><a href="#h11-0-53" id="h11-0-53" class="i">+        Box::new(Self { table, source, expressions })
</a><a href="#h11-0-54" id="h11-0-54" class="i">+    }
</a><a href="#h11-0-55" id="h11-0-55" class="i">+}
</a><a href="#h11-0-56" id="h11-0-56" class="i">+
</a><a href="#h11-0-57" id="h11-0-57" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Update&lt;T&gt; {
</a><a href="#h11-0-58" id="h11-0-58" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h11-0-59" id="h11-0-59" class="i">+        match self.source.execute(txn)? {
</a><a href="#h11-0-60" id="h11-0-60" class="i">+            ResultSet::Query { mut rows, .. } =&gt; {
</a><a href="#h11-0-61" id="h11-0-61" class="i">+                let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h11-0-62" id="h11-0-62" class="i">+
</a><a href="#h11-0-63" id="h11-0-63" class="i">+                // The iterator will see our changes, such that the same item may be iterated over
</a><a href="#h11-0-64" id="h11-0-64" class="i">+                // multiple times. We keep track of the primary keys here to avoid that, althought
</a><a href="#h11-0-65" id="h11-0-65" class="i">+                // it may cause ballooning memory usage for large updates.
</a><a href="#h11-0-66" id="h11-0-66" class="i">+                //
</a><a href="#h11-0-67" id="h11-0-67" class="i">+                // FIXME This is not safe for primary key updates, which may still be processed
</a><a href="#h11-0-68" id="h11-0-68" class="i">+                // multiple times - it should be possible to come up with a pathological case that
</a><a href="#h11-0-69" id="h11-0-69" class="i">+                // loops forever (e.g. UPDATE test SET id = id + 1).
</a><a href="#h11-0-70" id="h11-0-70" class="i">+                let mut updated = HashSet::new();
</a><a href="#h11-0-71" id="h11-0-71" class="i">+                while let Some(row) = rows.next().transpose()? {
</a><a href="#h11-0-72" id="h11-0-72" class="i">+                    let id = table.get_row_key(&amp;row)?;
</a><a href="#h11-0-73" id="h11-0-73" class="i">+                    if updated.contains(&amp;id) {
</a><a href="#h11-0-74" id="h11-0-74" class="i">+                        continue;
</a><a href="#h11-0-75" id="h11-0-75" class="i">+                    }
</a><a href="#h11-0-76" id="h11-0-76" class="i">+                    let mut new = row.clone();
</a><a href="#h11-0-77" id="h11-0-77" class="i">+                    for (field, expr) in &amp;self.expressions {
</a><a href="#h11-0-78" id="h11-0-78" class="i">+                        table.set_row_field(&amp;mut new, field, expr.evaluate(Some(&amp;row))?)?;
</a><a href="#h11-0-79" id="h11-0-79" class="i">+                    }
</a><a href="#h11-0-80" id="h11-0-80" class="i">+                    txn.update(&amp;table.name, &amp;id, new)?;
</a><a href="#h11-0-81" id="h11-0-81" class="i">+                    updated.insert(id);
</a><a href="#h11-0-82" id="h11-0-82" class="i">+                }
</a><a href="#h11-0-83" id="h11-0-83" class="i">+                Ok(ResultSet::Update { count: updated.len() as u64 })
</a><a href="#h11-0-84" id="h11-0-84" class="i">+            }
</a><a href="#h11-0-85" id="h11-0-85" class="i">+            r =&gt; Err(Error::Internal(format!(&quot;Unexpected response {:?}&quot;, r))),
</a><a href="#h11-0-86" id="h11-0-86" class="i">+        }
</a><a href="#h11-0-87" id="h11-0-87" class="i">+    }
</a><a href="#h11-0-88" id="h11-0-88" class="i">+}
</a><a href="#h11-0-89" id="h11-0-89" class="i">+
</a><a href="#h11-0-90" id="h11-0-90" class="i">+/// A DELETE executor
</a><a href="#h11-0-91" id="h11-0-91" class="i">+pub struct Delete&lt;T: Transaction&gt; {
</a><a href="#h11-0-92" id="h11-0-92" class="i">+    table: String,
</a><a href="#h11-0-93" id="h11-0-93" class="i">+    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h11-0-94" id="h11-0-94" class="i">+}
</a><a href="#h11-0-95" id="h11-0-95" class="i">+
</a><a href="#h11-0-96" id="h11-0-96" class="i">+impl&lt;T: Transaction&gt; Delete&lt;T&gt; {
</a><a href="#h11-0-97" id="h11-0-97" class="i">+    pub fn new(table: String, source: Box&lt;dyn Executor&lt;T&gt;&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h11-0-98" id="h11-0-98" class="i">+        Box::new(Self { table, source })
</a><a href="#h11-0-99" id="h11-0-99" class="i">+    }
</a><a href="#h11-0-100" id="h11-0-100" class="i">+}
</a><a href="#h11-0-101" id="h11-0-101" class="i">+
</a><a href="#h11-0-102" id="h11-0-102" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Delete&lt;T&gt; {
</a><a href="#h11-0-103" id="h11-0-103" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h11-0-104" id="h11-0-104" class="i">+        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h11-0-105" id="h11-0-105" class="i">+        let mut count = 0;
</a><a href="#h11-0-106" id="h11-0-106" class="i">+        match self.source.execute(txn)? {
</a><a href="#h11-0-107" id="h11-0-107" class="i">+            ResultSet::Query { mut rows, .. } =&gt; {
</a><a href="#h11-0-108" id="h11-0-108" class="i">+                while let Some(row) = rows.next().transpose()? {
</a><a href="#h11-0-109" id="h11-0-109" class="i">+                    txn.delete(&amp;table.name, &amp;table.get_row_key(&amp;row)?)?;
</a><a href="#h11-0-110" id="h11-0-110" class="i">+                    count += 1
</a><a href="#h11-0-111" id="h11-0-111" class="i">+                }
</a><a href="#h11-0-112" id="h11-0-112" class="i">+                Ok(ResultSet::Delete { count })
</a><a href="#h11-0-113" id="h11-0-113" class="i">+            }
</a><a href="#h11-0-114" id="h11-0-114" class="i">+            r =&gt; Err(Error::Internal(format!(&quot;Unexpected result {:?}&quot;, r))),
</a><a href="#h11-0-115" id="h11-0-115" class="i">+        }
</a><a href="#h11-0-116" id="h11-0-116" class="i">+    }
</a><a href="#h11-0-117" id="h11-0-117" class="i">+}
</a><b>diff --git a/<a id="h12" href="../file/src/sql/execution/nothing.rs.html">src/sql/execution/nothing.rs</a> b/<a href="../file/src/sql/execution/nothing.rs.html">src/sql/execution/nothing.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -1,22 +0,0 @@
</a><a href="#h12-0-0" id="h12-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h12-0-1" id="h12-0-1" class="d">-use super::super::types::Row;
</a><a href="#h12-0-2" id="h12-0-2" class="d">-use super::{Executor, ResultSet};
</a><a href="#h12-0-3" id="h12-0-3" class="d">-use crate::error::Result;
</a><a href="#h12-0-4" id="h12-0-4" class="d">-
</a><a href="#h12-0-5" id="h12-0-5" class="d">-/// An executor that produces a single empty row
</a><a href="#h12-0-6" id="h12-0-6" class="d">-pub struct Nothing;
</a><a href="#h12-0-7" id="h12-0-7" class="d">-
</a><a href="#h12-0-8" id="h12-0-8" class="d">-impl Nothing {
</a><a href="#h12-0-9" id="h12-0-9" class="d">-    pub fn new() -&gt; Box&lt;Self&gt; {
</a><a href="#h12-0-10" id="h12-0-10" class="d">-        Box::new(Self)
</a><a href="#h12-0-11" id="h12-0-11" class="d">-    }
</a><a href="#h12-0-12" id="h12-0-12" class="d">-}
</a><a href="#h12-0-13" id="h12-0-13" class="d">-
</a><a href="#h12-0-14" id="h12-0-14" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Nothing {
</a><a href="#h12-0-15" id="h12-0-15" class="d">-    fn execute(self: Box&lt;Self&gt;, _: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h12-0-16" id="h12-0-16" class="d">-        Ok(ResultSet::Query {
</a><a href="#h12-0-17" id="h12-0-17" class="d">-            columns: Vec::new(),
</a><a href="#h12-0-18" id="h12-0-18" class="d">-            rows: Box::new(std::iter::once(Ok(Row::new()))),
</a><a href="#h12-0-19" id="h12-0-19" class="d">-        })
</a><a href="#h12-0-20" id="h12-0-20" class="d">-    }
</a><a href="#h12-0-21" id="h12-0-21" class="d">-}
</a><b>diff --git a/<a id="h13" href="../file/src/sql/execution/offset.rs.html">src/sql/execution/offset.rs</a> b/<a href="../file/src/sql/execution/offset.rs.html">src/sql/execution/offset.rs</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -1,27 +0,0 @@
</a><a href="#h13-0-0" id="h13-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h13-0-1" id="h13-0-1" class="d">-use super::{Executor, ResultSet};
</a><a href="#h13-0-2" id="h13-0-2" class="d">-use crate::error::{Error, Result};
</a><a href="#h13-0-3" id="h13-0-3" class="d">-
</a><a href="#h13-0-4" id="h13-0-4" class="d">-/// An OFFSET executor
</a><a href="#h13-0-5" id="h13-0-5" class="d">-pub struct Offset&lt;T: Transaction&gt; {
</a><a href="#h13-0-6" id="h13-0-6" class="d">-    /// The source of rows to limit
</a><a href="#h13-0-7" id="h13-0-7" class="d">-    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h13-0-8" id="h13-0-8" class="d">-    /// The number of rows to skip
</a><a href="#h13-0-9" id="h13-0-9" class="d">-    offset: u64,
</a><a href="#h13-0-10" id="h13-0-10" class="d">-}
</a><a href="#h13-0-11" id="h13-0-11" class="d">-
</a><a href="#h13-0-12" id="h13-0-12" class="d">-impl&lt;T: Transaction&gt; Offset&lt;T&gt; {
</a><a href="#h13-0-13" id="h13-0-13" class="d">-    pub fn new(source: Box&lt;dyn Executor&lt;T&gt;&gt;, offset: u64) -&gt; Box&lt;Self&gt; {
</a><a href="#h13-0-14" id="h13-0-14" class="d">-        Box::new(Self { source, offset })
</a><a href="#h13-0-15" id="h13-0-15" class="d">-    }
</a><a href="#h13-0-16" id="h13-0-16" class="d">-}
</a><a href="#h13-0-17" id="h13-0-17" class="d">-
</a><a href="#h13-0-18" id="h13-0-18" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Offset&lt;T&gt; {
</a><a href="#h13-0-19" id="h13-0-19" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h13-0-20" id="h13-0-20" class="d">-        if let ResultSet::Query { columns, rows } = self.source.execute(txn)? {
</a><a href="#h13-0-21" id="h13-0-21" class="d">-            Ok(ResultSet::Query { columns, rows: Box::new(rows.skip(self.offset as usize)) })
</a><a href="#h13-0-22" id="h13-0-22" class="d">-        } else {
</a><a href="#h13-0-23" id="h13-0-23" class="d">-            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a><a href="#h13-0-24" id="h13-0-24" class="d">-        }
</a><a href="#h13-0-25" id="h13-0-25" class="d">-    }
</a><a href="#h13-0-26" id="h13-0-26" class="d">-}
</a><b>diff --git a/<a id="h14" href="../file/src/sql/execution/order.rs.html">src/sql/execution/order.rs</a> b/<a href="../file/src/sql/execution/order.rs.html">src/sql/execution/order.rs</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -1,66 +0,0 @@
</a><a href="#h14-0-0" id="h14-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h14-0-1" id="h14-0-1" class="d">-use super::super::plan::Direction;
</a><a href="#h14-0-2" id="h14-0-2" class="d">-use super::super::types::{Expression, Row, Value};
</a><a href="#h14-0-3" id="h14-0-3" class="d">-use super::{Executor, ResultSet};
</a><a href="#h14-0-4" id="h14-0-4" class="d">-use crate::error::{Error, Result};
</a><a href="#h14-0-5" id="h14-0-5" class="d">-
</a><a href="#h14-0-6" id="h14-0-6" class="d">-/// An order executor
</a><a href="#h14-0-7" id="h14-0-7" class="d">-pub struct Order&lt;T: Transaction&gt; {
</a><a href="#h14-0-8" id="h14-0-8" class="d">-    /// The source of rows to filter
</a><a href="#h14-0-9" id="h14-0-9" class="d">-    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h14-0-10" id="h14-0-10" class="d">-    /// The sort orders
</a><a href="#h14-0-11" id="h14-0-11" class="d">-    order: Vec&lt;(Expression, Direction)&gt;,
</a><a href="#h14-0-12" id="h14-0-12" class="d">-}
</a><a href="#h14-0-13" id="h14-0-13" class="d">-
</a><a href="#h14-0-14" id="h14-0-14" class="d">-impl&lt;T: Transaction&gt; Order&lt;T&gt; {
</a><a href="#h14-0-15" id="h14-0-15" class="d">-    pub fn new(source: Box&lt;dyn Executor&lt;T&gt;&gt;, order: Vec&lt;(Expression, Direction)&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h14-0-16" id="h14-0-16" class="d">-        Box::new(Self { source, order })
</a><a href="#h14-0-17" id="h14-0-17" class="d">-    }
</a><a href="#h14-0-18" id="h14-0-18" class="d">-}
</a><a href="#h14-0-19" id="h14-0-19" class="d">-
</a><a href="#h14-0-20" id="h14-0-20" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Order&lt;T&gt; {
</a><a href="#h14-0-21" id="h14-0-21" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h14-0-22" id="h14-0-22" class="d">-        match self.source.execute(txn)? {
</a><a href="#h14-0-23" id="h14-0-23" class="d">-            ResultSet::Query { columns, mut rows } =&gt; {
</a><a href="#h14-0-24" id="h14-0-24" class="d">-                // FIXME Since we can&#39;t return errors from the sort_by closure, we have to
</a><a href="#h14-0-25" id="h14-0-25" class="d">-                // pre-evaluate all values. This means that we can&#39;t short-circuit evaluation,
</a><a href="#h14-0-26" id="h14-0-26" class="d">-                // and have to temporarily store evaluated values, which is bad for performance
</a><a href="#h14-0-27" id="h14-0-27" class="d">-                // and memory usage respectively
</a><a href="#h14-0-28" id="h14-0-28" class="d">-                struct Item {
</a><a href="#h14-0-29" id="h14-0-29" class="d">-                    row: Row,
</a><a href="#h14-0-30" id="h14-0-30" class="d">-                    values: Vec&lt;Value&gt;,
</a><a href="#h14-0-31" id="h14-0-31" class="d">-                };
</a><a href="#h14-0-32" id="h14-0-32" class="d">-                let mut items = Vec::new();
</a><a href="#h14-0-33" id="h14-0-33" class="d">-                while let Some(row) = rows.next().transpose()? {
</a><a href="#h14-0-34" id="h14-0-34" class="d">-                    let mut values = Vec::new();
</a><a href="#h14-0-35" id="h14-0-35" class="d">-                    for (expr, _) in self.order.iter() {
</a><a href="#h14-0-36" id="h14-0-36" class="d">-                        values.push(expr.evaluate(Some(&amp;row))?);
</a><a href="#h14-0-37" id="h14-0-37" class="d">-                    }
</a><a href="#h14-0-38" id="h14-0-38" class="d">-                    items.push(Item { row, values })
</a><a href="#h14-0-39" id="h14-0-39" class="d">-                }
</a><a href="#h14-0-40" id="h14-0-40" class="d">-
</a><a href="#h14-0-41" id="h14-0-41" class="d">-                let order = &amp;self.order;
</a><a href="#h14-0-42" id="h14-0-42" class="d">-                items.sort_by(|a, b| {
</a><a href="#h14-0-43" id="h14-0-43" class="d">-                    for (i, (_, order)) in order.iter().enumerate() {
</a><a href="#h14-0-44" id="h14-0-44" class="d">-                        let value_a = &amp;a.values[i];
</a><a href="#h14-0-45" id="h14-0-45" class="d">-                        let value_b = &amp;b.values[i];
</a><a href="#h14-0-46" id="h14-0-46" class="d">-                        match value_a.partial_cmp(value_b) {
</a><a href="#h14-0-47" id="h14-0-47" class="d">-                            Some(std::cmp::Ordering::Equal) =&gt; {}
</a><a href="#h14-0-48" id="h14-0-48" class="d">-                            Some(o) =&gt; {
</a><a href="#h14-0-49" id="h14-0-49" class="d">-                                return if *order == Direction::Ascending { o } else { o.reverse() }
</a><a href="#h14-0-50" id="h14-0-50" class="d">-                            }
</a><a href="#h14-0-51" id="h14-0-51" class="d">-                            None =&gt; {}
</a><a href="#h14-0-52" id="h14-0-52" class="d">-                        }
</a><a href="#h14-0-53" id="h14-0-53" class="d">-                    }
</a><a href="#h14-0-54" id="h14-0-54" class="d">-                    std::cmp::Ordering::Equal
</a><a href="#h14-0-55" id="h14-0-55" class="d">-                });
</a><a href="#h14-0-56" id="h14-0-56" class="d">-
</a><a href="#h14-0-57" id="h14-0-57" class="d">-                Ok(ResultSet::Query {
</a><a href="#h14-0-58" id="h14-0-58" class="d">-                    columns,
</a><a href="#h14-0-59" id="h14-0-59" class="d">-                    rows: Box::new(items.into_iter().map(|i| Ok(i.row))),
</a><a href="#h14-0-60" id="h14-0-60" class="d">-                })
</a><a href="#h14-0-61" id="h14-0-61" class="d">-            }
</a><a href="#h14-0-62" id="h14-0-62" class="d">-            r =&gt; Err(Error::Internal(format!(&quot;Unexpected result {:?}&quot;, r))),
</a><a href="#h14-0-63" id="h14-0-63" class="d">-        }
</a><a href="#h14-0-64" id="h14-0-64" class="d">-    }
</a><a href="#h14-0-65" id="h14-0-65" class="d">-}
</a><b>diff --git a/<a id="h15" href="../file/src/sql/execution/projection.rs.html">src/sql/execution/projection.rs</a> b/<a href="../file/src/sql/execution/projection.rs.html">src/sql/execution/projection.rs</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -1,49 +0,0 @@
</a><a href="#h15-0-0" id="h15-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h15-0-1" id="h15-0-1" class="d">-use super::super::types::{Column, Expression};
</a><a href="#h15-0-2" id="h15-0-2" class="d">-use super::{Executor, ResultSet};
</a><a href="#h15-0-3" id="h15-0-3" class="d">-use crate::error::{Error, Result};
</a><a href="#h15-0-4" id="h15-0-4" class="d">-
</a><a href="#h15-0-5" id="h15-0-5" class="d">-/// A projection executor
</a><a href="#h15-0-6" id="h15-0-6" class="d">-pub struct Projection&lt;T: Transaction&gt; {
</a><a href="#h15-0-7" id="h15-0-7" class="d">-    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h15-0-8" id="h15-0-8" class="d">-    expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h15-0-9" id="h15-0-9" class="d">-}
</a><a href="#h15-0-10" id="h15-0-10" class="d">-
</a><a href="#h15-0-11" id="h15-0-11" class="d">-impl&lt;T: Transaction&gt; Projection&lt;T&gt; {
</a><a href="#h15-0-12" id="h15-0-12" class="d">-    pub fn new(
</a><a href="#h15-0-13" id="h15-0-13" class="d">-        source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h15-0-14" id="h15-0-14" class="d">-        expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h15-0-15" id="h15-0-15" class="d">-    ) -&gt; Box&lt;Self&gt; {
</a><a href="#h15-0-16" id="h15-0-16" class="d">-        Box::new(Self { source, expressions })
</a><a href="#h15-0-17" id="h15-0-17" class="d">-    }
</a><a href="#h15-0-18" id="h15-0-18" class="d">-}
</a><a href="#h15-0-19" id="h15-0-19" class="d">-
</a><a href="#h15-0-20" id="h15-0-20" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Projection&lt;T&gt; {
</a><a href="#h15-0-21" id="h15-0-21" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h15-0-22" id="h15-0-22" class="d">-        if let ResultSet::Query { columns, rows } = self.source.execute(txn)? {
</a><a href="#h15-0-23" id="h15-0-23" class="d">-            let (expressions, labels): (Vec&lt;Expression&gt;, Vec&lt;Option&lt;String&gt;&gt;) =
</a><a href="#h15-0-24" id="h15-0-24" class="d">-                self.expressions.into_iter().unzip();
</a><a href="#h15-0-25" id="h15-0-25" class="d">-            let columns = expressions
</a><a href="#h15-0-26" id="h15-0-26" class="d">-                .iter()
</a><a href="#h15-0-27" id="h15-0-27" class="d">-                .enumerate()
</a><a href="#h15-0-28" id="h15-0-28" class="d">-                .map(|(i, e)| {
</a><a href="#h15-0-29" id="h15-0-29" class="d">-                    if let Some(Some(label)) = labels.get(i) {
</a><a href="#h15-0-30" id="h15-0-30" class="d">-                        Column { name: Some(label.clone()) }
</a><a href="#h15-0-31" id="h15-0-31" class="d">-                    } else if let Expression::Field(i, _) = e {
</a><a href="#h15-0-32" id="h15-0-32" class="d">-                        columns.get(*i).cloned().unwrap_or(Column { name: None })
</a><a href="#h15-0-33" id="h15-0-33" class="d">-                    } else {
</a><a href="#h15-0-34" id="h15-0-34" class="d">-                        Column { name: None }
</a><a href="#h15-0-35" id="h15-0-35" class="d">-                    }
</a><a href="#h15-0-36" id="h15-0-36" class="d">-                })
</a><a href="#h15-0-37" id="h15-0-37" class="d">-                .collect();
</a><a href="#h15-0-38" id="h15-0-38" class="d">-            let rows = Box::new(rows.map(move |r| {
</a><a href="#h15-0-39" id="h15-0-39" class="d">-                r.and_then(|row| {
</a><a href="#h15-0-40" id="h15-0-40" class="d">-                    Ok(expressions.iter().map(|e| e.evaluate(Some(&amp;row))).collect::&lt;Result&lt;_&gt;&gt;()?)
</a><a href="#h15-0-41" id="h15-0-41" class="d">-                })
</a><a href="#h15-0-42" id="h15-0-42" class="d">-            }));
</a><a href="#h15-0-43" id="h15-0-43" class="d">-            Ok(ResultSet::Query { columns, rows })
</a><a href="#h15-0-44" id="h15-0-44" class="d">-        } else {
</a><a href="#h15-0-45" id="h15-0-45" class="d">-            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a><a href="#h15-0-46" id="h15-0-46" class="d">-        }
</a><a href="#h15-0-47" id="h15-0-47" class="d">-    }
</a><a href="#h15-0-48" id="h15-0-48" class="d">-}
</a><b>diff --git a/<a id="h16" href="../file/src/sql/execution/query.rs.html">src/sql/execution/query.rs</a> b/<a href="../file/src/sql/execution/query.rs.html">src/sql/execution/query.rs</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -0,0 +1,191 @@
</a><a href="#h16-0-0" id="h16-0-0" class="i">+use super::super::engine::Transaction;
</a><a href="#h16-0-1" id="h16-0-1" class="i">+use super::super::plan::Direction;
</a><a href="#h16-0-2" id="h16-0-2" class="i">+use super::super::types::{Column, Expression, Row, Value};
</a><a href="#h16-0-3" id="h16-0-3" class="i">+use super::{Executor, ResultSet};
</a><a href="#h16-0-4" id="h16-0-4" class="i">+use crate::error::{Error, Result};
</a><a href="#h16-0-5" id="h16-0-5" class="i">+
</a><a href="#h16-0-6" id="h16-0-6" class="i">+/// A filter executor
</a><a href="#h16-0-7" id="h16-0-7" class="i">+pub struct Filter&lt;T: Transaction&gt; {
</a><a href="#h16-0-8" id="h16-0-8" class="i">+    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h16-0-9" id="h16-0-9" class="i">+    predicate: Expression,
</a><a href="#h16-0-10" id="h16-0-10" class="i">+}
</a><a href="#h16-0-11" id="h16-0-11" class="i">+
</a><a href="#h16-0-12" id="h16-0-12" class="i">+impl&lt;T: Transaction&gt; Filter&lt;T&gt; {
</a><a href="#h16-0-13" id="h16-0-13" class="i">+    pub fn new(source: Box&lt;dyn Executor&lt;T&gt;&gt;, predicate: Expression) -&gt; Box&lt;Self&gt; {
</a><a href="#h16-0-14" id="h16-0-14" class="i">+        Box::new(Self { source, predicate })
</a><a href="#h16-0-15" id="h16-0-15" class="i">+    }
</a><a href="#h16-0-16" id="h16-0-16" class="i">+}
</a><a href="#h16-0-17" id="h16-0-17" class="i">+
</a><a href="#h16-0-18" id="h16-0-18" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Filter&lt;T&gt; {
</a><a href="#h16-0-19" id="h16-0-19" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h16-0-20" id="h16-0-20" class="i">+        let result = self.source.execute(txn)?;
</a><a href="#h16-0-21" id="h16-0-21" class="i">+        if let ResultSet::Query { columns, rows } = result {
</a><a href="#h16-0-22" id="h16-0-22" class="i">+            let predicate = self.predicate;
</a><a href="#h16-0-23" id="h16-0-23" class="i">+            Ok(ResultSet::Query {
</a><a href="#h16-0-24" id="h16-0-24" class="i">+                columns,
</a><a href="#h16-0-25" id="h16-0-25" class="i">+                rows: Box::new(rows.filter_map(move |r| {
</a><a href="#h16-0-26" id="h16-0-26" class="i">+                    r.and_then(|row| match predicate.evaluate(Some(&amp;row))? {
</a><a href="#h16-0-27" id="h16-0-27" class="i">+                        Value::Boolean(true) =&gt; Ok(Some(row)),
</a><a href="#h16-0-28" id="h16-0-28" class="i">+                        Value::Boolean(false) =&gt; Ok(None),
</a><a href="#h16-0-29" id="h16-0-29" class="i">+                        Value::Null =&gt; Ok(None),
</a><a href="#h16-0-30" id="h16-0-30" class="i">+                        value =&gt; Err(Error::Value(format!(
</a><a href="#h16-0-31" id="h16-0-31" class="i">+                            &quot;Filter returned {}, expected boolean&quot;,
</a><a href="#h16-0-32" id="h16-0-32" class="i">+                            value
</a><a href="#h16-0-33" id="h16-0-33" class="i">+                        ))),
</a><a href="#h16-0-34" id="h16-0-34" class="i">+                    })
</a><a href="#h16-0-35" id="h16-0-35" class="i">+                    .transpose()
</a><a href="#h16-0-36" id="h16-0-36" class="i">+                })),
</a><a href="#h16-0-37" id="h16-0-37" class="i">+            })
</a><a href="#h16-0-38" id="h16-0-38" class="i">+        } else {
</a><a href="#h16-0-39" id="h16-0-39" class="i">+            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a><a href="#h16-0-40" id="h16-0-40" class="i">+        }
</a><a href="#h16-0-41" id="h16-0-41" class="i">+    }
</a><a href="#h16-0-42" id="h16-0-42" class="i">+}
</a><a href="#h16-0-43" id="h16-0-43" class="i">+
</a><a href="#h16-0-44" id="h16-0-44" class="i">+/// A projection executor
</a><a href="#h16-0-45" id="h16-0-45" class="i">+pub struct Projection&lt;T: Transaction&gt; {
</a><a href="#h16-0-46" id="h16-0-46" class="i">+    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h16-0-47" id="h16-0-47" class="i">+    expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h16-0-48" id="h16-0-48" class="i">+}
</a><a href="#h16-0-49" id="h16-0-49" class="i">+
</a><a href="#h16-0-50" id="h16-0-50" class="i">+impl&lt;T: Transaction&gt; Projection&lt;T&gt; {
</a><a href="#h16-0-51" id="h16-0-51" class="i">+    pub fn new(
</a><a href="#h16-0-52" id="h16-0-52" class="i">+        source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h16-0-53" id="h16-0-53" class="i">+        expressions: Vec&lt;(Expression, Option&lt;String&gt;)&gt;,
</a><a href="#h16-0-54" id="h16-0-54" class="i">+    ) -&gt; Box&lt;Self&gt; {
</a><a href="#h16-0-55" id="h16-0-55" class="i">+        Box::new(Self { source, expressions })
</a><a href="#h16-0-56" id="h16-0-56" class="i">+    }
</a><a href="#h16-0-57" id="h16-0-57" class="i">+}
</a><a href="#h16-0-58" id="h16-0-58" class="i">+
</a><a href="#h16-0-59" id="h16-0-59" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Projection&lt;T&gt; {
</a><a href="#h16-0-60" id="h16-0-60" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h16-0-61" id="h16-0-61" class="i">+        if let ResultSet::Query { columns, rows } = self.source.execute(txn)? {
</a><a href="#h16-0-62" id="h16-0-62" class="i">+            let (expressions, labels): (Vec&lt;Expression&gt;, Vec&lt;Option&lt;String&gt;&gt;) =
</a><a href="#h16-0-63" id="h16-0-63" class="i">+                self.expressions.into_iter().unzip();
</a><a href="#h16-0-64" id="h16-0-64" class="i">+            let columns = expressions
</a><a href="#h16-0-65" id="h16-0-65" class="i">+                .iter()
</a><a href="#h16-0-66" id="h16-0-66" class="i">+                .enumerate()
</a><a href="#h16-0-67" id="h16-0-67" class="i">+                .map(|(i, e)| {
</a><a href="#h16-0-68" id="h16-0-68" class="i">+                    if let Some(Some(label)) = labels.get(i) {
</a><a href="#h16-0-69" id="h16-0-69" class="i">+                        Column { name: Some(label.clone()) }
</a><a href="#h16-0-70" id="h16-0-70" class="i">+                    } else if let Expression::Field(i, _) = e {
</a><a href="#h16-0-71" id="h16-0-71" class="i">+                        columns.get(*i).cloned().unwrap_or(Column { name: None })
</a><a href="#h16-0-72" id="h16-0-72" class="i">+                    } else {
</a><a href="#h16-0-73" id="h16-0-73" class="i">+                        Column { name: None }
</a><a href="#h16-0-74" id="h16-0-74" class="i">+                    }
</a><a href="#h16-0-75" id="h16-0-75" class="i">+                })
</a><a href="#h16-0-76" id="h16-0-76" class="i">+                .collect();
</a><a href="#h16-0-77" id="h16-0-77" class="i">+            let rows = Box::new(rows.map(move |r| {
</a><a href="#h16-0-78" id="h16-0-78" class="i">+                r.and_then(|row| {
</a><a href="#h16-0-79" id="h16-0-79" class="i">+                    Ok(expressions.iter().map(|e| e.evaluate(Some(&amp;row))).collect::&lt;Result&lt;_&gt;&gt;()?)
</a><a href="#h16-0-80" id="h16-0-80" class="i">+                })
</a><a href="#h16-0-81" id="h16-0-81" class="i">+            }));
</a><a href="#h16-0-82" id="h16-0-82" class="i">+            Ok(ResultSet::Query { columns, rows })
</a><a href="#h16-0-83" id="h16-0-83" class="i">+        } else {
</a><a href="#h16-0-84" id="h16-0-84" class="i">+            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a><a href="#h16-0-85" id="h16-0-85" class="i">+        }
</a><a href="#h16-0-86" id="h16-0-86" class="i">+    }
</a><a href="#h16-0-87" id="h16-0-87" class="i">+}
</a><a href="#h16-0-88" id="h16-0-88" class="i">+
</a><a href="#h16-0-89" id="h16-0-89" class="i">+/// An ORDER BY executor
</a><a href="#h16-0-90" id="h16-0-90" class="i">+pub struct Order&lt;T: Transaction&gt; {
</a><a href="#h16-0-91" id="h16-0-91" class="i">+    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h16-0-92" id="h16-0-92" class="i">+    order: Vec&lt;(Expression, Direction)&gt;,
</a><a href="#h16-0-93" id="h16-0-93" class="i">+}
</a><a href="#h16-0-94" id="h16-0-94" class="i">+
</a><a href="#h16-0-95" id="h16-0-95" class="i">+impl&lt;T: Transaction&gt; Order&lt;T&gt; {
</a><a href="#h16-0-96" id="h16-0-96" class="i">+    pub fn new(source: Box&lt;dyn Executor&lt;T&gt;&gt;, order: Vec&lt;(Expression, Direction)&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h16-0-97" id="h16-0-97" class="i">+        Box::new(Self { source, order })
</a><a href="#h16-0-98" id="h16-0-98" class="i">+    }
</a><a href="#h16-0-99" id="h16-0-99" class="i">+}
</a><a href="#h16-0-100" id="h16-0-100" class="i">+
</a><a href="#h16-0-101" id="h16-0-101" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Order&lt;T&gt; {
</a><a href="#h16-0-102" id="h16-0-102" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h16-0-103" id="h16-0-103" class="i">+        match self.source.execute(txn)? {
</a><a href="#h16-0-104" id="h16-0-104" class="i">+            ResultSet::Query { columns, mut rows } =&gt; {
</a><a href="#h16-0-105" id="h16-0-105" class="i">+                // FIXME Since we can&#39;t return errors from the sort_by closure, we have to
</a><a href="#h16-0-106" id="h16-0-106" class="i">+                // pre-evaluate all values. This means that we can&#39;t short-circuit evaluation,
</a><a href="#h16-0-107" id="h16-0-107" class="i">+                // and have to temporarily store evaluated values, which is bad for performance
</a><a href="#h16-0-108" id="h16-0-108" class="i">+                // and memory usage respectively
</a><a href="#h16-0-109" id="h16-0-109" class="i">+                struct Item {
</a><a href="#h16-0-110" id="h16-0-110" class="i">+                    row: Row,
</a><a href="#h16-0-111" id="h16-0-111" class="i">+                    values: Vec&lt;Value&gt;,
</a><a href="#h16-0-112" id="h16-0-112" class="i">+                };
</a><a href="#h16-0-113" id="h16-0-113" class="i">+                let mut items = Vec::new();
</a><a href="#h16-0-114" id="h16-0-114" class="i">+                while let Some(row) = rows.next().transpose()? {
</a><a href="#h16-0-115" id="h16-0-115" class="i">+                    let mut values = Vec::new();
</a><a href="#h16-0-116" id="h16-0-116" class="i">+                    for (expr, _) in self.order.iter() {
</a><a href="#h16-0-117" id="h16-0-117" class="i">+                        values.push(expr.evaluate(Some(&amp;row))?);
</a><a href="#h16-0-118" id="h16-0-118" class="i">+                    }
</a><a href="#h16-0-119" id="h16-0-119" class="i">+                    items.push(Item { row, values })
</a><a href="#h16-0-120" id="h16-0-120" class="i">+                }
</a><a href="#h16-0-121" id="h16-0-121" class="i">+
</a><a href="#h16-0-122" id="h16-0-122" class="i">+                let order = &amp;self.order;
</a><a href="#h16-0-123" id="h16-0-123" class="i">+                items.sort_by(|a, b| {
</a><a href="#h16-0-124" id="h16-0-124" class="i">+                    for (i, (_, order)) in order.iter().enumerate() {
</a><a href="#h16-0-125" id="h16-0-125" class="i">+                        let value_a = &amp;a.values[i];
</a><a href="#h16-0-126" id="h16-0-126" class="i">+                        let value_b = &amp;b.values[i];
</a><a href="#h16-0-127" id="h16-0-127" class="i">+                        match value_a.partial_cmp(value_b) {
</a><a href="#h16-0-128" id="h16-0-128" class="i">+                            Some(std::cmp::Ordering::Equal) =&gt; {}
</a><a href="#h16-0-129" id="h16-0-129" class="i">+                            Some(o) =&gt; {
</a><a href="#h16-0-130" id="h16-0-130" class="i">+                                return if *order == Direction::Ascending { o } else { o.reverse() }
</a><a href="#h16-0-131" id="h16-0-131" class="i">+                            }
</a><a href="#h16-0-132" id="h16-0-132" class="i">+                            None =&gt; {}
</a><a href="#h16-0-133" id="h16-0-133" class="i">+                        }
</a><a href="#h16-0-134" id="h16-0-134" class="i">+                    }
</a><a href="#h16-0-135" id="h16-0-135" class="i">+                    std::cmp::Ordering::Equal
</a><a href="#h16-0-136" id="h16-0-136" class="i">+                });
</a><a href="#h16-0-137" id="h16-0-137" class="i">+
</a><a href="#h16-0-138" id="h16-0-138" class="i">+                Ok(ResultSet::Query {
</a><a href="#h16-0-139" id="h16-0-139" class="i">+                    columns,
</a><a href="#h16-0-140" id="h16-0-140" class="i">+                    rows: Box::new(items.into_iter().map(|i| Ok(i.row))),
</a><a href="#h16-0-141" id="h16-0-141" class="i">+                })
</a><a href="#h16-0-142" id="h16-0-142" class="i">+            }
</a><a href="#h16-0-143" id="h16-0-143" class="i">+            r =&gt; Err(Error::Internal(format!(&quot;Unexpected result {:?}&quot;, r))),
</a><a href="#h16-0-144" id="h16-0-144" class="i">+        }
</a><a href="#h16-0-145" id="h16-0-145" class="i">+    }
</a><a href="#h16-0-146" id="h16-0-146" class="i">+}
</a><a href="#h16-0-147" id="h16-0-147" class="i">+
</a><a href="#h16-0-148" id="h16-0-148" class="i">+/// A LIMIT executor
</a><a href="#h16-0-149" id="h16-0-149" class="i">+pub struct Limit&lt;T: Transaction&gt; {
</a><a href="#h16-0-150" id="h16-0-150" class="i">+    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h16-0-151" id="h16-0-151" class="i">+    limit: u64,
</a><a href="#h16-0-152" id="h16-0-152" class="i">+}
</a><a href="#h16-0-153" id="h16-0-153" class="i">+
</a><a href="#h16-0-154" id="h16-0-154" class="i">+impl&lt;T: Transaction&gt; Limit&lt;T&gt; {
</a><a href="#h16-0-155" id="h16-0-155" class="i">+    pub fn new(source: Box&lt;dyn Executor&lt;T&gt;&gt;, limit: u64) -&gt; Box&lt;Self&gt; {
</a><a href="#h16-0-156" id="h16-0-156" class="i">+        Box::new(Self { source, limit })
</a><a href="#h16-0-157" id="h16-0-157" class="i">+    }
</a><a href="#h16-0-158" id="h16-0-158" class="i">+}
</a><a href="#h16-0-159" id="h16-0-159" class="i">+
</a><a href="#h16-0-160" id="h16-0-160" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Limit&lt;T&gt; {
</a><a href="#h16-0-161" id="h16-0-161" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h16-0-162" id="h16-0-162" class="i">+        if let ResultSet::Query { columns, rows } = self.source.execute(txn)? {
</a><a href="#h16-0-163" id="h16-0-163" class="i">+            Ok(ResultSet::Query { columns, rows: Box::new(rows.take(self.limit as usize)) })
</a><a href="#h16-0-164" id="h16-0-164" class="i">+        } else {
</a><a href="#h16-0-165" id="h16-0-165" class="i">+            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a><a href="#h16-0-166" id="h16-0-166" class="i">+        }
</a><a href="#h16-0-167" id="h16-0-167" class="i">+    }
</a><a href="#h16-0-168" id="h16-0-168" class="i">+}
</a><a href="#h16-0-169" id="h16-0-169" class="i">+
</a><a href="#h16-0-170" id="h16-0-170" class="i">+/// An OFFSET executor
</a><a href="#h16-0-171" id="h16-0-171" class="i">+pub struct Offset&lt;T: Transaction&gt; {
</a><a href="#h16-0-172" id="h16-0-172" class="i">+    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h16-0-173" id="h16-0-173" class="i">+    offset: u64,
</a><a href="#h16-0-174" id="h16-0-174" class="i">+}
</a><a href="#h16-0-175" id="h16-0-175" class="i">+
</a><a href="#h16-0-176" id="h16-0-176" class="i">+impl&lt;T: Transaction&gt; Offset&lt;T&gt; {
</a><a href="#h16-0-177" id="h16-0-177" class="i">+    pub fn new(source: Box&lt;dyn Executor&lt;T&gt;&gt;, offset: u64) -&gt; Box&lt;Self&gt; {
</a><a href="#h16-0-178" id="h16-0-178" class="i">+        Box::new(Self { source, offset })
</a><a href="#h16-0-179" id="h16-0-179" class="i">+    }
</a><a href="#h16-0-180" id="h16-0-180" class="i">+}
</a><a href="#h16-0-181" id="h16-0-181" class="i">+
</a><a href="#h16-0-182" id="h16-0-182" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Offset&lt;T&gt; {
</a><a href="#h16-0-183" id="h16-0-183" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h16-0-184" id="h16-0-184" class="i">+        if let ResultSet::Query { columns, rows } = self.source.execute(txn)? {
</a><a href="#h16-0-185" id="h16-0-185" class="i">+            Ok(ResultSet::Query { columns, rows: Box::new(rows.skip(self.offset as usize)) })
</a><a href="#h16-0-186" id="h16-0-186" class="i">+        } else {
</a><a href="#h16-0-187" id="h16-0-187" class="i">+            Err(Error::Internal(&quot;Unexpected result&quot;.into()))
</a><a href="#h16-0-188" id="h16-0-188" class="i">+        }
</a><a href="#h16-0-189" id="h16-0-189" class="i">+    }
</a><a href="#h16-0-190" id="h16-0-190" class="i">+}
</a><b>diff --git a/<a id="h17" href="../file/src/sql/execution/scan.rs.html">src/sql/execution/scan.rs</a> b/<a href="../file/src/sql/execution/scan.rs.html">src/sql/execution/scan.rs</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -1,26 +0,0 @@
</a><a href="#h17-0-0" id="h17-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h17-0-1" id="h17-0-1" class="d">-use super::super::types::{Column, Expression};
</a><a href="#h17-0-2" id="h17-0-2" class="d">-use super::{Executor, ResultSet};
</a><a href="#h17-0-3" id="h17-0-3" class="d">-use crate::error::Result;
</a><a href="#h17-0-4" id="h17-0-4" class="d">-
</a><a href="#h17-0-5" id="h17-0-5" class="d">-/// A table scan executor
</a><a href="#h17-0-6" id="h17-0-6" class="d">-pub struct Scan {
</a><a href="#h17-0-7" id="h17-0-7" class="d">-    table: String,
</a><a href="#h17-0-8" id="h17-0-8" class="d">-    filter: Option&lt;Expression&gt;,
</a><a href="#h17-0-9" id="h17-0-9" class="d">-}
</a><a href="#h17-0-10" id="h17-0-10" class="d">-
</a><a href="#h17-0-11" id="h17-0-11" class="d">-impl Scan {
</a><a href="#h17-0-12" id="h17-0-12" class="d">-    pub fn new(table: String, filter: Option&lt;Expression&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h17-0-13" id="h17-0-13" class="d">-        Box::new(Self { table, filter })
</a><a href="#h17-0-14" id="h17-0-14" class="d">-    }
</a><a href="#h17-0-15" id="h17-0-15" class="d">-}
</a><a href="#h17-0-16" id="h17-0-16" class="d">-
</a><a href="#h17-0-17" id="h17-0-17" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Scan {
</a><a href="#h17-0-18" id="h17-0-18" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h17-0-19" id="h17-0-19" class="d">-        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h17-0-20" id="h17-0-20" class="d">-        Ok(ResultSet::Query {
</a><a href="#h17-0-21" id="h17-0-21" class="d">-            columns: table.columns.iter().map(|c| Column { name: Some(c.name.clone()) }).collect(),
</a><a href="#h17-0-22" id="h17-0-22" class="d">-            rows: Box::new(txn.scan(&amp;table.name, self.filter)?),
</a><a href="#h17-0-23" id="h17-0-23" class="d">-        })
</a><a href="#h17-0-24" id="h17-0-24" class="d">-    }
</a><a href="#h17-0-25" id="h17-0-25" class="d">-}
</a><b>diff --git a/<a id="h18" href="../file/src/sql/execution/schema.rs.html">src/sql/execution/schema.rs</a> b/<a href="../file/src/sql/execution/schema.rs.html">src/sql/execution/schema.rs</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -0,0 +1,40 @@
</a><a href="#h18-0-0" id="h18-0-0" class="i">+use super::super::engine::Transaction;
</a><a href="#h18-0-1" id="h18-0-1" class="i">+use super::super::schema::Table;
</a><a href="#h18-0-2" id="h18-0-2" class="i">+use super::{Executor, ResultSet};
</a><a href="#h18-0-3" id="h18-0-3" class="i">+use crate::error::Result;
</a><a href="#h18-0-4" id="h18-0-4" class="i">+
</a><a href="#h18-0-5" id="h18-0-5" class="i">+/// A CREATE TABLE executor
</a><a href="#h18-0-6" id="h18-0-6" class="i">+pub struct CreateTable {
</a><a href="#h18-0-7" id="h18-0-7" class="i">+    table: Table,
</a><a href="#h18-0-8" id="h18-0-8" class="i">+}
</a><a href="#h18-0-9" id="h18-0-9" class="i">+
</a><a href="#h18-0-10" id="h18-0-10" class="i">+impl CreateTable {
</a><a href="#h18-0-11" id="h18-0-11" class="i">+    pub fn new(table: Table) -&gt; Box&lt;Self&gt; {
</a><a href="#h18-0-12" id="h18-0-12" class="i">+        Box::new(Self { table })
</a><a href="#h18-0-13" id="h18-0-13" class="i">+    }
</a><a href="#h18-0-14" id="h18-0-14" class="i">+}
</a><a href="#h18-0-15" id="h18-0-15" class="i">+
</a><a href="#h18-0-16" id="h18-0-16" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for CreateTable {
</a><a href="#h18-0-17" id="h18-0-17" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h18-0-18" id="h18-0-18" class="i">+        txn.create_table(&amp;self.table)?;
</a><a href="#h18-0-19" id="h18-0-19" class="i">+        Ok(ResultSet::CreateTable { name: self.table.name })
</a><a href="#h18-0-20" id="h18-0-20" class="i">+    }
</a><a href="#h18-0-21" id="h18-0-21" class="i">+}
</a><a href="#h18-0-22" id="h18-0-22" class="i">+
</a><a href="#h18-0-23" id="h18-0-23" class="i">+/// A DROP TABLE executor
</a><a href="#h18-0-24" id="h18-0-24" class="i">+pub struct DropTable {
</a><a href="#h18-0-25" id="h18-0-25" class="i">+    table: String,
</a><a href="#h18-0-26" id="h18-0-26" class="i">+}
</a><a href="#h18-0-27" id="h18-0-27" class="i">+
</a><a href="#h18-0-28" id="h18-0-28" class="i">+impl DropTable {
</a><a href="#h18-0-29" id="h18-0-29" class="i">+    pub fn new(table: String) -&gt; Box&lt;Self&gt; {
</a><a href="#h18-0-30" id="h18-0-30" class="i">+        Box::new(Self { table })
</a><a href="#h18-0-31" id="h18-0-31" class="i">+    }
</a><a href="#h18-0-32" id="h18-0-32" class="i">+}
</a><a href="#h18-0-33" id="h18-0-33" class="i">+
</a><a href="#h18-0-34" id="h18-0-34" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for DropTable {
</a><a href="#h18-0-35" id="h18-0-35" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h18-0-36" id="h18-0-36" class="i">+        txn.delete_table(&amp;self.table)?;
</a><a href="#h18-0-37" id="h18-0-37" class="i">+        Ok(ResultSet::DropTable { name: self.table })
</a><a href="#h18-0-38" id="h18-0-38" class="i">+    }
</a><a href="#h18-0-39" id="h18-0-39" class="i">+}
</a><b>diff --git a/<a id="h19" href="../file/src/sql/execution/source.rs.html">src/sql/execution/source.rs</a> b/<a href="../file/src/sql/execution/source.rs.html">src/sql/execution/source.rs</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -0,0 +1,111 @@
</a><a href="#h19-0-0" id="h19-0-0" class="i">+use super::super::engine::Transaction;
</a><a href="#h19-0-1" id="h19-0-1" class="i">+use super::super::types::{Column, Expression, Row, Value};
</a><a href="#h19-0-2" id="h19-0-2" class="i">+use super::{Executor, ResultSet};
</a><a href="#h19-0-3" id="h19-0-3" class="i">+use crate::error::Result;
</a><a href="#h19-0-4" id="h19-0-4" class="i">+
</a><a href="#h19-0-5" id="h19-0-5" class="i">+use std::collections::HashSet;
</a><a href="#h19-0-6" id="h19-0-6" class="i">+
</a><a href="#h19-0-7" id="h19-0-7" class="i">+/// A table scan executor
</a><a href="#h19-0-8" id="h19-0-8" class="i">+pub struct Scan {
</a><a href="#h19-0-9" id="h19-0-9" class="i">+    table: String,
</a><a href="#h19-0-10" id="h19-0-10" class="i">+    filter: Option&lt;Expression&gt;,
</a><a href="#h19-0-11" id="h19-0-11" class="i">+}
</a><a href="#h19-0-12" id="h19-0-12" class="i">+
</a><a href="#h19-0-13" id="h19-0-13" class="i">+impl Scan {
</a><a href="#h19-0-14" id="h19-0-14" class="i">+    pub fn new(table: String, filter: Option&lt;Expression&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h19-0-15" id="h19-0-15" class="i">+        Box::new(Self { table, filter })
</a><a href="#h19-0-16" id="h19-0-16" class="i">+    }
</a><a href="#h19-0-17" id="h19-0-17" class="i">+}
</a><a href="#h19-0-18" id="h19-0-18" class="i">+
</a><a href="#h19-0-19" id="h19-0-19" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Scan {
</a><a href="#h19-0-20" id="h19-0-20" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h19-0-21" id="h19-0-21" class="i">+        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h19-0-22" id="h19-0-22" class="i">+        Ok(ResultSet::Query {
</a><a href="#h19-0-23" id="h19-0-23" class="i">+            columns: table.columns.iter().map(|c| Column { name: Some(c.name.clone()) }).collect(),
</a><a href="#h19-0-24" id="h19-0-24" class="i">+            rows: Box::new(txn.scan(&amp;table.name, self.filter)?),
</a><a href="#h19-0-25" id="h19-0-25" class="i">+        })
</a><a href="#h19-0-26" id="h19-0-26" class="i">+    }
</a><a href="#h19-0-27" id="h19-0-27" class="i">+}
</a><a href="#h19-0-28" id="h19-0-28" class="i">+
</a><a href="#h19-0-29" id="h19-0-29" class="i">+/// A primary key lookup executor
</a><a href="#h19-0-30" id="h19-0-30" class="i">+pub struct KeyLookup {
</a><a href="#h19-0-31" id="h19-0-31" class="i">+    table: String,
</a><a href="#h19-0-32" id="h19-0-32" class="i">+    keys: Vec&lt;Value&gt;,
</a><a href="#h19-0-33" id="h19-0-33" class="i">+}
</a><a href="#h19-0-34" id="h19-0-34" class="i">+
</a><a href="#h19-0-35" id="h19-0-35" class="i">+impl KeyLookup {
</a><a href="#h19-0-36" id="h19-0-36" class="i">+    pub fn new(table: String, keys: Vec&lt;Value&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h19-0-37" id="h19-0-37" class="i">+        Box::new(Self { table, keys })
</a><a href="#h19-0-38" id="h19-0-38" class="i">+    }
</a><a href="#h19-0-39" id="h19-0-39" class="i">+}
</a><a href="#h19-0-40" id="h19-0-40" class="i">+
</a><a href="#h19-0-41" id="h19-0-41" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for KeyLookup {
</a><a href="#h19-0-42" id="h19-0-42" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h19-0-43" id="h19-0-43" class="i">+        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h19-0-44" id="h19-0-44" class="i">+
</a><a href="#h19-0-45" id="h19-0-45" class="i">+        // FIXME Is there a way to pass the txn into an iterator closure instead?
</a><a href="#h19-0-46" id="h19-0-46" class="i">+        let rows = self
</a><a href="#h19-0-47" id="h19-0-47" class="i">+            .keys
</a><a href="#h19-0-48" id="h19-0-48" class="i">+            .into_iter()
</a><a href="#h19-0-49" id="h19-0-49" class="i">+            .filter_map(|key| txn.read(&amp;table.name, &amp;key).transpose())
</a><a href="#h19-0-50" id="h19-0-50" class="i">+            .collect::&lt;Result&lt;Vec&lt;Row&gt;&gt;&gt;()?;
</a><a href="#h19-0-51" id="h19-0-51" class="i">+
</a><a href="#h19-0-52" id="h19-0-52" class="i">+        Ok(ResultSet::Query {
</a><a href="#h19-0-53" id="h19-0-53" class="i">+            columns: table.columns.iter().map(|c| Column { name: Some(c.name.clone()) }).collect(),
</a><a href="#h19-0-54" id="h19-0-54" class="i">+            rows: Box::new(rows.into_iter().map(Ok)),
</a><a href="#h19-0-55" id="h19-0-55" class="i">+        })
</a><a href="#h19-0-56" id="h19-0-56" class="i">+    }
</a><a href="#h19-0-57" id="h19-0-57" class="i">+}
</a><a href="#h19-0-58" id="h19-0-58" class="i">+
</a><a href="#h19-0-59" id="h19-0-59" class="i">+/// An index value lookup executor
</a><a href="#h19-0-60" id="h19-0-60" class="i">+pub struct IndexLookup {
</a><a href="#h19-0-61" id="h19-0-61" class="i">+    table: String,
</a><a href="#h19-0-62" id="h19-0-62" class="i">+    column: String,
</a><a href="#h19-0-63" id="h19-0-63" class="i">+    values: Vec&lt;Value&gt;,
</a><a href="#h19-0-64" id="h19-0-64" class="i">+}
</a><a href="#h19-0-65" id="h19-0-65" class="i">+
</a><a href="#h19-0-66" id="h19-0-66" class="i">+impl IndexLookup {
</a><a href="#h19-0-67" id="h19-0-67" class="i">+    pub fn new(table: String, column: String, values: Vec&lt;Value&gt;) -&gt; Box&lt;Self&gt; {
</a><a href="#h19-0-68" id="h19-0-68" class="i">+        Box::new(Self { table, column, values })
</a><a href="#h19-0-69" id="h19-0-69" class="i">+    }
</a><a href="#h19-0-70" id="h19-0-70" class="i">+}
</a><a href="#h19-0-71" id="h19-0-71" class="i">+
</a><a href="#h19-0-72" id="h19-0-72" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for IndexLookup {
</a><a href="#h19-0-73" id="h19-0-73" class="i">+    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h19-0-74" id="h19-0-74" class="i">+        let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h19-0-75" id="h19-0-75" class="i">+
</a><a href="#h19-0-76" id="h19-0-76" class="i">+        let mut pks: HashSet&lt;Value&gt; = HashSet::new();
</a><a href="#h19-0-77" id="h19-0-77" class="i">+        for value in self.values {
</a><a href="#h19-0-78" id="h19-0-78" class="i">+            pks.extend(txn.read_index(&amp;self.table, &amp;self.column, &amp;value)?);
</a><a href="#h19-0-79" id="h19-0-79" class="i">+        }
</a><a href="#h19-0-80" id="h19-0-80" class="i">+
</a><a href="#h19-0-81" id="h19-0-81" class="i">+        // FIXME Is there a way to pass the txn into an iterator closure instead?
</a><a href="#h19-0-82" id="h19-0-82" class="i">+        let rows = pks
</a><a href="#h19-0-83" id="h19-0-83" class="i">+            .into_iter()
</a><a href="#h19-0-84" id="h19-0-84" class="i">+            .filter_map(|pk| txn.read(&amp;table.name, &amp;pk).transpose())
</a><a href="#h19-0-85" id="h19-0-85" class="i">+            .collect::&lt;Result&lt;Vec&lt;Row&gt;&gt;&gt;()?;
</a><a href="#h19-0-86" id="h19-0-86" class="i">+
</a><a href="#h19-0-87" id="h19-0-87" class="i">+        Ok(ResultSet::Query {
</a><a href="#h19-0-88" id="h19-0-88" class="i">+            columns: table.columns.iter().map(|c| Column { name: Some(c.name.clone()) }).collect(),
</a><a href="#h19-0-89" id="h19-0-89" class="i">+            rows: Box::new(rows.into_iter().map(Ok)),
</a><a href="#h19-0-90" id="h19-0-90" class="i">+        })
</a><a href="#h19-0-91" id="h19-0-91" class="i">+    }
</a><a href="#h19-0-92" id="h19-0-92" class="i">+}
</a><a href="#h19-0-93" id="h19-0-93" class="i">+
</a><a href="#h19-0-94" id="h19-0-94" class="i">+/// An executor that produces a single empty row
</a><a href="#h19-0-95" id="h19-0-95" class="i">+pub struct Nothing;
</a><a href="#h19-0-96" id="h19-0-96" class="i">+
</a><a href="#h19-0-97" id="h19-0-97" class="i">+impl Nothing {
</a><a href="#h19-0-98" id="h19-0-98" class="i">+    pub fn new() -&gt; Box&lt;Self&gt; {
</a><a href="#h19-0-99" id="h19-0-99" class="i">+        Box::new(Self)
</a><a href="#h19-0-100" id="h19-0-100" class="i">+    }
</a><a href="#h19-0-101" id="h19-0-101" class="i">+}
</a><a href="#h19-0-102" id="h19-0-102" class="i">+
</a><a href="#h19-0-103" id="h19-0-103" class="i">+impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Nothing {
</a><a href="#h19-0-104" id="h19-0-104" class="i">+    fn execute(self: Box&lt;Self&gt;, _: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h19-0-105" id="h19-0-105" class="i">+        Ok(ResultSet::Query {
</a><a href="#h19-0-106" id="h19-0-106" class="i">+            columns: Vec::new(),
</a><a href="#h19-0-107" id="h19-0-107" class="i">+            rows: Box::new(std::iter::once(Ok(Row::new()))),
</a><a href="#h19-0-108" id="h19-0-108" class="i">+        })
</a><a href="#h19-0-109" id="h19-0-109" class="i">+    }
</a><a href="#h19-0-110" id="h19-0-110" class="i">+}
</a><b>diff --git a/<a id="h20" href="../file/src/sql/execution/update.rs.html">src/sql/execution/update.rs</a> b/<a href="../file/src/sql/execution/update.rs.html">src/sql/execution/update.rs</a></b>
<a href="#h20-0" id="h20-0" class="h">@@ -1,60 +0,0 @@
</a><a href="#h20-0-0" id="h20-0-0" class="d">-use super::super::engine::Transaction;
</a><a href="#h20-0-1" id="h20-0-1" class="d">-use super::super::types::Expression;
</a><a href="#h20-0-2" id="h20-0-2" class="d">-use super::{Executor, ResultSet};
</a><a href="#h20-0-3" id="h20-0-3" class="d">-use crate::error::{Error, Result};
</a><a href="#h20-0-4" id="h20-0-4" class="d">-
</a><a href="#h20-0-5" id="h20-0-5" class="d">-use std::collections::{BTreeMap, HashSet};
</a><a href="#h20-0-6" id="h20-0-6" class="d">-
</a><a href="#h20-0-7" id="h20-0-7" class="d">-/// An UPDATE executor
</a><a href="#h20-0-8" id="h20-0-8" class="d">-pub struct Update&lt;T: Transaction&gt; {
</a><a href="#h20-0-9" id="h20-0-9" class="d">-    /// The table to update
</a><a href="#h20-0-10" id="h20-0-10" class="d">-    table: String,
</a><a href="#h20-0-11" id="h20-0-11" class="d">-    /// The source of rows to update
</a><a href="#h20-0-12" id="h20-0-12" class="d">-    source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h20-0-13" id="h20-0-13" class="d">-    /// The expressions to update columns with
</a><a href="#h20-0-14" id="h20-0-14" class="d">-    /// FIXME Uses BTreeMap instead of HashMap for test stability
</a><a href="#h20-0-15" id="h20-0-15" class="d">-    expressions: BTreeMap&lt;String, Expression&gt;,
</a><a href="#h20-0-16" id="h20-0-16" class="d">-}
</a><a href="#h20-0-17" id="h20-0-17" class="d">-
</a><a href="#h20-0-18" id="h20-0-18" class="d">-impl&lt;T: Transaction&gt; Update&lt;T&gt; {
</a><a href="#h20-0-19" id="h20-0-19" class="d">-    pub fn new(
</a><a href="#h20-0-20" id="h20-0-20" class="d">-        table: String,
</a><a href="#h20-0-21" id="h20-0-21" class="d">-        source: Box&lt;dyn Executor&lt;T&gt;&gt;,
</a><a href="#h20-0-22" id="h20-0-22" class="d">-        expressions: BTreeMap&lt;String, Expression&gt;,
</a><a href="#h20-0-23" id="h20-0-23" class="d">-    ) -&gt; Box&lt;Self&gt; {
</a><a href="#h20-0-24" id="h20-0-24" class="d">-        Box::new(Self { table, source, expressions })
</a><a href="#h20-0-25" id="h20-0-25" class="d">-    }
</a><a href="#h20-0-26" id="h20-0-26" class="d">-}
</a><a href="#h20-0-27" id="h20-0-27" class="d">-
</a><a href="#h20-0-28" id="h20-0-28" class="d">-impl&lt;T: Transaction&gt; Executor&lt;T&gt; for Update&lt;T&gt; {
</a><a href="#h20-0-29" id="h20-0-29" class="d">-    fn execute(self: Box&lt;Self&gt;, txn: &amp;mut T) -&gt; Result&lt;ResultSet&gt; {
</a><a href="#h20-0-30" id="h20-0-30" class="d">-        match self.source.execute(txn)? {
</a><a href="#h20-0-31" id="h20-0-31" class="d">-            ResultSet::Query { mut rows, .. } =&gt; {
</a><a href="#h20-0-32" id="h20-0-32" class="d">-                let table = txn.must_read_table(&amp;self.table)?;
</a><a href="#h20-0-33" id="h20-0-33" class="d">-
</a><a href="#h20-0-34" id="h20-0-34" class="d">-                // The iterator will see our changes, such that the same item may be iterated over
</a><a href="#h20-0-35" id="h20-0-35" class="d">-                // multiple times. We keep track of the primary keys here to avoid that, althought
</a><a href="#h20-0-36" id="h20-0-36" class="d">-                // it may cause ballooning memory usage for large updates.
</a><a href="#h20-0-37" id="h20-0-37" class="d">-                //
</a><a href="#h20-0-38" id="h20-0-38" class="d">-                // FIXME This is not safe for primary key updates, which may still be processed
</a><a href="#h20-0-39" id="h20-0-39" class="d">-                // multiple times - it should be possible to come up with a pathological case that
</a><a href="#h20-0-40" id="h20-0-40" class="d">-                // loops forever (e.g. UPDATE test SET id = id + 1).
</a><a href="#h20-0-41" id="h20-0-41" class="d">-                let mut updated = HashSet::new();
</a><a href="#h20-0-42" id="h20-0-42" class="d">-                while let Some(row) = rows.next().transpose()? {
</a><a href="#h20-0-43" id="h20-0-43" class="d">-                    let id = table.get_row_key(&amp;row)?;
</a><a href="#h20-0-44" id="h20-0-44" class="d">-                    if updated.contains(&amp;id) {
</a><a href="#h20-0-45" id="h20-0-45" class="d">-                        continue;
</a><a href="#h20-0-46" id="h20-0-46" class="d">-                    }
</a><a href="#h20-0-47" id="h20-0-47" class="d">-                    let mut new = row.clone();
</a><a href="#h20-0-48" id="h20-0-48" class="d">-                    for (field, expr) in &amp;self.expressions {
</a><a href="#h20-0-49" id="h20-0-49" class="d">-                        table.set_row_field(&amp;mut new, field, expr.evaluate(Some(&amp;row))?)?;
</a><a href="#h20-0-50" id="h20-0-50" class="d">-                    }
</a><a href="#h20-0-51" id="h20-0-51" class="d">-                    txn.update(&amp;table.name, &amp;id, new)?;
</a><a href="#h20-0-52" id="h20-0-52" class="d">-                    updated.insert(id);
</a><a href="#h20-0-53" id="h20-0-53" class="d">-                }
</a><a href="#h20-0-54" id="h20-0-54" class="d">-                Ok(ResultSet::Update { count: updated.len() as u64 })
</a><a href="#h20-0-55" id="h20-0-55" class="d">-            }
</a><a href="#h20-0-56" id="h20-0-56" class="d">-            r =&gt; Err(Error::Internal(format!(&quot;Unexpected response {:?}&quot;, r))),
</a><a href="#h20-0-57" id="h20-0-57" class="d">-        }
</a><a href="#h20-0-58" id="h20-0-58" class="d">-    }
</a><a href="#h20-0-59" id="h20-0-59" class="d">-}
</a><b>diff --git a/<a id="h21" href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a> b/<a href="../file/src/sql/plan/mod.rs.html">src/sql/plan/mod.rs</a></b>
<a href="#h21-0" id="h21-0" class="h">@@ -63,7 +63,7 @@ pub enum Node {
</a>         table: String,
         alias: Option&lt;String&gt;,
         column: String,
<a href="#h21-0-3" id="h21-0-3" class="d">-        keys: Vec&lt;Value&gt;,
</a><a href="#h21-0-4" id="h21-0-4" class="i">+        values: Vec&lt;Value&gt;,
</a>     },
     Insert {
         table: String,
<b>diff --git a/<a id="h22" href="../file/src/sql/plan/optimizer.rs.html">src/sql/plan/optimizer.rs</a> b/<a href="../file/src/sql/plan/optimizer.rs.html">src/sql/plan/optimizer.rs</a></b>
<a href="#h22-0" id="h22-0" class="h">@@ -115,7 +115,7 @@ impl&lt;&#39;a, C: Catalog&gt; Optimizer for IndexLookup&lt;&#39;a, C&gt; {
</a>                                     table: table.name,
                                     alias,
                                     column: column.name,
<a href="#h22-0-3" id="h22-0-3" class="d">-                                    keys: vec![value],
</a><a href="#h22-0-4" id="h22-0-4" class="i">+                                    values: vec![value],
</a>                                 });
                             }
                         }
<b>diff --git a/<a id="h23" href="../file/tests/sql/query/where_index_lookup.html">tests/sql/query/where_index_lookup</a> b/<a href="../file/tests/sql/query/where_index_lookup.html">tests/sql/query/where_index_lookup</a></b>
<a href="#h23-0" id="h23-0" class="h">@@ -94,7 +94,7 @@ Optimized plan: Plan(
</a>             table: &quot;movies&quot;,
             alias: None,
             column: &quot;genre_id&quot;,
<a href="#h23-0-3" id="h23-0-3" class="d">-            keys: [
</a><a href="#h23-0-4" id="h23-0-4" class="i">+            values: [
</a>                 Integer(
                     2,
                 ),
</pre>
</div>
</body>
</html>
