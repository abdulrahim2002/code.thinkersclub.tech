<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>storage: add hybrid log store for Raft log. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/fe42d6425e05af3bc99014d61e1065df0e73fb26.html">fe42d6425e05af3bc99014d61e1065df0e73fb26</a>
<b>parent</b> <a href="../commit/9da1ffe6e40cbb8e5b4839346b57e14a78e1d482.html">9da1ffe6e40cbb8e5b4839346b57e14a78e1d482</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Thu, 14 May 2020 23:07:55 +0200

storage: add hybrid log store for Raft log.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">Cargo.lock</a></td><td> | </td><td class="num">1</td><td><span class="i">+</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">Cargo.toml</a></td><td> | </td><td class="num">1</td><td><span class="i">+</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">config/toydb.yaml</a></td><td> | </td><td class="num">5</td><td><span class="i">+++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/bin/toydb.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">+++</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/error.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/raft/log.rs</a></td><td> | </td><td class="num">410</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++</span><span class="d">---------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/raft/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">47</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d">------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/raft/node/follower.rs</a></td><td> | </td><td class="num">49</td><td><span class="i">+++++++++++++++++++++++++</span><span class="d">------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">src/raft/node/leader.rs</a></td><td> | </td><td class="num">92</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/raft/node/mod.rs</a></td><td> | </td><td class="num">91</td><td><span class="i">+++++++++++++++++++++++++++++</span><span class="d">--------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">src/raft/server.rs</a></td><td> | </td><td class="num">8</td><td><span class="i">++++</span><span class="d">----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h12">src/raft/state.rs</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++</span><span class="d">---------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h13">src/server.rs</a></td><td> | </td><td class="num">21</td><td><span class="i">++++++++++</span><span class="d">-----------</span></td></tr>
<tr><td class="D">D</td><td><a href="#h14">src/storage/kv/ilog.rs</a></td><td> | </td><td class="num">116</td><td><span class="i"></span><span class="d">-------------------------------------------------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h15">src/storage/kv/mod.rs</a></td><td> | </td><td class="num">2</td><td><span class="i"></span><span class="d">--</span></td></tr>
<tr><td class="A">A</td><td><a href="#h16">src/storage/log/hybrid.rs</a></td><td> | </td><td class="num">287</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h17">src/storage/log/memory.rs</a></td><td> | </td><td class="num">109</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h18">src/storage/log/mod.rs</a></td><td> | </td><td class="num">158</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="A">A</td><td><a href="#h19">src/storage/log/test.rs</a></td><td> | </td><td class="num">73</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h20">src/storage/mod.rs</a></td><td> | </td><td class="num">5</td><td><span class="i">+++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h21">src/utility/serialize.rs</a></td><td> | </td><td class="num">1</td><td><span class="i">+</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h22">tests/setup.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
</table></pre><pre>23 files changed, 1011 insertions(+), 493 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/Cargo.lock.html">Cargo.lock</a> b/<a href="../file/Cargo.lock.html">Cargo.lock</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -1100,6 +1100,7 @@ dependencies = [
</a>  &quot;rmp-serde 0.14.3 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
  &quot;rustyline 6.1.2 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
  &quot;serde 1.0.106 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
<a href="#h0-0-3" id="h0-0-3" class="i">+ &quot;serde_cbor 0.11.1 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
</a>  &quot;serde_derive 1.0.106 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
  &quot;serial_test 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
  &quot;simplelog 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
<b>diff --git a/<a id="h1" href="../file/Cargo.toml.html">Cargo.toml</a> b/<a href="../file/Cargo.toml.html">Cargo.toml</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -20,6 +20,7 @@ regex = &quot;~1.3.1&quot;
</a> rmp-serde = &quot;~0.14.0&quot;
 rustyline = &quot;~6.1.2&quot;
 serde = &quot;~1.0.91&quot;
<a href="#h1-0-3" id="h1-0-3" class="i">+serde_cbor = &quot;~0.11.1&quot;
</a> serde_derive = &quot;~1.0.91&quot;
 simplelog = &quot;~0.7.4&quot;
 tokio = { version = &quot;~0.2.18&quot;, features = [&quot;macros&quot;, &quot;rt-core&quot;, &quot;rt-threaded&quot;, &quot;net&quot;, &quot;tcp&quot;, &quot;stream&quot;, &quot;io-util&quot;, &quot;time&quot;, &quot;blocking&quot;, &quot;sync&quot;] }
<b>diff --git a/<a id="h2" href="../file/config/toydb.yaml.html">config/toydb.yaml</a> b/<a href="../file/config/toydb.yaml.html">config/toydb.yaml</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -6,6 +6,7 @@ peers: {}
</a> listen_sql: 0.0.0.0:9605
 listen_raft: 0.0.0.0:9705
 
<a href="#h2-0-3" id="h2-0-3" class="d">-# The node data directory and log level
</a><a href="#h2-0-4" id="h2-0-4" class="d">-data_dir: /var/lib/toydb
</a><a href="#h2-0-5" id="h2-0-5" class="i">+# The node log level, data directory, and whether to fsync writes
</a> log_level: INFO
<a href="#h2-0-7" id="h2-0-7" class="i">+data_dir: /var/lib/toydb
</a><a href="#h2-0-8" id="h2-0-8" class="i">+sync: true
</a><b>diff --git a/<a id="h3" href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a> b/<a href="../file/src/bin/toydb.rs.html">src/bin/toydb.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -26,7 +26,7 @@ async fn main() -&gt; Result&lt;(), toydb::Error&gt; {
</a>     }
     simplelog::SimpleLogger::init(loglevel, logconfig.build())?;
 
<a href="#h3-0-3" id="h3-0-3" class="d">-    Server::new(&amp;cfg.id, cfg.peers, &amp;cfg.data_dir)
</a><a href="#h3-0-4" id="h3-0-4" class="i">+    Server::new(&amp;cfg.id, cfg.peers, &amp;cfg.data_dir, cfg.sync)
</a>         .await?
         .listen(&amp;cfg.listen_sql, &amp;cfg.listen_raft)
         .await?
<a href="#h3-1" id="h3-1" class="h">@@ -41,6 +41,7 @@ struct Config {
</a>     listen_raft: String,
     log_level: String,
     data_dir: String,
<a href="#h3-1-3" id="h3-1-3" class="i">+    sync: bool,
</a>     peers: HashMap&lt;String, String&gt;,
 }
 
<a href="#h3-2" id="h3-2" class="h">@@ -52,6 +53,7 @@ impl Config {
</a>         c.set_default(&quot;listen_raft&quot;, &quot;0.0.0.0:9705&quot;)?;
         c.set_default(&quot;log_level&quot;, &quot;info&quot;)?;
         c.set_default(&quot;data_dir&quot;, &quot;/var/lib/toydb&quot;)?;
<a href="#h3-2-3" id="h3-2-3" class="i">+        c.set_default(&quot;sync&quot;, true)?;
</a> 
         c.merge(config::File::with_name(file))?;
         c.merge(config::Environment::with_prefix(&quot;TOYDB&quot;))?;
<b>diff --git a/<a id="h4" href="../file/src/error.rs.html">src/error.rs</a> b/<a href="../file/src/error.rs.html">src/error.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -67,6 +67,12 @@ impl From&lt;rustyline::error::ReadlineError&gt; for Error {
</a>     }
 }
 
<a href="#h4-0-3" id="h4-0-3" class="i">+impl From&lt;serde_cbor::error::Error&gt; for Error {
</a><a href="#h4-0-4" id="h4-0-4" class="i">+    fn from(err: serde_cbor::error::Error) -&gt; Self {
</a><a href="#h4-0-5" id="h4-0-5" class="i">+        Error::Internal(err.to_string())
</a><a href="#h4-0-6" id="h4-0-6" class="i">+    }
</a><a href="#h4-0-7" id="h4-0-7" class="i">+}
</a><a href="#h4-0-8" id="h4-0-8" class="i">+
</a> impl From&lt;std::io::Error&gt; for Error {
     fn from(err: std::io::Error) -&gt; Self {
         Error::Internal(err.to_string())
<b>diff --git a/<a id="h5" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,9 +1,10 @@
</a><a href="#h5-0-0" id="h5-0-0" class="d">-use crate::storage::kv;
</a><a href="#h5-0-1" id="h5-0-1" class="d">-use crate::utility::{deserialize, serialize};
</a><a href="#h5-0-2" id="h5-0-2" class="i">+use crate::storage::log;
</a> use crate::Error;
 
<a href="#h5-0-5" id="h5-0-5" class="d">-use log::debug;
</a><a href="#h5-0-6" id="h5-0-6" class="i">+use ::log::debug;
</a><a href="#h5-0-7" id="h5-0-7" class="i">+use serde::{Deserialize, Serialize};
</a> use serde_derive::{Deserialize, Serialize};
<a href="#h5-0-9" id="h5-0-9" class="i">+use std::ops::RangeBounds;
</a> 
 /// A replicated log entry
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
<a href="#h5-1" id="h5-1" class="h">@@ -16,130 +17,101 @@ pub struct Entry {
</a>     pub command: Option&lt;Vec&lt;u8&gt;&gt;,
 }
 
<a href="#h5-1-3" id="h5-1-3" class="i">+/// A metadata key
</a><a href="#h5-1-4" id="h5-1-4" class="i">+#[derive(Clone, Debug, PartialEq)]
</a><a href="#h5-1-5" id="h5-1-5" class="i">+pub enum Key {
</a><a href="#h5-1-6" id="h5-1-6" class="i">+    Term,
</a><a href="#h5-1-7" id="h5-1-7" class="i">+    VotedFor,
</a><a href="#h5-1-8" id="h5-1-8" class="i">+}
</a><a href="#h5-1-9" id="h5-1-9" class="i">+
</a><a href="#h5-1-10" id="h5-1-10" class="i">+impl Key {
</a><a href="#h5-1-11" id="h5-1-11" class="i">+    fn encode(&amp;self) -&gt; Vec&lt;u8&gt; {
</a><a href="#h5-1-12" id="h5-1-12" class="i">+        match self {
</a><a href="#h5-1-13" id="h5-1-13" class="i">+            Self::Term =&gt; vec![0],
</a><a href="#h5-1-14" id="h5-1-14" class="i">+            Self::VotedFor =&gt; vec![1],
</a><a href="#h5-1-15" id="h5-1-15" class="i">+        }
</a><a href="#h5-1-16" id="h5-1-16" class="i">+    }
</a><a href="#h5-1-17" id="h5-1-17" class="i">+}
</a><a href="#h5-1-18" id="h5-1-18" class="i">+
</a><a href="#h5-1-19" id="h5-1-19" class="i">+/// A log scan
</a><a href="#h5-1-20" id="h5-1-20" class="i">+pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Entry, Error&gt;&gt; + &#39;a&gt;;
</a><a href="#h5-1-21" id="h5-1-21" class="i">+
</a> /// The replicated Raft log
<a href="#h5-1-23" id="h5-1-23" class="d">-pub struct Log&lt;S: kv::Store&gt; {
</a><a href="#h5-1-24" id="h5-1-24" class="d">-    /// The underlying key-value store
</a><a href="#h5-1-25" id="h5-1-25" class="d">-    kv: S,
</a><a href="#h5-1-26" id="h5-1-26" class="i">+pub struct Log&lt;S: log::Store&gt; {
</a><a href="#h5-1-27" id="h5-1-27" class="i">+    /// The underlying log store.
</a><a href="#h5-1-28" id="h5-1-28" class="i">+    store: S,
</a>     /// The index of the last stored entry.
<a href="#h5-1-30" id="h5-1-30" class="d">-    last_index: u64,
</a><a href="#h5-1-31" id="h5-1-31" class="i">+    pub(super) last_index: u64,
</a>     /// The term of the last stored entry.
<a href="#h5-1-33" id="h5-1-33" class="d">-    last_term: u64,
</a><a href="#h5-1-34" id="h5-1-34" class="i">+    pub(super) last_term: u64,
</a>     /// The last entry known to be committed.
<a href="#h5-1-36" id="h5-1-36" class="d">-    commit_index: u64,
</a><a href="#h5-1-37" id="h5-1-37" class="i">+    pub(super) commit_index: u64,
</a>     /// The term of the last committed entry.
<a href="#h5-1-39" id="h5-1-39" class="d">-    commit_term: u64,
</a><a href="#h5-1-40" id="h5-1-40" class="i">+    pub(super) commit_term: u64,
</a> }
 
<a href="#h5-1-43" id="h5-1-43" class="d">-impl&lt;S: kv::Store&gt; Log&lt;S&gt; {
</a><a href="#h5-1-44" id="h5-1-44" class="d">-    /// Creates a new log, using a kv::Store for storage.
</a><a href="#h5-1-45" id="h5-1-45" class="i">+impl&lt;S: log::Store&gt; Log&lt;S&gt; {
</a><a href="#h5-1-46" id="h5-1-46" class="i">+    /// Creates a new log, using a log::Store for storage.
</a>     pub fn new(store: S) -&gt; Result&lt;Self, Error&gt; {
<a href="#h5-1-48" id="h5-1-48" class="d">-        let (mut commit_index, mut commit_term) = (0, 0);
</a><a href="#h5-1-49" id="h5-1-49" class="d">-        if let Some(index) =
</a><a href="#h5-1-50" id="h5-1-50" class="d">-            store.get(b&quot;commit_index&quot;)?.map(|v| deserialize::&lt;u64&gt;(&amp;v)).transpose()?
</a><a href="#h5-1-51" id="h5-1-51" class="d">-        {
</a><a href="#h5-1-52" id="h5-1-52" class="d">-            match store
</a><a href="#h5-1-53" id="h5-1-53" class="d">-                .get(&amp;index.to_string().as_bytes())?
</a><a href="#h5-1-54" id="h5-1-54" class="d">-                .map(|v| deserialize::&lt;Entry&gt;(&amp;v))
</a><a href="#h5-1-55" id="h5-1-55" class="i">+        let (commit_index, commit_term) = match store.committed() {
</a><a href="#h5-1-56" id="h5-1-56" class="i">+            0 =&gt; (0, 0),
</a><a href="#h5-1-57" id="h5-1-57" class="i">+            index =&gt; store
</a><a href="#h5-1-58" id="h5-1-58" class="i">+                .get(index)?
</a><a href="#h5-1-59" id="h5-1-59" class="i">+                .map(|v| Self::deserialize::&lt;Entry&gt;(&amp;v))
</a>                 .transpose()?
<a href="#h5-1-61" id="h5-1-61" class="d">-            {
</a><a href="#h5-1-62" id="h5-1-62" class="d">-                Some(Entry { term, .. }) =&gt; {
</a><a href="#h5-1-63" id="h5-1-63" class="d">-                    commit_index = index;
</a><a href="#h5-1-64" id="h5-1-64" class="d">-                    commit_term = term;
</a><a href="#h5-1-65" id="h5-1-65" class="d">-                }
</a><a href="#h5-1-66" id="h5-1-66" class="d">-                e =&gt; {
</a><a href="#h5-1-67" id="h5-1-67" class="d">-                    return Err(Error::Internal(format!(
</a><a href="#h5-1-68" id="h5-1-68" class="d">-                        &quot;Failed to load committed entry {}, got {:?}&quot;,
</a><a href="#h5-1-69" id="h5-1-69" class="d">-                        index, e
</a><a href="#h5-1-70" id="h5-1-70" class="d">-                    )))
</a><a href="#h5-1-71" id="h5-1-71" class="d">-                }
</a><a href="#h5-1-72" id="h5-1-72" class="d">-            }
</a><a href="#h5-1-73" id="h5-1-73" class="d">-        }
</a><a href="#h5-1-74" id="h5-1-74" class="d">-        // FIXME This really needs to be done in a better way.
</a><a href="#h5-1-75" id="h5-1-75" class="d">-        let (mut last_index, mut last_term) = (0, 0);
</a><a href="#h5-1-76" id="h5-1-76" class="d">-        for i in 1..std::u64::MAX {
</a><a href="#h5-1-77" id="h5-1-77" class="d">-            if let Some(e) = store.get(&amp;i.to_string().as_bytes())? {
</a><a href="#h5-1-78" id="h5-1-78" class="d">-                let entry: Entry = deserialize(&amp;e)?;
</a><a href="#h5-1-79" id="h5-1-79" class="d">-                last_index = i;
</a><a href="#h5-1-80" id="h5-1-80" class="d">-                last_term = entry.term;
</a><a href="#h5-1-81" id="h5-1-81" class="d">-            } else {
</a><a href="#h5-1-82" id="h5-1-82" class="d">-                break;
</a><a href="#h5-1-83" id="h5-1-83" class="d">-            }
</a><a href="#h5-1-84" id="h5-1-84" class="d">-        }
</a><a href="#h5-1-85" id="h5-1-85" class="d">-        Ok(Self { kv: store, last_index, last_term, commit_index, commit_term })
</a><a href="#h5-1-86" id="h5-1-86" class="i">+                .map(|e| (e.index, e.term))
</a><a href="#h5-1-87" id="h5-1-87" class="i">+                .ok_or_else(|| Error::Internal(&quot;Committed entry not found&quot;.into()))?,
</a><a href="#h5-1-88" id="h5-1-88" class="i">+        };
</a><a href="#h5-1-89" id="h5-1-89" class="i">+        let (last_index, last_term) = match store.len() {
</a><a href="#h5-1-90" id="h5-1-90" class="i">+            0 =&gt; (0, 0),
</a><a href="#h5-1-91" id="h5-1-91" class="i">+            index =&gt; store
</a><a href="#h5-1-92" id="h5-1-92" class="i">+                .get(index)?
</a><a href="#h5-1-93" id="h5-1-93" class="i">+                .map(|v| Self::deserialize::&lt;Entry&gt;(&amp;v))
</a><a href="#h5-1-94" id="h5-1-94" class="i">+                .transpose()?
</a><a href="#h5-1-95" id="h5-1-95" class="i">+                .map(|e| (e.index, e.term))
</a><a href="#h5-1-96" id="h5-1-96" class="i">+                .ok_or_else(|| Error::Internal(&quot;Last entry not found&quot;.into()))?,
</a><a href="#h5-1-97" id="h5-1-97" class="i">+        };
</a><a href="#h5-1-98" id="h5-1-98" class="i">+        Ok(Self { store, last_index, last_term, commit_index, commit_term })
</a>     }
 
     /// Appends a command to the log, returning the entry.
     pub fn append(&amp;mut self, term: u64, command: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;Entry, Error&gt; {
         let entry = Entry { index: self.last_index + 1, term, command };
         debug!(&quot;Appending log entry {}: {:?}&quot;, entry.index, entry);
<a href="#h5-1-105" id="h5-1-105" class="d">-        self.kv.set(&amp;entry.index.to_string().as_bytes(), serialize(&amp;entry)?)?;
</a><a href="#h5-1-106" id="h5-1-106" class="i">+        self.store.append(Self::serialize(&amp;entry)?)?;
</a>         self.last_index = entry.index;
         self.last_term = entry.term;
         Ok(entry)
     }
 
<a href="#h5-1-112" id="h5-1-112" class="d">-    /// Commits entries up to and including an index
</a><a href="#h5-1-113" id="h5-1-113" class="d">-    pub fn commit(&amp;mut self, mut index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h5-1-114" id="h5-1-114" class="d">-        index = std::cmp::min(index, self.last_index);
</a><a href="#h5-1-115" id="h5-1-115" class="d">-        index = std::cmp::max(index, self.commit_index);
</a><a href="#h5-1-116" id="h5-1-116" class="d">-        if index != self.commit_index {
</a><a href="#h5-1-117" id="h5-1-117" class="d">-            if let Some(entry) = self.get(index)? {
</a><a href="#h5-1-118" id="h5-1-118" class="d">-                debug!(&quot;Committing log entry {}&quot;, index);
</a><a href="#h5-1-119" id="h5-1-119" class="d">-                self.kv.set(b&quot;commit_index&quot;, serialize(&amp;index)?)?;
</a><a href="#h5-1-120" id="h5-1-120" class="d">-                self.kv.flush()?;
</a><a href="#h5-1-121" id="h5-1-121" class="d">-                self.commit_index = index;
</a><a href="#h5-1-122" id="h5-1-122" class="d">-                self.commit_term = entry.term;
</a><a href="#h5-1-123" id="h5-1-123" class="d">-            } else {
</a><a href="#h5-1-124" id="h5-1-124" class="d">-                return Err(Error::Internal(format!(
</a><a href="#h5-1-125" id="h5-1-125" class="d">-                    &quot;Entry at commit index {} does not exist&quot;,
</a><a href="#h5-1-126" id="h5-1-126" class="d">-                    index
</a><a href="#h5-1-127" id="h5-1-127" class="d">-                )));
</a><a href="#h5-1-128" id="h5-1-128" class="d">-            }
</a><a href="#h5-1-129" id="h5-1-129" class="d">-        }
</a><a href="#h5-1-130" id="h5-1-130" class="i">+    /// Commits entries up to and including an index.
</a><a href="#h5-1-131" id="h5-1-131" class="i">+    pub fn commit(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h5-1-132" id="h5-1-132" class="i">+        let entry = self
</a><a href="#h5-1-133" id="h5-1-133" class="i">+            .get(index)?
</a><a href="#h5-1-134" id="h5-1-134" class="i">+            .ok_or_else(|| Error::Internal(format!(&quot;Entry {} not found&quot;, index)))?;
</a><a href="#h5-1-135" id="h5-1-135" class="i">+        self.store.commit(index)?;
</a><a href="#h5-1-136" id="h5-1-136" class="i">+        self.commit_index = entry.index;
</a><a href="#h5-1-137" id="h5-1-137" class="i">+        self.commit_term = entry.term;
</a>         Ok(index)
     }
 
     /// Fetches an entry at an index
     pub fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Entry&gt;, Error&gt; {
<a href="#h5-1-143" id="h5-1-143" class="d">-        if let Some(value) = self.kv.get(&amp;index.to_string().as_bytes())? {
</a><a href="#h5-1-144" id="h5-1-144" class="d">-            Ok(Some(deserialize(&amp;value)?))
</a><a href="#h5-1-145" id="h5-1-145" class="d">-        } else {
</a><a href="#h5-1-146" id="h5-1-146" class="d">-            Ok(None)
</a><a href="#h5-1-147" id="h5-1-147" class="d">-        }
</a><a href="#h5-1-148" id="h5-1-148" class="d">-    }
</a><a href="#h5-1-149" id="h5-1-149" class="d">-
</a><a href="#h5-1-150" id="h5-1-150" class="d">-    /// Fetches the last committed index and term
</a><a href="#h5-1-151" id="h5-1-151" class="d">-    pub fn get_committed(&amp;self) -&gt; (u64, u64) {
</a><a href="#h5-1-152" id="h5-1-152" class="d">-        (self.commit_index, self.commit_term)
</a><a href="#h5-1-153" id="h5-1-153" class="d">-    }
</a><a href="#h5-1-154" id="h5-1-154" class="d">-
</a><a href="#h5-1-155" id="h5-1-155" class="d">-    /// Fetches the last stored index and term
</a><a href="#h5-1-156" id="h5-1-156" class="d">-    pub fn get_last(&amp;self) -&gt; (u64, u64) {
</a><a href="#h5-1-157" id="h5-1-157" class="d">-        (self.last_index, self.last_term)
</a><a href="#h5-1-158" id="h5-1-158" class="i">+        self.store.get(index)?.map(|v| Self::deserialize(&amp;v)).transpose()
</a>     }
 
     /// Checks if the log contains an entry
     pub fn has(&amp;self, index: u64, term: u64) -&gt; Result&lt;bool, Error&gt; {
<a href="#h5-1-163" id="h5-1-163" class="d">-        if index == 0 &amp;&amp; term == 0 {
</a><a href="#h5-1-164" id="h5-1-164" class="d">-            return Ok(true);
</a><a href="#h5-1-165" id="h5-1-165" class="d">-        }
</a>         match self.get(index)? {
<a href="#h5-1-167" id="h5-1-167" class="d">-            Some(ref entry) =&gt; Ok(entry.term == term),
</a><a href="#h5-1-168" id="h5-1-168" class="i">+            Some(entry) =&gt; Ok(entry.term == term),
</a><a href="#h5-1-169" id="h5-1-169" class="i">+            None if index == 0 &amp;&amp; term == 0 =&gt; Ok(true),
</a>             None =&gt; Ok(false),
         }
     }
 
<a href="#h5-1-174" id="h5-1-174" class="d">-    /// Fetches a range of entries
</a><a href="#h5-1-175" id="h5-1-175" class="d">-    // FIXME Should take all kinds of ranges (generic over std::ops::RangeBounds),
</a><a href="#h5-1-176" id="h5-1-176" class="d">-    // and use kv::Store.range() once implemented.
</a><a href="#h5-1-177" id="h5-1-177" class="d">-    pub fn range(&amp;self, range: std::ops::RangeFrom&lt;u64&gt;) -&gt; Result&lt;Vec&lt;Entry&gt;, Error&gt; {
</a><a href="#h5-1-178" id="h5-1-178" class="d">-        let mut entries = Vec::new();
</a><a href="#h5-1-179" id="h5-1-179" class="d">-        for i in range.start..=self.last_index {
</a><a href="#h5-1-180" id="h5-1-180" class="d">-            if let Some(entry) = self.get(i)? {
</a><a href="#h5-1-181" id="h5-1-181" class="d">-                entries.push(entry)
</a><a href="#h5-1-182" id="h5-1-182" class="d">-            }
</a><a href="#h5-1-183" id="h5-1-183" class="d">-        }
</a><a href="#h5-1-184" id="h5-1-184" class="d">-        Ok(entries)
</a><a href="#h5-1-185" id="h5-1-185" class="i">+    /// Iterates over log entries
</a><a href="#h5-1-186" id="h5-1-186" class="i">+    pub fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan {
</a><a href="#h5-1-187" id="h5-1-187" class="i">+        Box::new(self.store.scan(range).map(|r| r.and_then(|v| Self::deserialize(&amp;v))))
</a>     }
 
     /// Splices a set of entries onto an offset. The entries must be contiguous, and the first entry
<a href="#h5-2" id="h5-2" class="h">@@ -170,58 +142,65 @@ impl&lt;S: kv::Store&gt; Log&lt;S&gt; {
</a>     /// Refuses to remove entries that have been applied or committed.
     pub fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
         debug!(&quot;Truncating log from entry {}&quot;, index);
<a href="#h5-2-3" id="h5-2-3" class="d">-        if index &lt; self.commit_index {
</a><a href="#h5-2-4" id="h5-2-4" class="d">-            return Err(Error::Value(&quot;Cannot remove committed log entry&quot;.into()));
</a><a href="#h5-2-5" id="h5-2-5" class="d">-        }
</a><a href="#h5-2-6" id="h5-2-6" class="d">-
</a><a href="#h5-2-7" id="h5-2-7" class="d">-        // FIXME This shouldn&#39;t rely on last_index
</a><a href="#h5-2-8" id="h5-2-8" class="d">-        for i in (index + 1)..=self.last_index {
</a><a href="#h5-2-9" id="h5-2-9" class="d">-            self.kv.delete(&amp;i.to_string().as_bytes())?
</a><a href="#h5-2-10" id="h5-2-10" class="d">-        }
</a><a href="#h5-2-11" id="h5-2-11" class="d">-        self.last_index = std::cmp::min(index, self.last_index);
</a><a href="#h5-2-12" id="h5-2-12" class="d">-        self.last_term = self.get(self.last_index)?.map(|e| e.term).unwrap_or(0);
</a><a href="#h5-2-13" id="h5-2-13" class="d">-        Ok(self.last_index)
</a><a href="#h5-2-14" id="h5-2-14" class="i">+        let (index, term) = match self.store.truncate(index)? {
</a><a href="#h5-2-15" id="h5-2-15" class="i">+            0 =&gt; (0, 0),
</a><a href="#h5-2-16" id="h5-2-16" class="i">+            i =&gt; self
</a><a href="#h5-2-17" id="h5-2-17" class="i">+                .store
</a><a href="#h5-2-18" id="h5-2-18" class="i">+                .get(i)?
</a><a href="#h5-2-19" id="h5-2-19" class="i">+                .map(|v| Self::deserialize::&lt;Entry&gt;(&amp;v))
</a><a href="#h5-2-20" id="h5-2-20" class="i">+                .transpose()?
</a><a href="#h5-2-21" id="h5-2-21" class="i">+                .map(|e| (e.index, e.term))
</a><a href="#h5-2-22" id="h5-2-22" class="i">+                .ok_or_else(|| Error::Internal(format!(&quot;Entry {} not found&quot;, index)))?,
</a><a href="#h5-2-23" id="h5-2-23" class="i">+        };
</a><a href="#h5-2-24" id="h5-2-24" class="i">+        self.last_index = index;
</a><a href="#h5-2-25" id="h5-2-25" class="i">+        self.last_term = term;
</a><a href="#h5-2-26" id="h5-2-26" class="i">+        Ok(index)
</a>     }
 
     /// Loads information about the most recent term known by the log, containing the term number (0
     /// if none) and candidate voted for in current term (if any).
     pub fn load_term(&amp;self) -&gt; Result&lt;(u64, Option&lt;String&gt;), Error&gt; {
<a href="#h5-2-32" id="h5-2-32" class="d">-        let term = if let Some(value) = self.kv.get(b&quot;term&quot;)? { deserialize(&amp;value)? } else { 0 };
</a><a href="#h5-2-33" id="h5-2-33" class="d">-        let voted_for = if let Some(value) = self.kv.get(b&quot;voted_for&quot;)? {
</a><a href="#h5-2-34" id="h5-2-34" class="d">-            Some(deserialize(&amp;value)?)
</a><a href="#h5-2-35" id="h5-2-35" class="d">-        } else {
</a><a href="#h5-2-36" id="h5-2-36" class="d">-            None
</a><a href="#h5-2-37" id="h5-2-37" class="d">-        };
</a><a href="#h5-2-38" id="h5-2-38" class="i">+        let term = self
</a><a href="#h5-2-39" id="h5-2-39" class="i">+            .store
</a><a href="#h5-2-40" id="h5-2-40" class="i">+            .get_metadata(&amp;Key::Term.encode())?
</a><a href="#h5-2-41" id="h5-2-41" class="i">+            .map(|v| Self::deserialize(&amp;v))
</a><a href="#h5-2-42" id="h5-2-42" class="i">+            .transpose()?
</a><a href="#h5-2-43" id="h5-2-43" class="i">+            .unwrap_or(0);
</a><a href="#h5-2-44" id="h5-2-44" class="i">+        let voted_for = self
</a><a href="#h5-2-45" id="h5-2-45" class="i">+            .store
</a><a href="#h5-2-46" id="h5-2-46" class="i">+            .get_metadata(&amp;Key::VotedFor.encode())?
</a><a href="#h5-2-47" id="h5-2-47" class="i">+            .map(|v| Self::deserialize(&amp;v))
</a><a href="#h5-2-48" id="h5-2-48" class="i">+            .transpose()?
</a><a href="#h5-2-49" id="h5-2-49" class="i">+            .unwrap_or(None);
</a>         debug!(&quot;Loaded term {} and voted_for {:?} from log&quot;, term, voted_for);
         Ok((term, voted_for))
     }
 
     /// Saves information about the most recent term.
     pub fn save_term(&amp;mut self, term: u64, voted_for: Option&lt;&amp;str&gt;) -&gt; Result&lt;(), Error&gt; {
<a href="#h5-2-56" id="h5-2-56" class="d">-        if term &gt; 0 {
</a><a href="#h5-2-57" id="h5-2-57" class="d">-            self.kv.set(b&quot;term&quot;, serialize(&amp;term)?)?
</a><a href="#h5-2-58" id="h5-2-58" class="d">-        } else {
</a><a href="#h5-2-59" id="h5-2-59" class="d">-            self.kv.delete(b&quot;term&quot;)?
</a><a href="#h5-2-60" id="h5-2-60" class="d">-        }
</a><a href="#h5-2-61" id="h5-2-61" class="d">-        if let Some(v) = voted_for {
</a><a href="#h5-2-62" id="h5-2-62" class="d">-            self.kv.set(b&quot;voted_for&quot;, serialize(&amp;v)?)?
</a><a href="#h5-2-63" id="h5-2-63" class="d">-        } else {
</a><a href="#h5-2-64" id="h5-2-64" class="d">-            self.kv.delete(b&quot;voted_for&quot;)?
</a><a href="#h5-2-65" id="h5-2-65" class="d">-        }
</a><a href="#h5-2-66" id="h5-2-66" class="d">-        self.kv.flush()?;
</a><a href="#h5-2-67" id="h5-2-67" class="d">-        debug!(&quot;Saved term={} and voted_for={:?}&quot;, term, voted_for);
</a><a href="#h5-2-68" id="h5-2-68" class="i">+        self.store.set_metadata(&amp;Key::Term.encode(), Self::serialize(&amp;term)?)?;
</a><a href="#h5-2-69" id="h5-2-69" class="i">+        self.store.set_metadata(&amp;Key::VotedFor.encode(), Self::serialize(&amp;voted_for.clone())?)?;
</a>         Ok(())
     }
<a href="#h5-2-72" id="h5-2-72" class="i">+
</a><a href="#h5-2-73" id="h5-2-73" class="i">+    /// Serializes a value for the log store.
</a><a href="#h5-2-74" id="h5-2-74" class="i">+    fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
</a><a href="#h5-2-75" id="h5-2-75" class="i">+        Ok(serde_cbor::ser::to_vec_packed(value)?)
</a><a href="#h5-2-76" id="h5-2-76" class="i">+    }
</a><a href="#h5-2-77" id="h5-2-77" class="i">+
</a><a href="#h5-2-78" id="h5-2-78" class="i">+    /// Deserializes a value from the log store.
</a><a href="#h5-2-79" id="h5-2-79" class="i">+    fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V, Error&gt; {
</a><a href="#h5-2-80" id="h5-2-80" class="i">+        Ok(serde_cbor::from_slice(bytes)?)
</a><a href="#h5-2-81" id="h5-2-81" class="i">+    }
</a> }
 
 #[cfg(test)]
 mod tests {
     use super::*;
<a href="#h5-2-87" id="h5-2-87" class="d">-    use crate::storage::kv;
</a>     use pretty_assertions::assert_eq;
 
<a href="#h5-2-90" id="h5-2-90" class="d">-    fn setup() -&gt; Result&lt;(Log&lt;kv::Test&gt;, kv::Test), Error&gt; {
</a><a href="#h5-2-91" id="h5-2-91" class="d">-        let store = kv::Test::new();
</a><a href="#h5-2-92" id="h5-2-92" class="i">+    fn setup() -&gt; Result&lt;(Log&lt;log::Test&gt;, log::Test), Error&gt; {
</a><a href="#h5-2-93" id="h5-2-93" class="i">+        let store = log::Test::new();
</a>         let log = Log::new(store.clone())?;
         Ok((log, store))
     }
<a href="#h5-3" id="h5-3" class="h">@@ -229,8 +208,10 @@ mod tests {
</a>     #[test]
     fn new() -&gt; Result&lt;(), Error&gt; {
         let (l, _) = setup()?;
<a href="#h5-3-3" id="h5-3-3" class="d">-        assert_eq!((0, 0), l.get_last());
</a><a href="#h5-3-4" id="h5-3-4" class="d">-        assert_eq!((0, 0), l.get_committed());
</a><a href="#h5-3-5" id="h5-3-5" class="i">+        assert_eq!(0, l.last_index);
</a><a href="#h5-3-6" id="h5-3-6" class="i">+        assert_eq!(0, l.last_term);
</a><a href="#h5-3-7" id="h5-3-7" class="i">+        assert_eq!(0, l.commit_index);
</a><a href="#h5-3-8" id="h5-3-8" class="i">+        assert_eq!(0, l.commit_term);
</a>         assert_eq!(None, l.get(1)?);
         Ok(())
     }
<a href="#h5-4" id="h5-4" class="h">@@ -247,8 +228,10 @@ mod tests {
</a>         assert_eq!(Some(Entry { index: 1, term: 3, command: Some(vec![0x01]) }), l.get(1)?);
         assert_eq!(None, l.get(2)?);
 
<a href="#h5-4-3" id="h5-4-3" class="d">-        assert_eq!((1, 3), l.get_last());
</a><a href="#h5-4-4" id="h5-4-4" class="d">-        assert_eq!((0, 0), l.get_committed());
</a><a href="#h5-4-5" id="h5-4-5" class="i">+        assert_eq!(1, l.last_index);
</a><a href="#h5-4-6" id="h5-4-6" class="i">+        assert_eq!(3, l.last_term);
</a><a href="#h5-4-7" id="h5-4-7" class="i">+        assert_eq!(0, l.commit_index);
</a><a href="#h5-4-8" id="h5-4-8" class="i">+        assert_eq!(0, l.commit_term);
</a>         Ok(())
     }
 
<a href="#h5-5" id="h5-5" class="h">@@ -281,26 +264,24 @@ mod tests {
</a>         l.append(2, None)?;
         l.append(2, Some(vec![0x03]))?;
         assert_eq!(3, l.commit(3)?);
<a href="#h5-5-3" id="h5-5-3" class="d">-        assert_eq!((3, 2), l.get_committed());
</a><a href="#h5-5-4" id="h5-5-4" class="i">+        assert_eq!(3, l.commit_index);
</a><a href="#h5-5-5" id="h5-5-5" class="i">+        assert_eq!(2, l.commit_term);
</a> 
         // The last committed entry must be persisted, to sync with state machine
         let l = Log::new(store)?;
<a href="#h5-5-9" id="h5-5-9" class="d">-        assert_eq!((3, 2), l.get_committed());
</a><a href="#h5-5-10" id="h5-5-10" class="i">+        assert_eq!(3, l.commit_index);
</a><a href="#h5-5-11" id="h5-5-11" class="i">+        assert_eq!(2, l.commit_term);
</a>         Ok(())
     }
 
     #[test]
     fn commit_beyond() -&gt; Result&lt;(), Error&gt; {
<a href="#h5-5-17" id="h5-5-17" class="d">-        let (mut l, store) = setup()?;
</a><a href="#h5-5-18" id="h5-5-18" class="i">+        let (mut l, _) = setup()?;
</a>         l.append(1, Some(vec![0x01]))?;
         l.append(2, None)?;
         l.append(2, Some(vec![0x03]))?;
<a href="#h5-5-22" id="h5-5-22" class="d">-        assert_eq!(3, l.commit(4)?);
</a><a href="#h5-5-23" id="h5-5-23" class="d">-        assert_eq!((3, 2), l.get_committed());
</a><a href="#h5-5-24" id="h5-5-24" class="i">+        assert_eq!(Err(Error::Internal(&quot;Entry 4 not found&quot;.into())), l.commit(4));
</a> 
<a href="#h5-5-26" id="h5-5-26" class="d">-        // The last committed entry must be persisted, to sync with state machine
</a><a href="#h5-5-27" id="h5-5-27" class="d">-        let l = Log::new(store)?;
</a><a href="#h5-5-28" id="h5-5-28" class="d">-        assert_eq!((3, 2), l.get_committed());
</a>         Ok(())
     }
 
<a href="#h5-6" id="h5-6" class="h">@@ -311,21 +292,8 @@ mod tests {
</a>         l.append(2, None)?;
         l.append(2, Some(vec![0x03]))?;
         assert_eq!(2, l.commit(2)?);
<a href="#h5-6-3" id="h5-6-3" class="d">-        assert_eq!((2, 2), l.get_committed());
</a><a href="#h5-6-4" id="h5-6-4" class="d">-        Ok(())
</a><a href="#h5-6-5" id="h5-6-5" class="d">-    }
</a><a href="#h5-6-6" id="h5-6-6" class="d">-
</a><a href="#h5-6-7" id="h5-6-7" class="d">-    #[test]
</a><a href="#h5-6-8" id="h5-6-8" class="d">-    fn commit_reduce() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h5-6-9" id="h5-6-9" class="d">-        let (mut l, _) = setup()?;
</a><a href="#h5-6-10" id="h5-6-10" class="d">-        l.append(1, Some(vec![0x01]))?;
</a><a href="#h5-6-11" id="h5-6-11" class="d">-        l.append(2, None)?;
</a><a href="#h5-6-12" id="h5-6-12" class="d">-        l.append(2, Some(vec![0x03]))?;
</a><a href="#h5-6-13" id="h5-6-13" class="d">-        assert_eq!(2, l.commit(2)?);
</a><a href="#h5-6-14" id="h5-6-14" class="d">-        assert_eq!((2, 2), l.get_committed());
</a><a href="#h5-6-15" id="h5-6-15" class="d">-
</a><a href="#h5-6-16" id="h5-6-16" class="d">-        assert_eq!(2, l.commit(1)?);
</a><a href="#h5-6-17" id="h5-6-17" class="d">-        assert_eq!((2, 2), l.get_committed());
</a><a href="#h5-6-18" id="h5-6-18" class="i">+        assert_eq!(2, l.commit_index);
</a><a href="#h5-6-19" id="h5-6-19" class="i">+        assert_eq!(2, l.commit_term);
</a>         Ok(())
     }
 
<a href="#h5-7" id="h5-7" class="h">@@ -356,7 +324,7 @@ mod tests {
</a>     }
 
     #[test]
<a href="#h5-7-3" id="h5-7-3" class="d">-    fn range() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h5-7-4" id="h5-7-4" class="i">+    fn scan() -&gt; Result&lt;(), Error&gt; {
</a>         let (mut l, _) = setup()?;
         l.append(1, Some(vec![0x01]))?;
         l.append(1, Some(vec![0x02]))?;
<a href="#h5-8" id="h5-8" class="h">@@ -368,16 +336,16 @@ mod tests {
</a>                 Entry { index: 2, term: 1, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 1, command: Some(vec![0x03]) },
             ],
<a href="#h5-8-3" id="h5-8-3" class="d">-            l.range(0..)?
</a><a href="#h5-8-4" id="h5-8-4" class="i">+            l.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a>         );
         assert_eq!(
             vec![
                 Entry { index: 2, term: 1, command: Some(vec![0x02]) },
                 Entry { index: 3, term: 1, command: Some(vec![0x03]) },
             ],
<a href="#h5-8-11" id="h5-8-11" class="d">-            l.range(2..)?
</a><a href="#h5-8-12" id="h5-8-12" class="i">+            l.scan(2..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a>         );
<a href="#h5-8-14" id="h5-8-14" class="d">-        assert_eq!(Vec::&lt;Entry&gt;::new(), l.range(4..)?);
</a><a href="#h5-8-15" id="h5-8-15" class="i">+        assert!(l.scan(4..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a>         Ok(())
     }
 
<a href="#h5-9" id="h5-9" class="h">@@ -416,11 +384,17 @@ mod tests {
</a>                 Entry { index: 4, term: 4, command: Some(vec![0x04]) },
             ])?
         );
<a href="#h5-9-3" id="h5-9-3" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h5-9-4" id="h5-9-4" class="d">-        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h5-9-5" id="h5-9-5" class="d">-        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h5-9-6" id="h5-9-6" class="d">-        assert_eq!(Some(Entry { index: 4, term: 4, command: Some(vec![0x04]) }), l.get(4)?);
</a><a href="#h5-9-7" id="h5-9-7" class="d">-        assert_eq!((4, 4), l.get_last());
</a><a href="#h5-9-8" id="h5-9-8" class="i">+        assert_eq!(
</a><a href="#h5-9-9" id="h5-9-9" class="i">+            vec![
</a><a href="#h5-9-10" id="h5-9-10" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h5-9-11" id="h5-9-11" class="i">+                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h5-9-12" id="h5-9-12" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h5-9-13" id="h5-9-13" class="i">+                Entry { index: 4, term: 4, command: Some(vec![0x04]) },
</a><a href="#h5-9-14" id="h5-9-14" class="i">+            ],
</a><a href="#h5-9-15" id="h5-9-15" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-9-16" id="h5-9-16" class="i">+        );
</a><a href="#h5-9-17" id="h5-9-17" class="i">+        assert_eq!(4, l.last_index);
</a><a href="#h5-9-18" id="h5-9-18" class="i">+        assert_eq!(4, l.last_term);
</a>         Ok(())
     }
 
<a href="#h5-10" id="h5-10" class="h">@@ -438,9 +412,15 @@ mod tests {
</a>                 Entry { index: 2, term: 4, command: Some(vec![0x0b]) },
             ])?
         );
<a href="#h5-10-3" id="h5-10-3" class="d">-        assert_eq!(Some(Entry { index: 1, term: 4, command: Some(vec![0x0a]) }), l.get(1)?);
</a><a href="#h5-10-4" id="h5-10-4" class="d">-        assert_eq!(Some(Entry { index: 2, term: 4, command: Some(vec![0x0b]) }), l.get(2)?);
</a><a href="#h5-10-5" id="h5-10-5" class="d">-        assert_eq!((2, 4), l.get_last());
</a><a href="#h5-10-6" id="h5-10-6" class="i">+        assert_eq!(
</a><a href="#h5-10-7" id="h5-10-7" class="i">+            vec![
</a><a href="#h5-10-8" id="h5-10-8" class="i">+                Entry { index: 1, term: 4, command: Some(vec![0x0a]) },
</a><a href="#h5-10-9" id="h5-10-9" class="i">+                Entry { index: 2, term: 4, command: Some(vec![0x0b]) },
</a><a href="#h5-10-10" id="h5-10-10" class="i">+            ],
</a><a href="#h5-10-11" id="h5-10-11" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-10-12" id="h5-10-12" class="i">+        );
</a><a href="#h5-10-13" id="h5-10-13" class="i">+        assert_eq!(2, l.last_index);
</a><a href="#h5-10-14" id="h5-10-14" class="i">+        assert_eq!(4, l.last_term);
</a>         Ok(())
     }
 
<a href="#h5-11" id="h5-11" class="h">@@ -457,11 +437,17 @@ mod tests {
</a>                 Entry { index: 4, term: 4, command: Some(vec![0x04]) },
             ])?
         );
<a href="#h5-11-3" id="h5-11-3" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h5-11-4" id="h5-11-4" class="d">-        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h5-11-5" id="h5-11-5" class="d">-        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h5-11-6" id="h5-11-6" class="d">-        assert_eq!(Some(Entry { index: 4, term: 4, command: Some(vec![0x04]) }), l.get(4)?);
</a><a href="#h5-11-7" id="h5-11-7" class="d">-        assert_eq!((4, 4), l.get_last());
</a><a href="#h5-11-8" id="h5-11-8" class="i">+        assert_eq!(
</a><a href="#h5-11-9" id="h5-11-9" class="i">+            vec![
</a><a href="#h5-11-10" id="h5-11-10" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h5-11-11" id="h5-11-11" class="i">+                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h5-11-12" id="h5-11-12" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h5-11-13" id="h5-11-13" class="i">+                Entry { index: 4, term: 4, command: Some(vec![0x04]) },
</a><a href="#h5-11-14" id="h5-11-14" class="i">+            ],
</a><a href="#h5-11-15" id="h5-11-15" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-11-16" id="h5-11-16" class="i">+        );
</a><a href="#h5-11-17" id="h5-11-17" class="i">+        assert_eq!(4, l.last_index);
</a><a href="#h5-11-18" id="h5-11-18" class="i">+        assert_eq!(4, l.last_term);
</a>         Ok(())
     }
 
<a href="#h5-12" id="h5-12" class="h">@@ -480,10 +466,16 @@ mod tests {
</a>                 Entry { index: 3, term: 3, command: Some(vec![0x0c]) }
             ])?
         );
<a href="#h5-12-3" id="h5-12-3" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h5-12-4" id="h5-12-4" class="d">-        assert_eq!(Some(Entry { index: 2, term: 3, command: Some(vec![0x0b]) }), l.get(2)?);
</a><a href="#h5-12-5" id="h5-12-5" class="d">-        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x0c]) }), l.get(3)?);
</a><a href="#h5-12-6" id="h5-12-6" class="d">-        assert_eq!((3, 3), l.get_last());
</a><a href="#h5-12-7" id="h5-12-7" class="i">+        assert_eq!(
</a><a href="#h5-12-8" id="h5-12-8" class="i">+            vec![
</a><a href="#h5-12-9" id="h5-12-9" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h5-12-10" id="h5-12-10" class="i">+                Entry { index: 2, term: 3, command: Some(vec![0x0b]) },
</a><a href="#h5-12-11" id="h5-12-11" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x0c]) },
</a><a href="#h5-12-12" id="h5-12-12" class="i">+            ],
</a><a href="#h5-12-13" id="h5-12-13" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-12-14" id="h5-12-14" class="i">+        );
</a><a href="#h5-12-15" id="h5-12-15" class="i">+        assert_eq!(3, l.last_index);
</a><a href="#h5-12-16" id="h5-12-16" class="i">+        assert_eq!(3, l.last_term);
</a>         Ok(())
     }
 
<a href="#h5-13" id="h5-13" class="h">@@ -501,11 +493,14 @@ mod tests {
</a>                 Entry { index: 3, term: 3, command: Some(vec![0x03]) },
             ])
         );
<a href="#h5-13-3" id="h5-13-3" class="d">-        // FIXME Use range for these assertions
</a><a href="#h5-13-4" id="h5-13-4" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h5-13-5" id="h5-13-5" class="d">-        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h5-13-6" id="h5-13-6" class="d">-        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h5-13-7" id="h5-13-7" class="d">-        assert_eq!((3, 3), l.get_last());
</a><a href="#h5-13-8" id="h5-13-8" class="i">+        assert_eq!(
</a><a href="#h5-13-9" id="h5-13-9" class="i">+            vec![
</a><a href="#h5-13-10" id="h5-13-10" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h5-13-11" id="h5-13-11" class="i">+                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h5-13-12" id="h5-13-12" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h5-13-13" id="h5-13-13" class="i">+            ],
</a><a href="#h5-13-14" id="h5-13-14" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-13-15" id="h5-13-15" class="i">+        );
</a>         Ok(())
     }
 
<a href="#h5-14" id="h5-14" class="h">@@ -523,11 +518,14 @@ mod tests {
</a>                 Entry { index: 6, term: 3, command: Some(vec![0x06]) },
             ])
         );
<a href="#h5-14-3" id="h5-14-3" class="d">-        // FIXME Use range for these assertions
</a><a href="#h5-14-4" id="h5-14-4" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h5-14-5" id="h5-14-5" class="d">-        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h5-14-6" id="h5-14-6" class="d">-        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h5-14-7" id="h5-14-7" class="d">-        assert_eq!((3, 3), l.get_last());
</a><a href="#h5-14-8" id="h5-14-8" class="i">+        assert_eq!(
</a><a href="#h5-14-9" id="h5-14-9" class="i">+            vec![
</a><a href="#h5-14-10" id="h5-14-10" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h5-14-11" id="h5-14-11" class="i">+                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h5-14-12" id="h5-14-12" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h5-14-13" id="h5-14-13" class="i">+            ],
</a><a href="#h5-14-14" id="h5-14-14" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-14-15" id="h5-14-15" class="i">+        );
</a>         Ok(())
     }
 
<a href="#h5-15" id="h5-15" class="h">@@ -539,10 +537,14 @@ mod tests {
</a>         l.append(3, Some(vec![0x03]))?;
 
         assert_eq!(3, l.splice(vec![Entry { index: 2, term: 2, command: Some(vec![0x02]) },])?);
<a href="#h5-15-3" id="h5-15-3" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h5-15-4" id="h5-15-4" class="d">-        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h5-15-5" id="h5-15-5" class="d">-        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h5-15-6" id="h5-15-6" class="d">-        assert_eq!((3, 3), l.get_last());
</a><a href="#h5-15-7" id="h5-15-7" class="i">+        assert_eq!(
</a><a href="#h5-15-8" id="h5-15-8" class="i">+            vec![
</a><a href="#h5-15-9" id="h5-15-9" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h5-15-10" id="h5-15-10" class="i">+                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h5-15-11" id="h5-15-11" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h5-15-12" id="h5-15-12" class="i">+            ],
</a><a href="#h5-15-13" id="h5-15-13" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-15-14" id="h5-15-14" class="i">+        );
</a>         Ok(())
     }
 
<a href="#h5-16" id="h5-16" class="h">@@ -554,10 +556,13 @@ mod tests {
</a>         l.append(3, Some(vec![0x03]))?;
 
         assert_eq!(2, l.truncate(2)?);
<a href="#h5-16-3" id="h5-16-3" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h5-16-4" id="h5-16-4" class="d">-        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h5-16-5" id="h5-16-5" class="d">-        assert_eq!(None, l.get(3)?);
</a><a href="#h5-16-6" id="h5-16-6" class="d">-        assert_eq!((2, 2), l.get_last());
</a><a href="#h5-16-7" id="h5-16-7" class="i">+        assert_eq!(
</a><a href="#h5-16-8" id="h5-16-8" class="i">+            vec![
</a><a href="#h5-16-9" id="h5-16-9" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h5-16-10" id="h5-16-10" class="i">+                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h5-16-11" id="h5-16-11" class="i">+            ],
</a><a href="#h5-16-12" id="h5-16-12" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-16-13" id="h5-16-13" class="i">+        );
</a>         Ok(())
     }
 
<a href="#h5-17" id="h5-17" class="h">@@ -569,11 +574,14 @@ mod tests {
</a>         l.append(3, Some(vec![0x03]))?;
 
         assert_eq!(3, l.truncate(4)?);
<a href="#h5-17-3" id="h5-17-3" class="d">-        assert_eq!(Some(Entry { index: 1, term: 1, command: Some(vec![0x01]) }), l.get(1)?);
</a><a href="#h5-17-4" id="h5-17-4" class="d">-        assert_eq!(Some(Entry { index: 2, term: 2, command: Some(vec![0x02]) }), l.get(2)?);
</a><a href="#h5-17-5" id="h5-17-5" class="d">-        assert_eq!(Some(Entry { index: 3, term: 3, command: Some(vec![0x03]) }), l.get(3)?);
</a><a href="#h5-17-6" id="h5-17-6" class="d">-        assert_eq!(None, l.get(4)?);
</a><a href="#h5-17-7" id="h5-17-7" class="d">-        assert_eq!((3, 3), l.get_last());
</a><a href="#h5-17-8" id="h5-17-8" class="i">+        assert_eq!(
</a><a href="#h5-17-9" id="h5-17-9" class="i">+            vec![
</a><a href="#h5-17-10" id="h5-17-10" class="i">+                Entry { index: 1, term: 1, command: Some(vec![0x01]) },
</a><a href="#h5-17-11" id="h5-17-11" class="i">+                Entry { index: 2, term: 2, command: Some(vec![0x02]) },
</a><a href="#h5-17-12" id="h5-17-12" class="i">+                Entry { index: 3, term: 3, command: Some(vec![0x03]) },
</a><a href="#h5-17-13" id="h5-17-13" class="i">+            ],
</a><a href="#h5-17-14" id="h5-17-14" class="i">+            l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h5-17-15" id="h5-17-15" class="i">+        );
</a>         Ok(())
     }
 
<a href="#h5-18" id="h5-18" class="h">@@ -585,7 +593,10 @@ mod tests {
</a>         l.append(3, Some(vec![0x03]))?;
         l.commit(2)?;
 
<a href="#h5-18-3" id="h5-18-3" class="d">-        assert_eq!(l.truncate(1), Err(Error::Value(&quot;Cannot remove committed log entry&quot;.into())));
</a><a href="#h5-18-4" id="h5-18-4" class="i">+        assert_eq!(
</a><a href="#h5-18-5" id="h5-18-5" class="i">+            l.truncate(1),
</a><a href="#h5-18-6" id="h5-18-6" class="i">+            Err(Error::Internal(&quot;Cannot truncate below committed index 2&quot;.into()))
</a><a href="#h5-18-7" id="h5-18-7" class="i">+        );
</a>         assert_eq!(l.truncate(2)?, 2);
         Ok(())
     }
<a href="#h5-19" id="h5-19" class="h">@@ -598,10 +609,7 @@ mod tests {
</a>         l.append(3, Some(vec![0x03]))?;
 
         assert_eq!(0, l.truncate(0)?);
<a href="#h5-19-3" id="h5-19-3" class="d">-        assert_eq!(None, l.get(1)?);
</a><a href="#h5-19-4" id="h5-19-4" class="d">-        assert_eq!(None, l.get(2)?);
</a><a href="#h5-19-5" id="h5-19-5" class="d">-        assert_eq!(None, l.get(3)?);
</a><a href="#h5-19-6" id="h5-19-6" class="d">-        assert_eq!((0, 0), l.get_last());
</a><a href="#h5-19-7" id="h5-19-7" class="i">+        assert!(l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a>         Ok(())
     }
 }
<b>diff --git a/<a id="h6" href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a> b/<a href="../file/src/raft/mod.rs.html">src/raft/mod.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -5,7 +5,7 @@ mod node;
</a> mod server;
 mod state;
 
<a href="#h6-0-3" id="h6-0-3" class="d">-pub use self::log::{Entry, Log};
</a><a href="#h6-0-4" id="h6-0-4" class="i">+pub use self::log::{Entry, Log, Scan};
</a> pub use client::Client;
 pub use message::{Address, Event, Message, Request, Response};
 pub use node::{Node, Status};
<b>diff --git a/<a id="h7" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -1,9 +1,9 @@
</a> use super::super::{Address, Event, Message, Response};
 use super::{Follower, Leader, Node, RoleNode, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
<a href="#h7-0-2" id="h7-0-2" class="d">-use crate::storage::kv;
</a><a href="#h7-0-3" id="h7-0-3" class="i">+use crate::storage::log;
</a> use crate::Error;
 
<a href="#h7-0-6" id="h7-0-6" class="d">-use log::{debug, info, warn};
</a><a href="#h7-0-7" id="h7-0-7" class="i">+use ::log::{debug, info, warn};
</a> use rand::Rng as _;
 
 /// A candidate is campaigning to become a leader.
<a href="#h7-1" id="h7-1" class="h">@@ -29,11 +29,12 @@ impl Candidate {
</a>     }
 }
 
<a href="#h7-1-3" id="h7-1-3" class="d">-impl&lt;L: kv::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a><a href="#h7-1-4" id="h7-1-4" class="i">+impl&lt;L: log::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>     /// Transition to follower role.
     fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;, Error&gt; {
         info!(&quot;Discovered leader {} for term {}, following&quot;, leader, term);
<a href="#h7-1-8" id="h7-1-8" class="d">-        self.save_term(term, None)?;
</a><a href="#h7-1-9" id="h7-1-9" class="i">+        self.term = term;
</a><a href="#h7-1-10" id="h7-1-10" class="i">+        self.log.save_term(term, None)?;
</a>         let mut node = self.become_role(Follower::new(Some(leader), None))?;
         node.abort_proxied()?;
         node.forward_queued(Address::Peer(leader.to_string()))?;
<a href="#h7-2" id="h7-2" class="h">@@ -44,10 +45,15 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>     fn become_leader(self) -&gt; Result&lt;RoleNode&lt;Leader, L&gt;, Error&gt; {
         info!(&quot;Won election for term {}, becoming leader&quot;, self.term);
         let peers = self.peers.clone();
<a href="#h7-2-3" id="h7-2-3" class="d">-        let (last_index, _) = self.log.get_last();
</a><a href="#h7-2-4" id="h7-2-4" class="d">-        let (commit_index, commit_term) = self.log.get_committed();
</a><a href="#h7-2-5" id="h7-2-5" class="i">+        let last_index = self.log.last_index;
</a>         let mut node = self.become_role(Leader::new(peers, last_index))?;
<a href="#h7-2-7" id="h7-2-7" class="d">-        node.send(Address::Peers, Event::Heartbeat { commit_index, commit_term })?;
</a><a href="#h7-2-8" id="h7-2-8" class="i">+        node.send(
</a><a href="#h7-2-9" id="h7-2-9" class="i">+            Address::Peers,
</a><a href="#h7-2-10" id="h7-2-10" class="i">+            Event::Heartbeat {
</a><a href="#h7-2-11" id="h7-2-11" class="i">+                commit_index: node.log.commit_index,
</a><a href="#h7-2-12" id="h7-2-12" class="i">+                commit_term: node.log.commit_term,
</a><a href="#h7-2-13" id="h7-2-13" class="i">+            },
</a><a href="#h7-2-14" id="h7-2-14" class="i">+        )?;
</a>         node.append(None)?;
         node.abort_proxied()?;
         Ok(node)
<a href="#h7-3" id="h7-3" class="h">@@ -112,10 +118,16 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Candidate, L&gt; {
</a>         self.role.election_ticks += 1;
         if self.role.election_ticks &gt;= self.role.election_timeout {
             info!(&quot;Election timed out, starting new election for term {}&quot;, self.term + 1);
<a href="#h7-3-3" id="h7-3-3" class="d">-            self.save_term(self.term + 1, None)?;
</a><a href="#h7-3-4" id="h7-3-4" class="i">+            self.term += 1;
</a><a href="#h7-3-5" id="h7-3-5" class="i">+            self.log.save_term(self.term, None)?;
</a>             self.role = Candidate::new();
<a href="#h7-3-7" id="h7-3-7" class="d">-            let (last_index, last_term) = self.log.get_last();
</a><a href="#h7-3-8" id="h7-3-8" class="d">-            self.send(Address::Peers, Event::SolicitVote { last_index, last_term })?;
</a><a href="#h7-3-9" id="h7-3-9" class="i">+            self.send(
</a><a href="#h7-3-10" id="h7-3-10" class="i">+                Address::Peers,
</a><a href="#h7-3-11" id="h7-3-11" class="i">+                Event::SolicitVote {
</a><a href="#h7-3-12" id="h7-3-12" class="i">+                    last_index: self.log.last_index,
</a><a href="#h7-3-13" id="h7-3-13" class="i">+                    last_term: self.log.last_term,
</a><a href="#h7-3-14" id="h7-3-14" class="i">+                },
</a><a href="#h7-3-15" id="h7-3-15" class="i">+            )?;
</a>         }
         Ok(self.into())
     }
<a href="#h7-4" id="h7-4" class="h">@@ -126,14 +138,13 @@ mod tests {
</a>     use super::super::super::{Entry, Instruction, Log, Request};
     use super::super::tests::{assert_messages, assert_node};
     use super::*;
<a href="#h7-4-3" id="h7-4-3" class="d">-    use crate::storage::kv;
</a>     use std::collections::HashMap;
     use tokio::sync::mpsc;
 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;
         (
<a href="#h7-4-10" id="h7-4-10" class="d">-            RoleNode&lt;Candidate, kv::Test&gt;,
</a><a href="#h7-4-11" id="h7-4-11" class="i">+            RoleNode&lt;Candidate, log::Test&gt;,
</a>             mpsc::UnboundedReceiver&lt;Message&gt;,
             mpsc::UnboundedReceiver&lt;Instruction&gt;,
         ),
<a href="#h7-5" id="h7-5" class="h">@@ -141,11 +152,12 @@ mod tests {
</a>     &gt; {
         let (node_tx, mut node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
<a href="#h7-5-3" id="h7-5-3" class="d">-        let mut log = Log::new(kv::Test::new())?;
</a><a href="#h7-5-4" id="h7-5-4" class="i">+        let mut log = Log::new(log::Test::new())?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
         log.commit(2)?;
<a href="#h7-5-9" id="h7-5-9" class="i">+        log.save_term(3, None)?;
</a> 
         let mut node = RoleNode {
             id: &quot;a&quot;.into(),
<a href="#h7-6" id="h7-6" class="h">@@ -158,7 +170,6 @@ mod tests {
</a>             proxied_reqs: HashMap::new(),
             role: Candidate::new(),
         };
<a href="#h7-6-3" id="h7-6-3" class="d">-        node.save_term(3, None)?;
</a>         node = match node.step(Message {
             from: Address::Client,
             to: Address::Local,
<a href="#h7-7" id="h7-7" class="h">@@ -181,7 +192,7 @@ mod tests {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 3,
<a href="#h7-7-3" id="h7-7-3" class="d">-            event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
</a><a href="#h7-7-4" id="h7-7-4" class="i">+            event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
</a>         })?;
         assert_node(&amp;node).is_follower().term(3);
         assert_messages(
<a href="#h7-8" id="h7-8" class="h">@@ -200,7 +211,7 @@ mod tests {
</a>                     from: Address::Local,
                     to: Address::Peer(&quot;b&quot;.into()),
                     term: 3,
<a href="#h7-8-3" id="h7-8-3" class="d">-                    event: Event::ConfirmLeader { commit_index: 1, has_committed: true },
</a><a href="#h7-8-4" id="h7-8-4" class="i">+                    event: Event::ConfirmLeader { commit_index: 2, has_committed: true },
</a>                 },
             ],
         );
<a href="#h7-9" id="h7-9" class="h">@@ -217,7 +228,7 @@ mod tests {
</a>             from: Address::Peer(&quot;b&quot;.into()),
             to: Address::Peer(&quot;a&quot;.into()),
             term: 4,
<a href="#h7-9-3" id="h7-9-3" class="d">-            event: Event::Heartbeat { commit_index: 1, commit_term: 1 },
</a><a href="#h7-9-4" id="h7-9-4" class="i">+            event: Event::Heartbeat { commit_index: 2, commit_term: 1 },
</a>         })?;
         assert_node(&amp;node).is_follower().term(4);
         assert_messages(
<a href="#h7-10" id="h7-10" class="h">@@ -236,7 +247,7 @@ mod tests {
</a>                     from: Address::Local,
                     to: Address::Peer(&quot;b&quot;.into()),
                     term: 4,
<a href="#h7-10-3" id="h7-10-3" class="d">-                    event: Event::ConfirmLeader { commit_index: 1, has_committed: true },
</a><a href="#h7-10-4" id="h7-10-4" class="i">+                    event: Event::ConfirmLeader { commit_index: 2, has_committed: true },
</a>                 },
             ],
         );
<b>diff --git a/<a id="h8" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -1,9 +1,9 @@
</a> use super::super::{Address, Event, Instruction, Message, Response};
 use super::{Candidate, Node, RoleNode, ELECTION_TIMEOUT_MAX, ELECTION_TIMEOUT_MIN};
<a href="#h8-0-2" id="h8-0-2" class="d">-use crate::storage::kv;
</a><a href="#h8-0-3" id="h8-0-3" class="i">+use crate::storage::log;
</a> use crate::Error;
 
<a href="#h8-0-6" id="h8-0-6" class="d">-use log::{debug, info, warn};
</a><a href="#h8-0-7" id="h8-0-7" class="i">+use ::log::{debug, info, warn};
</a> use rand::Rng as _;
 
 // A follower replicates state from a leader.
<a href="#h8-1" id="h8-1" class="h">@@ -32,14 +32,17 @@ impl Follower {
</a>     }
 }
 
<a href="#h8-1-3" id="h8-1-3" class="d">-impl&lt;L: kv::Store&gt; RoleNode&lt;Follower, L&gt; {
</a><a href="#h8-1-4" id="h8-1-4" class="i">+impl&lt;L: log::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>     /// Transforms the node into a candidate.
     fn become_candidate(self) -&gt; Result&lt;RoleNode&lt;Candidate, L&gt;, Error&gt; {
         info!(&quot;Starting election for term {}&quot;, self.term + 1);
         let mut node = self.become_role(Candidate::new())?;
<a href="#h8-1-9" id="h8-1-9" class="d">-        node.save_term(node.term + 1, None)?;
</a><a href="#h8-1-10" id="h8-1-10" class="d">-        let (last_index, last_term) = node.log.get_last();
</a><a href="#h8-1-11" id="h8-1-11" class="d">-        node.send(Address::Peers, Event::SolicitVote { last_index, last_term })?;
</a><a href="#h8-1-12" id="h8-1-12" class="i">+        node.term += 1;
</a><a href="#h8-1-13" id="h8-1-13" class="i">+        node.log.save_term(node.term, None)?;
</a><a href="#h8-1-14" id="h8-1-14" class="i">+        node.send(
</a><a href="#h8-1-15" id="h8-1-15" class="i">+            Address::Peers,
</a><a href="#h8-1-16" id="h8-1-16" class="i">+            Event::SolicitVote { last_index: node.log.last_index, last_term: node.log.last_term },
</a><a href="#h8-1-17" id="h8-1-17" class="i">+        )?;
</a>         Ok(node)
     }
 
<a href="#h8-2" id="h8-2" class="h">@@ -48,7 +51,8 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>         let mut voted_for = None;
         if term &gt; self.term {
             info!(&quot;Discovered new term {}, following leader {}&quot;, term, leader);
<a href="#h8-2-3" id="h8-2-3" class="d">-            self.save_term(term, None)?;
</a><a href="#h8-2-4" id="h8-2-4" class="i">+            self.term = term;
</a><a href="#h8-2-5" id="h8-2-5" class="i">+            self.log.save_term(term, None)?;
</a>         } else {
             info!(&quot;Discovered leader {}, following&quot;, leader);
             voted_for = self.role.voted_for;
<a href="#h8-3" id="h8-3" class="h">@@ -85,15 +89,13 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>         match msg.event {
             Event::Heartbeat { commit_index, commit_term } =&gt; {
                 if self.is_leader(&amp;msg.from) {
<a href="#h8-3-3" id="h8-3-3" class="d">-                    let (prev_commit_index, _) = self.log.get_committed();
</a>                     let has_committed = self.log.has(commit_index, commit_term)?;
<a href="#h8-3-5" id="h8-3-5" class="d">-                    if has_committed {
</a><a href="#h8-3-6" id="h8-3-6" class="i">+                    if has_committed &amp;&amp; commit_index &gt; self.log.commit_index {
</a><a href="#h8-3-7" id="h8-3-7" class="i">+                        let old_commit_index = self.log.commit_index;
</a>                         self.log.commit(commit_index)?;
<a href="#h8-3-9" id="h8-3-9" class="d">-                        // FIXME This should use a range scan
</a><a href="#h8-3-10" id="h8-3-10" class="d">-                        for index in (prev_commit_index + 1)..=commit_index {
</a><a href="#h8-3-11" id="h8-3-11" class="d">-                            if let Some(entry) = self.log.get(index)? {
</a><a href="#h8-3-12" id="h8-3-12" class="d">-                                self.state_tx.send(Instruction::Apply { entry })?
</a><a href="#h8-3-13" id="h8-3-13" class="d">-                            }
</a><a href="#h8-3-14" id="h8-3-14" class="i">+                        let mut scan = self.log.scan((old_commit_index + 1)..=commit_index);
</a><a href="#h8-3-15" id="h8-3-15" class="i">+                        while let Some(entry) = scan.next().transpose()? {
</a><a href="#h8-3-16" id="h8-3-16" class="i">+                            self.state_tx.send(Instruction::Apply { entry })?;
</a>                         }
                     }
                     self.send(msg.from, Event::ConfirmLeader { commit_index, has_committed })?;
<a href="#h8-4" id="h8-4" class="h">@@ -106,17 +108,16 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Follower, L&gt; {
</a>                         return Ok(self.into());
                     }
                 }
<a href="#h8-4-3" id="h8-4-3" class="d">-                let (local_last_index, local_last_term) = self.log.get_last();
</a><a href="#h8-4-4" id="h8-4-4" class="d">-                if last_term &lt; local_last_term {
</a><a href="#h8-4-5" id="h8-4-5" class="i">+                if last_term &lt; self.log.last_term {
</a>                     return Ok(self.into());
                 }
<a href="#h8-4-8" id="h8-4-8" class="d">-                if last_term == local_last_term &amp;&amp; last_index &lt; local_last_index {
</a><a href="#h8-4-9" id="h8-4-9" class="i">+                if last_term == self.log.last_term &amp;&amp; last_index &lt; self.log.last_index {
</a>                     return Ok(self.into());
                 }
                 if let Address::Peer(from) = msg.from {
                     info!(&quot;Voting for {} in term {} election&quot;, from, self.term);
                     self.send(Address::Peer(from.clone()), Event::GrantVote)?;
<a href="#h8-4-15" id="h8-4-15" class="d">-                    self.save_term(self.term, Some(&amp;from))?;
</a><a href="#h8-4-16" id="h8-4-16" class="i">+                    self.log.save_term(self.term, Some(&amp;from))?;
</a>                     self.role.voted_for = Some(from);
                 }
             }
<a href="#h8-5" id="h8-5" class="h">@@ -179,18 +180,18 @@ pub mod tests {
</a>     use std::collections::HashMap;
     use tokio::sync::mpsc;
 
<a href="#h8-5-3" id="h8-5-3" class="d">-    pub fn follower_leader&lt;L: kv::Store&gt;(node: &amp;RoleNode&lt;Follower, L&gt;) -&gt; Option&lt;String&gt; {
</a><a href="#h8-5-4" id="h8-5-4" class="i">+    pub fn follower_leader&lt;L: log::Store&gt;(node: &amp;RoleNode&lt;Follower, L&gt;) -&gt; Option&lt;String&gt; {
</a>         node.role.leader.clone()
     }
 
<a href="#h8-5-8" id="h8-5-8" class="d">-    pub fn follower_voted_for&lt;L: kv::Store&gt;(node: &amp;RoleNode&lt;Follower, L&gt;) -&gt; Option&lt;String&gt; {
</a><a href="#h8-5-9" id="h8-5-9" class="i">+    pub fn follower_voted_for&lt;L: log::Store&gt;(node: &amp;RoleNode&lt;Follower, L&gt;) -&gt; Option&lt;String&gt; {
</a>         node.role.voted_for.clone()
     }
 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;
         (
<a href="#h8-5-16" id="h8-5-16" class="d">-            RoleNode&lt;Follower, kv::Test&gt;,
</a><a href="#h8-5-17" id="h8-5-17" class="i">+            RoleNode&lt;Follower, log::Test&gt;,
</a>             mpsc::UnboundedReceiver&lt;Message&gt;,
             mpsc::UnboundedReceiver&lt;Instruction&gt;,
         ),
<a href="#h8-6" id="h8-6" class="h">@@ -198,13 +199,14 @@ pub mod tests {
</a>     &gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
<a href="#h8-6-3" id="h8-6-3" class="d">-        let mut log = Log::new(kv::Test::new())?;
</a><a href="#h8-6-4" id="h8-6-4" class="i">+        let mut log = Log::new(log::Test::new())?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
         log.commit(2)?;
<a href="#h8-6-9" id="h8-6-9" class="i">+        log.save_term(3, None)?;
</a> 
<a href="#h8-6-11" id="h8-6-11" class="d">-        let mut node = RoleNode {
</a><a href="#h8-6-12" id="h8-6-12" class="i">+        let node = RoleNode {
</a>             id: &quot;a&quot;.into(),
             peers: vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()],
             term: 3,
<a href="#h8-7" id="h8-7" class="h">@@ -215,7 +217,6 @@ pub mod tests {
</a>             queued_reqs: Vec::new(),
             role: Follower::new(Some(&quot;b&quot;), None),
         };
<a href="#h8-7-3" id="h8-7-3" class="d">-        node.save_term(3, None)?;
</a>         Ok((node, node_rx, state_rx))
     }
 
<b>diff --git a/<a id="h9" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,9 +1,9 @@
</a> use super::super::{Address, Event, Instruction, Message, Request, Response, Status};
 use super::{Follower, Node, RoleNode, HEARTBEAT_INTERVAL};
<a href="#h9-0-2" id="h9-0-2" class="d">-use crate::storage::kv;
</a><a href="#h9-0-3" id="h9-0-3" class="i">+use crate::storage::log;
</a> use crate::Error;
 
<a href="#h9-0-6" id="h9-0-6" class="d">-use log::{debug, info, warn};
</a><a href="#h9-0-7" id="h9-0-7" class="i">+use ::log::{debug, info, warn};
</a> use std::collections::HashMap;
 
 // A leader serves requests and replicates the log to followers.
<a href="#h9-1" id="h9-1" class="h">@@ -33,11 +33,12 @@ impl Leader {
</a>     }
 }
 
<a href="#h9-1-3" id="h9-1-3" class="d">-impl&lt;L: kv::Store&gt; RoleNode&lt;Leader, L&gt; {
</a><a href="#h9-1-4" id="h9-1-4" class="i">+impl&lt;L: log::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>     /// Transforms the leader into a follower
     fn become_follower(mut self, term: u64, leader: &amp;str) -&gt; Result&lt;RoleNode&lt;Follower, L&gt;, Error&gt; {
         info!(&quot;Discovered new leader {} for term {}, following&quot;, leader, term);
<a href="#h9-1-8" id="h9-1-8" class="d">-        self.save_term(term, None)?;
</a><a href="#h9-1-9" id="h9-1-9" class="i">+        self.term = term;
</a><a href="#h9-1-10" id="h9-1-10" class="i">+        self.log.save_term(term, None)?;
</a>         self.state_tx.send(Instruction::Abort)?;
         self.become_role(Follower::new(Some(leader), None))
     }
<a href="#h9-2" id="h9-2" class="h">@@ -53,29 +54,26 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Leader, L&gt; {
</a> 
     /// Commits any pending log entries.
     fn commit(&amp;mut self) -&gt; Result&lt;u64, Error&gt; {
<a href="#h9-2-3" id="h9-2-3" class="d">-        let (last_index, _) = self.log.get_last();
</a><a href="#h9-2-4" id="h9-2-4" class="d">-        let (commit_index, _) = self.log.get_committed();
</a><a href="#h9-2-5" id="h9-2-5" class="d">-        let mut last_indexes = vec![last_index];
</a><a href="#h9-2-6" id="h9-2-6" class="i">+        let mut last_indexes = vec![self.log.last_index];
</a>         last_indexes.extend(self.role.peer_last_index.values());
         last_indexes.sort();
         last_indexes.reverse();
         let quorum_index = last_indexes[self.quorum() as usize - 1];
<a href="#h9-2-11" id="h9-2-11" class="d">-        if quorum_index &lt; commit_index {
</a><a href="#h9-2-12" id="h9-2-12" class="d">-            return Ok(commit_index);
</a><a href="#h9-2-13" id="h9-2-13" class="d">-        }
</a><a href="#h9-2-14" id="h9-2-14" class="d">-        // We can only safely commit up to an entry from our own term, see
</a><a href="#h9-2-15" id="h9-2-15" class="d">-        // figure 8 in Raft paper for background.
</a><a href="#h9-2-16" id="h9-2-16" class="d">-        let committed_index = match self.log.get(quorum_index)? {
</a><a href="#h9-2-17" id="h9-2-17" class="d">-            Some(entry) if entry.term == self.term =&gt; self.log.commit(quorum_index)?,
</a><a href="#h9-2-18" id="h9-2-18" class="d">-            _ =&gt; commit_index,
</a><a href="#h9-2-19" id="h9-2-19" class="d">-        };
</a><a href="#h9-2-20" id="h9-2-20" class="d">-        // FIXME Log should handle range scans
</a><a href="#h9-2-21" id="h9-2-21" class="d">-        for index in (commit_index + 1)..=committed_index {
</a><a href="#h9-2-22" id="h9-2-22" class="d">-            if let Some(entry) = self.log.get(index)? {
</a><a href="#h9-2-23" id="h9-2-23" class="d">-                self.state_tx.send(Instruction::Apply { entry })?
</a><a href="#h9-2-24" id="h9-2-24" class="i">+
</a><a href="#h9-2-25" id="h9-2-25" class="i">+        // We can only safely commit up to an entry from our own term, see figure 8 in Raft paper.
</a><a href="#h9-2-26" id="h9-2-26" class="i">+        if quorum_index &gt; self.log.commit_index {
</a><a href="#h9-2-27" id="h9-2-27" class="i">+            if let Some(entry) = self.log.get(quorum_index)? {
</a><a href="#h9-2-28" id="h9-2-28" class="i">+                if entry.term == self.term {
</a><a href="#h9-2-29" id="h9-2-29" class="i">+                    let old_commit_index = self.log.commit_index;
</a><a href="#h9-2-30" id="h9-2-30" class="i">+                    self.log.commit(quorum_index)?;
</a><a href="#h9-2-31" id="h9-2-31" class="i">+                    let mut scan = self.log.scan((old_commit_index + 1)..=self.log.commit_index);
</a><a href="#h9-2-32" id="h9-2-32" class="i">+                    while let Some(entry) = scan.next().transpose()? {
</a><a href="#h9-2-33" id="h9-2-33" class="i">+                        self.state_tx.send(Instruction::Apply { entry })?;
</a><a href="#h9-2-34" id="h9-2-34" class="i">+                    }
</a><a href="#h9-2-35" id="h9-2-35" class="i">+                }
</a>             }
         }
<a href="#h9-2-38" id="h9-2-38" class="d">-        Ok(committed_index)
</a><a href="#h9-2-39" id="h9-2-39" class="i">+        Ok(self.log.commit_index)
</a>     }
 
     /// Replicates the log to a peer.
<a href="#h9-3" id="h9-3" class="h">@@ -92,7 +90,7 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>             None if base_index == 0 =&gt; 0,
             None =&gt; return Err(Error::Internal(format!(&quot;Missing base entry {}&quot;, base_index))),
         };
<a href="#h9-3-3" id="h9-3-3" class="d">-        let entries = self.log.range(peer_next..)?;
</a><a href="#h9-3-4" id="h9-3-4" class="i">+        let entries = self.log.scan(peer_next..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?;
</a>         debug!(&quot;Replicating {} entries at base {} to {}&quot;, entries.len(), base_index, peer);
         self.send(
             Address::Peer(peer.to_string()),
<a href="#h9-4" id="h9-4" class="h">@@ -144,20 +142,27 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>             }
 
             Event::ClientRequest { id, request: Request::Query(command) } =&gt; {
<a href="#h9-4-3" id="h9-4-3" class="d">-                // FIXME This needs to wait until the first entry from out term has been
</a><a href="#h9-4-4" id="h9-4-4" class="i">+                // FIXME This needs to wait until the first entry from our term has been
</a>                 // committed, see: https://stackoverflow.com/questions/37207682/raft-some-questions-about-read-only-queries
<a href="#h9-4-6" id="h9-4-6" class="d">-                let (commit_index, commit_term) = self.log.get_committed();
</a>                 self.state_tx.send(Instruction::Query {
                     id,
                     address: msg.from,
                     command,
<a href="#h9-4-11" id="h9-4-11" class="d">-                    index: commit_index,
</a><a href="#h9-4-12" id="h9-4-12" class="i">+                    index: self.log.commit_index,
</a>                     quorum: self.quorum(),
                 })?;
<a href="#h9-4-15" id="h9-4-15" class="d">-                self.state_tx
</a><a href="#h9-4-16" id="h9-4-16" class="d">-                    .send(Instruction::Vote { index: commit_index, address: Address::Local })?;
</a><a href="#h9-4-17" id="h9-4-17" class="i">+                self.state_tx.send(Instruction::Vote {
</a><a href="#h9-4-18" id="h9-4-18" class="i">+                    index: self.log.commit_index,
</a><a href="#h9-4-19" id="h9-4-19" class="i">+                    address: Address::Local,
</a><a href="#h9-4-20" id="h9-4-20" class="i">+                })?;
</a>                 if !self.peers.is_empty() {
<a href="#h9-4-22" id="h9-4-22" class="d">-                    self.send(Address::Peers, Event::Heartbeat { commit_index, commit_term })?;
</a><a href="#h9-4-23" id="h9-4-23" class="i">+                    self.send(
</a><a href="#h9-4-24" id="h9-4-24" class="i">+                        Address::Peers,
</a><a href="#h9-4-25" id="h9-4-25" class="i">+                        Event::Heartbeat {
</a><a href="#h9-4-26" id="h9-4-26" class="i">+                            commit_index: self.log.commit_index,
</a><a href="#h9-4-27" id="h9-4-27" class="i">+                            commit_term: self.log.commit_term,
</a><a href="#h9-4-28" id="h9-4-28" class="i">+                        },
</a><a href="#h9-4-29" id="h9-4-29" class="i">+                    )?;
</a>                 }
             }
 
<a href="#h9-5" id="h9-5" class="h">@@ -175,11 +180,10 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>                     leader: self.id.clone(),
                     term: self.term,
                     node_last_index: self.role.peer_last_index.clone(),
<a href="#h9-5-3" id="h9-5-3" class="d">-                    commit_index: self.log.get_committed().0,
</a><a href="#h9-5-4" id="h9-5-4" class="i">+                    commit_index: self.log.commit_index,
</a>                     apply_index: 0,
                 };
<a href="#h9-5-7" id="h9-5-7" class="d">-                let (last_index, _) = self.log.get_last();
</a><a href="#h9-5-8" id="h9-5-8" class="d">-                status.node_last_index.insert(self.id.clone(), last_index);
</a><a href="#h9-5-9" id="h9-5-9" class="i">+                status.node_last_index.insert(self.id.clone(), self.log.last_index);
</a>                 self.state_tx.send(Instruction::Status { id, address: msg.from, status })?
             }
 
<a href="#h9-6" id="h9-6" class="h">@@ -208,8 +212,13 @@ impl&lt;L: kv::Store&gt; RoleNode&lt;Leader, L&gt; {
</a>             self.role.heartbeat_ticks += 1;
             if self.role.heartbeat_ticks &gt;= HEARTBEAT_INTERVAL {
                 self.role.heartbeat_ticks = 0;
<a href="#h9-6-3" id="h9-6-3" class="d">-                let (commit_index, commit_term) = self.log.get_committed();
</a><a href="#h9-6-4" id="h9-6-4" class="d">-                self.send(Address::Peers, Event::Heartbeat { commit_index, commit_term })?;
</a><a href="#h9-6-5" id="h9-6-5" class="i">+                self.send(
</a><a href="#h9-6-6" id="h9-6-6" class="i">+                    Address::Peers,
</a><a href="#h9-6-7" id="h9-6-7" class="i">+                    Event::Heartbeat {
</a><a href="#h9-6-8" id="h9-6-8" class="i">+                        commit_index: self.log.commit_index,
</a><a href="#h9-6-9" id="h9-6-9" class="i">+                        commit_term: self.log.commit_term,
</a><a href="#h9-6-10" id="h9-6-10" class="i">+                    },
</a><a href="#h9-6-11" id="h9-6-11" class="i">+                )?;
</a>             }
         }
         Ok(self.into())
<a href="#h9-7" id="h9-7" class="h">@@ -221,14 +230,13 @@ mod tests {
</a>     use super::super::super::{Entry, Log};
     use super::super::tests::{assert_messages, assert_node};
     use super::*;
<a href="#h9-7-3" id="h9-7-3" class="d">-    use crate::storage::kv;
</a>     use pretty_assertions::assert_eq;
     use tokio::sync::mpsc;
 
     #[allow(clippy::type_complexity)]
     fn setup() -&gt; Result&lt;
         (
<a href="#h9-7-10" id="h9-7-10" class="d">-            RoleNode&lt;Leader, kv::Test&gt;,
</a><a href="#h9-7-11" id="h9-7-11" class="i">+            RoleNode&lt;Leader, log::Test&gt;,
</a>             mpsc::UnboundedReceiver&lt;Message&gt;,
             mpsc::UnboundedReceiver&lt;Instruction&gt;,
         ),
<a href="#h9-8" id="h9-8" class="h">@@ -236,29 +244,27 @@ mod tests {
</a>     &gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
<a href="#h9-8-3" id="h9-8-3" class="d">-        let mut log = Log::new(kv::Test::new())?;
</a><a href="#h9-8-4" id="h9-8-4" class="i">+        let peers = vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()];
</a><a href="#h9-8-5" id="h9-8-5" class="i">+        let mut log = Log::new(log::Test::new())?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
         log.append(2, Some(vec![0x03]))?;
         log.append(3, Some(vec![0x04]))?;
         log.append(3, Some(vec![0x05]))?;
         log.commit(2)?;
<a href="#h9-8-12" id="h9-8-12" class="i">+        log.save_term(3, None)?;
</a> 
<a href="#h9-8-14" id="h9-8-14" class="d">-        let peers = vec![&quot;b&quot;.into(), &quot;c&quot;.into(), &quot;d&quot;.into(), &quot;e&quot;.into()];
</a><a href="#h9-8-15" id="h9-8-15" class="d">-        let (last_index, _) = log.get_last();
</a><a href="#h9-8-16" id="h9-8-16" class="d">-
</a><a href="#h9-8-17" id="h9-8-17" class="d">-        let mut node = RoleNode {
</a><a href="#h9-8-18" id="h9-8-18" class="i">+        let node = RoleNode {
</a>             id: &quot;a&quot;.into(),
             peers: peers.clone(),
             term: 3,
<a href="#h9-8-22" id="h9-8-22" class="i">+            role: Leader::new(peers, log.last_index),
</a>             log,
             node_tx,
             state_tx,
             proxied_reqs: HashMap::new(),
             queued_reqs: Vec::new(),
<a href="#h9-8-28" id="h9-8-28" class="d">-            role: Leader::new(peers, last_index),
</a>         };
<a href="#h9-8-30" id="h9-8-30" class="d">-        node.save_term(3, None)?;
</a>         Ok((node, node_rx, state_rx))
     }
 
<a href="#h9-9" id="h9-9" class="h">@@ -513,7 +519,7 @@ mod tests {
</a>     #[test]
     fn step_rejectentries() -&gt; Result&lt;(), Error&gt; {
         let (leader, mut node_rx, mut state_rx) = setup()?;
<a href="#h9-9-3" id="h9-9-3" class="d">-        let entries = leader.log.range(0..)?;
</a><a href="#h9-9-4" id="h9-9-4" class="i">+        let entries = leader.log.scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?;
</a>         let mut node: Node&lt;_&gt; = leader.into();
 
         for i in 0..(entries.len() + 3) {
<b>diff --git a/<a id="h10" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -3,13 +3,13 @@ mod follower;
</a> mod leader;
 
 use super::{Address, Driver, Event, Instruction, Log, Message, State};
<a href="#h10-0-3" id="h10-0-3" class="d">-use crate::storage::kv;
</a><a href="#h10-0-4" id="h10-0-4" class="i">+use crate::storage::log;
</a> use crate::Error;
 use candidate::Candidate;
 use follower::Follower;
 use leader::Leader;
 
<a href="#h10-0-10" id="h10-0-10" class="d">-use log::{debug, info};
</a><a href="#h10-0-11" id="h10-0-11" class="i">+use ::log::{debug, info};
</a> use serde_derive::{Deserialize, Serialize};
 use std::collections::HashMap;
 use tokio::sync::mpsc;
<a href="#h10-1" id="h10-1" class="h">@@ -35,13 +35,13 @@ pub struct Status {
</a> }
 
 /// The local Raft node state machine.
<a href="#h10-1-3" id="h10-1-3" class="d">-pub enum Node&lt;L: kv::Store&gt; {
</a><a href="#h10-1-4" id="h10-1-4" class="i">+pub enum Node&lt;L: log::Store&gt; {
</a>     Candidate(RoleNode&lt;Candidate, L&gt;),
     Follower(RoleNode&lt;Follower, L&gt;),
     Leader(RoleNode&lt;Leader, L&gt;),
 }
 
<a href="#h10-1-10" id="h10-1-10" class="d">-impl&lt;L: kv::Store&gt; Node&lt;L&gt; {
</a><a href="#h10-1-11" id="h10-1-11" class="i">+impl&lt;L: log::Store&gt; Node&lt;L&gt; {
</a>     /// Creates a new Raft node, starting as a follower, or leader if no peers.
     pub async fn new&lt;S: State + Send + &#39;static&gt;(
         id: &amp;str,
<a href="#h10-2" id="h10-2" class="h">@@ -50,26 +50,19 @@ impl&lt;L: kv::Store&gt; Node&lt;L&gt; {
</a>         mut state: S,
         node_tx: mpsc::UnboundedSender&lt;Message&gt;,
     ) -&gt; Result&lt;Self, Error&gt; {
<a href="#h10-2-3" id="h10-2-3" class="d">-        let (state_tx, state_rx) = mpsc::unbounded_channel();
</a><a href="#h10-2-4" id="h10-2-4" class="d">-        let (committed_index, _) = log.get_committed();
</a>         let applied_index = state.applied_index();
<a href="#h10-2-6" id="h10-2-6" class="d">-        if applied_index &gt; committed_index {
</a><a href="#h10-2-7" id="h10-2-7" class="i">+        if applied_index &gt; log.commit_index {
</a>             return Err(Error::Internal(format!(
                 &quot;State machine applied index {} greater than log committed index {}&quot;,
<a href="#h10-2-10" id="h10-2-10" class="d">-                applied_index, committed_index
</a><a href="#h10-2-11" id="h10-2-11" class="i">+                applied_index, log.commit_index
</a>             )));
         }
<a href="#h10-2-14" id="h10-2-14" class="i">+
</a><a href="#h10-2-15" id="h10-2-15" class="i">+        let (state_tx, state_rx) = mpsc::unbounded_channel();
</a>         let mut driver = Driver::new(state_rx, node_tx.clone());
<a href="#h10-2-17" id="h10-2-17" class="d">-        if committed_index &gt; applied_index {
</a><a href="#h10-2-18" id="h10-2-18" class="d">-            // FIXME Fix Log.range() and pass an iterator instead.
</a><a href="#h10-2-19" id="h10-2-19" class="d">-            let mut entries = Vec::new();
</a><a href="#h10-2-20" id="h10-2-20" class="d">-            for index in (applied_index + 1)..=committed_index {
</a><a href="#h10-2-21" id="h10-2-21" class="d">-                if let Some(entry) = log.get(index)? {
</a><a href="#h10-2-22" id="h10-2-22" class="d">-                    entries.push(entry);
</a><a href="#h10-2-23" id="h10-2-23" class="d">-                }
</a><a href="#h10-2-24" id="h10-2-24" class="d">-            }
</a><a href="#h10-2-25" id="h10-2-25" class="d">-            info!(&quot;Replaying log entries {} to {}&quot;, applied_index, committed_index);
</a><a href="#h10-2-26" id="h10-2-26" class="d">-            driver.replay(&amp;mut state, entries).await?;
</a><a href="#h10-2-27" id="h10-2-27" class="i">+        if log.commit_index &gt; applied_index {
</a><a href="#h10-2-28" id="h10-2-28" class="i">+            info!(&quot;Replaying log entries {} to {}&quot;, applied_index + 1, log.commit_index);
</a><a href="#h10-2-29" id="h10-2-29" class="i">+            driver.replay(&amp;mut state, log.scan((applied_index + 1)..=log.commit_index))?;
</a>         };
         tokio::spawn(driver.drive(state));
 
<a href="#h10-3" id="h10-3" class="h">@@ -87,7 +80,7 @@ impl&lt;L: kv::Store&gt; Node&lt;L&gt; {
</a>         };
         if node.peers.is_empty() {
             info!(&quot;No peers specified, starting as leader&quot;);
<a href="#h10-3-3" id="h10-3-3" class="d">-            let (last_index, _) = node.log.get_last();
</a><a href="#h10-3-4" id="h10-3-4" class="i">+            let last_index = node.log.last_index;
</a>             Ok(node.become_role(Leader::new(vec![], last_index))?.into())
         } else {
             Ok(node.into())
<a href="#h10-4" id="h10-4" class="h">@@ -123,26 +116,26 @@ impl&lt;L: kv::Store&gt; Node&lt;L&gt; {
</a>     }
 }
 
<a href="#h10-4-3" id="h10-4-3" class="d">-impl&lt;L: kv::Store&gt; From&lt;RoleNode&lt;Candidate, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h10-4-4" id="h10-4-4" class="i">+impl&lt;L: log::Store&gt; From&lt;RoleNode&lt;Candidate, L&gt;&gt; for Node&lt;L&gt; {
</a>     fn from(rn: RoleNode&lt;Candidate, L&gt;) -&gt; Self {
         Node::Candidate(rn)
     }
 }
 
<a href="#h10-4-10" id="h10-4-10" class="d">-impl&lt;L: kv::Store&gt; From&lt;RoleNode&lt;Follower, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h10-4-11" id="h10-4-11" class="i">+impl&lt;L: log::Store&gt; From&lt;RoleNode&lt;Follower, L&gt;&gt; for Node&lt;L&gt; {
</a>     fn from(rn: RoleNode&lt;Follower, L&gt;) -&gt; Self {
         Node::Follower(rn)
     }
 }
 
<a href="#h10-4-17" id="h10-4-17" class="d">-impl&lt;L: kv::Store&gt; From&lt;RoleNode&lt;Leader, L&gt;&gt; for Node&lt;L&gt; {
</a><a href="#h10-4-18" id="h10-4-18" class="i">+impl&lt;L: log::Store&gt; From&lt;RoleNode&lt;Leader, L&gt;&gt; for Node&lt;L&gt; {
</a>     fn from(rn: RoleNode&lt;Leader, L&gt;) -&gt; Self {
         Node::Leader(rn)
     }
 }
 
 // A Raft node with role R
<a href="#h10-4-25" id="h10-4-25" class="d">-pub struct RoleNode&lt;R, L: kv::Store&gt; {
</a><a href="#h10-4-26" id="h10-4-26" class="i">+pub struct RoleNode&lt;R, L: log::Store&gt; {
</a>     id: String,
     peers: Vec&lt;String&gt;,
     term: u64,
<a href="#h10-5" id="h10-5" class="h">@@ -156,7 +149,7 @@ pub struct RoleNode&lt;R, L: kv::Store&gt; {
</a>     role: R,
 }
 
<a href="#h10-5-3" id="h10-5-3" class="d">-impl&lt;R, L: kv::Store&gt; RoleNode&lt;R, L&gt; {
</a><a href="#h10-5-4" id="h10-5-4" class="i">+impl&lt;R, L: log::Store&gt; RoleNode&lt;R, L&gt; {
</a>     /// Transforms the node into another role.
     fn become_role&lt;T&gt;(self, role: T) -&gt; Result&lt;RoleNode&lt;T, L&gt;, Error&gt; {
         Ok(RoleNode {
<a href="#h10-6" id="h10-6" class="h">@@ -204,13 +197,6 @@ impl&lt;R, L: kv::Store&gt; RoleNode&lt;R, L&gt; {
</a>         (self.peers.len() as u64 + 1) / 2 + 1
     }
 
<a href="#h10-6-3" id="h10-6-3" class="d">-    /// Updates the current term and stores it in the log
</a><a href="#h10-6-4" id="h10-6-4" class="d">-    fn save_term(&amp;mut self, term: u64, voted_for: Option&lt;&amp;str&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-6-5" id="h10-6-5" class="d">-        self.log.save_term(term, voted_for)?;
</a><a href="#h10-6-6" id="h10-6-6" class="d">-        self.term = term;
</a><a href="#h10-6-7" id="h10-6-7" class="d">-        Ok(())
</a><a href="#h10-6-8" id="h10-6-8" class="d">-    }
</a><a href="#h10-6-9" id="h10-6-9" class="d">-
</a>     /// Sends an event
     fn send(&amp;self, to: Address, event: Event) -&gt; Result&lt;(), Error&gt; {
         let msg = Message { term: self.term, from: Address::Local, to, event };
<a href="#h10-7" id="h10-7" class="h">@@ -268,11 +254,11 @@ mod tests {
</a>         assert_eq!(msgs, actual);
     }
 
<a href="#h10-7-3" id="h10-7-3" class="d">-    pub struct NodeAsserter&lt;&#39;a, L: kv::Store&gt; {
</a><a href="#h10-7-4" id="h10-7-4" class="i">+    pub struct NodeAsserter&lt;&#39;a, L: log::Store&gt; {
</a>         node: &amp;&#39;a Node&lt;L&gt;,
     }
 
<a href="#h10-7-8" id="h10-7-8" class="d">-    impl&lt;&#39;a, L: kv::Store&gt; NodeAsserter&lt;&#39;a, L&gt; {
</a><a href="#h10-7-9" id="h10-7-9" class="i">+    impl&lt;&#39;a, L: log::Store&gt; NodeAsserter&lt;&#39;a, L&gt; {
</a>         pub fn new(node: &amp;&#39;a Node&lt;L&gt;) -&gt; Self {
             Self { node }
         }
<a href="#h10-8" id="h10-8" class="h">@@ -286,26 +272,23 @@ mod tests {
</a>         }
 
         pub fn committed(self, index: u64) -&gt; Self {
<a href="#h10-8-3" id="h10-8-3" class="d">-            let (commit_index, _) = self.log().get_committed();
</a><a href="#h10-8-4" id="h10-8-4" class="d">-            assert_eq!(index, commit_index, &quot;Unexpected committed index&quot;);
</a><a href="#h10-8-5" id="h10-8-5" class="i">+            assert_eq!(index, self.log().commit_index, &quot;Unexpected committed index&quot;);
</a>             self
         }
 
         pub fn last(self, index: u64) -&gt; Self {
<a href="#h10-8-10" id="h10-8-10" class="d">-            let (last_index, _) = self.log().get_last();
</a><a href="#h10-8-11" id="h10-8-11" class="d">-            assert_eq!(index, last_index, &quot;Unexpected last index&quot;);
</a><a href="#h10-8-12" id="h10-8-12" class="i">+            assert_eq!(index, self.log().last_index, &quot;Unexpected last index&quot;);
</a>             self
         }
 
         pub fn entry(self, entry: Entry) -&gt; Self {
<a href="#h10-8-17" id="h10-8-17" class="d">-            let (last_index, _) = self.log().get_last();
</a><a href="#h10-8-18" id="h10-8-18" class="d">-            assert!(entry.index &lt;= last_index, &quot;Index beyond last entry&quot;);
</a><a href="#h10-8-19" id="h10-8-19" class="i">+            assert!(entry.index &lt;= self.log().last_index, &quot;Index beyond last entry&quot;);
</a>             assert_eq!(entry, self.log().get(entry.index).unwrap().unwrap());
             self
         }
 
         pub fn entries(self, entries: Vec&lt;Entry&gt;) -&gt; Self {
<a href="#h10-8-25" id="h10-8-25" class="d">-            assert_eq!(entries, self.log().range(0..).unwrap());
</a><a href="#h10-8-26" id="h10-8-26" class="i">+            assert_eq!(entries, self.log().scan(0..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;().unwrap());
</a>             self
         }
 
<a href="#h10-9" id="h10-9" class="h">@@ -413,11 +396,11 @@ mod tests {
</a>         }
     }
 
<a href="#h10-9-3" id="h10-9-3" class="d">-    pub fn assert_node&lt;L: kv::Store&gt;(node: &amp;Node&lt;L&gt;) -&gt; NodeAsserter&lt;L&gt; {
</a><a href="#h10-9-4" id="h10-9-4" class="i">+    pub fn assert_node&lt;L: log::Store&gt;(node: &amp;Node&lt;L&gt;) -&gt; NodeAsserter&lt;L&gt; {
</a>         NodeAsserter::new(node)
     }
 
<a href="#h10-9-8" id="h10-9-8" class="d">-    fn setup_rolenode() -&gt; Result&lt;(RoleNode&lt;(), kv::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;), Error&gt;
</a><a href="#h10-9-9" id="h10-9-9" class="i">+    fn setup_rolenode() -&gt; Result&lt;(RoleNode&lt;(), log::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;), Error&gt;
</a>     {
         setup_rolenode_peers(vec![&quot;b&quot;.into(), &quot;c&quot;.into()])
     }
<a href="#h10-10" id="h10-10" class="h">@@ -425,7 +408,7 @@ mod tests {
</a>     #[allow(clippy::type_complexity)]
     fn setup_rolenode_peers(
         peers: Vec&lt;String&gt;,
<a href="#h10-10-3" id="h10-10-3" class="d">-    ) -&gt; Result&lt;(RoleNode&lt;(), kv::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;), Error&gt; {
</a><a href="#h10-10-4" id="h10-10-4" class="i">+    ) -&gt; Result&lt;(RoleNode&lt;(), log::Test&gt;, mpsc::UnboundedReceiver&lt;Message&gt;), Error&gt; {
</a>         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, _) = mpsc::unbounded_channel();
         let node = RoleNode {
<a href="#h10-11" id="h10-11" class="h">@@ -433,7 +416,7 @@ mod tests {
</a>             id: &quot;a&quot;.into(),
             peers,
             term: 1,
<a href="#h10-11-3" id="h10-11-3" class="d">-            log: Log::new(kv::Test::new())?,
</a><a href="#h10-11-4" id="h10-11-4" class="i">+            log: Log::new(log::Test::new())?,
</a>             node_tx,
             state_tx,
             proxied_reqs: HashMap::new(),
<a href="#h10-12" id="h10-12" class="h">@@ -448,7 +431,7 @@ mod tests {
</a>         let node = Node::new(
             &quot;a&quot;,
             vec![&quot;b&quot;.into(), &quot;c&quot;.into()],
<a href="#h10-12-3" id="h10-12-3" class="d">-            Log::new(kv::Test::new())?,
</a><a href="#h10-12-4" id="h10-12-4" class="i">+            Log::new(log::Test::new())?,
</a>             TestState::new(0),
             node_tx,
         )
<a href="#h10-13" id="h10-13" class="h">@@ -467,7 +450,7 @@ mod tests {
</a>     #[tokio::test]
     async fn new_loads_term() -&gt; Result&lt;(), Error&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h10-13-3" id="h10-13-3" class="d">-        let store = kv::Test::new();
</a><a href="#h10-13-4" id="h10-13-4" class="i">+        let store = log::Test::new();
</a>         Log::new(store.clone())?.save_term(3, Some(&quot;c&quot;))?;
         let node = Node::new(
             &quot;a&quot;,
<a href="#h10-14" id="h10-14" class="h">@@ -487,7 +470,7 @@ mod tests {
</a>     #[tokio::test(core_threads = 2)]
     async fn new_state_apply_all() -&gt; Result&lt;(), Error&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h10-14-3" id="h10-14-3" class="d">-        let mut log = Log::new(kv::Test::new())?;
</a><a href="#h10-14-4" id="h10-14-4" class="i">+        let mut log = Log::new(log::Test::new())?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
<a href="#h10-15" id="h10-15" class="h">@@ -505,7 +488,7 @@ mod tests {
</a>     #[tokio::test(core_threads = 2)]
     async fn new_state_apply_partial() -&gt; Result&lt;(), Error&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h10-15-3" id="h10-15-3" class="d">-        let mut log = Log::new(kv::Test::new())?;
</a><a href="#h10-15-4" id="h10-15-4" class="i">+        let mut log = Log::new(log::Test::new())?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
<a href="#h10-16" id="h10-16" class="h">@@ -523,7 +506,7 @@ mod tests {
</a>     #[tokio::test(core_threads = 2)]
     async fn new_state_apply_missing() -&gt; Result&lt;(), Error&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
<a href="#h10-16-3" id="h10-16-3" class="d">-        let mut log = Log::new(kv::Test::new())?;
</a><a href="#h10-16-4" id="h10-16-4" class="i">+        let mut log = Log::new(log::Test::new())?;
</a>         log.append(1, Some(vec![0x01]))?;
         log.append(2, None)?;
         log.append(2, Some(vec![0x02]))?;
<a href="#h10-17" id="h10-17" class="h">@@ -544,7 +527,7 @@ mod tests {
</a>     async fn new_single() -&gt; Result&lt;(), Error&gt; {
         let (node_tx, _) = mpsc::unbounded_channel();
         let node =
<a href="#h10-17-3" id="h10-17-3" class="d">-            Node::new(&quot;a&quot;, vec![], Log::new(kv::Test::new())?, TestState::new(0), node_tx).await?;
</a><a href="#h10-17-4" id="h10-17-4" class="i">+            Node::new(&quot;a&quot;, vec![], Log::new(log::Test::new())?, TestState::new(0), node_tx).await?;
</a>         match node {
             Node::Leader(rolenode) =&gt; {
                 assert_eq!(rolenode.id, &quot;a&quot;.to_owned());
<a href="#h10-18" id="h10-18" class="h">@@ -595,12 +578,4 @@ mod tests {
</a>         );
         Ok(())
     }
<a href="#h10-18-3" id="h10-18-3" class="d">-
</a><a href="#h10-18-4" id="h10-18-4" class="d">-    #[test]
</a><a href="#h10-18-5" id="h10-18-5" class="d">-    fn save_term() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h10-18-6" id="h10-18-6" class="d">-        let (mut node, _) = setup_rolenode()?;
</a><a href="#h10-18-7" id="h10-18-7" class="d">-        node.save_term(4, Some(&quot;b&quot;))?;
</a><a href="#h10-18-8" id="h10-18-8" class="d">-        assert_eq!(node.log.load_term()?, (4, Some(&quot;b&quot;.into())));
</a><a href="#h10-18-9" id="h10-18-9" class="d">-        Ok(())
</a><a href="#h10-18-10" id="h10-18-10" class="d">-    }
</a> }
<b>diff --git a/<a id="h11" href="../file/src/raft/server.rs.html">src/raft/server.rs</a> b/<a href="../file/src/raft/server.rs.html">src/raft/server.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -1,9 +1,9 @@
</a> use super::{Address, Event, Log, Message, Node, Request, Response, State};
<a href="#h11-0-1" id="h11-0-1" class="d">-use crate::storage::kv;
</a><a href="#h11-0-2" id="h11-0-2" class="i">+use crate::storage::log;
</a> use crate::Error;
 
<a href="#h11-0-5" id="h11-0-5" class="i">+use ::log::{debug, error};
</a> use futures::{sink::SinkExt as _, FutureExt as _};
<a href="#h11-0-7" id="h11-0-7" class="d">-use log::{debug, error};
</a> use std::collections::HashMap;
 use std::time::Duration;
 use tokio::net::{TcpListener, TcpStream};
<a href="#h11-1" id="h11-1" class="h">@@ -16,13 +16,13 @@ use uuid::Uuid;
</a> const TICK: Duration = Duration::from_millis(100);
 
 /// A Raft server.
<a href="#h11-1-3" id="h11-1-3" class="d">-pub struct Server&lt;L: kv::Store&gt; {
</a><a href="#h11-1-4" id="h11-1-4" class="i">+pub struct Server&lt;L: log::Store&gt; {
</a>     node: Node&lt;L&gt;,
     peers: HashMap&lt;String, String&gt;,
     node_rx: mpsc::UnboundedReceiver&lt;Message&gt;,
 }
 
<a href="#h11-1-10" id="h11-1-10" class="d">-impl&lt;L: kv::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a><a href="#h11-1-11" id="h11-1-11" class="i">+impl&lt;L: log::Store + Send + &#39;static&gt; Server&lt;L&gt; {
</a>     /// Creates a new Raft cluster
     pub async fn new&lt;S: State + Send + &#39;static&gt;(
         id: &amp;str,
<b>diff --git a/<a id="h12" href="../file/src/raft/state.rs.html">src/raft/state.rs</a> b/<a href="../file/src/raft/state.rs.html">src/raft/state.rs</a></b>
<a href="#h12-0" id="h12-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h12-0-0" id="h12-0-0" class="d">-use super::{Address, Entry, Event, Message, Response, Status};
</a><a href="#h12-0-1" id="h12-0-1" class="i">+use super::{Address, Entry, Event, Message, Response, Scan, Status};
</a> use crate::Error;
 
 use log::{debug, error};
<a href="#h12-1" id="h12-1" class="h">@@ -84,14 +84,10 @@ impl Driver {
</a>         Ok(())
     }
 
<a href="#h12-1-3" id="h12-1-3" class="d">-    /// Replays a set of log entries, for initial sync.
</a><a href="#h12-1-4" id="h12-1-4" class="d">-    /// FIXME Should take a log iterator when implemented.
</a><a href="#h12-1-5" id="h12-1-5" class="d">-    pub async fn replay&lt;S: State&gt;(
</a><a href="#h12-1-6" id="h12-1-6" class="d">-        &amp;mut self,
</a><a href="#h12-1-7" id="h12-1-7" class="d">-        state: &amp;mut S,
</a><a href="#h12-1-8" id="h12-1-8" class="d">-        entries: Vec&lt;Entry&gt;,
</a><a href="#h12-1-9" id="h12-1-9" class="d">-    ) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-1-10" id="h12-1-10" class="d">-        for entry in entries.into_iter() {
</a><a href="#h12-1-11" id="h12-1-11" class="i">+    /// Synchronously (re)plays a set of log entries, for initial sync.
</a><a href="#h12-1-12" id="h12-1-12" class="i">+    pub fn replay&lt;&#39;a, S: State&gt;(&amp;mut self, state: &amp;mut S, mut scan: Scan&lt;&#39;a&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h12-1-13" id="h12-1-13" class="i">+        while let Some(entry) = scan.next().transpose()? {
</a><a href="#h12-1-14" id="h12-1-14" class="i">+            debug!(&quot;Replaying {:?}&quot;, entry);
</a>             if let Some(command) = entry.command {
                 match state.mutate(entry.index, command) {
                     Err(error @ Error::Internal(_)) =&gt; return Err(error),
<b>diff --git a/<a id="h13" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h13-0" id="h13-0" class="h">@@ -4,11 +4,11 @@ use crate::sql::engine::{Engine as _, Mode};
</a> use crate::sql::execution::ResultSet;
 use crate::sql::schema::{Catalog as _, Table};
 use crate::sql::types::Row;
<a href="#h13-0-3" id="h13-0-3" class="d">-use crate::storage::kv;
</a><a href="#h13-0-4" id="h13-0-4" class="i">+use crate::storage::{kv, log};
</a> use crate::Error;
 
<a href="#h13-0-7" id="h13-0-7" class="i">+use ::log::{error, info};
</a> use futures::sink::SinkExt as _;
<a href="#h13-0-9" id="h13-0-9" class="d">-use log::{error, info};
</a> use serde_derive::{Deserialize, Serialize};
 use std::collections::HashMap;
 use std::fs;
<a href="#h13-1" id="h13-1" class="h">@@ -20,27 +20,26 @@ use tokio_util::codec::{Framed, LengthDelimitedCodec};
</a> 
 /// A toyDB server.
 pub struct Server {
<a href="#h13-1-3" id="h13-1-3" class="d">-    raft: raft::Server&lt;kv::ILog&gt;,
</a><a href="#h13-1-4" id="h13-1-4" class="i">+    raft: raft::Server&lt;log::Hybrid&gt;,
</a>     raft_listener: Option&lt;TcpListener&gt;,
     sql_listener: Option&lt;TcpListener&gt;,
 }
 
 impl Server {
     /// Creates a new toyDB server.
<a href="#h13-1-11" id="h13-1-11" class="d">-    pub async fn new(id: &amp;str, peers: HashMap&lt;String, String&gt;, dir: &amp;str) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h13-1-12" id="h13-1-12" class="i">+    pub async fn new(
</a><a href="#h13-1-13" id="h13-1-13" class="i">+        id: &amp;str,
</a><a href="#h13-1-14" id="h13-1-14" class="i">+        peers: HashMap&lt;String, String&gt;,
</a><a href="#h13-1-15" id="h13-1-15" class="i">+        dir: &amp;str,
</a><a href="#h13-1-16" id="h13-1-16" class="i">+        sync: bool,
</a><a href="#h13-1-17" id="h13-1-17" class="i">+    ) -&gt; Result&lt;Self, Error&gt; {
</a>         let path = Path::new(dir);
         fs::create_dir_all(path)?;
         Ok(Server {
             raft: raft::Server::new(
                 id,
                 peers,
<a href="#h13-1-24" id="h13-1-24" class="d">-                raft::Log::new(kv::ILog::new(
</a><a href="#h13-1-25" id="h13-1-25" class="d">-                    fs::OpenOptions::new()
</a><a href="#h13-1-26" id="h13-1-26" class="d">-                        .read(true)
</a><a href="#h13-1-27" id="h13-1-27" class="d">-                        .write(true)
</a><a href="#h13-1-28" id="h13-1-28" class="d">-                        .create(true)
</a><a href="#h13-1-29" id="h13-1-29" class="d">-                        .open(path.join(&quot;raft&quot;))?,
</a><a href="#h13-1-30" id="h13-1-30" class="d">-                )?)?,
</a><a href="#h13-1-31" id="h13-1-31" class="i">+                raft::Log::new(log::Hybrid::new(&amp;path, sync)?)?,
</a>                 // Use an in-memory database since the Raft log is durable
                 sql::engine::Raft::new_state(kv::MVCC::new(kv::Memory::new()))?,
             )
<b>diff --git a/<a id="h14" href="../file/src/storage/kv/ilog.rs.html">src/storage/kv/ilog.rs</a> b/<a href="../file/src/storage/kv/ilog.rs.html">src/storage/kv/ilog.rs</a></b>
<a href="#h14-0" id="h14-0" class="h">@@ -1,116 +0,0 @@
</a><a href="#h14-0-0" id="h14-0-0" class="d">-//! iLog is an indexed log. Changed key/value pairs are written sequentially to a file
</a><a href="#h14-0-1" id="h14-0-1" class="d">-//! (MessagePack-encoded), and an in-memory B-tree is used to index keys to locations in the
</a><a href="#h14-0-2" id="h14-0-2" class="d">-//! log. It is an initial prototype until a better storage backend is written.
</a><a href="#h14-0-3" id="h14-0-3" class="d">-
</a><a href="#h14-0-4" id="h14-0-4" class="d">-use super::{Scan, Store};
</a><a href="#h14-0-5" id="h14-0-5" class="d">-use crate::utility::{deserialize_read, serialize};
</a><a href="#h14-0-6" id="h14-0-6" class="d">-use crate::Error;
</a><a href="#h14-0-7" id="h14-0-7" class="d">-
</a><a href="#h14-0-8" id="h14-0-8" class="d">-use serde_derive::{Deserialize, Serialize};
</a><a href="#h14-0-9" id="h14-0-9" class="d">-use std::collections::BTreeMap;
</a><a href="#h14-0-10" id="h14-0-10" class="d">-use std::fs::File;
</a><a href="#h14-0-11" id="h14-0-11" class="d">-use std::io::{Seek as _, SeekFrom, Write as _};
</a><a href="#h14-0-12" id="h14-0-12" class="d">-use std::sync::RwLock;
</a><a href="#h14-0-13" id="h14-0-13" class="d">-
</a><a href="#h14-0-14" id="h14-0-14" class="d">-/// A log entry
</a><a href="#h14-0-15" id="h14-0-15" class="d">-#[derive(Debug, PartialEq, Serialize, Deserialize)]
</a><a href="#h14-0-16" id="h14-0-16" class="d">-struct Entry {
</a><a href="#h14-0-17" id="h14-0-17" class="d">-    key: Vec&lt;u8&gt;,
</a><a href="#h14-0-18" id="h14-0-18" class="d">-    value: Option&lt;Vec&lt;u8&gt;&gt;,
</a><a href="#h14-0-19" id="h14-0-19" class="d">-}
</a><a href="#h14-0-20" id="h14-0-20" class="d">-
</a><a href="#h14-0-21" id="h14-0-21" class="d">-/// A B-tree indexed log
</a><a href="#h14-0-22" id="h14-0-22" class="d">-pub struct ILog {
</a><a href="#h14-0-23" id="h14-0-23" class="d">-    file: RwLock&lt;File&gt;,
</a><a href="#h14-0-24" id="h14-0-24" class="d">-    index: BTreeMap&lt;Vec&lt;u8&gt;, u64&gt;,
</a><a href="#h14-0-25" id="h14-0-25" class="d">-}
</a><a href="#h14-0-26" id="h14-0-26" class="d">-
</a><a href="#h14-0-27" id="h14-0-27" class="d">-impl ILog {
</a><a href="#h14-0-28" id="h14-0-28" class="d">-    /// Creates a new ILog.
</a><a href="#h14-0-29" id="h14-0-29" class="d">-    pub fn new(mut file: File) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h14-0-30" id="h14-0-30" class="d">-        let index = Self::build_index(&amp;mut file)?;
</a><a href="#h14-0-31" id="h14-0-31" class="d">-        Ok(Self { file: RwLock::new(file), index })
</a><a href="#h14-0-32" id="h14-0-32" class="d">-    }
</a><a href="#h14-0-33" id="h14-0-33" class="d">-
</a><a href="#h14-0-34" id="h14-0-34" class="d">-    /// Builds the index by scanning the file.
</a><a href="#h14-0-35" id="h14-0-35" class="d">-    fn build_index(mut file: &amp;mut File) -&gt; Result&lt;BTreeMap&lt;Vec&lt;u8&gt;, u64&gt;, Error&gt; {
</a><a href="#h14-0-36" id="h14-0-36" class="d">-        let mut index = BTreeMap::new();
</a><a href="#h14-0-37" id="h14-0-37" class="d">-        let mut pos = file.seek(SeekFrom::Start(0))?;
</a><a href="#h14-0-38" id="h14-0-38" class="d">-        while let Some(entry) = deserialize_read::&lt;_, Entry&gt;(&amp;mut file)? {
</a><a href="#h14-0-39" id="h14-0-39" class="d">-            index.insert(entry.key, pos);
</a><a href="#h14-0-40" id="h14-0-40" class="d">-            pos = file.seek(SeekFrom::Current(0))?;
</a><a href="#h14-0-41" id="h14-0-41" class="d">-        }
</a><a href="#h14-0-42" id="h14-0-42" class="d">-        Ok(index)
</a><a href="#h14-0-43" id="h14-0-43" class="d">-    }
</a><a href="#h14-0-44" id="h14-0-44" class="d">-
</a><a href="#h14-0-45" id="h14-0-45" class="d">-    /// Loads an entry from a position.
</a><a href="#h14-0-46" id="h14-0-46" class="d">-    fn load(&amp;self, pos: u64) -&gt; Result&lt;Entry, Error&gt; {
</a><a href="#h14-0-47" id="h14-0-47" class="d">-        let mut cursor = self.file.write()?;
</a><a href="#h14-0-48" id="h14-0-48" class="d">-        cursor.seek(SeekFrom::Start(pos))?;
</a><a href="#h14-0-49" id="h14-0-49" class="d">-        deserialize_read(&amp;*cursor)?.ok_or_else(|| Error::Value(&quot;No log entry found&quot;.into()))
</a><a href="#h14-0-50" id="h14-0-50" class="d">-    }
</a><a href="#h14-0-51" id="h14-0-51" class="d">-
</a><a href="#h14-0-52" id="h14-0-52" class="d">-    /// Saves an entry by appending it to the log, returning its position.
</a><a href="#h14-0-53" id="h14-0-53" class="d">-    fn save(&amp;mut self, entry: &amp;Entry) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h14-0-54" id="h14-0-54" class="d">-        let mut cursor = self.file.write()?;
</a><a href="#h14-0-55" id="h14-0-55" class="d">-        let pos = cursor.seek(SeekFrom::End(0))?;
</a><a href="#h14-0-56" id="h14-0-56" class="d">-        cursor.write_all(&amp;serialize(entry)?)?;
</a><a href="#h14-0-57" id="h14-0-57" class="d">-        Ok(pos)
</a><a href="#h14-0-58" id="h14-0-58" class="d">-    }
</a><a href="#h14-0-59" id="h14-0-59" class="d">-}
</a><a href="#h14-0-60" id="h14-0-60" class="d">-
</a><a href="#h14-0-61" id="h14-0-61" class="d">-impl Store for ILog {
</a><a href="#h14-0-62" id="h14-0-62" class="d">-    fn delete(&amp;mut self, key: &amp;[u8]) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-63" id="h14-0-63" class="d">-        if self.index.contains_key(key) {
</a><a href="#h14-0-64" id="h14-0-64" class="d">-            self.save(&amp;Entry { key: key.to_vec(), value: None })?;
</a><a href="#h14-0-65" id="h14-0-65" class="d">-            self.index.remove(key);
</a><a href="#h14-0-66" id="h14-0-66" class="d">-        }
</a><a href="#h14-0-67" id="h14-0-67" class="d">-        Ok(())
</a><a href="#h14-0-68" id="h14-0-68" class="d">-    }
</a><a href="#h14-0-69" id="h14-0-69" class="d">-
</a><a href="#h14-0-70" id="h14-0-70" class="d">-    fn get(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h14-0-71" id="h14-0-71" class="d">-        if let Some(pos) = self.index.get(key) {
</a><a href="#h14-0-72" id="h14-0-72" class="d">-            return Ok(self.load(*pos)?.value);
</a><a href="#h14-0-73" id="h14-0-73" class="d">-        }
</a><a href="#h14-0-74" id="h14-0-74" class="d">-        Ok(None)
</a><a href="#h14-0-75" id="h14-0-75" class="d">-    }
</a><a href="#h14-0-76" id="h14-0-76" class="d">-
</a><a href="#h14-0-77" id="h14-0-77" class="d">-    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-78" id="h14-0-78" class="d">-        Ok(self.file.read()?.sync_all()?)
</a><a href="#h14-0-79" id="h14-0-79" class="d">-    }
</a><a href="#h14-0-80" id="h14-0-80" class="d">-
</a><a href="#h14-0-81" id="h14-0-81" class="d">-    fn scan(&amp;self, range: impl std::ops::RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Scan {
</a><a href="#h14-0-82" id="h14-0-82" class="d">-        // FIXME Needs to temporarily buffer results in a Vec to avoid dealing with
</a><a href="#h14-0-83" id="h14-0-83" class="d">-        // trait lifetimes right now.
</a><a href="#h14-0-84" id="h14-0-84" class="d">-        Box::new(
</a><a href="#h14-0-85" id="h14-0-85" class="d">-            self.index
</a><a href="#h14-0-86" id="h14-0-86" class="d">-                .range(range)
</a><a href="#h14-0-87" id="h14-0-87" class="d">-                .filter_map(|(k, p)| match self.load(*p) {
</a><a href="#h14-0-88" id="h14-0-88" class="d">-                    Ok(Entry { value: Some(v), .. }) =&gt; Some(Ok((k.clone(), v))),
</a><a href="#h14-0-89" id="h14-0-89" class="d">-                    Ok(Entry { value: None, .. }) =&gt; None,
</a><a href="#h14-0-90" id="h14-0-90" class="d">-                    Err(err) =&gt; Some(Err(err)),
</a><a href="#h14-0-91" id="h14-0-91" class="d">-                })
</a><a href="#h14-0-92" id="h14-0-92" class="d">-                .collect::&lt;Vec&lt;Result&lt;_, Error&gt;&gt;&gt;()
</a><a href="#h14-0-93" id="h14-0-93" class="d">-                .into_iter(),
</a><a href="#h14-0-94" id="h14-0-94" class="d">-        )
</a><a href="#h14-0-95" id="h14-0-95" class="d">-    }
</a><a href="#h14-0-96" id="h14-0-96" class="d">-
</a><a href="#h14-0-97" id="h14-0-97" class="d">-    fn set(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-98" id="h14-0-98" class="d">-        let pos = self.save(&amp;Entry { key: key.to_vec(), value: Some(value) })?;
</a><a href="#h14-0-99" id="h14-0-99" class="d">-        self.index.insert(key.to_vec(), pos);
</a><a href="#h14-0-100" id="h14-0-100" class="d">-        Ok(())
</a><a href="#h14-0-101" id="h14-0-101" class="d">-    }
</a><a href="#h14-0-102" id="h14-0-102" class="d">-}
</a><a href="#h14-0-103" id="h14-0-103" class="d">-
</a><a href="#h14-0-104" id="h14-0-104" class="d">-#[cfg(test)]
</a><a href="#h14-0-105" id="h14-0-105" class="d">-impl super::TestSuite&lt;ILog&gt; for ILog {
</a><a href="#h14-0-106" id="h14-0-106" class="d">-    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h14-0-107" id="h14-0-107" class="d">-        ILog::new(tempfile::tempfile()?)
</a><a href="#h14-0-108" id="h14-0-108" class="d">-    }
</a><a href="#h14-0-109" id="h14-0-109" class="d">-}
</a><a href="#h14-0-110" id="h14-0-110" class="d">-
</a><a href="#h14-0-111" id="h14-0-111" class="d">-#[test]
</a><a href="#h14-0-112" id="h14-0-112" class="d">-fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h14-0-113" id="h14-0-113" class="d">-    use super::TestSuite;
</a><a href="#h14-0-114" id="h14-0-114" class="d">-    ILog::test()
</a><a href="#h14-0-115" id="h14-0-115" class="d">-}
</a><b>diff --git a/<a id="h15" href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a> b/<a href="../file/src/storage/kv/mod.rs.html">src/storage/kv/mod.rs</a></b>
<a href="#h15-0" id="h15-0" class="h">@@ -1,10 +1,8 @@
</a><a href="#h15-0-0" id="h15-0-0" class="d">-mod ilog;
</a> mod memory;
 pub mod mvcc;
 #[cfg(test)]
 mod test;
 
<a href="#h15-0-6" id="h15-0-6" class="d">-pub use ilog::ILog;
</a> pub use memory::Memory;
 pub use mvcc::MVCC;
 #[cfg(test)]
<b>diff --git a/<a id="h16" href="../file/src/storage/log/hybrid.rs.html">src/storage/log/hybrid.rs</a> b/<a href="../file/src/storage/log/hybrid.rs.html">src/storage/log/hybrid.rs</a></b>
<a href="#h16-0" id="h16-0" class="h">@@ -0,0 +1,287 @@
</a><a href="#h16-0-0" id="h16-0-0" class="i">+use super::{Scan, Store};
</a><a href="#h16-0-1" id="h16-0-1" class="i">+use crate::Error;
</a><a href="#h16-0-2" id="h16-0-2" class="i">+
</a><a href="#h16-0-3" id="h16-0-3" class="i">+use std::cmp::{max, min};
</a><a href="#h16-0-4" id="h16-0-4" class="i">+use std::collections::{BTreeMap, HashMap, VecDeque};
</a><a href="#h16-0-5" id="h16-0-5" class="i">+use std::fs;
</a><a href="#h16-0-6" id="h16-0-6" class="i">+use std::io::{BufReader, BufWriter, Read as _, Seek as _, SeekFrom, Write};
</a><a href="#h16-0-7" id="h16-0-7" class="i">+use std::ops::{Bound, RangeBounds};
</a><a href="#h16-0-8" id="h16-0-8" class="i">+use std::path::Path;
</a><a href="#h16-0-9" id="h16-0-9" class="i">+use std::sync::Mutex;
</a><a href="#h16-0-10" id="h16-0-10" class="i">+
</a><a href="#h16-0-11" id="h16-0-11" class="i">+/// A hybrid log store, storing committed entries in an append-only file, uncommitted entries
</a><a href="#h16-0-12" id="h16-0-12" class="i">+/// in memory, and metadata in a separate file (should be an on-disk key-value store).
</a><a href="#h16-0-13" id="h16-0-13" class="i">+///
</a><a href="#h16-0-14" id="h16-0-14" class="i">+/// The log file contains sequential binary log entries, length-prefixed with a big-endian u64.
</a><a href="#h16-0-15" id="h16-0-15" class="i">+/// Entries are only flushed to disk when they are committed and permanent, thus the file is
</a><a href="#h16-0-16" id="h16-0-16" class="i">+/// written append-only.
</a><a href="#h16-0-17" id="h16-0-17" class="i">+///
</a><a href="#h16-0-18" id="h16-0-18" class="i">+/// An index of entry positions and sizes is maintained in memory. This is rebuilt on startup by
</a><a href="#h16-0-19" id="h16-0-19" class="i">+/// scanning the file, since maintaining the index in a separate file requires additional fsyncing
</a><a href="#h16-0-20" id="h16-0-20" class="i">+/// which is expensive. Since datasets are expected to be small, scanning the file on startup is
</a><a href="#h16-0-21" id="h16-0-21" class="i">+/// reasonably cheap.
</a><a href="#h16-0-22" id="h16-0-22" class="i">+pub struct Hybrid {
</a><a href="#h16-0-23" id="h16-0-23" class="i">+    /// The append-only log file. Protected by a mutex for interior mutability (i.e. read seeks).
</a><a href="#h16-0-24" id="h16-0-24" class="i">+    file: Mutex&lt;fs::File&gt;,
</a><a href="#h16-0-25" id="h16-0-25" class="i">+    /// Index of entry locations and sizes in the log file.
</a><a href="#h16-0-26" id="h16-0-26" class="i">+    index: BTreeMap&lt;u64, (u64, u64)&gt;,
</a><a href="#h16-0-27" id="h16-0-27" class="i">+    /// Uncommitted log entries.
</a><a href="#h16-0-28" id="h16-0-28" class="i">+    uncommitted: VecDeque&lt;Vec&lt;u8&gt;&gt;,
</a><a href="#h16-0-29" id="h16-0-29" class="i">+    /// Metadata cache. Flushed to disk on changes.
</a><a href="#h16-0-30" id="h16-0-30" class="i">+    metadata: HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h16-0-31" id="h16-0-31" class="i">+    /// The file used to store metadata.
</a><a href="#h16-0-32" id="h16-0-32" class="i">+    /// FIXME Should be an on-disk B-tree key-value store.
</a><a href="#h16-0-33" id="h16-0-33" class="i">+    metadata_file: fs::File,
</a><a href="#h16-0-34" id="h16-0-34" class="i">+    /// If true, fsync writes.
</a><a href="#h16-0-35" id="h16-0-35" class="i">+    sync: bool,
</a><a href="#h16-0-36" id="h16-0-36" class="i">+}
</a><a href="#h16-0-37" id="h16-0-37" class="i">+
</a><a href="#h16-0-38" id="h16-0-38" class="i">+impl Hybrid {
</a><a href="#h16-0-39" id="h16-0-39" class="i">+    /// Creates or opens a new hybrid log, with files in the given directory.
</a><a href="#h16-0-40" id="h16-0-40" class="i">+    pub fn new(dir: &amp;Path, sync: bool) -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h16-0-41" id="h16-0-41" class="i">+        let file = fs::OpenOptions::new()
</a><a href="#h16-0-42" id="h16-0-42" class="i">+            .read(true)
</a><a href="#h16-0-43" id="h16-0-43" class="i">+            .write(true)
</a><a href="#h16-0-44" id="h16-0-44" class="i">+            .create(true)
</a><a href="#h16-0-45" id="h16-0-45" class="i">+            .open(dir.join(&quot;raft-log&quot;))?;
</a><a href="#h16-0-46" id="h16-0-46" class="i">+
</a><a href="#h16-0-47" id="h16-0-47" class="i">+        let metadata_file = fs::OpenOptions::new()
</a><a href="#h16-0-48" id="h16-0-48" class="i">+            .read(true)
</a><a href="#h16-0-49" id="h16-0-49" class="i">+            .write(true)
</a><a href="#h16-0-50" id="h16-0-50" class="i">+            .create(true)
</a><a href="#h16-0-51" id="h16-0-51" class="i">+            .open(dir.join(&quot;raft-metadata&quot;))?;
</a><a href="#h16-0-52" id="h16-0-52" class="i">+
</a><a href="#h16-0-53" id="h16-0-53" class="i">+        Ok(Self {
</a><a href="#h16-0-54" id="h16-0-54" class="i">+            index: Self::build_index(&amp;file)?,
</a><a href="#h16-0-55" id="h16-0-55" class="i">+            file: Mutex::new(file),
</a><a href="#h16-0-56" id="h16-0-56" class="i">+            uncommitted: VecDeque::new(),
</a><a href="#h16-0-57" id="h16-0-57" class="i">+            metadata: Self::load_metadata(&amp;metadata_file)?,
</a><a href="#h16-0-58" id="h16-0-58" class="i">+            metadata_file,
</a><a href="#h16-0-59" id="h16-0-59" class="i">+            sync,
</a><a href="#h16-0-60" id="h16-0-60" class="i">+        })
</a><a href="#h16-0-61" id="h16-0-61" class="i">+    }
</a><a href="#h16-0-62" id="h16-0-62" class="i">+
</a><a href="#h16-0-63" id="h16-0-63" class="i">+    /// Builds the index by scanning the log file.
</a><a href="#h16-0-64" id="h16-0-64" class="i">+    fn build_index(file: &amp;fs::File) -&gt; Result&lt;BTreeMap&lt;u64, (u64, u64)&gt;, Error&gt; {
</a><a href="#h16-0-65" id="h16-0-65" class="i">+        let filesize = file.metadata()?.len();
</a><a href="#h16-0-66" id="h16-0-66" class="i">+        let mut bufreader = BufReader::new(file);
</a><a href="#h16-0-67" id="h16-0-67" class="i">+        let mut index = BTreeMap::new();
</a><a href="#h16-0-68" id="h16-0-68" class="i">+        let mut sizebuf = [0; 8];
</a><a href="#h16-0-69" id="h16-0-69" class="i">+        let mut pos = 0;
</a><a href="#h16-0-70" id="h16-0-70" class="i">+        let mut i = 1;
</a><a href="#h16-0-71" id="h16-0-71" class="i">+        while pos &lt; filesize {
</a><a href="#h16-0-72" id="h16-0-72" class="i">+            bufreader.read_exact(&amp;mut sizebuf)?;
</a><a href="#h16-0-73" id="h16-0-73" class="i">+            pos += 8;
</a><a href="#h16-0-74" id="h16-0-74" class="i">+            let size = u64::from_be_bytes(sizebuf);
</a><a href="#h16-0-75" id="h16-0-75" class="i">+            index.insert(i, (pos, size));
</a><a href="#h16-0-76" id="h16-0-76" class="i">+            let mut buf = vec![0; size as usize];
</a><a href="#h16-0-77" id="h16-0-77" class="i">+            bufreader.read_exact(&amp;mut buf)?;
</a><a href="#h16-0-78" id="h16-0-78" class="i">+            pos += size;
</a><a href="#h16-0-79" id="h16-0-79" class="i">+            i += 1;
</a><a href="#h16-0-80" id="h16-0-80" class="i">+        }
</a><a href="#h16-0-81" id="h16-0-81" class="i">+        Ok(index)
</a><a href="#h16-0-82" id="h16-0-82" class="i">+    }
</a><a href="#h16-0-83" id="h16-0-83" class="i">+
</a><a href="#h16-0-84" id="h16-0-84" class="i">+    /// Loads metadata from a file.
</a><a href="#h16-0-85" id="h16-0-85" class="i">+    fn load_metadata(file: &amp;fs::File) -&gt; Result&lt;HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h16-0-86" id="h16-0-86" class="i">+        match serde_cbor::from_reader(file) {
</a><a href="#h16-0-87" id="h16-0-87" class="i">+            Ok(metadata) =&gt; Ok(metadata),
</a><a href="#h16-0-88" id="h16-0-88" class="i">+            Err(err) if err.is_eof() =&gt; Ok(HashMap::new()),
</a><a href="#h16-0-89" id="h16-0-89" class="i">+            Err(err) =&gt; Err(err.into()),
</a><a href="#h16-0-90" id="h16-0-90" class="i">+        }
</a><a href="#h16-0-91" id="h16-0-91" class="i">+    }
</a><a href="#h16-0-92" id="h16-0-92" class="i">+}
</a><a href="#h16-0-93" id="h16-0-93" class="i">+
</a><a href="#h16-0-94" id="h16-0-94" class="i">+impl Store for Hybrid {
</a><a href="#h16-0-95" id="h16-0-95" class="i">+    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h16-0-96" id="h16-0-96" class="i">+        self.uncommitted.push_back(entry);
</a><a href="#h16-0-97" id="h16-0-97" class="i">+        Ok(self.len())
</a><a href="#h16-0-98" id="h16-0-98" class="i">+    }
</a><a href="#h16-0-99" id="h16-0-99" class="i">+
</a><a href="#h16-0-100" id="h16-0-100" class="i">+    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-0-101" id="h16-0-101" class="i">+        if index &gt; self.len() {
</a><a href="#h16-0-102" id="h16-0-102" class="i">+            return Err(Error::Internal(format!(&quot;Cannot commit non-existant index {}&quot;, index)));
</a><a href="#h16-0-103" id="h16-0-103" class="i">+        }
</a><a href="#h16-0-104" id="h16-0-104" class="i">+        if index &lt; self.index.len() as u64 {
</a><a href="#h16-0-105" id="h16-0-105" class="i">+            return Err(Error::Internal(format!(
</a><a href="#h16-0-106" id="h16-0-106" class="i">+                &quot;Cannot commit below current committed index {}&quot;,
</a><a href="#h16-0-107" id="h16-0-107" class="i">+                self.index.len() as u64
</a><a href="#h16-0-108" id="h16-0-108" class="i">+            )));
</a><a href="#h16-0-109" id="h16-0-109" class="i">+        }
</a><a href="#h16-0-110" id="h16-0-110" class="i">+        if index == self.index.len() as u64 {
</a><a href="#h16-0-111" id="h16-0-111" class="i">+            return Ok(());
</a><a href="#h16-0-112" id="h16-0-112" class="i">+        }
</a><a href="#h16-0-113" id="h16-0-113" class="i">+
</a><a href="#h16-0-114" id="h16-0-114" class="i">+        let mut file = self.file.lock()?;
</a><a href="#h16-0-115" id="h16-0-115" class="i">+        let mut pos = file.seek(SeekFrom::End(0))?;
</a><a href="#h16-0-116" id="h16-0-116" class="i">+        let mut bufwriter = BufWriter::new(&amp;mut *file);
</a><a href="#h16-0-117" id="h16-0-117" class="i">+        for i in (self.index.len() as u64 + 1)..=index {
</a><a href="#h16-0-118" id="h16-0-118" class="i">+            let entry = self
</a><a href="#h16-0-119" id="h16-0-119" class="i">+                .uncommitted
</a><a href="#h16-0-120" id="h16-0-120" class="i">+                .pop_front()
</a><a href="#h16-0-121" id="h16-0-121" class="i">+                .ok_or_else(|| Error::Internal(&quot;Unexpected end of uncommitted entries&quot;.into()))?;
</a><a href="#h16-0-122" id="h16-0-122" class="i">+            bufwriter.write_all(&amp;entry.len().to_be_bytes())?;
</a><a href="#h16-0-123" id="h16-0-123" class="i">+            pos += 8;
</a><a href="#h16-0-124" id="h16-0-124" class="i">+            self.index.insert(i, (pos, entry.len() as u64));
</a><a href="#h16-0-125" id="h16-0-125" class="i">+            bufwriter.write_all(&amp;entry)?;
</a><a href="#h16-0-126" id="h16-0-126" class="i">+            pos += entry.len() as u64;
</a><a href="#h16-0-127" id="h16-0-127" class="i">+        }
</a><a href="#h16-0-128" id="h16-0-128" class="i">+        bufwriter.flush()?;
</a><a href="#h16-0-129" id="h16-0-129" class="i">+        drop(bufwriter);
</a><a href="#h16-0-130" id="h16-0-130" class="i">+        if self.sync {
</a><a href="#h16-0-131" id="h16-0-131" class="i">+            file.sync_data()?;
</a><a href="#h16-0-132" id="h16-0-132" class="i">+        }
</a><a href="#h16-0-133" id="h16-0-133" class="i">+        Ok(())
</a><a href="#h16-0-134" id="h16-0-134" class="i">+    }
</a><a href="#h16-0-135" id="h16-0-135" class="i">+
</a><a href="#h16-0-136" id="h16-0-136" class="i">+    fn committed(&amp;self) -&gt; u64 {
</a><a href="#h16-0-137" id="h16-0-137" class="i">+        self.index.len() as u64
</a><a href="#h16-0-138" id="h16-0-138" class="i">+    }
</a><a href="#h16-0-139" id="h16-0-139" class="i">+
</a><a href="#h16-0-140" id="h16-0-140" class="i">+    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h16-0-141" id="h16-0-141" class="i">+        match index {
</a><a href="#h16-0-142" id="h16-0-142" class="i">+            0 =&gt; Ok(None),
</a><a href="#h16-0-143" id="h16-0-143" class="i">+            i if i &lt;= self.index.len() as u64 =&gt; {
</a><a href="#h16-0-144" id="h16-0-144" class="i">+                let (pos, size) = self.index.get(&amp;i).copied().ok_or_else(|| {
</a><a href="#h16-0-145" id="h16-0-145" class="i">+                    Error::Internal(format!(&quot;Indexed position not found for entry {}&quot;, i))
</a><a href="#h16-0-146" id="h16-0-146" class="i">+                })?;
</a><a href="#h16-0-147" id="h16-0-147" class="i">+                let mut entry = vec![0; size as usize];
</a><a href="#h16-0-148" id="h16-0-148" class="i">+                let mut file = self.file.lock()?;
</a><a href="#h16-0-149" id="h16-0-149" class="i">+                file.seek(SeekFrom::Start(pos))?;
</a><a href="#h16-0-150" id="h16-0-150" class="i">+                file.read_exact(&amp;mut entry)?;
</a><a href="#h16-0-151" id="h16-0-151" class="i">+                Ok(Some(entry))
</a><a href="#h16-0-152" id="h16-0-152" class="i">+            }
</a><a href="#h16-0-153" id="h16-0-153" class="i">+            i =&gt; Ok(self.uncommitted.get(i as usize - self.index.len() - 1).cloned()),
</a><a href="#h16-0-154" id="h16-0-154" class="i">+        }
</a><a href="#h16-0-155" id="h16-0-155" class="i">+    }
</a><a href="#h16-0-156" id="h16-0-156" class="i">+
</a><a href="#h16-0-157" id="h16-0-157" class="i">+    fn len(&amp;self) -&gt; u64 {
</a><a href="#h16-0-158" id="h16-0-158" class="i">+        self.index.len() as u64 + self.uncommitted.len() as u64
</a><a href="#h16-0-159" id="h16-0-159" class="i">+    }
</a><a href="#h16-0-160" id="h16-0-160" class="i">+
</a><a href="#h16-0-161" id="h16-0-161" class="i">+    fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan {
</a><a href="#h16-0-162" id="h16-0-162" class="i">+        let start = match range.start_bound() {
</a><a href="#h16-0-163" id="h16-0-163" class="i">+            Bound::Included(0) =&gt; 1,
</a><a href="#h16-0-164" id="h16-0-164" class="i">+            Bound::Included(n) =&gt; *n,
</a><a href="#h16-0-165" id="h16-0-165" class="i">+            Bound::Excluded(n) =&gt; *n + 1,
</a><a href="#h16-0-166" id="h16-0-166" class="i">+            Bound::Unbounded =&gt; 1,
</a><a href="#h16-0-167" id="h16-0-167" class="i">+        };
</a><a href="#h16-0-168" id="h16-0-168" class="i">+        let end = match range.end_bound() {
</a><a href="#h16-0-169" id="h16-0-169" class="i">+            Bound::Included(n) =&gt; *n,
</a><a href="#h16-0-170" id="h16-0-170" class="i">+            Bound::Excluded(0) =&gt; 0,
</a><a href="#h16-0-171" id="h16-0-171" class="i">+            Bound::Excluded(n) =&gt; *n - 1,
</a><a href="#h16-0-172" id="h16-0-172" class="i">+            Bound::Unbounded =&gt; self.len(),
</a><a href="#h16-0-173" id="h16-0-173" class="i">+        };
</a><a href="#h16-0-174" id="h16-0-174" class="i">+
</a><a href="#h16-0-175" id="h16-0-175" class="i">+        let mut scan: Scan = Box::new(std::iter::empty());
</a><a href="#h16-0-176" id="h16-0-176" class="i">+        if start &gt; end {
</a><a href="#h16-0-177" id="h16-0-177" class="i">+            return scan;
</a><a href="#h16-0-178" id="h16-0-178" class="i">+        }
</a><a href="#h16-0-179" id="h16-0-179" class="i">+
</a><a href="#h16-0-180" id="h16-0-180" class="i">+        // Scan committed entries in file
</a><a href="#h16-0-181" id="h16-0-181" class="i">+        if let Some((offset, _)) = self.index.get(&amp;start) {
</a><a href="#h16-0-182" id="h16-0-182" class="i">+            let mut file = self.file.lock().unwrap();
</a><a href="#h16-0-183" id="h16-0-183" class="i">+            file.seek(SeekFrom::Start(*offset - 8)).unwrap(); // seek to length prefix
</a><a href="#h16-0-184" id="h16-0-184" class="i">+            let mut bufreader = BufReader::new(MutexReader(file)); // FIXME Avoid MutexReader
</a><a href="#h16-0-185" id="h16-0-185" class="i">+            scan =
</a><a href="#h16-0-186" id="h16-0-186" class="i">+                Box::new(scan.chain(self.index.range(start..=end).map(move |(_, (_, size))| {
</a><a href="#h16-0-187" id="h16-0-187" class="i">+                    let mut sizebuf = vec![0; 8];
</a><a href="#h16-0-188" id="h16-0-188" class="i">+                    bufreader.read_exact(&amp;mut sizebuf)?;
</a><a href="#h16-0-189" id="h16-0-189" class="i">+                    let mut entry = vec![0; *size as usize];
</a><a href="#h16-0-190" id="h16-0-190" class="i">+                    bufreader.read_exact(&amp;mut entry)?;
</a><a href="#h16-0-191" id="h16-0-191" class="i">+                    Ok(entry)
</a><a href="#h16-0-192" id="h16-0-192" class="i">+                })));
</a><a href="#h16-0-193" id="h16-0-193" class="i">+        }
</a><a href="#h16-0-194" id="h16-0-194" class="i">+
</a><a href="#h16-0-195" id="h16-0-195" class="i">+        // Scan uncommitted entries in memory
</a><a href="#h16-0-196" id="h16-0-196" class="i">+        if end &gt; self.index.len() as u64 {
</a><a href="#h16-0-197" id="h16-0-197" class="i">+            scan = Box::new(
</a><a href="#h16-0-198" id="h16-0-198" class="i">+                scan.chain(
</a><a href="#h16-0-199" id="h16-0-199" class="i">+                    self.uncommitted
</a><a href="#h16-0-200" id="h16-0-200" class="i">+                        .iter()
</a><a href="#h16-0-201" id="h16-0-201" class="i">+                        .skip(start as usize - min(start as usize, self.index.len() + 1))
</a><a href="#h16-0-202" id="h16-0-202" class="i">+                        .take(end as usize - max(start as usize, self.index.len()) + 1)
</a><a href="#h16-0-203" id="h16-0-203" class="i">+                        .cloned()
</a><a href="#h16-0-204" id="h16-0-204" class="i">+                        .map(Ok),
</a><a href="#h16-0-205" id="h16-0-205" class="i">+                ),
</a><a href="#h16-0-206" id="h16-0-206" class="i">+            )
</a><a href="#h16-0-207" id="h16-0-207" class="i">+        }
</a><a href="#h16-0-208" id="h16-0-208" class="i">+
</a><a href="#h16-0-209" id="h16-0-209" class="i">+        scan
</a><a href="#h16-0-210" id="h16-0-210" class="i">+    }
</a><a href="#h16-0-211" id="h16-0-211" class="i">+
</a><a href="#h16-0-212" id="h16-0-212" class="i">+    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h16-0-213" id="h16-0-213" class="i">+        if index &lt; self.index.len() as u64 {
</a><a href="#h16-0-214" id="h16-0-214" class="i">+            return Err(Error::Internal(format!(
</a><a href="#h16-0-215" id="h16-0-215" class="i">+                &quot;Cannot truncate below committed index {}&quot;,
</a><a href="#h16-0-216" id="h16-0-216" class="i">+                self.index.len() as u64
</a><a href="#h16-0-217" id="h16-0-217" class="i">+            )));
</a><a href="#h16-0-218" id="h16-0-218" class="i">+        }
</a><a href="#h16-0-219" id="h16-0-219" class="i">+        self.uncommitted.truncate(index as usize - self.index.len());
</a><a href="#h16-0-220" id="h16-0-220" class="i">+        Ok(self.len())
</a><a href="#h16-0-221" id="h16-0-221" class="i">+    }
</a><a href="#h16-0-222" id="h16-0-222" class="i">+
</a><a href="#h16-0-223" id="h16-0-223" class="i">+    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h16-0-224" id="h16-0-224" class="i">+        Ok(self.metadata.get(key).cloned())
</a><a href="#h16-0-225" id="h16-0-225" class="i">+    }
</a><a href="#h16-0-226" id="h16-0-226" class="i">+
</a><a href="#h16-0-227" id="h16-0-227" class="i">+    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-0-228" id="h16-0-228" class="i">+        self.metadata.insert(key.to_vec(), value);
</a><a href="#h16-0-229" id="h16-0-229" class="i">+        self.metadata_file.set_len(0)?;
</a><a href="#h16-0-230" id="h16-0-230" class="i">+        self.metadata_file.seek(SeekFrom::Start(0))?;
</a><a href="#h16-0-231" id="h16-0-231" class="i">+        serde_cbor::to_writer(&amp;mut self.metadata_file, &amp;self.metadata)?;
</a><a href="#h16-0-232" id="h16-0-232" class="i">+        if self.sync {
</a><a href="#h16-0-233" id="h16-0-233" class="i">+            self.metadata_file.sync_data()?;
</a><a href="#h16-0-234" id="h16-0-234" class="i">+        }
</a><a href="#h16-0-235" id="h16-0-235" class="i">+        Ok(())
</a><a href="#h16-0-236" id="h16-0-236" class="i">+    }
</a><a href="#h16-0-237" id="h16-0-237" class="i">+}
</a><a href="#h16-0-238" id="h16-0-238" class="i">+
</a><a href="#h16-0-239" id="h16-0-239" class="i">+impl Drop for Hybrid {
</a><a href="#h16-0-240" id="h16-0-240" class="i">+    /// Attempt to fsync data on drop, in case we&#39;re running without sync.
</a><a href="#h16-0-241" id="h16-0-241" class="i">+    fn drop(&amp;mut self) {
</a><a href="#h16-0-242" id="h16-0-242" class="i">+        self.metadata_file.sync_all().ok();
</a><a href="#h16-0-243" id="h16-0-243" class="i">+        self.file.lock().map(|f| f.sync_all()).ok();
</a><a href="#h16-0-244" id="h16-0-244" class="i">+    }
</a><a href="#h16-0-245" id="h16-0-245" class="i">+}
</a><a href="#h16-0-246" id="h16-0-246" class="i">+
</a><a href="#h16-0-247" id="h16-0-247" class="i">+struct MutexReader&lt;&#39;a&gt;(std::sync::MutexGuard&lt;&#39;a, fs::File&gt;);
</a><a href="#h16-0-248" id="h16-0-248" class="i">+
</a><a href="#h16-0-249" id="h16-0-249" class="i">+impl&lt;&#39;a&gt; std::io::Read for MutexReader&lt;&#39;a&gt; {
</a><a href="#h16-0-250" id="h16-0-250" class="i">+    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
</a><a href="#h16-0-251" id="h16-0-251" class="i">+        self.0.read(buf)
</a><a href="#h16-0-252" id="h16-0-252" class="i">+    }
</a><a href="#h16-0-253" id="h16-0-253" class="i">+}
</a><a href="#h16-0-254" id="h16-0-254" class="i">+
</a><a href="#h16-0-255" id="h16-0-255" class="i">+#[cfg(test)]
</a><a href="#h16-0-256" id="h16-0-256" class="i">+impl super::TestSuite&lt;Hybrid&gt; for Hybrid {
</a><a href="#h16-0-257" id="h16-0-257" class="i">+    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h16-0-258" id="h16-0-258" class="i">+        let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h16-0-259" id="h16-0-259" class="i">+        Hybrid::new(dir.as_ref(), false)
</a><a href="#h16-0-260" id="h16-0-260" class="i">+    }
</a><a href="#h16-0-261" id="h16-0-261" class="i">+}
</a><a href="#h16-0-262" id="h16-0-262" class="i">+
</a><a href="#h16-0-263" id="h16-0-263" class="i">+#[test]
</a><a href="#h16-0-264" id="h16-0-264" class="i">+fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-0-265" id="h16-0-265" class="i">+    use super::TestSuite;
</a><a href="#h16-0-266" id="h16-0-266" class="i">+    Hybrid::test()
</a><a href="#h16-0-267" id="h16-0-267" class="i">+}
</a><a href="#h16-0-268" id="h16-0-268" class="i">+
</a><a href="#h16-0-269" id="h16-0-269" class="i">+#[test]
</a><a href="#h16-0-270" id="h16-0-270" class="i">+fn test_persistent() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h16-0-271" id="h16-0-271" class="i">+    let dir = tempdir::TempDir::new(&quot;toydb&quot;)?;
</a><a href="#h16-0-272" id="h16-0-272" class="i">+    let mut l = Hybrid::new(dir.as_ref(), true)?;
</a><a href="#h16-0-273" id="h16-0-273" class="i">+
</a><a href="#h16-0-274" id="h16-0-274" class="i">+    l.append(vec![0x01])?;
</a><a href="#h16-0-275" id="h16-0-275" class="i">+    l.append(vec![0x02])?;
</a><a href="#h16-0-276" id="h16-0-276" class="i">+    l.append(vec![0x03])?;
</a><a href="#h16-0-277" id="h16-0-277" class="i">+    l.append(vec![0x04])?;
</a><a href="#h16-0-278" id="h16-0-278" class="i">+    l.append(vec![0x05])?;
</a><a href="#h16-0-279" id="h16-0-279" class="i">+    l.commit(3)?;
</a><a href="#h16-0-280" id="h16-0-280" class="i">+
</a><a href="#h16-0-281" id="h16-0-281" class="i">+    let l = Hybrid::new(dir.as_ref(), true)?;
</a><a href="#h16-0-282" id="h16-0-282" class="i">+
</a><a href="#h16-0-283" id="h16-0-283" class="i">+    assert_eq!(vec![vec![1], vec![2], vec![3]], l.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h16-0-284" id="h16-0-284" class="i">+
</a><a href="#h16-0-285" id="h16-0-285" class="i">+    Ok(())
</a><a href="#h16-0-286" id="h16-0-286" class="i">+}
</a><b>diff --git a/<a id="h17" href="../file/src/storage/log/memory.rs.html">src/storage/log/memory.rs</a> b/<a href="../file/src/storage/log/memory.rs.html">src/storage/log/memory.rs</a></b>
<a href="#h17-0" id="h17-0" class="h">@@ -0,0 +1,109 @@
</a><a href="#h17-0-0" id="h17-0-0" class="i">+use super::Store;
</a><a href="#h17-0-1" id="h17-0-1" class="i">+use crate::Error;
</a><a href="#h17-0-2" id="h17-0-2" class="i">+
</a><a href="#h17-0-3" id="h17-0-3" class="i">+use std::collections::HashMap;
</a><a href="#h17-0-4" id="h17-0-4" class="i">+use std::ops::{Bound, RangeBounds};
</a><a href="#h17-0-5" id="h17-0-5" class="i">+
</a><a href="#h17-0-6" id="h17-0-6" class="i">+// An in-memory log store.
</a><a href="#h17-0-7" id="h17-0-7" class="i">+pub struct Memory {
</a><a href="#h17-0-8" id="h17-0-8" class="i">+    log: Vec&lt;Vec&lt;u8&gt;&gt;,
</a><a href="#h17-0-9" id="h17-0-9" class="i">+    committed: u64,
</a><a href="#h17-0-10" id="h17-0-10" class="i">+    metadata: HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;,
</a><a href="#h17-0-11" id="h17-0-11" class="i">+}
</a><a href="#h17-0-12" id="h17-0-12" class="i">+
</a><a href="#h17-0-13" id="h17-0-13" class="i">+impl Memory {
</a><a href="#h17-0-14" id="h17-0-14" class="i">+    /// Creates a new in-memory log.
</a><a href="#h17-0-15" id="h17-0-15" class="i">+    pub fn new() -&gt; Self {
</a><a href="#h17-0-16" id="h17-0-16" class="i">+        Self { log: Vec::new(), committed: 0, metadata: HashMap::new() }
</a><a href="#h17-0-17" id="h17-0-17" class="i">+    }
</a><a href="#h17-0-18" id="h17-0-18" class="i">+}
</a><a href="#h17-0-19" id="h17-0-19" class="i">+
</a><a href="#h17-0-20" id="h17-0-20" class="i">+impl Store for Memory {
</a><a href="#h17-0-21" id="h17-0-21" class="i">+    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h17-0-22" id="h17-0-22" class="i">+        self.log.push(entry);
</a><a href="#h17-0-23" id="h17-0-23" class="i">+        Ok(self.log.len() as u64)
</a><a href="#h17-0-24" id="h17-0-24" class="i">+    }
</a><a href="#h17-0-25" id="h17-0-25" class="i">+
</a><a href="#h17-0-26" id="h17-0-26" class="i">+    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h17-0-27" id="h17-0-27" class="i">+        if index &gt; self.len() {
</a><a href="#h17-0-28" id="h17-0-28" class="i">+            return Err(Error::Internal(format!(&quot;Cannot commit non-existant index {}&quot;, index)));
</a><a href="#h17-0-29" id="h17-0-29" class="i">+        }
</a><a href="#h17-0-30" id="h17-0-30" class="i">+        if index &lt; self.committed {
</a><a href="#h17-0-31" id="h17-0-31" class="i">+            return Err(Error::Internal(format!(
</a><a href="#h17-0-32" id="h17-0-32" class="i">+                &quot;Cannot commit below current index {}&quot;,
</a><a href="#h17-0-33" id="h17-0-33" class="i">+                self.committed
</a><a href="#h17-0-34" id="h17-0-34" class="i">+            )));
</a><a href="#h17-0-35" id="h17-0-35" class="i">+        }
</a><a href="#h17-0-36" id="h17-0-36" class="i">+        self.committed = index;
</a><a href="#h17-0-37" id="h17-0-37" class="i">+        Ok(())
</a><a href="#h17-0-38" id="h17-0-38" class="i">+    }
</a><a href="#h17-0-39" id="h17-0-39" class="i">+
</a><a href="#h17-0-40" id="h17-0-40" class="i">+    fn committed(&amp;self) -&gt; u64 {
</a><a href="#h17-0-41" id="h17-0-41" class="i">+        self.committed
</a><a href="#h17-0-42" id="h17-0-42" class="i">+    }
</a><a href="#h17-0-43" id="h17-0-43" class="i">+
</a><a href="#h17-0-44" id="h17-0-44" class="i">+    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h17-0-45" id="h17-0-45" class="i">+        match index {
</a><a href="#h17-0-46" id="h17-0-46" class="i">+            0 =&gt; Ok(None),
</a><a href="#h17-0-47" id="h17-0-47" class="i">+            i =&gt; Ok(self.log.get(i as usize - 1).cloned()),
</a><a href="#h17-0-48" id="h17-0-48" class="i">+        }
</a><a href="#h17-0-49" id="h17-0-49" class="i">+    }
</a><a href="#h17-0-50" id="h17-0-50" class="i">+
</a><a href="#h17-0-51" id="h17-0-51" class="i">+    fn len(&amp;self) -&gt; u64 {
</a><a href="#h17-0-52" id="h17-0-52" class="i">+        self.log.len() as u64
</a><a href="#h17-0-53" id="h17-0-53" class="i">+    }
</a><a href="#h17-0-54" id="h17-0-54" class="i">+
</a><a href="#h17-0-55" id="h17-0-55" class="i">+    fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; super::Scan {
</a><a href="#h17-0-56" id="h17-0-56" class="i">+        Box::new(
</a><a href="#h17-0-57" id="h17-0-57" class="i">+            self.log
</a><a href="#h17-0-58" id="h17-0-58" class="i">+                .iter()
</a><a href="#h17-0-59" id="h17-0-59" class="i">+                .take(match range.end_bound() {
</a><a href="#h17-0-60" id="h17-0-60" class="i">+                    Bound::Included(n) =&gt; *n as usize,
</a><a href="#h17-0-61" id="h17-0-61" class="i">+                    Bound::Excluded(0) =&gt; 0,
</a><a href="#h17-0-62" id="h17-0-62" class="i">+                    Bound::Excluded(n) =&gt; *n as usize - 1,
</a><a href="#h17-0-63" id="h17-0-63" class="i">+                    Bound::Unbounded =&gt; std::usize::MAX,
</a><a href="#h17-0-64" id="h17-0-64" class="i">+                })
</a><a href="#h17-0-65" id="h17-0-65" class="i">+                .skip(match range.start_bound() {
</a><a href="#h17-0-66" id="h17-0-66" class="i">+                    Bound::Included(0) =&gt; 0,
</a><a href="#h17-0-67" id="h17-0-67" class="i">+                    Bound::Included(n) =&gt; *n as usize - 1,
</a><a href="#h17-0-68" id="h17-0-68" class="i">+                    Bound::Excluded(n) =&gt; *n as usize,
</a><a href="#h17-0-69" id="h17-0-69" class="i">+                    Bound::Unbounded =&gt; 0,
</a><a href="#h17-0-70" id="h17-0-70" class="i">+                })
</a><a href="#h17-0-71" id="h17-0-71" class="i">+                .cloned()
</a><a href="#h17-0-72" id="h17-0-72" class="i">+                .map(Ok),
</a><a href="#h17-0-73" id="h17-0-73" class="i">+        )
</a><a href="#h17-0-74" id="h17-0-74" class="i">+    }
</a><a href="#h17-0-75" id="h17-0-75" class="i">+
</a><a href="#h17-0-76" id="h17-0-76" class="i">+    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h17-0-77" id="h17-0-77" class="i">+        if index &lt; self.committed {
</a><a href="#h17-0-78" id="h17-0-78" class="i">+            return Err(Error::Internal(format!(
</a><a href="#h17-0-79" id="h17-0-79" class="i">+                &quot;Cannot truncate below committed index {}&quot;,
</a><a href="#h17-0-80" id="h17-0-80" class="i">+                self.committed
</a><a href="#h17-0-81" id="h17-0-81" class="i">+            )));
</a><a href="#h17-0-82" id="h17-0-82" class="i">+        }
</a><a href="#h17-0-83" id="h17-0-83" class="i">+        self.log.truncate(index as usize);
</a><a href="#h17-0-84" id="h17-0-84" class="i">+        Ok(self.log.len() as u64)
</a><a href="#h17-0-85" id="h17-0-85" class="i">+    }
</a><a href="#h17-0-86" id="h17-0-86" class="i">+
</a><a href="#h17-0-87" id="h17-0-87" class="i">+    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h17-0-88" id="h17-0-88" class="i">+        Ok(self.metadata.get(key).cloned())
</a><a href="#h17-0-89" id="h17-0-89" class="i">+    }
</a><a href="#h17-0-90" id="h17-0-90" class="i">+
</a><a href="#h17-0-91" id="h17-0-91" class="i">+    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h17-0-92" id="h17-0-92" class="i">+        self.metadata.insert(key.to_vec(), value);
</a><a href="#h17-0-93" id="h17-0-93" class="i">+        Ok(())
</a><a href="#h17-0-94" id="h17-0-94" class="i">+    }
</a><a href="#h17-0-95" id="h17-0-95" class="i">+}
</a><a href="#h17-0-96" id="h17-0-96" class="i">+
</a><a href="#h17-0-97" id="h17-0-97" class="i">+#[cfg(test)]
</a><a href="#h17-0-98" id="h17-0-98" class="i">+impl super::TestSuite&lt;Memory&gt; for Memory {
</a><a href="#h17-0-99" id="h17-0-99" class="i">+    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h17-0-100" id="h17-0-100" class="i">+        Ok(Memory::new())
</a><a href="#h17-0-101" id="h17-0-101" class="i">+    }
</a><a href="#h17-0-102" id="h17-0-102" class="i">+}
</a><a href="#h17-0-103" id="h17-0-103" class="i">+
</a><a href="#h17-0-104" id="h17-0-104" class="i">+#[test]
</a><a href="#h17-0-105" id="h17-0-105" class="i">+fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h17-0-106" id="h17-0-106" class="i">+    use super::TestSuite;
</a><a href="#h17-0-107" id="h17-0-107" class="i">+    Memory::test()
</a><a href="#h17-0-108" id="h17-0-108" class="i">+}
</a><b>diff --git a/<a id="h18" href="../file/src/storage/log/mod.rs.html">src/storage/log/mod.rs</a> b/<a href="../file/src/storage/log/mod.rs.html">src/storage/log/mod.rs</a></b>
<a href="#h18-0" id="h18-0" class="h">@@ -0,0 +1,158 @@
</a><a href="#h18-0-0" id="h18-0-0" class="i">+mod hybrid;
</a><a href="#h18-0-1" id="h18-0-1" class="i">+mod memory;
</a><a href="#h18-0-2" id="h18-0-2" class="i">+#[cfg(test)]
</a><a href="#h18-0-3" id="h18-0-3" class="i">+mod test;
</a><a href="#h18-0-4" id="h18-0-4" class="i">+
</a><a href="#h18-0-5" id="h18-0-5" class="i">+pub use hybrid::Hybrid;
</a><a href="#h18-0-6" id="h18-0-6" class="i">+pub use memory::Memory;
</a><a href="#h18-0-7" id="h18-0-7" class="i">+#[cfg(test)]
</a><a href="#h18-0-8" id="h18-0-8" class="i">+pub use test::Test;
</a><a href="#h18-0-9" id="h18-0-9" class="i">+
</a><a href="#h18-0-10" id="h18-0-10" class="i">+use crate::Error;
</a><a href="#h18-0-11" id="h18-0-11" class="i">+
</a><a href="#h18-0-12" id="h18-0-12" class="i">+use std::ops::RangeBounds;
</a><a href="#h18-0-13" id="h18-0-13" class="i">+
</a><a href="#h18-0-14" id="h18-0-14" class="i">+/// A log store. Entry indexes are 1-based, to match Raft semantics.
</a><a href="#h18-0-15" id="h18-0-15" class="i">+pub trait Store {
</a><a href="#h18-0-16" id="h18-0-16" class="i">+    /// Appends a log entry, returning its index.
</a><a href="#h18-0-17" id="h18-0-17" class="i">+    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64, Error&gt;;
</a><a href="#h18-0-18" id="h18-0-18" class="i">+
</a><a href="#h18-0-19" id="h18-0-19" class="i">+    /// Commits log entries up to and including the given index, making them immutable.
</a><a href="#h18-0-20" id="h18-0-20" class="i">+    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h18-0-21" id="h18-0-21" class="i">+
</a><a href="#h18-0-22" id="h18-0-22" class="i">+    /// Returns the committed index, if any.
</a><a href="#h18-0-23" id="h18-0-23" class="i">+    fn committed(&amp;self) -&gt; u64;
</a><a href="#h18-0-24" id="h18-0-24" class="i">+
</a><a href="#h18-0-25" id="h18-0-25" class="i">+    /// Fetches a log entry, if it exists.
</a><a href="#h18-0-26" id="h18-0-26" class="i">+    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt;;
</a><a href="#h18-0-27" id="h18-0-27" class="i">+
</a><a href="#h18-0-28" id="h18-0-28" class="i">+    /// Returns the number of entries in the log.
</a><a href="#h18-0-29" id="h18-0-29" class="i">+    fn len(&amp;self) -&gt; u64;
</a><a href="#h18-0-30" id="h18-0-30" class="i">+
</a><a href="#h18-0-31" id="h18-0-31" class="i">+    /// Scans the log between the given indexes.
</a><a href="#h18-0-32" id="h18-0-32" class="i">+    fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan;
</a><a href="#h18-0-33" id="h18-0-33" class="i">+
</a><a href="#h18-0-34" id="h18-0-34" class="i">+    /// Truncates the log be removing any entries above the given index, and returns the
</a><a href="#h18-0-35" id="h18-0-35" class="i">+    /// highest index. Errors if asked to truncate any committed entries.
</a><a href="#h18-0-36" id="h18-0-36" class="i">+    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt;;
</a><a href="#h18-0-37" id="h18-0-37" class="i">+
</a><a href="#h18-0-38" id="h18-0-38" class="i">+    /// Gets a metadata value.
</a><a href="#h18-0-39" id="h18-0-39" class="i">+    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt;;
</a><a href="#h18-0-40" id="h18-0-40" class="i">+
</a><a href="#h18-0-41" id="h18-0-41" class="i">+    /// Sets a metadata value.
</a><a href="#h18-0-42" id="h18-0-42" class="i">+    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt;;
</a><a href="#h18-0-43" id="h18-0-43" class="i">+
</a><a href="#h18-0-44" id="h18-0-44" class="i">+    /// Returns true if the log has no entries.
</a><a href="#h18-0-45" id="h18-0-45" class="i">+    fn is_empty(&amp;self) -&gt; bool {
</a><a href="#h18-0-46" id="h18-0-46" class="i">+        self.len() == 0
</a><a href="#h18-0-47" id="h18-0-47" class="i">+    }
</a><a href="#h18-0-48" id="h18-0-48" class="i">+}
</a><a href="#h18-0-49" id="h18-0-49" class="i">+
</a><a href="#h18-0-50" id="h18-0-50" class="i">+/// Iterator over a log range.
</a><a href="#h18-0-51" id="h18-0-51" class="i">+pub type Scan&lt;&#39;a&gt; = Box&lt;dyn Iterator&lt;Item = Result&lt;Vec&lt;u8&gt;, Error&gt;&gt; + &#39;a&gt;;
</a><a href="#h18-0-52" id="h18-0-52" class="i">+
</a><a href="#h18-0-53" id="h18-0-53" class="i">+#[cfg(test)]
</a><a href="#h18-0-54" id="h18-0-54" class="i">+trait TestSuite&lt;S: Store&gt; {
</a><a href="#h18-0-55" id="h18-0-55" class="i">+    fn setup() -&gt; Result&lt;S, Error&gt;;
</a><a href="#h18-0-56" id="h18-0-56" class="i">+
</a><a href="#h18-0-57" id="h18-0-57" class="i">+    fn test() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-0-58" id="h18-0-58" class="i">+        Self::test_append()?;
</a><a href="#h18-0-59" id="h18-0-59" class="i">+        Self::test_commit_truncate()?;
</a><a href="#h18-0-60" id="h18-0-60" class="i">+        Self::test_get()?;
</a><a href="#h18-0-61" id="h18-0-61" class="i">+        Self::test_metadata()?;
</a><a href="#h18-0-62" id="h18-0-62" class="i">+        Self::test_scan()?;
</a><a href="#h18-0-63" id="h18-0-63" class="i">+        Ok(())
</a><a href="#h18-0-64" id="h18-0-64" class="i">+    }
</a><a href="#h18-0-65" id="h18-0-65" class="i">+
</a><a href="#h18-0-66" id="h18-0-66" class="i">+    fn test_append() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-0-67" id="h18-0-67" class="i">+        let mut s = Self::setup()?;
</a><a href="#h18-0-68" id="h18-0-68" class="i">+        assert_eq!(0, s.len());
</a><a href="#h18-0-69" id="h18-0-69" class="i">+        assert_eq!(1, s.append(vec![0x01])?);
</a><a href="#h18-0-70" id="h18-0-70" class="i">+        assert_eq!(2, s.append(vec![0x02])?);
</a><a href="#h18-0-71" id="h18-0-71" class="i">+        assert_eq!(3, s.append(vec![0x03])?);
</a><a href="#h18-0-72" id="h18-0-72" class="i">+        assert_eq!(3, s.len());
</a><a href="#h18-0-73" id="h18-0-73" class="i">+        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-74" id="h18-0-74" class="i">+        Ok(())
</a><a href="#h18-0-75" id="h18-0-75" class="i">+    }
</a><a href="#h18-0-76" id="h18-0-76" class="i">+
</a><a href="#h18-0-77" id="h18-0-77" class="i">+    fn test_commit_truncate() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-0-78" id="h18-0-78" class="i">+        let mut s = Self::setup()?;
</a><a href="#h18-0-79" id="h18-0-79" class="i">+
</a><a href="#h18-0-80" id="h18-0-80" class="i">+        assert_eq!(0, s.committed());
</a><a href="#h18-0-81" id="h18-0-81" class="i">+
</a><a href="#h18-0-82" id="h18-0-82" class="i">+        // Truncating an empty store should be fine.
</a><a href="#h18-0-83" id="h18-0-83" class="i">+        assert_eq!(0, s.truncate(0)?);
</a><a href="#h18-0-84" id="h18-0-84" class="i">+
</a><a href="#h18-0-85" id="h18-0-85" class="i">+        s.append(vec![0x01])?;
</a><a href="#h18-0-86" id="h18-0-86" class="i">+        s.append(vec![0x02])?;
</a><a href="#h18-0-87" id="h18-0-87" class="i">+        s.append(vec![0x03])?;
</a><a href="#h18-0-88" id="h18-0-88" class="i">+        s.commit(1)?;
</a><a href="#h18-0-89" id="h18-0-89" class="i">+        assert_eq!(1, s.committed());
</a><a href="#h18-0-90" id="h18-0-90" class="i">+
</a><a href="#h18-0-91" id="h18-0-91" class="i">+        // Truncating beyond the end should be fine.
</a><a href="#h18-0-92" id="h18-0-92" class="i">+        assert_eq!(3, s.truncate(4)?);
</a><a href="#h18-0-93" id="h18-0-93" class="i">+        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-94" id="h18-0-94" class="i">+
</a><a href="#h18-0-95" id="h18-0-95" class="i">+        // Truncating a committed entry should error.
</a><a href="#h18-0-96" id="h18-0-96" class="i">+        assert_eq!(
</a><a href="#h18-0-97" id="h18-0-97" class="i">+            Err(Error::Internal(&quot;Cannot truncate below committed index 1&quot;.into())),
</a><a href="#h18-0-98" id="h18-0-98" class="i">+            s.truncate(0)
</a><a href="#h18-0-99" id="h18-0-99" class="i">+        );
</a><a href="#h18-0-100" id="h18-0-100" class="i">+
</a><a href="#h18-0-101" id="h18-0-101" class="i">+        // Truncating above should work.
</a><a href="#h18-0-102" id="h18-0-102" class="i">+        assert_eq!(1, s.truncate(1)?);
</a><a href="#h18-0-103" id="h18-0-103" class="i">+        assert_eq!(vec![vec![1]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-104" id="h18-0-104" class="i">+
</a><a href="#h18-0-105" id="h18-0-105" class="i">+        Ok(())
</a><a href="#h18-0-106" id="h18-0-106" class="i">+    }
</a><a href="#h18-0-107" id="h18-0-107" class="i">+
</a><a href="#h18-0-108" id="h18-0-108" class="i">+    fn test_get() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-0-109" id="h18-0-109" class="i">+        let mut s = Self::setup()?;
</a><a href="#h18-0-110" id="h18-0-110" class="i">+        s.append(vec![0x01])?;
</a><a href="#h18-0-111" id="h18-0-111" class="i">+        s.append(vec![0x02])?;
</a><a href="#h18-0-112" id="h18-0-112" class="i">+        s.append(vec![0x03])?;
</a><a href="#h18-0-113" id="h18-0-113" class="i">+        assert_eq!(None, s.get(0)?);
</a><a href="#h18-0-114" id="h18-0-114" class="i">+        assert_eq!(Some(vec![0x01]), s.get(1)?);
</a><a href="#h18-0-115" id="h18-0-115" class="i">+        assert_eq!(None, s.get(4)?);
</a><a href="#h18-0-116" id="h18-0-116" class="i">+        Ok(())
</a><a href="#h18-0-117" id="h18-0-117" class="i">+    }
</a><a href="#h18-0-118" id="h18-0-118" class="i">+
</a><a href="#h18-0-119" id="h18-0-119" class="i">+    fn test_metadata() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-0-120" id="h18-0-120" class="i">+        let mut s = Self::setup()?;
</a><a href="#h18-0-121" id="h18-0-121" class="i">+        s.set_metadata(b&quot;a&quot;, vec![0x01])?;
</a><a href="#h18-0-122" id="h18-0-122" class="i">+        assert_eq!(Some(vec![0x01]), s.get_metadata(b&quot;a&quot;)?);
</a><a href="#h18-0-123" id="h18-0-123" class="i">+        assert_eq!(None, s.get_metadata(b&quot;b&quot;)?);
</a><a href="#h18-0-124" id="h18-0-124" class="i">+        Ok(())
</a><a href="#h18-0-125" id="h18-0-125" class="i">+    }
</a><a href="#h18-0-126" id="h18-0-126" class="i">+
</a><a href="#h18-0-127" id="h18-0-127" class="i">+    fn test_scan() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h18-0-128" id="h18-0-128" class="i">+        let mut s = Self::setup()?;
</a><a href="#h18-0-129" id="h18-0-129" class="i">+        s.append(vec![0x01])?;
</a><a href="#h18-0-130" id="h18-0-130" class="i">+        s.append(vec![0x02])?;
</a><a href="#h18-0-131" id="h18-0-131" class="i">+        s.append(vec![0x03])?;
</a><a href="#h18-0-132" id="h18-0-132" class="i">+        s.commit(2)?;
</a><a href="#h18-0-133" id="h18-0-133" class="i">+
</a><a href="#h18-0-134" id="h18-0-134" class="i">+        assert_eq!(vec![vec![1], vec![2], vec![3]], s.scan(..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-135" id="h18-0-135" class="i">+
</a><a href="#h18-0-136" id="h18-0-136" class="i">+        assert_eq!(vec![vec![1]], s.scan(0..2).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-137" id="h18-0-137" class="i">+        assert_eq!(vec![vec![1], vec![2]], s.scan(1..3).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-138" id="h18-0-138" class="i">+        assert_eq!(
</a><a href="#h18-0-139" id="h18-0-139" class="i">+            vec![vec![1], vec![2], vec![3]],
</a><a href="#h18-0-140" id="h18-0-140" class="i">+            s.scan(1..=3).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?
</a><a href="#h18-0-141" id="h18-0-141" class="i">+        );
</a><a href="#h18-0-142" id="h18-0-142" class="i">+        assert!(s.scan(3..1).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h18-0-143" id="h18-0-143" class="i">+        assert!(s.scan(1..1).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h18-0-144" id="h18-0-144" class="i">+        assert_eq!(vec![vec![2]], s.scan(2..=2).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-145" id="h18-0-145" class="i">+        assert_eq!(vec![vec![2], vec![3]], s.scan(2..5).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-146" id="h18-0-146" class="i">+
</a><a href="#h18-0-147" id="h18-0-147" class="i">+        assert!(s.scan(..0).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h18-0-148" id="h18-0-148" class="i">+        assert_eq!(vec![vec![1]], s.scan(..=1).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-149" id="h18-0-149" class="i">+        assert_eq!(vec![vec![1], vec![2]], s.scan(..3).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-150" id="h18-0-150" class="i">+
</a><a href="#h18-0-151" id="h18-0-151" class="i">+        assert!(s.scan(4..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?.is_empty());
</a><a href="#h18-0-152" id="h18-0-152" class="i">+        assert_eq!(vec![vec![3]], s.scan(3..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-153" id="h18-0-153" class="i">+        assert_eq!(vec![vec![2], vec![3]], s.scan(2..).collect::&lt;Result&lt;Vec&lt;_&gt;, Error&gt;&gt;()?);
</a><a href="#h18-0-154" id="h18-0-154" class="i">+
</a><a href="#h18-0-155" id="h18-0-155" class="i">+        Ok(())
</a><a href="#h18-0-156" id="h18-0-156" class="i">+    }
</a><a href="#h18-0-157" id="h18-0-157" class="i">+}
</a><b>diff --git a/<a id="h19" href="../file/src/storage/log/test.rs.html">src/storage/log/test.rs</a> b/<a href="../file/src/storage/log/test.rs.html">src/storage/log/test.rs</a></b>
<a href="#h19-0" id="h19-0" class="h">@@ -0,0 +1,73 @@
</a><a href="#h19-0-0" id="h19-0-0" class="i">+use super::{Memory, Scan, Store};
</a><a href="#h19-0-1" id="h19-0-1" class="i">+use crate::Error;
</a><a href="#h19-0-2" id="h19-0-2" class="i">+
</a><a href="#h19-0-3" id="h19-0-3" class="i">+use std::ops::RangeBounds;
</a><a href="#h19-0-4" id="h19-0-4" class="i">+use std::sync::{Arc, RwLock};
</a><a href="#h19-0-5" id="h19-0-5" class="i">+
</a><a href="#h19-0-6" id="h19-0-6" class="i">+/// Log storage backend for testing. Protects an inner Memory backend using a mutex, so it can
</a><a href="#h19-0-7" id="h19-0-7" class="i">+/// be cloned and inspected.
</a><a href="#h19-0-8" id="h19-0-8" class="i">+#[derive(Clone)]
</a><a href="#h19-0-9" id="h19-0-9" class="i">+pub struct Test {
</a><a href="#h19-0-10" id="h19-0-10" class="i">+    store: Arc&lt;RwLock&lt;Memory&gt;&gt;,
</a><a href="#h19-0-11" id="h19-0-11" class="i">+}
</a><a href="#h19-0-12" id="h19-0-12" class="i">+
</a><a href="#h19-0-13" id="h19-0-13" class="i">+impl Test {
</a><a href="#h19-0-14" id="h19-0-14" class="i">+    /// Creates a new Test key-value storage engine.
</a><a href="#h19-0-15" id="h19-0-15" class="i">+    pub fn new() -&gt; Self {
</a><a href="#h19-0-16" id="h19-0-16" class="i">+        Self { store: Arc::new(RwLock::new(Memory::new())) }
</a><a href="#h19-0-17" id="h19-0-17" class="i">+    }
</a><a href="#h19-0-18" id="h19-0-18" class="i">+}
</a><a href="#h19-0-19" id="h19-0-19" class="i">+
</a><a href="#h19-0-20" id="h19-0-20" class="i">+impl Store for Test {
</a><a href="#h19-0-21" id="h19-0-21" class="i">+    fn append(&amp;mut self, entry: Vec&lt;u8&gt;) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h19-0-22" id="h19-0-22" class="i">+        self.store.write()?.append(entry)
</a><a href="#h19-0-23" id="h19-0-23" class="i">+    }
</a><a href="#h19-0-24" id="h19-0-24" class="i">+
</a><a href="#h19-0-25" id="h19-0-25" class="i">+    fn commit(&amp;mut self, index: u64) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h19-0-26" id="h19-0-26" class="i">+        self.store.write()?.commit(index)
</a><a href="#h19-0-27" id="h19-0-27" class="i">+    }
</a><a href="#h19-0-28" id="h19-0-28" class="i">+
</a><a href="#h19-0-29" id="h19-0-29" class="i">+    fn committed(&amp;self) -&gt; u64 {
</a><a href="#h19-0-30" id="h19-0-30" class="i">+        self.store.read().unwrap().committed()
</a><a href="#h19-0-31" id="h19-0-31" class="i">+    }
</a><a href="#h19-0-32" id="h19-0-32" class="i">+
</a><a href="#h19-0-33" id="h19-0-33" class="i">+    fn get(&amp;self, index: u64) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h19-0-34" id="h19-0-34" class="i">+        self.store.read()?.get(index)
</a><a href="#h19-0-35" id="h19-0-35" class="i">+    }
</a><a href="#h19-0-36" id="h19-0-36" class="i">+
</a><a href="#h19-0-37" id="h19-0-37" class="i">+    fn len(&amp;self) -&gt; u64 {
</a><a href="#h19-0-38" id="h19-0-38" class="i">+        self.store.read().unwrap().len()
</a><a href="#h19-0-39" id="h19-0-39" class="i">+    }
</a><a href="#h19-0-40" id="h19-0-40" class="i">+
</a><a href="#h19-0-41" id="h19-0-41" class="i">+    fn scan(&amp;self, range: impl RangeBounds&lt;u64&gt;) -&gt; Scan {
</a><a href="#h19-0-42" id="h19-0-42" class="i">+        // Since the mutex guard is scoped to this method, we simply buffer the result.
</a><a href="#h19-0-43" id="h19-0-43" class="i">+        Box::new(
</a><a href="#h19-0-44" id="h19-0-44" class="i">+            self.store.read().unwrap().scan(range).collect::&lt;Vec&lt;Result&lt;_, Error&gt;&gt;&gt;().into_iter(),
</a><a href="#h19-0-45" id="h19-0-45" class="i">+        )
</a><a href="#h19-0-46" id="h19-0-46" class="i">+    }
</a><a href="#h19-0-47" id="h19-0-47" class="i">+
</a><a href="#h19-0-48" id="h19-0-48" class="i">+    fn truncate(&amp;mut self, index: u64) -&gt; Result&lt;u64, Error&gt; {
</a><a href="#h19-0-49" id="h19-0-49" class="i">+        self.store.write()?.truncate(index)
</a><a href="#h19-0-50" id="h19-0-50" class="i">+    }
</a><a href="#h19-0-51" id="h19-0-51" class="i">+
</a><a href="#h19-0-52" id="h19-0-52" class="i">+    fn get_metadata(&amp;self, key: &amp;[u8]) -&gt; Result&lt;Option&lt;Vec&lt;u8&gt;&gt;, Error&gt; {
</a><a href="#h19-0-53" id="h19-0-53" class="i">+        self.store.read()?.get_metadata(key)
</a><a href="#h19-0-54" id="h19-0-54" class="i">+    }
</a><a href="#h19-0-55" id="h19-0-55" class="i">+
</a><a href="#h19-0-56" id="h19-0-56" class="i">+    fn set_metadata(&amp;mut self, key: &amp;[u8], value: Vec&lt;u8&gt;) -&gt; Result&lt;(), Error&gt; {
</a><a href="#h19-0-57" id="h19-0-57" class="i">+        self.store.write()?.set_metadata(key, value)
</a><a href="#h19-0-58" id="h19-0-58" class="i">+    }
</a><a href="#h19-0-59" id="h19-0-59" class="i">+}
</a><a href="#h19-0-60" id="h19-0-60" class="i">+
</a><a href="#h19-0-61" id="h19-0-61" class="i">+#[cfg(test)]
</a><a href="#h19-0-62" id="h19-0-62" class="i">+impl super::TestSuite&lt;Test&gt; for Test {
</a><a href="#h19-0-63" id="h19-0-63" class="i">+    fn setup() -&gt; Result&lt;Self, Error&gt; {
</a><a href="#h19-0-64" id="h19-0-64" class="i">+        Ok(Test::new())
</a><a href="#h19-0-65" id="h19-0-65" class="i">+    }
</a><a href="#h19-0-66" id="h19-0-66" class="i">+}
</a><a href="#h19-0-67" id="h19-0-67" class="i">+
</a><a href="#h19-0-68" id="h19-0-68" class="i">+#[test]
</a><a href="#h19-0-69" id="h19-0-69" class="i">+fn tests() -&gt; Result&lt;(), Error&gt; {
</a><a href="#h19-0-70" id="h19-0-70" class="i">+    use super::TestSuite;
</a><a href="#h19-0-71" id="h19-0-71" class="i">+    Test::test()
</a><a href="#h19-0-72" id="h19-0-72" class="i">+}
</a><b>diff --git a/<a id="h20" href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a> b/<a href="../file/src/storage/mod.rs.html">src/storage/mod.rs</a></b>
<a href="#h20-0" id="h20-0" class="h">@@ -1 +1,2 @@
</a><a href="#h20-0-0" id="h20-0-0" class="d">-pub mod kv;
</a><a href="#h20-0-1" id="h20-0-1" class="d">-\ No newline at end of file
</a><a href="#h20-0-2" id="h20-0-2" class="i">+pub mod kv;
</a><a href="#h20-0-3" id="h20-0-3" class="i">+pub mod log;
</a><a href="#h20-0-4" id="h20-0-4" class="i">+\ No newline at end of file
</a><b>diff --git a/<a id="h21" href="../file/src/utility/serialize.rs.html">src/utility/serialize.rs</a> b/<a href="../file/src/utility/serialize.rs.html">src/utility/serialize.rs</a></b>
<a href="#h21-0" id="h21-0" class="h">@@ -10,6 +10,7 @@ pub fn deserialize&lt;&#39;de, V: Deserialize&lt;&#39;de&gt;&gt;(bytes: &amp;[u8]) -&gt; Result&lt;V, Error&gt; {
</a> }
 
 /// Deserializes the next value from a reader, using MessagePack.
<a href="#h21-0-3" id="h21-0-3" class="i">+#[allow(dead_code)]
</a> pub fn deserialize_read&lt;R: Read, V: DeserializeOwned&gt;(reader: R) -&gt; Result&lt;Option&lt;V&gt;, Error&gt; {
     match rmp_serde::decode::from_read(reader) {
         Ok(value) =&gt; Ok(Some(value)),
<b>diff --git a/<a id="h22" href="../file/tests/setup.rs.html">tests/setup.rs</a> b/<a href="../file/tests/setup.rs.html">tests/setup.rs</a></b>
<a href="#h22-0" id="h22-0" class="h">@@ -75,7 +75,7 @@ pub async fn server(
</a>     peers: HashMap&lt;String, String&gt;,
 ) -&gt; Result&lt;Teardown, Error&gt; {
     let dir = TempDir::new(&quot;toydb&quot;)?;
<a href="#h22-0-3" id="h22-0-3" class="d">-    let mut srv = Server::new(id, peers, &amp;dir.path().to_string_lossy()).await?;
</a><a href="#h22-0-4" id="h22-0-4" class="i">+    let mut srv = Server::new(id, peers, &amp;dir.path().to_string_lossy(), false).await?;
</a> 
     srv = srv.listen(addr_sql, addr_raft).await?;
     let (task, abort) = srv.serve().remote_handle();
</pre>
</div>
</body>
</html>
