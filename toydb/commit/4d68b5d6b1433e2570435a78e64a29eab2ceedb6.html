<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Use a HashSet for Raft peers. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/4d68b5d6b1433e2570435a78e64a29eab2ceedb6.html">4d68b5d6b1433e2570435a78e64a29eab2ceedb6</a>
<b>parent</b> <a href="../commit/87d4e465e113c4670ed6ca5a7948bede8836d312.html">87d4e465e113c4670ed6ca5a7948bede8836d312</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 19 Nov 2023 16:36:56 +0100

Use a HashSet for Raft peers.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/node/candidate.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/raft/node/follower.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/node/leader.rs</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/node/mod.rs</a></td><td> | </td><td class="num">24</td><td><span class="i">++++++++++++</span><span class="d">------------</span></td></tr>
</table></pre><pre>4 files changed, 18 insertions(+), 18 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a> b/<a href="../file/src/raft/node/candidate.rs.html">src/raft/node/candidate.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -172,7 +172,7 @@ mod tests {
</a> 
         let mut node = RoleNode {
             id: 1,
<a href="#h0-0-3" id="h0-0-3" class="d">-            peers: vec![2, 3, 4, 5],
</a><a href="#h0-0-4" id="h0-0-4" class="i">+            peers: HashSet::from([2, 3, 4, 5]),
</a>             term: 3,
             log,
             node_tx,
<b>diff --git a/<a id="h1" href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a> b/<a href="../file/src/raft/node/follower.rs.html">src/raft/node/follower.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -277,7 +277,7 @@ pub mod tests {
</a> 
         let node = RoleNode {
             id: 1,
<a href="#h1-0-3" id="h1-0-3" class="d">-            peers: vec![2, 3, 4, 5],
</a><a href="#h1-0-4" id="h1-0-4" class="i">+            peers: HashSet::from([2, 3, 4, 5]),
</a>             term: 3,
             log,
             node_tx,
<a href="#h1-1" id="h1-1" class="h">@@ -595,7 +595,7 @@ pub mod tests {
</a> 
         let follower = RoleNode {
             id: 1,
<a href="#h1-1-3" id="h1-1-3" class="d">-            peers: vec![2, 3, 4, 5],
</a><a href="#h1-1-4" id="h1-1-4" class="i">+            peers: HashSet::from([2, 3, 4, 5]),
</a>             term: 0,
             log,
             node_tx,
<b>diff --git a/<a id="h2" href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a> b/<a href="../file/src/raft/node/leader.rs.html">src/raft/node/leader.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -3,7 +3,7 @@ use super::{Follower, Node, NodeID, RoleNode, Term, Ticks, HEARTBEAT_INTERVAL};
</a> use crate::error::{Error, Result};
 
 use ::log::{debug, error, info};
<a href="#h2-0-3" id="h2-0-3" class="d">-use std::collections::HashMap;
</a><a href="#h2-0-4" id="h2-0-4" class="i">+use std::collections::{HashMap, HashSet};
</a> 
 // A leader serves requests and replicates the log to followers.
 #[derive(Debug)]
<a href="#h2-1" id="h2-1" class="h">@@ -18,7 +18,7 @@ pub struct Leader {
</a> 
 impl Leader {
     /// Creates a new leader role.
<a href="#h2-1-3" id="h2-1-3" class="d">-    pub fn new(peers: Vec&lt;NodeID&gt;, last_index: Index) -&gt; Self {
</a><a href="#h2-1-4" id="h2-1-4" class="i">+    pub fn new(peers: HashSet&lt;NodeID&gt;, last_index: Index) -&gt; Self {
</a>         let mut leader = Self {
             since_heartbeat: 0,
             peer_next_index: HashMap::new(),
<a href="#h2-2" id="h2-2" class="h">@@ -259,7 +259,7 @@ mod tests {
</a>     )&gt; {
         let (node_tx, node_rx) = mpsc::unbounded_channel();
         let (state_tx, state_rx) = mpsc::unbounded_channel();
<a href="#h2-2-3" id="h2-2-3" class="d">-        let peers = vec![2, 3, 4, 5];
</a><a href="#h2-2-4" id="h2-2-4" class="i">+        let peers = HashSet::from([2, 3, 4, 5]);
</a>         let mut log = Log::new(Box::new(storage::engine::Memory::new()), false)?;
         log.append(1, Some(vec![0x01]))?;
         log.append(1, Some(vec![0x02]))?;
<b>diff --git a/<a id="h3" href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a> b/<a href="../file/src/raft/node/mod.rs.html">src/raft/node/mod.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -11,7 +11,7 @@ use leader::Leader;
</a> use ::log::{debug, info};
 use rand::Rng as _;
 use serde_derive::{Deserialize, Serialize};
<a href="#h3-0-3" id="h3-0-3" class="d">-use std::collections::HashMap;
</a><a href="#h3-0-4" id="h3-0-4" class="i">+use std::collections::{HashMap, HashSet};
</a> use tokio::sync::mpsc;
 
 /// A node ID.
<a href="#h3-1" id="h3-1" class="h">@@ -59,7 +59,7 @@ impl Node {
</a>     /// Creates a new Raft node, starting as a follower, or leader if no peers.
     pub async fn new(
         id: NodeID,
<a href="#h3-1-3" id="h3-1-3" class="d">-        peers: Vec&lt;NodeID&gt;,
</a><a href="#h3-1-4" id="h3-1-4" class="i">+        peers: HashSet&lt;NodeID&gt;,
</a>         mut log: Log,
         mut state: Box&lt;dyn State&gt;,
         node_tx: mpsc::UnboundedSender&lt;Message&gt;,
<a href="#h3-2" id="h3-2" class="h">@@ -85,7 +85,7 @@ impl Node {
</a>                 node.log.set_term(term, Some(id))?;
             }
             let (last_index, _) = node.log.get_last_index();
<a href="#h3-2-3" id="h3-2-3" class="d">-            Ok(node.become_role(Leader::new(vec![], last_index)).into())
</a><a href="#h3-2-4" id="h3-2-4" class="i">+            Ok(node.become_role(Leader::new(HashSet::new(), last_index)).into())
</a>         } else {
             Ok(node.into())
         }
<a href="#h3-3" id="h3-3" class="h">@@ -141,7 +141,7 @@ impl From&lt;RoleNode&lt;Leader&gt;&gt; for Node {
</a> // A Raft node with role R
 pub struct RoleNode&lt;R&gt; {
     id: NodeID,
<a href="#h3-3-3" id="h3-3-3" class="d">-    peers: Vec&lt;NodeID&gt;,
</a><a href="#h3-3-4" id="h3-3-4" class="i">+    peers: HashSet&lt;NodeID&gt;,
</a>     term: Term,
     log: Log,
     node_tx: mpsc::UnboundedSender&lt;Message&gt;,
<a href="#h3-4" id="h3-4" class="h">@@ -382,7 +382,7 @@ mod tests {
</a>         let node = RoleNode {
             role: (),
             id: 1,
<a href="#h3-4-3" id="h3-4-3" class="d">-            peers,
</a><a href="#h3-4-4" id="h3-4-4" class="i">+            peers: HashSet::from_iter(peers),
</a>             term: 1,
             log: Log::new(Box::new(storage::engine::Memory::new()), false)?,
             node_tx,
<a href="#h3-5" id="h3-5" class="h">@@ -396,7 +396,7 @@ mod tests {
</a>         let (node_tx, _) = mpsc::unbounded_channel();
         let node = Node::new(
             1,
<a href="#h3-5-3" id="h3-5-3" class="d">-            vec![2, 3],
</a><a href="#h3-5-4" id="h3-5-4" class="i">+            HashSet::from([2, 3]),
</a>             Log::new(Box::new(storage::engine::Memory::new()), false)?,
             Box::new(TestState::new(0)),
             node_tx,
<a href="#h3-6" id="h3-6" class="h">@@ -406,7 +406,7 @@ mod tests {
</a>             Node::Follower(rolenode) =&gt; {
                 assert_eq!(rolenode.id, 1);
                 assert_eq!(rolenode.term, 0);
<a href="#h3-6-3" id="h3-6-3" class="d">-                assert_eq!(rolenode.peers, vec![2, 3]);
</a><a href="#h3-6-4" id="h3-6-4" class="i">+                assert_eq!(rolenode.peers, HashSet::from([2, 3]));
</a>             }
             _ =&gt; panic!(&quot;Expected node to start as follower&quot;),
         }
<a href="#h3-7" id="h3-7" class="h">@@ -424,7 +424,7 @@ mod tests {
</a>         log.append(2, Some(vec![0x03]))?;
         let state = Box::new(TestState::new(0));
 
<a href="#h3-7-3" id="h3-7-3" class="d">-        Node::new(1, vec![2, 3], log, state.clone(), node_tx).await?;
</a><a href="#h3-7-4" id="h3-7-4" class="i">+        Node::new(1, HashSet::from([2, 3]), log, state.clone(), node_tx).await?;
</a>         tokio::time::sleep(std::time::Duration::from_millis(100)).await;
         assert_eq!(state.list(), vec![vec![0x01], vec![0x02]]);
         assert_eq!(state.get_applied_index(), 3);
<a href="#h3-8" id="h3-8" class="h">@@ -442,7 +442,7 @@ mod tests {
</a>         log.append(2, Some(vec![0x03]))?;
         let state = Box::new(TestState::new(2));
 
<a href="#h3-8-3" id="h3-8-3" class="d">-        Node::new(1, vec![2, 3], log, state.clone(), node_tx).await?;
</a><a href="#h3-8-4" id="h3-8-4" class="i">+        Node::new(1, HashSet::from([2, 3]), log, state.clone(), node_tx).await?;
</a>         tokio::time::sleep(std::time::Duration::from_millis(100)).await;
         assert_eq!(state.list(), vec![vec![0x02]]);
         assert_eq!(state.get_applied_index(), 3);
<a href="#h3-9" id="h3-9" class="h">@@ -461,7 +461,7 @@ mod tests {
</a>         log.append(2, Some(vec![0x03])).unwrap();
         let state = Box::new(TestState::new(4));
 
<a href="#h3-9-3" id="h3-9-3" class="d">-        Node::new(1, vec![2, 3], log, state.clone(), node_tx).await.unwrap();
</a><a href="#h3-9-4" id="h3-9-4" class="i">+        Node::new(1, HashSet::from([2, 3]), log, state.clone(), node_tx).await.unwrap();
</a>     }
 
     #[tokio::test]
<a href="#h3-10" id="h3-10" class="h">@@ -469,7 +469,7 @@ mod tests {
</a>         let (node_tx, _) = mpsc::unbounded_channel();
         let node = Node::new(
             1,
<a href="#h3-10-3" id="h3-10-3" class="d">-            vec![],
</a><a href="#h3-10-4" id="h3-10-4" class="i">+            HashSet::new(),
</a>             Log::new(Box::new(storage::engine::Memory::new()), false)?,
             Box::new(TestState::new(0)),
             node_tx,
<a href="#h3-11" id="h3-11" class="h">@@ -492,7 +492,7 @@ mod tests {
</a>         let new = node.become_role(&quot;role&quot;);
         assert_eq!(new.id, 1);
         assert_eq!(new.term, 1);
<a href="#h3-11-3" id="h3-11-3" class="d">-        assert_eq!(new.peers, vec![2, 3]);
</a><a href="#h3-11-4" id="h3-11-4" class="i">+        assert_eq!(new.peers, HashSet::from([2, 3]));
</a>         assert_eq!(new.role, &quot;role&quot;);
         Ok(())
     }
</pre>
</div>
</body>
</html>
