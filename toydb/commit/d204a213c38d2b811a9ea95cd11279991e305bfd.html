<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>encoding: add `Key` and `Value` traits with decode/encode default impls - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/d204a213c38d2b811a9ea95cd11279991e305bfd.html">d204a213c38d2b811a9ea95cd11279991e305bfd</a>
<b>parent</b> <a href="../commit/763caa8742503495727f2ad6c2e45cf2c2b68b12.html">763caa8742503495727f2ad6c2e45cf2c2b68b12</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Fri, 31 May 2024 11:50:59 +0200

encoding: add `Key` and `Value` traits with decode/encode default impls

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/client.rs</a></td><td> | </td><td class="num">11</td><td><span class="i">++++++</span><span class="d">-----</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/encoding/mod.rs</a></td><td> | </td><td class="num">62</td><td><span class="i">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">--</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/log.rs</a></td><td> | </td><td class="num">18</td><td><span class="i">+++</span><span class="d">---------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/message.rs</a></td><td> | </td><td class="num">7</td><td><span class="i">+++++++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/node.rs</a></td><td> | </td><td class="num">26</td><td><span class="i">+++++</span><span class="d">---------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/server.rs</a></td><td> | </td><td class="num">17</td><td><span class="i">+++++++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h6">src/sql/engine/kv.rs</a></td><td> | </td><td class="num">48</td><td><span class="i">+++++++++++++</span><span class="d">-----------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h7">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">49</td><td><span class="i">+++++++++++++++++++++++++</span><span class="d">------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h8">src/sql/schema.rs</a></td><td> | </td><td class="num">3</td><td><span class="i">+++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h9">src/sql/types/mod.rs</a></td><td> | </td><td class="num">3</td><td><span class="i">+++</span><span class="d"></span></td></tr>
<tr><td class="M">M</td><td><a href="#h10">src/storage/debug.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h11">src/storage/mvcc.rs</a></td><td> | </td><td class="num">36</td><td><span class="i">+++++++++++++++</span><span class="d">---------------------</span></td></tr>
</table></pre><pre>12 files changed, 152 insertions(+), 130 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/client.rs.html">src/client.rs</a> b/<a href="../file/src/client.rs.html">src/client.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -1,11 +1,12 @@
</a><a href="#h0-0-0" id="h0-0-0" class="d">-use crate::encoding::bincode;
</a><a href="#h0-0-1" id="h0-0-1" class="i">+use std::io::Write as _;
</a><a href="#h0-0-2" id="h0-0-2" class="i">+
</a><a href="#h0-0-3" id="h0-0-3" class="i">+use crate::encoding::Value as _;
</a> use crate::error::{Error, Result};
 use crate::server::{Request, Response, Status};
 use crate::sql::execution::ResultSet;
 use crate::sql::schema::Table;
 
 use rand::Rng;
<a href="#h0-0-10" id="h0-0-10" class="d">-use std::io::Write as _;
</a> 
 /// A toyDB client
 pub struct Client {
<a href="#h0-1" id="h0-1" class="h">@@ -25,9 +26,9 @@ impl Client {
</a> 
     /// Call a server method
     fn call(&amp;mut self, request: Request) -&gt; Result&lt;Response&gt; {
<a href="#h0-1-3" id="h0-1-3" class="d">-        bincode::serialize_into(&amp;mut self.writer, &amp;request)?;
</a><a href="#h0-1-4" id="h0-1-4" class="i">+        request.encode_into(&amp;mut self.writer)?;
</a>         self.writer.flush()?;
<a href="#h0-1-6" id="h0-1-6" class="d">-        bincode::deserialize_from(&amp;mut self.reader)?
</a><a href="#h0-1-7" id="h0-1-7" class="i">+        Result::&lt;Response&gt;::decode_from(&amp;mut self.reader)?
</a>     }
 
     /// Executes a query
<a href="#h0-2" id="h0-2" class="h">@@ -40,7 +41,7 @@ impl Client {
</a>             // FIXME We buffer rows for now to avoid lifetime hassles
             let mut rows = Vec::new();
             loop {
<a href="#h0-2-3" id="h0-2-3" class="d">-                match bincode::deserialize_from::&lt;_, Result&lt;_&gt;&gt;(&amp;mut self.reader)?? {
</a><a href="#h0-2-4" id="h0-2-4" class="i">+                match Result::&lt;Response&gt;::decode_from(&amp;mut self.reader)?? {
</a>                     Response::Row(Some(row)) =&gt; rows.push(row),
                     Response::Row(None) =&gt; break,
                     response =&gt; {
<b>diff --git a/<a id="h1" href="../file/src/encoding/mod.rs.html">src/encoding/mod.rs</a> b/<a href="../file/src/encoding/mod.rs.html">src/encoding/mod.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -1,6 +1,64 @@
</a> //! Binary data encodings.
 //!
<a href="#h1-0-2" id="h1-0-2" class="d">-//! - keycode: used for keys in the key/value store.
</a><a href="#h1-0-3" id="h1-0-3" class="d">-//! - bincode: used for values in the key/value store and network protocols.
</a><a href="#h1-0-4" id="h1-0-4" class="i">+//! * keycode: used for keys in the key/value store.
</a><a href="#h1-0-5" id="h1-0-5" class="i">+//! * bincode: used for values in the key/value store and network protocols.
</a><a href="#h1-0-6" id="h1-0-6" class="i">+
</a> pub mod bincode;
 pub mod keycode;
<a href="#h1-0-9" id="h1-0-9" class="i">+
</a><a href="#h1-0-10" id="h1-0-10" class="i">+use crate::error::Result;
</a><a href="#h1-0-11" id="h1-0-11" class="i">+use serde::{de::DeserializeOwned, Deserialize, Serialize};
</a><a href="#h1-0-12" id="h1-0-12" class="i">+
</a><a href="#h1-0-13" id="h1-0-13" class="i">+/// Adds automatic Keycode encode/decode methods to key enums. These are
</a><a href="#h1-0-14" id="h1-0-14" class="i">+/// primarily meant for keys stored in key/value storage engines.
</a><a href="#h1-0-15" id="h1-0-15" class="i">+///
</a><a href="#h1-0-16" id="h1-0-16" class="i">+/// TODO: consider making this DeserializeOwned instead.
</a><a href="#h1-0-17" id="h1-0-17" class="i">+pub trait Key&lt;&#39;de&gt;: Serialize + Deserialize&lt;&#39;de&gt; {
</a><a href="#h1-0-18" id="h1-0-18" class="i">+    /// Decodes a key from a byte slice using Keycode.
</a><a href="#h1-0-19" id="h1-0-19" class="i">+    fn decode(bytes: &amp;&#39;de [u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h1-0-20" id="h1-0-20" class="i">+        keycode::deserialize(bytes)
</a><a href="#h1-0-21" id="h1-0-21" class="i">+    }
</a><a href="#h1-0-22" id="h1-0-22" class="i">+
</a><a href="#h1-0-23" id="h1-0-23" class="i">+    /// Encodes a key to a byte vector using Keycode.
</a><a href="#h1-0-24" id="h1-0-24" class="i">+    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h1-0-25" id="h1-0-25" class="i">+        keycode::serialize(self)
</a><a href="#h1-0-26" id="h1-0-26" class="i">+    }
</a><a href="#h1-0-27" id="h1-0-27" class="i">+}
</a><a href="#h1-0-28" id="h1-0-28" class="i">+
</a><a href="#h1-0-29" id="h1-0-29" class="i">+/// Adds automatic Bincode encode/decode methods to value types. These are used
</a><a href="#h1-0-30" id="h1-0-30" class="i">+/// not only for values in key/value storage engines, but also for e.g. network
</a><a href="#h1-0-31" id="h1-0-31" class="i">+/// protocol messages and other values.
</a><a href="#h1-0-32" id="h1-0-32" class="i">+pub trait Value: Serialize + DeserializeOwned {
</a><a href="#h1-0-33" id="h1-0-33" class="i">+    /// Decodes a value from a byte slice using Bincode.
</a><a href="#h1-0-34" id="h1-0-34" class="i">+    fn decode(bytes: &amp;[u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h1-0-35" id="h1-0-35" class="i">+        bincode::deserialize(bytes)
</a><a href="#h1-0-36" id="h1-0-36" class="i">+    }
</a><a href="#h1-0-37" id="h1-0-37" class="i">+
</a><a href="#h1-0-38" id="h1-0-38" class="i">+    /// Decodes a value from a reader using Bincode.
</a><a href="#h1-0-39" id="h1-0-39" class="i">+    fn decode_from&lt;R: std::io::Read&gt;(reader: R) -&gt; Result&lt;Self&gt; {
</a><a href="#h1-0-40" id="h1-0-40" class="i">+        bincode::deserialize_from(reader)
</a><a href="#h1-0-41" id="h1-0-41" class="i">+    }
</a><a href="#h1-0-42" id="h1-0-42" class="i">+
</a><a href="#h1-0-43" id="h1-0-43" class="i">+    /// Decodes a value from a reader using Bincode, or returns None if the
</a><a href="#h1-0-44" id="h1-0-44" class="i">+    /// reader is closed.
</a><a href="#h1-0-45" id="h1-0-45" class="i">+    fn maybe_decode_from&lt;R: std::io::Read&gt;(reader: R) -&gt; Result&lt;Option&lt;Self&gt;&gt; {
</a><a href="#h1-0-46" id="h1-0-46" class="i">+        bincode::maybe_deserialize_from(reader)
</a><a href="#h1-0-47" id="h1-0-47" class="i">+    }
</a><a href="#h1-0-48" id="h1-0-48" class="i">+
</a><a href="#h1-0-49" id="h1-0-49" class="i">+    /// Encodes a value to a byte vector using Bincode.
</a><a href="#h1-0-50" id="h1-0-50" class="i">+    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h1-0-51" id="h1-0-51" class="i">+        bincode::serialize(self)
</a><a href="#h1-0-52" id="h1-0-52" class="i">+    }
</a><a href="#h1-0-53" id="h1-0-53" class="i">+
</a><a href="#h1-0-54" id="h1-0-54" class="i">+    /// Encodes a value into a writer using Bincode.
</a><a href="#h1-0-55" id="h1-0-55" class="i">+    fn encode_into&lt;W: std::io::Write&gt;(&amp;self, writer: W) -&gt; Result&lt;()&gt; {
</a><a href="#h1-0-56" id="h1-0-56" class="i">+        bincode::serialize_into(writer, self)
</a><a href="#h1-0-57" id="h1-0-57" class="i">+    }
</a><a href="#h1-0-58" id="h1-0-58" class="i">+}
</a><a href="#h1-0-59" id="h1-0-59" class="i">+
</a><a href="#h1-0-60" id="h1-0-60" class="i">+/// Blanket implementations for various types wrapping a value type.
</a><a href="#h1-0-61" id="h1-0-61" class="i">+impl&lt;V: Value + std::cmp::Eq + std::hash::Hash&gt; Value for std::collections::HashSet&lt;V&gt; {}
</a><a href="#h1-0-62" id="h1-0-62" class="i">+impl&lt;V: Value&gt; Value for Option&lt;V&gt; {}
</a><a href="#h1-0-63" id="h1-0-63" class="i">+impl&lt;V: Value&gt; Value for Result&lt;V&gt; {}
</a><a href="#h1-0-64" id="h1-0-64" class="i">+impl&lt;V: Value&gt; Value for Vec&lt;V&gt; {}
</a><a href="#h1-0-65" id="h1-0-65" class="i">+impl&lt;V: Value + std::cmp::Eq + std::hash::Hash&gt; Value for Vec&lt;(V, std::collections::HashSet&lt;V&gt;)&gt; {}
</a><b>diff --git a/<a id="h2" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -1,5 +1,5 @@
</a> use super::{NodeID, Term};
<a href="#h2-0-1" id="h2-0-1" class="d">-use crate::encoding::{bincode, keycode};
</a><a href="#h2-0-2" id="h2-0-2" class="i">+use crate::encoding::{self, bincode, Key as _};
</a> use crate::error::{Error, Result};
 use crate::storage;
 use crate::{asserterr, errassert};
<a href="#h2-1" id="h2-1" class="h">@@ -31,15 +31,7 @@ pub enum Key {
</a>     CommitIndex,
 }
 
<a href="#h2-1-3" id="h2-1-3" class="d">-impl Key {
</a><a href="#h2-1-4" id="h2-1-4" class="d">-    fn decode(bytes: &amp;[u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h2-1-5" id="h2-1-5" class="d">-        keycode::deserialize(bytes)
</a><a href="#h2-1-6" id="h2-1-6" class="d">-    }
</a><a href="#h2-1-7" id="h2-1-7" class="d">-
</a><a href="#h2-1-8" id="h2-1-8" class="d">-    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-1-9" id="h2-1-9" class="d">-        keycode::serialize(self)
</a><a href="#h2-1-10" id="h2-1-10" class="d">-    }
</a><a href="#h2-1-11" id="h2-1-11" class="d">-}
</a><a href="#h2-1-12" id="h2-1-12" class="i">+impl encoding::Key&lt;&#39;_&gt; for Key {}
</a> 
 /// Log key prefixes, used for prefix scans.
 ///
<a href="#h2-2" id="h2-2" class="h">@@ -51,11 +43,7 @@ enum KeyPrefix {
</a>     CommitIndex,
 }
 
<a href="#h2-2-3" id="h2-2-3" class="d">-impl KeyPrefix {
</a><a href="#h2-2-4" id="h2-2-4" class="d">-    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h2-2-5" id="h2-2-5" class="d">-        keycode::serialize(self)
</a><a href="#h2-2-6" id="h2-2-6" class="d">-    }
</a><a href="#h2-2-7" id="h2-2-7" class="d">-}
</a><a href="#h2-2-8" id="h2-2-8" class="i">+impl encoding::Key&lt;&#39;_&gt; for KeyPrefix {}
</a> 
 /// A Raft log.
 pub struct Log {
<b>diff --git a/<a id="h3" href="../file/src/raft/message.rs.html">src/raft/message.rs</a> b/<a href="../file/src/raft/message.rs.html">src/raft/message.rs</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -1,4 +1,5 @@
</a> use super::{Entry, Index, NodeID, Term};
<a href="#h3-0-1" id="h3-0-1" class="i">+use crate::encoding;
</a> use crate::error::Result;
 use crate::storage;
 
<a href="#h3-1" id="h3-1" class="h">@@ -18,6 +19,8 @@ pub struct Envelope {
</a>     pub message: Message,
 }
 
<a href="#h3-1-3" id="h3-1-3" class="i">+impl encoding::Value for Envelope {}
</a><a href="#h3-1-4" id="h3-1-4" class="i">+
</a> /// A message sent between Raft nodes.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub enum Message {
<a href="#h3-2" id="h3-2" class="h">@@ -140,6 +143,8 @@ pub enum Request {
</a>     Status,
 }
 
<a href="#h3-2-3" id="h3-2-3" class="i">+impl encoding::Value for Request {}
</a><a href="#h3-2-4" id="h3-2-4" class="i">+
</a> /// A client response. This will be wrapped in a Result to handle errors.
 ///
 /// TODO: consider a separate error kind here, or a wrapped Result, to separate
<a href="#h3-3" id="h3-3" class="h">@@ -155,6 +160,8 @@ pub enum Response {
</a>     Status(Status),
 }
 
<a href="#h3-3-3" id="h3-3-3" class="i">+impl encoding::Value for Response {}
</a><a href="#h3-3-4" id="h3-3-4" class="i">+
</a> /// Raft cluster status.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub struct Status {
<b>diff --git a/<a id="h4" href="../file/src/raft/node.rs.html">src/raft/node.rs</a> b/<a href="../file/src/raft/node.rs.html">src/raft/node.rs</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -1105,7 +1105,7 @@ fn quorum_value&lt;T: Ord + Copy&gt;(mut values: Vec&lt;T&gt;) -&gt; T {
</a> #[cfg(test)]
 mod tests {
     use super::*;
<a href="#h4-0-3" id="h4-0-3" class="d">-    use crate::encoding::bincode;
</a><a href="#h4-0-4" id="h4-0-4" class="i">+    use crate::encoding::{self, bincode, Value as _};
</a>     use crate::raft::{
         Entry, Request, RequestID, Response, ELECTION_TIMEOUT_RANGE, HEARTBEAT_INTERVAL,
     };
<a href="#h4-1" id="h4-1" class="h">@@ -2025,6 +2025,8 @@ mod tests {
</a>         Scan,
     }
 
<a href="#h4-1-3" id="h4-1-3" class="i">+    impl encoding::Value for TestCommand {}
</a><a href="#h4-1-4" id="h4-1-4" class="i">+
</a>     impl std::fmt::Display for TestCommand {
         fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
             match self {
<a href="#h4-2" id="h4-2" class="h">@@ -2035,16 +2037,6 @@ mod tests {
</a>         }
     }
 
<a href="#h4-2-3" id="h4-2-3" class="d">-    impl TestCommand {
</a><a href="#h4-2-4" id="h4-2-4" class="d">-        fn decode(raw: &amp;[u8]) -&gt; crate::error::Result&lt;Self&gt; {
</a><a href="#h4-2-5" id="h4-2-5" class="d">-            bincode::deserialize(raw)
</a><a href="#h4-2-6" id="h4-2-6" class="d">-        }
</a><a href="#h4-2-7" id="h4-2-7" class="d">-
</a><a href="#h4-2-8" id="h4-2-8" class="d">-        fn encode(&amp;self) -&gt; crate::error::Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h4-2-9" id="h4-2-9" class="d">-            bincode::serialize(self)
</a><a href="#h4-2-10" id="h4-2-10" class="d">-        }
</a><a href="#h4-2-11" id="h4-2-11" class="d">-    }
</a><a href="#h4-2-12" id="h4-2-12" class="d">-
</a>     /// A TestCommand response.
     #[derive(Serialize, Deserialize)]
     enum TestResponse {
<a href="#h4-3" id="h4-3" class="h">@@ -2056,6 +2048,8 @@ mod tests {
</a>         Scan(BTreeMap&lt;String, String&gt;),
     }
 
<a href="#h4-3-3" id="h4-3-3" class="i">+    impl encoding::Value for TestResponse {}
</a><a href="#h4-3-4" id="h4-3-4" class="i">+
</a>     impl std::fmt::Display for TestResponse {
         fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {
             match self {
<a href="#h4-4" id="h4-4" class="h">@@ -2069,14 +2063,4 @@ mod tests {
</a>             Ok(())
         }
     }
<a href="#h4-4-3" id="h4-4-3" class="d">-
</a><a href="#h4-4-4" id="h4-4-4" class="d">-    impl TestResponse {
</a><a href="#h4-4-5" id="h4-4-5" class="d">-        fn decode(raw: &amp;[u8]) -&gt; crate::error::Result&lt;Self&gt; {
</a><a href="#h4-4-6" id="h4-4-6" class="d">-            bincode::deserialize(raw)
</a><a href="#h4-4-7" id="h4-4-7" class="d">-        }
</a><a href="#h4-4-8" id="h4-4-8" class="d">-
</a><a href="#h4-4-9" id="h4-4-9" class="d">-        fn encode(&amp;self) -&gt; crate::error::Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h4-4-10" id="h4-4-10" class="d">-            bincode::serialize(self)
</a><a href="#h4-4-11" id="h4-4-11" class="d">-        }
</a><a href="#h4-4-12" id="h4-4-12" class="d">-    }
</a> }
<b>diff --git a/<a id="h5" href="../file/src/server.rs.html">src/server.rs</a> b/<a href="../file/src/server.rs.html">src/server.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -1,4 +1,4 @@
</a><a href="#h5-0-0" id="h5-0-0" class="d">-use crate::encoding::bincode;
</a><a href="#h5-0-1" id="h5-0-1" class="i">+use crate::encoding::{self, Value as _};
</a> use crate::error::{Error, Result};
 use crate::raft;
 use crate::sql;
<a href="#h5-1" id="h5-1" class="h">@@ -137,7 +137,7 @@ impl Server {
</a>     /// stepping into the Raft node.
     fn raft_receive_peer(socket: TcpStream, raft_step_tx: Sender&lt;raft::Envelope&gt;) -&gt; Result&lt;()&gt; {
         let mut socket = std::io::BufReader::new(socket);
<a href="#h5-1-3" id="h5-1-3" class="d">-        while let Some(message) = bincode::maybe_deserialize_from(&amp;mut socket)? {
</a><a href="#h5-1-4" id="h5-1-4" class="i">+        while let Some(message) = raft::Envelope::maybe_decode_from(&amp;mut socket)? {
</a>             raft_step_tx.send(message)?;
         }
         Ok(())
<a href="#h5-2" id="h5-2" class="h">@@ -156,7 +156,8 @@ impl Server {
</a>                 }
             };
             while let Ok(message) = raft_node_rx.recv() {
<a href="#h5-2-3" id="h5-2-3" class="d">-                if let Err(err) = bincode::serialize_into(&amp;mut socket, &amp;message)
</a><a href="#h5-2-4" id="h5-2-4" class="i">+                if let Err(err) = message
</a><a href="#h5-2-5" id="h5-2-5" class="i">+                    .encode_into(&amp;mut socket)
</a>                     .and_then(|()| socket.flush().map_err(Error::from))
                 {
                     error!(&quot;Failed sending to Raft peer {addr}: {err}&quot;);
<a href="#h5-3" id="h5-3" class="h">@@ -285,7 +286,7 @@ impl Server {
</a>         let mut reader = std::io::BufReader::new(socket.try_clone()?);
         let mut writer = std::io::BufWriter::new(socket);
 
<a href="#h5-3-3" id="h5-3-3" class="d">-        while let Some(request) = bincode::maybe_deserialize_from(&amp;mut reader)? {
</a><a href="#h5-3-4" id="h5-3-4" class="i">+        while let Some(request) = Request::maybe_decode_from(&amp;mut reader)? {
</a>             // Execute request.
             debug!(&quot;Received request {request:?}&quot;);
             let mut response = match request {
<a href="#h5-4" id="h5-4" class="h">@@ -326,9 +327,9 @@ impl Server {
</a>                 );
             }
 
<a href="#h5-4-3" id="h5-4-3" class="d">-            bincode::serialize_into(&amp;mut writer, &amp;response)?;
</a><a href="#h5-4-4" id="h5-4-4" class="i">+            response.encode_into(&amp;mut writer)?;
</a>             for row in rows {
<a href="#h5-4-6" id="h5-4-6" class="d">-                bincode::serialize_into(&amp;mut writer, &amp;row)?;
</a><a href="#h5-4-7" id="h5-4-7" class="i">+                row.encode_into(&amp;mut writer)?;
</a>             }
             writer.flush()?;
         }
<a href="#h5-5" id="h5-5" class="h">@@ -349,6 +350,8 @@ pub enum Request {
</a>     Status,
 }
 
<a href="#h5-5-3" id="h5-5-3" class="i">+impl encoding::Value for Request {}
</a><a href="#h5-5-4" id="h5-5-4" class="i">+
</a> /// A SQL server response.
 #[derive(Debug, Serialize, Deserialize)]
 pub enum Response {
<a href="#h5-6" id="h5-6" class="h">@@ -359,6 +362,8 @@ pub enum Response {
</a>     Status(Status),
 }
 
<a href="#h5-6-3" id="h5-6-3" class="i">+impl encoding::Value for Response {}
</a><a href="#h5-6-4" id="h5-6-4" class="i">+
</a> /// SQL server status.
 #[derive(Debug, PartialEq, Serialize, Deserialize)]
 pub struct Status {
<b>diff --git a/<a id="h6" href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a> b/<a href="../file/src/sql/engine/kv.rs.html">src/sql/engine/kv.rs</a></b>
<a href="#h6-0" id="h6-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::schema::{Catalog, Table, Tables};
 use super::super::types::{Expression, Row, Value};
 use super::Transaction as _;
<a href="#h6-0-3" id="h6-0-3" class="d">-use crate::encoding::{bincode, keycode};
</a><a href="#h6-0-4" id="h6-0-4" class="i">+use crate::encoding::{self, Key as _, Value as _};
</a> use crate::error::{Error, Result};
 use crate::storage;
 
<a href="#h6-1" id="h6-1" class="h">@@ -64,16 +64,6 @@ impl&lt;E: storage::Engine&gt; super::Engine for KV&lt;E&gt; {
</a>     }
 }
 
<a href="#h6-1-3" id="h6-1-3" class="d">-/// Serializes SQL metadata.
</a><a href="#h6-1-4" id="h6-1-4" class="d">-fn serialize&lt;V: Serialize&gt;(value: &amp;V) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h6-1-5" id="h6-1-5" class="d">-    bincode::serialize(value)
</a><a href="#h6-1-6" id="h6-1-6" class="d">-}
</a><a href="#h6-1-7" id="h6-1-7" class="d">-
</a><a href="#h6-1-8" id="h6-1-8" class="d">-/// Deserializes SQL metadata.
</a><a href="#h6-1-9" id="h6-1-9" class="d">-fn deserialize&lt;&#39;a, V: Deserialize&lt;&#39;a&gt;&gt;(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;V&gt; {
</a><a href="#h6-1-10" id="h6-1-10" class="d">-    bincode::deserialize(bytes)
</a><a href="#h6-1-11" id="h6-1-11" class="d">-}
</a><a href="#h6-1-12" id="h6-1-12" class="d">-
</a> /// An SQL transaction based on an MVCC key/value transaction
 pub struct Transaction&lt;E: storage::Engine&gt; {
     txn: storage::mvcc::Transaction&lt;E&gt;,
<a href="#h6-2" id="h6-2" class="h">@@ -95,7 +85,7 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>         Ok(self
             .txn
             .get(&amp;Key::Index(table.into(), column.into(), value.into()).encode()?)?
<a href="#h6-2-3" id="h6-2-3" class="d">-            .map(|v| deserialize(&amp;v))
</a><a href="#h6-2-4" id="h6-2-4" class="i">+            .map(|v| HashSet::&lt;Value&gt;::decode(&amp;v))
</a>             .transpose()?
             .unwrap_or_default())
     }
<a href="#h6-3" id="h6-3" class="h">@@ -112,7 +102,7 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>         if index.is_empty() {
             self.txn.delete(&amp;key)
         } else {
<a href="#h6-3-3" id="h6-3-3" class="d">-            self.txn.set(&amp;key, serialize(&amp;index)?)
</a><a href="#h6-3-4" id="h6-3-4" class="i">+            self.txn.set(&amp;key, index.encode()?)
</a>         }
     }
 }
<a href="#h6-4" id="h6-4" class="h">@@ -144,7 +134,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>                 id, table.name
             )));
         }
<a href="#h6-4-3" id="h6-4-3" class="d">-        self.txn.set(&amp;Key::Row((&amp;table.name).into(), (&amp;id).into()).encode()?, serialize(&amp;row)?)?;
</a><a href="#h6-4-4" id="h6-4-4" class="i">+        self.txn.set(&amp;Key::Row((&amp;table.name).into(), (&amp;id).into()).encode()?, row.encode()?)?;
</a> 
         // Update indexes
         for (i, column) in table.columns.iter().enumerate().filter(|(_, c)| c.index) {
<a href="#h6-5" id="h6-5" class="h">@@ -192,7 +182,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>     fn read(&amp;self, table: &amp;str, id: &amp;Value) -&gt; Result&lt;Option&lt;Row&gt;&gt; {
         self.txn
             .get(&amp;Key::Row(table.into(), id.into()).encode()?)?
<a href="#h6-5-3" id="h6-5-3" class="d">-            .map(|v| deserialize(&amp;v))
</a><a href="#h6-5-4" id="h6-5-4" class="i">+            .map(|v| Row::decode(&amp;v))
</a>             .transpose()
     }
 
<a href="#h6-6" id="h6-6" class="h">@@ -209,7 +199,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>             self.txn
                 .scan_prefix(&amp;KeyPrefix::Row((&amp;table.name).into()).encode()?)?
                 .iter()
<a href="#h6-6-3" id="h6-6-3" class="d">-                .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)))
</a><a href="#h6-6-4" id="h6-6-4" class="i">+                .map(|r| r.and_then(|(_, v)| Row::decode(&amp;v)))
</a>                 .filter_map(move |r| match r {
                     Ok(row) =&gt; match &amp;filter {
                         Some(filter) =&gt; match filter.evaluate(Some(&amp;row)) {
<a href="#h6-7" id="h6-7" class="h">@@ -248,7 +238,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>                         Key::Index(_, _, pk) =&gt; pk.into_owned(),
                         _ =&gt; return Err(Error::Internal(&quot;Invalid index key&quot;.into())),
                     };
<a href="#h6-7-3" id="h6-7-3" class="d">-                    Ok((value, deserialize(&amp;v)?))
</a><a href="#h6-7-4" id="h6-7-4" class="i">+                    Ok((value, HashSet::&lt;Value&gt;::decode(&amp;v)?))
</a>                 })
                 .collect::&lt;Vec&lt;_&gt;&gt;()
                 .into_iter(),
<a href="#h6-8" id="h6-8" class="h">@@ -283,7 +273,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         }
 
         table.validate_row(&amp;row, self)?;
<a href="#h6-8-3" id="h6-8-3" class="d">-        self.txn.set(&amp;Key::Row(table.name.into(), id.into()).encode()?, serialize(&amp;row)?)
</a><a href="#h6-8-4" id="h6-8-4" class="i">+        self.txn.set(&amp;Key::Row(table.name.into(), id.into()).encode()?, row.encode()?)
</a>     }
 }
 
<a href="#h6-9" id="h6-9" class="h">@@ -293,7 +283,7 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>             return Err(Error::Value(format!(&quot;Table {} already exists&quot;, table.name)));
         }
         table.validate(self)?;
<a href="#h6-9-3" id="h6-9-3" class="d">-        self.txn.set(&amp;Key::Table((&amp;table.name).into()).encode()?, serialize(&amp;table)?)
</a><a href="#h6-9-4" id="h6-9-4" class="i">+        self.txn.set(&amp;Key::Table((&amp;table.name).into()).encode()?, table.encode()?)
</a>     }
 
     fn delete_table(&amp;mut self, table: &amp;str) -&gt; Result&lt;()&gt; {
<a href="#h6-10" id="h6-10" class="h">@@ -312,7 +302,7 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>     }
 
     fn read_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;&gt; {
<a href="#h6-10-3" id="h6-10-3" class="d">-        self.txn.get(&amp;Key::Table(table.into()).encode()?)?.map(|v| deserialize(&amp;v)).transpose()
</a><a href="#h6-10-4" id="h6-10-4" class="i">+        self.txn.get(&amp;Key::Table(table.into()).encode()?)?.map(|v| Table::decode(&amp;v)).transpose()
</a>     }
 
     fn scan_tables(&amp;self) -&gt; Result&lt;Tables&gt; {
<a href="#h6-11" id="h6-11" class="h">@@ -320,7 +310,7 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>             self.txn
                 .scan_prefix(&amp;KeyPrefix::Table.encode()?)?
                 .iter()
<a href="#h6-11-3" id="h6-11-3" class="d">-                .map(|r| r.and_then(|(_, v)| deserialize(&amp;v)))
</a><a href="#h6-11-4" id="h6-11-4" class="i">+                .map(|r| r.and_then(|(_, v)| Table::decode(&amp;v)))
</a>                 .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
                 .into_iter(),
         ))
<a href="#h6-12" id="h6-12" class="h">@@ -341,15 +331,7 @@ enum Key&lt;&#39;a&gt; {
</a>     Row(Cow&lt;&#39;a, str&gt;, Cow&lt;&#39;a, Value&gt;),
 }
 
<a href="#h6-12-3" id="h6-12-3" class="d">-impl&lt;&#39;a&gt; Key&lt;&#39;a&gt; {
</a><a href="#h6-12-4" id="h6-12-4" class="d">-    fn encode(self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h6-12-5" id="h6-12-5" class="d">-        keycode::serialize(&amp;self)
</a><a href="#h6-12-6" id="h6-12-6" class="d">-    }
</a><a href="#h6-12-7" id="h6-12-7" class="d">-
</a><a href="#h6-12-8" id="h6-12-8" class="d">-    fn decode(bytes: &amp;[u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h6-12-9" id="h6-12-9" class="d">-        keycode::deserialize(bytes)
</a><a href="#h6-12-10" id="h6-12-10" class="d">-    }
</a><a href="#h6-12-11" id="h6-12-11" class="d">-}
</a><a href="#h6-12-12" id="h6-12-12" class="i">+impl&lt;&#39;a&gt; encoding::Key&lt;&#39;a&gt; for Key&lt;&#39;a&gt; {}
</a> 
 /// Key prefixes, allowing prefix scans of specific parts of the keyspace. These
 /// must match the keys -- in particular, the enum variant indexes must match.
<a href="#h6-13" id="h6-13" class="h">@@ -363,8 +345,4 @@ enum KeyPrefix&lt;&#39;a&gt; {
</a>     Row(Cow&lt;&#39;a, str&gt;),
 }
 
<a href="#h6-13-3" id="h6-13-3" class="d">-impl&lt;&#39;a&gt; KeyPrefix&lt;&#39;a&gt; {
</a><a href="#h6-13-4" id="h6-13-4" class="d">-    fn encode(self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h6-13-5" id="h6-13-5" class="d">-        keycode::serialize(&amp;self)
</a><a href="#h6-13-6" id="h6-13-6" class="d">-    }
</a><a href="#h6-13-7" id="h6-13-7" class="d">-}
</a><a href="#h6-13-8" id="h6-13-8" class="i">+impl&lt;&#39;a&gt; encoding::Key&lt;&#39;a&gt; for KeyPrefix&lt;&#39;a&gt; {}
</a><b>diff --git a/<a id="h7" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h7-0" id="h7-0" class="h">@@ -1,7 +1,7 @@
</a> use super::super::schema::{Catalog, Table, Tables};
 use super::super::types::{Expression, Row, Value};
 use super::{Engine as _, IndexScan, Scan, Transaction as _};
<a href="#h7-0-3" id="h7-0-3" class="d">-use crate::encoding::bincode;
</a><a href="#h7-0-4" id="h7-0-4" class="i">+use crate::encoding::{self, bincode, Value as _};
</a> use crate::error::{Error, Result};
 use crate::raft::{self, Entry};
 use crate::storage::{self, mvcc::TransactionState};
<a href="#h7-1" id="h7-1" class="h">@@ -35,6 +35,8 @@ enum Mutation {
</a>     DeleteTable { txn: TransactionState, table: String },
 }
 
<a href="#h7-1-3" id="h7-1-3" class="i">+impl encoding::Value for Mutation {}
</a><a href="#h7-1-4" id="h7-1-4" class="i">+
</a> /// A Raft state machine query.
 ///
 /// TODO: use Cows for these.
<a href="#h7-2" id="h7-2" class="h">@@ -60,6 +62,8 @@ enum Query {
</a>     ReadTable { txn: TransactionState, table: String },
 }
 
<a href="#h7-2-3" id="h7-2-3" class="i">+impl encoding::Value for Query {}
</a><a href="#h7-2-4" id="h7-2-4" class="i">+
</a> /// Status for the Raft SQL engine.
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub struct Status {
<a href="#h7-3" id="h7-3" class="h">@@ -89,7 +93,7 @@ impl Client {
</a>     /// Mutates the Raft state machine, deserializing the response into the
     /// return type.
     fn mutate&lt;V: DeserializeOwned&gt;(&amp;self, mutation: Mutation) -&gt; Result&lt;V&gt; {
<a href="#h7-3-3" id="h7-3-3" class="d">-        match self.execute(raft::Request::Write(bincode::serialize(&amp;mutation)?))? {
</a><a href="#h7-3-4" id="h7-3-4" class="i">+        match self.execute(raft::Request::Write(mutation.encode()?))? {
</a>             raft::Response::Write(response) =&gt; Ok(bincode::deserialize(&amp;response)?),
             resp =&gt; Err(Error::Internal(format!(&quot;Unexpected Raft mutation response {:?}&quot;, resp))),
         }
<a href="#h7-4" id="h7-4" class="h">@@ -98,7 +102,7 @@ impl Client {
</a>     /// Queries the Raft state machine, deserializing the response into the
     /// return type.
     fn query&lt;V: DeserializeOwned&gt;(&amp;self, query: Query) -&gt; Result&lt;V&gt; {
<a href="#h7-4-3" id="h7-4-3" class="d">-        match self.execute(raft::Request::Read(bincode::serialize(&amp;query)?))? {
</a><a href="#h7-4-4" id="h7-4-4" class="i">+        match self.execute(raft::Request::Read(query.encode()?))? {
</a>             raft::Response::Read(response) =&gt; Ok(bincode::deserialize(&amp;response)?),
             resp =&gt; Err(Error::Internal(format!(&quot;Unexpected Raft query response {:?}&quot;, resp))),
         }
<a href="#h7-5" id="h7-5" class="h">@@ -306,7 +310,7 @@ impl&lt;E: storage::Engine&gt; State&lt;E&gt; {
</a>     /// Mutates the state machine.
     fn mutate(&amp;mut self, mutation: Mutation) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
         match mutation {
<a href="#h7-5-3" id="h7-5-3" class="d">-            Mutation::Begin =&gt; bincode::serialize(&amp;self.engine.begin()?.state()),
</a><a href="#h7-5-4" id="h7-5-4" class="i">+            Mutation::Begin =&gt; self.engine.begin()?.state().encode(),
</a>             Mutation::Commit(txn) =&gt; bincode::serialize(&amp;self.engine.resume(txn)?.commit()?),
             Mutation::Rollback(txn) =&gt; bincode::serialize(&amp;self.engine.resume(txn)?.rollback()?),
 
<a href="#h7-6" id="h7-6" class="h">@@ -339,7 +343,7 @@ impl&lt;E: storage::Engine&gt; raft::State for State&lt;E&gt; {
</a>         assert_eq!(entry.index, self.applied_index + 1, &quot;entry index not after applied index&quot;);
 
         let result = match &amp;entry.command {
<a href="#h7-6-3" id="h7-6-3" class="d">-            Some(command) =&gt; match self.mutate(bincode::deserialize(command)?) {
</a><a href="#h7-6-4" id="h7-6-4" class="i">+            Some(command) =&gt; match self.mutate(Mutation::decode(command)?) {
</a>                 error @ Err(Error::Internal(_)) =&gt; return error, // don&#39;t record as applied
                 result =&gt; result,
             },
<a href="#h7-7" id="h7-7" class="h">@@ -351,39 +355,36 @@ impl&lt;E: storage::Engine&gt; raft::State for State&lt;E&gt; {
</a>     }
 
     fn read(&amp;self, command: Vec&lt;u8&gt;) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
<a href="#h7-7-3" id="h7-7-3" class="d">-        match bincode::deserialize(&amp;command)? {
</a><a href="#h7-7-4" id="h7-7-4" class="i">+        match Query::decode(&amp;command)? {
</a>             Query::BeginReadOnly { as_of } =&gt; {
                 let txn = if let Some(version) = as_of {
                     self.engine.begin_as_of(version)?
                 } else {
                     self.engine.begin_read_only()?
                 };
<a href="#h7-7-11" id="h7-7-11" class="d">-                bincode::serialize(&amp;txn.state())
</a><a href="#h7-7-12" id="h7-7-12" class="d">-            }
</a><a href="#h7-7-13" id="h7-7-13" class="d">-            Query::Read { txn, table, id } =&gt; {
</a><a href="#h7-7-14" id="h7-7-14" class="d">-                bincode::serialize(&amp;self.engine.resume(txn)?.read(&amp;table, &amp;id)?)
</a><a href="#h7-7-15" id="h7-7-15" class="i">+                txn.state().encode()
</a>             }
<a href="#h7-7-17" id="h7-7-17" class="i">+            Query::Read { txn, table, id } =&gt; self.engine.resume(txn)?.read(&amp;table, &amp;id)?.encode(),
</a>             Query::ReadIndex { txn, table, column, value } =&gt; {
<a href="#h7-7-19" id="h7-7-19" class="d">-                bincode::serialize(&amp;self.engine.resume(txn)?.read_index(&amp;table, &amp;column, &amp;value)?)
</a><a href="#h7-7-20" id="h7-7-20" class="i">+                self.engine.resume(txn)?.read_index(&amp;table, &amp;column, &amp;value)?.encode()
</a>             }
             // FIXME These need to stream rows somehow
<a href="#h7-7-23" id="h7-7-23" class="d">-            Query::Scan { txn, table, filter } =&gt; bincode::serialize(
</a><a href="#h7-7-24" id="h7-7-24" class="d">-                &amp;self.engine.resume(txn)?.scan(&amp;table, filter)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h7-7-25" id="h7-7-25" class="d">-            ),
</a><a href="#h7-7-26" id="h7-7-26" class="d">-            Query::ScanIndex { txn, table, column } =&gt; bincode::serialize(
</a><a href="#h7-7-27" id="h7-7-27" class="d">-                &amp;self
</a><a href="#h7-7-28" id="h7-7-28" class="d">-                    .engine
</a><a href="#h7-7-29" id="h7-7-29" class="d">-                    .resume(txn)?
</a><a href="#h7-7-30" id="h7-7-30" class="d">-                    .scan_index(&amp;table, &amp;column)?
</a><a href="#h7-7-31" id="h7-7-31" class="d">-                    .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?,
</a><a href="#h7-7-32" id="h7-7-32" class="d">-            ),
</a><a href="#h7-7-33" id="h7-7-33" class="d">-            Query::Status =&gt; bincode::serialize(&amp;self.engine.kv.status()?),
</a><a href="#h7-7-34" id="h7-7-34" class="i">+            Query::Scan { txn, table, filter } =&gt; {
</a><a href="#h7-7-35" id="h7-7-35" class="i">+                self.engine.resume(txn)?.scan(&amp;table, filter)?.collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?.encode()
</a><a href="#h7-7-36" id="h7-7-36" class="i">+            }
</a><a href="#h7-7-37" id="h7-7-37" class="i">+            Query::ScanIndex { txn, table, column } =&gt; self
</a><a href="#h7-7-38" id="h7-7-38" class="i">+                .engine
</a><a href="#h7-7-39" id="h7-7-39" class="i">+                .resume(txn)?
</a><a href="#h7-7-40" id="h7-7-40" class="i">+                .scan_index(&amp;table, &amp;column)?
</a><a href="#h7-7-41" id="h7-7-41" class="i">+                .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?
</a><a href="#h7-7-42" id="h7-7-42" class="i">+                .encode(),
</a><a href="#h7-7-43" id="h7-7-43" class="i">+            Query::Status =&gt; self.engine.kv.status()?.encode(),
</a> 
             Query::ReadTable { txn, table } =&gt; {
<a href="#h7-7-46" id="h7-7-46" class="d">-                bincode::serialize(&amp;self.engine.resume(txn)?.read_table(&amp;table)?)
</a><a href="#h7-7-47" id="h7-7-47" class="i">+                self.engine.resume(txn)?.read_table(&amp;table)?.encode()
</a>             }
             Query::ScanTables { txn } =&gt; {
<a href="#h7-7-50" id="h7-7-50" class="d">-                bincode::serialize(&amp;self.engine.resume(txn)?.scan_tables()?.collect::&lt;Vec&lt;_&gt;&gt;())
</a><a href="#h7-7-51" id="h7-7-51" class="i">+                self.engine.resume(txn)?.scan_tables()?.collect::&lt;Vec&lt;_&gt;&gt;().encode()
</a>             }
         }
     }
<b>diff --git a/<a id="h8" href="../file/src/sql/schema.rs.html">src/sql/schema.rs</a> b/<a href="../file/src/sql/schema.rs.html">src/sql/schema.rs</a></b>
<a href="#h8-0" id="h8-0" class="h">@@ -1,6 +1,7 @@
</a> use super::engine::Transaction;
 use super::parser::format_ident;
 use super::types::{DataType, Value};
<a href="#h8-0-3" id="h8-0-3" class="i">+use crate::encoding;
</a> use crate::error::{Error, Result};
 
 use serde_derive::{Deserialize, Serialize};
<a href="#h8-1" id="h8-1" class="h">@@ -53,6 +54,8 @@ pub struct Table {
</a>     pub columns: Vec&lt;Column&gt;,
 }
 
<a href="#h8-1-3" id="h8-1-3" class="i">+impl encoding::Value for Table {}
</a><a href="#h8-1-4" id="h8-1-4" class="i">+
</a> impl Table {
     /// Creates a new table schema
     pub fn new(name: String, columns: Vec&lt;Column&gt;) -&gt; Result&lt;Self&gt; {
<b>diff --git a/<a id="h9" href="../file/src/sql/types/mod.rs.html">src/sql/types/mod.rs</a> b/<a href="../file/src/sql/types/mod.rs.html">src/sql/types/mod.rs</a></b>
<a href="#h9-0" id="h9-0" class="h">@@ -1,6 +1,7 @@
</a> mod expression;
 pub use expression::Expression;
 
<a href="#h9-0-3" id="h9-0-3" class="i">+use crate::encoding;
</a> use crate::error::{Error, Result};
 
 use serde_derive::{Deserialize, Serialize};
<a href="#h9-1" id="h9-1" class="h">@@ -38,6 +39,8 @@ pub enum Value {
</a>     String(String),
 }
 
<a href="#h9-1-3" id="h9-1-3" class="i">+impl encoding::Value for Value {}
</a><a href="#h9-1-4" id="h9-1-4" class="i">+
</a> impl std::cmp::Eq for Value {}
 
 #[allow(clippy::derived_hash_with_manual_eq)]
<b>diff --git a/<a id="h10" href="../file/src/storage/debug.rs.html">src/storage/debug.rs</a> b/<a href="../file/src/storage/debug.rs.html">src/storage/debug.rs</a></b>
<a href="#h10-0" id="h10-0" class="h">@@ -6,7 +6,7 @@ use crossbeam::channel::{Receiver, Sender};
</a> 
 use super::engine::{self, ScanIterator, Status};
 use super::mvcc::{self, TransactionState};
<a href="#h10-0-3" id="h10-0-3" class="d">-use crate::encoding::bincode;
</a><a href="#h10-0-4" id="h10-0-4" class="i">+use crate::encoding::{bincode, Key as _};
</a> use crate::error::Result;
 
 /// Formats a raw byte string, either as a UTF-8 string (if valid and
<b>diff --git a/<a id="h11" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h11-0" id="h11-0" class="h">@@ -140,7 +140,7 @@
</a> //! travel queries (it&#39;s a feature, not a bug!).
 
 use super::engine::Engine;
<a href="#h11-0-3" id="h11-0-3" class="d">-use crate::encoding::{bincode, keycode};
</a><a href="#h11-0-4" id="h11-0-4" class="i">+use crate::encoding::{self, bincode, Key as _, Value as _};
</a> use crate::error::{Error, Result};
 
 use serde::{Deserialize, Serialize};
<a href="#h11-1" id="h11-1" class="h">@@ -153,6 +153,8 @@ use std::sync::{Arc, Mutex, MutexGuard};
</a> /// is incremented when beginning each read-write transaction.
 type Version = u64;
 
<a href="#h11-1-3" id="h11-1-3" class="i">+impl encoding::Value for Version {}
</a><a href="#h11-1-4" id="h11-1-4" class="i">+
</a> /// MVCC keys, using the KeyCode encoding which preserves the ordering and
 /// grouping of keys. Cow byte slices allow encoding borrowed values and
 /// decoding into owned values.
<a href="#h11-2" id="h11-2" class="h">@@ -191,15 +193,7 @@ pub enum Key&lt;&#39;a&gt; {
</a>     ),
 }
 
<a href="#h11-2-3" id="h11-2-3" class="d">-impl&lt;&#39;a&gt; Key&lt;&#39;a&gt; {
</a><a href="#h11-2-4" id="h11-2-4" class="d">-    pub fn decode(bytes: &amp;&#39;a [u8]) -&gt; Result&lt;Self&gt; {
</a><a href="#h11-2-5" id="h11-2-5" class="d">-        keycode::deserialize(bytes)
</a><a href="#h11-2-6" id="h11-2-6" class="d">-    }
</a><a href="#h11-2-7" id="h11-2-7" class="d">-
</a><a href="#h11-2-8" id="h11-2-8" class="d">-    pub fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h11-2-9" id="h11-2-9" class="d">-        keycode::serialize(&amp;self)
</a><a href="#h11-2-10" id="h11-2-10" class="d">-    }
</a><a href="#h11-2-11" id="h11-2-11" class="d">-}
</a><a href="#h11-2-12" id="h11-2-12" class="i">+impl&lt;&#39;a&gt; encoding::Key&lt;&#39;a&gt; for Key&lt;&#39;a&gt; {}
</a> 
 /// MVCC key prefixes, for prefix scans. These must match the keys above,
 /// including the enum variant index.
<a href="#h11-3" id="h11-3" class="h">@@ -217,11 +211,7 @@ enum KeyPrefix&lt;&#39;a&gt; {
</a>     Unversioned,
 }
 
<a href="#h11-3-3" id="h11-3-3" class="d">-impl&lt;&#39;a&gt; KeyPrefix&lt;&#39;a&gt; {
</a><a href="#h11-3-4" id="h11-3-4" class="d">-    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h11-3-5" id="h11-3-5" class="d">-        keycode::serialize(&amp;self)
</a><a href="#h11-3-6" id="h11-3-6" class="d">-    }
</a><a href="#h11-3-7" id="h11-3-7" class="d">-}
</a><a href="#h11-3-8" id="h11-3-8" class="i">+impl&lt;&#39;a&gt; encoding::Key&lt;&#39;a&gt; for KeyPrefix&lt;&#39;a&gt; {}
</a> 
 /// An MVCC-based transactional key-value engine. It wraps an underlying storage
 /// engine that&#39;s used for raw key/value storage.
<a href="#h11-4" id="h11-4" class="h">@@ -282,7 +272,7 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a>     pub fn status(&amp;self) -&gt; Result&lt;Status&gt; {
         let mut engine = self.engine.lock()?;
         let versions = match engine.get(&amp;Key::NextVersion.encode()?)? {
<a href="#h11-4-3" id="h11-4-3" class="d">-            Some(ref v) =&gt; bincode::deserialize::&lt;u64&gt;(v)? - 1,
</a><a href="#h11-4-4" id="h11-4-4" class="i">+            Some(ref v) =&gt; Version::decode(v)? - 1,
</a>             None =&gt; 0,
         };
         let active_txns = engine.scan_prefix(&amp;KeyPrefix::TxnActive.encode()?).count() as u64;
<a href="#h11-5" id="h11-5" class="h">@@ -301,6 +291,8 @@ pub struct Status {
</a>     pub storage: super::engine::Status,
 }
 
<a href="#h11-5-3" id="h11-5-3" class="i">+impl encoding::Value for Status {}
</a><a href="#h11-5-4" id="h11-5-4" class="i">+
</a> /// An MVCC transaction.
 pub struct Transaction&lt;E: Engine&gt; {
     /// The underlying engine, shared by all transactions.
<a href="#h11-6" id="h11-6" class="h">@@ -336,6 +328,8 @@ pub struct TransactionState {
</a>     pub active: HashSet&lt;Version&gt;,
 }
 
<a href="#h11-6-3" id="h11-6-3" class="i">+impl encoding::Value for TransactionState {}
</a><a href="#h11-6-4" id="h11-6-4" class="i">+
</a> impl TransactionState {
     /// Checks whether the given version is visible to this transaction.
     ///
<a href="#h11-7" id="h11-7" class="h">@@ -369,16 +363,16 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a> 
         // Allocate a new version to write at.
         let version = match session.get(&amp;Key::NextVersion.encode()?)? {
<a href="#h11-7-3" id="h11-7-3" class="d">-            Some(ref v) =&gt; bincode::deserialize(v)?,
</a><a href="#h11-7-4" id="h11-7-4" class="i">+            Some(ref v) =&gt; Version::decode(v)?,
</a>             None =&gt; 1,
         };
<a href="#h11-7-7" id="h11-7-7" class="d">-        session.set(&amp;Key::NextVersion.encode()?, bincode::serialize(&amp;(version + 1))?)?;
</a><a href="#h11-7-8" id="h11-7-8" class="i">+        session.set(&amp;Key::NextVersion.encode()?, (version + 1).encode()?)?;
</a> 
         // Fetch the current set of active transactions, persist it for
         // time-travel queries if non-empty, then add this txn to it.
         let active = Self::scan_active(&amp;mut session)?;
         if !active.is_empty() {
<a href="#h11-7-14" id="h11-7-14" class="d">-            session.set(&amp;Key::TxnActiveSnapshot(version).encode()?, bincode::serialize(&amp;active)?)?
</a><a href="#h11-7-15" id="h11-7-15" class="i">+            session.set(&amp;Key::TxnActiveSnapshot(version).encode()?, active.encode()?)?
</a>         }
         session.set(&amp;Key::TxnActive(version).encode()?, vec![])?;
         drop(session);
<a href="#h11-8" id="h11-8" class="h">@@ -395,7 +389,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a> 
         // Fetch the latest version.
         let mut version = match session.get(&amp;Key::NextVersion.encode()?)? {
<a href="#h11-8-3" id="h11-8-3" class="d">-            Some(ref v) =&gt; bincode::deserialize(v)?,
</a><a href="#h11-8-4" id="h11-8-4" class="i">+            Some(ref v) =&gt; Version::decode(v)?,
</a>             None =&gt; 1,
         };
 
<a href="#h11-9" id="h11-9" class="h">@@ -409,7 +403,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>             }
             version = as_of;
             if let Some(value) = session.get(&amp;Key::TxnActiveSnapshot(version).encode()?)? {
<a href="#h11-9-3" id="h11-9-3" class="d">-                active = bincode::deserialize(&amp;value)?;
</a><a href="#h11-9-4" id="h11-9-4" class="i">+                active = HashSet::&lt;Version&gt;::decode(&amp;value)?;
</a>             }
         } else {
             active = Self::scan_active(&amp;mut session)?;
</pre>
</div>
</body>
</html>
