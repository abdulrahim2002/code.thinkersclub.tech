<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>storage: use `[ops]` tag for engine operations in test scripts - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/4f4aca1e60d07bc34ca6b0a9b4251a7a9de6a28a.html">4f4aca1e60d07bc34ca6b0a9b4251a7a9de6a28a</a>
<b>parent</b> <a href="../commit/75eaf7c1262e94e04242daf3fb0e8d79627f5d67.html">75eaf7c1262e94e04242daf3fb0e8d79627f5d67</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Fri, 14 Jun 2024 00:09:05 +0200

storage: use `[ops]` tag for engine operations in test scripts

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/raft/log.rs</a></td><td> | </td><td class="num">71</td><td><span class="i">+++++++++++++++++++++++++++++++++++</span><span class="d">------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/raft/testscripts/log/append</a></td><td> | </td><td class="num">12</td><td><span class="i">++++++</span><span class="d">------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/raft/testscripts/log/commit</a></td><td> | </td><td class="num">6</td><td><span class="i">+++</span><span class="d">---</span></td></tr>
<tr><td class="M">M</td><td><a href="#h3">src/raft/testscripts/log/splice</a></td><td> | </td><td class="num">46</td><td><span class="i">+++++++++++++++++++++++</span><span class="d">-----------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h4">src/raft/testscripts/log/term</a></td><td> | </td><td class="num">14</td><td><span class="i">+++++++</span><span class="d">-------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h5">src/storage/mvcc.rs</a></td><td> | </td><td class="num">24</td><td><span class="i">++++++++++++</span><span class="d">------------</span></td></tr>
</table></pre><pre>6 files changed, 86 insertions(+), 87 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/raft/log.rs.html">src/raft/log.rs</a> b/<a href="../file/src/raft/log.rs.html">src/raft/log.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -343,8 +343,9 @@ mod tests {
</a>     use super::*;
     use crossbeam::channel::Receiver;
     use regex::Regex;
<a href="#h0-0-3" id="h0-0-3" class="i">+    use std::fmt::Write as _;
</a>     use std::{error::Error, result::Result};
<a href="#h0-0-5" id="h0-0-5" class="d">-    use storage::engine::test as testengine;
</a><a href="#h0-0-6" id="h0-0-6" class="i">+    use storage::engine::test::{self as testengine, Operation};
</a>     use test_each_file::test_each_path;
 
     // Run goldenscript tests in src/raft/testscripts/log.
<a href="#h0-1" id="h0-1" class="h">@@ -365,29 +366,24 @@ mod tests {
</a>     impl goldenscript::Runner for TestRunner {
         fn run(&amp;mut self, command: &amp;goldenscript::Command) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
             let mut output = String::new();
<a href="#h0-1-3" id="h0-1-3" class="d">-            // TODO: use [ops] tag instead of oplog= parameters. See MVCC runner.
</a>             match command.name.as_str() {
<a href="#h0-1-5" id="h0-1-5" class="d">-                // append [COMMAND] [oplog=BOOL]
</a><a href="#h0-1-6" id="h0-1-6" class="i">+                // append [COMMAND]
</a>                 &quot;append&quot; =&gt; {
                     let mut args = command.consume_args();
                     let command = args.next_pos().map(|a| a.value.as_bytes().to_vec());
<a href="#h0-1-10" id="h0-1-10" class="d">-                    let oplog = args.lookup_parse(&quot;oplog&quot;)?.unwrap_or(false);
</a>                     args.reject_rest()?;
                     let index = self.log.append(command)?;
                     let entry = self.log.get(index)?.expect(&quot;entry not found&quot;);
<a href="#h0-1-14" id="h0-1-14" class="d">-                    self.maybe_oplog(oplog, &amp;mut output);
</a>                     output.push_str(&amp;format!(&quot;append → {}\n&quot;, Self::format_entry(&amp;entry)));
                 }
 
<a href="#h0-1-18" id="h0-1-18" class="d">-                // commit INDEX [oplog=BOOL]
</a><a href="#h0-1-19" id="h0-1-19" class="i">+                // commit INDEX
</a>                 &quot;commit&quot; =&gt; {
                     let mut args = command.consume_args();
                     let index = args.next_pos().ok_or(&quot;index not given&quot;)?.parse()?;
<a href="#h0-1-23" id="h0-1-23" class="d">-                    let oplog = args.lookup_parse(&quot;oplog&quot;)?.unwrap_or(false);
</a>                     args.reject_rest()?;
                     let index = self.log.commit(index)?;
                     let entry = self.log.get(index)?.expect(&quot;entry not found&quot;);
<a href="#h0-1-27" id="h0-1-27" class="d">-                    self.maybe_oplog(oplog, &amp;mut output);
</a>                     output.push_str(&amp;format!(&quot;commit → {}\n&quot;, Self::format_entry(&amp;entry)));
                 }
 
<a href="#h0-2" id="h0-2" class="h">@@ -479,21 +475,18 @@ mod tests {
</a>                     }
                 }
 
<a href="#h0-2-3" id="h0-2-3" class="d">-                // set_term TERM [VOTE] [oplog=true]
</a><a href="#h0-2-4" id="h0-2-4" class="i">+                // set_term TERM [VOTE]
</a>                 &quot;set_term&quot; =&gt; {
                     let mut args = command.consume_args();
                     let term = args.next_pos().ok_or(&quot;term not given&quot;)?.parse()?;
                     let vote = args.next_pos().map(|a| a.parse()).transpose()?;
<a href="#h0-2-9" id="h0-2-9" class="d">-                    let oplog = args.lookup_parse(&quot;oplog&quot;)?.unwrap_or(false);
</a>                     args.reject_rest()?;
                     self.log.set_term(term, vote)?;
<a href="#h0-2-12" id="h0-2-12" class="d">-                    self.maybe_oplog(oplog, &amp;mut output);
</a>                 }
 
<a href="#h0-2-15" id="h0-2-15" class="d">-                // splice [INDEX@TERM=COMMAND...] [oplog=BOOL]
</a><a href="#h0-2-16" id="h0-2-16" class="i">+                // splice [INDEX@TERM=COMMAND...]
</a>                 &quot;splice&quot; =&gt; {
                     let mut args = command.consume_args();
<a href="#h0-2-19" id="h0-2-19" class="d">-                    let oplog = args.lookup_parse(&quot;oplog&quot;)?.unwrap_or(false);
</a>                     let mut entries = Vec::new();
                     for arg in args.rest_key() {
                         let (index, term) = Self::parse_index_term(arg.key.as_deref().unwrap())?;
<a href="#h0-3" id="h0-3" class="h">@@ -506,7 +499,6 @@ mod tests {
</a>                     args.reject_rest()?;
                     let index = self.log.splice(entries)?;
                     let entry = self.log.get(index)?.expect(&quot;entry not found&quot;);
<a href="#h0-3-3" id="h0-3-3" class="d">-                    self.maybe_oplog(oplog, &amp;mut output);
</a>                     output.push_str(&amp;format!(&quot;splice → {}\n&quot;, Self::format_entry(&amp;entry)));
                 }
 
<a href="#h0-4" id="h0-4" class="h">@@ -533,10 +525,35 @@ mod tests {
</a>             Ok(output)
         }
 
<a href="#h0-4-3" id="h0-4-3" class="d">-        fn end_command(&amp;mut self, _: &amp;goldenscript::Command) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
</a><a href="#h0-4-4" id="h0-4-4" class="d">-            // Drain the oplog, to avoid it leaking to another command.
</a><a href="#h0-4-5" id="h0-4-5" class="d">-            while self.op_rx.try_recv().is_ok() {}
</a><a href="#h0-4-6" id="h0-4-6" class="d">-            Ok(String::new())
</a><a href="#h0-4-7" id="h0-4-7" class="i">+        /// If requested via [ops] tag, output engine operations for the command.
</a><a href="#h0-4-8" id="h0-4-8" class="i">+        fn end_command(
</a><a href="#h0-4-9" id="h0-4-9" class="i">+            &amp;mut self,
</a><a href="#h0-4-10" id="h0-4-10" class="i">+            command: &amp;goldenscript::Command,
</a><a href="#h0-4-11" id="h0-4-11" class="i">+        ) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
</a><a href="#h0-4-12" id="h0-4-12" class="i">+            // Parse tags.
</a><a href="#h0-4-13" id="h0-4-13" class="i">+            let mut show_ops = false;
</a><a href="#h0-4-14" id="h0-4-14" class="i">+            for tag in &amp;command.tags {
</a><a href="#h0-4-15" id="h0-4-15" class="i">+                match tag.as_str() {
</a><a href="#h0-4-16" id="h0-4-16" class="i">+                    &quot;ops&quot; =&gt; show_ops = true,
</a><a href="#h0-4-17" id="h0-4-17" class="i">+                    tag =&gt; return Err(format!(&quot;invalid tag {tag}&quot;).into()),
</a><a href="#h0-4-18" id="h0-4-18" class="i">+                }
</a><a href="#h0-4-19" id="h0-4-19" class="i">+            }
</a><a href="#h0-4-20" id="h0-4-20" class="i">+
</a><a href="#h0-4-21" id="h0-4-21" class="i">+            // Process engine operations, either output or drain.
</a><a href="#h0-4-22" id="h0-4-22" class="i">+            let mut output = String::new();
</a><a href="#h0-4-23" id="h0-4-23" class="i">+            while let Ok(op) = self.op_rx.try_recv() {
</a><a href="#h0-4-24" id="h0-4-24" class="i">+                match op {
</a><a href="#h0-4-25" id="h0-4-25" class="i">+                    _ if !show_ops =&gt; {}
</a><a href="#h0-4-26" id="h0-4-26" class="i">+                    Operation::Delete { key } =&gt; {
</a><a href="#h0-4-27" id="h0-4-27" class="i">+                        writeln!(output, &quot;engine delete {}&quot;, Self::format_key(&amp;key))?
</a><a href="#h0-4-28" id="h0-4-28" class="i">+                    }
</a><a href="#h0-4-29" id="h0-4-29" class="i">+                    Operation::Flush =&gt; writeln!(output, &quot;engine flush&quot;)?,
</a><a href="#h0-4-30" id="h0-4-30" class="i">+                    Operation::Set { key, value } =&gt; {
</a><a href="#h0-4-31" id="h0-4-31" class="i">+                        writeln!(output, &quot;engine set {}&quot;, Self::format_key_value(&amp;key, &amp;value))?
</a><a href="#h0-4-32" id="h0-4-32" class="i">+                    }
</a><a href="#h0-4-33" id="h0-4-33" class="i">+                }
</a><a href="#h0-4-34" id="h0-4-34" class="i">+            }
</a><a href="#h0-4-35" id="h0-4-35" class="i">+            Ok(output)
</a>         }
     }
 
<a href="#h0-5" id="h0-5" class="h">@@ -573,24 +590,6 @@ mod tests {
</a>             format!(&quot;{} = 0x{}&quot;, Self::format_key(key), hex::encode(value))
         }
 
<a href="#h0-5-3" id="h0-5-3" class="d">-        /// Outputs the oplog if requested.
</a><a href="#h0-5-4" id="h0-5-4" class="d">-        fn maybe_oplog(&amp;self, maybe: bool, output: &amp;mut String) {
</a><a href="#h0-5-5" id="h0-5-5" class="d">-            if !maybe {
</a><a href="#h0-5-6" id="h0-5-6" class="d">-                return;
</a><a href="#h0-5-7" id="h0-5-7" class="d">-            }
</a><a href="#h0-5-8" id="h0-5-8" class="d">-            while let Ok(op) = self.op_rx.try_recv() {
</a><a href="#h0-5-9" id="h0-5-9" class="d">-                use testengine::Operation;
</a><a href="#h0-5-10" id="h0-5-10" class="d">-                let s = match op {
</a><a href="#h0-5-11" id="h0-5-11" class="d">-                    Operation::Delete { key } =&gt; format!(&quot;delete {}&quot;, Self::format_key(&amp;key)),
</a><a href="#h0-5-12" id="h0-5-12" class="d">-                    Operation::Flush =&gt; &quot;flush&quot;.to_string(),
</a><a href="#h0-5-13" id="h0-5-13" class="d">-                    Operation::Set { key, value } =&gt; {
</a><a href="#h0-5-14" id="h0-5-14" class="d">-                        format!(&quot;set {}&quot;, Self::format_key_value(&amp;key, &amp;value))
</a><a href="#h0-5-15" id="h0-5-15" class="d">-                    }
</a><a href="#h0-5-16" id="h0-5-16" class="d">-                };
</a><a href="#h0-5-17" id="h0-5-17" class="d">-                output.push_str(&amp;format!(&quot;engine: {s}\n&quot;));
</a><a href="#h0-5-18" id="h0-5-18" class="d">-            }
</a><a href="#h0-5-19" id="h0-5-19" class="d">-        }
</a><a href="#h0-5-20" id="h0-5-20" class="d">-
</a>         /// Parses an index@term pair.
         fn parse_index_term(s: &amp;str) -&gt; Result&lt;(Index, Term), Box&lt;dyn Error&gt;&gt; {
             let re = Regex::new(r&quot;^(\d+)@(\d+)$&quot;).expect(&quot;invalid regex&quot;);
<b>diff --git a/<a id="h1" href="../file/src/raft/testscripts/log/append.html">src/raft/testscripts/log/append</a> b/<a href="../file/src/raft/testscripts/log/append.html">src/raft/testscripts/log/append</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -6,18 +6,18 @@ Panic: can&#39;t append entry in term 0
</a> # Appending to an empty log works. The term doesn&#39;t have to be 1. The entry is
 # written to the engine and flushed to durable storage.
 set_term 2
<a href="#h1-0-3" id="h1-0-3" class="d">-append foo oplog=true
</a><a href="#h1-0-4" id="h1-0-4" class="i">+append foo [ops]
</a> ---
<a href="#h1-0-6" id="h1-0-6" class="d">-engine: set Entry(1) 0x000000000000000001 = 0x01020103666f6f
</a><a href="#h1-0-7" id="h1-0-7" class="d">-engine: flush
</a> append → 1@2 foo
<a href="#h1-0-9" id="h1-0-9" class="i">+engine set Entry(1) 0x000000000000000001 = 0x01020103666f6f
</a><a href="#h1-0-10" id="h1-0-10" class="i">+engine flush
</a> 
 # Appending a noop entry (no command) also works.
<a href="#h1-0-13" id="h1-0-13" class="d">-append oplog=true
</a><a href="#h1-0-14" id="h1-0-14" class="i">+append [ops]
</a> ---
<a href="#h1-0-16" id="h1-0-16" class="d">-engine: set Entry(2) 0x000000000000000002 = 0x020200
</a><a href="#h1-0-17" id="h1-0-17" class="d">-engine: flush
</a> append → 2@2 None
<a href="#h1-0-19" id="h1-0-19" class="i">+engine set Entry(2) 0x000000000000000002 = 0x020200
</a><a href="#h1-0-20" id="h1-0-20" class="i">+engine flush
</a> 
 # Check that the last index/term is updated (commit index isn&#39;t), and that
 # the engine contains the expected data, both in logical and raw form.
<b>diff --git a/<a id="h2" href="../file/src/raft/testscripts/log/commit.html">src/raft/testscripts/log/commit</a> b/<a href="../file/src/raft/testscripts/log/commit.html">src/raft/testscripts/log/commit</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -18,11 +18,11 @@ Panic: commit index 0 does not exist
</a> #
 # Show the engine operations too, and notice that the commit index isn&#39;t flushed
 # to durable storage (it can be recovered from the durable quorum logs).
<a href="#h2-0-3" id="h2-0-3" class="d">-commit 1 oplog=true
</a><a href="#h2-0-4" id="h2-0-4" class="i">+commit 1 [ops]
</a> status
 ---
<a href="#h2-0-7" id="h2-0-7" class="d">-engine: set CommitIndex 0x02 = 0x0101
</a> commit → 1@1 None
<a href="#h2-0-9" id="h2-0-9" class="i">+engine set CommitIndex 0x02 = 0x0101
</a> term=2 last=3@2 commit=1@1 vote=None
 
 # Dump the raw engine contents tdump
<a href="#h2-1" id="h2-1" class="h">@@ -35,7 +35,7 @@ TermVote 0x01 = 0x0200
</a> CommitIndex 0x02 = 0x0101
 
 # Commits are idempotent, which doesn&#39;t incur an engine set.
<a href="#h2-1-3" id="h2-1-3" class="d">-commit 1 oplog=true
</a><a href="#h2-1-4" id="h2-1-4" class="i">+commit 1 [ops]
</a> status
 ---
 commit → 1@1 None
<b>diff --git a/<a id="h3" href="../file/src/raft/testscripts/log/splice.html">src/raft/testscripts/log/splice</a> b/<a href="../file/src/raft/testscripts/log/splice.html">src/raft/testscripts/log/splice</a></b>
<a href="#h3-0" id="h3-0" class="h">@@ -20,20 +20,20 @@ Panic: first index 2 must touch existing log
</a> # starting at a term after 1. They should be written to the engine and flushed
 # to durable storage. It should also update the state.
 set_term 2
<a href="#h3-0-3" id="h3-0-3" class="d">-splice 1@2= 2@2=command oplog=true
</a><a href="#h3-0-4" id="h3-0-4" class="i">+splice 1@2= 2@2=command [ops]
</a> status
 scan
 ---
<a href="#h3-0-8" id="h3-0-8" class="d">-engine: set Entry(1) 0x000000000000000001 = 0x010200
</a><a href="#h3-0-9" id="h3-0-9" class="d">-engine: set Entry(2) 0x000000000000000002 = 0x02020107636f6d6d616e64
</a><a href="#h3-0-10" id="h3-0-10" class="d">-engine: flush
</a> splice → 2@2 command
<a href="#h3-0-12" id="h3-0-12" class="i">+engine set Entry(1) 0x000000000000000001 = 0x010200
</a><a href="#h3-0-13" id="h3-0-13" class="i">+engine set Entry(2) 0x000000000000000002 = 0x02020107636f6d6d616e64
</a><a href="#h3-0-14" id="h3-0-14" class="i">+engine flush
</a> term=2 last=2@2 commit=0@0 vote=None
 1@2 None
 2@2 command
 
 # Splicing an empty list should work and be a noop.
<a href="#h3-0-20" id="h3-0-20" class="d">-splice oplog=true
</a><a href="#h3-0-21" id="h3-0-21" class="i">+splice [ops]
</a> status
 scan
 ---
<a href="#h3-1" id="h3-1" class="h">@@ -75,7 +75,7 @@ Panic: splice term 3 beyond current 2
</a> Panic: splice term 4 beyond current 2
 
 # Fully overlapping entries is a noop.
<a href="#h3-1-3" id="h3-1-3" class="d">-splice 1@2= 2@2=command oplog=true
</a><a href="#h3-1-4" id="h3-1-4" class="i">+splice 1@2= 2@2=command [ops]
</a> scan
 ---
 splice → 2@2 command
<a href="#h3-2" id="h3-2" class="h">@@ -83,7 +83,7 @@ splice → 2@2 command
</a> 2@2 command
 
 # An overlapping prefix is a noop.
<a href="#h3-2-3" id="h3-2-3" class="d">-splice 1@2= oplog=true
</a><a href="#h3-2-4" id="h3-2-4" class="i">+splice 1@2= [ops]
</a> scan
 ---
 splice → 2@2 command
<a href="#h3-3" id="h3-3" class="h">@@ -91,7 +91,7 @@ splice → 2@2 command
</a> 2@2 command
 
 # An overlapping suffix is a noop.
<a href="#h3-3-3" id="h3-3-3" class="d">-splice 2@2=command oplog=true
</a><a href="#h3-3-4" id="h3-3-4" class="i">+splice 2@2=command [ops]
</a> scan
 ---
 splice → 2@2 command
<a href="#h3-4" id="h3-4" class="h">@@ -121,13 +121,13 @@ splice → 4@3 None
</a> 4@3 None
 
 # Splicing with suffix overlap should work, and only write the new entries.
<a href="#h3-4-3" id="h3-4-3" class="d">-splice 3@2=bar 4@3= 5@3=foo 6@3=bar oplog=true
</a><a href="#h3-4-4" id="h3-4-4" class="i">+splice 3@2=bar 4@3= 5@3=foo 6@3=bar [ops]
</a> scan
 ---
<a href="#h3-4-7" id="h3-4-7" class="d">-engine: set Entry(5) 0x000000000000000005 = 0x05030103666f6f
</a><a href="#h3-4-8" id="h3-4-8" class="d">-engine: set Entry(6) 0x000000000000000006 = 0x06030103626172
</a><a href="#h3-4-9" id="h3-4-9" class="d">-engine: flush
</a> splice → 6@3 bar
<a href="#h3-4-11" id="h3-4-11" class="i">+engine set Entry(5) 0x000000000000000005 = 0x05030103666f6f
</a><a href="#h3-4-12" id="h3-4-12" class="i">+engine set Entry(6) 0x000000000000000006 = 0x06030103626172
</a><a href="#h3-4-13" id="h3-4-13" class="i">+engine flush
</a> 1@2 None
 2@2 command
 3@2 bar
<a href="#h3-5" id="h3-5" class="h">@@ -137,15 +137,15 @@ splice → 6@3 bar
</a> 
 # Splicing at an existing index with a new term should replace the tail.
 set_term 4
<a href="#h3-5-3" id="h3-5-3" class="d">-splice 4@4= oplog=true
</a><a href="#h3-5-4" id="h3-5-4" class="i">+splice 4@4= [ops]
</a> status
 scan
 ---
<a href="#h3-5-8" id="h3-5-8" class="d">-engine: set Entry(4) 0x000000000000000004 = 0x040400
</a><a href="#h3-5-9" id="h3-5-9" class="d">-engine: delete Entry(5) 0x000000000000000005
</a><a href="#h3-5-10" id="h3-5-10" class="d">-engine: delete Entry(6) 0x000000000000000006
</a><a href="#h3-5-11" id="h3-5-11" class="d">-engine: flush
</a> splice → 4@4 None
<a href="#h3-5-13" id="h3-5-13" class="i">+engine set Entry(4) 0x000000000000000004 = 0x040400
</a><a href="#h3-5-14" id="h3-5-14" class="i">+engine delete Entry(5) 0x000000000000000005
</a><a href="#h3-5-15" id="h3-5-15" class="i">+engine delete Entry(6) 0x000000000000000006
</a><a href="#h3-5-16" id="h3-5-16" class="i">+engine flush
</a> term=4 last=4@4 commit=0@0 vote=None
 1@2 None
 2@2 command
<a href="#h3-6" id="h3-6" class="h">@@ -154,16 +154,16 @@ term=4 last=4@4 commit=0@0 vote=None
</a> 
 # This also holds at the start of the log.
 set_term 5
<a href="#h3-6-3" id="h3-6-3" class="d">-splice 1@5= 2@5=foo 3@5=bar oplog=true
</a><a href="#h3-6-4" id="h3-6-4" class="i">+splice 1@5= 2@5=foo 3@5=bar [ops]
</a> status
 scan
 ---
<a href="#h3-6-8" id="h3-6-8" class="d">-engine: set Entry(1) 0x000000000000000001 = 0x010500
</a><a href="#h3-6-9" id="h3-6-9" class="d">-engine: set Entry(2) 0x000000000000000002 = 0x02050103666f6f
</a><a href="#h3-6-10" id="h3-6-10" class="d">-engine: set Entry(3) 0x000000000000000003 = 0x03050103626172
</a><a href="#h3-6-11" id="h3-6-11" class="d">-engine: delete Entry(4) 0x000000000000000004
</a><a href="#h3-6-12" id="h3-6-12" class="d">-engine: flush
</a> splice → 3@5 bar
<a href="#h3-6-14" id="h3-6-14" class="i">+engine set Entry(1) 0x000000000000000001 = 0x010500
</a><a href="#h3-6-15" id="h3-6-15" class="i">+engine set Entry(2) 0x000000000000000002 = 0x02050103666f6f
</a><a href="#h3-6-16" id="h3-6-16" class="i">+engine set Entry(3) 0x000000000000000003 = 0x03050103626172
</a><a href="#h3-6-17" id="h3-6-17" class="i">+engine delete Entry(4) 0x000000000000000004
</a><a href="#h3-6-18" id="h3-6-18" class="i">+engine flush
</a> term=5 last=3@5 commit=0@0 vote=None
 1@5 None
 2@5 foo
<b>diff --git a/<a id="h4" href="../file/src/raft/testscripts/log/term.html">src/raft/testscripts/log/term</a> b/<a href="../file/src/raft/testscripts/log/term.html">src/raft/testscripts/log/term</a></b>
<a href="#h4-0" id="h4-0" class="h">@@ -10,23 +10,23 @@ Panic: can&#39;t set term 0
</a> 
 # set_term stores a term and empty vote, writing it to the engine
 # and flushing it to durable storage.
<a href="#h4-0-3" id="h4-0-3" class="d">-set_term 3 oplog=true
</a><a href="#h4-0-4" id="h4-0-4" class="i">+set_term 3 [ops]
</a> get_term
 ---
<a href="#h4-0-7" id="h4-0-7" class="d">-engine: set TermVote 0x01 = 0x0300
</a><a href="#h4-0-8" id="h4-0-8" class="d">-engine: flush
</a><a href="#h4-0-9" id="h4-0-9" class="i">+engine set TermVote 0x01 = 0x0300
</a><a href="#h4-0-10" id="h4-0-10" class="i">+engine flush
</a> term=3 vote=None
 
 # set_term stores a term and vote.
<a href="#h4-0-14" id="h4-0-14" class="d">-set_term 3 7 oplog=true
</a><a href="#h4-0-15" id="h4-0-15" class="i">+set_term 3 7 [ops]
</a> get_term
 ---
<a href="#h4-0-18" id="h4-0-18" class="d">-engine: set TermVote 0x01 = 0x030107
</a><a href="#h4-0-19" id="h4-0-19" class="d">-engine: flush
</a><a href="#h4-0-20" id="h4-0-20" class="i">+engine set TermVote 0x01 = 0x030107
</a><a href="#h4-0-21" id="h4-0-21" class="i">+engine flush
</a> term=3 vote=7
 
 # set_term is idempotent, which doesn&#39;t incur an engine write.
<a href="#h4-0-25" id="h4-0-25" class="d">-set_term 3 7 oplog=true
</a><a href="#h4-0-26" id="h4-0-26" class="i">+set_term 3 7 [ops]
</a> get_term
 ---
 term=3 vote=7
<b>diff --git a/<a id="h5" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h5-0" id="h5-0" class="h">@@ -829,12 +829,6 @@ pub mod tests {
</a> 
     impl goldenscript::Runner for MVCCRunner {
         fn run(&amp;mut self, command: &amp;goldenscript::Command) -&gt; StdResult&lt;String, Box&lt;dyn StdError&gt;&gt; {
<a href="#h5-0-3" id="h5-0-3" class="d">-            // Validate tags.
</a><a href="#h5-0-4" id="h5-0-4" class="d">-            if let Some(tag) = command.tags.iter().find(|t| *t != &quot;ops&quot;) {
</a><a href="#h5-0-5" id="h5-0-5" class="d">-                return Err(format!(&quot;invalid tag {tag}&quot;).into());
</a><a href="#h5-0-6" id="h5-0-6" class="d">-            }
</a><a href="#h5-0-7" id="h5-0-7" class="d">-
</a><a href="#h5-0-8" id="h5-0-8" class="d">-            // Execute command.
</a>             let mut output = String::new();
             match command.name.as_str() {
                 // txn: begin [readonly] [as_of=VERSION]
<a href="#h5-1" id="h5-1" class="h">@@ -1051,19 +1045,25 @@ pub mod tests {
</a>             Ok(output)
         }
 
<a href="#h5-1-3" id="h5-1-3" class="i">+        /// If requested via [ops] tag, output engine operations for the command.
</a>         fn end_command(
             &amp;mut self,
             command: &amp;goldenscript::Command,
         ) -&gt; StdResult&lt;String, Box&lt;dyn StdError&gt;&gt; {
<a href="#h5-1-8" id="h5-1-8" class="d">-            let mut output = String::new();
</a><a href="#h5-1-9" id="h5-1-9" class="i">+            // Parse tags.
</a><a href="#h5-1-10" id="h5-1-10" class="i">+            let mut show_ops = false;
</a><a href="#h5-1-11" id="h5-1-11" class="i">+            for tag in &amp;command.tags {
</a><a href="#h5-1-12" id="h5-1-12" class="i">+                match tag.as_str() {
</a><a href="#h5-1-13" id="h5-1-13" class="i">+                    &quot;ops&quot; =&gt; show_ops = true,
</a><a href="#h5-1-14" id="h5-1-14" class="i">+                    tag =&gt; return Err(format!(&quot;invalid tag {tag}&quot;).into()),
</a><a href="#h5-1-15" id="h5-1-15" class="i">+                }
</a><a href="#h5-1-16" id="h5-1-16" class="i">+            }
</a> 
<a href="#h5-1-18" id="h5-1-18" class="d">-            // Output engine operations, if requested. Otherwise, drain them.
</a><a href="#h5-1-19" id="h5-1-19" class="d">-            let show_ops = command.tags.contains(&amp;&quot;ops&quot;.to_string());
</a><a href="#h5-1-20" id="h5-1-20" class="i">+            // Process engine operations, either output or drain.
</a><a href="#h5-1-21" id="h5-1-21" class="i">+            let mut output = String::new();
</a>             while let Ok(op) = self.op_rx.try_recv() {
<a href="#h5-1-23" id="h5-1-23" class="d">-                if !show_ops {
</a><a href="#h5-1-24" id="h5-1-24" class="d">-                    continue;
</a><a href="#h5-1-25" id="h5-1-25" class="d">-                }
</a>                 match op {
<a href="#h5-1-27" id="h5-1-27" class="i">+                    _ if !show_ops =&gt; {}
</a>                     Operation::Delete { key } =&gt; {
                         let (fkey, _) = debug::format_key_value(&amp;key, &amp;None);
                         writeln!(output, &quot;engine delete {fkey}&quot;)?
</pre>
</div>
</body>
</html>
