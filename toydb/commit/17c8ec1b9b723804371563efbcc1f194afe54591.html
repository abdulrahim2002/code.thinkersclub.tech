<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Use prefix scans in MVCC. - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/17c8ec1b9b723804371563efbcc1f194afe54591.html">17c8ec1b9b723804371563efbcc1f194afe54591</a>
<b>parent</b> <a href="../commit/bcc4b0b500332ff15033c43ec865f30e1667af58.html">bcc4b0b500332ff15033c43ec865f30e1667af58</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Wed,  6 Sep 2023 20:47:42 +0200

Use prefix scans in MVCC.

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/storage/mvcc.rs</a></td><td> | </td><td class="num">85</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++++++++++++++++</span><span class="d">--------------------------</span></td></tr>
</table></pre><pre>1 file changed, 57 insertions(+), 28 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a> b/<a href="../file/src/storage/mvcc.rs.html">src/storage/mvcc.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -58,6 +58,28 @@ impl&lt;&#39;a&gt; Key&lt;&#39;a&gt; {
</a>     }
 }
 
<a href="#h0-0-3" id="h0-0-3" class="i">+/// MVCC key prefixes, for prefix scans. These must match the keys above,
</a><a href="#h0-0-4" id="h0-0-4" class="i">+/// including the enum variant index.
</a><a href="#h0-0-5" id="h0-0-5" class="i">+#[derive(Debug, Deserialize, Serialize)]
</a><a href="#h0-0-6" id="h0-0-6" class="i">+enum KeyPrefix&lt;&#39;a&gt; {
</a><a href="#h0-0-7" id="h0-0-7" class="i">+    NextVersion,
</a><a href="#h0-0-8" id="h0-0-8" class="i">+    TxnActive,
</a><a href="#h0-0-9" id="h0-0-9" class="i">+    TxnActiveSnapshot,
</a><a href="#h0-0-10" id="h0-0-10" class="i">+    TxnUpdate(Version),
</a><a href="#h0-0-11" id="h0-0-11" class="i">+    Version(
</a><a href="#h0-0-12" id="h0-0-12" class="i">+        #[serde(with = &quot;serde_bytes&quot;)]
</a><a href="#h0-0-13" id="h0-0-13" class="i">+        #[serde(borrow)]
</a><a href="#h0-0-14" id="h0-0-14" class="i">+        Cow&lt;&#39;a, [u8]&gt;,
</a><a href="#h0-0-15" id="h0-0-15" class="i">+    ),
</a><a href="#h0-0-16" id="h0-0-16" class="i">+    Unversioned,
</a><a href="#h0-0-17" id="h0-0-17" class="i">+}
</a><a href="#h0-0-18" id="h0-0-18" class="i">+
</a><a href="#h0-0-19" id="h0-0-19" class="i">+impl&lt;&#39;a&gt; KeyPrefix&lt;&#39;a&gt; {
</a><a href="#h0-0-20" id="h0-0-20" class="i">+    fn encode(&amp;self) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
</a><a href="#h0-0-21" id="h0-0-21" class="i">+        keycode::serialize(&amp;self)
</a><a href="#h0-0-22" id="h0-0-22" class="i">+    }
</a><a href="#h0-0-23" id="h0-0-23" class="i">+}
</a><a href="#h0-0-24" id="h0-0-24" class="i">+
</a> /// MVCC status
 #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
 pub struct Status {
<a href="#h0-1" id="h0-1" class="h">@@ -128,7 +150,7 @@ impl&lt;E: Engine&gt; MVCC&lt;E&gt; {
</a>                 None =&gt; 1,
             } - 1,
             txns_active: engine
<a href="#h0-1-3" id="h0-1-3" class="d">-                .scan(Key::TxnActive(0).encode()?..Key::TxnActive(std::u64::MAX).encode()?)
</a><a href="#h0-1-4" id="h0-1-4" class="i">+                .scan_prefix(&amp;KeyPrefix::TxnActive.encode()?)
</a>                 .try_fold(0, |count, r| r.map(|_| count + 1))?,
         });
     }
<a href="#h0-2" id="h0-2" class="h">@@ -235,9 +257,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>     /// Scans the set of currently active transactions.
     fn scan_active(session: &amp;mut MutexGuard&lt;E&gt;) -&gt; Result&lt;HashSet&lt;Version&gt;&gt; {
         let mut active = HashSet::new();
<a href="#h0-2-3" id="h0-2-3" class="d">-        // TODO: Add Engine.scan_prefix() trait method.
</a><a href="#h0-2-4" id="h0-2-4" class="d">-        let mut scan =
</a><a href="#h0-2-5" id="h0-2-5" class="d">-            session.scan(Key::TxnActive(0).encode()?..=Key::TxnActive(u64::MAX).encode()?);
</a><a href="#h0-2-6" id="h0-2-6" class="i">+        let mut scan = session.scan_prefix(&amp;KeyPrefix::TxnActive.encode()?);
</a>         while let Some((key, _)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::TxnActive(version) =&gt; active.insert(version),
<a href="#h0-3" id="h0-3" class="h">@@ -281,10 +301,7 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a>         }
         let mut session = self.engine.lock()?;
         let mut rollback = Vec::new();
<a href="#h0-3-3" id="h0-3-3" class="d">-        let mut scan = session.scan(
</a><a href="#h0-3-4" id="h0-3-4" class="d">-            Key::TxnUpdate(self.version, vec![].into()).encode()?
</a><a href="#h0-3-5" id="h0-3-5" class="d">-                ..Key::TxnUpdate(self.version + 1, vec![].into()).encode()?,
</a><a href="#h0-3-6" id="h0-3-6" class="d">-        );
</a><a href="#h0-3-7" id="h0-3-7" class="i">+        let mut scan = session.scan_prefix(&amp;KeyPrefix::TxnUpdate(self.version).encode()?);
</a>         while let Some((key, _)) = scan.next().transpose()? {
             match Key::decode(&amp;key)? {
                 Key::TxnUpdate(_, updated_key) =&gt; rollback.push(updated_key.into_owned()),
<a href="#h0-4" id="h0-4" class="h">@@ -356,26 +373,15 @@ impl&lt;E: Engine&gt; Transaction&lt;E&gt; {
</a> 
     /// Scans keys under a given prefix.
     pub fn scan_prefix(&amp;self, prefix: &amp;[u8]) -&gt; Result&lt;ScanIterator&gt; {
<a href="#h0-4-3" id="h0-4-3" class="d">-        if prefix.is_empty() {
</a><a href="#h0-4-4" id="h0-4-4" class="d">-            return Err(Error::Internal(&quot;Scan prefix cannot be empty&quot;.into()));
</a><a href="#h0-4-5" id="h0-4-5" class="d">-        }
</a><a href="#h0-4-6" id="h0-4-6" class="d">-        let start = prefix.to_vec();
</a><a href="#h0-4-7" id="h0-4-7" class="d">-        let mut end = start.clone();
</a><a href="#h0-4-8" id="h0-4-8" class="d">-        for i in (0..end.len()).rev() {
</a><a href="#h0-4-9" id="h0-4-9" class="d">-            match end[i] {
</a><a href="#h0-4-10" id="h0-4-10" class="d">-                // If all 0xff we could in principle use Range::Unbounded, but it won&#39;t happen
</a><a href="#h0-4-11" id="h0-4-11" class="d">-                0xff if i == 0 =&gt; return Err(Error::Internal(&quot;Invalid prefix scan range&quot;.into())),
</a><a href="#h0-4-12" id="h0-4-12" class="d">-                0xff =&gt; {
</a><a href="#h0-4-13" id="h0-4-13" class="d">-                    end[i] = 0x00;
</a><a href="#h0-4-14" id="h0-4-14" class="d">-                    continue;
</a><a href="#h0-4-15" id="h0-4-15" class="d">-                }
</a><a href="#h0-4-16" id="h0-4-16" class="d">-                v =&gt; {
</a><a href="#h0-4-17" id="h0-4-17" class="d">-                    end[i] = v + 1;
</a><a href="#h0-4-18" id="h0-4-18" class="d">-                    break;
</a><a href="#h0-4-19" id="h0-4-19" class="d">-                }
</a><a href="#h0-4-20" id="h0-4-20" class="d">-            }
</a><a href="#h0-4-21" id="h0-4-21" class="d">-        }
</a><a href="#h0-4-22" id="h0-4-22" class="d">-        self.scan(start..end)
</a><a href="#h0-4-23" id="h0-4-23" class="i">+        // Normally, KeyPrefix::Version will only match all versions of the
</a><a href="#h0-4-24" id="h0-4-24" class="i">+        // exact given key. We want all keys maching the prefix, so we chop off
</a><a href="#h0-4-25" id="h0-4-25" class="i">+        // the KeyCode byte slice terminator 0x0000 at the end.
</a><a href="#h0-4-26" id="h0-4-26" class="i">+        let prefix = KeyPrefix::Version(prefix.into()).encode()?;
</a><a href="#h0-4-27" id="h0-4-27" class="i">+        let prefix = &amp;prefix[..prefix.len() - 2];
</a><a href="#h0-4-28" id="h0-4-28" class="i">+        // TODO: For now, collect results from the engine to not have to deal with lifetimes.
</a><a href="#h0-4-29" id="h0-4-29" class="i">+        let scan =
</a><a href="#h0-4-30" id="h0-4-30" class="i">+            Box::new(self.engine.lock()?.scan_prefix(prefix).collect::&lt;Vec&lt;_&gt;&gt;().into_iter());
</a><a href="#h0-4-31" id="h0-4-31" class="i">+        Ok(Box::new(Scan::new(scan, self.version, self.read_only, self.active.clone())))
</a>     }
 
     /// Sets a key.
<a href="#h0-5" id="h0-5" class="h">@@ -537,6 +543,29 @@ pub mod tests {
</a>     }
 
     #[test]
<a href="#h0-5-3" id="h0-5-3" class="i">+    /// Tests that key prefixes are actually prefixes of keys.
</a><a href="#h0-5-4" id="h0-5-4" class="i">+    fn test_key_prefix() -&gt; Result&lt;()&gt; {
</a><a href="#h0-5-5" id="h0-5-5" class="i">+        let cases = vec![
</a><a href="#h0-5-6" id="h0-5-6" class="i">+            (KeyPrefix::NextVersion, Key::NextVersion),
</a><a href="#h0-5-7" id="h0-5-7" class="i">+            (KeyPrefix::TxnActive, Key::TxnActive(1)),
</a><a href="#h0-5-8" id="h0-5-8" class="i">+            (KeyPrefix::TxnActiveSnapshot, Key::TxnActiveSnapshot(1)),
</a><a href="#h0-5-9" id="h0-5-9" class="i">+            (KeyPrefix::TxnUpdate(1), Key::TxnUpdate(1, b&quot;foo&quot;.as_slice().into())),
</a><a href="#h0-5-10" id="h0-5-10" class="i">+            (
</a><a href="#h0-5-11" id="h0-5-11" class="i">+                KeyPrefix::Version(b&quot;foo&quot;.as_slice().into()),
</a><a href="#h0-5-12" id="h0-5-12" class="i">+                Key::Version(b&quot;foo&quot;.as_slice().into(), 1),
</a><a href="#h0-5-13" id="h0-5-13" class="i">+            ),
</a><a href="#h0-5-14" id="h0-5-14" class="i">+            (KeyPrefix::Unversioned, Key::Unversioned(b&quot;foo&quot;.as_slice().into())),
</a><a href="#h0-5-15" id="h0-5-15" class="i">+        ];
</a><a href="#h0-5-16" id="h0-5-16" class="i">+
</a><a href="#h0-5-17" id="h0-5-17" class="i">+        for (prefix, key) in cases {
</a><a href="#h0-5-18" id="h0-5-18" class="i">+            let prefix = prefix.encode()?;
</a><a href="#h0-5-19" id="h0-5-19" class="i">+            let key = key.encode()?;
</a><a href="#h0-5-20" id="h0-5-20" class="i">+            assert_eq!(prefix, key[..prefix.len()])
</a><a href="#h0-5-21" id="h0-5-21" class="i">+        }
</a><a href="#h0-5-22" id="h0-5-22" class="i">+        Ok(())
</a><a href="#h0-5-23" id="h0-5-23" class="i">+    }
</a><a href="#h0-5-24" id="h0-5-24" class="i">+
</a><a href="#h0-5-25" id="h0-5-25" class="i">+    #[test]
</a>     fn test_begin() -&gt; Result&lt;()&gt; {
         let mvcc = setup();
 
</pre>
</div>
</body>
</html>
