<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>sql: clean up `Engine` trait - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/969c9a592a40f404e77aedb37d5de2ee5175a14a.html">969c9a592a40f404e77aedb37d5de2ee5175a14a</a>
<b>parent</b> <a href="../commit/1269f8e027afff8ec962d3bfc67f18e51f7d829f.html">1269f8e027afff8ec962d3bfc67f18e51f7d829f</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Tue, 18 Jun 2024 17:40:09 +0200

sql: clean up `Engine` trait

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/sql/engine/engine.rs</a></td><td> | </td><td class="num">75</td><td><span class="i">+++++++++++++++++++++++++++++++++++</span><span class="d">----------------------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/sql/engine/local.rs</a></td><td> | </td><td class="num">25</td><td><span class="i">+++++++++++++++++++++++</span><span class="d">--</span></td></tr>
</table></pre><pre>2 files changed, 58 insertions(+), 42 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/sql/engine/engine.rs.html">src/sql/engine/engine.rs</a> b/<a href="../file/src/sql/engine/engine.rs.html">src/sql/engine/engine.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -9,9 +9,14 @@ use crate::storage::mvcc;
</a> 
 use std::collections::{HashMap, HashSet};
 
<a href="#h0-0-3" id="h0-0-3" class="d">-/// The SQL engine interface.
</a><a href="#h0-0-4" id="h0-0-4" class="i">+/// A SQL engine. This provides low-level CRUD (create, read, update, delete)
</a><a href="#h0-0-5" id="h0-0-5" class="i">+/// operations for table rows, a schema catalog for accessing and modifying
</a><a href="#h0-0-6" id="h0-0-6" class="i">+/// table schemas, and interactive SQL sessions that execute client SQL
</a><a href="#h0-0-7" id="h0-0-7" class="i">+/// statements. All engine access is transactional with snapshot isolation.
</a> pub trait Engine&lt;&#39;a&gt;: Sized {
<a href="#h0-0-9" id="h0-0-9" class="d">-    /// The transaction type.
</a><a href="#h0-0-10" id="h0-0-10" class="i">+    /// The engine&#39;s transaction type. This provides both row-level CRUD
</a><a href="#h0-0-11" id="h0-0-11" class="i">+    /// operations as well as transactional access to the schema catalog. It
</a><a href="#h0-0-12" id="h0-0-12" class="i">+    /// can&#39;t outlive the engine.
</a>     type Transaction: Transaction + Catalog + &#39;a;
 
     /// Begins a read-write transaction.
<a href="#h0-1" id="h0-1" class="h">@@ -21,19 +26,22 @@ pub trait Engine&lt;&#39;a&gt;: Sized {
</a>     /// Begins a read-only transaction as of a historical version.
     fn begin_as_of(&amp;self, version: mvcc::Version) -&gt; Result&lt;Self::Transaction&gt;;
 
<a href="#h0-1-3" id="h0-1-3" class="d">-    /// Creates a client session for executing SQL statements.
</a><a href="#h0-1-4" id="h0-1-4" class="i">+    /// Creates a session for executing SQL statements. Can&#39;t outlive engine.
</a>     fn session(&amp;&#39;a self) -&gt; Session&lt;&#39;a, Self&gt; {
         Session::new(self)
     }
 }
 
<a href="#h0-1-10" id="h0-1-10" class="d">-/// A SQL transaction.
</a><a href="#h0-1-11" id="h0-1-11" class="i">+/// A SQL transaction. Executes transactional CRUD operations on table rows.
</a><a href="#h0-1-12" id="h0-1-12" class="i">+/// Provides snapshot isolation (see `storage::mvcc` module for details).
</a> ///
 /// All methods operate on row batches rather than single rows to amortize the
<a href="#h0-1-15" id="h0-1-15" class="d">-/// cost. We have to do a Raft roundtrip for every call, and we&#39;d rather not
</a><a href="#h0-1-16" id="h0-1-16" class="d">-/// have to do a Raft roundtrip for every row.
</a><a href="#h0-1-17" id="h0-1-17" class="i">+/// cost. With the Raft engine, each call results in a Raft roundtrip, and we&#39;d
</a><a href="#h0-1-18" id="h0-1-18" class="i">+/// rather not have to do that for every single row that&#39;s modified.
</a><a href="#h0-1-19" id="h0-1-19" class="i">+///
</a><a href="#h0-1-20" id="h0-1-20" class="i">+/// TODO: decide whether to use borrowed, owned, or Cowed parameters.
</a> pub trait Transaction {
<a href="#h0-1-22" id="h0-1-22" class="d">-    /// The transaction&#39;s MVCC version.
</a><a href="#h0-1-23" id="h0-1-23" class="i">+    /// The transaction&#39;s MVCC version. Unique for read/write transactions.
</a>     fn version(&amp;self) -&gt; mvcc::Version;
     /// Whether the transaction is read-only.
     fn read_only(&amp;self) -&gt; bool;
<a href="#h0-2" id="h0-2" class="h">@@ -43,62 +51,49 @@ pub trait Transaction {
</a>     /// Rolls back the transaction.
     fn rollback(self) -&gt; Result&lt;()&gt;;
 
<a href="#h0-2-3" id="h0-2-3" class="d">-    /// Deletes table rows by primary key.
</a><a href="#h0-2-4" id="h0-2-4" class="i">+    /// Deletes table rows by primary key, if they exist.
</a>     fn delete(&amp;self, table: &amp;str, ids: &amp;[Value]) -&gt; Result&lt;()&gt;;
<a href="#h0-2-6" id="h0-2-6" class="d">-    /// Fetches table rows by primary key.
</a><a href="#h0-2-7" id="h0-2-7" class="i">+    /// Fetches table rows by primary key, if they exist.
</a>     fn get(&amp;self, table: &amp;str, ids: &amp;[Value]) -&gt; Result&lt;Vec&lt;Row&gt;&gt;;
     /// Inserts new table rows.
     fn insert(&amp;self, table: &amp;str, rows: Vec&lt;Row&gt;) -&gt; Result&lt;()&gt;;
<a href="#h0-2-11" id="h0-2-11" class="d">-    /// Looks up a set of table primary keys by an index value.
</a><a href="#h0-2-12" id="h0-2-12" class="d">-    /// TODO: should this just return a Vec instead?
</a><a href="#h0-2-13" id="h0-2-13" class="i">+    /// Looks up a set of primary keys by index values.
</a>     fn lookup_index(&amp;self, table: &amp;str, column: &amp;str, values: &amp;[Value]) -&gt; Result&lt;HashSet&lt;Value&gt;&gt;;
     /// Scans a table&#39;s rows, optionally applying the given filter.
     fn scan(&amp;self, table: &amp;str, filter: Option&lt;Expression&gt;) -&gt; Result&lt;Rows&gt;;
<a href="#h0-2-17" id="h0-2-17" class="d">-    /// Scans a column&#39;s index entries.
</a><a href="#h0-2-18" id="h0-2-18" class="d">-    /// TODO: this is only used for tests. Remove it?
</a><a href="#h0-2-19" id="h0-2-19" class="d">-    fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;IndexScan&gt;;
</a>     /// Updates table rows by primary key.
     fn update(&amp;self, table: &amp;str, rows: HashMap&lt;Value, Row&gt;) -&gt; Result&lt;()&gt;;
<a href="#h0-2-22" id="h0-2-22" class="i">+
</a><a href="#h0-2-23" id="h0-2-23" class="i">+    /// Scans a column&#39;s index entries.
</a><a href="#h0-2-24" id="h0-2-24" class="i">+    /// TODO: this is only used for tests, remove it.
</a><a href="#h0-2-25" id="h0-2-25" class="i">+    fn scan_index(&amp;self, table: &amp;str, column: &amp;str) -&gt; Result&lt;IndexScan&gt;;
</a> }
 
 /// An index scan iterator.
 pub type IndexScan = Box&lt;dyn Iterator&lt;Item = Result&lt;(Value, HashSet&lt;Value&gt;)&gt;&gt;&gt;;
 
<a href="#h0-2-31" id="h0-2-31" class="d">-/// The catalog stores schema information.
</a><a href="#h0-2-32" id="h0-2-32" class="i">+/// The catalog stores table schema information. It is required for
</a><a href="#h0-2-33" id="h0-2-33" class="i">+/// Engine::Transaction, and thus fully transactional. For simplicity, it only
</a><a href="#h0-2-34" id="h0-2-34" class="i">+/// supports very simple operations: creating and dropping tables. There are no
</a><a href="#h0-2-35" id="h0-2-35" class="i">+/// ALTER TABLE schema changes, nor CREATE INDEX -- everything has to be
</a><a href="#h0-2-36" id="h0-2-36" class="i">+/// specified when the table is initially created.
</a><a href="#h0-2-37" id="h0-2-37" class="i">+///
</a><a href="#h0-2-38" id="h0-2-38" class="i">+/// This type is separate from Transaction, even though Engine::Transaction
</a><a href="#h0-2-39" id="h0-2-39" class="i">+/// requires transactions to implement it. This allows better control of when
</a><a href="#h0-2-40" id="h0-2-40" class="i">+/// catalog access should be used (i.e. during planning, not execution).
</a> pub trait Catalog {
<a href="#h0-2-42" id="h0-2-42" class="d">-    /// Creates a new table.
</a><a href="#h0-2-43" id="h0-2-43" class="i">+    /// Creates a new table. Errors if it already exists.
</a>     fn create_table(&amp;self, table: Table) -&gt; Result&lt;()&gt;;
     /// Drops a table. Errors if it does not exist, unless if_exists is true.
     /// Returns true if the table existed and was deleted.
     fn drop_table(&amp;self, table: &amp;str, if_exists: bool) -&gt; Result&lt;bool&gt;;
<a href="#h0-2-48" id="h0-2-48" class="d">-    /// Fetches a table schema.
</a><a href="#h0-2-49" id="h0-2-49" class="i">+    /// Fetches a table schema, or None if it doesn&#39;t exist.
</a>     fn get_table(&amp;self, table: &amp;str) -&gt; Result&lt;Option&lt;Table&gt;&gt;;
<a href="#h0-2-51" id="h0-2-51" class="d">-    /// Lists tables.
</a><a href="#h0-2-52" id="h0-2-52" class="i">+    /// Returns a list of all table schemas.
</a>     fn list_tables(&amp;self) -&gt; Result&lt;Vec&lt;Table&gt;&gt;;
 
<a href="#h0-2-55" id="h0-2-55" class="d">-    /// Reads a table, errors if it does not exist.
</a><a href="#h0-2-56" id="h0-2-56" class="i">+    /// Fetches a table schema, or errors if it does not exist.
</a>     fn must_get_table(&amp;self, table: &amp;str) -&gt; Result&lt;Table&gt; {
         self.get_table(table)?.ok_or(errinput!(&quot;table {table} does not exist&quot;))
     }
<a href="#h0-2-60" id="h0-2-60" class="d">-
</a><a href="#h0-2-61" id="h0-2-61" class="d">-    /// Returns all references to a table, as table,column pairs.
</a><a href="#h0-2-62" id="h0-2-62" class="d">-    /// TODO: make this actually be table,column, instead of a column vec.
</a><a href="#h0-2-63" id="h0-2-63" class="d">-    fn references(&amp;self, table: &amp;str, with_self: bool) -&gt; Result&lt;Vec&lt;(String, Vec&lt;String&gt;)&gt;&gt; {
</a><a href="#h0-2-64" id="h0-2-64" class="d">-        Ok(self
</a><a href="#h0-2-65" id="h0-2-65" class="d">-            .list_tables()?
</a><a href="#h0-2-66" id="h0-2-66" class="d">-            .into_iter()
</a><a href="#h0-2-67" id="h0-2-67" class="d">-            .filter(|t| with_self || t.name != table)
</a><a href="#h0-2-68" id="h0-2-68" class="d">-            .map(|t| {
</a><a href="#h0-2-69" id="h0-2-69" class="d">-                (
</a><a href="#h0-2-70" id="h0-2-70" class="d">-                    t.name,
</a><a href="#h0-2-71" id="h0-2-71" class="d">-                    t.columns
</a><a href="#h0-2-72" id="h0-2-72" class="d">-                        .iter()
</a><a href="#h0-2-73" id="h0-2-73" class="d">-                        .filter(|c| c.references.as_deref() == Some(table))
</a><a href="#h0-2-74" id="h0-2-74" class="d">-                        .map(|c| c.name.clone())
</a><a href="#h0-2-75" id="h0-2-75" class="d">-                        .collect::&lt;Vec&lt;_&gt;&gt;(),
</a><a href="#h0-2-76" id="h0-2-76" class="d">-                )
</a><a href="#h0-2-77" id="h0-2-77" class="d">-            })
</a><a href="#h0-2-78" id="h0-2-78" class="d">-            .filter(|(_, cs)| !cs.is_empty())
</a><a href="#h0-2-79" id="h0-2-79" class="d">-            .collect())
</a><a href="#h0-2-80" id="h0-2-80" class="d">-    }
</a> }
<b>diff --git a/<a id="h1" href="../file/src/sql/engine/local.rs.html">src/sql/engine/local.rs</a> b/<a href="../file/src/sql/engine/local.rs.html">src/sql/engine/local.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -99,6 +99,26 @@ impl&lt;E: storage::Engine&gt; Transaction&lt;E&gt; {
</a>             self.txn.set(&amp;key, index.encode())
         }
     }
<a href="#h1-0-3" id="h1-0-3" class="i">+
</a><a href="#h1-0-4" id="h1-0-4" class="i">+    /// Returns all foreign key references to a table, as table -&gt; columns.
</a><a href="#h1-0-5" id="h1-0-5" class="i">+    /// This includes references from the table itself.
</a><a href="#h1-0-6" id="h1-0-6" class="i">+    fn references(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;(String, Vec&lt;String&gt;)&gt;&gt; {
</a><a href="#h1-0-7" id="h1-0-7" class="i">+        Ok(self
</a><a href="#h1-0-8" id="h1-0-8" class="i">+            .list_tables()?
</a><a href="#h1-0-9" id="h1-0-9" class="i">+            .into_iter()
</a><a href="#h1-0-10" id="h1-0-10" class="i">+            .map(|t| {
</a><a href="#h1-0-11" id="h1-0-11" class="i">+                (
</a><a href="#h1-0-12" id="h1-0-12" class="i">+                    t.name,
</a><a href="#h1-0-13" id="h1-0-13" class="i">+                    t.columns
</a><a href="#h1-0-14" id="h1-0-14" class="i">+                        .iter()
</a><a href="#h1-0-15" id="h1-0-15" class="i">+                        .filter(|c| c.references.as_deref() == Some(table))
</a><a href="#h1-0-16" id="h1-0-16" class="i">+                        .map(|c| c.name.clone())
</a><a href="#h1-0-17" id="h1-0-17" class="i">+                        .collect::&lt;Vec&lt;_&gt;&gt;(),
</a><a href="#h1-0-18" id="h1-0-18" class="i">+                )
</a><a href="#h1-0-19" id="h1-0-19" class="i">+            })
</a><a href="#h1-0-20" id="h1-0-20" class="i">+            .filter(|(_, cs)| !cs.is_empty())
</a><a href="#h1-0-21" id="h1-0-21" class="i">+            .collect())
</a><a href="#h1-0-22" id="h1-0-22" class="i">+    }
</a> }
 
 impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
<a href="#h1-1" id="h1-1" class="h">@@ -142,7 +162,7 @@ impl&lt;E: storage::Engine&gt; super::Transaction for Transaction&lt;E&gt; {
</a>         // TODO: try to be more clever than simply iterating over each ID.
         for id in ids {
             let table = self.must_get_table(table)?;
<a href="#h1-1-3" id="h1-1-3" class="d">-            for (t, cs) in self.references(&amp;table.name, true)? {
</a><a href="#h1-1-4" id="h1-1-4" class="i">+            for (t, cs) in self.references(&amp;table.name)? {
</a>                 let t = self.must_get_table(&amp;t)?;
                 let cs = cs
                     .into_iter()
<a href="#h1-2" id="h1-2" class="h">@@ -304,7 +324,8 @@ impl&lt;E: storage::Engine&gt; Catalog for Transaction&lt;E&gt; {
</a>         } else {
             return Ok(false);
         };
<a href="#h1-2-3" id="h1-2-3" class="d">-        if let Some((t, cs)) = self.references(&amp;table.name, false)?.first() {
</a><a href="#h1-2-4" id="h1-2-4" class="i">+        if let Some((t, cs)) = self.references(&amp;table.name)?.iter().find(|(t, _)| *t != table.name)
</a><a href="#h1-2-5" id="h1-2-5" class="i">+        {
</a>             return errinput!(&quot;table {} is referenced by table {} column {}&quot;, table.name, t, cs[0]);
         }
         let mut scan = self.scan(&amp;table.name, None)?;
</pre>
</div>
</body>
</html>
