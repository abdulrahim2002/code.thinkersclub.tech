<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>kv: initial MVCC cleanups - toydb - An SQL engine written in Rust
</title>
<link rel="icon" type="image/png" href="../favicon.png" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed" href="../atom.xml" />
<link rel="alternate" type="application/atom+xml" title="toydb.git Atom Feed (tags)" href="../tags.xml" />
<link rel="stylesheet" type="text/css" href="../style.css" />
</head>
<body>
<table><tr><td><a href="../../"><img src="../logo.png" alt="" width="32" height="32" /></a></td><td><h1>toydb</h1><span class="desc">An SQL engine written in Rust
</span></td></tr><tr class="url"><td></td><td>git clone <a href="https://github.com/erikgrinaker/toydb">https://github.com/erikgrinaker/toydb</a></td></tr><tr><td></td><td>
<a href="../log.html">Log</a> | <a href="../files.html">Files</a> | <a href="../refs.html">Refs</a> | <a href="../file/README.md.html">README</a> | <a href="../file/LICENSE.html">LICENSE</a></td></tr></table>
<hr/>
<div id="content">
<pre><b>commit</b> <a href="../commit/8be59b9489f1bae70ed34f626a4a527ea96c34bb.html">8be59b9489f1bae70ed34f626a4a527ea96c34bb</a>
<b>parent</b> <a href="../commit/dc04ffcecc5df267f84674a8f3dfd16af4cdc721.html">dc04ffcecc5df267f84674a8f3dfd16af4cdc721</a>
<b>Author:</b> Erik Grinaker &lt;<a href="mailto:erik@grinaker.org">erik@grinaker.org</a>&gt;
<b>Date:</b>   Sun, 15 Dec 2019 18:31:29 +0100

kv: initial MVCC cleanups

<b>Diffstat:</b>
<table><tr><td class="M">M</td><td><a href="#h0">src/client.rs</a></td><td> | </td><td class="num">2</td><td><span class="i">+</span><span class="d">-</span></td></tr>
<tr><td class="M">M</td><td><a href="#h1">src/kv/mvcc.rs</a></td><td> | </td><td class="num">64</td><td><span class="i">+++++++++++++++++++++++++++++++++++++++</span><span class="d">-------------------------</span></td></tr>
<tr><td class="M">M</td><td><a href="#h2">src/sql/engine/raft.rs</a></td><td> | </td><td class="num">4</td><td><span class="i">++</span><span class="d">--</span></td></tr>
</table></pre><pre>3 files changed, 42 insertions(+), 28 deletions(-)
<hr/><b>diff --git a/<a id="h0" href="../file/src/client.rs.html">src/client.rs</a> b/<a href="../file/src/client.rs.html">src/client.rs</a></b>
<a href="#h0-0" id="h0-0" class="h">@@ -90,7 +90,7 @@ pub struct ResultSet {
</a>     rows: Box&lt;dyn Iterator&lt;Item = Result&lt;service::Row, grpc::Error&gt;&gt;&gt;,
 }
 
<a href="#h0-0-3" id="h0-0-3" class="d">-#[derive(Clone, Debug, Serialize, Deserialize)]
</a><a href="#h0-0-4" id="h0-0-4" class="i">+#[derive(Clone, Serialize, Deserialize)]
</a> pub enum Effect {
     Begin { id: u64, mode: Mode },
     Commit(u64),
<b>diff --git a/<a id="h1" href="../file/src/kv/mvcc.rs.html">src/kv/mvcc.rs</a> b/<a href="../file/src/kv/mvcc.rs.html">src/kv/mvcc.rs</a></b>
<a href="#h1-0" id="h1-0" class="h">@@ -6,43 +6,53 @@ use std::collections::HashSet;
</a> use std::ops::{Bound, RangeBounds};
 use std::sync::{Arc, RwLock, RwLockReadGuard, RwLockWriteGuard};
 
<a href="#h1-0-3" id="h1-0-3" class="d">-/// An MVCC-based transactional key-value store
</a><a href="#h1-0-4" id="h1-0-4" class="i">+/// An MVCC-based transactional key-value store.
</a> pub struct MVCC&lt;S: Storage&gt; {
<a href="#h1-0-6" id="h1-0-6" class="i">+    /// The storage backend. It is protected by a mutex so it can be shared
</a><a href="#h1-0-7" id="h1-0-7" class="i">+    /// between multiple transactions. FIXME Can we avoid the mutex?
</a>     storage: Arc&lt;RwLock&lt;S&gt;&gt;,
 }
 
 impl&lt;S: Storage&gt; MVCC&lt;S&gt; {
<a href="#h1-0-12" id="h1-0-12" class="d">-    /// Creates a new MVCC key-value store
</a><a href="#h1-0-13" id="h1-0-13" class="i">+    /// Creates a new MVCC key-value store with the given storage backend.
</a>     pub fn new(storage: S) -&gt; Self {
         Self { storage: Arc::new(RwLock::new(storage)) }
     }
 
<a href="#h1-0-18" id="h1-0-18" class="d">-    /// Begins a new transaction in the default mutable mode
</a><a href="#h1-0-19" id="h1-0-19" class="i">+    /// Begins a new transaction in read-write mode.
</a>     #[allow(dead_code)]
     pub fn begin(&amp;self) -&gt; Result&lt;Transaction&lt;S&gt;, Error&gt; {
         Transaction::begin(self.storage.clone(), Mode::ReadWrite)
     }
 
<a href="#h1-0-25" id="h1-0-25" class="d">-    /// Begins a new transaction in the given mode
</a><a href="#h1-0-26" id="h1-0-26" class="i">+    /// Begins a new transaction in the given mode.
</a>     pub fn begin_with_mode(&amp;self, mode: Mode) -&gt; Result&lt;Transaction&lt;S&gt;, Error&gt; {
         Transaction::begin(self.storage.clone(), mode)
     }
 
<a href="#h1-0-31" id="h1-0-31" class="d">-    /// Resumes a transaction
</a><a href="#h1-0-32" id="h1-0-32" class="i">+    /// Resumes a transaction with the given ID.
</a>     pub fn resume(&amp;self, id: u64) -&gt; Result&lt;Transaction&lt;S&gt;, Error&gt; {
         Transaction::resume(self.storage.clone(), id)
     }
 }
 
<a href="#h1-0-38" id="h1-0-38" class="d">-/// An MVCC transaction mode
</a><a href="#h1-0-39" id="h1-0-39" class="d">-#[derive(Clone, Debug, Serialize, Deserialize)]
</a><a href="#h1-0-40" id="h1-0-40" class="i">+/// An MVCC transaction mode.
</a><a href="#h1-0-41" id="h1-0-41" class="i">+#[derive(Clone, Serialize, Deserialize)]
</a> pub enum Mode {
<a href="#h1-0-43" id="h1-0-43" class="i">+    /// A read-write transaction.
</a>     ReadWrite,
<a href="#h1-0-45" id="h1-0-45" class="i">+    /// A read-only transaction.
</a>     ReadOnly,
<a href="#h1-0-47" id="h1-0-47" class="i">+    /// A read-only transaction running in a snapshot of a given version.
</a><a href="#h1-0-48" id="h1-0-48" class="i">+    ///
</a><a href="#h1-0-49" id="h1-0-49" class="i">+    /// The version must refer to a committed transaction ID. Any changes visible to the original
</a><a href="#h1-0-50" id="h1-0-50" class="i">+    /// transaction will be visible in the snapshot (i.e. transactions that had not committed before
</a><a href="#h1-0-51" id="h1-0-51" class="i">+    /// the snapshot transaction started will not be visible, even though they have a lower version).
</a>     Snapshot { version: u64 },
 }
 
 impl Mode {
<a href="#h1-0-56" id="h1-0-56" class="i">+    /// Asserts that the mode can mutate data, otherwise throws `Error::ReadOnly`.
</a>     fn assert_mutable(&amp;self) -&gt; Result&lt;(), Error&gt; {
         if self.is_mutable() {
             Ok(())
<a href="#h1-1" id="h1-1" class="h">@@ -51,6 +61,7 @@ impl Mode {
</a>         }
     }
 
<a href="#h1-1-3" id="h1-1-3" class="i">+    /// Checks whether the transaction mode can mutate data.
</a>     fn is_mutable(&amp;self) -&gt; bool {
         match self {
             Self::ReadWrite =&gt; true,
<a href="#h1-2" id="h1-2" class="h">@@ -60,16 +71,20 @@ impl Mode {
</a>     }
 }
 
<a href="#h1-2-3" id="h1-2-3" class="d">-/// An MVCC transaction
</a><a href="#h1-2-4" id="h1-2-4" class="i">+/// An MVCC transaction.
</a> pub struct Transaction&lt;S: Storage&gt; {
<a href="#h1-2-6" id="h1-2-6" class="i">+    /// The underlying storage for the transaction. Shared between transactions using a mutex.
</a>     storage: Arc&lt;RwLock&lt;S&gt;&gt;,
<a href="#h1-2-8" id="h1-2-8" class="d">-    id: u64,
</a><a href="#h1-2-9" id="h1-2-9" class="d">-    mode: Mode,
</a><a href="#h1-2-10" id="h1-2-10" class="i">+    /// The snapshot that the transaction is running in.
</a>     snapshot: Snapshot,
<a href="#h1-2-12" id="h1-2-12" class="i">+    /// The transaction mode.
</a><a href="#h1-2-13" id="h1-2-13" class="i">+    mode: Mode,
</a><a href="#h1-2-14" id="h1-2-14" class="i">+    /// The unique transaction ID.
</a><a href="#h1-2-15" id="h1-2-15" class="i">+    id: u64,
</a> }
 
 impl&lt;&#39;a, S: Storage&gt; Transaction&lt;S&gt; {
<a href="#h1-2-19" id="h1-2-19" class="d">-    /// Begins a new transaction
</a><a href="#h1-2-20" id="h1-2-20" class="i">+    /// Begins a new transaction in the given mode.
</a>     fn begin(storage: Arc&lt;RwLock&lt;S&gt;&gt;, mode: Mode) -&gt; Result&lt;Self, Error&gt; {
         let id = {
             let mut storage = storage.write()?;
<a href="#h1-3" id="h1-3" class="h">@@ -88,7 +103,8 @@ impl&lt;&#39;a, S: Storage&gt; Transaction&lt;S&gt; {
</a>         Ok(Self { storage, id, mode, snapshot })
     }
 
<a href="#h1-3-3" id="h1-3-3" class="d">-    /// Resumes a transaction
</a><a href="#h1-3-4" id="h1-3-4" class="i">+    /// Resumes an active transaction with the given ID. If no such active transaction exists,
</a><a href="#h1-3-5" id="h1-3-5" class="i">+    /// an error is returned.
</a>     fn resume(storage: Arc&lt;RwLock&lt;S&gt;&gt;, id: u64) -&gt; Result&lt;Self, Error&gt; {
         let key = Key::TxnActive(id).encode();
         let mode = if let Some(v) = storage.read()?.read(&amp;key)? {
<a href="#h1-4" id="h1-4" class="h">@@ -103,12 +119,12 @@ impl&lt;&#39;a, S: Storage&gt; Transaction&lt;S&gt; {
</a>         Ok(Self { storage, id, mode, snapshot })
     }
 
<a href="#h1-4-3" id="h1-4-3" class="d">-    /// Returns the transaction ID
</a><a href="#h1-4-4" id="h1-4-4" class="i">+    /// Returns the transaction ID.
</a>     pub fn id(&amp;self) -&gt; u64 {
         self.id
     }
 
<a href="#h1-4-9" id="h1-4-9" class="d">-    /// Returns the transaction mode
</a><a href="#h1-4-10" id="h1-4-10" class="i">+    /// Returns the transaction mode.
</a>     pub fn mode(&amp;self) -&gt; Mode {
         self.mode.clone()
     }
<a href="#h1-5" id="h1-5" class="h">@@ -180,7 +196,7 @@ impl&lt;&#39;a, S: Storage&gt; Transaction&lt;S&gt; {
</a> 
     /// Scans a key range
     pub fn scan(&amp;self, range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;Range, Error&gt; {
<a href="#h1-5-3" id="h1-5-3" class="d">-        Ok(Box::new(Scan::new(self.storage.clone(), self.snapshot.clone(), range)?))
</a><a href="#h1-5-4" id="h1-5-4" class="i">+        Ok(Box::new(Scan::new(self.storage.read()?, self.snapshot.clone(), range)?))
</a>     }
 
     /// Sets a key
<a href="#h1-6" id="h1-6" class="h">@@ -255,8 +271,8 @@ impl Snapshot {
</a> }
 
 /// A key range scan
<a href="#h1-6-3" id="h1-6-3" class="d">-pub struct Scan&lt;S: Storage&gt; {
</a><a href="#h1-6-4" id="h1-6-4" class="d">-    storage: Arc&lt;RwLock&lt;S&gt;&gt;,
</a><a href="#h1-6-5" id="h1-6-5" class="i">+pub struct Scan&lt;&#39;a, S: Storage&gt; {
</a><a href="#h1-6-6" id="h1-6-6" class="i">+    storage: RwLockReadGuard&lt;&#39;a, S&gt;,
</a>     snapshot: Snapshot,
     mark_front: Bound&lt;Vec&lt;u8&gt;&gt;,
     mark_back: Bound&lt;Vec&lt;u8&gt;&gt;,
<a href="#h1-7" id="h1-7" class="h">@@ -264,9 +280,9 @@ pub struct Scan&lt;S: Storage&gt; {
</a>     rev_ignore: Option&lt;(Vec&lt;u8&gt;)&gt;,
 }
 
<a href="#h1-7-3" id="h1-7-3" class="d">-impl&lt;S: Storage&gt; Scan&lt;S&gt; {
</a><a href="#h1-7-4" id="h1-7-4" class="i">+impl&lt;&#39;a, S: Storage&gt; Scan&lt;&#39;a, S&gt; {
</a>     fn new(
<a href="#h1-7-6" id="h1-7-6" class="d">-        storage: Arc&lt;RwLock&lt;S&gt;&gt;,
</a><a href="#h1-7-7" id="h1-7-7" class="i">+        storage: RwLockReadGuard&lt;&#39;a, S&gt;,
</a>         snapshot: Snapshot,
         range: impl RangeBounds&lt;Vec&lt;u8&gt;&gt;,
     ) -&gt; Result&lt;Self, Error&gt; {
<a href="#h1-8" id="h1-8" class="h">@@ -294,12 +310,11 @@ impl&lt;S: Storage&gt; Scan&lt;S&gt; {
</a>     }
 }
 
<a href="#h1-8-3" id="h1-8-3" class="d">-impl&lt;S: Storage&gt; Iterator for Scan&lt;S&gt; {
</a><a href="#h1-8-4" id="h1-8-4" class="i">+impl&lt;&#39;a, S: Storage&gt; Iterator for Scan&lt;&#39;a, S&gt; {
</a>     type Item = Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;), Error&gt;;
 
     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
<a href="#h1-8-8" id="h1-8-8" class="d">-        let storage = self.storage.read().unwrap();
</a><a href="#h1-8-9" id="h1-8-9" class="d">-        let range = storage.scan((self.mark_front.clone(), self.mark_back.clone()));
</a><a href="#h1-8-10" id="h1-8-10" class="i">+        let range = self.storage.scan((self.mark_front.clone(), self.mark_back.clone()));
</a>         for r in range {
             match r {
                 Ok((k, v)) =&gt; {
<a href="#h1-9" id="h1-9" class="h">@@ -350,10 +365,9 @@ impl&lt;S: Storage&gt; Iterator for Scan&lt;S&gt; {
</a>     }
 }
 
<a href="#h1-9-3" id="h1-9-3" class="d">-impl&lt;S: Storage&gt; DoubleEndedIterator for Scan&lt;S&gt; {
</a><a href="#h1-9-4" id="h1-9-4" class="i">+impl&lt;&#39;a, S: Storage&gt; DoubleEndedIterator for Scan&lt;&#39;a, S&gt; {
</a>     fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
<a href="#h1-9-6" id="h1-9-6" class="d">-        let storage = self.storage.read().unwrap();
</a><a href="#h1-9-7" id="h1-9-7" class="d">-        let mut range = storage.scan((self.mark_front.clone(), self.mark_back.clone()));
</a><a href="#h1-9-8" id="h1-9-8" class="i">+        let mut range = self.storage.scan((self.mark_front.clone(), self.mark_back.clone()));
</a>         while let Some(r) = range.next_back() {
             match r {
                 Ok((k, v)) =&gt; {
<b>diff --git a/<a id="h2" href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a> b/<a href="../file/src/sql/engine/raft.rs.html">src/sql/engine/raft.rs</a></b>
<a href="#h2-0" id="h2-0" class="h">@@ -9,7 +9,7 @@ use crate::utility::{deserialize, serialize};
</a> use crate::Error;
 
 /// A state machine mutation
<a href="#h2-0-3" id="h2-0-3" class="d">-#[derive(Clone, Debug, Serialize, Deserialize)]
</a><a href="#h2-0-4" id="h2-0-4" class="i">+#[derive(Clone, Serialize, Deserialize)]
</a> enum Mutation {
     Begin(Mode),
     Commit(u64),
<a href="#h2-1" id="h2-1" class="h">@@ -24,7 +24,7 @@ enum Mutation {
</a> }
 
 /// A state machine query
<a href="#h2-1-3" id="h2-1-3" class="d">-#[derive(Clone, Debug, Serialize, Deserialize)]
</a><a href="#h2-1-4" id="h2-1-4" class="i">+#[derive(Clone, Serialize, Deserialize)]
</a> enum Query {
     Resume(u64),
 
</pre>
</div>
</body>
</html>
